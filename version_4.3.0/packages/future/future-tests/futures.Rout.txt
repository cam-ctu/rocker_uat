
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:20:24.815] plan(): Setting new future strategy stack:
[13:20:24.816] List of future strategies:
[13:20:24.816] 1. sequential:
[13:20:24.816]    - args: function (..., envir = parent.frame())
[13:20:24.816]    - tweaked: FALSE
[13:20:24.816]    - call: future::plan("sequential")
[13:20:24.829] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[13:20:24.881] plan(): Setting new future strategy stack:
[13:20:24.881] List of future strategies:
[13:20:24.881] 1. sequential:
[13:20:24.881]    - args: function (..., envir = parent.frame())
[13:20:24.881]    - tweaked: FALSE
[13:20:24.881]    - call: plan(strategy)
[13:20:24.893] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[13:20:24.894] getGlobalsAndPackages() ...
[13:20:24.894] Searching for globals...
[13:20:24.896] 
[13:20:24.897] Searching for globals ... DONE
[13:20:24.897] - globals: [0] <none>
[13:20:24.897] getGlobalsAndPackages() ... DONE
[13:20:24.898] run() for ‘Future’ ...
[13:20:24.898] - state: ‘created’
[13:20:24.898] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:24.898] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:24.898] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:24.898]   - Field: ‘label’
[13:20:24.899]   - Field: ‘local’
[13:20:24.899]   - Field: ‘owner’
[13:20:24.899]   - Field: ‘envir’
[13:20:24.899]   - Field: ‘packages’
[13:20:24.899]   - Field: ‘gc’
[13:20:24.899]   - Field: ‘conditions’
[13:20:24.899]   - Field: ‘expr’
[13:20:24.899]   - Field: ‘uuid’
[13:20:24.899]   - Field: ‘seed’
[13:20:24.899]   - Field: ‘version’
[13:20:24.899]   - Field: ‘result’
[13:20:24.900]   - Field: ‘asynchronous’
[13:20:24.900]   - Field: ‘calls’
[13:20:24.900]   - Field: ‘globals’
[13:20:24.900]   - Field: ‘stdout’
[13:20:24.900]   - Field: ‘earlySignal’
[13:20:24.900]   - Field: ‘lazy’
[13:20:24.900]   - Field: ‘state’
[13:20:24.900] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:24.900] - Launch lazy future ...
[13:20:24.901] Packages needed by the future expression (n = 0): <none>
[13:20:24.901] Packages needed by future strategies (n = 0): <none>
[13:20:24.902] {
[13:20:24.902]     {
[13:20:24.902]         {
[13:20:24.902]             ...future.startTime <- base::Sys.time()
[13:20:24.902]             {
[13:20:24.902]                 {
[13:20:24.902]                   {
[13:20:24.902]                     base::local({
[13:20:24.902]                       has_future <- base::requireNamespace("future", 
[13:20:24.902]                         quietly = TRUE)
[13:20:24.902]                       if (has_future) {
[13:20:24.902]                         ns <- base::getNamespace("future")
[13:20:24.902]                         version <- ns[[".package"]][["version"]]
[13:20:24.902]                         if (is.null(version)) 
[13:20:24.902]                           version <- utils::packageVersion("future")
[13:20:24.902]                       }
[13:20:24.902]                       else {
[13:20:24.902]                         version <- NULL
[13:20:24.902]                       }
[13:20:24.902]                       if (!has_future || version < "1.8.0") {
[13:20:24.902]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:24.902]                           "", base::R.version$version.string), 
[13:20:24.902]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:24.902]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:24.902]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:24.902]                             "release", "version")], collapse = " "), 
[13:20:24.902]                           hostname = base::Sys.info()[["nodename"]])
[13:20:24.902]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:24.902]                           info)
[13:20:24.902]                         info <- base::paste(info, collapse = "; ")
[13:20:24.902]                         if (!has_future) {
[13:20:24.902]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:24.902]                             info)
[13:20:24.902]                         }
[13:20:24.902]                         else {
[13:20:24.902]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:24.902]                             info, version)
[13:20:24.902]                         }
[13:20:24.902]                         base::stop(msg)
[13:20:24.902]                       }
[13:20:24.902]                     })
[13:20:24.902]                   }
[13:20:24.902]                   options(future.plan = NULL)
[13:20:24.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:24.902]                 }
[13:20:24.902]                 ...future.workdir <- getwd()
[13:20:24.902]             }
[13:20:24.902]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:24.902]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:24.902]         }
[13:20:24.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:24.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:24.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:24.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:24.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:24.902]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:24.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:24.902]             base::names(...future.oldOptions))
[13:20:24.902]     }
[13:20:24.902]     if (FALSE) {
[13:20:24.902]     }
[13:20:24.902]     else {
[13:20:24.902]         if (TRUE) {
[13:20:24.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:24.902]                 open = "w")
[13:20:24.902]         }
[13:20:24.902]         else {
[13:20:24.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:24.902]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:24.902]         }
[13:20:24.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:24.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:24.902]             base::sink(type = "output", split = FALSE)
[13:20:24.902]             base::close(...future.stdout)
[13:20:24.902]         }, add = TRUE)
[13:20:24.902]     }
[13:20:24.902]     ...future.frame <- base::sys.nframe()
[13:20:24.902]     ...future.conditions <- base::list()
[13:20:24.902]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:24.902]     if (FALSE) {
[13:20:24.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:24.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:24.902]     }
[13:20:24.902]     ...future.result <- base::tryCatch({
[13:20:24.902]         base::withCallingHandlers({
[13:20:24.902]             ...future.value <- base::withVisible(base::local(2))
[13:20:24.902]             future::FutureResult(value = ...future.value$value, 
[13:20:24.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.902]                   ...future.rng), globalenv = if (FALSE) 
[13:20:24.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:24.902]                     ...future.globalenv.names))
[13:20:24.902]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:24.902]         }, condition = base::local({
[13:20:24.902]             c <- base::c
[13:20:24.902]             inherits <- base::inherits
[13:20:24.902]             invokeRestart <- base::invokeRestart
[13:20:24.902]             length <- base::length
[13:20:24.902]             list <- base::list
[13:20:24.902]             seq.int <- base::seq.int
[13:20:24.902]             signalCondition <- base::signalCondition
[13:20:24.902]             sys.calls <- base::sys.calls
[13:20:24.902]             `[[` <- base::`[[`
[13:20:24.902]             `+` <- base::`+`
[13:20:24.902]             `<<-` <- base::`<<-`
[13:20:24.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:24.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:24.902]                   3L)]
[13:20:24.902]             }
[13:20:24.902]             function(cond) {
[13:20:24.902]                 is_error <- inherits(cond, "error")
[13:20:24.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:24.902]                   NULL)
[13:20:24.902]                 if (is_error) {
[13:20:24.902]                   sessionInformation <- function() {
[13:20:24.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:24.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:24.902]                       search = base::search(), system = base::Sys.info())
[13:20:24.902]                   }
[13:20:24.902]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:24.902]                     cond$call), session = sessionInformation(), 
[13:20:24.902]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:24.902]                   signalCondition(cond)
[13:20:24.902]                 }
[13:20:24.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:24.902]                 "immediateCondition"))) {
[13:20:24.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:24.902]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:24.902]                   if (TRUE && !signal) {
[13:20:24.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.902]                     {
[13:20:24.902]                       inherits <- base::inherits
[13:20:24.902]                       invokeRestart <- base::invokeRestart
[13:20:24.902]                       is.null <- base::is.null
[13:20:24.902]                       muffled <- FALSE
[13:20:24.902]                       if (inherits(cond, "message")) {
[13:20:24.902]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.902]                         if (muffled) 
[13:20:24.902]                           invokeRestart("muffleMessage")
[13:20:24.902]                       }
[13:20:24.902]                       else if (inherits(cond, "warning")) {
[13:20:24.902]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.902]                         if (muffled) 
[13:20:24.902]                           invokeRestart("muffleWarning")
[13:20:24.902]                       }
[13:20:24.902]                       else if (inherits(cond, "condition")) {
[13:20:24.902]                         if (!is.null(pattern)) {
[13:20:24.902]                           computeRestarts <- base::computeRestarts
[13:20:24.902]                           grepl <- base::grepl
[13:20:24.902]                           restarts <- computeRestarts(cond)
[13:20:24.902]                           for (restart in restarts) {
[13:20:24.902]                             name <- restart$name
[13:20:24.902]                             if (is.null(name)) 
[13:20:24.902]                               next
[13:20:24.902]                             if (!grepl(pattern, name)) 
[13:20:24.902]                               next
[13:20:24.902]                             invokeRestart(restart)
[13:20:24.902]                             muffled <- TRUE
[13:20:24.902]                             break
[13:20:24.902]                           }
[13:20:24.902]                         }
[13:20:24.902]                       }
[13:20:24.902]                       invisible(muffled)
[13:20:24.902]                     }
[13:20:24.902]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.902]                   }
[13:20:24.902]                 }
[13:20:24.902]                 else {
[13:20:24.902]                   if (TRUE) {
[13:20:24.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.902]                     {
[13:20:24.902]                       inherits <- base::inherits
[13:20:24.902]                       invokeRestart <- base::invokeRestart
[13:20:24.902]                       is.null <- base::is.null
[13:20:24.902]                       muffled <- FALSE
[13:20:24.902]                       if (inherits(cond, "message")) {
[13:20:24.902]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.902]                         if (muffled) 
[13:20:24.902]                           invokeRestart("muffleMessage")
[13:20:24.902]                       }
[13:20:24.902]                       else if (inherits(cond, "warning")) {
[13:20:24.902]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.902]                         if (muffled) 
[13:20:24.902]                           invokeRestart("muffleWarning")
[13:20:24.902]                       }
[13:20:24.902]                       else if (inherits(cond, "condition")) {
[13:20:24.902]                         if (!is.null(pattern)) {
[13:20:24.902]                           computeRestarts <- base::computeRestarts
[13:20:24.902]                           grepl <- base::grepl
[13:20:24.902]                           restarts <- computeRestarts(cond)
[13:20:24.902]                           for (restart in restarts) {
[13:20:24.902]                             name <- restart$name
[13:20:24.902]                             if (is.null(name)) 
[13:20:24.902]                               next
[13:20:24.902]                             if (!grepl(pattern, name)) 
[13:20:24.902]                               next
[13:20:24.902]                             invokeRestart(restart)
[13:20:24.902]                             muffled <- TRUE
[13:20:24.902]                             break
[13:20:24.902]                           }
[13:20:24.902]                         }
[13:20:24.902]                       }
[13:20:24.902]                       invisible(muffled)
[13:20:24.902]                     }
[13:20:24.902]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.902]                   }
[13:20:24.902]                 }
[13:20:24.902]             }
[13:20:24.902]         }))
[13:20:24.902]     }, error = function(ex) {
[13:20:24.902]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:24.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.902]                 ...future.rng), started = ...future.startTime, 
[13:20:24.902]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:24.902]             version = "1.8"), class = "FutureResult")
[13:20:24.902]     }, finally = {
[13:20:24.902]         if (!identical(...future.workdir, getwd())) 
[13:20:24.902]             setwd(...future.workdir)
[13:20:24.902]         {
[13:20:24.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:24.902]                 ...future.oldOptions$nwarnings <- NULL
[13:20:24.902]             }
[13:20:24.902]             base::options(...future.oldOptions)
[13:20:24.902]             if (.Platform$OS.type == "windows") {
[13:20:24.902]                 old_names <- names(...future.oldEnvVars)
[13:20:24.902]                 envs <- base::Sys.getenv()
[13:20:24.902]                 names <- names(envs)
[13:20:24.902]                 common <- intersect(names, old_names)
[13:20:24.902]                 added <- setdiff(names, old_names)
[13:20:24.902]                 removed <- setdiff(old_names, names)
[13:20:24.902]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:24.902]                   envs[common]]
[13:20:24.902]                 NAMES <- toupper(changed)
[13:20:24.902]                 args <- list()
[13:20:24.902]                 for (kk in seq_along(NAMES)) {
[13:20:24.902]                   name <- changed[[kk]]
[13:20:24.902]                   NAME <- NAMES[[kk]]
[13:20:24.902]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.902]                     next
[13:20:24.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.902]                 }
[13:20:24.902]                 NAMES <- toupper(added)
[13:20:24.902]                 for (kk in seq_along(NAMES)) {
[13:20:24.902]                   name <- added[[kk]]
[13:20:24.902]                   NAME <- NAMES[[kk]]
[13:20:24.902]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.902]                     next
[13:20:24.902]                   args[[name]] <- ""
[13:20:24.902]                 }
[13:20:24.902]                 NAMES <- toupper(removed)
[13:20:24.902]                 for (kk in seq_along(NAMES)) {
[13:20:24.902]                   name <- removed[[kk]]
[13:20:24.902]                   NAME <- NAMES[[kk]]
[13:20:24.902]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.902]                     next
[13:20:24.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.902]                 }
[13:20:24.902]                 if (length(args) > 0) 
[13:20:24.902]                   base::do.call(base::Sys.setenv, args = args)
[13:20:24.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:24.902]             }
[13:20:24.902]             else {
[13:20:24.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:24.902]             }
[13:20:24.902]             {
[13:20:24.902]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:24.902]                   0L) {
[13:20:24.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:24.902]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:24.902]                   base::options(opts)
[13:20:24.902]                 }
[13:20:24.902]                 {
[13:20:24.902]                   {
[13:20:24.902]                     NULL
[13:20:24.902]                     RNGkind("Mersenne-Twister")
[13:20:24.902]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:24.902]                       inherits = FALSE)
[13:20:24.902]                   }
[13:20:24.902]                   options(future.plan = NULL)
[13:20:24.902]                   if (is.na(NA_character_)) 
[13:20:24.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:24.902]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:24.902]                   {
[13:20:24.902]                     future <- SequentialFuture(..., envir = envir)
[13:20:24.902]                     if (!future$lazy) 
[13:20:24.902]                       future <- run(future)
[13:20:24.902]                     invisible(future)
[13:20:24.902]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:24.902]                 }
[13:20:24.902]             }
[13:20:24.902]         }
[13:20:24.902]     })
[13:20:24.902]     if (TRUE) {
[13:20:24.902]         base::sink(type = "output", split = FALSE)
[13:20:24.902]         if (TRUE) {
[13:20:24.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:24.902]         }
[13:20:24.902]         else {
[13:20:24.902]             ...future.result["stdout"] <- base::list(NULL)
[13:20:24.902]         }
[13:20:24.902]         base::close(...future.stdout)
[13:20:24.902]         ...future.stdout <- NULL
[13:20:24.902]     }
[13:20:24.902]     ...future.result$conditions <- ...future.conditions
[13:20:24.902]     ...future.result$finished <- base::Sys.time()
[13:20:24.902]     ...future.result
[13:20:24.902] }
[13:20:24.904] plan(): Setting new future strategy stack:
[13:20:24.904] List of future strategies:
[13:20:24.904] 1. sequential:
[13:20:24.904]    - args: function (..., envir = parent.frame())
[13:20:24.904]    - tweaked: FALSE
[13:20:24.904]    - call: NULL
[13:20:24.904] plan(): nbrOfWorkers() = 1
[13:20:24.906] plan(): Setting new future strategy stack:
[13:20:24.906] List of future strategies:
[13:20:24.906] 1. sequential:
[13:20:24.906]    - args: function (..., envir = parent.frame())
[13:20:24.906]    - tweaked: FALSE
[13:20:24.906]    - call: plan(strategy)
[13:20:24.906] plan(): nbrOfWorkers() = 1
[13:20:24.906] SequentialFuture started (and completed)
[13:20:24.907] - Launch lazy future ... done
[13:20:24.907] run() for ‘SequentialFuture’ ... done
[13:20:24.907] getGlobalsAndPackages() ...
[13:20:24.907] Searching for globals...
[13:20:24.907] 
[13:20:24.907] Searching for globals ... DONE
[13:20:24.907] - globals: [0] <none>
[13:20:24.908] getGlobalsAndPackages() ... DONE
[13:20:24.908] run() for ‘Future’ ...
[13:20:24.908] - state: ‘created’
[13:20:24.908] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:24.908] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:24.908] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:24.908]   - Field: ‘label’
[13:20:24.909]   - Field: ‘local’
[13:20:24.909]   - Field: ‘owner’
[13:20:24.909]   - Field: ‘envir’
[13:20:24.909]   - Field: ‘packages’
[13:20:24.909]   - Field: ‘gc’
[13:20:24.909]   - Field: ‘conditions’
[13:20:24.909]   - Field: ‘expr’
[13:20:24.909]   - Field: ‘uuid’
[13:20:24.909]   - Field: ‘seed’
[13:20:24.909]   - Field: ‘version’
[13:20:24.909]   - Field: ‘result’
[13:20:24.910]   - Field: ‘asynchronous’
[13:20:24.910]   - Field: ‘calls’
[13:20:24.910]   - Field: ‘globals’
[13:20:24.910]   - Field: ‘stdout’
[13:20:24.910]   - Field: ‘earlySignal’
[13:20:24.910]   - Field: ‘lazy’
[13:20:24.910]   - Field: ‘state’
[13:20:24.910] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:24.910] - Launch lazy future ...
[13:20:24.910] Packages needed by the future expression (n = 0): <none>
[13:20:24.911] Packages needed by future strategies (n = 0): <none>
[13:20:24.911] {
[13:20:24.911]     {
[13:20:24.911]         {
[13:20:24.911]             ...future.startTime <- base::Sys.time()
[13:20:24.911]             {
[13:20:24.911]                 {
[13:20:24.911]                   {
[13:20:24.911]                     base::local({
[13:20:24.911]                       has_future <- base::requireNamespace("future", 
[13:20:24.911]                         quietly = TRUE)
[13:20:24.911]                       if (has_future) {
[13:20:24.911]                         ns <- base::getNamespace("future")
[13:20:24.911]                         version <- ns[[".package"]][["version"]]
[13:20:24.911]                         if (is.null(version)) 
[13:20:24.911]                           version <- utils::packageVersion("future")
[13:20:24.911]                       }
[13:20:24.911]                       else {
[13:20:24.911]                         version <- NULL
[13:20:24.911]                       }
[13:20:24.911]                       if (!has_future || version < "1.8.0") {
[13:20:24.911]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:24.911]                           "", base::R.version$version.string), 
[13:20:24.911]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:24.911]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:24.911]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:24.911]                             "release", "version")], collapse = " "), 
[13:20:24.911]                           hostname = base::Sys.info()[["nodename"]])
[13:20:24.911]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:24.911]                           info)
[13:20:24.911]                         info <- base::paste(info, collapse = "; ")
[13:20:24.911]                         if (!has_future) {
[13:20:24.911]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:24.911]                             info)
[13:20:24.911]                         }
[13:20:24.911]                         else {
[13:20:24.911]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:24.911]                             info, version)
[13:20:24.911]                         }
[13:20:24.911]                         base::stop(msg)
[13:20:24.911]                       }
[13:20:24.911]                     })
[13:20:24.911]                   }
[13:20:24.911]                   options(future.plan = NULL)
[13:20:24.911]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.911]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:24.911]                 }
[13:20:24.911]                 ...future.workdir <- getwd()
[13:20:24.911]             }
[13:20:24.911]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:24.911]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:24.911]         }
[13:20:24.911]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:24.911]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:24.911]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:24.911]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:24.911]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:24.911]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:24.911]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:24.911]             base::names(...future.oldOptions))
[13:20:24.911]     }
[13:20:24.911]     if (FALSE) {
[13:20:24.911]     }
[13:20:24.911]     else {
[13:20:24.911]         if (TRUE) {
[13:20:24.911]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:24.911]                 open = "w")
[13:20:24.911]         }
[13:20:24.911]         else {
[13:20:24.911]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:24.911]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:24.911]         }
[13:20:24.911]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:24.911]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:24.911]             base::sink(type = "output", split = FALSE)
[13:20:24.911]             base::close(...future.stdout)
[13:20:24.911]         }, add = TRUE)
[13:20:24.911]     }
[13:20:24.911]     ...future.frame <- base::sys.nframe()
[13:20:24.911]     ...future.conditions <- base::list()
[13:20:24.911]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:24.911]     if (FALSE) {
[13:20:24.911]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:24.911]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:24.911]     }
[13:20:24.911]     ...future.result <- base::tryCatch({
[13:20:24.911]         base::withCallingHandlers({
[13:20:24.911]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:24.911]             future::FutureResult(value = ...future.value$value, 
[13:20:24.911]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.911]                   ...future.rng), globalenv = if (FALSE) 
[13:20:24.911]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:24.911]                     ...future.globalenv.names))
[13:20:24.911]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:24.911]         }, condition = base::local({
[13:20:24.911]             c <- base::c
[13:20:24.911]             inherits <- base::inherits
[13:20:24.911]             invokeRestart <- base::invokeRestart
[13:20:24.911]             length <- base::length
[13:20:24.911]             list <- base::list
[13:20:24.911]             seq.int <- base::seq.int
[13:20:24.911]             signalCondition <- base::signalCondition
[13:20:24.911]             sys.calls <- base::sys.calls
[13:20:24.911]             `[[` <- base::`[[`
[13:20:24.911]             `+` <- base::`+`
[13:20:24.911]             `<<-` <- base::`<<-`
[13:20:24.911]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:24.911]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:24.911]                   3L)]
[13:20:24.911]             }
[13:20:24.911]             function(cond) {
[13:20:24.911]                 is_error <- inherits(cond, "error")
[13:20:24.911]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:24.911]                   NULL)
[13:20:24.911]                 if (is_error) {
[13:20:24.911]                   sessionInformation <- function() {
[13:20:24.911]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:24.911]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:24.911]                       search = base::search(), system = base::Sys.info())
[13:20:24.911]                   }
[13:20:24.911]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.911]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:24.911]                     cond$call), session = sessionInformation(), 
[13:20:24.911]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:24.911]                   signalCondition(cond)
[13:20:24.911]                 }
[13:20:24.911]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:24.911]                 "immediateCondition"))) {
[13:20:24.911]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:24.911]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.911]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:24.911]                   if (TRUE && !signal) {
[13:20:24.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.911]                     {
[13:20:24.911]                       inherits <- base::inherits
[13:20:24.911]                       invokeRestart <- base::invokeRestart
[13:20:24.911]                       is.null <- base::is.null
[13:20:24.911]                       muffled <- FALSE
[13:20:24.911]                       if (inherits(cond, "message")) {
[13:20:24.911]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.911]                         if (muffled) 
[13:20:24.911]                           invokeRestart("muffleMessage")
[13:20:24.911]                       }
[13:20:24.911]                       else if (inherits(cond, "warning")) {
[13:20:24.911]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.911]                         if (muffled) 
[13:20:24.911]                           invokeRestart("muffleWarning")
[13:20:24.911]                       }
[13:20:24.911]                       else if (inherits(cond, "condition")) {
[13:20:24.911]                         if (!is.null(pattern)) {
[13:20:24.911]                           computeRestarts <- base::computeRestarts
[13:20:24.911]                           grepl <- base::grepl
[13:20:24.911]                           restarts <- computeRestarts(cond)
[13:20:24.911]                           for (restart in restarts) {
[13:20:24.911]                             name <- restart$name
[13:20:24.911]                             if (is.null(name)) 
[13:20:24.911]                               next
[13:20:24.911]                             if (!grepl(pattern, name)) 
[13:20:24.911]                               next
[13:20:24.911]                             invokeRestart(restart)
[13:20:24.911]                             muffled <- TRUE
[13:20:24.911]                             break
[13:20:24.911]                           }
[13:20:24.911]                         }
[13:20:24.911]                       }
[13:20:24.911]                       invisible(muffled)
[13:20:24.911]                     }
[13:20:24.911]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.911]                   }
[13:20:24.911]                 }
[13:20:24.911]                 else {
[13:20:24.911]                   if (TRUE) {
[13:20:24.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.911]                     {
[13:20:24.911]                       inherits <- base::inherits
[13:20:24.911]                       invokeRestart <- base::invokeRestart
[13:20:24.911]                       is.null <- base::is.null
[13:20:24.911]                       muffled <- FALSE
[13:20:24.911]                       if (inherits(cond, "message")) {
[13:20:24.911]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.911]                         if (muffled) 
[13:20:24.911]                           invokeRestart("muffleMessage")
[13:20:24.911]                       }
[13:20:24.911]                       else if (inherits(cond, "warning")) {
[13:20:24.911]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.911]                         if (muffled) 
[13:20:24.911]                           invokeRestart("muffleWarning")
[13:20:24.911]                       }
[13:20:24.911]                       else if (inherits(cond, "condition")) {
[13:20:24.911]                         if (!is.null(pattern)) {
[13:20:24.911]                           computeRestarts <- base::computeRestarts
[13:20:24.911]                           grepl <- base::grepl
[13:20:24.911]                           restarts <- computeRestarts(cond)
[13:20:24.911]                           for (restart in restarts) {
[13:20:24.911]                             name <- restart$name
[13:20:24.911]                             if (is.null(name)) 
[13:20:24.911]                               next
[13:20:24.911]                             if (!grepl(pattern, name)) 
[13:20:24.911]                               next
[13:20:24.911]                             invokeRestart(restart)
[13:20:24.911]                             muffled <- TRUE
[13:20:24.911]                             break
[13:20:24.911]                           }
[13:20:24.911]                         }
[13:20:24.911]                       }
[13:20:24.911]                       invisible(muffled)
[13:20:24.911]                     }
[13:20:24.911]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.911]                   }
[13:20:24.911]                 }
[13:20:24.911]             }
[13:20:24.911]         }))
[13:20:24.911]     }, error = function(ex) {
[13:20:24.911]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:24.911]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.911]                 ...future.rng), started = ...future.startTime, 
[13:20:24.911]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:24.911]             version = "1.8"), class = "FutureResult")
[13:20:24.911]     }, finally = {
[13:20:24.911]         if (!identical(...future.workdir, getwd())) 
[13:20:24.911]             setwd(...future.workdir)
[13:20:24.911]         {
[13:20:24.911]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:24.911]                 ...future.oldOptions$nwarnings <- NULL
[13:20:24.911]             }
[13:20:24.911]             base::options(...future.oldOptions)
[13:20:24.911]             if (.Platform$OS.type == "windows") {
[13:20:24.911]                 old_names <- names(...future.oldEnvVars)
[13:20:24.911]                 envs <- base::Sys.getenv()
[13:20:24.911]                 names <- names(envs)
[13:20:24.911]                 common <- intersect(names, old_names)
[13:20:24.911]                 added <- setdiff(names, old_names)
[13:20:24.911]                 removed <- setdiff(old_names, names)
[13:20:24.911]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:24.911]                   envs[common]]
[13:20:24.911]                 NAMES <- toupper(changed)
[13:20:24.911]                 args <- list()
[13:20:24.911]                 for (kk in seq_along(NAMES)) {
[13:20:24.911]                   name <- changed[[kk]]
[13:20:24.911]                   NAME <- NAMES[[kk]]
[13:20:24.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.911]                     next
[13:20:24.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.911]                 }
[13:20:24.911]                 NAMES <- toupper(added)
[13:20:24.911]                 for (kk in seq_along(NAMES)) {
[13:20:24.911]                   name <- added[[kk]]
[13:20:24.911]                   NAME <- NAMES[[kk]]
[13:20:24.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.911]                     next
[13:20:24.911]                   args[[name]] <- ""
[13:20:24.911]                 }
[13:20:24.911]                 NAMES <- toupper(removed)
[13:20:24.911]                 for (kk in seq_along(NAMES)) {
[13:20:24.911]                   name <- removed[[kk]]
[13:20:24.911]                   NAME <- NAMES[[kk]]
[13:20:24.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.911]                     next
[13:20:24.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.911]                 }
[13:20:24.911]                 if (length(args) > 0) 
[13:20:24.911]                   base::do.call(base::Sys.setenv, args = args)
[13:20:24.911]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:24.911]             }
[13:20:24.911]             else {
[13:20:24.911]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:24.911]             }
[13:20:24.911]             {
[13:20:24.911]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:24.911]                   0L) {
[13:20:24.911]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:24.911]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:24.911]                   base::options(opts)
[13:20:24.911]                 }
[13:20:24.911]                 {
[13:20:24.911]                   {
[13:20:24.911]                     NULL
[13:20:24.911]                     RNGkind("Mersenne-Twister")
[13:20:24.911]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:24.911]                       inherits = FALSE)
[13:20:24.911]                   }
[13:20:24.911]                   options(future.plan = NULL)
[13:20:24.911]                   if (is.na(NA_character_)) 
[13:20:24.911]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.911]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:24.911]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:24.911]                   {
[13:20:24.911]                     future <- SequentialFuture(..., envir = envir)
[13:20:24.911]                     if (!future$lazy) 
[13:20:24.911]                       future <- run(future)
[13:20:24.911]                     invisible(future)
[13:20:24.911]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:24.911]                 }
[13:20:24.911]             }
[13:20:24.911]         }
[13:20:24.911]     })
[13:20:24.911]     if (TRUE) {
[13:20:24.911]         base::sink(type = "output", split = FALSE)
[13:20:24.911]         if (TRUE) {
[13:20:24.911]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:24.911]         }
[13:20:24.911]         else {
[13:20:24.911]             ...future.result["stdout"] <- base::list(NULL)
[13:20:24.911]         }
[13:20:24.911]         base::close(...future.stdout)
[13:20:24.911]         ...future.stdout <- NULL
[13:20:24.911]     }
[13:20:24.911]     ...future.result$conditions <- ...future.conditions
[13:20:24.911]     ...future.result$finished <- base::Sys.time()
[13:20:24.911]     ...future.result
[13:20:24.911] }
[13:20:24.913] plan(): Setting new future strategy stack:
[13:20:24.913] List of future strategies:
[13:20:24.913] 1. sequential:
[13:20:24.913]    - args: function (..., envir = parent.frame())
[13:20:24.913]    - tweaked: FALSE
[13:20:24.913]    - call: NULL
[13:20:24.913] plan(): nbrOfWorkers() = 1
[13:20:24.914] plan(): Setting new future strategy stack:
[13:20:24.914] List of future strategies:
[13:20:24.914] 1. sequential:
[13:20:24.914]    - args: function (..., envir = parent.frame())
[13:20:24.914]    - tweaked: FALSE
[13:20:24.914]    - call: plan(strategy)
[13:20:24.914] plan(): nbrOfWorkers() = 1
[13:20:24.914] SequentialFuture started (and completed)
[13:20:24.915] - Launch lazy future ... done
[13:20:24.915] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659b976c98> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659bd9f800> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659b976c98> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659bd9f800> 
 $  : NULL
 $  : NULL
 $  : num 6
[13:20:24.923] resolved() for ‘SequentialFuture’ ...
[13:20:24.923] - state: ‘finished’
[13:20:24.923] - run: TRUE
[13:20:24.923] - result: ‘FutureResult’
[13:20:24.923] resolved() for ‘SequentialFuture’ ... done
[13:20:24.923] resolved() for ‘SequentialFuture’ ...
[13:20:24.924] - state: ‘finished’
[13:20:24.924] - run: TRUE
[13:20:24.924] - result: ‘FutureResult’
[13:20:24.924] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:24.925] resolve() on list ...
[13:20:24.925]  recursive: 0
[13:20:24.925]  length: 6
[13:20:24.925]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:24.925] signalConditionsASAP(numeric, pos=1) ...
[13:20:24.926] - nx: 6
[13:20:24.926] - relay: TRUE
[13:20:24.926] - stdout: TRUE
[13:20:24.926] - signal: TRUE
[13:20:24.926] - resignal: FALSE
[13:20:24.926] - force: TRUE
[13:20:24.926] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.926] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.926]  - until=2
[13:20:24.926]  - relaying element #2
[13:20:24.926] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.927] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.927] signalConditionsASAP(NULL, pos=1) ... done
[13:20:24.927]  length: 5 (resolved future 1)
[13:20:24.927] resolved() for ‘SequentialFuture’ ...
[13:20:24.927] - state: ‘finished’
[13:20:24.927] - run: TRUE
[13:20:24.927] - result: ‘FutureResult’
[13:20:24.927] resolved() for ‘SequentialFuture’ ... done
[13:20:24.927] Future #2
[13:20:24.928] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:24.928] - nx: 6
[13:20:24.928] - relay: TRUE
[13:20:24.928] - stdout: TRUE
[13:20:24.928] - signal: TRUE
[13:20:24.928] - resignal: FALSE
[13:20:24.928] - force: TRUE
[13:20:24.928] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.928] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.928]  - until=2
[13:20:24.929]  - relaying element #2
[13:20:24.929] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:24.929] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:24.929] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:24.929]  length: 4 (resolved future 2)
[13:20:24.929] resolved() for ‘SequentialFuture’ ...
[13:20:24.929] - state: ‘finished’
[13:20:24.930] - run: TRUE
[13:20:24.930] - result: ‘FutureResult’
[13:20:24.930] resolved() for ‘SequentialFuture’ ... done
[13:20:24.930] Future #3
[13:20:24.930] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:24.930] - nx: 6
[13:20:24.930] - relay: TRUE
[13:20:24.930] - stdout: TRUE
[13:20:24.930] - signal: TRUE
[13:20:24.930] - resignal: FALSE
[13:20:24.930] - force: TRUE
[13:20:24.931] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:24.931] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:24.931]  - until=3
[13:20:24.931]  - relaying element #3
[13:20:24.931] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.931] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.931] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:24.931]  length: 3 (resolved future 3)
[13:20:24.931] signalConditionsASAP(NULL, pos=4) ...
[13:20:24.931] - nx: 6
[13:20:24.932] - relay: TRUE
[13:20:24.932] - stdout: TRUE
[13:20:24.932] - signal: TRUE
[13:20:24.932] - resignal: FALSE
[13:20:24.932] - force: TRUE
[13:20:24.932] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.932]  - until=5
[13:20:24.932]  - relaying element #5
[13:20:24.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:24.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.932] signalConditionsASAP(NULL, pos=4) ... done
[13:20:24.933]  length: 2 (resolved future 4)
[13:20:24.933] signalConditionsASAP(NULL, pos=5) ...
[13:20:24.933] - nx: 6
[13:20:24.933] - relay: TRUE
[13:20:24.933] - stdout: TRUE
[13:20:24.933] - signal: TRUE
[13:20:24.933] - resignal: FALSE
[13:20:24.933] - force: TRUE
[13:20:24.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:24.933] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.933]  - until=6
[13:20:24.933]  - relaying element #6
[13:20:24.934] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:24.934] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.934] signalConditionsASAP(NULL, pos=5) ... done
[13:20:24.934]  length: 1 (resolved future 5)
[13:20:24.934] signalConditionsASAP(numeric, pos=6) ...
[13:20:24.934] - nx: 6
[13:20:24.934] - relay: TRUE
[13:20:24.934] - stdout: TRUE
[13:20:24.934] - signal: TRUE
[13:20:24.934] - resignal: FALSE
[13:20:24.934] - force: TRUE
[13:20:24.934] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:24.935] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.935]  - until=6
[13:20:24.935] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:24.935] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.935] signalConditionsASAP(numeric, pos=6) ... done
[13:20:24.935]  length: 0 (resolved future 6)
[13:20:24.935] Relaying remaining futures
[13:20:24.935] signalConditionsASAP(NULL, pos=0) ...
[13:20:24.935] - nx: 6
[13:20:24.935] - relay: TRUE
[13:20:24.935] - stdout: TRUE
[13:20:24.935] - signal: TRUE
[13:20:24.936] - resignal: FALSE
[13:20:24.936] - force: TRUE
[13:20:24.936] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:24.936] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:24.936] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:24.936] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.936] signalConditionsASAP(NULL, pos=0) ... done
[13:20:24.936] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[13:20:24.938] getGlobalsAndPackages() ...
[13:20:24.938] Searching for globals...
[13:20:24.939] 
[13:20:24.939] Searching for globals ... DONE
[13:20:24.939] - globals: [0] <none>
[13:20:24.939] getGlobalsAndPackages() ... DONE
[13:20:24.939] run() for ‘Future’ ...
[13:20:24.939] - state: ‘created’
[13:20:24.939] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:24.940] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:24.940] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:24.940]   - Field: ‘label’
[13:20:24.940]   - Field: ‘local’
[13:20:24.940]   - Field: ‘owner’
[13:20:24.940]   - Field: ‘envir’
[13:20:24.940]   - Field: ‘packages’
[13:20:24.940]   - Field: ‘gc’
[13:20:24.941]   - Field: ‘conditions’
[13:20:24.941]   - Field: ‘expr’
[13:20:24.941]   - Field: ‘uuid’
[13:20:24.941]   - Field: ‘seed’
[13:20:24.941]   - Field: ‘version’
[13:20:24.941]   - Field: ‘result’
[13:20:24.941]   - Field: ‘asynchronous’
[13:20:24.941]   - Field: ‘calls’
[13:20:24.941]   - Field: ‘globals’
[13:20:24.941]   - Field: ‘stdout’
[13:20:24.941]   - Field: ‘earlySignal’
[13:20:24.942]   - Field: ‘lazy’
[13:20:24.942]   - Field: ‘state’
[13:20:24.942] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:24.942] - Launch lazy future ...
[13:20:24.942] Packages needed by the future expression (n = 0): <none>
[13:20:24.942] Packages needed by future strategies (n = 0): <none>
[13:20:24.943] {
[13:20:24.943]     {
[13:20:24.943]         {
[13:20:24.943]             ...future.startTime <- base::Sys.time()
[13:20:24.943]             {
[13:20:24.943]                 {
[13:20:24.943]                   {
[13:20:24.943]                     base::local({
[13:20:24.943]                       has_future <- base::requireNamespace("future", 
[13:20:24.943]                         quietly = TRUE)
[13:20:24.943]                       if (has_future) {
[13:20:24.943]                         ns <- base::getNamespace("future")
[13:20:24.943]                         version <- ns[[".package"]][["version"]]
[13:20:24.943]                         if (is.null(version)) 
[13:20:24.943]                           version <- utils::packageVersion("future")
[13:20:24.943]                       }
[13:20:24.943]                       else {
[13:20:24.943]                         version <- NULL
[13:20:24.943]                       }
[13:20:24.943]                       if (!has_future || version < "1.8.0") {
[13:20:24.943]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:24.943]                           "", base::R.version$version.string), 
[13:20:24.943]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:24.943]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:24.943]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:24.943]                             "release", "version")], collapse = " "), 
[13:20:24.943]                           hostname = base::Sys.info()[["nodename"]])
[13:20:24.943]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:24.943]                           info)
[13:20:24.943]                         info <- base::paste(info, collapse = "; ")
[13:20:24.943]                         if (!has_future) {
[13:20:24.943]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:24.943]                             info)
[13:20:24.943]                         }
[13:20:24.943]                         else {
[13:20:24.943]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:24.943]                             info, version)
[13:20:24.943]                         }
[13:20:24.943]                         base::stop(msg)
[13:20:24.943]                       }
[13:20:24.943]                     })
[13:20:24.943]                   }
[13:20:24.943]                   options(future.plan = NULL)
[13:20:24.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:24.943]                 }
[13:20:24.943]                 ...future.workdir <- getwd()
[13:20:24.943]             }
[13:20:24.943]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:24.943]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:24.943]         }
[13:20:24.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:24.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:24.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:24.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:24.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:24.943]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:24.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:24.943]             base::names(...future.oldOptions))
[13:20:24.943]     }
[13:20:24.943]     if (FALSE) {
[13:20:24.943]     }
[13:20:24.943]     else {
[13:20:24.943]         if (TRUE) {
[13:20:24.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:24.943]                 open = "w")
[13:20:24.943]         }
[13:20:24.943]         else {
[13:20:24.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:24.943]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:24.943]         }
[13:20:24.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:24.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:24.943]             base::sink(type = "output", split = FALSE)
[13:20:24.943]             base::close(...future.stdout)
[13:20:24.943]         }, add = TRUE)
[13:20:24.943]     }
[13:20:24.943]     ...future.frame <- base::sys.nframe()
[13:20:24.943]     ...future.conditions <- base::list()
[13:20:24.943]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:24.943]     if (FALSE) {
[13:20:24.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:24.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:24.943]     }
[13:20:24.943]     ...future.result <- base::tryCatch({
[13:20:24.943]         base::withCallingHandlers({
[13:20:24.943]             ...future.value <- base::withVisible(base::local(2))
[13:20:24.943]             future::FutureResult(value = ...future.value$value, 
[13:20:24.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.943]                   ...future.rng), globalenv = if (FALSE) 
[13:20:24.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:24.943]                     ...future.globalenv.names))
[13:20:24.943]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:24.943]         }, condition = base::local({
[13:20:24.943]             c <- base::c
[13:20:24.943]             inherits <- base::inherits
[13:20:24.943]             invokeRestart <- base::invokeRestart
[13:20:24.943]             length <- base::length
[13:20:24.943]             list <- base::list
[13:20:24.943]             seq.int <- base::seq.int
[13:20:24.943]             signalCondition <- base::signalCondition
[13:20:24.943]             sys.calls <- base::sys.calls
[13:20:24.943]             `[[` <- base::`[[`
[13:20:24.943]             `+` <- base::`+`
[13:20:24.943]             `<<-` <- base::`<<-`
[13:20:24.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:24.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:24.943]                   3L)]
[13:20:24.943]             }
[13:20:24.943]             function(cond) {
[13:20:24.943]                 is_error <- inherits(cond, "error")
[13:20:24.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:24.943]                   NULL)
[13:20:24.943]                 if (is_error) {
[13:20:24.943]                   sessionInformation <- function() {
[13:20:24.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:24.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:24.943]                       search = base::search(), system = base::Sys.info())
[13:20:24.943]                   }
[13:20:24.943]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:24.943]                     cond$call), session = sessionInformation(), 
[13:20:24.943]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:24.943]                   signalCondition(cond)
[13:20:24.943]                 }
[13:20:24.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:24.943]                 "immediateCondition"))) {
[13:20:24.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:24.943]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:24.943]                   if (TRUE && !signal) {
[13:20:24.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.943]                     {
[13:20:24.943]                       inherits <- base::inherits
[13:20:24.943]                       invokeRestart <- base::invokeRestart
[13:20:24.943]                       is.null <- base::is.null
[13:20:24.943]                       muffled <- FALSE
[13:20:24.943]                       if (inherits(cond, "message")) {
[13:20:24.943]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.943]                         if (muffled) 
[13:20:24.943]                           invokeRestart("muffleMessage")
[13:20:24.943]                       }
[13:20:24.943]                       else if (inherits(cond, "warning")) {
[13:20:24.943]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.943]                         if (muffled) 
[13:20:24.943]                           invokeRestart("muffleWarning")
[13:20:24.943]                       }
[13:20:24.943]                       else if (inherits(cond, "condition")) {
[13:20:24.943]                         if (!is.null(pattern)) {
[13:20:24.943]                           computeRestarts <- base::computeRestarts
[13:20:24.943]                           grepl <- base::grepl
[13:20:24.943]                           restarts <- computeRestarts(cond)
[13:20:24.943]                           for (restart in restarts) {
[13:20:24.943]                             name <- restart$name
[13:20:24.943]                             if (is.null(name)) 
[13:20:24.943]                               next
[13:20:24.943]                             if (!grepl(pattern, name)) 
[13:20:24.943]                               next
[13:20:24.943]                             invokeRestart(restart)
[13:20:24.943]                             muffled <- TRUE
[13:20:24.943]                             break
[13:20:24.943]                           }
[13:20:24.943]                         }
[13:20:24.943]                       }
[13:20:24.943]                       invisible(muffled)
[13:20:24.943]                     }
[13:20:24.943]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.943]                   }
[13:20:24.943]                 }
[13:20:24.943]                 else {
[13:20:24.943]                   if (TRUE) {
[13:20:24.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.943]                     {
[13:20:24.943]                       inherits <- base::inherits
[13:20:24.943]                       invokeRestart <- base::invokeRestart
[13:20:24.943]                       is.null <- base::is.null
[13:20:24.943]                       muffled <- FALSE
[13:20:24.943]                       if (inherits(cond, "message")) {
[13:20:24.943]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.943]                         if (muffled) 
[13:20:24.943]                           invokeRestart("muffleMessage")
[13:20:24.943]                       }
[13:20:24.943]                       else if (inherits(cond, "warning")) {
[13:20:24.943]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.943]                         if (muffled) 
[13:20:24.943]                           invokeRestart("muffleWarning")
[13:20:24.943]                       }
[13:20:24.943]                       else if (inherits(cond, "condition")) {
[13:20:24.943]                         if (!is.null(pattern)) {
[13:20:24.943]                           computeRestarts <- base::computeRestarts
[13:20:24.943]                           grepl <- base::grepl
[13:20:24.943]                           restarts <- computeRestarts(cond)
[13:20:24.943]                           for (restart in restarts) {
[13:20:24.943]                             name <- restart$name
[13:20:24.943]                             if (is.null(name)) 
[13:20:24.943]                               next
[13:20:24.943]                             if (!grepl(pattern, name)) 
[13:20:24.943]                               next
[13:20:24.943]                             invokeRestart(restart)
[13:20:24.943]                             muffled <- TRUE
[13:20:24.943]                             break
[13:20:24.943]                           }
[13:20:24.943]                         }
[13:20:24.943]                       }
[13:20:24.943]                       invisible(muffled)
[13:20:24.943]                     }
[13:20:24.943]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.943]                   }
[13:20:24.943]                 }
[13:20:24.943]             }
[13:20:24.943]         }))
[13:20:24.943]     }, error = function(ex) {
[13:20:24.943]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:24.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.943]                 ...future.rng), started = ...future.startTime, 
[13:20:24.943]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:24.943]             version = "1.8"), class = "FutureResult")
[13:20:24.943]     }, finally = {
[13:20:24.943]         if (!identical(...future.workdir, getwd())) 
[13:20:24.943]             setwd(...future.workdir)
[13:20:24.943]         {
[13:20:24.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:24.943]                 ...future.oldOptions$nwarnings <- NULL
[13:20:24.943]             }
[13:20:24.943]             base::options(...future.oldOptions)
[13:20:24.943]             if (.Platform$OS.type == "windows") {
[13:20:24.943]                 old_names <- names(...future.oldEnvVars)
[13:20:24.943]                 envs <- base::Sys.getenv()
[13:20:24.943]                 names <- names(envs)
[13:20:24.943]                 common <- intersect(names, old_names)
[13:20:24.943]                 added <- setdiff(names, old_names)
[13:20:24.943]                 removed <- setdiff(old_names, names)
[13:20:24.943]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:24.943]                   envs[common]]
[13:20:24.943]                 NAMES <- toupper(changed)
[13:20:24.943]                 args <- list()
[13:20:24.943]                 for (kk in seq_along(NAMES)) {
[13:20:24.943]                   name <- changed[[kk]]
[13:20:24.943]                   NAME <- NAMES[[kk]]
[13:20:24.943]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.943]                     next
[13:20:24.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.943]                 }
[13:20:24.943]                 NAMES <- toupper(added)
[13:20:24.943]                 for (kk in seq_along(NAMES)) {
[13:20:24.943]                   name <- added[[kk]]
[13:20:24.943]                   NAME <- NAMES[[kk]]
[13:20:24.943]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.943]                     next
[13:20:24.943]                   args[[name]] <- ""
[13:20:24.943]                 }
[13:20:24.943]                 NAMES <- toupper(removed)
[13:20:24.943]                 for (kk in seq_along(NAMES)) {
[13:20:24.943]                   name <- removed[[kk]]
[13:20:24.943]                   NAME <- NAMES[[kk]]
[13:20:24.943]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.943]                     next
[13:20:24.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.943]                 }
[13:20:24.943]                 if (length(args) > 0) 
[13:20:24.943]                   base::do.call(base::Sys.setenv, args = args)
[13:20:24.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:24.943]             }
[13:20:24.943]             else {
[13:20:24.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:24.943]             }
[13:20:24.943]             {
[13:20:24.943]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:24.943]                   0L) {
[13:20:24.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:24.943]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:24.943]                   base::options(opts)
[13:20:24.943]                 }
[13:20:24.943]                 {
[13:20:24.943]                   {
[13:20:24.943]                     NULL
[13:20:24.943]                     RNGkind("Mersenne-Twister")
[13:20:24.943]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:24.943]                       inherits = FALSE)
[13:20:24.943]                   }
[13:20:24.943]                   options(future.plan = NULL)
[13:20:24.943]                   if (is.na(NA_character_)) 
[13:20:24.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:24.943]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:24.943]                   {
[13:20:24.943]                     future <- SequentialFuture(..., envir = envir)
[13:20:24.943]                     if (!future$lazy) 
[13:20:24.943]                       future <- run(future)
[13:20:24.943]                     invisible(future)
[13:20:24.943]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:24.943]                 }
[13:20:24.943]             }
[13:20:24.943]         }
[13:20:24.943]     })
[13:20:24.943]     if (TRUE) {
[13:20:24.943]         base::sink(type = "output", split = FALSE)
[13:20:24.943]         if (TRUE) {
[13:20:24.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:24.943]         }
[13:20:24.943]         else {
[13:20:24.943]             ...future.result["stdout"] <- base::list(NULL)
[13:20:24.943]         }
[13:20:24.943]         base::close(...future.stdout)
[13:20:24.943]         ...future.stdout <- NULL
[13:20:24.943]     }
[13:20:24.943]     ...future.result$conditions <- ...future.conditions
[13:20:24.943]     ...future.result$finished <- base::Sys.time()
[13:20:24.943]     ...future.result
[13:20:24.943] }
[13:20:24.944] plan(): Setting new future strategy stack:
[13:20:24.944] List of future strategies:
[13:20:24.944] 1. sequential:
[13:20:24.944]    - args: function (..., envir = parent.frame())
[13:20:24.944]    - tweaked: FALSE
[13:20:24.944]    - call: NULL
[13:20:24.945] plan(): nbrOfWorkers() = 1
[13:20:24.945] plan(): Setting new future strategy stack:
[13:20:24.946] List of future strategies:
[13:20:24.946] 1. sequential:
[13:20:24.946]    - args: function (..., envir = parent.frame())
[13:20:24.946]    - tweaked: FALSE
[13:20:24.946]    - call: plan(strategy)
[13:20:24.946] plan(): nbrOfWorkers() = 1
[13:20:24.946] SequentialFuture started (and completed)
[13:20:24.946] - Launch lazy future ... done
[13:20:24.946] run() for ‘SequentialFuture’ ... done
[13:20:24.946] getGlobalsAndPackages() ...
[13:20:24.947] Searching for globals...
[13:20:24.947] 
[13:20:24.947] Searching for globals ... DONE
[13:20:24.947] - globals: [0] <none>
[13:20:24.947] getGlobalsAndPackages() ... DONE
[13:20:24.947] run() for ‘Future’ ...
[13:20:24.947] - state: ‘created’
[13:20:24.947] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:24.948] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:24.948] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:24.948]   - Field: ‘label’
[13:20:24.948]   - Field: ‘local’
[13:20:24.948]   - Field: ‘owner’
[13:20:24.950]   - Field: ‘envir’
[13:20:24.950]   - Field: ‘packages’
[13:20:24.950]   - Field: ‘gc’
[13:20:24.950]   - Field: ‘conditions’
[13:20:24.950]   - Field: ‘expr’
[13:20:24.950]   - Field: ‘uuid’
[13:20:24.950]   - Field: ‘seed’
[13:20:24.950]   - Field: ‘version’
[13:20:24.950]   - Field: ‘result’
[13:20:24.951]   - Field: ‘asynchronous’
[13:20:24.951]   - Field: ‘calls’
[13:20:24.951]   - Field: ‘globals’
[13:20:24.951]   - Field: ‘stdout’
[13:20:24.951]   - Field: ‘earlySignal’
[13:20:24.951]   - Field: ‘lazy’
[13:20:24.951]   - Field: ‘state’
[13:20:24.951] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:24.951] - Launch lazy future ...
[13:20:24.951] Packages needed by the future expression (n = 0): <none>
[13:20:24.952] Packages needed by future strategies (n = 0): <none>
[13:20:24.952] {
[13:20:24.952]     {
[13:20:24.952]         {
[13:20:24.952]             ...future.startTime <- base::Sys.time()
[13:20:24.952]             {
[13:20:24.952]                 {
[13:20:24.952]                   {
[13:20:24.952]                     base::local({
[13:20:24.952]                       has_future <- base::requireNamespace("future", 
[13:20:24.952]                         quietly = TRUE)
[13:20:24.952]                       if (has_future) {
[13:20:24.952]                         ns <- base::getNamespace("future")
[13:20:24.952]                         version <- ns[[".package"]][["version"]]
[13:20:24.952]                         if (is.null(version)) 
[13:20:24.952]                           version <- utils::packageVersion("future")
[13:20:24.952]                       }
[13:20:24.952]                       else {
[13:20:24.952]                         version <- NULL
[13:20:24.952]                       }
[13:20:24.952]                       if (!has_future || version < "1.8.0") {
[13:20:24.952]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:24.952]                           "", base::R.version$version.string), 
[13:20:24.952]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:24.952]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:24.952]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:24.952]                             "release", "version")], collapse = " "), 
[13:20:24.952]                           hostname = base::Sys.info()[["nodename"]])
[13:20:24.952]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:24.952]                           info)
[13:20:24.952]                         info <- base::paste(info, collapse = "; ")
[13:20:24.952]                         if (!has_future) {
[13:20:24.952]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:24.952]                             info)
[13:20:24.952]                         }
[13:20:24.952]                         else {
[13:20:24.952]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:24.952]                             info, version)
[13:20:24.952]                         }
[13:20:24.952]                         base::stop(msg)
[13:20:24.952]                       }
[13:20:24.952]                     })
[13:20:24.952]                   }
[13:20:24.952]                   options(future.plan = NULL)
[13:20:24.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:24.952]                 }
[13:20:24.952]                 ...future.workdir <- getwd()
[13:20:24.952]             }
[13:20:24.952]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:24.952]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:24.952]         }
[13:20:24.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:24.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:24.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:24.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:24.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:24.952]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:24.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:24.952]             base::names(...future.oldOptions))
[13:20:24.952]     }
[13:20:24.952]     if (FALSE) {
[13:20:24.952]     }
[13:20:24.952]     else {
[13:20:24.952]         if (TRUE) {
[13:20:24.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:24.952]                 open = "w")
[13:20:24.952]         }
[13:20:24.952]         else {
[13:20:24.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:24.952]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:24.952]         }
[13:20:24.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:24.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:24.952]             base::sink(type = "output", split = FALSE)
[13:20:24.952]             base::close(...future.stdout)
[13:20:24.952]         }, add = TRUE)
[13:20:24.952]     }
[13:20:24.952]     ...future.frame <- base::sys.nframe()
[13:20:24.952]     ...future.conditions <- base::list()
[13:20:24.952]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:24.952]     if (FALSE) {
[13:20:24.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:24.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:24.952]     }
[13:20:24.952]     ...future.result <- base::tryCatch({
[13:20:24.952]         base::withCallingHandlers({
[13:20:24.952]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:24.952]             future::FutureResult(value = ...future.value$value, 
[13:20:24.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.952]                   ...future.rng), globalenv = if (FALSE) 
[13:20:24.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:24.952]                     ...future.globalenv.names))
[13:20:24.952]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:24.952]         }, condition = base::local({
[13:20:24.952]             c <- base::c
[13:20:24.952]             inherits <- base::inherits
[13:20:24.952]             invokeRestart <- base::invokeRestart
[13:20:24.952]             length <- base::length
[13:20:24.952]             list <- base::list
[13:20:24.952]             seq.int <- base::seq.int
[13:20:24.952]             signalCondition <- base::signalCondition
[13:20:24.952]             sys.calls <- base::sys.calls
[13:20:24.952]             `[[` <- base::`[[`
[13:20:24.952]             `+` <- base::`+`
[13:20:24.952]             `<<-` <- base::`<<-`
[13:20:24.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:24.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:24.952]                   3L)]
[13:20:24.952]             }
[13:20:24.952]             function(cond) {
[13:20:24.952]                 is_error <- inherits(cond, "error")
[13:20:24.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:24.952]                   NULL)
[13:20:24.952]                 if (is_error) {
[13:20:24.952]                   sessionInformation <- function() {
[13:20:24.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:24.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:24.952]                       search = base::search(), system = base::Sys.info())
[13:20:24.952]                   }
[13:20:24.952]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:24.952]                     cond$call), session = sessionInformation(), 
[13:20:24.952]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:24.952]                   signalCondition(cond)
[13:20:24.952]                 }
[13:20:24.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:24.952]                 "immediateCondition"))) {
[13:20:24.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:24.952]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:24.952]                   if (TRUE && !signal) {
[13:20:24.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.952]                     {
[13:20:24.952]                       inherits <- base::inherits
[13:20:24.952]                       invokeRestart <- base::invokeRestart
[13:20:24.952]                       is.null <- base::is.null
[13:20:24.952]                       muffled <- FALSE
[13:20:24.952]                       if (inherits(cond, "message")) {
[13:20:24.952]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.952]                         if (muffled) 
[13:20:24.952]                           invokeRestart("muffleMessage")
[13:20:24.952]                       }
[13:20:24.952]                       else if (inherits(cond, "warning")) {
[13:20:24.952]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.952]                         if (muffled) 
[13:20:24.952]                           invokeRestart("muffleWarning")
[13:20:24.952]                       }
[13:20:24.952]                       else if (inherits(cond, "condition")) {
[13:20:24.952]                         if (!is.null(pattern)) {
[13:20:24.952]                           computeRestarts <- base::computeRestarts
[13:20:24.952]                           grepl <- base::grepl
[13:20:24.952]                           restarts <- computeRestarts(cond)
[13:20:24.952]                           for (restart in restarts) {
[13:20:24.952]                             name <- restart$name
[13:20:24.952]                             if (is.null(name)) 
[13:20:24.952]                               next
[13:20:24.952]                             if (!grepl(pattern, name)) 
[13:20:24.952]                               next
[13:20:24.952]                             invokeRestart(restart)
[13:20:24.952]                             muffled <- TRUE
[13:20:24.952]                             break
[13:20:24.952]                           }
[13:20:24.952]                         }
[13:20:24.952]                       }
[13:20:24.952]                       invisible(muffled)
[13:20:24.952]                     }
[13:20:24.952]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.952]                   }
[13:20:24.952]                 }
[13:20:24.952]                 else {
[13:20:24.952]                   if (TRUE) {
[13:20:24.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.952]                     {
[13:20:24.952]                       inherits <- base::inherits
[13:20:24.952]                       invokeRestart <- base::invokeRestart
[13:20:24.952]                       is.null <- base::is.null
[13:20:24.952]                       muffled <- FALSE
[13:20:24.952]                       if (inherits(cond, "message")) {
[13:20:24.952]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.952]                         if (muffled) 
[13:20:24.952]                           invokeRestart("muffleMessage")
[13:20:24.952]                       }
[13:20:24.952]                       else if (inherits(cond, "warning")) {
[13:20:24.952]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.952]                         if (muffled) 
[13:20:24.952]                           invokeRestart("muffleWarning")
[13:20:24.952]                       }
[13:20:24.952]                       else if (inherits(cond, "condition")) {
[13:20:24.952]                         if (!is.null(pattern)) {
[13:20:24.952]                           computeRestarts <- base::computeRestarts
[13:20:24.952]                           grepl <- base::grepl
[13:20:24.952]                           restarts <- computeRestarts(cond)
[13:20:24.952]                           for (restart in restarts) {
[13:20:24.952]                             name <- restart$name
[13:20:24.952]                             if (is.null(name)) 
[13:20:24.952]                               next
[13:20:24.952]                             if (!grepl(pattern, name)) 
[13:20:24.952]                               next
[13:20:24.952]                             invokeRestart(restart)
[13:20:24.952]                             muffled <- TRUE
[13:20:24.952]                             break
[13:20:24.952]                           }
[13:20:24.952]                         }
[13:20:24.952]                       }
[13:20:24.952]                       invisible(muffled)
[13:20:24.952]                     }
[13:20:24.952]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.952]                   }
[13:20:24.952]                 }
[13:20:24.952]             }
[13:20:24.952]         }))
[13:20:24.952]     }, error = function(ex) {
[13:20:24.952]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:24.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.952]                 ...future.rng), started = ...future.startTime, 
[13:20:24.952]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:24.952]             version = "1.8"), class = "FutureResult")
[13:20:24.952]     }, finally = {
[13:20:24.952]         if (!identical(...future.workdir, getwd())) 
[13:20:24.952]             setwd(...future.workdir)
[13:20:24.952]         {
[13:20:24.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:24.952]                 ...future.oldOptions$nwarnings <- NULL
[13:20:24.952]             }
[13:20:24.952]             base::options(...future.oldOptions)
[13:20:24.952]             if (.Platform$OS.type == "windows") {
[13:20:24.952]                 old_names <- names(...future.oldEnvVars)
[13:20:24.952]                 envs <- base::Sys.getenv()
[13:20:24.952]                 names <- names(envs)
[13:20:24.952]                 common <- intersect(names, old_names)
[13:20:24.952]                 added <- setdiff(names, old_names)
[13:20:24.952]                 removed <- setdiff(old_names, names)
[13:20:24.952]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:24.952]                   envs[common]]
[13:20:24.952]                 NAMES <- toupper(changed)
[13:20:24.952]                 args <- list()
[13:20:24.952]                 for (kk in seq_along(NAMES)) {
[13:20:24.952]                   name <- changed[[kk]]
[13:20:24.952]                   NAME <- NAMES[[kk]]
[13:20:24.952]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.952]                     next
[13:20:24.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.952]                 }
[13:20:24.952]                 NAMES <- toupper(added)
[13:20:24.952]                 for (kk in seq_along(NAMES)) {
[13:20:24.952]                   name <- added[[kk]]
[13:20:24.952]                   NAME <- NAMES[[kk]]
[13:20:24.952]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.952]                     next
[13:20:24.952]                   args[[name]] <- ""
[13:20:24.952]                 }
[13:20:24.952]                 NAMES <- toupper(removed)
[13:20:24.952]                 for (kk in seq_along(NAMES)) {
[13:20:24.952]                   name <- removed[[kk]]
[13:20:24.952]                   NAME <- NAMES[[kk]]
[13:20:24.952]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.952]                     next
[13:20:24.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.952]                 }
[13:20:24.952]                 if (length(args) > 0) 
[13:20:24.952]                   base::do.call(base::Sys.setenv, args = args)
[13:20:24.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:24.952]             }
[13:20:24.952]             else {
[13:20:24.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:24.952]             }
[13:20:24.952]             {
[13:20:24.952]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:24.952]                   0L) {
[13:20:24.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:24.952]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:24.952]                   base::options(opts)
[13:20:24.952]                 }
[13:20:24.952]                 {
[13:20:24.952]                   {
[13:20:24.952]                     NULL
[13:20:24.952]                     RNGkind("Mersenne-Twister")
[13:20:24.952]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:24.952]                       inherits = FALSE)
[13:20:24.952]                   }
[13:20:24.952]                   options(future.plan = NULL)
[13:20:24.952]                   if (is.na(NA_character_)) 
[13:20:24.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:24.952]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:24.952]                   {
[13:20:24.952]                     future <- SequentialFuture(..., envir = envir)
[13:20:24.952]                     if (!future$lazy) 
[13:20:24.952]                       future <- run(future)
[13:20:24.952]                     invisible(future)
[13:20:24.952]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:24.952]                 }
[13:20:24.952]             }
[13:20:24.952]         }
[13:20:24.952]     })
[13:20:24.952]     if (TRUE) {
[13:20:24.952]         base::sink(type = "output", split = FALSE)
[13:20:24.952]         if (TRUE) {
[13:20:24.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:24.952]         }
[13:20:24.952]         else {
[13:20:24.952]             ...future.result["stdout"] <- base::list(NULL)
[13:20:24.952]         }
[13:20:24.952]         base::close(...future.stdout)
[13:20:24.952]         ...future.stdout <- NULL
[13:20:24.952]     }
[13:20:24.952]     ...future.result$conditions <- ...future.conditions
[13:20:24.952]     ...future.result$finished <- base::Sys.time()
[13:20:24.952]     ...future.result
[13:20:24.952] }
[13:20:24.954] plan(): Setting new future strategy stack:
[13:20:24.954] List of future strategies:
[13:20:24.954] 1. sequential:
[13:20:24.954]    - args: function (..., envir = parent.frame())
[13:20:24.954]    - tweaked: FALSE
[13:20:24.954]    - call: NULL
[13:20:24.954] plan(): nbrOfWorkers() = 1
[13:20:24.955] plan(): Setting new future strategy stack:
[13:20:24.955] List of future strategies:
[13:20:24.955] 1. sequential:
[13:20:24.955]    - args: function (..., envir = parent.frame())
[13:20:24.955]    - tweaked: FALSE
[13:20:24.955]    - call: plan(strategy)
[13:20:24.955] plan(): nbrOfWorkers() = 1
[13:20:24.956] SequentialFuture started (and completed)
[13:20:24.956] - Launch lazy future ... done
[13:20:24.956] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659bd5a948> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659c1ba5b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659bd5a948> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659c1ba5b0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:20:24.961] resolved() for ‘SequentialFuture’ ...
[13:20:24.961] - state: ‘finished’
[13:20:24.961] - run: TRUE
[13:20:24.961] - result: ‘FutureResult’
[13:20:24.961] resolved() for ‘SequentialFuture’ ... done
[13:20:24.961] resolved() for ‘SequentialFuture’ ...
[13:20:24.961] - state: ‘finished’
[13:20:24.961] - run: TRUE
[13:20:24.961] - result: ‘FutureResult’
[13:20:24.961] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:24.963] resolve() on list ...
[13:20:24.963]  recursive: 0
[13:20:24.963]  length: 6
[13:20:24.964]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:24.964] signalConditionsASAP(numeric, pos=1) ...
[13:20:24.964] - nx: 6
[13:20:24.964] - relay: TRUE
[13:20:24.964] - stdout: TRUE
[13:20:24.964] - signal: TRUE
[13:20:24.964] - resignal: FALSE
[13:20:24.964] - force: TRUE
[13:20:24.964] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.964] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.964]  - until=2
[13:20:24.965]  - relaying element #2
[13:20:24.965] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.965] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.965] signalConditionsASAP(NULL, pos=1) ... done
[13:20:24.965]  length: 5 (resolved future 1)
[13:20:24.965] resolved() for ‘SequentialFuture’ ...
[13:20:24.965] - state: ‘finished’
[13:20:24.965] - run: TRUE
[13:20:24.965] - result: ‘FutureResult’
[13:20:24.965] resolved() for ‘SequentialFuture’ ... done
[13:20:24.965] Future #2
[13:20:24.966] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:24.966] - nx: 6
[13:20:24.966] - relay: TRUE
[13:20:24.966] - stdout: TRUE
[13:20:24.966] - signal: TRUE
[13:20:24.966] - resignal: FALSE
[13:20:24.966] - force: TRUE
[13:20:24.966] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.966] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:24.966]  - until=2
[13:20:24.966]  - relaying element #2
[13:20:24.967] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:24.967] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:24.967] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:24.967]  length: 4 (resolved future 2)
[13:20:24.967] resolved() for ‘SequentialFuture’ ...
[13:20:24.967] - state: ‘finished’
[13:20:24.967] - run: TRUE
[13:20:24.967] - result: ‘FutureResult’
[13:20:24.967] resolved() for ‘SequentialFuture’ ... done
[13:20:24.968] Future #3
[13:20:24.968] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:24.968] - nx: 6
[13:20:24.968] - relay: TRUE
[13:20:24.968] - stdout: TRUE
[13:20:24.968] - signal: TRUE
[13:20:24.968] - resignal: FALSE
[13:20:24.968] - force: TRUE
[13:20:24.968] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:24.968] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:24.968]  - until=3
[13:20:24.969]  - relaying element #3
[13:20:24.969] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.969] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.969] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:24.969]  length: 3 (resolved future 3)
[13:20:24.969] signalConditionsASAP(NULL, pos=4) ...
[13:20:24.969] - nx: 6
[13:20:24.969] - relay: TRUE
[13:20:24.969] - stdout: TRUE
[13:20:24.969] - signal: TRUE
[13:20:24.969] - resignal: FALSE
[13:20:24.970] - force: TRUE
[13:20:24.970] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.970] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.970]  - until=5
[13:20:24.970]  - relaying element #5
[13:20:24.970] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:24.970] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.970] signalConditionsASAP(NULL, pos=4) ... done
[13:20:24.970]  length: 2 (resolved future 4)
[13:20:24.970] signalConditionsASAP(NULL, pos=5) ...
[13:20:24.970] - nx: 6
[13:20:24.970] - relay: TRUE
[13:20:24.971] - stdout: TRUE
[13:20:24.971] - signal: TRUE
[13:20:24.971] - resignal: FALSE
[13:20:24.971] - force: TRUE
[13:20:24.971] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:24.971] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.971]  - until=6
[13:20:24.971]  - relaying element #6
[13:20:24.971] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:24.971] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.971] signalConditionsASAP(NULL, pos=5) ... done
[13:20:24.971]  length: 1 (resolved future 5)
[13:20:24.972] signalConditionsASAP(numeric, pos=6) ...
[13:20:24.972] - nx: 6
[13:20:24.972] - relay: TRUE
[13:20:24.972] - stdout: TRUE
[13:20:24.972] - signal: TRUE
[13:20:24.972] - resignal: FALSE
[13:20:24.972] - force: TRUE
[13:20:24.972] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:24.972] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.972]  - until=6
[13:20:24.972] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:24.972] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.973] signalConditionsASAP(numeric, pos=6) ... done
[13:20:24.973]  length: 0 (resolved future 6)
[13:20:24.973] Relaying remaining futures
[13:20:24.973] signalConditionsASAP(NULL, pos=0) ...
[13:20:24.973] - nx: 6
[13:20:24.973] - relay: TRUE
[13:20:24.973] - stdout: TRUE
[13:20:24.973] - signal: TRUE
[13:20:24.973] - resignal: FALSE
[13:20:24.973] - force: TRUE
[13:20:24.973] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:24.973] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:24.974] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:24.974] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:24.974] signalConditionsASAP(NULL, pos=0) ... done
[13:20:24.974] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:20:24.978] getGlobalsAndPackages() ...
[13:20:24.978] Searching for globals...
[13:20:24.979] 
[13:20:24.979] Searching for globals ... DONE
[13:20:24.979] - globals: [0] <none>
[13:20:24.979] getGlobalsAndPackages() ... DONE
[13:20:24.979] run() for ‘Future’ ...
[13:20:24.979] - state: ‘created’
[13:20:24.980] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:24.980] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:24.980] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:24.980]   - Field: ‘label’
[13:20:24.980]   - Field: ‘local’
[13:20:24.980]   - Field: ‘owner’
[13:20:24.980]   - Field: ‘envir’
[13:20:24.980]   - Field: ‘packages’
[13:20:24.980]   - Field: ‘gc’
[13:20:24.981]   - Field: ‘conditions’
[13:20:24.981]   - Field: ‘expr’
[13:20:24.981]   - Field: ‘uuid’
[13:20:24.981]   - Field: ‘seed’
[13:20:24.981]   - Field: ‘version’
[13:20:24.981]   - Field: ‘result’
[13:20:24.981]   - Field: ‘asynchronous’
[13:20:24.981]   - Field: ‘calls’
[13:20:24.981]   - Field: ‘globals’
[13:20:24.981]   - Field: ‘stdout’
[13:20:24.982]   - Field: ‘earlySignal’
[13:20:24.982]   - Field: ‘lazy’
[13:20:24.982]   - Field: ‘state’
[13:20:24.982] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:24.982] - Launch lazy future ...
[13:20:24.982] Packages needed by the future expression (n = 0): <none>
[13:20:24.982] Packages needed by future strategies (n = 0): <none>
[13:20:24.983] {
[13:20:24.983]     {
[13:20:24.983]         {
[13:20:24.983]             ...future.startTime <- base::Sys.time()
[13:20:24.983]             {
[13:20:24.983]                 {
[13:20:24.983]                   {
[13:20:24.983]                     base::local({
[13:20:24.983]                       has_future <- base::requireNamespace("future", 
[13:20:24.983]                         quietly = TRUE)
[13:20:24.983]                       if (has_future) {
[13:20:24.983]                         ns <- base::getNamespace("future")
[13:20:24.983]                         version <- ns[[".package"]][["version"]]
[13:20:24.983]                         if (is.null(version)) 
[13:20:24.983]                           version <- utils::packageVersion("future")
[13:20:24.983]                       }
[13:20:24.983]                       else {
[13:20:24.983]                         version <- NULL
[13:20:24.983]                       }
[13:20:24.983]                       if (!has_future || version < "1.8.0") {
[13:20:24.983]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:24.983]                           "", base::R.version$version.string), 
[13:20:24.983]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:24.983]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:24.983]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:24.983]                             "release", "version")], collapse = " "), 
[13:20:24.983]                           hostname = base::Sys.info()[["nodename"]])
[13:20:24.983]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:24.983]                           info)
[13:20:24.983]                         info <- base::paste(info, collapse = "; ")
[13:20:24.983]                         if (!has_future) {
[13:20:24.983]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:24.983]                             info)
[13:20:24.983]                         }
[13:20:24.983]                         else {
[13:20:24.983]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:24.983]                             info, version)
[13:20:24.983]                         }
[13:20:24.983]                         base::stop(msg)
[13:20:24.983]                       }
[13:20:24.983]                     })
[13:20:24.983]                   }
[13:20:24.983]                   options(future.plan = NULL)
[13:20:24.983]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.983]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:24.983]                 }
[13:20:24.983]                 ...future.workdir <- getwd()
[13:20:24.983]             }
[13:20:24.983]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:24.983]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:24.983]         }
[13:20:24.983]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:24.983]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:24.983]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:24.983]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:24.983]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:24.983]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:24.983]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:24.983]             base::names(...future.oldOptions))
[13:20:24.983]     }
[13:20:24.983]     if (FALSE) {
[13:20:24.983]     }
[13:20:24.983]     else {
[13:20:24.983]         if (TRUE) {
[13:20:24.983]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:24.983]                 open = "w")
[13:20:24.983]         }
[13:20:24.983]         else {
[13:20:24.983]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:24.983]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:24.983]         }
[13:20:24.983]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:24.983]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:24.983]             base::sink(type = "output", split = FALSE)
[13:20:24.983]             base::close(...future.stdout)
[13:20:24.983]         }, add = TRUE)
[13:20:24.983]     }
[13:20:24.983]     ...future.frame <- base::sys.nframe()
[13:20:24.983]     ...future.conditions <- base::list()
[13:20:24.983]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:24.983]     if (FALSE) {
[13:20:24.983]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:24.983]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:24.983]     }
[13:20:24.983]     ...future.result <- base::tryCatch({
[13:20:24.983]         base::withCallingHandlers({
[13:20:24.983]             ...future.value <- base::withVisible(base::local(2))
[13:20:24.983]             future::FutureResult(value = ...future.value$value, 
[13:20:24.983]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.983]                   ...future.rng), globalenv = if (FALSE) 
[13:20:24.983]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:24.983]                     ...future.globalenv.names))
[13:20:24.983]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:24.983]         }, condition = base::local({
[13:20:24.983]             c <- base::c
[13:20:24.983]             inherits <- base::inherits
[13:20:24.983]             invokeRestart <- base::invokeRestart
[13:20:24.983]             length <- base::length
[13:20:24.983]             list <- base::list
[13:20:24.983]             seq.int <- base::seq.int
[13:20:24.983]             signalCondition <- base::signalCondition
[13:20:24.983]             sys.calls <- base::sys.calls
[13:20:24.983]             `[[` <- base::`[[`
[13:20:24.983]             `+` <- base::`+`
[13:20:24.983]             `<<-` <- base::`<<-`
[13:20:24.983]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:24.983]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:24.983]                   3L)]
[13:20:24.983]             }
[13:20:24.983]             function(cond) {
[13:20:24.983]                 is_error <- inherits(cond, "error")
[13:20:24.983]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:24.983]                   NULL)
[13:20:24.983]                 if (is_error) {
[13:20:24.983]                   sessionInformation <- function() {
[13:20:24.983]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:24.983]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:24.983]                       search = base::search(), system = base::Sys.info())
[13:20:24.983]                   }
[13:20:24.983]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.983]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:24.983]                     cond$call), session = sessionInformation(), 
[13:20:24.983]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:24.983]                   signalCondition(cond)
[13:20:24.983]                 }
[13:20:24.983]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:24.983]                 "immediateCondition"))) {
[13:20:24.983]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:24.983]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.983]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:24.983]                   if (TRUE && !signal) {
[13:20:24.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.983]                     {
[13:20:24.983]                       inherits <- base::inherits
[13:20:24.983]                       invokeRestart <- base::invokeRestart
[13:20:24.983]                       is.null <- base::is.null
[13:20:24.983]                       muffled <- FALSE
[13:20:24.983]                       if (inherits(cond, "message")) {
[13:20:24.983]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.983]                         if (muffled) 
[13:20:24.983]                           invokeRestart("muffleMessage")
[13:20:24.983]                       }
[13:20:24.983]                       else if (inherits(cond, "warning")) {
[13:20:24.983]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.983]                         if (muffled) 
[13:20:24.983]                           invokeRestart("muffleWarning")
[13:20:24.983]                       }
[13:20:24.983]                       else if (inherits(cond, "condition")) {
[13:20:24.983]                         if (!is.null(pattern)) {
[13:20:24.983]                           computeRestarts <- base::computeRestarts
[13:20:24.983]                           grepl <- base::grepl
[13:20:24.983]                           restarts <- computeRestarts(cond)
[13:20:24.983]                           for (restart in restarts) {
[13:20:24.983]                             name <- restart$name
[13:20:24.983]                             if (is.null(name)) 
[13:20:24.983]                               next
[13:20:24.983]                             if (!grepl(pattern, name)) 
[13:20:24.983]                               next
[13:20:24.983]                             invokeRestart(restart)
[13:20:24.983]                             muffled <- TRUE
[13:20:24.983]                             break
[13:20:24.983]                           }
[13:20:24.983]                         }
[13:20:24.983]                       }
[13:20:24.983]                       invisible(muffled)
[13:20:24.983]                     }
[13:20:24.983]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.983]                   }
[13:20:24.983]                 }
[13:20:24.983]                 else {
[13:20:24.983]                   if (TRUE) {
[13:20:24.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.983]                     {
[13:20:24.983]                       inherits <- base::inherits
[13:20:24.983]                       invokeRestart <- base::invokeRestart
[13:20:24.983]                       is.null <- base::is.null
[13:20:24.983]                       muffled <- FALSE
[13:20:24.983]                       if (inherits(cond, "message")) {
[13:20:24.983]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.983]                         if (muffled) 
[13:20:24.983]                           invokeRestart("muffleMessage")
[13:20:24.983]                       }
[13:20:24.983]                       else if (inherits(cond, "warning")) {
[13:20:24.983]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.983]                         if (muffled) 
[13:20:24.983]                           invokeRestart("muffleWarning")
[13:20:24.983]                       }
[13:20:24.983]                       else if (inherits(cond, "condition")) {
[13:20:24.983]                         if (!is.null(pattern)) {
[13:20:24.983]                           computeRestarts <- base::computeRestarts
[13:20:24.983]                           grepl <- base::grepl
[13:20:24.983]                           restarts <- computeRestarts(cond)
[13:20:24.983]                           for (restart in restarts) {
[13:20:24.983]                             name <- restart$name
[13:20:24.983]                             if (is.null(name)) 
[13:20:24.983]                               next
[13:20:24.983]                             if (!grepl(pattern, name)) 
[13:20:24.983]                               next
[13:20:24.983]                             invokeRestart(restart)
[13:20:24.983]                             muffled <- TRUE
[13:20:24.983]                             break
[13:20:24.983]                           }
[13:20:24.983]                         }
[13:20:24.983]                       }
[13:20:24.983]                       invisible(muffled)
[13:20:24.983]                     }
[13:20:24.983]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.983]                   }
[13:20:24.983]                 }
[13:20:24.983]             }
[13:20:24.983]         }))
[13:20:24.983]     }, error = function(ex) {
[13:20:24.983]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:24.983]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.983]                 ...future.rng), started = ...future.startTime, 
[13:20:24.983]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:24.983]             version = "1.8"), class = "FutureResult")
[13:20:24.983]     }, finally = {
[13:20:24.983]         if (!identical(...future.workdir, getwd())) 
[13:20:24.983]             setwd(...future.workdir)
[13:20:24.983]         {
[13:20:24.983]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:24.983]                 ...future.oldOptions$nwarnings <- NULL
[13:20:24.983]             }
[13:20:24.983]             base::options(...future.oldOptions)
[13:20:24.983]             if (.Platform$OS.type == "windows") {
[13:20:24.983]                 old_names <- names(...future.oldEnvVars)
[13:20:24.983]                 envs <- base::Sys.getenv()
[13:20:24.983]                 names <- names(envs)
[13:20:24.983]                 common <- intersect(names, old_names)
[13:20:24.983]                 added <- setdiff(names, old_names)
[13:20:24.983]                 removed <- setdiff(old_names, names)
[13:20:24.983]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:24.983]                   envs[common]]
[13:20:24.983]                 NAMES <- toupper(changed)
[13:20:24.983]                 args <- list()
[13:20:24.983]                 for (kk in seq_along(NAMES)) {
[13:20:24.983]                   name <- changed[[kk]]
[13:20:24.983]                   NAME <- NAMES[[kk]]
[13:20:24.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.983]                     next
[13:20:24.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.983]                 }
[13:20:24.983]                 NAMES <- toupper(added)
[13:20:24.983]                 for (kk in seq_along(NAMES)) {
[13:20:24.983]                   name <- added[[kk]]
[13:20:24.983]                   NAME <- NAMES[[kk]]
[13:20:24.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.983]                     next
[13:20:24.983]                   args[[name]] <- ""
[13:20:24.983]                 }
[13:20:24.983]                 NAMES <- toupper(removed)
[13:20:24.983]                 for (kk in seq_along(NAMES)) {
[13:20:24.983]                   name <- removed[[kk]]
[13:20:24.983]                   NAME <- NAMES[[kk]]
[13:20:24.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.983]                     next
[13:20:24.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.983]                 }
[13:20:24.983]                 if (length(args) > 0) 
[13:20:24.983]                   base::do.call(base::Sys.setenv, args = args)
[13:20:24.983]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:24.983]             }
[13:20:24.983]             else {
[13:20:24.983]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:24.983]             }
[13:20:24.983]             {
[13:20:24.983]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:24.983]                   0L) {
[13:20:24.983]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:24.983]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:24.983]                   base::options(opts)
[13:20:24.983]                 }
[13:20:24.983]                 {
[13:20:24.983]                   {
[13:20:24.983]                     NULL
[13:20:24.983]                     RNGkind("Mersenne-Twister")
[13:20:24.983]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:24.983]                       inherits = FALSE)
[13:20:24.983]                   }
[13:20:24.983]                   options(future.plan = NULL)
[13:20:24.983]                   if (is.na(NA_character_)) 
[13:20:24.983]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.983]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:24.983]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:24.983]                   {
[13:20:24.983]                     future <- SequentialFuture(..., envir = envir)
[13:20:24.983]                     if (!future$lazy) 
[13:20:24.983]                       future <- run(future)
[13:20:24.983]                     invisible(future)
[13:20:24.983]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:24.983]                 }
[13:20:24.983]             }
[13:20:24.983]         }
[13:20:24.983]     })
[13:20:24.983]     if (TRUE) {
[13:20:24.983]         base::sink(type = "output", split = FALSE)
[13:20:24.983]         if (TRUE) {
[13:20:24.983]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:24.983]         }
[13:20:24.983]         else {
[13:20:24.983]             ...future.result["stdout"] <- base::list(NULL)
[13:20:24.983]         }
[13:20:24.983]         base::close(...future.stdout)
[13:20:24.983]         ...future.stdout <- NULL
[13:20:24.983]     }
[13:20:24.983]     ...future.result$conditions <- ...future.conditions
[13:20:24.983]     ...future.result$finished <- base::Sys.time()
[13:20:24.983]     ...future.result
[13:20:24.983] }
[13:20:24.984] plan(): Setting new future strategy stack:
[13:20:24.984] List of future strategies:
[13:20:24.984] 1. sequential:
[13:20:24.984]    - args: function (..., envir = parent.frame())
[13:20:24.984]    - tweaked: FALSE
[13:20:24.984]    - call: NULL
[13:20:24.985] plan(): nbrOfWorkers() = 1
[13:20:24.985] plan(): Setting new future strategy stack:
[13:20:24.986] List of future strategies:
[13:20:24.986] 1. sequential:
[13:20:24.986]    - args: function (..., envir = parent.frame())
[13:20:24.986]    - tweaked: FALSE
[13:20:24.986]    - call: plan(strategy)
[13:20:24.986] plan(): nbrOfWorkers() = 1
[13:20:24.986] SequentialFuture started (and completed)
[13:20:24.986] - Launch lazy future ... done
[13:20:24.986] run() for ‘SequentialFuture’ ... done
[13:20:24.986] getGlobalsAndPackages() ...
[13:20:24.987] Searching for globals...
[13:20:24.987] 
[13:20:24.987] Searching for globals ... DONE
[13:20:24.987] - globals: [0] <none>
[13:20:24.987] getGlobalsAndPackages() ... DONE
[13:20:24.987] run() for ‘Future’ ...
[13:20:24.987] - state: ‘created’
[13:20:24.988] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:24.988] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:24.988] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:24.988]   - Field: ‘label’
[13:20:24.988]   - Field: ‘local’
[13:20:24.988]   - Field: ‘owner’
[13:20:24.988]   - Field: ‘envir’
[13:20:24.988]   - Field: ‘packages’
[13:20:24.988]   - Field: ‘gc’
[13:20:24.989]   - Field: ‘conditions’
[13:20:24.989]   - Field: ‘expr’
[13:20:24.989]   - Field: ‘uuid’
[13:20:24.989]   - Field: ‘seed’
[13:20:24.989]   - Field: ‘version’
[13:20:24.989]   - Field: ‘result’
[13:20:24.989]   - Field: ‘asynchronous’
[13:20:24.989]   - Field: ‘calls’
[13:20:24.989]   - Field: ‘globals’
[13:20:24.989]   - Field: ‘stdout’
[13:20:24.989]   - Field: ‘earlySignal’
[13:20:24.990]   - Field: ‘lazy’
[13:20:24.990]   - Field: ‘state’
[13:20:24.990] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:24.990] - Launch lazy future ...
[13:20:24.990] Packages needed by the future expression (n = 0): <none>
[13:20:24.990] Packages needed by future strategies (n = 0): <none>
[13:20:24.990] {
[13:20:24.990]     {
[13:20:24.990]         {
[13:20:24.990]             ...future.startTime <- base::Sys.time()
[13:20:24.990]             {
[13:20:24.990]                 {
[13:20:24.990]                   {
[13:20:24.990]                     base::local({
[13:20:24.990]                       has_future <- base::requireNamespace("future", 
[13:20:24.990]                         quietly = TRUE)
[13:20:24.990]                       if (has_future) {
[13:20:24.990]                         ns <- base::getNamespace("future")
[13:20:24.990]                         version <- ns[[".package"]][["version"]]
[13:20:24.990]                         if (is.null(version)) 
[13:20:24.990]                           version <- utils::packageVersion("future")
[13:20:24.990]                       }
[13:20:24.990]                       else {
[13:20:24.990]                         version <- NULL
[13:20:24.990]                       }
[13:20:24.990]                       if (!has_future || version < "1.8.0") {
[13:20:24.990]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:24.990]                           "", base::R.version$version.string), 
[13:20:24.990]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:24.990]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:24.990]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:24.990]                             "release", "version")], collapse = " "), 
[13:20:24.990]                           hostname = base::Sys.info()[["nodename"]])
[13:20:24.990]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:24.990]                           info)
[13:20:24.990]                         info <- base::paste(info, collapse = "; ")
[13:20:24.990]                         if (!has_future) {
[13:20:24.990]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:24.990]                             info)
[13:20:24.990]                         }
[13:20:24.990]                         else {
[13:20:24.990]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:24.990]                             info, version)
[13:20:24.990]                         }
[13:20:24.990]                         base::stop(msg)
[13:20:24.990]                       }
[13:20:24.990]                     })
[13:20:24.990]                   }
[13:20:24.990]                   options(future.plan = NULL)
[13:20:24.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:24.990]                 }
[13:20:24.990]                 ...future.workdir <- getwd()
[13:20:24.990]             }
[13:20:24.990]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:24.990]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:24.990]         }
[13:20:24.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:24.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:24.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:24.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:24.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:24.990]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:24.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:24.990]             base::names(...future.oldOptions))
[13:20:24.990]     }
[13:20:24.990]     if (FALSE) {
[13:20:24.990]     }
[13:20:24.990]     else {
[13:20:24.990]         if (TRUE) {
[13:20:24.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:24.990]                 open = "w")
[13:20:24.990]         }
[13:20:24.990]         else {
[13:20:24.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:24.990]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:24.990]         }
[13:20:24.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:24.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:24.990]             base::sink(type = "output", split = FALSE)
[13:20:24.990]             base::close(...future.stdout)
[13:20:24.990]         }, add = TRUE)
[13:20:24.990]     }
[13:20:24.990]     ...future.frame <- base::sys.nframe()
[13:20:24.990]     ...future.conditions <- base::list()
[13:20:24.990]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:24.990]     if (FALSE) {
[13:20:24.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:24.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:24.990]     }
[13:20:24.990]     ...future.result <- base::tryCatch({
[13:20:24.990]         base::withCallingHandlers({
[13:20:24.990]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:24.990]             future::FutureResult(value = ...future.value$value, 
[13:20:24.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.990]                   ...future.rng), globalenv = if (FALSE) 
[13:20:24.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:24.990]                     ...future.globalenv.names))
[13:20:24.990]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:24.990]         }, condition = base::local({
[13:20:24.990]             c <- base::c
[13:20:24.990]             inherits <- base::inherits
[13:20:24.990]             invokeRestart <- base::invokeRestart
[13:20:24.990]             length <- base::length
[13:20:24.990]             list <- base::list
[13:20:24.990]             seq.int <- base::seq.int
[13:20:24.990]             signalCondition <- base::signalCondition
[13:20:24.990]             sys.calls <- base::sys.calls
[13:20:24.990]             `[[` <- base::`[[`
[13:20:24.990]             `+` <- base::`+`
[13:20:24.990]             `<<-` <- base::`<<-`
[13:20:24.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:24.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:24.990]                   3L)]
[13:20:24.990]             }
[13:20:24.990]             function(cond) {
[13:20:24.990]                 is_error <- inherits(cond, "error")
[13:20:24.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:24.990]                   NULL)
[13:20:24.990]                 if (is_error) {
[13:20:24.990]                   sessionInformation <- function() {
[13:20:24.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:24.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:24.990]                       search = base::search(), system = base::Sys.info())
[13:20:24.990]                   }
[13:20:24.990]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:24.990]                     cond$call), session = sessionInformation(), 
[13:20:24.990]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:24.990]                   signalCondition(cond)
[13:20:24.990]                 }
[13:20:24.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:24.990]                 "immediateCondition"))) {
[13:20:24.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:24.990]                   ...future.conditions[[length(...future.conditions) + 
[13:20:24.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:24.990]                   if (TRUE && !signal) {
[13:20:24.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.990]                     {
[13:20:24.990]                       inherits <- base::inherits
[13:20:24.990]                       invokeRestart <- base::invokeRestart
[13:20:24.990]                       is.null <- base::is.null
[13:20:24.990]                       muffled <- FALSE
[13:20:24.990]                       if (inherits(cond, "message")) {
[13:20:24.990]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.990]                         if (muffled) 
[13:20:24.990]                           invokeRestart("muffleMessage")
[13:20:24.990]                       }
[13:20:24.990]                       else if (inherits(cond, "warning")) {
[13:20:24.990]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.990]                         if (muffled) 
[13:20:24.990]                           invokeRestart("muffleWarning")
[13:20:24.990]                       }
[13:20:24.990]                       else if (inherits(cond, "condition")) {
[13:20:24.990]                         if (!is.null(pattern)) {
[13:20:24.990]                           computeRestarts <- base::computeRestarts
[13:20:24.990]                           grepl <- base::grepl
[13:20:24.990]                           restarts <- computeRestarts(cond)
[13:20:24.990]                           for (restart in restarts) {
[13:20:24.990]                             name <- restart$name
[13:20:24.990]                             if (is.null(name)) 
[13:20:24.990]                               next
[13:20:24.990]                             if (!grepl(pattern, name)) 
[13:20:24.990]                               next
[13:20:24.990]                             invokeRestart(restart)
[13:20:24.990]                             muffled <- TRUE
[13:20:24.990]                             break
[13:20:24.990]                           }
[13:20:24.990]                         }
[13:20:24.990]                       }
[13:20:24.990]                       invisible(muffled)
[13:20:24.990]                     }
[13:20:24.990]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.990]                   }
[13:20:24.990]                 }
[13:20:24.990]                 else {
[13:20:24.990]                   if (TRUE) {
[13:20:24.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:24.990]                     {
[13:20:24.990]                       inherits <- base::inherits
[13:20:24.990]                       invokeRestart <- base::invokeRestart
[13:20:24.990]                       is.null <- base::is.null
[13:20:24.990]                       muffled <- FALSE
[13:20:24.990]                       if (inherits(cond, "message")) {
[13:20:24.990]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:24.990]                         if (muffled) 
[13:20:24.990]                           invokeRestart("muffleMessage")
[13:20:24.990]                       }
[13:20:24.990]                       else if (inherits(cond, "warning")) {
[13:20:24.990]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:24.990]                         if (muffled) 
[13:20:24.990]                           invokeRestart("muffleWarning")
[13:20:24.990]                       }
[13:20:24.990]                       else if (inherits(cond, "condition")) {
[13:20:24.990]                         if (!is.null(pattern)) {
[13:20:24.990]                           computeRestarts <- base::computeRestarts
[13:20:24.990]                           grepl <- base::grepl
[13:20:24.990]                           restarts <- computeRestarts(cond)
[13:20:24.990]                           for (restart in restarts) {
[13:20:24.990]                             name <- restart$name
[13:20:24.990]                             if (is.null(name)) 
[13:20:24.990]                               next
[13:20:24.990]                             if (!grepl(pattern, name)) 
[13:20:24.990]                               next
[13:20:24.990]                             invokeRestart(restart)
[13:20:24.990]                             muffled <- TRUE
[13:20:24.990]                             break
[13:20:24.990]                           }
[13:20:24.990]                         }
[13:20:24.990]                       }
[13:20:24.990]                       invisible(muffled)
[13:20:24.990]                     }
[13:20:24.990]                     muffleCondition(cond, pattern = "^muffle")
[13:20:24.990]                   }
[13:20:24.990]                 }
[13:20:24.990]             }
[13:20:24.990]         }))
[13:20:24.990]     }, error = function(ex) {
[13:20:24.990]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:24.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:24.990]                 ...future.rng), started = ...future.startTime, 
[13:20:24.990]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:24.990]             version = "1.8"), class = "FutureResult")
[13:20:24.990]     }, finally = {
[13:20:24.990]         if (!identical(...future.workdir, getwd())) 
[13:20:24.990]             setwd(...future.workdir)
[13:20:24.990]         {
[13:20:24.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:24.990]                 ...future.oldOptions$nwarnings <- NULL
[13:20:24.990]             }
[13:20:24.990]             base::options(...future.oldOptions)
[13:20:24.990]             if (.Platform$OS.type == "windows") {
[13:20:24.990]                 old_names <- names(...future.oldEnvVars)
[13:20:24.990]                 envs <- base::Sys.getenv()
[13:20:24.990]                 names <- names(envs)
[13:20:24.990]                 common <- intersect(names, old_names)
[13:20:24.990]                 added <- setdiff(names, old_names)
[13:20:24.990]                 removed <- setdiff(old_names, names)
[13:20:24.990]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:24.990]                   envs[common]]
[13:20:24.990]                 NAMES <- toupper(changed)
[13:20:24.990]                 args <- list()
[13:20:24.990]                 for (kk in seq_along(NAMES)) {
[13:20:24.990]                   name <- changed[[kk]]
[13:20:24.990]                   NAME <- NAMES[[kk]]
[13:20:24.990]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.990]                     next
[13:20:24.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.990]                 }
[13:20:24.990]                 NAMES <- toupper(added)
[13:20:24.990]                 for (kk in seq_along(NAMES)) {
[13:20:24.990]                   name <- added[[kk]]
[13:20:24.990]                   NAME <- NAMES[[kk]]
[13:20:24.990]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.990]                     next
[13:20:24.990]                   args[[name]] <- ""
[13:20:24.990]                 }
[13:20:24.990]                 NAMES <- toupper(removed)
[13:20:24.990]                 for (kk in seq_along(NAMES)) {
[13:20:24.990]                   name <- removed[[kk]]
[13:20:24.990]                   NAME <- NAMES[[kk]]
[13:20:24.990]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:24.990]                     next
[13:20:24.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:24.990]                 }
[13:20:24.990]                 if (length(args) > 0) 
[13:20:24.990]                   base::do.call(base::Sys.setenv, args = args)
[13:20:24.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:24.990]             }
[13:20:24.990]             else {
[13:20:24.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:24.990]             }
[13:20:24.990]             {
[13:20:24.990]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:24.990]                   0L) {
[13:20:24.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:24.990]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:24.990]                   base::options(opts)
[13:20:24.990]                 }
[13:20:24.990]                 {
[13:20:24.990]                   {
[13:20:24.990]                     NULL
[13:20:24.990]                     RNGkind("Mersenne-Twister")
[13:20:24.990]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:24.990]                       inherits = FALSE)
[13:20:24.990]                   }
[13:20:24.990]                   options(future.plan = NULL)
[13:20:24.990]                   if (is.na(NA_character_)) 
[13:20:24.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:24.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:24.990]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:24.990]                   {
[13:20:24.990]                     future <- SequentialFuture(..., envir = envir)
[13:20:24.990]                     if (!future$lazy) 
[13:20:24.990]                       future <- run(future)
[13:20:24.990]                     invisible(future)
[13:20:24.990]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:24.990]                 }
[13:20:24.990]             }
[13:20:24.990]         }
[13:20:24.990]     })
[13:20:24.990]     if (TRUE) {
[13:20:24.990]         base::sink(type = "output", split = FALSE)
[13:20:24.990]         if (TRUE) {
[13:20:24.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:24.990]         }
[13:20:24.990]         else {
[13:20:24.990]             ...future.result["stdout"] <- base::list(NULL)
[13:20:24.990]         }
[13:20:24.990]         base::close(...future.stdout)
[13:20:24.990]         ...future.stdout <- NULL
[13:20:24.990]     }
[13:20:24.990]     ...future.result$conditions <- ...future.conditions
[13:20:24.990]     ...future.result$finished <- base::Sys.time()
[13:20:24.990]     ...future.result
[13:20:24.990] }
[13:20:24.992] plan(): Setting new future strategy stack:
[13:20:24.992] List of future strategies:
[13:20:24.992] 1. sequential:
[13:20:24.992]    - args: function (..., envir = parent.frame())
[13:20:24.992]    - tweaked: FALSE
[13:20:24.992]    - call: NULL
[13:20:24.993] plan(): nbrOfWorkers() = 1
[13:20:24.993] plan(): Setting new future strategy stack:
[13:20:24.993] List of future strategies:
[13:20:24.993] 1. sequential:
[13:20:24.993]    - args: function (..., envir = parent.frame())
[13:20:24.993]    - tweaked: FALSE
[13:20:24.993]    - call: plan(strategy)
[13:20:24.994] plan(): nbrOfWorkers() = 1
[13:20:24.994] SequentialFuture started (and completed)
[13:20:24.994] - Launch lazy future ... done
[13:20:24.994] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659a829d10> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659b4342c0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659a829d10> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659b4342c0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:20:24.999] resolved() for ‘SequentialFuture’ ...
[13:20:25.000] - state: ‘finished’
[13:20:25.000] - run: TRUE
[13:20:25.000] - result: ‘FutureResult’
[13:20:25.000] resolved() for ‘SequentialFuture’ ... done
[13:20:25.000] resolved() for ‘SequentialFuture’ ...
[13:20:25.000] - state: ‘finished’
[13:20:25.001] - run: TRUE
[13:20:25.001] - result: ‘FutureResult’
[13:20:25.001] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:25.002] resolve() on list ...
[13:20:25.002]  recursive: 0
[13:20:25.003]  length: 6
[13:20:25.003]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:25.003] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.003] - nx: 6
[13:20:25.003] - relay: TRUE
[13:20:25.003] - stdout: TRUE
[13:20:25.003] - signal: TRUE
[13:20:25.003] - resignal: FALSE
[13:20:25.003] - force: TRUE
[13:20:25.003] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.003] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.004]  - until=2
[13:20:25.004]  - relaying element #2
[13:20:25.004] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.004] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.004] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.004]  length: 5 (resolved future 1)
[13:20:25.004] resolved() for ‘SequentialFuture’ ...
[13:20:25.004] - state: ‘finished’
[13:20:25.004] - run: TRUE
[13:20:25.004] - result: ‘FutureResult’
[13:20:25.004] resolved() for ‘SequentialFuture’ ... done
[13:20:25.005] Future #2
[13:20:25.005] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.005] - nx: 6
[13:20:25.005] - relay: TRUE
[13:20:25.005] - stdout: TRUE
[13:20:25.005] - signal: TRUE
[13:20:25.005] - resignal: FALSE
[13:20:25.005] - force: TRUE
[13:20:25.005] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.005] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.006]  - until=2
[13:20:25.006]  - relaying element #2
[13:20:25.006] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.006] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.006] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.006]  length: 4 (resolved future 2)
[13:20:25.006] resolved() for ‘SequentialFuture’ ...
[13:20:25.006] - state: ‘finished’
[13:20:25.006] - run: TRUE
[13:20:25.006] - result: ‘FutureResult’
[13:20:25.007] resolved() for ‘SequentialFuture’ ... done
[13:20:25.009] Future #3
[13:20:25.009] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.009] - nx: 6
[13:20:25.009] - relay: TRUE
[13:20:25.009] - stdout: TRUE
[13:20:25.009] - signal: TRUE
[13:20:25.009] - resignal: FALSE
[13:20:25.009] - force: TRUE
[13:20:25.009] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.010] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.010]  - until=3
[13:20:25.010]  - relaying element #3
[13:20:25.010] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.010] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.010] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.010]  length: 3 (resolved future 3)
[13:20:25.010] signalConditionsASAP(NULL, pos=4) ...
[13:20:25.010] - nx: 6
[13:20:25.011] - relay: TRUE
[13:20:25.011] - stdout: TRUE
[13:20:25.011] - signal: TRUE
[13:20:25.011] - resignal: FALSE
[13:20:25.011] - force: TRUE
[13:20:25.011] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.011] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.011]  - until=5
[13:20:25.011]  - relaying element #5
[13:20:25.011] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.011] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.012] signalConditionsASAP(NULL, pos=4) ... done
[13:20:25.012]  length: 2 (resolved future 4)
[13:20:25.012] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.012] - nx: 6
[13:20:25.012] - relay: TRUE
[13:20:25.012] - stdout: TRUE
[13:20:25.012] - signal: TRUE
[13:20:25.012] - resignal: FALSE
[13:20:25.012] - force: TRUE
[13:20:25.012] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.012] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.013]  - until=6
[13:20:25.013]  - relaying element #6
[13:20:25.013] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.013] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.013] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.013]  length: 1 (resolved future 5)
[13:20:25.013] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.013] - nx: 6
[13:20:25.013] - relay: TRUE
[13:20:25.013] - stdout: TRUE
[13:20:25.013] - signal: TRUE
[13:20:25.014] - resignal: FALSE
[13:20:25.014] - force: TRUE
[13:20:25.014] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.014] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.014]  - until=6
[13:20:25.014] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.014] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.014] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.014]  length: 0 (resolved future 6)
[13:20:25.014] Relaying remaining futures
[13:20:25.014] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.015] - nx: 6
[13:20:25.015] - relay: TRUE
[13:20:25.015] - stdout: TRUE
[13:20:25.015] - signal: TRUE
[13:20:25.015] - resignal: FALSE
[13:20:25.015] - force: TRUE
[13:20:25.015] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.015] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:25.015] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.015] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.015] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.016] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:20:25.019] getGlobalsAndPackages() ...
[13:20:25.019] Searching for globals...
[13:20:25.019] 
[13:20:25.019] Searching for globals ... DONE
[13:20:25.020] - globals: [0] <none>
[13:20:25.020] getGlobalsAndPackages() ... DONE
[13:20:25.020] run() for ‘Future’ ...
[13:20:25.020] - state: ‘created’
[13:20:25.020] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.020] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.021] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.021]   - Field: ‘label’
[13:20:25.021]   - Field: ‘local’
[13:20:25.021]   - Field: ‘owner’
[13:20:25.021]   - Field: ‘envir’
[13:20:25.021]   - Field: ‘packages’
[13:20:25.021]   - Field: ‘gc’
[13:20:25.021]   - Field: ‘conditions’
[13:20:25.021]   - Field: ‘expr’
[13:20:25.021]   - Field: ‘uuid’
[13:20:25.022]   - Field: ‘seed’
[13:20:25.022]   - Field: ‘version’
[13:20:25.022]   - Field: ‘result’
[13:20:25.022]   - Field: ‘asynchronous’
[13:20:25.022]   - Field: ‘calls’
[13:20:25.022]   - Field: ‘globals’
[13:20:25.022]   - Field: ‘stdout’
[13:20:25.022]   - Field: ‘earlySignal’
[13:20:25.022]   - Field: ‘lazy’
[13:20:25.022]   - Field: ‘state’
[13:20:25.022] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.023] - Launch lazy future ...
[13:20:25.023] Packages needed by the future expression (n = 0): <none>
[13:20:25.023] Packages needed by future strategies (n = 0): <none>
[13:20:25.023] {
[13:20:25.023]     {
[13:20:25.023]         {
[13:20:25.023]             ...future.startTime <- base::Sys.time()
[13:20:25.023]             {
[13:20:25.023]                 {
[13:20:25.023]                   {
[13:20:25.023]                     base::local({
[13:20:25.023]                       has_future <- base::requireNamespace("future", 
[13:20:25.023]                         quietly = TRUE)
[13:20:25.023]                       if (has_future) {
[13:20:25.023]                         ns <- base::getNamespace("future")
[13:20:25.023]                         version <- ns[[".package"]][["version"]]
[13:20:25.023]                         if (is.null(version)) 
[13:20:25.023]                           version <- utils::packageVersion("future")
[13:20:25.023]                       }
[13:20:25.023]                       else {
[13:20:25.023]                         version <- NULL
[13:20:25.023]                       }
[13:20:25.023]                       if (!has_future || version < "1.8.0") {
[13:20:25.023]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.023]                           "", base::R.version$version.string), 
[13:20:25.023]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.023]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.023]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.023]                             "release", "version")], collapse = " "), 
[13:20:25.023]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.023]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.023]                           info)
[13:20:25.023]                         info <- base::paste(info, collapse = "; ")
[13:20:25.023]                         if (!has_future) {
[13:20:25.023]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.023]                             info)
[13:20:25.023]                         }
[13:20:25.023]                         else {
[13:20:25.023]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.023]                             info, version)
[13:20:25.023]                         }
[13:20:25.023]                         base::stop(msg)
[13:20:25.023]                       }
[13:20:25.023]                     })
[13:20:25.023]                   }
[13:20:25.023]                   options(future.plan = NULL)
[13:20:25.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.023]                 }
[13:20:25.023]                 ...future.workdir <- getwd()
[13:20:25.023]             }
[13:20:25.023]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.023]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.023]         }
[13:20:25.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.023]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.023]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.023]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.023]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.023]             base::names(...future.oldOptions))
[13:20:25.023]     }
[13:20:25.023]     if (FALSE) {
[13:20:25.023]     }
[13:20:25.023]     else {
[13:20:25.023]         if (TRUE) {
[13:20:25.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.023]                 open = "w")
[13:20:25.023]         }
[13:20:25.023]         else {
[13:20:25.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.023]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.023]         }
[13:20:25.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.023]             base::sink(type = "output", split = FALSE)
[13:20:25.023]             base::close(...future.stdout)
[13:20:25.023]         }, add = TRUE)
[13:20:25.023]     }
[13:20:25.023]     ...future.frame <- base::sys.nframe()
[13:20:25.023]     ...future.conditions <- base::list()
[13:20:25.023]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.023]     if (FALSE) {
[13:20:25.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.023]     }
[13:20:25.023]     ...future.result <- base::tryCatch({
[13:20:25.023]         base::withCallingHandlers({
[13:20:25.023]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.023]             future::FutureResult(value = ...future.value$value, 
[13:20:25.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.023]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.023]                     ...future.globalenv.names))
[13:20:25.023]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.023]         }, condition = base::local({
[13:20:25.023]             c <- base::c
[13:20:25.023]             inherits <- base::inherits
[13:20:25.023]             invokeRestart <- base::invokeRestart
[13:20:25.023]             length <- base::length
[13:20:25.023]             list <- base::list
[13:20:25.023]             seq.int <- base::seq.int
[13:20:25.023]             signalCondition <- base::signalCondition
[13:20:25.023]             sys.calls <- base::sys.calls
[13:20:25.023]             `[[` <- base::`[[`
[13:20:25.023]             `+` <- base::`+`
[13:20:25.023]             `<<-` <- base::`<<-`
[13:20:25.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.023]                   3L)]
[13:20:25.023]             }
[13:20:25.023]             function(cond) {
[13:20:25.023]                 is_error <- inherits(cond, "error")
[13:20:25.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.023]                   NULL)
[13:20:25.023]                 if (is_error) {
[13:20:25.023]                   sessionInformation <- function() {
[13:20:25.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.023]                       search = base::search(), system = base::Sys.info())
[13:20:25.023]                   }
[13:20:25.023]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.023]                     cond$call), session = sessionInformation(), 
[13:20:25.023]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.023]                   signalCondition(cond)
[13:20:25.023]                 }
[13:20:25.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.023]                 "immediateCondition"))) {
[13:20:25.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.023]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.023]                   if (TRUE && !signal) {
[13:20:25.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.023]                     {
[13:20:25.023]                       inherits <- base::inherits
[13:20:25.023]                       invokeRestart <- base::invokeRestart
[13:20:25.023]                       is.null <- base::is.null
[13:20:25.023]                       muffled <- FALSE
[13:20:25.023]                       if (inherits(cond, "message")) {
[13:20:25.023]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.023]                         if (muffled) 
[13:20:25.023]                           invokeRestart("muffleMessage")
[13:20:25.023]                       }
[13:20:25.023]                       else if (inherits(cond, "warning")) {
[13:20:25.023]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.023]                         if (muffled) 
[13:20:25.023]                           invokeRestart("muffleWarning")
[13:20:25.023]                       }
[13:20:25.023]                       else if (inherits(cond, "condition")) {
[13:20:25.023]                         if (!is.null(pattern)) {
[13:20:25.023]                           computeRestarts <- base::computeRestarts
[13:20:25.023]                           grepl <- base::grepl
[13:20:25.023]                           restarts <- computeRestarts(cond)
[13:20:25.023]                           for (restart in restarts) {
[13:20:25.023]                             name <- restart$name
[13:20:25.023]                             if (is.null(name)) 
[13:20:25.023]                               next
[13:20:25.023]                             if (!grepl(pattern, name)) 
[13:20:25.023]                               next
[13:20:25.023]                             invokeRestart(restart)
[13:20:25.023]                             muffled <- TRUE
[13:20:25.023]                             break
[13:20:25.023]                           }
[13:20:25.023]                         }
[13:20:25.023]                       }
[13:20:25.023]                       invisible(muffled)
[13:20:25.023]                     }
[13:20:25.023]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.023]                   }
[13:20:25.023]                 }
[13:20:25.023]                 else {
[13:20:25.023]                   if (TRUE) {
[13:20:25.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.023]                     {
[13:20:25.023]                       inherits <- base::inherits
[13:20:25.023]                       invokeRestart <- base::invokeRestart
[13:20:25.023]                       is.null <- base::is.null
[13:20:25.023]                       muffled <- FALSE
[13:20:25.023]                       if (inherits(cond, "message")) {
[13:20:25.023]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.023]                         if (muffled) 
[13:20:25.023]                           invokeRestart("muffleMessage")
[13:20:25.023]                       }
[13:20:25.023]                       else if (inherits(cond, "warning")) {
[13:20:25.023]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.023]                         if (muffled) 
[13:20:25.023]                           invokeRestart("muffleWarning")
[13:20:25.023]                       }
[13:20:25.023]                       else if (inherits(cond, "condition")) {
[13:20:25.023]                         if (!is.null(pattern)) {
[13:20:25.023]                           computeRestarts <- base::computeRestarts
[13:20:25.023]                           grepl <- base::grepl
[13:20:25.023]                           restarts <- computeRestarts(cond)
[13:20:25.023]                           for (restart in restarts) {
[13:20:25.023]                             name <- restart$name
[13:20:25.023]                             if (is.null(name)) 
[13:20:25.023]                               next
[13:20:25.023]                             if (!grepl(pattern, name)) 
[13:20:25.023]                               next
[13:20:25.023]                             invokeRestart(restart)
[13:20:25.023]                             muffled <- TRUE
[13:20:25.023]                             break
[13:20:25.023]                           }
[13:20:25.023]                         }
[13:20:25.023]                       }
[13:20:25.023]                       invisible(muffled)
[13:20:25.023]                     }
[13:20:25.023]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.023]                   }
[13:20:25.023]                 }
[13:20:25.023]             }
[13:20:25.023]         }))
[13:20:25.023]     }, error = function(ex) {
[13:20:25.023]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.023]                 ...future.rng), started = ...future.startTime, 
[13:20:25.023]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.023]             version = "1.8"), class = "FutureResult")
[13:20:25.023]     }, finally = {
[13:20:25.023]         if (!identical(...future.workdir, getwd())) 
[13:20:25.023]             setwd(...future.workdir)
[13:20:25.023]         {
[13:20:25.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.023]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.023]             }
[13:20:25.023]             base::options(...future.oldOptions)
[13:20:25.023]             if (.Platform$OS.type == "windows") {
[13:20:25.023]                 old_names <- names(...future.oldEnvVars)
[13:20:25.023]                 envs <- base::Sys.getenv()
[13:20:25.023]                 names <- names(envs)
[13:20:25.023]                 common <- intersect(names, old_names)
[13:20:25.023]                 added <- setdiff(names, old_names)
[13:20:25.023]                 removed <- setdiff(old_names, names)
[13:20:25.023]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.023]                   envs[common]]
[13:20:25.023]                 NAMES <- toupper(changed)
[13:20:25.023]                 args <- list()
[13:20:25.023]                 for (kk in seq_along(NAMES)) {
[13:20:25.023]                   name <- changed[[kk]]
[13:20:25.023]                   NAME <- NAMES[[kk]]
[13:20:25.023]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.023]                     next
[13:20:25.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.023]                 }
[13:20:25.023]                 NAMES <- toupper(added)
[13:20:25.023]                 for (kk in seq_along(NAMES)) {
[13:20:25.023]                   name <- added[[kk]]
[13:20:25.023]                   NAME <- NAMES[[kk]]
[13:20:25.023]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.023]                     next
[13:20:25.023]                   args[[name]] <- ""
[13:20:25.023]                 }
[13:20:25.023]                 NAMES <- toupper(removed)
[13:20:25.023]                 for (kk in seq_along(NAMES)) {
[13:20:25.023]                   name <- removed[[kk]]
[13:20:25.023]                   NAME <- NAMES[[kk]]
[13:20:25.023]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.023]                     next
[13:20:25.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.023]                 }
[13:20:25.023]                 if (length(args) > 0) 
[13:20:25.023]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.023]             }
[13:20:25.023]             else {
[13:20:25.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.023]             }
[13:20:25.023]             {
[13:20:25.023]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.023]                   0L) {
[13:20:25.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.023]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.023]                   base::options(opts)
[13:20:25.023]                 }
[13:20:25.023]                 {
[13:20:25.023]                   {
[13:20:25.023]                     NULL
[13:20:25.023]                     RNGkind("Mersenne-Twister")
[13:20:25.023]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.023]                       inherits = FALSE)
[13:20:25.023]                   }
[13:20:25.023]                   options(future.plan = NULL)
[13:20:25.023]                   if (is.na(NA_character_)) 
[13:20:25.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.023]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.023]                   {
[13:20:25.023]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.023]                     if (!future$lazy) 
[13:20:25.023]                       future <- run(future)
[13:20:25.023]                     invisible(future)
[13:20:25.023]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.023]                 }
[13:20:25.023]             }
[13:20:25.023]         }
[13:20:25.023]     })
[13:20:25.023]     if (TRUE) {
[13:20:25.023]         base::sink(type = "output", split = FALSE)
[13:20:25.023]         if (TRUE) {
[13:20:25.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.023]         }
[13:20:25.023]         else {
[13:20:25.023]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.023]         }
[13:20:25.023]         base::close(...future.stdout)
[13:20:25.023]         ...future.stdout <- NULL
[13:20:25.023]     }
[13:20:25.023]     ...future.result$conditions <- ...future.conditions
[13:20:25.023]     ...future.result$finished <- base::Sys.time()
[13:20:25.023]     ...future.result
[13:20:25.023] }
[13:20:25.025] plan(): Setting new future strategy stack:
[13:20:25.025] List of future strategies:
[13:20:25.025] 1. sequential:
[13:20:25.025]    - args: function (..., envir = parent.frame())
[13:20:25.025]    - tweaked: FALSE
[13:20:25.025]    - call: NULL
[13:20:25.026] plan(): nbrOfWorkers() = 1
[13:20:25.026] plan(): Setting new future strategy stack:
[13:20:25.027] List of future strategies:
[13:20:25.027] 1. sequential:
[13:20:25.027]    - args: function (..., envir = parent.frame())
[13:20:25.027]    - tweaked: FALSE
[13:20:25.027]    - call: plan(strategy)
[13:20:25.027] plan(): nbrOfWorkers() = 1
[13:20:25.027] SequentialFuture started (and completed)
[13:20:25.027] - Launch lazy future ... done
[13:20:25.027] run() for ‘SequentialFuture’ ... done
[13:20:25.027] getGlobalsAndPackages() ...
[13:20:25.028] Searching for globals...
[13:20:25.028] 
[13:20:25.028] Searching for globals ... DONE
[13:20:25.028] - globals: [0] <none>
[13:20:25.028] getGlobalsAndPackages() ... DONE
[13:20:25.028] run() for ‘Future’ ...
[13:20:25.029] - state: ‘created’
[13:20:25.029] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.029] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.029] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.029]   - Field: ‘label’
[13:20:25.029]   - Field: ‘local’
[13:20:25.029]   - Field: ‘owner’
[13:20:25.030]   - Field: ‘envir’
[13:20:25.030]   - Field: ‘packages’
[13:20:25.030]   - Field: ‘gc’
[13:20:25.030]   - Field: ‘conditions’
[13:20:25.030]   - Field: ‘expr’
[13:20:25.030]   - Field: ‘uuid’
[13:20:25.030]   - Field: ‘seed’
[13:20:25.030]   - Field: ‘version’
[13:20:25.030]   - Field: ‘result’
[13:20:25.030]   - Field: ‘asynchronous’
[13:20:25.031]   - Field: ‘calls’
[13:20:25.031]   - Field: ‘globals’
[13:20:25.031]   - Field: ‘stdout’
[13:20:25.031]   - Field: ‘earlySignal’
[13:20:25.031]   - Field: ‘lazy’
[13:20:25.031]   - Field: ‘state’
[13:20:25.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.031] - Launch lazy future ...
[13:20:25.032] Packages needed by the future expression (n = 0): <none>
[13:20:25.032] Packages needed by future strategies (n = 0): <none>
[13:20:25.032] {
[13:20:25.032]     {
[13:20:25.032]         {
[13:20:25.032]             ...future.startTime <- base::Sys.time()
[13:20:25.032]             {
[13:20:25.032]                 {
[13:20:25.032]                   {
[13:20:25.032]                     base::local({
[13:20:25.032]                       has_future <- base::requireNamespace("future", 
[13:20:25.032]                         quietly = TRUE)
[13:20:25.032]                       if (has_future) {
[13:20:25.032]                         ns <- base::getNamespace("future")
[13:20:25.032]                         version <- ns[[".package"]][["version"]]
[13:20:25.032]                         if (is.null(version)) 
[13:20:25.032]                           version <- utils::packageVersion("future")
[13:20:25.032]                       }
[13:20:25.032]                       else {
[13:20:25.032]                         version <- NULL
[13:20:25.032]                       }
[13:20:25.032]                       if (!has_future || version < "1.8.0") {
[13:20:25.032]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.032]                           "", base::R.version$version.string), 
[13:20:25.032]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.032]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.032]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.032]                             "release", "version")], collapse = " "), 
[13:20:25.032]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.032]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.032]                           info)
[13:20:25.032]                         info <- base::paste(info, collapse = "; ")
[13:20:25.032]                         if (!has_future) {
[13:20:25.032]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.032]                             info)
[13:20:25.032]                         }
[13:20:25.032]                         else {
[13:20:25.032]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.032]                             info, version)
[13:20:25.032]                         }
[13:20:25.032]                         base::stop(msg)
[13:20:25.032]                       }
[13:20:25.032]                     })
[13:20:25.032]                   }
[13:20:25.032]                   options(future.plan = NULL)
[13:20:25.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.032]                 }
[13:20:25.032]                 ...future.workdir <- getwd()
[13:20:25.032]             }
[13:20:25.032]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.032]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.032]         }
[13:20:25.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.032]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.032]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.032]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.032]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.032]             base::names(...future.oldOptions))
[13:20:25.032]     }
[13:20:25.032]     if (FALSE) {
[13:20:25.032]     }
[13:20:25.032]     else {
[13:20:25.032]         if (TRUE) {
[13:20:25.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.032]                 open = "w")
[13:20:25.032]         }
[13:20:25.032]         else {
[13:20:25.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.032]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.032]         }
[13:20:25.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.032]             base::sink(type = "output", split = FALSE)
[13:20:25.032]             base::close(...future.stdout)
[13:20:25.032]         }, add = TRUE)
[13:20:25.032]     }
[13:20:25.032]     ...future.frame <- base::sys.nframe()
[13:20:25.032]     ...future.conditions <- base::list()
[13:20:25.032]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.032]     if (FALSE) {
[13:20:25.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.032]     }
[13:20:25.032]     ...future.result <- base::tryCatch({
[13:20:25.032]         base::withCallingHandlers({
[13:20:25.032]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.032]             future::FutureResult(value = ...future.value$value, 
[13:20:25.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.032]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.032]                     ...future.globalenv.names))
[13:20:25.032]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.032]         }, condition = base::local({
[13:20:25.032]             c <- base::c
[13:20:25.032]             inherits <- base::inherits
[13:20:25.032]             invokeRestart <- base::invokeRestart
[13:20:25.032]             length <- base::length
[13:20:25.032]             list <- base::list
[13:20:25.032]             seq.int <- base::seq.int
[13:20:25.032]             signalCondition <- base::signalCondition
[13:20:25.032]             sys.calls <- base::sys.calls
[13:20:25.032]             `[[` <- base::`[[`
[13:20:25.032]             `+` <- base::`+`
[13:20:25.032]             `<<-` <- base::`<<-`
[13:20:25.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.032]                   3L)]
[13:20:25.032]             }
[13:20:25.032]             function(cond) {
[13:20:25.032]                 is_error <- inherits(cond, "error")
[13:20:25.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.032]                   NULL)
[13:20:25.032]                 if (is_error) {
[13:20:25.032]                   sessionInformation <- function() {
[13:20:25.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.032]                       search = base::search(), system = base::Sys.info())
[13:20:25.032]                   }
[13:20:25.032]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.032]                     cond$call), session = sessionInformation(), 
[13:20:25.032]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.032]                   signalCondition(cond)
[13:20:25.032]                 }
[13:20:25.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.032]                 "immediateCondition"))) {
[13:20:25.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.032]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.032]                   if (TRUE && !signal) {
[13:20:25.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.032]                     {
[13:20:25.032]                       inherits <- base::inherits
[13:20:25.032]                       invokeRestart <- base::invokeRestart
[13:20:25.032]                       is.null <- base::is.null
[13:20:25.032]                       muffled <- FALSE
[13:20:25.032]                       if (inherits(cond, "message")) {
[13:20:25.032]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.032]                         if (muffled) 
[13:20:25.032]                           invokeRestart("muffleMessage")
[13:20:25.032]                       }
[13:20:25.032]                       else if (inherits(cond, "warning")) {
[13:20:25.032]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.032]                         if (muffled) 
[13:20:25.032]                           invokeRestart("muffleWarning")
[13:20:25.032]                       }
[13:20:25.032]                       else if (inherits(cond, "condition")) {
[13:20:25.032]                         if (!is.null(pattern)) {
[13:20:25.032]                           computeRestarts <- base::computeRestarts
[13:20:25.032]                           grepl <- base::grepl
[13:20:25.032]                           restarts <- computeRestarts(cond)
[13:20:25.032]                           for (restart in restarts) {
[13:20:25.032]                             name <- restart$name
[13:20:25.032]                             if (is.null(name)) 
[13:20:25.032]                               next
[13:20:25.032]                             if (!grepl(pattern, name)) 
[13:20:25.032]                               next
[13:20:25.032]                             invokeRestart(restart)
[13:20:25.032]                             muffled <- TRUE
[13:20:25.032]                             break
[13:20:25.032]                           }
[13:20:25.032]                         }
[13:20:25.032]                       }
[13:20:25.032]                       invisible(muffled)
[13:20:25.032]                     }
[13:20:25.032]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.032]                   }
[13:20:25.032]                 }
[13:20:25.032]                 else {
[13:20:25.032]                   if (TRUE) {
[13:20:25.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.032]                     {
[13:20:25.032]                       inherits <- base::inherits
[13:20:25.032]                       invokeRestart <- base::invokeRestart
[13:20:25.032]                       is.null <- base::is.null
[13:20:25.032]                       muffled <- FALSE
[13:20:25.032]                       if (inherits(cond, "message")) {
[13:20:25.032]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.032]                         if (muffled) 
[13:20:25.032]                           invokeRestart("muffleMessage")
[13:20:25.032]                       }
[13:20:25.032]                       else if (inherits(cond, "warning")) {
[13:20:25.032]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.032]                         if (muffled) 
[13:20:25.032]                           invokeRestart("muffleWarning")
[13:20:25.032]                       }
[13:20:25.032]                       else if (inherits(cond, "condition")) {
[13:20:25.032]                         if (!is.null(pattern)) {
[13:20:25.032]                           computeRestarts <- base::computeRestarts
[13:20:25.032]                           grepl <- base::grepl
[13:20:25.032]                           restarts <- computeRestarts(cond)
[13:20:25.032]                           for (restart in restarts) {
[13:20:25.032]                             name <- restart$name
[13:20:25.032]                             if (is.null(name)) 
[13:20:25.032]                               next
[13:20:25.032]                             if (!grepl(pattern, name)) 
[13:20:25.032]                               next
[13:20:25.032]                             invokeRestart(restart)
[13:20:25.032]                             muffled <- TRUE
[13:20:25.032]                             break
[13:20:25.032]                           }
[13:20:25.032]                         }
[13:20:25.032]                       }
[13:20:25.032]                       invisible(muffled)
[13:20:25.032]                     }
[13:20:25.032]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.032]                   }
[13:20:25.032]                 }
[13:20:25.032]             }
[13:20:25.032]         }))
[13:20:25.032]     }, error = function(ex) {
[13:20:25.032]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.032]                 ...future.rng), started = ...future.startTime, 
[13:20:25.032]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.032]             version = "1.8"), class = "FutureResult")
[13:20:25.032]     }, finally = {
[13:20:25.032]         if (!identical(...future.workdir, getwd())) 
[13:20:25.032]             setwd(...future.workdir)
[13:20:25.032]         {
[13:20:25.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.032]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.032]             }
[13:20:25.032]             base::options(...future.oldOptions)
[13:20:25.032]             if (.Platform$OS.type == "windows") {
[13:20:25.032]                 old_names <- names(...future.oldEnvVars)
[13:20:25.032]                 envs <- base::Sys.getenv()
[13:20:25.032]                 names <- names(envs)
[13:20:25.032]                 common <- intersect(names, old_names)
[13:20:25.032]                 added <- setdiff(names, old_names)
[13:20:25.032]                 removed <- setdiff(old_names, names)
[13:20:25.032]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.032]                   envs[common]]
[13:20:25.032]                 NAMES <- toupper(changed)
[13:20:25.032]                 args <- list()
[13:20:25.032]                 for (kk in seq_along(NAMES)) {
[13:20:25.032]                   name <- changed[[kk]]
[13:20:25.032]                   NAME <- NAMES[[kk]]
[13:20:25.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.032]                     next
[13:20:25.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.032]                 }
[13:20:25.032]                 NAMES <- toupper(added)
[13:20:25.032]                 for (kk in seq_along(NAMES)) {
[13:20:25.032]                   name <- added[[kk]]
[13:20:25.032]                   NAME <- NAMES[[kk]]
[13:20:25.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.032]                     next
[13:20:25.032]                   args[[name]] <- ""
[13:20:25.032]                 }
[13:20:25.032]                 NAMES <- toupper(removed)
[13:20:25.032]                 for (kk in seq_along(NAMES)) {
[13:20:25.032]                   name <- removed[[kk]]
[13:20:25.032]                   NAME <- NAMES[[kk]]
[13:20:25.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.032]                     next
[13:20:25.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.032]                 }
[13:20:25.032]                 if (length(args) > 0) 
[13:20:25.032]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.032]             }
[13:20:25.032]             else {
[13:20:25.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.032]             }
[13:20:25.032]             {
[13:20:25.032]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.032]                   0L) {
[13:20:25.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.032]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.032]                   base::options(opts)
[13:20:25.032]                 }
[13:20:25.032]                 {
[13:20:25.032]                   {
[13:20:25.032]                     NULL
[13:20:25.032]                     RNGkind("Mersenne-Twister")
[13:20:25.032]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.032]                       inherits = FALSE)
[13:20:25.032]                   }
[13:20:25.032]                   options(future.plan = NULL)
[13:20:25.032]                   if (is.na(NA_character_)) 
[13:20:25.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.032]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.032]                   {
[13:20:25.032]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.032]                     if (!future$lazy) 
[13:20:25.032]                       future <- run(future)
[13:20:25.032]                     invisible(future)
[13:20:25.032]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.032]                 }
[13:20:25.032]             }
[13:20:25.032]         }
[13:20:25.032]     })
[13:20:25.032]     if (TRUE) {
[13:20:25.032]         base::sink(type = "output", split = FALSE)
[13:20:25.032]         if (TRUE) {
[13:20:25.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.032]         }
[13:20:25.032]         else {
[13:20:25.032]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.032]         }
[13:20:25.032]         base::close(...future.stdout)
[13:20:25.032]         ...future.stdout <- NULL
[13:20:25.032]     }
[13:20:25.032]     ...future.result$conditions <- ...future.conditions
[13:20:25.032]     ...future.result$finished <- base::Sys.time()
[13:20:25.032]     ...future.result
[13:20:25.032] }
[13:20:25.034] plan(): Setting new future strategy stack:
[13:20:25.034] List of future strategies:
[13:20:25.034] 1. sequential:
[13:20:25.034]    - args: function (..., envir = parent.frame())
[13:20:25.034]    - tweaked: FALSE
[13:20:25.034]    - call: NULL
[13:20:25.034] plan(): nbrOfWorkers() = 1
[13:20:25.035] plan(): Setting new future strategy stack:
[13:20:25.035] List of future strategies:
[13:20:25.035] 1. sequential:
[13:20:25.035]    - args: function (..., envir = parent.frame())
[13:20:25.035]    - tweaked: FALSE
[13:20:25.035]    - call: plan(strategy)
[13:20:25.036] plan(): nbrOfWorkers() = 1
[13:20:25.036] SequentialFuture started (and completed)
[13:20:25.036] - Launch lazy future ... done
[13:20:25.036] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659b67ce50> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659bca3258> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659b67ce50> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659bca3258> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:20:25.043] resolved() for ‘SequentialFuture’ ...
[13:20:25.043] - state: ‘finished’
[13:20:25.043] - run: TRUE
[13:20:25.043] - result: ‘FutureResult’
[13:20:25.043] resolved() for ‘SequentialFuture’ ... done
[13:20:25.043] resolved() for ‘SequentialFuture’ ...
[13:20:25.044] - state: ‘finished’
[13:20:25.044] - run: TRUE
[13:20:25.044] - result: ‘FutureResult’
[13:20:25.044] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:25.046] resolve() on list ...
[13:20:25.046]  recursive: 0
[13:20:25.046]  length: 6
[13:20:25.046]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:25.046] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.046] - nx: 6
[13:20:25.046] - relay: TRUE
[13:20:25.046] - stdout: TRUE
[13:20:25.046] - signal: TRUE
[13:20:25.047] - resignal: FALSE
[13:20:25.047] - force: TRUE
[13:20:25.047] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.047] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.047]  - until=2
[13:20:25.047]  - relaying element #2
[13:20:25.047] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.047] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.047] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.047]  length: 5 (resolved future 1)
[13:20:25.047] resolved() for ‘SequentialFuture’ ...
[13:20:25.048] - state: ‘finished’
[13:20:25.048] - run: TRUE
[13:20:25.048] - result: ‘FutureResult’
[13:20:25.048] resolved() for ‘SequentialFuture’ ... done
[13:20:25.048] Future #2
[13:20:25.048] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.048] - nx: 6
[13:20:25.048] - relay: TRUE
[13:20:25.048] - stdout: TRUE
[13:20:25.048] - signal: TRUE
[13:20:25.049] - resignal: FALSE
[13:20:25.049] - force: TRUE
[13:20:25.049] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.049] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.049]  - until=2
[13:20:25.049]  - relaying element #2
[13:20:25.049] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.049] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.049] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.050]  length: 4 (resolved future 2)
[13:20:25.050] resolved() for ‘SequentialFuture’ ...
[13:20:25.050] - state: ‘finished’
[13:20:25.050] - run: TRUE
[13:20:25.050] - result: ‘FutureResult’
[13:20:25.050] resolved() for ‘SequentialFuture’ ... done
[13:20:25.050] Future #3
[13:20:25.050] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.050] - nx: 6
[13:20:25.050] - relay: TRUE
[13:20:25.050] - stdout: TRUE
[13:20:25.051] - signal: TRUE
[13:20:25.051] - resignal: FALSE
[13:20:25.051] - force: TRUE
[13:20:25.051] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.051] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.051]  - until=3
[13:20:25.051]  - relaying element #3
[13:20:25.051] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.051] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.051] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.052]  length: 3 (resolved future 3)
[13:20:25.052] signalConditionsASAP(NULL, pos=4) ...
[13:20:25.052] - nx: 6
[13:20:25.052] - relay: TRUE
[13:20:25.052] - stdout: TRUE
[13:20:25.052] - signal: TRUE
[13:20:25.052] - resignal: FALSE
[13:20:25.052] - force: TRUE
[13:20:25.052] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.052] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.052]  - until=5
[13:20:25.053]  - relaying element #5
[13:20:25.053] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.053] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.053] signalConditionsASAP(NULL, pos=4) ... done
[13:20:25.053]  length: 2 (resolved future 4)
[13:20:25.053] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.053] - nx: 6
[13:20:25.053] - relay: TRUE
[13:20:25.053] - stdout: TRUE
[13:20:25.053] - signal: TRUE
[13:20:25.053] - resignal: FALSE
[13:20:25.053] - force: TRUE
[13:20:25.054] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.054] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.054]  - until=6
[13:20:25.054]  - relaying element #6
[13:20:25.054] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.054] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.054] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.054]  length: 1 (resolved future 5)
[13:20:25.054] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.054] - nx: 6
[13:20:25.054] - relay: TRUE
[13:20:25.054] - stdout: TRUE
[13:20:25.055] - signal: TRUE
[13:20:25.055] - resignal: FALSE
[13:20:25.055] - force: TRUE
[13:20:25.055] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.055] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.055]  - until=6
[13:20:25.055] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.055] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.055] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.055]  length: 0 (resolved future 6)
[13:20:25.055] Relaying remaining futures
[13:20:25.056] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.056] - nx: 6
[13:20:25.056] - relay: TRUE
[13:20:25.056] - stdout: TRUE
[13:20:25.056] - signal: TRUE
[13:20:25.056] - resignal: FALSE
[13:20:25.056] - force: TRUE
[13:20:25.056] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.056] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:25.056] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.056] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.056] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.057] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:20:25.060] getGlobalsAndPackages() ...
[13:20:25.060] Searching for globals...
[13:20:25.060] 
[13:20:25.061] Searching for globals ... DONE
[13:20:25.061] - globals: [0] <none>
[13:20:25.061] getGlobalsAndPackages() ... DONE
[13:20:25.061] run() for ‘Future’ ...
[13:20:25.061] - state: ‘created’
[13:20:25.061] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.061] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.062]   - Field: ‘label’
[13:20:25.062]   - Field: ‘local’
[13:20:25.062]   - Field: ‘owner’
[13:20:25.062]   - Field: ‘envir’
[13:20:25.062]   - Field: ‘packages’
[13:20:25.062]   - Field: ‘gc’
[13:20:25.062]   - Field: ‘conditions’
[13:20:25.062]   - Field: ‘expr’
[13:20:25.062]   - Field: ‘uuid’
[13:20:25.063]   - Field: ‘seed’
[13:20:25.063]   - Field: ‘version’
[13:20:25.063]   - Field: ‘result’
[13:20:25.063]   - Field: ‘asynchronous’
[13:20:25.063]   - Field: ‘calls’
[13:20:25.063]   - Field: ‘globals’
[13:20:25.063]   - Field: ‘stdout’
[13:20:25.063]   - Field: ‘earlySignal’
[13:20:25.063]   - Field: ‘lazy’
[13:20:25.063]   - Field: ‘state’
[13:20:25.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.064] - Launch lazy future ...
[13:20:25.064] Packages needed by the future expression (n = 0): <none>
[13:20:25.064] Packages needed by future strategies (n = 0): <none>
[13:20:25.064] {
[13:20:25.064]     {
[13:20:25.064]         {
[13:20:25.064]             ...future.startTime <- base::Sys.time()
[13:20:25.064]             {
[13:20:25.064]                 {
[13:20:25.064]                   {
[13:20:25.064]                     base::local({
[13:20:25.064]                       has_future <- base::requireNamespace("future", 
[13:20:25.064]                         quietly = TRUE)
[13:20:25.064]                       if (has_future) {
[13:20:25.064]                         ns <- base::getNamespace("future")
[13:20:25.064]                         version <- ns[[".package"]][["version"]]
[13:20:25.064]                         if (is.null(version)) 
[13:20:25.064]                           version <- utils::packageVersion("future")
[13:20:25.064]                       }
[13:20:25.064]                       else {
[13:20:25.064]                         version <- NULL
[13:20:25.064]                       }
[13:20:25.064]                       if (!has_future || version < "1.8.0") {
[13:20:25.064]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.064]                           "", base::R.version$version.string), 
[13:20:25.064]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.064]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.064]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.064]                             "release", "version")], collapse = " "), 
[13:20:25.064]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.064]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.064]                           info)
[13:20:25.064]                         info <- base::paste(info, collapse = "; ")
[13:20:25.064]                         if (!has_future) {
[13:20:25.064]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.064]                             info)
[13:20:25.064]                         }
[13:20:25.064]                         else {
[13:20:25.064]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.064]                             info, version)
[13:20:25.064]                         }
[13:20:25.064]                         base::stop(msg)
[13:20:25.064]                       }
[13:20:25.064]                     })
[13:20:25.064]                   }
[13:20:25.064]                   options(future.plan = NULL)
[13:20:25.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.064]                 }
[13:20:25.064]                 ...future.workdir <- getwd()
[13:20:25.064]             }
[13:20:25.064]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.064]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.064]         }
[13:20:25.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.064]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.064]             base::names(...future.oldOptions))
[13:20:25.064]     }
[13:20:25.064]     if (FALSE) {
[13:20:25.064]     }
[13:20:25.064]     else {
[13:20:25.064]         if (TRUE) {
[13:20:25.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.064]                 open = "w")
[13:20:25.064]         }
[13:20:25.064]         else {
[13:20:25.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.064]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.064]         }
[13:20:25.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.064]             base::sink(type = "output", split = FALSE)
[13:20:25.064]             base::close(...future.stdout)
[13:20:25.064]         }, add = TRUE)
[13:20:25.064]     }
[13:20:25.064]     ...future.frame <- base::sys.nframe()
[13:20:25.064]     ...future.conditions <- base::list()
[13:20:25.064]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.064]     if (FALSE) {
[13:20:25.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.064]     }
[13:20:25.064]     ...future.result <- base::tryCatch({
[13:20:25.064]         base::withCallingHandlers({
[13:20:25.064]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.064]             future::FutureResult(value = ...future.value$value, 
[13:20:25.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.064]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.064]                     ...future.globalenv.names))
[13:20:25.064]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.064]         }, condition = base::local({
[13:20:25.064]             c <- base::c
[13:20:25.064]             inherits <- base::inherits
[13:20:25.064]             invokeRestart <- base::invokeRestart
[13:20:25.064]             length <- base::length
[13:20:25.064]             list <- base::list
[13:20:25.064]             seq.int <- base::seq.int
[13:20:25.064]             signalCondition <- base::signalCondition
[13:20:25.064]             sys.calls <- base::sys.calls
[13:20:25.064]             `[[` <- base::`[[`
[13:20:25.064]             `+` <- base::`+`
[13:20:25.064]             `<<-` <- base::`<<-`
[13:20:25.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.064]                   3L)]
[13:20:25.064]             }
[13:20:25.064]             function(cond) {
[13:20:25.064]                 is_error <- inherits(cond, "error")
[13:20:25.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.064]                   NULL)
[13:20:25.064]                 if (is_error) {
[13:20:25.064]                   sessionInformation <- function() {
[13:20:25.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.064]                       search = base::search(), system = base::Sys.info())
[13:20:25.064]                   }
[13:20:25.064]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.064]                     cond$call), session = sessionInformation(), 
[13:20:25.064]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.064]                   signalCondition(cond)
[13:20:25.064]                 }
[13:20:25.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.064]                 "immediateCondition"))) {
[13:20:25.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.064]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.064]                   if (TRUE && !signal) {
[13:20:25.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.064]                     {
[13:20:25.064]                       inherits <- base::inherits
[13:20:25.064]                       invokeRestart <- base::invokeRestart
[13:20:25.064]                       is.null <- base::is.null
[13:20:25.064]                       muffled <- FALSE
[13:20:25.064]                       if (inherits(cond, "message")) {
[13:20:25.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.064]                         if (muffled) 
[13:20:25.064]                           invokeRestart("muffleMessage")
[13:20:25.064]                       }
[13:20:25.064]                       else if (inherits(cond, "warning")) {
[13:20:25.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.064]                         if (muffled) 
[13:20:25.064]                           invokeRestart("muffleWarning")
[13:20:25.064]                       }
[13:20:25.064]                       else if (inherits(cond, "condition")) {
[13:20:25.064]                         if (!is.null(pattern)) {
[13:20:25.064]                           computeRestarts <- base::computeRestarts
[13:20:25.064]                           grepl <- base::grepl
[13:20:25.064]                           restarts <- computeRestarts(cond)
[13:20:25.064]                           for (restart in restarts) {
[13:20:25.064]                             name <- restart$name
[13:20:25.064]                             if (is.null(name)) 
[13:20:25.064]                               next
[13:20:25.064]                             if (!grepl(pattern, name)) 
[13:20:25.064]                               next
[13:20:25.064]                             invokeRestart(restart)
[13:20:25.064]                             muffled <- TRUE
[13:20:25.064]                             break
[13:20:25.064]                           }
[13:20:25.064]                         }
[13:20:25.064]                       }
[13:20:25.064]                       invisible(muffled)
[13:20:25.064]                     }
[13:20:25.064]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.064]                   }
[13:20:25.064]                 }
[13:20:25.064]                 else {
[13:20:25.064]                   if (TRUE) {
[13:20:25.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.064]                     {
[13:20:25.064]                       inherits <- base::inherits
[13:20:25.064]                       invokeRestart <- base::invokeRestart
[13:20:25.064]                       is.null <- base::is.null
[13:20:25.064]                       muffled <- FALSE
[13:20:25.064]                       if (inherits(cond, "message")) {
[13:20:25.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.064]                         if (muffled) 
[13:20:25.064]                           invokeRestart("muffleMessage")
[13:20:25.064]                       }
[13:20:25.064]                       else if (inherits(cond, "warning")) {
[13:20:25.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.064]                         if (muffled) 
[13:20:25.064]                           invokeRestart("muffleWarning")
[13:20:25.064]                       }
[13:20:25.064]                       else if (inherits(cond, "condition")) {
[13:20:25.064]                         if (!is.null(pattern)) {
[13:20:25.064]                           computeRestarts <- base::computeRestarts
[13:20:25.064]                           grepl <- base::grepl
[13:20:25.064]                           restarts <- computeRestarts(cond)
[13:20:25.064]                           for (restart in restarts) {
[13:20:25.064]                             name <- restart$name
[13:20:25.064]                             if (is.null(name)) 
[13:20:25.064]                               next
[13:20:25.064]                             if (!grepl(pattern, name)) 
[13:20:25.064]                               next
[13:20:25.064]                             invokeRestart(restart)
[13:20:25.064]                             muffled <- TRUE
[13:20:25.064]                             break
[13:20:25.064]                           }
[13:20:25.064]                         }
[13:20:25.064]                       }
[13:20:25.064]                       invisible(muffled)
[13:20:25.064]                     }
[13:20:25.064]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.064]                   }
[13:20:25.064]                 }
[13:20:25.064]             }
[13:20:25.064]         }))
[13:20:25.064]     }, error = function(ex) {
[13:20:25.064]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.064]                 ...future.rng), started = ...future.startTime, 
[13:20:25.064]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.064]             version = "1.8"), class = "FutureResult")
[13:20:25.064]     }, finally = {
[13:20:25.064]         if (!identical(...future.workdir, getwd())) 
[13:20:25.064]             setwd(...future.workdir)
[13:20:25.064]         {
[13:20:25.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.064]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.064]             }
[13:20:25.064]             base::options(...future.oldOptions)
[13:20:25.064]             if (.Platform$OS.type == "windows") {
[13:20:25.064]                 old_names <- names(...future.oldEnvVars)
[13:20:25.064]                 envs <- base::Sys.getenv()
[13:20:25.064]                 names <- names(envs)
[13:20:25.064]                 common <- intersect(names, old_names)
[13:20:25.064]                 added <- setdiff(names, old_names)
[13:20:25.064]                 removed <- setdiff(old_names, names)
[13:20:25.064]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.064]                   envs[common]]
[13:20:25.064]                 NAMES <- toupper(changed)
[13:20:25.064]                 args <- list()
[13:20:25.064]                 for (kk in seq_along(NAMES)) {
[13:20:25.064]                   name <- changed[[kk]]
[13:20:25.064]                   NAME <- NAMES[[kk]]
[13:20:25.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.064]                     next
[13:20:25.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.064]                 }
[13:20:25.064]                 NAMES <- toupper(added)
[13:20:25.064]                 for (kk in seq_along(NAMES)) {
[13:20:25.064]                   name <- added[[kk]]
[13:20:25.064]                   NAME <- NAMES[[kk]]
[13:20:25.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.064]                     next
[13:20:25.064]                   args[[name]] <- ""
[13:20:25.064]                 }
[13:20:25.064]                 NAMES <- toupper(removed)
[13:20:25.064]                 for (kk in seq_along(NAMES)) {
[13:20:25.064]                   name <- removed[[kk]]
[13:20:25.064]                   NAME <- NAMES[[kk]]
[13:20:25.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.064]                     next
[13:20:25.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.064]                 }
[13:20:25.064]                 if (length(args) > 0) 
[13:20:25.064]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.064]             }
[13:20:25.064]             else {
[13:20:25.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.064]             }
[13:20:25.064]             {
[13:20:25.064]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.064]                   0L) {
[13:20:25.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.064]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.064]                   base::options(opts)
[13:20:25.064]                 }
[13:20:25.064]                 {
[13:20:25.064]                   {
[13:20:25.064]                     NULL
[13:20:25.064]                     RNGkind("Mersenne-Twister")
[13:20:25.064]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.064]                       inherits = FALSE)
[13:20:25.064]                   }
[13:20:25.064]                   options(future.plan = NULL)
[13:20:25.064]                   if (is.na(NA_character_)) 
[13:20:25.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.064]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.064]                   {
[13:20:25.064]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.064]                     if (!future$lazy) 
[13:20:25.064]                       future <- run(future)
[13:20:25.064]                     invisible(future)
[13:20:25.064]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.064]                 }
[13:20:25.064]             }
[13:20:25.064]         }
[13:20:25.064]     })
[13:20:25.064]     if (TRUE) {
[13:20:25.064]         base::sink(type = "output", split = FALSE)
[13:20:25.064]         if (TRUE) {
[13:20:25.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.064]         }
[13:20:25.064]         else {
[13:20:25.064]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.064]         }
[13:20:25.064]         base::close(...future.stdout)
[13:20:25.064]         ...future.stdout <- NULL
[13:20:25.064]     }
[13:20:25.064]     ...future.result$conditions <- ...future.conditions
[13:20:25.064]     ...future.result$finished <- base::Sys.time()
[13:20:25.064]     ...future.result
[13:20:25.064] }
[13:20:25.068] plan(): Setting new future strategy stack:
[13:20:25.068] List of future strategies:
[13:20:25.068] 1. sequential:
[13:20:25.068]    - args: function (..., envir = parent.frame())
[13:20:25.068]    - tweaked: FALSE
[13:20:25.068]    - call: NULL
[13:20:25.068] plan(): nbrOfWorkers() = 1
[13:20:25.069] plan(): Setting new future strategy stack:
[13:20:25.069] List of future strategies:
[13:20:25.069] 1. sequential:
[13:20:25.069]    - args: function (..., envir = parent.frame())
[13:20:25.069]    - tweaked: FALSE
[13:20:25.069]    - call: plan(strategy)
[13:20:25.070] plan(): nbrOfWorkers() = 1
[13:20:25.070] SequentialFuture started (and completed)
[13:20:25.070] - Launch lazy future ... done
[13:20:25.070] run() for ‘SequentialFuture’ ... done
[13:20:25.070] getGlobalsAndPackages() ...
[13:20:25.070] Searching for globals...
[13:20:25.071] 
[13:20:25.071] Searching for globals ... DONE
[13:20:25.071] - globals: [0] <none>
[13:20:25.071] getGlobalsAndPackages() ... DONE
[13:20:25.071] run() for ‘Future’ ...
[13:20:25.071] - state: ‘created’
[13:20:25.071] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.072] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.072] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.072]   - Field: ‘label’
[13:20:25.072]   - Field: ‘local’
[13:20:25.072]   - Field: ‘owner’
[13:20:25.072]   - Field: ‘envir’
[13:20:25.072]   - Field: ‘packages’
[13:20:25.072]   - Field: ‘gc’
[13:20:25.072]   - Field: ‘conditions’
[13:20:25.073]   - Field: ‘expr’
[13:20:25.073]   - Field: ‘uuid’
[13:20:25.073]   - Field: ‘seed’
[13:20:25.073]   - Field: ‘version’
[13:20:25.073]   - Field: ‘result’
[13:20:25.073]   - Field: ‘asynchronous’
[13:20:25.073]   - Field: ‘calls’
[13:20:25.073]   - Field: ‘globals’
[13:20:25.073]   - Field: ‘stdout’
[13:20:25.073]   - Field: ‘earlySignal’
[13:20:25.074]   - Field: ‘lazy’
[13:20:25.074]   - Field: ‘state’
[13:20:25.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.074] - Launch lazy future ...
[13:20:25.074] Packages needed by the future expression (n = 0): <none>
[13:20:25.074] Packages needed by future strategies (n = 0): <none>
[13:20:25.075] {
[13:20:25.075]     {
[13:20:25.075]         {
[13:20:25.075]             ...future.startTime <- base::Sys.time()
[13:20:25.075]             {
[13:20:25.075]                 {
[13:20:25.075]                   {
[13:20:25.075]                     base::local({
[13:20:25.075]                       has_future <- base::requireNamespace("future", 
[13:20:25.075]                         quietly = TRUE)
[13:20:25.075]                       if (has_future) {
[13:20:25.075]                         ns <- base::getNamespace("future")
[13:20:25.075]                         version <- ns[[".package"]][["version"]]
[13:20:25.075]                         if (is.null(version)) 
[13:20:25.075]                           version <- utils::packageVersion("future")
[13:20:25.075]                       }
[13:20:25.075]                       else {
[13:20:25.075]                         version <- NULL
[13:20:25.075]                       }
[13:20:25.075]                       if (!has_future || version < "1.8.0") {
[13:20:25.075]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.075]                           "", base::R.version$version.string), 
[13:20:25.075]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.075]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.075]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.075]                             "release", "version")], collapse = " "), 
[13:20:25.075]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.075]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.075]                           info)
[13:20:25.075]                         info <- base::paste(info, collapse = "; ")
[13:20:25.075]                         if (!has_future) {
[13:20:25.075]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.075]                             info)
[13:20:25.075]                         }
[13:20:25.075]                         else {
[13:20:25.075]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.075]                             info, version)
[13:20:25.075]                         }
[13:20:25.075]                         base::stop(msg)
[13:20:25.075]                       }
[13:20:25.075]                     })
[13:20:25.075]                   }
[13:20:25.075]                   options(future.plan = NULL)
[13:20:25.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.075]                 }
[13:20:25.075]                 ...future.workdir <- getwd()
[13:20:25.075]             }
[13:20:25.075]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.075]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.075]         }
[13:20:25.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.075]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.075]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.075]             base::names(...future.oldOptions))
[13:20:25.075]     }
[13:20:25.075]     if (FALSE) {
[13:20:25.075]     }
[13:20:25.075]     else {
[13:20:25.075]         if (TRUE) {
[13:20:25.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.075]                 open = "w")
[13:20:25.075]         }
[13:20:25.075]         else {
[13:20:25.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.075]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.075]         }
[13:20:25.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.075]             base::sink(type = "output", split = FALSE)
[13:20:25.075]             base::close(...future.stdout)
[13:20:25.075]         }, add = TRUE)
[13:20:25.075]     }
[13:20:25.075]     ...future.frame <- base::sys.nframe()
[13:20:25.075]     ...future.conditions <- base::list()
[13:20:25.075]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.075]     if (FALSE) {
[13:20:25.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.075]     }
[13:20:25.075]     ...future.result <- base::tryCatch({
[13:20:25.075]         base::withCallingHandlers({
[13:20:25.075]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.075]             future::FutureResult(value = ...future.value$value, 
[13:20:25.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.075]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.075]                     ...future.globalenv.names))
[13:20:25.075]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.075]         }, condition = base::local({
[13:20:25.075]             c <- base::c
[13:20:25.075]             inherits <- base::inherits
[13:20:25.075]             invokeRestart <- base::invokeRestart
[13:20:25.075]             length <- base::length
[13:20:25.075]             list <- base::list
[13:20:25.075]             seq.int <- base::seq.int
[13:20:25.075]             signalCondition <- base::signalCondition
[13:20:25.075]             sys.calls <- base::sys.calls
[13:20:25.075]             `[[` <- base::`[[`
[13:20:25.075]             `+` <- base::`+`
[13:20:25.075]             `<<-` <- base::`<<-`
[13:20:25.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.075]                   3L)]
[13:20:25.075]             }
[13:20:25.075]             function(cond) {
[13:20:25.075]                 is_error <- inherits(cond, "error")
[13:20:25.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.075]                   NULL)
[13:20:25.075]                 if (is_error) {
[13:20:25.075]                   sessionInformation <- function() {
[13:20:25.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.075]                       search = base::search(), system = base::Sys.info())
[13:20:25.075]                   }
[13:20:25.075]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.075]                     cond$call), session = sessionInformation(), 
[13:20:25.075]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.075]                   signalCondition(cond)
[13:20:25.075]                 }
[13:20:25.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.075]                 "immediateCondition"))) {
[13:20:25.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.075]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.075]                   if (TRUE && !signal) {
[13:20:25.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.075]                     {
[13:20:25.075]                       inherits <- base::inherits
[13:20:25.075]                       invokeRestart <- base::invokeRestart
[13:20:25.075]                       is.null <- base::is.null
[13:20:25.075]                       muffled <- FALSE
[13:20:25.075]                       if (inherits(cond, "message")) {
[13:20:25.075]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.075]                         if (muffled) 
[13:20:25.075]                           invokeRestart("muffleMessage")
[13:20:25.075]                       }
[13:20:25.075]                       else if (inherits(cond, "warning")) {
[13:20:25.075]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.075]                         if (muffled) 
[13:20:25.075]                           invokeRestart("muffleWarning")
[13:20:25.075]                       }
[13:20:25.075]                       else if (inherits(cond, "condition")) {
[13:20:25.075]                         if (!is.null(pattern)) {
[13:20:25.075]                           computeRestarts <- base::computeRestarts
[13:20:25.075]                           grepl <- base::grepl
[13:20:25.075]                           restarts <- computeRestarts(cond)
[13:20:25.075]                           for (restart in restarts) {
[13:20:25.075]                             name <- restart$name
[13:20:25.075]                             if (is.null(name)) 
[13:20:25.075]                               next
[13:20:25.075]                             if (!grepl(pattern, name)) 
[13:20:25.075]                               next
[13:20:25.075]                             invokeRestart(restart)
[13:20:25.075]                             muffled <- TRUE
[13:20:25.075]                             break
[13:20:25.075]                           }
[13:20:25.075]                         }
[13:20:25.075]                       }
[13:20:25.075]                       invisible(muffled)
[13:20:25.075]                     }
[13:20:25.075]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.075]                   }
[13:20:25.075]                 }
[13:20:25.075]                 else {
[13:20:25.075]                   if (TRUE) {
[13:20:25.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.075]                     {
[13:20:25.075]                       inherits <- base::inherits
[13:20:25.075]                       invokeRestart <- base::invokeRestart
[13:20:25.075]                       is.null <- base::is.null
[13:20:25.075]                       muffled <- FALSE
[13:20:25.075]                       if (inherits(cond, "message")) {
[13:20:25.075]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.075]                         if (muffled) 
[13:20:25.075]                           invokeRestart("muffleMessage")
[13:20:25.075]                       }
[13:20:25.075]                       else if (inherits(cond, "warning")) {
[13:20:25.075]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.075]                         if (muffled) 
[13:20:25.075]                           invokeRestart("muffleWarning")
[13:20:25.075]                       }
[13:20:25.075]                       else if (inherits(cond, "condition")) {
[13:20:25.075]                         if (!is.null(pattern)) {
[13:20:25.075]                           computeRestarts <- base::computeRestarts
[13:20:25.075]                           grepl <- base::grepl
[13:20:25.075]                           restarts <- computeRestarts(cond)
[13:20:25.075]                           for (restart in restarts) {
[13:20:25.075]                             name <- restart$name
[13:20:25.075]                             if (is.null(name)) 
[13:20:25.075]                               next
[13:20:25.075]                             if (!grepl(pattern, name)) 
[13:20:25.075]                               next
[13:20:25.075]                             invokeRestart(restart)
[13:20:25.075]                             muffled <- TRUE
[13:20:25.075]                             break
[13:20:25.075]                           }
[13:20:25.075]                         }
[13:20:25.075]                       }
[13:20:25.075]                       invisible(muffled)
[13:20:25.075]                     }
[13:20:25.075]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.075]                   }
[13:20:25.075]                 }
[13:20:25.075]             }
[13:20:25.075]         }))
[13:20:25.075]     }, error = function(ex) {
[13:20:25.075]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.075]                 ...future.rng), started = ...future.startTime, 
[13:20:25.075]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.075]             version = "1.8"), class = "FutureResult")
[13:20:25.075]     }, finally = {
[13:20:25.075]         if (!identical(...future.workdir, getwd())) 
[13:20:25.075]             setwd(...future.workdir)
[13:20:25.075]         {
[13:20:25.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.075]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.075]             }
[13:20:25.075]             base::options(...future.oldOptions)
[13:20:25.075]             if (.Platform$OS.type == "windows") {
[13:20:25.075]                 old_names <- names(...future.oldEnvVars)
[13:20:25.075]                 envs <- base::Sys.getenv()
[13:20:25.075]                 names <- names(envs)
[13:20:25.075]                 common <- intersect(names, old_names)
[13:20:25.075]                 added <- setdiff(names, old_names)
[13:20:25.075]                 removed <- setdiff(old_names, names)
[13:20:25.075]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.075]                   envs[common]]
[13:20:25.075]                 NAMES <- toupper(changed)
[13:20:25.075]                 args <- list()
[13:20:25.075]                 for (kk in seq_along(NAMES)) {
[13:20:25.075]                   name <- changed[[kk]]
[13:20:25.075]                   NAME <- NAMES[[kk]]
[13:20:25.075]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.075]                     next
[13:20:25.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.075]                 }
[13:20:25.075]                 NAMES <- toupper(added)
[13:20:25.075]                 for (kk in seq_along(NAMES)) {
[13:20:25.075]                   name <- added[[kk]]
[13:20:25.075]                   NAME <- NAMES[[kk]]
[13:20:25.075]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.075]                     next
[13:20:25.075]                   args[[name]] <- ""
[13:20:25.075]                 }
[13:20:25.075]                 NAMES <- toupper(removed)
[13:20:25.075]                 for (kk in seq_along(NAMES)) {
[13:20:25.075]                   name <- removed[[kk]]
[13:20:25.075]                   NAME <- NAMES[[kk]]
[13:20:25.075]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.075]                     next
[13:20:25.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.075]                 }
[13:20:25.075]                 if (length(args) > 0) 
[13:20:25.075]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.075]             }
[13:20:25.075]             else {
[13:20:25.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.075]             }
[13:20:25.075]             {
[13:20:25.075]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.075]                   0L) {
[13:20:25.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.075]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.075]                   base::options(opts)
[13:20:25.075]                 }
[13:20:25.075]                 {
[13:20:25.075]                   {
[13:20:25.075]                     NULL
[13:20:25.075]                     RNGkind("Mersenne-Twister")
[13:20:25.075]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.075]                       inherits = FALSE)
[13:20:25.075]                   }
[13:20:25.075]                   options(future.plan = NULL)
[13:20:25.075]                   if (is.na(NA_character_)) 
[13:20:25.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.075]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.075]                   {
[13:20:25.075]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.075]                     if (!future$lazy) 
[13:20:25.075]                       future <- run(future)
[13:20:25.075]                     invisible(future)
[13:20:25.075]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.075]                 }
[13:20:25.075]             }
[13:20:25.075]         }
[13:20:25.075]     })
[13:20:25.075]     if (TRUE) {
[13:20:25.075]         base::sink(type = "output", split = FALSE)
[13:20:25.075]         if (TRUE) {
[13:20:25.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.075]         }
[13:20:25.075]         else {
[13:20:25.075]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.075]         }
[13:20:25.075]         base::close(...future.stdout)
[13:20:25.075]         ...future.stdout <- NULL
[13:20:25.075]     }
[13:20:25.075]     ...future.result$conditions <- ...future.conditions
[13:20:25.075]     ...future.result$finished <- base::Sys.time()
[13:20:25.075]     ...future.result
[13:20:25.075] }
[13:20:25.076] plan(): Setting new future strategy stack:
[13:20:25.076] List of future strategies:
[13:20:25.076] 1. sequential:
[13:20:25.076]    - args: function (..., envir = parent.frame())
[13:20:25.076]    - tweaked: FALSE
[13:20:25.076]    - call: NULL
[13:20:25.077] plan(): nbrOfWorkers() = 1
[13:20:25.077] plan(): Setting new future strategy stack:
[13:20:25.078] List of future strategies:
[13:20:25.078] 1. sequential:
[13:20:25.078]    - args: function (..., envir = parent.frame())
[13:20:25.078]    - tweaked: FALSE
[13:20:25.078]    - call: plan(strategy)
[13:20:25.078] plan(): nbrOfWorkers() = 1
[13:20:25.078] SequentialFuture started (and completed)
[13:20:25.078] - Launch lazy future ... done
[13:20:25.078] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659bf1e990> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659a5ff948> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659bf1e990> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55659a5ff948> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:20:25.084] resolved() for ‘SequentialFuture’ ...
[13:20:25.084] - state: ‘finished’
[13:20:25.084] - run: TRUE
[13:20:25.084] - result: ‘FutureResult’
[13:20:25.084] resolved() for ‘SequentialFuture’ ... done
[13:20:25.084] resolved() for ‘SequentialFuture’ ...
[13:20:25.084] - state: ‘finished’
[13:20:25.085] - run: TRUE
[13:20:25.085] - result: ‘FutureResult’
[13:20:25.085] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:25.087] resolve() on list ...
[13:20:25.087]  recursive: 0
[13:20:25.087]  length: 6
[13:20:25.087]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:25.087] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.087] - nx: 6
[13:20:25.087] - relay: TRUE
[13:20:25.087] - stdout: TRUE
[13:20:25.087] - signal: TRUE
[13:20:25.088] - resignal: FALSE
[13:20:25.088] - force: TRUE
[13:20:25.088] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.088] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.088]  - until=2
[13:20:25.088]  - relaying element #2
[13:20:25.088] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.088] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.088] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.088]  length: 5 (resolved future 1)
[13:20:25.088] resolved() for ‘SequentialFuture’ ...
[13:20:25.089] - state: ‘finished’
[13:20:25.089] - run: TRUE
[13:20:25.089] - result: ‘FutureResult’
[13:20:25.089] resolved() for ‘SequentialFuture’ ... done
[13:20:25.089] Future #2
[13:20:25.089] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.089] - nx: 6
[13:20:25.089] - relay: TRUE
[13:20:25.089] - stdout: TRUE
[13:20:25.089] - signal: TRUE
[13:20:25.090] - resignal: FALSE
[13:20:25.090] - force: TRUE
[13:20:25.090] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.090] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.090]  - until=2
[13:20:25.090]  - relaying element #2
[13:20:25.090] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.090] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.090] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.090]  length: 4 (resolved future 2)
[13:20:25.091] resolved() for ‘SequentialFuture’ ...
[13:20:25.091] - state: ‘finished’
[13:20:25.091] - run: TRUE
[13:20:25.091] - result: ‘FutureResult’
[13:20:25.091] resolved() for ‘SequentialFuture’ ... done
[13:20:25.091] Future #3
[13:20:25.091] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.091] - nx: 6
[13:20:25.091] - relay: TRUE
[13:20:25.091] - stdout: TRUE
[13:20:25.092] - signal: TRUE
[13:20:25.092] - resignal: FALSE
[13:20:25.092] - force: TRUE
[13:20:25.092] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.092] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.092]  - until=3
[13:20:25.092]  - relaying element #3
[13:20:25.092] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.092] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.092] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.092]  length: 3 (resolved future 3)
[13:20:25.093] signalConditionsASAP(NULL, pos=4) ...
[13:20:25.093] - nx: 6
[13:20:25.093] - relay: TRUE
[13:20:25.093] - stdout: TRUE
[13:20:25.093] - signal: TRUE
[13:20:25.093] - resignal: FALSE
[13:20:25.093] - force: TRUE
[13:20:25.093] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.093] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.093]  - until=5
[13:20:25.093]  - relaying element #5
[13:20:25.094] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.094] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.094] signalConditionsASAP(NULL, pos=4) ... done
[13:20:25.094]  length: 2 (resolved future 4)
[13:20:25.094] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.094] - nx: 6
[13:20:25.094] - relay: TRUE
[13:20:25.094] - stdout: TRUE
[13:20:25.094] - signal: TRUE
[13:20:25.094] - resignal: FALSE
[13:20:25.094] - force: TRUE
[13:20:25.094] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.095] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.095]  - until=6
[13:20:25.095]  - relaying element #6
[13:20:25.097] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.097] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.097] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.097]  length: 1 (resolved future 5)
[13:20:25.097] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.097] - nx: 6
[13:20:25.097] - relay: TRUE
[13:20:25.097] - stdout: TRUE
[13:20:25.097] - signal: TRUE
[13:20:25.098] - resignal: FALSE
[13:20:25.098] - force: TRUE
[13:20:25.098] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.098] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.098]  - until=6
[13:20:25.098] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.098] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.098] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.098]  length: 0 (resolved future 6)
[13:20:25.098] Relaying remaining futures
[13:20:25.098] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.099] - nx: 6
[13:20:25.099] - relay: TRUE
[13:20:25.099] - stdout: TRUE
[13:20:25.099] - signal: TRUE
[13:20:25.099] - resignal: FALSE
[13:20:25.099] - force: TRUE
[13:20:25.099] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.099] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:25.099] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.099] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.099] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.100] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[13:20:25.109] plan(): Setting new future strategy stack:
[13:20:25.109] List of future strategies:
[13:20:25.109] 1. sequential:
[13:20:25.109]    - args: function (..., envir = parent.frame())
[13:20:25.109]    - tweaked: FALSE
[13:20:25.109]    - call: plan(strategy)
[13:20:25.110] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[13:20:25.110] getGlobalsAndPackages() ...
[13:20:25.110] Searching for globals...
[13:20:25.111] 
[13:20:25.111] Searching for globals ... DONE
[13:20:25.111] - globals: [0] <none>
[13:20:25.111] getGlobalsAndPackages() ... DONE
[13:20:25.111] run() for ‘Future’ ...
[13:20:25.111] - state: ‘created’
[13:20:25.111] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.112] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.112] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.112]   - Field: ‘label’
[13:20:25.112]   - Field: ‘local’
[13:20:25.112]   - Field: ‘owner’
[13:20:25.112]   - Field: ‘envir’
[13:20:25.112]   - Field: ‘packages’
[13:20:25.112]   - Field: ‘gc’
[13:20:25.112]   - Field: ‘conditions’
[13:20:25.112]   - Field: ‘expr’
[13:20:25.113]   - Field: ‘uuid’
[13:20:25.113]   - Field: ‘seed’
[13:20:25.113]   - Field: ‘version’
[13:20:25.113]   - Field: ‘result’
[13:20:25.113]   - Field: ‘asynchronous’
[13:20:25.113]   - Field: ‘calls’
[13:20:25.113]   - Field: ‘globals’
[13:20:25.113]   - Field: ‘stdout’
[13:20:25.113]   - Field: ‘earlySignal’
[13:20:25.113]   - Field: ‘lazy’
[13:20:25.114]   - Field: ‘state’
[13:20:25.114] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.114] - Launch lazy future ...
[13:20:25.114] Packages needed by the future expression (n = 0): <none>
[13:20:25.114] Packages needed by future strategies (n = 0): <none>
[13:20:25.114] {
[13:20:25.114]     {
[13:20:25.114]         {
[13:20:25.114]             ...future.startTime <- base::Sys.time()
[13:20:25.114]             {
[13:20:25.114]                 {
[13:20:25.114]                   {
[13:20:25.114]                     base::local({
[13:20:25.114]                       has_future <- base::requireNamespace("future", 
[13:20:25.114]                         quietly = TRUE)
[13:20:25.114]                       if (has_future) {
[13:20:25.114]                         ns <- base::getNamespace("future")
[13:20:25.114]                         version <- ns[[".package"]][["version"]]
[13:20:25.114]                         if (is.null(version)) 
[13:20:25.114]                           version <- utils::packageVersion("future")
[13:20:25.114]                       }
[13:20:25.114]                       else {
[13:20:25.114]                         version <- NULL
[13:20:25.114]                       }
[13:20:25.114]                       if (!has_future || version < "1.8.0") {
[13:20:25.114]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.114]                           "", base::R.version$version.string), 
[13:20:25.114]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.114]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.114]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.114]                             "release", "version")], collapse = " "), 
[13:20:25.114]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.114]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.114]                           info)
[13:20:25.114]                         info <- base::paste(info, collapse = "; ")
[13:20:25.114]                         if (!has_future) {
[13:20:25.114]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.114]                             info)
[13:20:25.114]                         }
[13:20:25.114]                         else {
[13:20:25.114]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.114]                             info, version)
[13:20:25.114]                         }
[13:20:25.114]                         base::stop(msg)
[13:20:25.114]                       }
[13:20:25.114]                     })
[13:20:25.114]                   }
[13:20:25.114]                   options(future.plan = NULL)
[13:20:25.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.114]                 }
[13:20:25.114]                 ...future.workdir <- getwd()
[13:20:25.114]             }
[13:20:25.114]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.114]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.114]         }
[13:20:25.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.114]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.114]             base::names(...future.oldOptions))
[13:20:25.114]     }
[13:20:25.114]     if (FALSE) {
[13:20:25.114]     }
[13:20:25.114]     else {
[13:20:25.114]         if (TRUE) {
[13:20:25.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.114]                 open = "w")
[13:20:25.114]         }
[13:20:25.114]         else {
[13:20:25.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.114]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.114]         }
[13:20:25.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.114]             base::sink(type = "output", split = FALSE)
[13:20:25.114]             base::close(...future.stdout)
[13:20:25.114]         }, add = TRUE)
[13:20:25.114]     }
[13:20:25.114]     ...future.frame <- base::sys.nframe()
[13:20:25.114]     ...future.conditions <- base::list()
[13:20:25.114]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.114]     if (FALSE) {
[13:20:25.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.114]     }
[13:20:25.114]     ...future.result <- base::tryCatch({
[13:20:25.114]         base::withCallingHandlers({
[13:20:25.114]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.114]             future::FutureResult(value = ...future.value$value, 
[13:20:25.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.114]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.114]                     ...future.globalenv.names))
[13:20:25.114]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.114]         }, condition = base::local({
[13:20:25.114]             c <- base::c
[13:20:25.114]             inherits <- base::inherits
[13:20:25.114]             invokeRestart <- base::invokeRestart
[13:20:25.114]             length <- base::length
[13:20:25.114]             list <- base::list
[13:20:25.114]             seq.int <- base::seq.int
[13:20:25.114]             signalCondition <- base::signalCondition
[13:20:25.114]             sys.calls <- base::sys.calls
[13:20:25.114]             `[[` <- base::`[[`
[13:20:25.114]             `+` <- base::`+`
[13:20:25.114]             `<<-` <- base::`<<-`
[13:20:25.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.114]                   3L)]
[13:20:25.114]             }
[13:20:25.114]             function(cond) {
[13:20:25.114]                 is_error <- inherits(cond, "error")
[13:20:25.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.114]                   NULL)
[13:20:25.114]                 if (is_error) {
[13:20:25.114]                   sessionInformation <- function() {
[13:20:25.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.114]                       search = base::search(), system = base::Sys.info())
[13:20:25.114]                   }
[13:20:25.114]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.114]                     cond$call), session = sessionInformation(), 
[13:20:25.114]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.114]                   signalCondition(cond)
[13:20:25.114]                 }
[13:20:25.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.114]                 "immediateCondition"))) {
[13:20:25.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.114]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.114]                   if (TRUE && !signal) {
[13:20:25.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.114]                     {
[13:20:25.114]                       inherits <- base::inherits
[13:20:25.114]                       invokeRestart <- base::invokeRestart
[13:20:25.114]                       is.null <- base::is.null
[13:20:25.114]                       muffled <- FALSE
[13:20:25.114]                       if (inherits(cond, "message")) {
[13:20:25.114]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.114]                         if (muffled) 
[13:20:25.114]                           invokeRestart("muffleMessage")
[13:20:25.114]                       }
[13:20:25.114]                       else if (inherits(cond, "warning")) {
[13:20:25.114]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.114]                         if (muffled) 
[13:20:25.114]                           invokeRestart("muffleWarning")
[13:20:25.114]                       }
[13:20:25.114]                       else if (inherits(cond, "condition")) {
[13:20:25.114]                         if (!is.null(pattern)) {
[13:20:25.114]                           computeRestarts <- base::computeRestarts
[13:20:25.114]                           grepl <- base::grepl
[13:20:25.114]                           restarts <- computeRestarts(cond)
[13:20:25.114]                           for (restart in restarts) {
[13:20:25.114]                             name <- restart$name
[13:20:25.114]                             if (is.null(name)) 
[13:20:25.114]                               next
[13:20:25.114]                             if (!grepl(pattern, name)) 
[13:20:25.114]                               next
[13:20:25.114]                             invokeRestart(restart)
[13:20:25.114]                             muffled <- TRUE
[13:20:25.114]                             break
[13:20:25.114]                           }
[13:20:25.114]                         }
[13:20:25.114]                       }
[13:20:25.114]                       invisible(muffled)
[13:20:25.114]                     }
[13:20:25.114]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.114]                   }
[13:20:25.114]                 }
[13:20:25.114]                 else {
[13:20:25.114]                   if (TRUE) {
[13:20:25.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.114]                     {
[13:20:25.114]                       inherits <- base::inherits
[13:20:25.114]                       invokeRestart <- base::invokeRestart
[13:20:25.114]                       is.null <- base::is.null
[13:20:25.114]                       muffled <- FALSE
[13:20:25.114]                       if (inherits(cond, "message")) {
[13:20:25.114]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.114]                         if (muffled) 
[13:20:25.114]                           invokeRestart("muffleMessage")
[13:20:25.114]                       }
[13:20:25.114]                       else if (inherits(cond, "warning")) {
[13:20:25.114]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.114]                         if (muffled) 
[13:20:25.114]                           invokeRestart("muffleWarning")
[13:20:25.114]                       }
[13:20:25.114]                       else if (inherits(cond, "condition")) {
[13:20:25.114]                         if (!is.null(pattern)) {
[13:20:25.114]                           computeRestarts <- base::computeRestarts
[13:20:25.114]                           grepl <- base::grepl
[13:20:25.114]                           restarts <- computeRestarts(cond)
[13:20:25.114]                           for (restart in restarts) {
[13:20:25.114]                             name <- restart$name
[13:20:25.114]                             if (is.null(name)) 
[13:20:25.114]                               next
[13:20:25.114]                             if (!grepl(pattern, name)) 
[13:20:25.114]                               next
[13:20:25.114]                             invokeRestart(restart)
[13:20:25.114]                             muffled <- TRUE
[13:20:25.114]                             break
[13:20:25.114]                           }
[13:20:25.114]                         }
[13:20:25.114]                       }
[13:20:25.114]                       invisible(muffled)
[13:20:25.114]                     }
[13:20:25.114]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.114]                   }
[13:20:25.114]                 }
[13:20:25.114]             }
[13:20:25.114]         }))
[13:20:25.114]     }, error = function(ex) {
[13:20:25.114]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.114]                 ...future.rng), started = ...future.startTime, 
[13:20:25.114]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.114]             version = "1.8"), class = "FutureResult")
[13:20:25.114]     }, finally = {
[13:20:25.114]         if (!identical(...future.workdir, getwd())) 
[13:20:25.114]             setwd(...future.workdir)
[13:20:25.114]         {
[13:20:25.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.114]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.114]             }
[13:20:25.114]             base::options(...future.oldOptions)
[13:20:25.114]             if (.Platform$OS.type == "windows") {
[13:20:25.114]                 old_names <- names(...future.oldEnvVars)
[13:20:25.114]                 envs <- base::Sys.getenv()
[13:20:25.114]                 names <- names(envs)
[13:20:25.114]                 common <- intersect(names, old_names)
[13:20:25.114]                 added <- setdiff(names, old_names)
[13:20:25.114]                 removed <- setdiff(old_names, names)
[13:20:25.114]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.114]                   envs[common]]
[13:20:25.114]                 NAMES <- toupper(changed)
[13:20:25.114]                 args <- list()
[13:20:25.114]                 for (kk in seq_along(NAMES)) {
[13:20:25.114]                   name <- changed[[kk]]
[13:20:25.114]                   NAME <- NAMES[[kk]]
[13:20:25.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.114]                     next
[13:20:25.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.114]                 }
[13:20:25.114]                 NAMES <- toupper(added)
[13:20:25.114]                 for (kk in seq_along(NAMES)) {
[13:20:25.114]                   name <- added[[kk]]
[13:20:25.114]                   NAME <- NAMES[[kk]]
[13:20:25.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.114]                     next
[13:20:25.114]                   args[[name]] <- ""
[13:20:25.114]                 }
[13:20:25.114]                 NAMES <- toupper(removed)
[13:20:25.114]                 for (kk in seq_along(NAMES)) {
[13:20:25.114]                   name <- removed[[kk]]
[13:20:25.114]                   NAME <- NAMES[[kk]]
[13:20:25.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.114]                     next
[13:20:25.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.114]                 }
[13:20:25.114]                 if (length(args) > 0) 
[13:20:25.114]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.114]             }
[13:20:25.114]             else {
[13:20:25.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.114]             }
[13:20:25.114]             {
[13:20:25.114]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.114]                   0L) {
[13:20:25.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.114]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.114]                   base::options(opts)
[13:20:25.114]                 }
[13:20:25.114]                 {
[13:20:25.114]                   {
[13:20:25.114]                     NULL
[13:20:25.114]                     RNGkind("Mersenne-Twister")
[13:20:25.114]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.114]                       inherits = FALSE)
[13:20:25.114]                   }
[13:20:25.114]                   options(future.plan = NULL)
[13:20:25.114]                   if (is.na(NA_character_)) 
[13:20:25.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.114]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.114]                   {
[13:20:25.114]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.114]                     if (!future$lazy) 
[13:20:25.114]                       future <- run(future)
[13:20:25.114]                     invisible(future)
[13:20:25.114]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.114]                 }
[13:20:25.114]             }
[13:20:25.114]         }
[13:20:25.114]     })
[13:20:25.114]     if (TRUE) {
[13:20:25.114]         base::sink(type = "output", split = FALSE)
[13:20:25.114]         if (TRUE) {
[13:20:25.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.114]         }
[13:20:25.114]         else {
[13:20:25.114]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.114]         }
[13:20:25.114]         base::close(...future.stdout)
[13:20:25.114]         ...future.stdout <- NULL
[13:20:25.114]     }
[13:20:25.114]     ...future.result$conditions <- ...future.conditions
[13:20:25.114]     ...future.result$finished <- base::Sys.time()
[13:20:25.114]     ...future.result
[13:20:25.114] }
[13:20:25.116] plan(): Setting new future strategy stack:
[13:20:25.116] List of future strategies:
[13:20:25.116] 1. sequential:
[13:20:25.116]    - args: function (..., envir = parent.frame())
[13:20:25.116]    - tweaked: FALSE
[13:20:25.116]    - call: NULL
[13:20:25.117] plan(): nbrOfWorkers() = 1
[13:20:25.117] plan(): Setting new future strategy stack:
[13:20:25.118] List of future strategies:
[13:20:25.118] 1. sequential:
[13:20:25.118]    - args: function (..., envir = parent.frame())
[13:20:25.118]    - tweaked: FALSE
[13:20:25.118]    - call: plan(strategy)
[13:20:25.118] plan(): nbrOfWorkers() = 1
[13:20:25.118] SequentialFuture started (and completed)
[13:20:25.118] - Launch lazy future ... done
[13:20:25.118] run() for ‘SequentialFuture’ ... done
[13:20:25.118] getGlobalsAndPackages() ...
[13:20:25.119] Searching for globals...
[13:20:25.119] 
[13:20:25.119] Searching for globals ... DONE
[13:20:25.119] - globals: [0] <none>
[13:20:25.119] getGlobalsAndPackages() ... DONE
[13:20:25.119] run() for ‘Future’ ...
[13:20:25.119] - state: ‘created’
[13:20:25.120] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.120] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.120] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.120]   - Field: ‘label’
[13:20:25.120]   - Field: ‘local’
[13:20:25.120]   - Field: ‘owner’
[13:20:25.120]   - Field: ‘envir’
[13:20:25.120]   - Field: ‘packages’
[13:20:25.120]   - Field: ‘gc’
[13:20:25.121]   - Field: ‘conditions’
[13:20:25.121]   - Field: ‘expr’
[13:20:25.121]   - Field: ‘uuid’
[13:20:25.121]   - Field: ‘seed’
[13:20:25.121]   - Field: ‘version’
[13:20:25.121]   - Field: ‘result’
[13:20:25.121]   - Field: ‘asynchronous’
[13:20:25.121]   - Field: ‘calls’
[13:20:25.121]   - Field: ‘globals’
[13:20:25.121]   - Field: ‘stdout’
[13:20:25.122]   - Field: ‘earlySignal’
[13:20:25.122]   - Field: ‘lazy’
[13:20:25.122]   - Field: ‘state’
[13:20:25.123] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.124] - Launch lazy future ...
[13:20:25.124] Packages needed by the future expression (n = 0): <none>
[13:20:25.124] Packages needed by future strategies (n = 0): <none>
[13:20:25.124] {
[13:20:25.124]     {
[13:20:25.124]         {
[13:20:25.124]             ...future.startTime <- base::Sys.time()
[13:20:25.124]             {
[13:20:25.124]                 {
[13:20:25.124]                   {
[13:20:25.124]                     base::local({
[13:20:25.124]                       has_future <- base::requireNamespace("future", 
[13:20:25.124]                         quietly = TRUE)
[13:20:25.124]                       if (has_future) {
[13:20:25.124]                         ns <- base::getNamespace("future")
[13:20:25.124]                         version <- ns[[".package"]][["version"]]
[13:20:25.124]                         if (is.null(version)) 
[13:20:25.124]                           version <- utils::packageVersion("future")
[13:20:25.124]                       }
[13:20:25.124]                       else {
[13:20:25.124]                         version <- NULL
[13:20:25.124]                       }
[13:20:25.124]                       if (!has_future || version < "1.8.0") {
[13:20:25.124]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.124]                           "", base::R.version$version.string), 
[13:20:25.124]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.124]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.124]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.124]                             "release", "version")], collapse = " "), 
[13:20:25.124]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.124]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.124]                           info)
[13:20:25.124]                         info <- base::paste(info, collapse = "; ")
[13:20:25.124]                         if (!has_future) {
[13:20:25.124]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.124]                             info)
[13:20:25.124]                         }
[13:20:25.124]                         else {
[13:20:25.124]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.124]                             info, version)
[13:20:25.124]                         }
[13:20:25.124]                         base::stop(msg)
[13:20:25.124]                       }
[13:20:25.124]                     })
[13:20:25.124]                   }
[13:20:25.124]                   options(future.plan = NULL)
[13:20:25.124]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.124]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.124]                 }
[13:20:25.124]                 ...future.workdir <- getwd()
[13:20:25.124]             }
[13:20:25.124]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.124]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.124]         }
[13:20:25.124]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.124]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.124]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.124]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.124]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.124]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.124]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.124]             base::names(...future.oldOptions))
[13:20:25.124]     }
[13:20:25.124]     if (FALSE) {
[13:20:25.124]     }
[13:20:25.124]     else {
[13:20:25.124]         if (TRUE) {
[13:20:25.124]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.124]                 open = "w")
[13:20:25.124]         }
[13:20:25.124]         else {
[13:20:25.124]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.124]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.124]         }
[13:20:25.124]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.124]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.124]             base::sink(type = "output", split = FALSE)
[13:20:25.124]             base::close(...future.stdout)
[13:20:25.124]         }, add = TRUE)
[13:20:25.124]     }
[13:20:25.124]     ...future.frame <- base::sys.nframe()
[13:20:25.124]     ...future.conditions <- base::list()
[13:20:25.124]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.124]     if (FALSE) {
[13:20:25.124]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.124]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.124]     }
[13:20:25.124]     ...future.result <- base::tryCatch({
[13:20:25.124]         base::withCallingHandlers({
[13:20:25.124]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.124]             future::FutureResult(value = ...future.value$value, 
[13:20:25.124]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.124]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.124]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.124]                     ...future.globalenv.names))
[13:20:25.124]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.124]         }, condition = base::local({
[13:20:25.124]             c <- base::c
[13:20:25.124]             inherits <- base::inherits
[13:20:25.124]             invokeRestart <- base::invokeRestart
[13:20:25.124]             length <- base::length
[13:20:25.124]             list <- base::list
[13:20:25.124]             seq.int <- base::seq.int
[13:20:25.124]             signalCondition <- base::signalCondition
[13:20:25.124]             sys.calls <- base::sys.calls
[13:20:25.124]             `[[` <- base::`[[`
[13:20:25.124]             `+` <- base::`+`
[13:20:25.124]             `<<-` <- base::`<<-`
[13:20:25.124]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.124]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.124]                   3L)]
[13:20:25.124]             }
[13:20:25.124]             function(cond) {
[13:20:25.124]                 is_error <- inherits(cond, "error")
[13:20:25.124]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.124]                   NULL)
[13:20:25.124]                 if (is_error) {
[13:20:25.124]                   sessionInformation <- function() {
[13:20:25.124]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.124]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.124]                       search = base::search(), system = base::Sys.info())
[13:20:25.124]                   }
[13:20:25.124]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.124]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.124]                     cond$call), session = sessionInformation(), 
[13:20:25.124]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.124]                   signalCondition(cond)
[13:20:25.124]                 }
[13:20:25.124]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.124]                 "immediateCondition"))) {
[13:20:25.124]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.124]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.124]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.124]                   if (TRUE && !signal) {
[13:20:25.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.124]                     {
[13:20:25.124]                       inherits <- base::inherits
[13:20:25.124]                       invokeRestart <- base::invokeRestart
[13:20:25.124]                       is.null <- base::is.null
[13:20:25.124]                       muffled <- FALSE
[13:20:25.124]                       if (inherits(cond, "message")) {
[13:20:25.124]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.124]                         if (muffled) 
[13:20:25.124]                           invokeRestart("muffleMessage")
[13:20:25.124]                       }
[13:20:25.124]                       else if (inherits(cond, "warning")) {
[13:20:25.124]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.124]                         if (muffled) 
[13:20:25.124]                           invokeRestart("muffleWarning")
[13:20:25.124]                       }
[13:20:25.124]                       else if (inherits(cond, "condition")) {
[13:20:25.124]                         if (!is.null(pattern)) {
[13:20:25.124]                           computeRestarts <- base::computeRestarts
[13:20:25.124]                           grepl <- base::grepl
[13:20:25.124]                           restarts <- computeRestarts(cond)
[13:20:25.124]                           for (restart in restarts) {
[13:20:25.124]                             name <- restart$name
[13:20:25.124]                             if (is.null(name)) 
[13:20:25.124]                               next
[13:20:25.124]                             if (!grepl(pattern, name)) 
[13:20:25.124]                               next
[13:20:25.124]                             invokeRestart(restart)
[13:20:25.124]                             muffled <- TRUE
[13:20:25.124]                             break
[13:20:25.124]                           }
[13:20:25.124]                         }
[13:20:25.124]                       }
[13:20:25.124]                       invisible(muffled)
[13:20:25.124]                     }
[13:20:25.124]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.124]                   }
[13:20:25.124]                 }
[13:20:25.124]                 else {
[13:20:25.124]                   if (TRUE) {
[13:20:25.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.124]                     {
[13:20:25.124]                       inherits <- base::inherits
[13:20:25.124]                       invokeRestart <- base::invokeRestart
[13:20:25.124]                       is.null <- base::is.null
[13:20:25.124]                       muffled <- FALSE
[13:20:25.124]                       if (inherits(cond, "message")) {
[13:20:25.124]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.124]                         if (muffled) 
[13:20:25.124]                           invokeRestart("muffleMessage")
[13:20:25.124]                       }
[13:20:25.124]                       else if (inherits(cond, "warning")) {
[13:20:25.124]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.124]                         if (muffled) 
[13:20:25.124]                           invokeRestart("muffleWarning")
[13:20:25.124]                       }
[13:20:25.124]                       else if (inherits(cond, "condition")) {
[13:20:25.124]                         if (!is.null(pattern)) {
[13:20:25.124]                           computeRestarts <- base::computeRestarts
[13:20:25.124]                           grepl <- base::grepl
[13:20:25.124]                           restarts <- computeRestarts(cond)
[13:20:25.124]                           for (restart in restarts) {
[13:20:25.124]                             name <- restart$name
[13:20:25.124]                             if (is.null(name)) 
[13:20:25.124]                               next
[13:20:25.124]                             if (!grepl(pattern, name)) 
[13:20:25.124]                               next
[13:20:25.124]                             invokeRestart(restart)
[13:20:25.124]                             muffled <- TRUE
[13:20:25.124]                             break
[13:20:25.124]                           }
[13:20:25.124]                         }
[13:20:25.124]                       }
[13:20:25.124]                       invisible(muffled)
[13:20:25.124]                     }
[13:20:25.124]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.124]                   }
[13:20:25.124]                 }
[13:20:25.124]             }
[13:20:25.124]         }))
[13:20:25.124]     }, error = function(ex) {
[13:20:25.124]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.124]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.124]                 ...future.rng), started = ...future.startTime, 
[13:20:25.124]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.124]             version = "1.8"), class = "FutureResult")
[13:20:25.124]     }, finally = {
[13:20:25.124]         if (!identical(...future.workdir, getwd())) 
[13:20:25.124]             setwd(...future.workdir)
[13:20:25.124]         {
[13:20:25.124]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.124]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.124]             }
[13:20:25.124]             base::options(...future.oldOptions)
[13:20:25.124]             if (.Platform$OS.type == "windows") {
[13:20:25.124]                 old_names <- names(...future.oldEnvVars)
[13:20:25.124]                 envs <- base::Sys.getenv()
[13:20:25.124]                 names <- names(envs)
[13:20:25.124]                 common <- intersect(names, old_names)
[13:20:25.124]                 added <- setdiff(names, old_names)
[13:20:25.124]                 removed <- setdiff(old_names, names)
[13:20:25.124]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.124]                   envs[common]]
[13:20:25.124]                 NAMES <- toupper(changed)
[13:20:25.124]                 args <- list()
[13:20:25.124]                 for (kk in seq_along(NAMES)) {
[13:20:25.124]                   name <- changed[[kk]]
[13:20:25.124]                   NAME <- NAMES[[kk]]
[13:20:25.124]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.124]                     next
[13:20:25.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.124]                 }
[13:20:25.124]                 NAMES <- toupper(added)
[13:20:25.124]                 for (kk in seq_along(NAMES)) {
[13:20:25.124]                   name <- added[[kk]]
[13:20:25.124]                   NAME <- NAMES[[kk]]
[13:20:25.124]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.124]                     next
[13:20:25.124]                   args[[name]] <- ""
[13:20:25.124]                 }
[13:20:25.124]                 NAMES <- toupper(removed)
[13:20:25.124]                 for (kk in seq_along(NAMES)) {
[13:20:25.124]                   name <- removed[[kk]]
[13:20:25.124]                   NAME <- NAMES[[kk]]
[13:20:25.124]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.124]                     next
[13:20:25.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.124]                 }
[13:20:25.124]                 if (length(args) > 0) 
[13:20:25.124]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.124]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.124]             }
[13:20:25.124]             else {
[13:20:25.124]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.124]             }
[13:20:25.124]             {
[13:20:25.124]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.124]                   0L) {
[13:20:25.124]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.124]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.124]                   base::options(opts)
[13:20:25.124]                 }
[13:20:25.124]                 {
[13:20:25.124]                   {
[13:20:25.124]                     NULL
[13:20:25.124]                     RNGkind("Mersenne-Twister")
[13:20:25.124]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.124]                       inherits = FALSE)
[13:20:25.124]                   }
[13:20:25.124]                   options(future.plan = NULL)
[13:20:25.124]                   if (is.na(NA_character_)) 
[13:20:25.124]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.124]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.124]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.124]                   {
[13:20:25.124]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.124]                     if (!future$lazy) 
[13:20:25.124]                       future <- run(future)
[13:20:25.124]                     invisible(future)
[13:20:25.124]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.124]                 }
[13:20:25.124]             }
[13:20:25.124]         }
[13:20:25.124]     })
[13:20:25.124]     if (TRUE) {
[13:20:25.124]         base::sink(type = "output", split = FALSE)
[13:20:25.124]         if (TRUE) {
[13:20:25.124]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.124]         }
[13:20:25.124]         else {
[13:20:25.124]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.124]         }
[13:20:25.124]         base::close(...future.stdout)
[13:20:25.124]         ...future.stdout <- NULL
[13:20:25.124]     }
[13:20:25.124]     ...future.result$conditions <- ...future.conditions
[13:20:25.124]     ...future.result$finished <- base::Sys.time()
[13:20:25.124]     ...future.result
[13:20:25.124] }
[13:20:25.126] plan(): Setting new future strategy stack:
[13:20:25.126] List of future strategies:
[13:20:25.126] 1. sequential:
[13:20:25.126]    - args: function (..., envir = parent.frame())
[13:20:25.126]    - tweaked: FALSE
[13:20:25.126]    - call: NULL
[13:20:25.127] plan(): nbrOfWorkers() = 1
[13:20:25.127] plan(): Setting new future strategy stack:
[13:20:25.127] List of future strategies:
[13:20:25.127] 1. sequential:
[13:20:25.127]    - args: function (..., envir = parent.frame())
[13:20:25.127]    - tweaked: FALSE
[13:20:25.127]    - call: plan(strategy)
[13:20:25.128] plan(): nbrOfWorkers() = 1
[13:20:25.128] SequentialFuture started (and completed)
[13:20:25.128] - Launch lazy future ... done
[13:20:25.128] run() for ‘SequentialFuture’ ... done
[13:20:25.129] getGlobalsAndPackages() ...
[13:20:25.129] Searching for globals...
[13:20:25.131] - globals found: [1] ‘{’
[13:20:25.131] Searching for globals ... DONE
[13:20:25.131] Resolving globals: FALSE
[13:20:25.132] 
[13:20:25.132] 
[13:20:25.132] getGlobalsAndPackages() ... DONE
[13:20:25.132] run() for ‘Future’ ...
[13:20:25.132] - state: ‘created’
[13:20:25.132] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.132] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.133]   - Field: ‘label’
[13:20:25.133]   - Field: ‘local’
[13:20:25.133]   - Field: ‘owner’
[13:20:25.133]   - Field: ‘envir’
[13:20:25.133]   - Field: ‘packages’
[13:20:25.133]   - Field: ‘gc’
[13:20:25.133]   - Field: ‘conditions’
[13:20:25.133]   - Field: ‘expr’
[13:20:25.133]   - Field: ‘uuid’
[13:20:25.133]   - Field: ‘seed’
[13:20:25.134]   - Field: ‘version’
[13:20:25.134]   - Field: ‘result’
[13:20:25.134]   - Field: ‘asynchronous’
[13:20:25.134]   - Field: ‘calls’
[13:20:25.134]   - Field: ‘globals’
[13:20:25.134]   - Field: ‘stdout’
[13:20:25.134]   - Field: ‘earlySignal’
[13:20:25.134]   - Field: ‘lazy’
[13:20:25.134]   - Field: ‘state’
[13:20:25.134] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.135] - Launch lazy future ...
[13:20:25.135] Packages needed by the future expression (n = 0): <none>
[13:20:25.135] Packages needed by future strategies (n = 0): <none>
[13:20:25.135] {
[13:20:25.135]     {
[13:20:25.135]         {
[13:20:25.135]             ...future.startTime <- base::Sys.time()
[13:20:25.135]             {
[13:20:25.135]                 {
[13:20:25.135]                   {
[13:20:25.135]                     base::local({
[13:20:25.135]                       has_future <- base::requireNamespace("future", 
[13:20:25.135]                         quietly = TRUE)
[13:20:25.135]                       if (has_future) {
[13:20:25.135]                         ns <- base::getNamespace("future")
[13:20:25.135]                         version <- ns[[".package"]][["version"]]
[13:20:25.135]                         if (is.null(version)) 
[13:20:25.135]                           version <- utils::packageVersion("future")
[13:20:25.135]                       }
[13:20:25.135]                       else {
[13:20:25.135]                         version <- NULL
[13:20:25.135]                       }
[13:20:25.135]                       if (!has_future || version < "1.8.0") {
[13:20:25.135]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.135]                           "", base::R.version$version.string), 
[13:20:25.135]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.135]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.135]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.135]                             "release", "version")], collapse = " "), 
[13:20:25.135]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.135]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.135]                           info)
[13:20:25.135]                         info <- base::paste(info, collapse = "; ")
[13:20:25.135]                         if (!has_future) {
[13:20:25.135]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.135]                             info)
[13:20:25.135]                         }
[13:20:25.135]                         else {
[13:20:25.135]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.135]                             info, version)
[13:20:25.135]                         }
[13:20:25.135]                         base::stop(msg)
[13:20:25.135]                       }
[13:20:25.135]                     })
[13:20:25.135]                   }
[13:20:25.135]                   options(future.plan = NULL)
[13:20:25.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.135]                 }
[13:20:25.135]                 ...future.workdir <- getwd()
[13:20:25.135]             }
[13:20:25.135]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.135]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.135]         }
[13:20:25.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.135]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.135]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.135]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.135]             base::names(...future.oldOptions))
[13:20:25.135]     }
[13:20:25.135]     if (FALSE) {
[13:20:25.135]     }
[13:20:25.135]     else {
[13:20:25.135]         if (TRUE) {
[13:20:25.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.135]                 open = "w")
[13:20:25.135]         }
[13:20:25.135]         else {
[13:20:25.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.135]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.135]         }
[13:20:25.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.135]             base::sink(type = "output", split = FALSE)
[13:20:25.135]             base::close(...future.stdout)
[13:20:25.135]         }, add = TRUE)
[13:20:25.135]     }
[13:20:25.135]     ...future.frame <- base::sys.nframe()
[13:20:25.135]     ...future.conditions <- base::list()
[13:20:25.135]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.135]     if (FALSE) {
[13:20:25.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.135]     }
[13:20:25.135]     ...future.result <- base::tryCatch({
[13:20:25.135]         base::withCallingHandlers({
[13:20:25.135]             ...future.value <- base::withVisible(base::local({
[13:20:25.135]                 4
[13:20:25.135]             }))
[13:20:25.135]             future::FutureResult(value = ...future.value$value, 
[13:20:25.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.135]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.135]                     ...future.globalenv.names))
[13:20:25.135]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.135]         }, condition = base::local({
[13:20:25.135]             c <- base::c
[13:20:25.135]             inherits <- base::inherits
[13:20:25.135]             invokeRestart <- base::invokeRestart
[13:20:25.135]             length <- base::length
[13:20:25.135]             list <- base::list
[13:20:25.135]             seq.int <- base::seq.int
[13:20:25.135]             signalCondition <- base::signalCondition
[13:20:25.135]             sys.calls <- base::sys.calls
[13:20:25.135]             `[[` <- base::`[[`
[13:20:25.135]             `+` <- base::`+`
[13:20:25.135]             `<<-` <- base::`<<-`
[13:20:25.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.135]                   3L)]
[13:20:25.135]             }
[13:20:25.135]             function(cond) {
[13:20:25.135]                 is_error <- inherits(cond, "error")
[13:20:25.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.135]                   NULL)
[13:20:25.135]                 if (is_error) {
[13:20:25.135]                   sessionInformation <- function() {
[13:20:25.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.135]                       search = base::search(), system = base::Sys.info())
[13:20:25.135]                   }
[13:20:25.135]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.135]                     cond$call), session = sessionInformation(), 
[13:20:25.135]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.135]                   signalCondition(cond)
[13:20:25.135]                 }
[13:20:25.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.135]                 "immediateCondition"))) {
[13:20:25.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.135]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.135]                   if (TRUE && !signal) {
[13:20:25.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.135]                     {
[13:20:25.135]                       inherits <- base::inherits
[13:20:25.135]                       invokeRestart <- base::invokeRestart
[13:20:25.135]                       is.null <- base::is.null
[13:20:25.135]                       muffled <- FALSE
[13:20:25.135]                       if (inherits(cond, "message")) {
[13:20:25.135]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.135]                         if (muffled) 
[13:20:25.135]                           invokeRestart("muffleMessage")
[13:20:25.135]                       }
[13:20:25.135]                       else if (inherits(cond, "warning")) {
[13:20:25.135]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.135]                         if (muffled) 
[13:20:25.135]                           invokeRestart("muffleWarning")
[13:20:25.135]                       }
[13:20:25.135]                       else if (inherits(cond, "condition")) {
[13:20:25.135]                         if (!is.null(pattern)) {
[13:20:25.135]                           computeRestarts <- base::computeRestarts
[13:20:25.135]                           grepl <- base::grepl
[13:20:25.135]                           restarts <- computeRestarts(cond)
[13:20:25.135]                           for (restart in restarts) {
[13:20:25.135]                             name <- restart$name
[13:20:25.135]                             if (is.null(name)) 
[13:20:25.135]                               next
[13:20:25.135]                             if (!grepl(pattern, name)) 
[13:20:25.135]                               next
[13:20:25.135]                             invokeRestart(restart)
[13:20:25.135]                             muffled <- TRUE
[13:20:25.135]                             break
[13:20:25.135]                           }
[13:20:25.135]                         }
[13:20:25.135]                       }
[13:20:25.135]                       invisible(muffled)
[13:20:25.135]                     }
[13:20:25.135]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.135]                   }
[13:20:25.135]                 }
[13:20:25.135]                 else {
[13:20:25.135]                   if (TRUE) {
[13:20:25.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.135]                     {
[13:20:25.135]                       inherits <- base::inherits
[13:20:25.135]                       invokeRestart <- base::invokeRestart
[13:20:25.135]                       is.null <- base::is.null
[13:20:25.135]                       muffled <- FALSE
[13:20:25.135]                       if (inherits(cond, "message")) {
[13:20:25.135]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.135]                         if (muffled) 
[13:20:25.135]                           invokeRestart("muffleMessage")
[13:20:25.135]                       }
[13:20:25.135]                       else if (inherits(cond, "warning")) {
[13:20:25.135]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.135]                         if (muffled) 
[13:20:25.135]                           invokeRestart("muffleWarning")
[13:20:25.135]                       }
[13:20:25.135]                       else if (inherits(cond, "condition")) {
[13:20:25.135]                         if (!is.null(pattern)) {
[13:20:25.135]                           computeRestarts <- base::computeRestarts
[13:20:25.135]                           grepl <- base::grepl
[13:20:25.135]                           restarts <- computeRestarts(cond)
[13:20:25.135]                           for (restart in restarts) {
[13:20:25.135]                             name <- restart$name
[13:20:25.135]                             if (is.null(name)) 
[13:20:25.135]                               next
[13:20:25.135]                             if (!grepl(pattern, name)) 
[13:20:25.135]                               next
[13:20:25.135]                             invokeRestart(restart)
[13:20:25.135]                             muffled <- TRUE
[13:20:25.135]                             break
[13:20:25.135]                           }
[13:20:25.135]                         }
[13:20:25.135]                       }
[13:20:25.135]                       invisible(muffled)
[13:20:25.135]                     }
[13:20:25.135]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.135]                   }
[13:20:25.135]                 }
[13:20:25.135]             }
[13:20:25.135]         }))
[13:20:25.135]     }, error = function(ex) {
[13:20:25.135]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.135]                 ...future.rng), started = ...future.startTime, 
[13:20:25.135]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.135]             version = "1.8"), class = "FutureResult")
[13:20:25.135]     }, finally = {
[13:20:25.135]         if (!identical(...future.workdir, getwd())) 
[13:20:25.135]             setwd(...future.workdir)
[13:20:25.135]         {
[13:20:25.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.135]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.135]             }
[13:20:25.135]             base::options(...future.oldOptions)
[13:20:25.135]             if (.Platform$OS.type == "windows") {
[13:20:25.135]                 old_names <- names(...future.oldEnvVars)
[13:20:25.135]                 envs <- base::Sys.getenv()
[13:20:25.135]                 names <- names(envs)
[13:20:25.135]                 common <- intersect(names, old_names)
[13:20:25.135]                 added <- setdiff(names, old_names)
[13:20:25.135]                 removed <- setdiff(old_names, names)
[13:20:25.135]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.135]                   envs[common]]
[13:20:25.135]                 NAMES <- toupper(changed)
[13:20:25.135]                 args <- list()
[13:20:25.135]                 for (kk in seq_along(NAMES)) {
[13:20:25.135]                   name <- changed[[kk]]
[13:20:25.135]                   NAME <- NAMES[[kk]]
[13:20:25.135]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.135]                     next
[13:20:25.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.135]                 }
[13:20:25.135]                 NAMES <- toupper(added)
[13:20:25.135]                 for (kk in seq_along(NAMES)) {
[13:20:25.135]                   name <- added[[kk]]
[13:20:25.135]                   NAME <- NAMES[[kk]]
[13:20:25.135]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.135]                     next
[13:20:25.135]                   args[[name]] <- ""
[13:20:25.135]                 }
[13:20:25.135]                 NAMES <- toupper(removed)
[13:20:25.135]                 for (kk in seq_along(NAMES)) {
[13:20:25.135]                   name <- removed[[kk]]
[13:20:25.135]                   NAME <- NAMES[[kk]]
[13:20:25.135]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.135]                     next
[13:20:25.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.135]                 }
[13:20:25.135]                 if (length(args) > 0) 
[13:20:25.135]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.135]             }
[13:20:25.135]             else {
[13:20:25.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.135]             }
[13:20:25.135]             {
[13:20:25.135]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.135]                   0L) {
[13:20:25.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.135]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.135]                   base::options(opts)
[13:20:25.135]                 }
[13:20:25.135]                 {
[13:20:25.135]                   {
[13:20:25.135]                     NULL
[13:20:25.135]                     RNGkind("Mersenne-Twister")
[13:20:25.135]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.135]                       inherits = FALSE)
[13:20:25.135]                   }
[13:20:25.135]                   options(future.plan = NULL)
[13:20:25.135]                   if (is.na(NA_character_)) 
[13:20:25.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.135]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.135]                   {
[13:20:25.135]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.135]                     if (!future$lazy) 
[13:20:25.135]                       future <- run(future)
[13:20:25.135]                     invisible(future)
[13:20:25.135]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.135]                 }
[13:20:25.135]             }
[13:20:25.135]         }
[13:20:25.135]     })
[13:20:25.135]     if (TRUE) {
[13:20:25.135]         base::sink(type = "output", split = FALSE)
[13:20:25.135]         if (TRUE) {
[13:20:25.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.135]         }
[13:20:25.135]         else {
[13:20:25.135]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.135]         }
[13:20:25.135]         base::close(...future.stdout)
[13:20:25.135]         ...future.stdout <- NULL
[13:20:25.135]     }
[13:20:25.135]     ...future.result$conditions <- ...future.conditions
[13:20:25.135]     ...future.result$finished <- base::Sys.time()
[13:20:25.135]     ...future.result
[13:20:25.135] }
[13:20:25.137] plan(): Setting new future strategy stack:
[13:20:25.137] List of future strategies:
[13:20:25.137] 1. sequential:
[13:20:25.137]    - args: function (..., envir = parent.frame())
[13:20:25.137]    - tweaked: FALSE
[13:20:25.137]    - call: NULL
[13:20:25.137] plan(): nbrOfWorkers() = 1
[13:20:25.138] plan(): Setting new future strategy stack:
[13:20:25.138] List of future strategies:
[13:20:25.138] 1. sequential:
[13:20:25.138]    - args: function (..., envir = parent.frame())
[13:20:25.138]    - tweaked: FALSE
[13:20:25.138]    - call: plan(strategy)
[13:20:25.139] plan(): nbrOfWorkers() = 1
[13:20:25.139] SequentialFuture started (and completed)
[13:20:25.139] - Launch lazy future ... done
[13:20:25.139] run() for ‘SequentialFuture’ ... done
<environment: 0x55659bb39eb8> 
<environment: 0x55659b6ab6d0> 
[13:20:25.140] resolved() for ‘SequentialFuture’ ...
[13:20:25.141] - state: ‘finished’
[13:20:25.141] - run: TRUE
[13:20:25.141] - result: ‘FutureResult’
[13:20:25.141] resolved() for ‘SequentialFuture’ ... done
[13:20:25.141] resolved() for ‘SequentialFuture’ ...
[13:20:25.141] - state: ‘finished’
[13:20:25.141] - run: TRUE
[13:20:25.141] - result: ‘FutureResult’
[13:20:25.141] resolved() for ‘SequentialFuture’ ... done
[13:20:25.141] resolved() for ‘SequentialFuture’ ...
[13:20:25.141] - state: ‘finished’
[13:20:25.142] - run: TRUE
[13:20:25.142] - result: ‘FutureResult’
[13:20:25.142] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:25.143] resolve() on environment ...
[13:20:25.143]  recursive: 0
[13:20:25.144]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:25.144] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.144] - nx: 4
[13:20:25.144] - relay: TRUE
[13:20:25.144] - stdout: TRUE
[13:20:25.144] - signal: TRUE
[13:20:25.144] - resignal: FALSE
[13:20:25.144] - force: TRUE
[13:20:25.144] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.144] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.145]  - until=2
[13:20:25.145]  - relaying element #2
[13:20:25.145] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:25.145] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.145] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.145]  length: 3 (resolved future 1)
[13:20:25.145] resolved() for ‘SequentialFuture’ ...
[13:20:25.145] - state: ‘finished’
[13:20:25.145] - run: TRUE
[13:20:25.145] - result: ‘FutureResult’
[13:20:25.146] resolved() for ‘SequentialFuture’ ... done
[13:20:25.146] Future #2
[13:20:25.146] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.146] - nx: 4
[13:20:25.146] - relay: TRUE
[13:20:25.146] - stdout: TRUE
[13:20:25.146] - signal: TRUE
[13:20:25.146] - resignal: FALSE
[13:20:25.146] - force: TRUE
[13:20:25.146] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:25.146] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.147]  - until=2
[13:20:25.147]  - relaying element #2
[13:20:25.147] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:25.147] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:25.147] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.147]  length: 2 (resolved future 2)
[13:20:25.147] resolved() for ‘SequentialFuture’ ...
[13:20:25.147] - state: ‘finished’
[13:20:25.147] - run: TRUE
[13:20:25.147] - result: ‘FutureResult’
[13:20:25.148] resolved() for ‘SequentialFuture’ ... done
[13:20:25.148] Future #3
[13:20:25.148] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.148] - nx: 4
[13:20:25.148] - relay: TRUE
[13:20:25.148] - stdout: TRUE
[13:20:25.148] - signal: TRUE
[13:20:25.148] - resignal: FALSE
[13:20:25.148] - force: TRUE
[13:20:25.148] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:25.148] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:25.149]  - until=3
[13:20:25.149]  - relaying element #3
[13:20:25.149] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:25.149] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:25.149] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.149]  length: 1 (resolved future 3)
[13:20:25.149] resolved() for ‘SequentialFuture’ ...
[13:20:25.149] - state: ‘finished’
[13:20:25.149] - run: TRUE
[13:20:25.150] - result: ‘FutureResult’
[13:20:25.150] resolved() for ‘SequentialFuture’ ... done
[13:20:25.150] Future #4
[13:20:25.150] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:20:25.150] - nx: 4
[13:20:25.150] - relay: TRUE
[13:20:25.150] - stdout: TRUE
[13:20:25.150] - signal: TRUE
[13:20:25.150] - resignal: FALSE
[13:20:25.150] - force: TRUE
[13:20:25.150] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:25.151] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:25.151]  - until=4
[13:20:25.151]  - relaying element #4
[13:20:25.151] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.151] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:25.151] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:20:25.151]  length: 0 (resolved future 4)
[13:20:25.151] Relaying remaining futures
[13:20:25.151] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.151] - nx: 4
[13:20:25.151] - relay: TRUE
[13:20:25.152] - stdout: TRUE
[13:20:25.152] - signal: TRUE
[13:20:25.152] - resignal: FALSE
[13:20:25.152] - force: TRUE
[13:20:25.152] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.152] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:25.152] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.152] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:25.154] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.154] resolve() on environment ... DONE
<environment: 0x55659bab4580> 
Dimensions: c(1, 6)
[13:20:25.155] getGlobalsAndPackages() ...
[13:20:25.155] Searching for globals...
[13:20:25.155] 
[13:20:25.155] Searching for globals ... DONE
[13:20:25.156] - globals: [0] <none>
[13:20:25.156] getGlobalsAndPackages() ... DONE
[13:20:25.156] run() for ‘Future’ ...
[13:20:25.156] - state: ‘created’
[13:20:25.156] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.156] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.156] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.157]   - Field: ‘label’
[13:20:25.157]   - Field: ‘local’
[13:20:25.157]   - Field: ‘owner’
[13:20:25.157]   - Field: ‘envir’
[13:20:25.157]   - Field: ‘packages’
[13:20:25.157]   - Field: ‘gc’
[13:20:25.157]   - Field: ‘conditions’
[13:20:25.157]   - Field: ‘expr’
[13:20:25.157]   - Field: ‘uuid’
[13:20:25.157]   - Field: ‘seed’
[13:20:25.158]   - Field: ‘version’
[13:20:25.158]   - Field: ‘result’
[13:20:25.158]   - Field: ‘asynchronous’
[13:20:25.158]   - Field: ‘calls’
[13:20:25.158]   - Field: ‘globals’
[13:20:25.158]   - Field: ‘stdout’
[13:20:25.158]   - Field: ‘earlySignal’
[13:20:25.158]   - Field: ‘lazy’
[13:20:25.158]   - Field: ‘state’
[13:20:25.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.159] - Launch lazy future ...
[13:20:25.159] Packages needed by the future expression (n = 0): <none>
[13:20:25.159] Packages needed by future strategies (n = 0): <none>
[13:20:25.159] {
[13:20:25.159]     {
[13:20:25.159]         {
[13:20:25.159]             ...future.startTime <- base::Sys.time()
[13:20:25.159]             {
[13:20:25.159]                 {
[13:20:25.159]                   {
[13:20:25.159]                     base::local({
[13:20:25.159]                       has_future <- base::requireNamespace("future", 
[13:20:25.159]                         quietly = TRUE)
[13:20:25.159]                       if (has_future) {
[13:20:25.159]                         ns <- base::getNamespace("future")
[13:20:25.159]                         version <- ns[[".package"]][["version"]]
[13:20:25.159]                         if (is.null(version)) 
[13:20:25.159]                           version <- utils::packageVersion("future")
[13:20:25.159]                       }
[13:20:25.159]                       else {
[13:20:25.159]                         version <- NULL
[13:20:25.159]                       }
[13:20:25.159]                       if (!has_future || version < "1.8.0") {
[13:20:25.159]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.159]                           "", base::R.version$version.string), 
[13:20:25.159]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.159]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.159]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.159]                             "release", "version")], collapse = " "), 
[13:20:25.159]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.159]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.159]                           info)
[13:20:25.159]                         info <- base::paste(info, collapse = "; ")
[13:20:25.159]                         if (!has_future) {
[13:20:25.159]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.159]                             info)
[13:20:25.159]                         }
[13:20:25.159]                         else {
[13:20:25.159]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.159]                             info, version)
[13:20:25.159]                         }
[13:20:25.159]                         base::stop(msg)
[13:20:25.159]                       }
[13:20:25.159]                     })
[13:20:25.159]                   }
[13:20:25.159]                   options(future.plan = NULL)
[13:20:25.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.159]                 }
[13:20:25.159]                 ...future.workdir <- getwd()
[13:20:25.159]             }
[13:20:25.159]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.159]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.159]         }
[13:20:25.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.159]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.159]             base::names(...future.oldOptions))
[13:20:25.159]     }
[13:20:25.159]     if (FALSE) {
[13:20:25.159]     }
[13:20:25.159]     else {
[13:20:25.159]         if (TRUE) {
[13:20:25.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.159]                 open = "w")
[13:20:25.159]         }
[13:20:25.159]         else {
[13:20:25.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.159]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.159]         }
[13:20:25.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.159]             base::sink(type = "output", split = FALSE)
[13:20:25.159]             base::close(...future.stdout)
[13:20:25.159]         }, add = TRUE)
[13:20:25.159]     }
[13:20:25.159]     ...future.frame <- base::sys.nframe()
[13:20:25.159]     ...future.conditions <- base::list()
[13:20:25.159]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.159]     if (FALSE) {
[13:20:25.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.159]     }
[13:20:25.159]     ...future.result <- base::tryCatch({
[13:20:25.159]         base::withCallingHandlers({
[13:20:25.159]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.159]             future::FutureResult(value = ...future.value$value, 
[13:20:25.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.159]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.159]                     ...future.globalenv.names))
[13:20:25.159]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.159]         }, condition = base::local({
[13:20:25.159]             c <- base::c
[13:20:25.159]             inherits <- base::inherits
[13:20:25.159]             invokeRestart <- base::invokeRestart
[13:20:25.159]             length <- base::length
[13:20:25.159]             list <- base::list
[13:20:25.159]             seq.int <- base::seq.int
[13:20:25.159]             signalCondition <- base::signalCondition
[13:20:25.159]             sys.calls <- base::sys.calls
[13:20:25.159]             `[[` <- base::`[[`
[13:20:25.159]             `+` <- base::`+`
[13:20:25.159]             `<<-` <- base::`<<-`
[13:20:25.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.159]                   3L)]
[13:20:25.159]             }
[13:20:25.159]             function(cond) {
[13:20:25.159]                 is_error <- inherits(cond, "error")
[13:20:25.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.159]                   NULL)
[13:20:25.159]                 if (is_error) {
[13:20:25.159]                   sessionInformation <- function() {
[13:20:25.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.159]                       search = base::search(), system = base::Sys.info())
[13:20:25.159]                   }
[13:20:25.159]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.159]                     cond$call), session = sessionInformation(), 
[13:20:25.159]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.159]                   signalCondition(cond)
[13:20:25.159]                 }
[13:20:25.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.159]                 "immediateCondition"))) {
[13:20:25.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.159]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.159]                   if (TRUE && !signal) {
[13:20:25.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.159]                     {
[13:20:25.159]                       inherits <- base::inherits
[13:20:25.159]                       invokeRestart <- base::invokeRestart
[13:20:25.159]                       is.null <- base::is.null
[13:20:25.159]                       muffled <- FALSE
[13:20:25.159]                       if (inherits(cond, "message")) {
[13:20:25.159]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.159]                         if (muffled) 
[13:20:25.159]                           invokeRestart("muffleMessage")
[13:20:25.159]                       }
[13:20:25.159]                       else if (inherits(cond, "warning")) {
[13:20:25.159]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.159]                         if (muffled) 
[13:20:25.159]                           invokeRestart("muffleWarning")
[13:20:25.159]                       }
[13:20:25.159]                       else if (inherits(cond, "condition")) {
[13:20:25.159]                         if (!is.null(pattern)) {
[13:20:25.159]                           computeRestarts <- base::computeRestarts
[13:20:25.159]                           grepl <- base::grepl
[13:20:25.159]                           restarts <- computeRestarts(cond)
[13:20:25.159]                           for (restart in restarts) {
[13:20:25.159]                             name <- restart$name
[13:20:25.159]                             if (is.null(name)) 
[13:20:25.159]                               next
[13:20:25.159]                             if (!grepl(pattern, name)) 
[13:20:25.159]                               next
[13:20:25.159]                             invokeRestart(restart)
[13:20:25.159]                             muffled <- TRUE
[13:20:25.159]                             break
[13:20:25.159]                           }
[13:20:25.159]                         }
[13:20:25.159]                       }
[13:20:25.159]                       invisible(muffled)
[13:20:25.159]                     }
[13:20:25.159]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.159]                   }
[13:20:25.159]                 }
[13:20:25.159]                 else {
[13:20:25.159]                   if (TRUE) {
[13:20:25.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.159]                     {
[13:20:25.159]                       inherits <- base::inherits
[13:20:25.159]                       invokeRestart <- base::invokeRestart
[13:20:25.159]                       is.null <- base::is.null
[13:20:25.159]                       muffled <- FALSE
[13:20:25.159]                       if (inherits(cond, "message")) {
[13:20:25.159]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.159]                         if (muffled) 
[13:20:25.159]                           invokeRestart("muffleMessage")
[13:20:25.159]                       }
[13:20:25.159]                       else if (inherits(cond, "warning")) {
[13:20:25.159]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.159]                         if (muffled) 
[13:20:25.159]                           invokeRestart("muffleWarning")
[13:20:25.159]                       }
[13:20:25.159]                       else if (inherits(cond, "condition")) {
[13:20:25.159]                         if (!is.null(pattern)) {
[13:20:25.159]                           computeRestarts <- base::computeRestarts
[13:20:25.159]                           grepl <- base::grepl
[13:20:25.159]                           restarts <- computeRestarts(cond)
[13:20:25.159]                           for (restart in restarts) {
[13:20:25.159]                             name <- restart$name
[13:20:25.159]                             if (is.null(name)) 
[13:20:25.159]                               next
[13:20:25.159]                             if (!grepl(pattern, name)) 
[13:20:25.159]                               next
[13:20:25.159]                             invokeRestart(restart)
[13:20:25.159]                             muffled <- TRUE
[13:20:25.159]                             break
[13:20:25.159]                           }
[13:20:25.159]                         }
[13:20:25.159]                       }
[13:20:25.159]                       invisible(muffled)
[13:20:25.159]                     }
[13:20:25.159]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.159]                   }
[13:20:25.159]                 }
[13:20:25.159]             }
[13:20:25.159]         }))
[13:20:25.159]     }, error = function(ex) {
[13:20:25.159]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.159]                 ...future.rng), started = ...future.startTime, 
[13:20:25.159]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.159]             version = "1.8"), class = "FutureResult")
[13:20:25.159]     }, finally = {
[13:20:25.159]         if (!identical(...future.workdir, getwd())) 
[13:20:25.159]             setwd(...future.workdir)
[13:20:25.159]         {
[13:20:25.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.159]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.159]             }
[13:20:25.159]             base::options(...future.oldOptions)
[13:20:25.159]             if (.Platform$OS.type == "windows") {
[13:20:25.159]                 old_names <- names(...future.oldEnvVars)
[13:20:25.159]                 envs <- base::Sys.getenv()
[13:20:25.159]                 names <- names(envs)
[13:20:25.159]                 common <- intersect(names, old_names)
[13:20:25.159]                 added <- setdiff(names, old_names)
[13:20:25.159]                 removed <- setdiff(old_names, names)
[13:20:25.159]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.159]                   envs[common]]
[13:20:25.159]                 NAMES <- toupper(changed)
[13:20:25.159]                 args <- list()
[13:20:25.159]                 for (kk in seq_along(NAMES)) {
[13:20:25.159]                   name <- changed[[kk]]
[13:20:25.159]                   NAME <- NAMES[[kk]]
[13:20:25.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.159]                     next
[13:20:25.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.159]                 }
[13:20:25.159]                 NAMES <- toupper(added)
[13:20:25.159]                 for (kk in seq_along(NAMES)) {
[13:20:25.159]                   name <- added[[kk]]
[13:20:25.159]                   NAME <- NAMES[[kk]]
[13:20:25.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.159]                     next
[13:20:25.159]                   args[[name]] <- ""
[13:20:25.159]                 }
[13:20:25.159]                 NAMES <- toupper(removed)
[13:20:25.159]                 for (kk in seq_along(NAMES)) {
[13:20:25.159]                   name <- removed[[kk]]
[13:20:25.159]                   NAME <- NAMES[[kk]]
[13:20:25.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.159]                     next
[13:20:25.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.159]                 }
[13:20:25.159]                 if (length(args) > 0) 
[13:20:25.159]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.159]             }
[13:20:25.159]             else {
[13:20:25.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.159]             }
[13:20:25.159]             {
[13:20:25.159]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.159]                   0L) {
[13:20:25.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.159]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.159]                   base::options(opts)
[13:20:25.159]                 }
[13:20:25.159]                 {
[13:20:25.159]                   {
[13:20:25.159]                     NULL
[13:20:25.159]                     RNGkind("Mersenne-Twister")
[13:20:25.159]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.159]                       inherits = FALSE)
[13:20:25.159]                   }
[13:20:25.159]                   options(future.plan = NULL)
[13:20:25.159]                   if (is.na(NA_character_)) 
[13:20:25.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.159]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.159]                   {
[13:20:25.159]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.159]                     if (!future$lazy) 
[13:20:25.159]                       future <- run(future)
[13:20:25.159]                     invisible(future)
[13:20:25.159]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.159]                 }
[13:20:25.159]             }
[13:20:25.159]         }
[13:20:25.159]     })
[13:20:25.159]     if (TRUE) {
[13:20:25.159]         base::sink(type = "output", split = FALSE)
[13:20:25.159]         if (TRUE) {
[13:20:25.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.159]         }
[13:20:25.159]         else {
[13:20:25.159]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.159]         }
[13:20:25.159]         base::close(...future.stdout)
[13:20:25.159]         ...future.stdout <- NULL
[13:20:25.159]     }
[13:20:25.159]     ...future.result$conditions <- ...future.conditions
[13:20:25.159]     ...future.result$finished <- base::Sys.time()
[13:20:25.159]     ...future.result
[13:20:25.159] }
[13:20:25.161] plan(): Setting new future strategy stack:
[13:20:25.161] List of future strategies:
[13:20:25.161] 1. sequential:
[13:20:25.161]    - args: function (..., envir = parent.frame())
[13:20:25.161]    - tweaked: FALSE
[13:20:25.161]    - call: NULL
[13:20:25.161] plan(): nbrOfWorkers() = 1
[13:20:25.162] plan(): Setting new future strategy stack:
[13:20:25.162] List of future strategies:
[13:20:25.162] 1. sequential:
[13:20:25.162]    - args: function (..., envir = parent.frame())
[13:20:25.162]    - tweaked: FALSE
[13:20:25.162]    - call: plan(strategy)
[13:20:25.163] plan(): nbrOfWorkers() = 1
[13:20:25.163] SequentialFuture started (and completed)
[13:20:25.163] - Launch lazy future ... done
[13:20:25.163] run() for ‘SequentialFuture’ ... done
[13:20:25.163] getGlobalsAndPackages() ...
[13:20:25.163] Searching for globals...
[13:20:25.164] 
[13:20:25.164] Searching for globals ... DONE
[13:20:25.164] - globals: [0] <none>
[13:20:25.164] getGlobalsAndPackages() ... DONE
[13:20:25.164] run() for ‘Future’ ...
[13:20:25.164] - state: ‘created’
[13:20:25.164] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.165] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.165] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.165]   - Field: ‘label’
[13:20:25.165]   - Field: ‘local’
[13:20:25.165]   - Field: ‘owner’
[13:20:25.165]   - Field: ‘envir’
[13:20:25.165]   - Field: ‘packages’
[13:20:25.165]   - Field: ‘gc’
[13:20:25.165]   - Field: ‘conditions’
[13:20:25.165]   - Field: ‘expr’
[13:20:25.166]   - Field: ‘uuid’
[13:20:25.166]   - Field: ‘seed’
[13:20:25.166]   - Field: ‘version’
[13:20:25.166]   - Field: ‘result’
[13:20:25.166]   - Field: ‘asynchronous’
[13:20:25.166]   - Field: ‘calls’
[13:20:25.166]   - Field: ‘globals’
[13:20:25.166]   - Field: ‘stdout’
[13:20:25.166]   - Field: ‘earlySignal’
[13:20:25.166]   - Field: ‘lazy’
[13:20:25.166]   - Field: ‘state’
[13:20:25.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.167] - Launch lazy future ...
[13:20:25.167] Packages needed by the future expression (n = 0): <none>
[13:20:25.167] Packages needed by future strategies (n = 0): <none>
[13:20:25.167] {
[13:20:25.167]     {
[13:20:25.167]         {
[13:20:25.167]             ...future.startTime <- base::Sys.time()
[13:20:25.167]             {
[13:20:25.167]                 {
[13:20:25.167]                   {
[13:20:25.167]                     base::local({
[13:20:25.167]                       has_future <- base::requireNamespace("future", 
[13:20:25.167]                         quietly = TRUE)
[13:20:25.167]                       if (has_future) {
[13:20:25.167]                         ns <- base::getNamespace("future")
[13:20:25.167]                         version <- ns[[".package"]][["version"]]
[13:20:25.167]                         if (is.null(version)) 
[13:20:25.167]                           version <- utils::packageVersion("future")
[13:20:25.167]                       }
[13:20:25.167]                       else {
[13:20:25.167]                         version <- NULL
[13:20:25.167]                       }
[13:20:25.167]                       if (!has_future || version < "1.8.0") {
[13:20:25.167]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.167]                           "", base::R.version$version.string), 
[13:20:25.167]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.167]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.167]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.167]                             "release", "version")], collapse = " "), 
[13:20:25.167]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.167]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.167]                           info)
[13:20:25.167]                         info <- base::paste(info, collapse = "; ")
[13:20:25.167]                         if (!has_future) {
[13:20:25.167]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.167]                             info)
[13:20:25.167]                         }
[13:20:25.167]                         else {
[13:20:25.167]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.167]                             info, version)
[13:20:25.167]                         }
[13:20:25.167]                         base::stop(msg)
[13:20:25.167]                       }
[13:20:25.167]                     })
[13:20:25.167]                   }
[13:20:25.167]                   options(future.plan = NULL)
[13:20:25.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.167]                 }
[13:20:25.167]                 ...future.workdir <- getwd()
[13:20:25.167]             }
[13:20:25.167]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.167]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.167]         }
[13:20:25.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.167]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.167]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.167]             base::names(...future.oldOptions))
[13:20:25.167]     }
[13:20:25.167]     if (FALSE) {
[13:20:25.167]     }
[13:20:25.167]     else {
[13:20:25.167]         if (TRUE) {
[13:20:25.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.167]                 open = "w")
[13:20:25.167]         }
[13:20:25.167]         else {
[13:20:25.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.167]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.167]         }
[13:20:25.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.167]             base::sink(type = "output", split = FALSE)
[13:20:25.167]             base::close(...future.stdout)
[13:20:25.167]         }, add = TRUE)
[13:20:25.167]     }
[13:20:25.167]     ...future.frame <- base::sys.nframe()
[13:20:25.167]     ...future.conditions <- base::list()
[13:20:25.167]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.167]     if (FALSE) {
[13:20:25.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.167]     }
[13:20:25.167]     ...future.result <- base::tryCatch({
[13:20:25.167]         base::withCallingHandlers({
[13:20:25.167]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.167]             future::FutureResult(value = ...future.value$value, 
[13:20:25.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.167]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.167]                     ...future.globalenv.names))
[13:20:25.167]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.167]         }, condition = base::local({
[13:20:25.167]             c <- base::c
[13:20:25.167]             inherits <- base::inherits
[13:20:25.167]             invokeRestart <- base::invokeRestart
[13:20:25.167]             length <- base::length
[13:20:25.167]             list <- base::list
[13:20:25.167]             seq.int <- base::seq.int
[13:20:25.167]             signalCondition <- base::signalCondition
[13:20:25.167]             sys.calls <- base::sys.calls
[13:20:25.167]             `[[` <- base::`[[`
[13:20:25.167]             `+` <- base::`+`
[13:20:25.167]             `<<-` <- base::`<<-`
[13:20:25.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.167]                   3L)]
[13:20:25.167]             }
[13:20:25.167]             function(cond) {
[13:20:25.167]                 is_error <- inherits(cond, "error")
[13:20:25.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.167]                   NULL)
[13:20:25.167]                 if (is_error) {
[13:20:25.167]                   sessionInformation <- function() {
[13:20:25.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.167]                       search = base::search(), system = base::Sys.info())
[13:20:25.167]                   }
[13:20:25.167]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.167]                     cond$call), session = sessionInformation(), 
[13:20:25.167]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.167]                   signalCondition(cond)
[13:20:25.167]                 }
[13:20:25.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.167]                 "immediateCondition"))) {
[13:20:25.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.167]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.167]                   if (TRUE && !signal) {
[13:20:25.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.167]                     {
[13:20:25.167]                       inherits <- base::inherits
[13:20:25.167]                       invokeRestart <- base::invokeRestart
[13:20:25.167]                       is.null <- base::is.null
[13:20:25.167]                       muffled <- FALSE
[13:20:25.167]                       if (inherits(cond, "message")) {
[13:20:25.167]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.167]                         if (muffled) 
[13:20:25.167]                           invokeRestart("muffleMessage")
[13:20:25.167]                       }
[13:20:25.167]                       else if (inherits(cond, "warning")) {
[13:20:25.167]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.167]                         if (muffled) 
[13:20:25.167]                           invokeRestart("muffleWarning")
[13:20:25.167]                       }
[13:20:25.167]                       else if (inherits(cond, "condition")) {
[13:20:25.167]                         if (!is.null(pattern)) {
[13:20:25.167]                           computeRestarts <- base::computeRestarts
[13:20:25.167]                           grepl <- base::grepl
[13:20:25.167]                           restarts <- computeRestarts(cond)
[13:20:25.167]                           for (restart in restarts) {
[13:20:25.167]                             name <- restart$name
[13:20:25.167]                             if (is.null(name)) 
[13:20:25.167]                               next
[13:20:25.167]                             if (!grepl(pattern, name)) 
[13:20:25.167]                               next
[13:20:25.167]                             invokeRestart(restart)
[13:20:25.167]                             muffled <- TRUE
[13:20:25.167]                             break
[13:20:25.167]                           }
[13:20:25.167]                         }
[13:20:25.167]                       }
[13:20:25.167]                       invisible(muffled)
[13:20:25.167]                     }
[13:20:25.167]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.167]                   }
[13:20:25.167]                 }
[13:20:25.167]                 else {
[13:20:25.167]                   if (TRUE) {
[13:20:25.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.167]                     {
[13:20:25.167]                       inherits <- base::inherits
[13:20:25.167]                       invokeRestart <- base::invokeRestart
[13:20:25.167]                       is.null <- base::is.null
[13:20:25.167]                       muffled <- FALSE
[13:20:25.167]                       if (inherits(cond, "message")) {
[13:20:25.167]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.167]                         if (muffled) 
[13:20:25.167]                           invokeRestart("muffleMessage")
[13:20:25.167]                       }
[13:20:25.167]                       else if (inherits(cond, "warning")) {
[13:20:25.167]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.167]                         if (muffled) 
[13:20:25.167]                           invokeRestart("muffleWarning")
[13:20:25.167]                       }
[13:20:25.167]                       else if (inherits(cond, "condition")) {
[13:20:25.167]                         if (!is.null(pattern)) {
[13:20:25.167]                           computeRestarts <- base::computeRestarts
[13:20:25.167]                           grepl <- base::grepl
[13:20:25.167]                           restarts <- computeRestarts(cond)
[13:20:25.167]                           for (restart in restarts) {
[13:20:25.167]                             name <- restart$name
[13:20:25.167]                             if (is.null(name)) 
[13:20:25.167]                               next
[13:20:25.167]                             if (!grepl(pattern, name)) 
[13:20:25.167]                               next
[13:20:25.167]                             invokeRestart(restart)
[13:20:25.167]                             muffled <- TRUE
[13:20:25.167]                             break
[13:20:25.167]                           }
[13:20:25.167]                         }
[13:20:25.167]                       }
[13:20:25.167]                       invisible(muffled)
[13:20:25.167]                     }
[13:20:25.167]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.167]                   }
[13:20:25.167]                 }
[13:20:25.167]             }
[13:20:25.167]         }))
[13:20:25.167]     }, error = function(ex) {
[13:20:25.167]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.167]                 ...future.rng), started = ...future.startTime, 
[13:20:25.167]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.167]             version = "1.8"), class = "FutureResult")
[13:20:25.167]     }, finally = {
[13:20:25.167]         if (!identical(...future.workdir, getwd())) 
[13:20:25.167]             setwd(...future.workdir)
[13:20:25.167]         {
[13:20:25.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.167]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.167]             }
[13:20:25.167]             base::options(...future.oldOptions)
[13:20:25.167]             if (.Platform$OS.type == "windows") {
[13:20:25.167]                 old_names <- names(...future.oldEnvVars)
[13:20:25.167]                 envs <- base::Sys.getenv()
[13:20:25.167]                 names <- names(envs)
[13:20:25.167]                 common <- intersect(names, old_names)
[13:20:25.167]                 added <- setdiff(names, old_names)
[13:20:25.167]                 removed <- setdiff(old_names, names)
[13:20:25.167]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.167]                   envs[common]]
[13:20:25.167]                 NAMES <- toupper(changed)
[13:20:25.167]                 args <- list()
[13:20:25.167]                 for (kk in seq_along(NAMES)) {
[13:20:25.167]                   name <- changed[[kk]]
[13:20:25.167]                   NAME <- NAMES[[kk]]
[13:20:25.167]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.167]                     next
[13:20:25.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.167]                 }
[13:20:25.167]                 NAMES <- toupper(added)
[13:20:25.167]                 for (kk in seq_along(NAMES)) {
[13:20:25.167]                   name <- added[[kk]]
[13:20:25.167]                   NAME <- NAMES[[kk]]
[13:20:25.167]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.167]                     next
[13:20:25.167]                   args[[name]] <- ""
[13:20:25.167]                 }
[13:20:25.167]                 NAMES <- toupper(removed)
[13:20:25.167]                 for (kk in seq_along(NAMES)) {
[13:20:25.167]                   name <- removed[[kk]]
[13:20:25.167]                   NAME <- NAMES[[kk]]
[13:20:25.167]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.167]                     next
[13:20:25.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.167]                 }
[13:20:25.167]                 if (length(args) > 0) 
[13:20:25.167]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.167]             }
[13:20:25.167]             else {
[13:20:25.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.167]             }
[13:20:25.167]             {
[13:20:25.167]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.167]                   0L) {
[13:20:25.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.167]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.167]                   base::options(opts)
[13:20:25.167]                 }
[13:20:25.167]                 {
[13:20:25.167]                   {
[13:20:25.167]                     NULL
[13:20:25.167]                     RNGkind("Mersenne-Twister")
[13:20:25.167]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.167]                       inherits = FALSE)
[13:20:25.167]                   }
[13:20:25.167]                   options(future.plan = NULL)
[13:20:25.167]                   if (is.na(NA_character_)) 
[13:20:25.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.167]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.167]                   {
[13:20:25.167]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.167]                     if (!future$lazy) 
[13:20:25.167]                       future <- run(future)
[13:20:25.167]                     invisible(future)
[13:20:25.167]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.167]                 }
[13:20:25.167]             }
[13:20:25.167]         }
[13:20:25.167]     })
[13:20:25.167]     if (TRUE) {
[13:20:25.167]         base::sink(type = "output", split = FALSE)
[13:20:25.167]         if (TRUE) {
[13:20:25.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.167]         }
[13:20:25.167]         else {
[13:20:25.167]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.167]         }
[13:20:25.167]         base::close(...future.stdout)
[13:20:25.167]         ...future.stdout <- NULL
[13:20:25.167]     }
[13:20:25.167]     ...future.result$conditions <- ...future.conditions
[13:20:25.167]     ...future.result$finished <- base::Sys.time()
[13:20:25.167]     ...future.result
[13:20:25.167] }
[13:20:25.169] plan(): Setting new future strategy stack:
[13:20:25.169] List of future strategies:
[13:20:25.169] 1. sequential:
[13:20:25.169]    - args: function (..., envir = parent.frame())
[13:20:25.169]    - tweaked: FALSE
[13:20:25.169]    - call: NULL
[13:20:25.170] plan(): nbrOfWorkers() = 1
[13:20:25.170] plan(): Setting new future strategy stack:
[13:20:25.170] List of future strategies:
[13:20:25.170] 1. sequential:
[13:20:25.170]    - args: function (..., envir = parent.frame())
[13:20:25.170]    - tweaked: FALSE
[13:20:25.170]    - call: plan(strategy)
[13:20:25.171] plan(): nbrOfWorkers() = 1
[13:20:25.171] SequentialFuture started (and completed)
[13:20:25.171] - Launch lazy future ... done
[13:20:25.171] run() for ‘SequentialFuture’ ... done
[13:20:25.171] getGlobalsAndPackages() ...
[13:20:25.172] Searching for globals...
[13:20:25.172] - globals found: [1] ‘{’
[13:20:25.172] Searching for globals ... DONE
[13:20:25.172] Resolving globals: FALSE
[13:20:25.173] 
[13:20:25.173] 
[13:20:25.173] getGlobalsAndPackages() ... DONE
[13:20:25.173] run() for ‘Future’ ...
[13:20:25.173] - state: ‘created’
[13:20:25.173] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.174] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.174] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.174]   - Field: ‘label’
[13:20:25.174]   - Field: ‘local’
[13:20:25.174]   - Field: ‘owner’
[13:20:25.174]   - Field: ‘envir’
[13:20:25.174]   - Field: ‘packages’
[13:20:25.174]   - Field: ‘gc’
[13:20:25.174]   - Field: ‘conditions’
[13:20:25.174]   - Field: ‘expr’
[13:20:25.174]   - Field: ‘uuid’
[13:20:25.175]   - Field: ‘seed’
[13:20:25.175]   - Field: ‘version’
[13:20:25.175]   - Field: ‘result’
[13:20:25.175]   - Field: ‘asynchronous’
[13:20:25.175]   - Field: ‘calls’
[13:20:25.175]   - Field: ‘globals’
[13:20:25.175]   - Field: ‘stdout’
[13:20:25.175]   - Field: ‘earlySignal’
[13:20:25.175]   - Field: ‘lazy’
[13:20:25.175]   - Field: ‘state’
[13:20:25.175] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.176] - Launch lazy future ...
[13:20:25.176] Packages needed by the future expression (n = 0): <none>
[13:20:25.176] Packages needed by future strategies (n = 0): <none>
[13:20:25.176] {
[13:20:25.176]     {
[13:20:25.176]         {
[13:20:25.176]             ...future.startTime <- base::Sys.time()
[13:20:25.176]             {
[13:20:25.176]                 {
[13:20:25.176]                   {
[13:20:25.176]                     base::local({
[13:20:25.176]                       has_future <- base::requireNamespace("future", 
[13:20:25.176]                         quietly = TRUE)
[13:20:25.176]                       if (has_future) {
[13:20:25.176]                         ns <- base::getNamespace("future")
[13:20:25.176]                         version <- ns[[".package"]][["version"]]
[13:20:25.176]                         if (is.null(version)) 
[13:20:25.176]                           version <- utils::packageVersion("future")
[13:20:25.176]                       }
[13:20:25.176]                       else {
[13:20:25.176]                         version <- NULL
[13:20:25.176]                       }
[13:20:25.176]                       if (!has_future || version < "1.8.0") {
[13:20:25.176]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.176]                           "", base::R.version$version.string), 
[13:20:25.176]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.176]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.176]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.176]                             "release", "version")], collapse = " "), 
[13:20:25.176]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.176]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.176]                           info)
[13:20:25.176]                         info <- base::paste(info, collapse = "; ")
[13:20:25.176]                         if (!has_future) {
[13:20:25.176]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.176]                             info)
[13:20:25.176]                         }
[13:20:25.176]                         else {
[13:20:25.176]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.176]                             info, version)
[13:20:25.176]                         }
[13:20:25.176]                         base::stop(msg)
[13:20:25.176]                       }
[13:20:25.176]                     })
[13:20:25.176]                   }
[13:20:25.176]                   options(future.plan = NULL)
[13:20:25.176]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.176]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.176]                 }
[13:20:25.176]                 ...future.workdir <- getwd()
[13:20:25.176]             }
[13:20:25.176]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.176]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.176]         }
[13:20:25.176]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.176]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.176]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.176]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.176]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.176]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.176]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.176]             base::names(...future.oldOptions))
[13:20:25.176]     }
[13:20:25.176]     if (FALSE) {
[13:20:25.176]     }
[13:20:25.176]     else {
[13:20:25.176]         if (TRUE) {
[13:20:25.176]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.176]                 open = "w")
[13:20:25.176]         }
[13:20:25.176]         else {
[13:20:25.176]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.176]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.176]         }
[13:20:25.176]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.176]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.176]             base::sink(type = "output", split = FALSE)
[13:20:25.176]             base::close(...future.stdout)
[13:20:25.176]         }, add = TRUE)
[13:20:25.176]     }
[13:20:25.176]     ...future.frame <- base::sys.nframe()
[13:20:25.176]     ...future.conditions <- base::list()
[13:20:25.176]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.176]     if (FALSE) {
[13:20:25.176]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.176]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.176]     }
[13:20:25.176]     ...future.result <- base::tryCatch({
[13:20:25.176]         base::withCallingHandlers({
[13:20:25.176]             ...future.value <- base::withVisible(base::local({
[13:20:25.176]                 4
[13:20:25.176]             }))
[13:20:25.176]             future::FutureResult(value = ...future.value$value, 
[13:20:25.176]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.176]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.176]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.176]                     ...future.globalenv.names))
[13:20:25.176]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.176]         }, condition = base::local({
[13:20:25.176]             c <- base::c
[13:20:25.176]             inherits <- base::inherits
[13:20:25.176]             invokeRestart <- base::invokeRestart
[13:20:25.176]             length <- base::length
[13:20:25.176]             list <- base::list
[13:20:25.176]             seq.int <- base::seq.int
[13:20:25.176]             signalCondition <- base::signalCondition
[13:20:25.176]             sys.calls <- base::sys.calls
[13:20:25.176]             `[[` <- base::`[[`
[13:20:25.176]             `+` <- base::`+`
[13:20:25.176]             `<<-` <- base::`<<-`
[13:20:25.176]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.176]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.176]                   3L)]
[13:20:25.176]             }
[13:20:25.176]             function(cond) {
[13:20:25.176]                 is_error <- inherits(cond, "error")
[13:20:25.176]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.176]                   NULL)
[13:20:25.176]                 if (is_error) {
[13:20:25.176]                   sessionInformation <- function() {
[13:20:25.176]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.176]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.176]                       search = base::search(), system = base::Sys.info())
[13:20:25.176]                   }
[13:20:25.176]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.176]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.176]                     cond$call), session = sessionInformation(), 
[13:20:25.176]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.176]                   signalCondition(cond)
[13:20:25.176]                 }
[13:20:25.176]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.176]                 "immediateCondition"))) {
[13:20:25.176]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.176]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.176]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.176]                   if (TRUE && !signal) {
[13:20:25.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.176]                     {
[13:20:25.176]                       inherits <- base::inherits
[13:20:25.176]                       invokeRestart <- base::invokeRestart
[13:20:25.176]                       is.null <- base::is.null
[13:20:25.176]                       muffled <- FALSE
[13:20:25.176]                       if (inherits(cond, "message")) {
[13:20:25.176]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.176]                         if (muffled) 
[13:20:25.176]                           invokeRestart("muffleMessage")
[13:20:25.176]                       }
[13:20:25.176]                       else if (inherits(cond, "warning")) {
[13:20:25.176]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.176]                         if (muffled) 
[13:20:25.176]                           invokeRestart("muffleWarning")
[13:20:25.176]                       }
[13:20:25.176]                       else if (inherits(cond, "condition")) {
[13:20:25.176]                         if (!is.null(pattern)) {
[13:20:25.176]                           computeRestarts <- base::computeRestarts
[13:20:25.176]                           grepl <- base::grepl
[13:20:25.176]                           restarts <- computeRestarts(cond)
[13:20:25.176]                           for (restart in restarts) {
[13:20:25.176]                             name <- restart$name
[13:20:25.176]                             if (is.null(name)) 
[13:20:25.176]                               next
[13:20:25.176]                             if (!grepl(pattern, name)) 
[13:20:25.176]                               next
[13:20:25.176]                             invokeRestart(restart)
[13:20:25.176]                             muffled <- TRUE
[13:20:25.176]                             break
[13:20:25.176]                           }
[13:20:25.176]                         }
[13:20:25.176]                       }
[13:20:25.176]                       invisible(muffled)
[13:20:25.176]                     }
[13:20:25.176]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.176]                   }
[13:20:25.176]                 }
[13:20:25.176]                 else {
[13:20:25.176]                   if (TRUE) {
[13:20:25.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.176]                     {
[13:20:25.176]                       inherits <- base::inherits
[13:20:25.176]                       invokeRestart <- base::invokeRestart
[13:20:25.176]                       is.null <- base::is.null
[13:20:25.176]                       muffled <- FALSE
[13:20:25.176]                       if (inherits(cond, "message")) {
[13:20:25.176]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.176]                         if (muffled) 
[13:20:25.176]                           invokeRestart("muffleMessage")
[13:20:25.176]                       }
[13:20:25.176]                       else if (inherits(cond, "warning")) {
[13:20:25.176]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.176]                         if (muffled) 
[13:20:25.176]                           invokeRestart("muffleWarning")
[13:20:25.176]                       }
[13:20:25.176]                       else if (inherits(cond, "condition")) {
[13:20:25.176]                         if (!is.null(pattern)) {
[13:20:25.176]                           computeRestarts <- base::computeRestarts
[13:20:25.176]                           grepl <- base::grepl
[13:20:25.176]                           restarts <- computeRestarts(cond)
[13:20:25.176]                           for (restart in restarts) {
[13:20:25.176]                             name <- restart$name
[13:20:25.176]                             if (is.null(name)) 
[13:20:25.176]                               next
[13:20:25.176]                             if (!grepl(pattern, name)) 
[13:20:25.176]                               next
[13:20:25.176]                             invokeRestart(restart)
[13:20:25.176]                             muffled <- TRUE
[13:20:25.176]                             break
[13:20:25.176]                           }
[13:20:25.176]                         }
[13:20:25.176]                       }
[13:20:25.176]                       invisible(muffled)
[13:20:25.176]                     }
[13:20:25.176]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.176]                   }
[13:20:25.176]                 }
[13:20:25.176]             }
[13:20:25.176]         }))
[13:20:25.176]     }, error = function(ex) {
[13:20:25.176]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.176]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.176]                 ...future.rng), started = ...future.startTime, 
[13:20:25.176]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.176]             version = "1.8"), class = "FutureResult")
[13:20:25.176]     }, finally = {
[13:20:25.176]         if (!identical(...future.workdir, getwd())) 
[13:20:25.176]             setwd(...future.workdir)
[13:20:25.176]         {
[13:20:25.176]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.176]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.176]             }
[13:20:25.176]             base::options(...future.oldOptions)
[13:20:25.176]             if (.Platform$OS.type == "windows") {
[13:20:25.176]                 old_names <- names(...future.oldEnvVars)
[13:20:25.176]                 envs <- base::Sys.getenv()
[13:20:25.176]                 names <- names(envs)
[13:20:25.176]                 common <- intersect(names, old_names)
[13:20:25.176]                 added <- setdiff(names, old_names)
[13:20:25.176]                 removed <- setdiff(old_names, names)
[13:20:25.176]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.176]                   envs[common]]
[13:20:25.176]                 NAMES <- toupper(changed)
[13:20:25.176]                 args <- list()
[13:20:25.176]                 for (kk in seq_along(NAMES)) {
[13:20:25.176]                   name <- changed[[kk]]
[13:20:25.176]                   NAME <- NAMES[[kk]]
[13:20:25.176]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.176]                     next
[13:20:25.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.176]                 }
[13:20:25.176]                 NAMES <- toupper(added)
[13:20:25.176]                 for (kk in seq_along(NAMES)) {
[13:20:25.176]                   name <- added[[kk]]
[13:20:25.176]                   NAME <- NAMES[[kk]]
[13:20:25.176]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.176]                     next
[13:20:25.176]                   args[[name]] <- ""
[13:20:25.176]                 }
[13:20:25.176]                 NAMES <- toupper(removed)
[13:20:25.176]                 for (kk in seq_along(NAMES)) {
[13:20:25.176]                   name <- removed[[kk]]
[13:20:25.176]                   NAME <- NAMES[[kk]]
[13:20:25.176]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.176]                     next
[13:20:25.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.176]                 }
[13:20:25.176]                 if (length(args) > 0) 
[13:20:25.176]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.176]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.176]             }
[13:20:25.176]             else {
[13:20:25.176]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.176]             }
[13:20:25.176]             {
[13:20:25.176]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.176]                   0L) {
[13:20:25.176]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.176]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.176]                   base::options(opts)
[13:20:25.176]                 }
[13:20:25.176]                 {
[13:20:25.176]                   {
[13:20:25.176]                     NULL
[13:20:25.176]                     RNGkind("Mersenne-Twister")
[13:20:25.176]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.176]                       inherits = FALSE)
[13:20:25.176]                   }
[13:20:25.176]                   options(future.plan = NULL)
[13:20:25.176]                   if (is.na(NA_character_)) 
[13:20:25.176]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.176]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.176]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.176]                   {
[13:20:25.176]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.176]                     if (!future$lazy) 
[13:20:25.176]                       future <- run(future)
[13:20:25.176]                     invisible(future)
[13:20:25.176]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.176]                 }
[13:20:25.176]             }
[13:20:25.176]         }
[13:20:25.176]     })
[13:20:25.176]     if (TRUE) {
[13:20:25.176]         base::sink(type = "output", split = FALSE)
[13:20:25.176]         if (TRUE) {
[13:20:25.176]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.176]         }
[13:20:25.176]         else {
[13:20:25.176]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.176]         }
[13:20:25.176]         base::close(...future.stdout)
[13:20:25.176]         ...future.stdout <- NULL
[13:20:25.176]     }
[13:20:25.176]     ...future.result$conditions <- ...future.conditions
[13:20:25.176]     ...future.result$finished <- base::Sys.time()
[13:20:25.176]     ...future.result
[13:20:25.176] }
[13:20:25.178] plan(): Setting new future strategy stack:
[13:20:25.178] List of future strategies:
[13:20:25.178] 1. sequential:
[13:20:25.178]    - args: function (..., envir = parent.frame())
[13:20:25.178]    - tweaked: FALSE
[13:20:25.178]    - call: NULL
[13:20:25.179] plan(): nbrOfWorkers() = 1
[13:20:25.179] plan(): Setting new future strategy stack:
[13:20:25.179] List of future strategies:
[13:20:25.179] 1. sequential:
[13:20:25.179]    - args: function (..., envir = parent.frame())
[13:20:25.179]    - tweaked: FALSE
[13:20:25.179]    - call: plan(strategy)
[13:20:25.180] plan(): nbrOfWorkers() = 1
[13:20:25.180] SequentialFuture started (and completed)
[13:20:25.180] - Launch lazy future ... done
[13:20:25.180] run() for ‘SequentialFuture’ ... done
<environment: 0x55659b0c2ff8> 
<environment: 0x55659bf55a30> 
[13:20:25.181] resolved() for ‘SequentialFuture’ ...
[13:20:25.181] - state: ‘finished’
[13:20:25.182] - run: TRUE
[13:20:25.182] - result: ‘FutureResult’
[13:20:25.182] resolved() for ‘SequentialFuture’ ... done
[13:20:25.182] resolved() for ‘SequentialFuture’ ...
[13:20:25.182] - state: ‘finished’
[13:20:25.182] - run: TRUE
[13:20:25.182] - result: ‘FutureResult’
[13:20:25.182] resolved() for ‘SequentialFuture’ ... done
[13:20:25.182] resolved() for ‘SequentialFuture’ ...
[13:20:25.182] - state: ‘finished’
[13:20:25.182] - run: TRUE
[13:20:25.183] - result: ‘FutureResult’
[13:20:25.183] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:25.186] resolve() on environment ...
[13:20:25.186]  recursive: 0
[13:20:25.186]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:25.186] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.187] - nx: 4
[13:20:25.187] - relay: TRUE
[13:20:25.187] - stdout: TRUE
[13:20:25.187] - signal: TRUE
[13:20:25.187] - resignal: FALSE
[13:20:25.187] - force: TRUE
[13:20:25.187] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.187] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.187]  - until=2
[13:20:25.187]  - relaying element #2
[13:20:25.187] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:25.187] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.188] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.188]  length: 3 (resolved future 1)
[13:20:25.188] resolved() for ‘SequentialFuture’ ...
[13:20:25.188] - state: ‘finished’
[13:20:25.188] - run: TRUE
[13:20:25.188] - result: ‘FutureResult’
[13:20:25.188] resolved() for ‘SequentialFuture’ ... done
[13:20:25.188] Future #2
[13:20:25.188] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.189] - nx: 4
[13:20:25.189] - relay: TRUE
[13:20:25.189] - stdout: TRUE
[13:20:25.189] - signal: TRUE
[13:20:25.189] - resignal: FALSE
[13:20:25.189] - force: TRUE
[13:20:25.189] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:25.189] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.189]  - until=2
[13:20:25.189]  - relaying element #2
[13:20:25.189] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:25.190] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:25.190] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.190]  length: 2 (resolved future 2)
[13:20:25.190] resolved() for ‘SequentialFuture’ ...
[13:20:25.190] - state: ‘finished’
[13:20:25.190] - run: TRUE
[13:20:25.190] - result: ‘FutureResult’
[13:20:25.190] resolved() for ‘SequentialFuture’ ... done
[13:20:25.190] Future #3
[13:20:25.190] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.191] - nx: 4
[13:20:25.191] - relay: TRUE
[13:20:25.191] - stdout: TRUE
[13:20:25.191] - signal: TRUE
[13:20:25.191] - resignal: FALSE
[13:20:25.191] - force: TRUE
[13:20:25.191] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:25.191] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:25.191]  - until=3
[13:20:25.191]  - relaying element #3
[13:20:25.191] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:25.192] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:25.192] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.192]  length: 1 (resolved future 3)
[13:20:25.192] resolved() for ‘SequentialFuture’ ...
[13:20:25.192] - state: ‘finished’
[13:20:25.192] - run: TRUE
[13:20:25.192] - result: ‘FutureResult’
[13:20:25.192] resolved() for ‘SequentialFuture’ ... done
[13:20:25.192] Future #4
[13:20:25.192] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:20:25.193] - nx: 4
[13:20:25.193] - relay: TRUE
[13:20:25.193] - stdout: TRUE
[13:20:25.193] - signal: TRUE
[13:20:25.193] - resignal: FALSE
[13:20:25.193] - force: TRUE
[13:20:25.193] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:25.193] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:25.193]  - until=4
[13:20:25.193]  - relaying element #4
[13:20:25.194] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.194] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:25.194] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:20:25.194]  length: 0 (resolved future 4)
[13:20:25.194] Relaying remaining futures
[13:20:25.194] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.194] - nx: 4
[13:20:25.194] - relay: TRUE
[13:20:25.194] - stdout: TRUE
[13:20:25.194] - signal: TRUE
[13:20:25.194] - resignal: FALSE
[13:20:25.194] - force: TRUE
[13:20:25.195] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.195] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:25.195] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.195] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:25.195] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.195] resolve() on environment ... DONE
<environment: 0x55659b082680> 
Dimensions: c(2, 3)
[13:20:25.196] getGlobalsAndPackages() ...
[13:20:25.196] Searching for globals...
[13:20:25.196] 
[13:20:25.196] Searching for globals ... DONE
[13:20:25.196] - globals: [0] <none>
[13:20:25.196] getGlobalsAndPackages() ... DONE
[13:20:25.196] run() for ‘Future’ ...
[13:20:25.197] - state: ‘created’
[13:20:25.197] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.197] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.197] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.197]   - Field: ‘label’
[13:20:25.197]   - Field: ‘local’
[13:20:25.197]   - Field: ‘owner’
[13:20:25.197]   - Field: ‘envir’
[13:20:25.198]   - Field: ‘packages’
[13:20:25.198]   - Field: ‘gc’
[13:20:25.198]   - Field: ‘conditions’
[13:20:25.198]   - Field: ‘expr’
[13:20:25.198]   - Field: ‘uuid’
[13:20:25.198]   - Field: ‘seed’
[13:20:25.198]   - Field: ‘version’
[13:20:25.198]   - Field: ‘result’
[13:20:25.198]   - Field: ‘asynchronous’
[13:20:25.198]   - Field: ‘calls’
[13:20:25.198]   - Field: ‘globals’
[13:20:25.199]   - Field: ‘stdout’
[13:20:25.199]   - Field: ‘earlySignal’
[13:20:25.199]   - Field: ‘lazy’
[13:20:25.199]   - Field: ‘state’
[13:20:25.199] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.199] - Launch lazy future ...
[13:20:25.199] Packages needed by the future expression (n = 0): <none>
[13:20:25.199] Packages needed by future strategies (n = 0): <none>
[13:20:25.200] {
[13:20:25.200]     {
[13:20:25.200]         {
[13:20:25.200]             ...future.startTime <- base::Sys.time()
[13:20:25.200]             {
[13:20:25.200]                 {
[13:20:25.200]                   {
[13:20:25.200]                     base::local({
[13:20:25.200]                       has_future <- base::requireNamespace("future", 
[13:20:25.200]                         quietly = TRUE)
[13:20:25.200]                       if (has_future) {
[13:20:25.200]                         ns <- base::getNamespace("future")
[13:20:25.200]                         version <- ns[[".package"]][["version"]]
[13:20:25.200]                         if (is.null(version)) 
[13:20:25.200]                           version <- utils::packageVersion("future")
[13:20:25.200]                       }
[13:20:25.200]                       else {
[13:20:25.200]                         version <- NULL
[13:20:25.200]                       }
[13:20:25.200]                       if (!has_future || version < "1.8.0") {
[13:20:25.200]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.200]                           "", base::R.version$version.string), 
[13:20:25.200]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.200]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.200]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.200]                             "release", "version")], collapse = " "), 
[13:20:25.200]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.200]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.200]                           info)
[13:20:25.200]                         info <- base::paste(info, collapse = "; ")
[13:20:25.200]                         if (!has_future) {
[13:20:25.200]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.200]                             info)
[13:20:25.200]                         }
[13:20:25.200]                         else {
[13:20:25.200]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.200]                             info, version)
[13:20:25.200]                         }
[13:20:25.200]                         base::stop(msg)
[13:20:25.200]                       }
[13:20:25.200]                     })
[13:20:25.200]                   }
[13:20:25.200]                   options(future.plan = NULL)
[13:20:25.200]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.200]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.200]                 }
[13:20:25.200]                 ...future.workdir <- getwd()
[13:20:25.200]             }
[13:20:25.200]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.200]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.200]         }
[13:20:25.200]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.200]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.200]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.200]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.200]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.200]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.200]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.200]             base::names(...future.oldOptions))
[13:20:25.200]     }
[13:20:25.200]     if (FALSE) {
[13:20:25.200]     }
[13:20:25.200]     else {
[13:20:25.200]         if (TRUE) {
[13:20:25.200]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.200]                 open = "w")
[13:20:25.200]         }
[13:20:25.200]         else {
[13:20:25.200]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.200]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.200]         }
[13:20:25.200]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.200]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.200]             base::sink(type = "output", split = FALSE)
[13:20:25.200]             base::close(...future.stdout)
[13:20:25.200]         }, add = TRUE)
[13:20:25.200]     }
[13:20:25.200]     ...future.frame <- base::sys.nframe()
[13:20:25.200]     ...future.conditions <- base::list()
[13:20:25.200]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.200]     if (FALSE) {
[13:20:25.200]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.200]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.200]     }
[13:20:25.200]     ...future.result <- base::tryCatch({
[13:20:25.200]         base::withCallingHandlers({
[13:20:25.200]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.200]             future::FutureResult(value = ...future.value$value, 
[13:20:25.200]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.200]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.200]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.200]                     ...future.globalenv.names))
[13:20:25.200]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.200]         }, condition = base::local({
[13:20:25.200]             c <- base::c
[13:20:25.200]             inherits <- base::inherits
[13:20:25.200]             invokeRestart <- base::invokeRestart
[13:20:25.200]             length <- base::length
[13:20:25.200]             list <- base::list
[13:20:25.200]             seq.int <- base::seq.int
[13:20:25.200]             signalCondition <- base::signalCondition
[13:20:25.200]             sys.calls <- base::sys.calls
[13:20:25.200]             `[[` <- base::`[[`
[13:20:25.200]             `+` <- base::`+`
[13:20:25.200]             `<<-` <- base::`<<-`
[13:20:25.200]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.200]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.200]                   3L)]
[13:20:25.200]             }
[13:20:25.200]             function(cond) {
[13:20:25.200]                 is_error <- inherits(cond, "error")
[13:20:25.200]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.200]                   NULL)
[13:20:25.200]                 if (is_error) {
[13:20:25.200]                   sessionInformation <- function() {
[13:20:25.200]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.200]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.200]                       search = base::search(), system = base::Sys.info())
[13:20:25.200]                   }
[13:20:25.200]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.200]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.200]                     cond$call), session = sessionInformation(), 
[13:20:25.200]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.200]                   signalCondition(cond)
[13:20:25.200]                 }
[13:20:25.200]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.200]                 "immediateCondition"))) {
[13:20:25.200]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.200]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.200]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.200]                   if (TRUE && !signal) {
[13:20:25.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.200]                     {
[13:20:25.200]                       inherits <- base::inherits
[13:20:25.200]                       invokeRestart <- base::invokeRestart
[13:20:25.200]                       is.null <- base::is.null
[13:20:25.200]                       muffled <- FALSE
[13:20:25.200]                       if (inherits(cond, "message")) {
[13:20:25.200]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.200]                         if (muffled) 
[13:20:25.200]                           invokeRestart("muffleMessage")
[13:20:25.200]                       }
[13:20:25.200]                       else if (inherits(cond, "warning")) {
[13:20:25.200]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.200]                         if (muffled) 
[13:20:25.200]                           invokeRestart("muffleWarning")
[13:20:25.200]                       }
[13:20:25.200]                       else if (inherits(cond, "condition")) {
[13:20:25.200]                         if (!is.null(pattern)) {
[13:20:25.200]                           computeRestarts <- base::computeRestarts
[13:20:25.200]                           grepl <- base::grepl
[13:20:25.200]                           restarts <- computeRestarts(cond)
[13:20:25.200]                           for (restart in restarts) {
[13:20:25.200]                             name <- restart$name
[13:20:25.200]                             if (is.null(name)) 
[13:20:25.200]                               next
[13:20:25.200]                             if (!grepl(pattern, name)) 
[13:20:25.200]                               next
[13:20:25.200]                             invokeRestart(restart)
[13:20:25.200]                             muffled <- TRUE
[13:20:25.200]                             break
[13:20:25.200]                           }
[13:20:25.200]                         }
[13:20:25.200]                       }
[13:20:25.200]                       invisible(muffled)
[13:20:25.200]                     }
[13:20:25.200]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.200]                   }
[13:20:25.200]                 }
[13:20:25.200]                 else {
[13:20:25.200]                   if (TRUE) {
[13:20:25.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.200]                     {
[13:20:25.200]                       inherits <- base::inherits
[13:20:25.200]                       invokeRestart <- base::invokeRestart
[13:20:25.200]                       is.null <- base::is.null
[13:20:25.200]                       muffled <- FALSE
[13:20:25.200]                       if (inherits(cond, "message")) {
[13:20:25.200]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.200]                         if (muffled) 
[13:20:25.200]                           invokeRestart("muffleMessage")
[13:20:25.200]                       }
[13:20:25.200]                       else if (inherits(cond, "warning")) {
[13:20:25.200]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.200]                         if (muffled) 
[13:20:25.200]                           invokeRestart("muffleWarning")
[13:20:25.200]                       }
[13:20:25.200]                       else if (inherits(cond, "condition")) {
[13:20:25.200]                         if (!is.null(pattern)) {
[13:20:25.200]                           computeRestarts <- base::computeRestarts
[13:20:25.200]                           grepl <- base::grepl
[13:20:25.200]                           restarts <- computeRestarts(cond)
[13:20:25.200]                           for (restart in restarts) {
[13:20:25.200]                             name <- restart$name
[13:20:25.200]                             if (is.null(name)) 
[13:20:25.200]                               next
[13:20:25.200]                             if (!grepl(pattern, name)) 
[13:20:25.200]                               next
[13:20:25.200]                             invokeRestart(restart)
[13:20:25.200]                             muffled <- TRUE
[13:20:25.200]                             break
[13:20:25.200]                           }
[13:20:25.200]                         }
[13:20:25.200]                       }
[13:20:25.200]                       invisible(muffled)
[13:20:25.200]                     }
[13:20:25.200]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.200]                   }
[13:20:25.200]                 }
[13:20:25.200]             }
[13:20:25.200]         }))
[13:20:25.200]     }, error = function(ex) {
[13:20:25.200]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.200]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.200]                 ...future.rng), started = ...future.startTime, 
[13:20:25.200]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.200]             version = "1.8"), class = "FutureResult")
[13:20:25.200]     }, finally = {
[13:20:25.200]         if (!identical(...future.workdir, getwd())) 
[13:20:25.200]             setwd(...future.workdir)
[13:20:25.200]         {
[13:20:25.200]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.200]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.200]             }
[13:20:25.200]             base::options(...future.oldOptions)
[13:20:25.200]             if (.Platform$OS.type == "windows") {
[13:20:25.200]                 old_names <- names(...future.oldEnvVars)
[13:20:25.200]                 envs <- base::Sys.getenv()
[13:20:25.200]                 names <- names(envs)
[13:20:25.200]                 common <- intersect(names, old_names)
[13:20:25.200]                 added <- setdiff(names, old_names)
[13:20:25.200]                 removed <- setdiff(old_names, names)
[13:20:25.200]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.200]                   envs[common]]
[13:20:25.200]                 NAMES <- toupper(changed)
[13:20:25.200]                 args <- list()
[13:20:25.200]                 for (kk in seq_along(NAMES)) {
[13:20:25.200]                   name <- changed[[kk]]
[13:20:25.200]                   NAME <- NAMES[[kk]]
[13:20:25.200]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.200]                     next
[13:20:25.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.200]                 }
[13:20:25.200]                 NAMES <- toupper(added)
[13:20:25.200]                 for (kk in seq_along(NAMES)) {
[13:20:25.200]                   name <- added[[kk]]
[13:20:25.200]                   NAME <- NAMES[[kk]]
[13:20:25.200]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.200]                     next
[13:20:25.200]                   args[[name]] <- ""
[13:20:25.200]                 }
[13:20:25.200]                 NAMES <- toupper(removed)
[13:20:25.200]                 for (kk in seq_along(NAMES)) {
[13:20:25.200]                   name <- removed[[kk]]
[13:20:25.200]                   NAME <- NAMES[[kk]]
[13:20:25.200]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.200]                     next
[13:20:25.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.200]                 }
[13:20:25.200]                 if (length(args) > 0) 
[13:20:25.200]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.200]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.200]             }
[13:20:25.200]             else {
[13:20:25.200]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.200]             }
[13:20:25.200]             {
[13:20:25.200]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.200]                   0L) {
[13:20:25.200]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.200]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.200]                   base::options(opts)
[13:20:25.200]                 }
[13:20:25.200]                 {
[13:20:25.200]                   {
[13:20:25.200]                     NULL
[13:20:25.200]                     RNGkind("Mersenne-Twister")
[13:20:25.200]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.200]                       inherits = FALSE)
[13:20:25.200]                   }
[13:20:25.200]                   options(future.plan = NULL)
[13:20:25.200]                   if (is.na(NA_character_)) 
[13:20:25.200]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.200]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.200]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.200]                   {
[13:20:25.200]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.200]                     if (!future$lazy) 
[13:20:25.200]                       future <- run(future)
[13:20:25.200]                     invisible(future)
[13:20:25.200]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.200]                 }
[13:20:25.200]             }
[13:20:25.200]         }
[13:20:25.200]     })
[13:20:25.200]     if (TRUE) {
[13:20:25.200]         base::sink(type = "output", split = FALSE)
[13:20:25.200]         if (TRUE) {
[13:20:25.200]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.200]         }
[13:20:25.200]         else {
[13:20:25.200]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.200]         }
[13:20:25.200]         base::close(...future.stdout)
[13:20:25.200]         ...future.stdout <- NULL
[13:20:25.200]     }
[13:20:25.200]     ...future.result$conditions <- ...future.conditions
[13:20:25.200]     ...future.result$finished <- base::Sys.time()
[13:20:25.200]     ...future.result
[13:20:25.200] }
[13:20:25.202] plan(): Setting new future strategy stack:
[13:20:25.202] List of future strategies:
[13:20:25.202] 1. sequential:
[13:20:25.202]    - args: function (..., envir = parent.frame())
[13:20:25.202]    - tweaked: FALSE
[13:20:25.202]    - call: NULL
[13:20:25.202] plan(): nbrOfWorkers() = 1
[13:20:25.203] plan(): Setting new future strategy stack:
[13:20:25.203] List of future strategies:
[13:20:25.203] 1. sequential:
[13:20:25.203]    - args: function (..., envir = parent.frame())
[13:20:25.203]    - tweaked: FALSE
[13:20:25.203]    - call: plan(strategy)
[13:20:25.203] plan(): nbrOfWorkers() = 1
[13:20:25.204] SequentialFuture started (and completed)
[13:20:25.204] - Launch lazy future ... done
[13:20:25.204] run() for ‘SequentialFuture’ ... done
[13:20:25.204] getGlobalsAndPackages() ...
[13:20:25.204] Searching for globals...
[13:20:25.204] 
[13:20:25.204] Searching for globals ... DONE
[13:20:25.204] - globals: [0] <none>
[13:20:25.205] getGlobalsAndPackages() ... DONE
[13:20:25.205] run() for ‘Future’ ...
[13:20:25.205] - state: ‘created’
[13:20:25.205] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.205] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.205] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.206]   - Field: ‘label’
[13:20:25.206]   - Field: ‘local’
[13:20:25.206]   - Field: ‘owner’
[13:20:25.206]   - Field: ‘envir’
[13:20:25.206]   - Field: ‘packages’
[13:20:25.206]   - Field: ‘gc’
[13:20:25.206]   - Field: ‘conditions’
[13:20:25.206]   - Field: ‘expr’
[13:20:25.206]   - Field: ‘uuid’
[13:20:25.206]   - Field: ‘seed’
[13:20:25.206]   - Field: ‘version’
[13:20:25.207]   - Field: ‘result’
[13:20:25.207]   - Field: ‘asynchronous’
[13:20:25.207]   - Field: ‘calls’
[13:20:25.207]   - Field: ‘globals’
[13:20:25.207]   - Field: ‘stdout’
[13:20:25.207]   - Field: ‘earlySignal’
[13:20:25.207]   - Field: ‘lazy’
[13:20:25.207]   - Field: ‘state’
[13:20:25.207] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.207] - Launch lazy future ...
[13:20:25.208] Packages needed by the future expression (n = 0): <none>
[13:20:25.208] Packages needed by future strategies (n = 0): <none>
[13:20:25.208] {
[13:20:25.208]     {
[13:20:25.208]         {
[13:20:25.208]             ...future.startTime <- base::Sys.time()
[13:20:25.208]             {
[13:20:25.208]                 {
[13:20:25.208]                   {
[13:20:25.208]                     base::local({
[13:20:25.208]                       has_future <- base::requireNamespace("future", 
[13:20:25.208]                         quietly = TRUE)
[13:20:25.208]                       if (has_future) {
[13:20:25.208]                         ns <- base::getNamespace("future")
[13:20:25.208]                         version <- ns[[".package"]][["version"]]
[13:20:25.208]                         if (is.null(version)) 
[13:20:25.208]                           version <- utils::packageVersion("future")
[13:20:25.208]                       }
[13:20:25.208]                       else {
[13:20:25.208]                         version <- NULL
[13:20:25.208]                       }
[13:20:25.208]                       if (!has_future || version < "1.8.0") {
[13:20:25.208]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.208]                           "", base::R.version$version.string), 
[13:20:25.208]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.208]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.208]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.208]                             "release", "version")], collapse = " "), 
[13:20:25.208]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.208]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.208]                           info)
[13:20:25.208]                         info <- base::paste(info, collapse = "; ")
[13:20:25.208]                         if (!has_future) {
[13:20:25.208]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.208]                             info)
[13:20:25.208]                         }
[13:20:25.208]                         else {
[13:20:25.208]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.208]                             info, version)
[13:20:25.208]                         }
[13:20:25.208]                         base::stop(msg)
[13:20:25.208]                       }
[13:20:25.208]                     })
[13:20:25.208]                   }
[13:20:25.208]                   options(future.plan = NULL)
[13:20:25.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.208]                 }
[13:20:25.208]                 ...future.workdir <- getwd()
[13:20:25.208]             }
[13:20:25.208]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.208]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.208]         }
[13:20:25.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.208]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.208]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.208]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.208]             base::names(...future.oldOptions))
[13:20:25.208]     }
[13:20:25.208]     if (FALSE) {
[13:20:25.208]     }
[13:20:25.208]     else {
[13:20:25.208]         if (TRUE) {
[13:20:25.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.208]                 open = "w")
[13:20:25.208]         }
[13:20:25.208]         else {
[13:20:25.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.208]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.208]         }
[13:20:25.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.208]             base::sink(type = "output", split = FALSE)
[13:20:25.208]             base::close(...future.stdout)
[13:20:25.208]         }, add = TRUE)
[13:20:25.208]     }
[13:20:25.208]     ...future.frame <- base::sys.nframe()
[13:20:25.208]     ...future.conditions <- base::list()
[13:20:25.208]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.208]     if (FALSE) {
[13:20:25.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.208]     }
[13:20:25.208]     ...future.result <- base::tryCatch({
[13:20:25.208]         base::withCallingHandlers({
[13:20:25.208]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.208]             future::FutureResult(value = ...future.value$value, 
[13:20:25.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.208]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.208]                     ...future.globalenv.names))
[13:20:25.208]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.208]         }, condition = base::local({
[13:20:25.208]             c <- base::c
[13:20:25.208]             inherits <- base::inherits
[13:20:25.208]             invokeRestart <- base::invokeRestart
[13:20:25.208]             length <- base::length
[13:20:25.208]             list <- base::list
[13:20:25.208]             seq.int <- base::seq.int
[13:20:25.208]             signalCondition <- base::signalCondition
[13:20:25.208]             sys.calls <- base::sys.calls
[13:20:25.208]             `[[` <- base::`[[`
[13:20:25.208]             `+` <- base::`+`
[13:20:25.208]             `<<-` <- base::`<<-`
[13:20:25.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.208]                   3L)]
[13:20:25.208]             }
[13:20:25.208]             function(cond) {
[13:20:25.208]                 is_error <- inherits(cond, "error")
[13:20:25.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.208]                   NULL)
[13:20:25.208]                 if (is_error) {
[13:20:25.208]                   sessionInformation <- function() {
[13:20:25.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.208]                       search = base::search(), system = base::Sys.info())
[13:20:25.208]                   }
[13:20:25.208]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.208]                     cond$call), session = sessionInformation(), 
[13:20:25.208]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.208]                   signalCondition(cond)
[13:20:25.208]                 }
[13:20:25.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.208]                 "immediateCondition"))) {
[13:20:25.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.208]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.208]                   if (TRUE && !signal) {
[13:20:25.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.208]                     {
[13:20:25.208]                       inherits <- base::inherits
[13:20:25.208]                       invokeRestart <- base::invokeRestart
[13:20:25.208]                       is.null <- base::is.null
[13:20:25.208]                       muffled <- FALSE
[13:20:25.208]                       if (inherits(cond, "message")) {
[13:20:25.208]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.208]                         if (muffled) 
[13:20:25.208]                           invokeRestart("muffleMessage")
[13:20:25.208]                       }
[13:20:25.208]                       else if (inherits(cond, "warning")) {
[13:20:25.208]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.208]                         if (muffled) 
[13:20:25.208]                           invokeRestart("muffleWarning")
[13:20:25.208]                       }
[13:20:25.208]                       else if (inherits(cond, "condition")) {
[13:20:25.208]                         if (!is.null(pattern)) {
[13:20:25.208]                           computeRestarts <- base::computeRestarts
[13:20:25.208]                           grepl <- base::grepl
[13:20:25.208]                           restarts <- computeRestarts(cond)
[13:20:25.208]                           for (restart in restarts) {
[13:20:25.208]                             name <- restart$name
[13:20:25.208]                             if (is.null(name)) 
[13:20:25.208]                               next
[13:20:25.208]                             if (!grepl(pattern, name)) 
[13:20:25.208]                               next
[13:20:25.208]                             invokeRestart(restart)
[13:20:25.208]                             muffled <- TRUE
[13:20:25.208]                             break
[13:20:25.208]                           }
[13:20:25.208]                         }
[13:20:25.208]                       }
[13:20:25.208]                       invisible(muffled)
[13:20:25.208]                     }
[13:20:25.208]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.208]                   }
[13:20:25.208]                 }
[13:20:25.208]                 else {
[13:20:25.208]                   if (TRUE) {
[13:20:25.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.208]                     {
[13:20:25.208]                       inherits <- base::inherits
[13:20:25.208]                       invokeRestart <- base::invokeRestart
[13:20:25.208]                       is.null <- base::is.null
[13:20:25.208]                       muffled <- FALSE
[13:20:25.208]                       if (inherits(cond, "message")) {
[13:20:25.208]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.208]                         if (muffled) 
[13:20:25.208]                           invokeRestart("muffleMessage")
[13:20:25.208]                       }
[13:20:25.208]                       else if (inherits(cond, "warning")) {
[13:20:25.208]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.208]                         if (muffled) 
[13:20:25.208]                           invokeRestart("muffleWarning")
[13:20:25.208]                       }
[13:20:25.208]                       else if (inherits(cond, "condition")) {
[13:20:25.208]                         if (!is.null(pattern)) {
[13:20:25.208]                           computeRestarts <- base::computeRestarts
[13:20:25.208]                           grepl <- base::grepl
[13:20:25.208]                           restarts <- computeRestarts(cond)
[13:20:25.208]                           for (restart in restarts) {
[13:20:25.208]                             name <- restart$name
[13:20:25.208]                             if (is.null(name)) 
[13:20:25.208]                               next
[13:20:25.208]                             if (!grepl(pattern, name)) 
[13:20:25.208]                               next
[13:20:25.208]                             invokeRestart(restart)
[13:20:25.208]                             muffled <- TRUE
[13:20:25.208]                             break
[13:20:25.208]                           }
[13:20:25.208]                         }
[13:20:25.208]                       }
[13:20:25.208]                       invisible(muffled)
[13:20:25.208]                     }
[13:20:25.208]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.208]                   }
[13:20:25.208]                 }
[13:20:25.208]             }
[13:20:25.208]         }))
[13:20:25.208]     }, error = function(ex) {
[13:20:25.208]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.208]                 ...future.rng), started = ...future.startTime, 
[13:20:25.208]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.208]             version = "1.8"), class = "FutureResult")
[13:20:25.208]     }, finally = {
[13:20:25.208]         if (!identical(...future.workdir, getwd())) 
[13:20:25.208]             setwd(...future.workdir)
[13:20:25.208]         {
[13:20:25.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.208]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.208]             }
[13:20:25.208]             base::options(...future.oldOptions)
[13:20:25.208]             if (.Platform$OS.type == "windows") {
[13:20:25.208]                 old_names <- names(...future.oldEnvVars)
[13:20:25.208]                 envs <- base::Sys.getenv()
[13:20:25.208]                 names <- names(envs)
[13:20:25.208]                 common <- intersect(names, old_names)
[13:20:25.208]                 added <- setdiff(names, old_names)
[13:20:25.208]                 removed <- setdiff(old_names, names)
[13:20:25.208]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.208]                   envs[common]]
[13:20:25.208]                 NAMES <- toupper(changed)
[13:20:25.208]                 args <- list()
[13:20:25.208]                 for (kk in seq_along(NAMES)) {
[13:20:25.208]                   name <- changed[[kk]]
[13:20:25.208]                   NAME <- NAMES[[kk]]
[13:20:25.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.208]                     next
[13:20:25.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.208]                 }
[13:20:25.208]                 NAMES <- toupper(added)
[13:20:25.208]                 for (kk in seq_along(NAMES)) {
[13:20:25.208]                   name <- added[[kk]]
[13:20:25.208]                   NAME <- NAMES[[kk]]
[13:20:25.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.208]                     next
[13:20:25.208]                   args[[name]] <- ""
[13:20:25.208]                 }
[13:20:25.208]                 NAMES <- toupper(removed)
[13:20:25.208]                 for (kk in seq_along(NAMES)) {
[13:20:25.208]                   name <- removed[[kk]]
[13:20:25.208]                   NAME <- NAMES[[kk]]
[13:20:25.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.208]                     next
[13:20:25.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.208]                 }
[13:20:25.208]                 if (length(args) > 0) 
[13:20:25.208]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.208]             }
[13:20:25.208]             else {
[13:20:25.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.208]             }
[13:20:25.208]             {
[13:20:25.208]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.208]                   0L) {
[13:20:25.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.208]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.208]                   base::options(opts)
[13:20:25.208]                 }
[13:20:25.208]                 {
[13:20:25.208]                   {
[13:20:25.208]                     NULL
[13:20:25.208]                     RNGkind("Mersenne-Twister")
[13:20:25.208]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.208]                       inherits = FALSE)
[13:20:25.208]                   }
[13:20:25.208]                   options(future.plan = NULL)
[13:20:25.208]                   if (is.na(NA_character_)) 
[13:20:25.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.208]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.208]                   {
[13:20:25.208]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.208]                     if (!future$lazy) 
[13:20:25.208]                       future <- run(future)
[13:20:25.208]                     invisible(future)
[13:20:25.208]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.208]                 }
[13:20:25.208]             }
[13:20:25.208]         }
[13:20:25.208]     })
[13:20:25.208]     if (TRUE) {
[13:20:25.208]         base::sink(type = "output", split = FALSE)
[13:20:25.208]         if (TRUE) {
[13:20:25.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.208]         }
[13:20:25.208]         else {
[13:20:25.208]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.208]         }
[13:20:25.208]         base::close(...future.stdout)
[13:20:25.208]         ...future.stdout <- NULL
[13:20:25.208]     }
[13:20:25.208]     ...future.result$conditions <- ...future.conditions
[13:20:25.208]     ...future.result$finished <- base::Sys.time()
[13:20:25.208]     ...future.result
[13:20:25.208] }
[13:20:25.210] plan(): Setting new future strategy stack:
[13:20:25.210] List of future strategies:
[13:20:25.210] 1. sequential:
[13:20:25.210]    - args: function (..., envir = parent.frame())
[13:20:25.210]    - tweaked: FALSE
[13:20:25.210]    - call: NULL
[13:20:25.210] plan(): nbrOfWorkers() = 1
[13:20:25.211] plan(): Setting new future strategy stack:
[13:20:25.211] List of future strategies:
[13:20:25.211] 1. sequential:
[13:20:25.211]    - args: function (..., envir = parent.frame())
[13:20:25.211]    - tweaked: FALSE
[13:20:25.211]    - call: plan(strategy)
[13:20:25.214] plan(): nbrOfWorkers() = 1
[13:20:25.214] SequentialFuture started (and completed)
[13:20:25.214] - Launch lazy future ... done
[13:20:25.214] run() for ‘SequentialFuture’ ... done
[13:20:25.214] getGlobalsAndPackages() ...
[13:20:25.214] Searching for globals...
[13:20:25.215] - globals found: [1] ‘{’
[13:20:25.215] Searching for globals ... DONE
[13:20:25.215] Resolving globals: FALSE
[13:20:25.216] 
[13:20:25.216] 
[13:20:25.216] getGlobalsAndPackages() ... DONE
[13:20:25.216] run() for ‘Future’ ...
[13:20:25.216] - state: ‘created’
[13:20:25.216] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.217] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.217] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.217]   - Field: ‘label’
[13:20:25.217]   - Field: ‘local’
[13:20:25.217]   - Field: ‘owner’
[13:20:25.217]   - Field: ‘envir’
[13:20:25.217]   - Field: ‘packages’
[13:20:25.217]   - Field: ‘gc’
[13:20:25.217]   - Field: ‘conditions’
[13:20:25.217]   - Field: ‘expr’
[13:20:25.218]   - Field: ‘uuid’
[13:20:25.218]   - Field: ‘seed’
[13:20:25.218]   - Field: ‘version’
[13:20:25.218]   - Field: ‘result’
[13:20:25.218]   - Field: ‘asynchronous’
[13:20:25.218]   - Field: ‘calls’
[13:20:25.218]   - Field: ‘globals’
[13:20:25.218]   - Field: ‘stdout’
[13:20:25.218]   - Field: ‘earlySignal’
[13:20:25.218]   - Field: ‘lazy’
[13:20:25.218]   - Field: ‘state’
[13:20:25.219] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.219] - Launch lazy future ...
[13:20:25.219] Packages needed by the future expression (n = 0): <none>
[13:20:25.219] Packages needed by future strategies (n = 0): <none>
[13:20:25.219] {
[13:20:25.219]     {
[13:20:25.219]         {
[13:20:25.219]             ...future.startTime <- base::Sys.time()
[13:20:25.219]             {
[13:20:25.219]                 {
[13:20:25.219]                   {
[13:20:25.219]                     base::local({
[13:20:25.219]                       has_future <- base::requireNamespace("future", 
[13:20:25.219]                         quietly = TRUE)
[13:20:25.219]                       if (has_future) {
[13:20:25.219]                         ns <- base::getNamespace("future")
[13:20:25.219]                         version <- ns[[".package"]][["version"]]
[13:20:25.219]                         if (is.null(version)) 
[13:20:25.219]                           version <- utils::packageVersion("future")
[13:20:25.219]                       }
[13:20:25.219]                       else {
[13:20:25.219]                         version <- NULL
[13:20:25.219]                       }
[13:20:25.219]                       if (!has_future || version < "1.8.0") {
[13:20:25.219]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.219]                           "", base::R.version$version.string), 
[13:20:25.219]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.219]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.219]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.219]                             "release", "version")], collapse = " "), 
[13:20:25.219]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.219]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.219]                           info)
[13:20:25.219]                         info <- base::paste(info, collapse = "; ")
[13:20:25.219]                         if (!has_future) {
[13:20:25.219]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.219]                             info)
[13:20:25.219]                         }
[13:20:25.219]                         else {
[13:20:25.219]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.219]                             info, version)
[13:20:25.219]                         }
[13:20:25.219]                         base::stop(msg)
[13:20:25.219]                       }
[13:20:25.219]                     })
[13:20:25.219]                   }
[13:20:25.219]                   options(future.plan = NULL)
[13:20:25.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.219]                 }
[13:20:25.219]                 ...future.workdir <- getwd()
[13:20:25.219]             }
[13:20:25.219]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.219]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.219]         }
[13:20:25.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.219]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.219]             base::names(...future.oldOptions))
[13:20:25.219]     }
[13:20:25.219]     if (FALSE) {
[13:20:25.219]     }
[13:20:25.219]     else {
[13:20:25.219]         if (TRUE) {
[13:20:25.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.219]                 open = "w")
[13:20:25.219]         }
[13:20:25.219]         else {
[13:20:25.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.219]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.219]         }
[13:20:25.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.219]             base::sink(type = "output", split = FALSE)
[13:20:25.219]             base::close(...future.stdout)
[13:20:25.219]         }, add = TRUE)
[13:20:25.219]     }
[13:20:25.219]     ...future.frame <- base::sys.nframe()
[13:20:25.219]     ...future.conditions <- base::list()
[13:20:25.219]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.219]     if (FALSE) {
[13:20:25.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.219]     }
[13:20:25.219]     ...future.result <- base::tryCatch({
[13:20:25.219]         base::withCallingHandlers({
[13:20:25.219]             ...future.value <- base::withVisible(base::local({
[13:20:25.219]                 4
[13:20:25.219]             }))
[13:20:25.219]             future::FutureResult(value = ...future.value$value, 
[13:20:25.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.219]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.219]                     ...future.globalenv.names))
[13:20:25.219]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.219]         }, condition = base::local({
[13:20:25.219]             c <- base::c
[13:20:25.219]             inherits <- base::inherits
[13:20:25.219]             invokeRestart <- base::invokeRestart
[13:20:25.219]             length <- base::length
[13:20:25.219]             list <- base::list
[13:20:25.219]             seq.int <- base::seq.int
[13:20:25.219]             signalCondition <- base::signalCondition
[13:20:25.219]             sys.calls <- base::sys.calls
[13:20:25.219]             `[[` <- base::`[[`
[13:20:25.219]             `+` <- base::`+`
[13:20:25.219]             `<<-` <- base::`<<-`
[13:20:25.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.219]                   3L)]
[13:20:25.219]             }
[13:20:25.219]             function(cond) {
[13:20:25.219]                 is_error <- inherits(cond, "error")
[13:20:25.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.219]                   NULL)
[13:20:25.219]                 if (is_error) {
[13:20:25.219]                   sessionInformation <- function() {
[13:20:25.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.219]                       search = base::search(), system = base::Sys.info())
[13:20:25.219]                   }
[13:20:25.219]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.219]                     cond$call), session = sessionInformation(), 
[13:20:25.219]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.219]                   signalCondition(cond)
[13:20:25.219]                 }
[13:20:25.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.219]                 "immediateCondition"))) {
[13:20:25.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.219]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.219]                   if (TRUE && !signal) {
[13:20:25.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.219]                     {
[13:20:25.219]                       inherits <- base::inherits
[13:20:25.219]                       invokeRestart <- base::invokeRestart
[13:20:25.219]                       is.null <- base::is.null
[13:20:25.219]                       muffled <- FALSE
[13:20:25.219]                       if (inherits(cond, "message")) {
[13:20:25.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.219]                         if (muffled) 
[13:20:25.219]                           invokeRestart("muffleMessage")
[13:20:25.219]                       }
[13:20:25.219]                       else if (inherits(cond, "warning")) {
[13:20:25.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.219]                         if (muffled) 
[13:20:25.219]                           invokeRestart("muffleWarning")
[13:20:25.219]                       }
[13:20:25.219]                       else if (inherits(cond, "condition")) {
[13:20:25.219]                         if (!is.null(pattern)) {
[13:20:25.219]                           computeRestarts <- base::computeRestarts
[13:20:25.219]                           grepl <- base::grepl
[13:20:25.219]                           restarts <- computeRestarts(cond)
[13:20:25.219]                           for (restart in restarts) {
[13:20:25.219]                             name <- restart$name
[13:20:25.219]                             if (is.null(name)) 
[13:20:25.219]                               next
[13:20:25.219]                             if (!grepl(pattern, name)) 
[13:20:25.219]                               next
[13:20:25.219]                             invokeRestart(restart)
[13:20:25.219]                             muffled <- TRUE
[13:20:25.219]                             break
[13:20:25.219]                           }
[13:20:25.219]                         }
[13:20:25.219]                       }
[13:20:25.219]                       invisible(muffled)
[13:20:25.219]                     }
[13:20:25.219]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.219]                   }
[13:20:25.219]                 }
[13:20:25.219]                 else {
[13:20:25.219]                   if (TRUE) {
[13:20:25.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.219]                     {
[13:20:25.219]                       inherits <- base::inherits
[13:20:25.219]                       invokeRestart <- base::invokeRestart
[13:20:25.219]                       is.null <- base::is.null
[13:20:25.219]                       muffled <- FALSE
[13:20:25.219]                       if (inherits(cond, "message")) {
[13:20:25.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.219]                         if (muffled) 
[13:20:25.219]                           invokeRestart("muffleMessage")
[13:20:25.219]                       }
[13:20:25.219]                       else if (inherits(cond, "warning")) {
[13:20:25.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.219]                         if (muffled) 
[13:20:25.219]                           invokeRestart("muffleWarning")
[13:20:25.219]                       }
[13:20:25.219]                       else if (inherits(cond, "condition")) {
[13:20:25.219]                         if (!is.null(pattern)) {
[13:20:25.219]                           computeRestarts <- base::computeRestarts
[13:20:25.219]                           grepl <- base::grepl
[13:20:25.219]                           restarts <- computeRestarts(cond)
[13:20:25.219]                           for (restart in restarts) {
[13:20:25.219]                             name <- restart$name
[13:20:25.219]                             if (is.null(name)) 
[13:20:25.219]                               next
[13:20:25.219]                             if (!grepl(pattern, name)) 
[13:20:25.219]                               next
[13:20:25.219]                             invokeRestart(restart)
[13:20:25.219]                             muffled <- TRUE
[13:20:25.219]                             break
[13:20:25.219]                           }
[13:20:25.219]                         }
[13:20:25.219]                       }
[13:20:25.219]                       invisible(muffled)
[13:20:25.219]                     }
[13:20:25.219]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.219]                   }
[13:20:25.219]                 }
[13:20:25.219]             }
[13:20:25.219]         }))
[13:20:25.219]     }, error = function(ex) {
[13:20:25.219]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.219]                 ...future.rng), started = ...future.startTime, 
[13:20:25.219]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.219]             version = "1.8"), class = "FutureResult")
[13:20:25.219]     }, finally = {
[13:20:25.219]         if (!identical(...future.workdir, getwd())) 
[13:20:25.219]             setwd(...future.workdir)
[13:20:25.219]         {
[13:20:25.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.219]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.219]             }
[13:20:25.219]             base::options(...future.oldOptions)
[13:20:25.219]             if (.Platform$OS.type == "windows") {
[13:20:25.219]                 old_names <- names(...future.oldEnvVars)
[13:20:25.219]                 envs <- base::Sys.getenv()
[13:20:25.219]                 names <- names(envs)
[13:20:25.219]                 common <- intersect(names, old_names)
[13:20:25.219]                 added <- setdiff(names, old_names)
[13:20:25.219]                 removed <- setdiff(old_names, names)
[13:20:25.219]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.219]                   envs[common]]
[13:20:25.219]                 NAMES <- toupper(changed)
[13:20:25.219]                 args <- list()
[13:20:25.219]                 for (kk in seq_along(NAMES)) {
[13:20:25.219]                   name <- changed[[kk]]
[13:20:25.219]                   NAME <- NAMES[[kk]]
[13:20:25.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.219]                     next
[13:20:25.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.219]                 }
[13:20:25.219]                 NAMES <- toupper(added)
[13:20:25.219]                 for (kk in seq_along(NAMES)) {
[13:20:25.219]                   name <- added[[kk]]
[13:20:25.219]                   NAME <- NAMES[[kk]]
[13:20:25.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.219]                     next
[13:20:25.219]                   args[[name]] <- ""
[13:20:25.219]                 }
[13:20:25.219]                 NAMES <- toupper(removed)
[13:20:25.219]                 for (kk in seq_along(NAMES)) {
[13:20:25.219]                   name <- removed[[kk]]
[13:20:25.219]                   NAME <- NAMES[[kk]]
[13:20:25.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.219]                     next
[13:20:25.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.219]                 }
[13:20:25.219]                 if (length(args) > 0) 
[13:20:25.219]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.219]             }
[13:20:25.219]             else {
[13:20:25.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.219]             }
[13:20:25.219]             {
[13:20:25.219]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.219]                   0L) {
[13:20:25.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.219]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.219]                   base::options(opts)
[13:20:25.219]                 }
[13:20:25.219]                 {
[13:20:25.219]                   {
[13:20:25.219]                     NULL
[13:20:25.219]                     RNGkind("Mersenne-Twister")
[13:20:25.219]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.219]                       inherits = FALSE)
[13:20:25.219]                   }
[13:20:25.219]                   options(future.plan = NULL)
[13:20:25.219]                   if (is.na(NA_character_)) 
[13:20:25.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.219]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.219]                   {
[13:20:25.219]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.219]                     if (!future$lazy) 
[13:20:25.219]                       future <- run(future)
[13:20:25.219]                     invisible(future)
[13:20:25.219]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.219]                 }
[13:20:25.219]             }
[13:20:25.219]         }
[13:20:25.219]     })
[13:20:25.219]     if (TRUE) {
[13:20:25.219]         base::sink(type = "output", split = FALSE)
[13:20:25.219]         if (TRUE) {
[13:20:25.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.219]         }
[13:20:25.219]         else {
[13:20:25.219]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.219]         }
[13:20:25.219]         base::close(...future.stdout)
[13:20:25.219]         ...future.stdout <- NULL
[13:20:25.219]     }
[13:20:25.219]     ...future.result$conditions <- ...future.conditions
[13:20:25.219]     ...future.result$finished <- base::Sys.time()
[13:20:25.219]     ...future.result
[13:20:25.219] }
[13:20:25.221] plan(): Setting new future strategy stack:
[13:20:25.221] List of future strategies:
[13:20:25.221] 1. sequential:
[13:20:25.221]    - args: function (..., envir = parent.frame())
[13:20:25.221]    - tweaked: FALSE
[13:20:25.221]    - call: NULL
[13:20:25.222] plan(): nbrOfWorkers() = 1
[13:20:25.222] plan(): Setting new future strategy stack:
[13:20:25.222] List of future strategies:
[13:20:25.222] 1. sequential:
[13:20:25.222]    - args: function (..., envir = parent.frame())
[13:20:25.222]    - tweaked: FALSE
[13:20:25.222]    - call: plan(strategy)
[13:20:25.223] plan(): nbrOfWorkers() = 1
[13:20:25.223] SequentialFuture started (and completed)
[13:20:25.223] - Launch lazy future ... done
[13:20:25.223] run() for ‘SequentialFuture’ ... done
<environment: 0x55659b8d4a58> 
<environment: 0x55659b4ff6a0> 
[13:20:25.224] resolved() for ‘SequentialFuture’ ...
[13:20:25.225] - state: ‘finished’
[13:20:25.225] - run: TRUE
[13:20:25.225] - result: ‘FutureResult’
[13:20:25.225] resolved() for ‘SequentialFuture’ ... done
[13:20:25.225] resolved() for ‘SequentialFuture’ ...
[13:20:25.225] - state: ‘finished’
[13:20:25.225] - run: TRUE
[13:20:25.225] - result: ‘FutureResult’
[13:20:25.225] resolved() for ‘SequentialFuture’ ... done
[13:20:25.225] resolved() for ‘SequentialFuture’ ...
[13:20:25.226] - state: ‘finished’
[13:20:25.226] - run: TRUE
[13:20:25.226] - result: ‘FutureResult’
[13:20:25.226] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:25.227] resolve() on environment ...
[13:20:25.227]  recursive: 0
[13:20:25.228]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:25.228] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.228] - nx: 4
[13:20:25.228] - relay: TRUE
[13:20:25.228] - stdout: TRUE
[13:20:25.228] - signal: TRUE
[13:20:25.228] - resignal: FALSE
[13:20:25.228] - force: TRUE
[13:20:25.228] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.228] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.229]  - until=2
[13:20:25.229]  - relaying element #2
[13:20:25.229] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:25.229] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.229] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.229]  length: 3 (resolved future 1)
[13:20:25.229] resolved() for ‘SequentialFuture’ ...
[13:20:25.229] - state: ‘finished’
[13:20:25.229] - run: TRUE
[13:20:25.229] - result: ‘FutureResult’
[13:20:25.229] resolved() for ‘SequentialFuture’ ... done
[13:20:25.230] Future #2
[13:20:25.230] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.230] - nx: 4
[13:20:25.230] - relay: TRUE
[13:20:25.230] - stdout: TRUE
[13:20:25.230] - signal: TRUE
[13:20:25.230] - resignal: FALSE
[13:20:25.230] - force: TRUE
[13:20:25.230] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:25.230] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.231]  - until=2
[13:20:25.231]  - relaying element #2
[13:20:25.231] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:25.231] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:25.231] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.231]  length: 2 (resolved future 2)
[13:20:25.231] resolved() for ‘SequentialFuture’ ...
[13:20:25.231] - state: ‘finished’
[13:20:25.231] - run: TRUE
[13:20:25.231] - result: ‘FutureResult’
[13:20:25.232] resolved() for ‘SequentialFuture’ ... done
[13:20:25.232] Future #3
[13:20:25.232] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.232] - nx: 4
[13:20:25.232] - relay: TRUE
[13:20:25.232] - stdout: TRUE
[13:20:25.232] - signal: TRUE
[13:20:25.232] - resignal: FALSE
[13:20:25.232] - force: TRUE
[13:20:25.232] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:25.232] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:25.233]  - until=3
[13:20:25.233]  - relaying element #3
[13:20:25.233] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:25.233] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:25.233] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.233]  length: 1 (resolved future 3)
[13:20:25.233] resolved() for ‘SequentialFuture’ ...
[13:20:25.233] - state: ‘finished’
[13:20:25.233] - run: TRUE
[13:20:25.233] - result: ‘FutureResult’
[13:20:25.234] resolved() for ‘SequentialFuture’ ... done
[13:20:25.234] Future #4
[13:20:25.234] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:20:25.234] - nx: 4
[13:20:25.234] - relay: TRUE
[13:20:25.234] - stdout: TRUE
[13:20:25.234] - signal: TRUE
[13:20:25.234] - resignal: FALSE
[13:20:25.234] - force: TRUE
[13:20:25.234] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:25.234] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:25.235]  - until=4
[13:20:25.235]  - relaying element #4
[13:20:25.235] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.235] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:25.235] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:20:25.235]  length: 0 (resolved future 4)
[13:20:25.235] Relaying remaining futures
[13:20:25.235] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.235] - nx: 4
[13:20:25.235] - relay: TRUE
[13:20:25.236] - stdout: TRUE
[13:20:25.236] - signal: TRUE
[13:20:25.236] - resignal: FALSE
[13:20:25.236] - force: TRUE
[13:20:25.236] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.236] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:25.236] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.236] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:25.236] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.236] resolve() on environment ... DONE
<environment: 0x55659b91b260> 
Dimensions: c(2, 3, 1)
[13:20:25.237] getGlobalsAndPackages() ...
[13:20:25.237] Searching for globals...
[13:20:25.237] 
[13:20:25.237] Searching for globals ... DONE
[13:20:25.238] - globals: [0] <none>
[13:20:25.238] getGlobalsAndPackages() ... DONE
[13:20:25.238] run() for ‘Future’ ...
[13:20:25.238] - state: ‘created’
[13:20:25.238] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.240] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.240] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.241]   - Field: ‘label’
[13:20:25.241]   - Field: ‘local’
[13:20:25.241]   - Field: ‘owner’
[13:20:25.241]   - Field: ‘envir’
[13:20:25.241]   - Field: ‘packages’
[13:20:25.241]   - Field: ‘gc’
[13:20:25.241]   - Field: ‘conditions’
[13:20:25.241]   - Field: ‘expr’
[13:20:25.241]   - Field: ‘uuid’
[13:20:25.241]   - Field: ‘seed’
[13:20:25.242]   - Field: ‘version’
[13:20:25.242]   - Field: ‘result’
[13:20:25.242]   - Field: ‘asynchronous’
[13:20:25.242]   - Field: ‘calls’
[13:20:25.242]   - Field: ‘globals’
[13:20:25.242]   - Field: ‘stdout’
[13:20:25.242]   - Field: ‘earlySignal’
[13:20:25.242]   - Field: ‘lazy’
[13:20:25.242]   - Field: ‘state’
[13:20:25.242] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.242] - Launch lazy future ...
[13:20:25.243] Packages needed by the future expression (n = 0): <none>
[13:20:25.243] Packages needed by future strategies (n = 0): <none>
[13:20:25.243] {
[13:20:25.243]     {
[13:20:25.243]         {
[13:20:25.243]             ...future.startTime <- base::Sys.time()
[13:20:25.243]             {
[13:20:25.243]                 {
[13:20:25.243]                   {
[13:20:25.243]                     base::local({
[13:20:25.243]                       has_future <- base::requireNamespace("future", 
[13:20:25.243]                         quietly = TRUE)
[13:20:25.243]                       if (has_future) {
[13:20:25.243]                         ns <- base::getNamespace("future")
[13:20:25.243]                         version <- ns[[".package"]][["version"]]
[13:20:25.243]                         if (is.null(version)) 
[13:20:25.243]                           version <- utils::packageVersion("future")
[13:20:25.243]                       }
[13:20:25.243]                       else {
[13:20:25.243]                         version <- NULL
[13:20:25.243]                       }
[13:20:25.243]                       if (!has_future || version < "1.8.0") {
[13:20:25.243]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.243]                           "", base::R.version$version.string), 
[13:20:25.243]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.243]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.243]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.243]                             "release", "version")], collapse = " "), 
[13:20:25.243]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.243]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.243]                           info)
[13:20:25.243]                         info <- base::paste(info, collapse = "; ")
[13:20:25.243]                         if (!has_future) {
[13:20:25.243]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.243]                             info)
[13:20:25.243]                         }
[13:20:25.243]                         else {
[13:20:25.243]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.243]                             info, version)
[13:20:25.243]                         }
[13:20:25.243]                         base::stop(msg)
[13:20:25.243]                       }
[13:20:25.243]                     })
[13:20:25.243]                   }
[13:20:25.243]                   options(future.plan = NULL)
[13:20:25.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.243]                 }
[13:20:25.243]                 ...future.workdir <- getwd()
[13:20:25.243]             }
[13:20:25.243]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.243]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.243]         }
[13:20:25.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.243]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.243]             base::names(...future.oldOptions))
[13:20:25.243]     }
[13:20:25.243]     if (FALSE) {
[13:20:25.243]     }
[13:20:25.243]     else {
[13:20:25.243]         if (TRUE) {
[13:20:25.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.243]                 open = "w")
[13:20:25.243]         }
[13:20:25.243]         else {
[13:20:25.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.243]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.243]         }
[13:20:25.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.243]             base::sink(type = "output", split = FALSE)
[13:20:25.243]             base::close(...future.stdout)
[13:20:25.243]         }, add = TRUE)
[13:20:25.243]     }
[13:20:25.243]     ...future.frame <- base::sys.nframe()
[13:20:25.243]     ...future.conditions <- base::list()
[13:20:25.243]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.243]     if (FALSE) {
[13:20:25.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.243]     }
[13:20:25.243]     ...future.result <- base::tryCatch({
[13:20:25.243]         base::withCallingHandlers({
[13:20:25.243]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.243]             future::FutureResult(value = ...future.value$value, 
[13:20:25.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.243]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.243]                     ...future.globalenv.names))
[13:20:25.243]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.243]         }, condition = base::local({
[13:20:25.243]             c <- base::c
[13:20:25.243]             inherits <- base::inherits
[13:20:25.243]             invokeRestart <- base::invokeRestart
[13:20:25.243]             length <- base::length
[13:20:25.243]             list <- base::list
[13:20:25.243]             seq.int <- base::seq.int
[13:20:25.243]             signalCondition <- base::signalCondition
[13:20:25.243]             sys.calls <- base::sys.calls
[13:20:25.243]             `[[` <- base::`[[`
[13:20:25.243]             `+` <- base::`+`
[13:20:25.243]             `<<-` <- base::`<<-`
[13:20:25.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.243]                   3L)]
[13:20:25.243]             }
[13:20:25.243]             function(cond) {
[13:20:25.243]                 is_error <- inherits(cond, "error")
[13:20:25.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.243]                   NULL)
[13:20:25.243]                 if (is_error) {
[13:20:25.243]                   sessionInformation <- function() {
[13:20:25.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.243]                       search = base::search(), system = base::Sys.info())
[13:20:25.243]                   }
[13:20:25.243]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.243]                     cond$call), session = sessionInformation(), 
[13:20:25.243]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.243]                   signalCondition(cond)
[13:20:25.243]                 }
[13:20:25.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.243]                 "immediateCondition"))) {
[13:20:25.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.243]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.243]                   if (TRUE && !signal) {
[13:20:25.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.243]                     {
[13:20:25.243]                       inherits <- base::inherits
[13:20:25.243]                       invokeRestart <- base::invokeRestart
[13:20:25.243]                       is.null <- base::is.null
[13:20:25.243]                       muffled <- FALSE
[13:20:25.243]                       if (inherits(cond, "message")) {
[13:20:25.243]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.243]                         if (muffled) 
[13:20:25.243]                           invokeRestart("muffleMessage")
[13:20:25.243]                       }
[13:20:25.243]                       else if (inherits(cond, "warning")) {
[13:20:25.243]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.243]                         if (muffled) 
[13:20:25.243]                           invokeRestart("muffleWarning")
[13:20:25.243]                       }
[13:20:25.243]                       else if (inherits(cond, "condition")) {
[13:20:25.243]                         if (!is.null(pattern)) {
[13:20:25.243]                           computeRestarts <- base::computeRestarts
[13:20:25.243]                           grepl <- base::grepl
[13:20:25.243]                           restarts <- computeRestarts(cond)
[13:20:25.243]                           for (restart in restarts) {
[13:20:25.243]                             name <- restart$name
[13:20:25.243]                             if (is.null(name)) 
[13:20:25.243]                               next
[13:20:25.243]                             if (!grepl(pattern, name)) 
[13:20:25.243]                               next
[13:20:25.243]                             invokeRestart(restart)
[13:20:25.243]                             muffled <- TRUE
[13:20:25.243]                             break
[13:20:25.243]                           }
[13:20:25.243]                         }
[13:20:25.243]                       }
[13:20:25.243]                       invisible(muffled)
[13:20:25.243]                     }
[13:20:25.243]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.243]                   }
[13:20:25.243]                 }
[13:20:25.243]                 else {
[13:20:25.243]                   if (TRUE) {
[13:20:25.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.243]                     {
[13:20:25.243]                       inherits <- base::inherits
[13:20:25.243]                       invokeRestart <- base::invokeRestart
[13:20:25.243]                       is.null <- base::is.null
[13:20:25.243]                       muffled <- FALSE
[13:20:25.243]                       if (inherits(cond, "message")) {
[13:20:25.243]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.243]                         if (muffled) 
[13:20:25.243]                           invokeRestart("muffleMessage")
[13:20:25.243]                       }
[13:20:25.243]                       else if (inherits(cond, "warning")) {
[13:20:25.243]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.243]                         if (muffled) 
[13:20:25.243]                           invokeRestart("muffleWarning")
[13:20:25.243]                       }
[13:20:25.243]                       else if (inherits(cond, "condition")) {
[13:20:25.243]                         if (!is.null(pattern)) {
[13:20:25.243]                           computeRestarts <- base::computeRestarts
[13:20:25.243]                           grepl <- base::grepl
[13:20:25.243]                           restarts <- computeRestarts(cond)
[13:20:25.243]                           for (restart in restarts) {
[13:20:25.243]                             name <- restart$name
[13:20:25.243]                             if (is.null(name)) 
[13:20:25.243]                               next
[13:20:25.243]                             if (!grepl(pattern, name)) 
[13:20:25.243]                               next
[13:20:25.243]                             invokeRestart(restart)
[13:20:25.243]                             muffled <- TRUE
[13:20:25.243]                             break
[13:20:25.243]                           }
[13:20:25.243]                         }
[13:20:25.243]                       }
[13:20:25.243]                       invisible(muffled)
[13:20:25.243]                     }
[13:20:25.243]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.243]                   }
[13:20:25.243]                 }
[13:20:25.243]             }
[13:20:25.243]         }))
[13:20:25.243]     }, error = function(ex) {
[13:20:25.243]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.243]                 ...future.rng), started = ...future.startTime, 
[13:20:25.243]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.243]             version = "1.8"), class = "FutureResult")
[13:20:25.243]     }, finally = {
[13:20:25.243]         if (!identical(...future.workdir, getwd())) 
[13:20:25.243]             setwd(...future.workdir)
[13:20:25.243]         {
[13:20:25.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.243]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.243]             }
[13:20:25.243]             base::options(...future.oldOptions)
[13:20:25.243]             if (.Platform$OS.type == "windows") {
[13:20:25.243]                 old_names <- names(...future.oldEnvVars)
[13:20:25.243]                 envs <- base::Sys.getenv()
[13:20:25.243]                 names <- names(envs)
[13:20:25.243]                 common <- intersect(names, old_names)
[13:20:25.243]                 added <- setdiff(names, old_names)
[13:20:25.243]                 removed <- setdiff(old_names, names)
[13:20:25.243]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.243]                   envs[common]]
[13:20:25.243]                 NAMES <- toupper(changed)
[13:20:25.243]                 args <- list()
[13:20:25.243]                 for (kk in seq_along(NAMES)) {
[13:20:25.243]                   name <- changed[[kk]]
[13:20:25.243]                   NAME <- NAMES[[kk]]
[13:20:25.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.243]                     next
[13:20:25.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.243]                 }
[13:20:25.243]                 NAMES <- toupper(added)
[13:20:25.243]                 for (kk in seq_along(NAMES)) {
[13:20:25.243]                   name <- added[[kk]]
[13:20:25.243]                   NAME <- NAMES[[kk]]
[13:20:25.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.243]                     next
[13:20:25.243]                   args[[name]] <- ""
[13:20:25.243]                 }
[13:20:25.243]                 NAMES <- toupper(removed)
[13:20:25.243]                 for (kk in seq_along(NAMES)) {
[13:20:25.243]                   name <- removed[[kk]]
[13:20:25.243]                   NAME <- NAMES[[kk]]
[13:20:25.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.243]                     next
[13:20:25.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.243]                 }
[13:20:25.243]                 if (length(args) > 0) 
[13:20:25.243]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.243]             }
[13:20:25.243]             else {
[13:20:25.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.243]             }
[13:20:25.243]             {
[13:20:25.243]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.243]                   0L) {
[13:20:25.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.243]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.243]                   base::options(opts)
[13:20:25.243]                 }
[13:20:25.243]                 {
[13:20:25.243]                   {
[13:20:25.243]                     NULL
[13:20:25.243]                     RNGkind("Mersenne-Twister")
[13:20:25.243]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.243]                       inherits = FALSE)
[13:20:25.243]                   }
[13:20:25.243]                   options(future.plan = NULL)
[13:20:25.243]                   if (is.na(NA_character_)) 
[13:20:25.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.243]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.243]                   {
[13:20:25.243]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.243]                     if (!future$lazy) 
[13:20:25.243]                       future <- run(future)
[13:20:25.243]                     invisible(future)
[13:20:25.243]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.243]                 }
[13:20:25.243]             }
[13:20:25.243]         }
[13:20:25.243]     })
[13:20:25.243]     if (TRUE) {
[13:20:25.243]         base::sink(type = "output", split = FALSE)
[13:20:25.243]         if (TRUE) {
[13:20:25.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.243]         }
[13:20:25.243]         else {
[13:20:25.243]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.243]         }
[13:20:25.243]         base::close(...future.stdout)
[13:20:25.243]         ...future.stdout <- NULL
[13:20:25.243]     }
[13:20:25.243]     ...future.result$conditions <- ...future.conditions
[13:20:25.243]     ...future.result$finished <- base::Sys.time()
[13:20:25.243]     ...future.result
[13:20:25.243] }
[13:20:25.245] plan(): Setting new future strategy stack:
[13:20:25.245] List of future strategies:
[13:20:25.245] 1. sequential:
[13:20:25.245]    - args: function (..., envir = parent.frame())
[13:20:25.245]    - tweaked: FALSE
[13:20:25.245]    - call: NULL
[13:20:25.246] plan(): nbrOfWorkers() = 1
[13:20:25.246] plan(): Setting new future strategy stack:
[13:20:25.247] List of future strategies:
[13:20:25.247] 1. sequential:
[13:20:25.247]    - args: function (..., envir = parent.frame())
[13:20:25.247]    - tweaked: FALSE
[13:20:25.247]    - call: plan(strategy)
[13:20:25.247] plan(): nbrOfWorkers() = 1
[13:20:25.247] SequentialFuture started (and completed)
[13:20:25.247] - Launch lazy future ... done
[13:20:25.247] run() for ‘SequentialFuture’ ... done
[13:20:25.248] getGlobalsAndPackages() ...
[13:20:25.248] Searching for globals...
[13:20:25.248] 
[13:20:25.248] Searching for globals ... DONE
[13:20:25.248] - globals: [0] <none>
[13:20:25.248] getGlobalsAndPackages() ... DONE
[13:20:25.249] run() for ‘Future’ ...
[13:20:25.249] - state: ‘created’
[13:20:25.249] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.249] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.249] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.249]   - Field: ‘label’
[13:20:25.250]   - Field: ‘local’
[13:20:25.250]   - Field: ‘owner’
[13:20:25.250]   - Field: ‘envir’
[13:20:25.250]   - Field: ‘packages’
[13:20:25.250]   - Field: ‘gc’
[13:20:25.250]   - Field: ‘conditions’
[13:20:25.250]   - Field: ‘expr’
[13:20:25.250]   - Field: ‘uuid’
[13:20:25.250]   - Field: ‘seed’
[13:20:25.250]   - Field: ‘version’
[13:20:25.250]   - Field: ‘result’
[13:20:25.251]   - Field: ‘asynchronous’
[13:20:25.251]   - Field: ‘calls’
[13:20:25.251]   - Field: ‘globals’
[13:20:25.251]   - Field: ‘stdout’
[13:20:25.251]   - Field: ‘earlySignal’
[13:20:25.251]   - Field: ‘lazy’
[13:20:25.251]   - Field: ‘state’
[13:20:25.251] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.251] - Launch lazy future ...
[13:20:25.252] Packages needed by the future expression (n = 0): <none>
[13:20:25.252] Packages needed by future strategies (n = 0): <none>
[13:20:25.252] {
[13:20:25.252]     {
[13:20:25.252]         {
[13:20:25.252]             ...future.startTime <- base::Sys.time()
[13:20:25.252]             {
[13:20:25.252]                 {
[13:20:25.252]                   {
[13:20:25.252]                     base::local({
[13:20:25.252]                       has_future <- base::requireNamespace("future", 
[13:20:25.252]                         quietly = TRUE)
[13:20:25.252]                       if (has_future) {
[13:20:25.252]                         ns <- base::getNamespace("future")
[13:20:25.252]                         version <- ns[[".package"]][["version"]]
[13:20:25.252]                         if (is.null(version)) 
[13:20:25.252]                           version <- utils::packageVersion("future")
[13:20:25.252]                       }
[13:20:25.252]                       else {
[13:20:25.252]                         version <- NULL
[13:20:25.252]                       }
[13:20:25.252]                       if (!has_future || version < "1.8.0") {
[13:20:25.252]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.252]                           "", base::R.version$version.string), 
[13:20:25.252]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.252]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.252]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.252]                             "release", "version")], collapse = " "), 
[13:20:25.252]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.252]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.252]                           info)
[13:20:25.252]                         info <- base::paste(info, collapse = "; ")
[13:20:25.252]                         if (!has_future) {
[13:20:25.252]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.252]                             info)
[13:20:25.252]                         }
[13:20:25.252]                         else {
[13:20:25.252]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.252]                             info, version)
[13:20:25.252]                         }
[13:20:25.252]                         base::stop(msg)
[13:20:25.252]                       }
[13:20:25.252]                     })
[13:20:25.252]                   }
[13:20:25.252]                   options(future.plan = NULL)
[13:20:25.252]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.252]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.252]                 }
[13:20:25.252]                 ...future.workdir <- getwd()
[13:20:25.252]             }
[13:20:25.252]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.252]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.252]         }
[13:20:25.252]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.252]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.252]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.252]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.252]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.252]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.252]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.252]             base::names(...future.oldOptions))
[13:20:25.252]     }
[13:20:25.252]     if (FALSE) {
[13:20:25.252]     }
[13:20:25.252]     else {
[13:20:25.252]         if (TRUE) {
[13:20:25.252]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.252]                 open = "w")
[13:20:25.252]         }
[13:20:25.252]         else {
[13:20:25.252]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.252]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.252]         }
[13:20:25.252]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.252]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.252]             base::sink(type = "output", split = FALSE)
[13:20:25.252]             base::close(...future.stdout)
[13:20:25.252]         }, add = TRUE)
[13:20:25.252]     }
[13:20:25.252]     ...future.frame <- base::sys.nframe()
[13:20:25.252]     ...future.conditions <- base::list()
[13:20:25.252]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.252]     if (FALSE) {
[13:20:25.252]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.252]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.252]     }
[13:20:25.252]     ...future.result <- base::tryCatch({
[13:20:25.252]         base::withCallingHandlers({
[13:20:25.252]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.252]             future::FutureResult(value = ...future.value$value, 
[13:20:25.252]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.252]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.252]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.252]                     ...future.globalenv.names))
[13:20:25.252]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.252]         }, condition = base::local({
[13:20:25.252]             c <- base::c
[13:20:25.252]             inherits <- base::inherits
[13:20:25.252]             invokeRestart <- base::invokeRestart
[13:20:25.252]             length <- base::length
[13:20:25.252]             list <- base::list
[13:20:25.252]             seq.int <- base::seq.int
[13:20:25.252]             signalCondition <- base::signalCondition
[13:20:25.252]             sys.calls <- base::sys.calls
[13:20:25.252]             `[[` <- base::`[[`
[13:20:25.252]             `+` <- base::`+`
[13:20:25.252]             `<<-` <- base::`<<-`
[13:20:25.252]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.252]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.252]                   3L)]
[13:20:25.252]             }
[13:20:25.252]             function(cond) {
[13:20:25.252]                 is_error <- inherits(cond, "error")
[13:20:25.252]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.252]                   NULL)
[13:20:25.252]                 if (is_error) {
[13:20:25.252]                   sessionInformation <- function() {
[13:20:25.252]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.252]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.252]                       search = base::search(), system = base::Sys.info())
[13:20:25.252]                   }
[13:20:25.252]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.252]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.252]                     cond$call), session = sessionInformation(), 
[13:20:25.252]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.252]                   signalCondition(cond)
[13:20:25.252]                 }
[13:20:25.252]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.252]                 "immediateCondition"))) {
[13:20:25.252]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.252]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.252]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.252]                   if (TRUE && !signal) {
[13:20:25.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.252]                     {
[13:20:25.252]                       inherits <- base::inherits
[13:20:25.252]                       invokeRestart <- base::invokeRestart
[13:20:25.252]                       is.null <- base::is.null
[13:20:25.252]                       muffled <- FALSE
[13:20:25.252]                       if (inherits(cond, "message")) {
[13:20:25.252]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.252]                         if (muffled) 
[13:20:25.252]                           invokeRestart("muffleMessage")
[13:20:25.252]                       }
[13:20:25.252]                       else if (inherits(cond, "warning")) {
[13:20:25.252]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.252]                         if (muffled) 
[13:20:25.252]                           invokeRestart("muffleWarning")
[13:20:25.252]                       }
[13:20:25.252]                       else if (inherits(cond, "condition")) {
[13:20:25.252]                         if (!is.null(pattern)) {
[13:20:25.252]                           computeRestarts <- base::computeRestarts
[13:20:25.252]                           grepl <- base::grepl
[13:20:25.252]                           restarts <- computeRestarts(cond)
[13:20:25.252]                           for (restart in restarts) {
[13:20:25.252]                             name <- restart$name
[13:20:25.252]                             if (is.null(name)) 
[13:20:25.252]                               next
[13:20:25.252]                             if (!grepl(pattern, name)) 
[13:20:25.252]                               next
[13:20:25.252]                             invokeRestart(restart)
[13:20:25.252]                             muffled <- TRUE
[13:20:25.252]                             break
[13:20:25.252]                           }
[13:20:25.252]                         }
[13:20:25.252]                       }
[13:20:25.252]                       invisible(muffled)
[13:20:25.252]                     }
[13:20:25.252]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.252]                   }
[13:20:25.252]                 }
[13:20:25.252]                 else {
[13:20:25.252]                   if (TRUE) {
[13:20:25.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.252]                     {
[13:20:25.252]                       inherits <- base::inherits
[13:20:25.252]                       invokeRestart <- base::invokeRestart
[13:20:25.252]                       is.null <- base::is.null
[13:20:25.252]                       muffled <- FALSE
[13:20:25.252]                       if (inherits(cond, "message")) {
[13:20:25.252]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.252]                         if (muffled) 
[13:20:25.252]                           invokeRestart("muffleMessage")
[13:20:25.252]                       }
[13:20:25.252]                       else if (inherits(cond, "warning")) {
[13:20:25.252]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.252]                         if (muffled) 
[13:20:25.252]                           invokeRestart("muffleWarning")
[13:20:25.252]                       }
[13:20:25.252]                       else if (inherits(cond, "condition")) {
[13:20:25.252]                         if (!is.null(pattern)) {
[13:20:25.252]                           computeRestarts <- base::computeRestarts
[13:20:25.252]                           grepl <- base::grepl
[13:20:25.252]                           restarts <- computeRestarts(cond)
[13:20:25.252]                           for (restart in restarts) {
[13:20:25.252]                             name <- restart$name
[13:20:25.252]                             if (is.null(name)) 
[13:20:25.252]                               next
[13:20:25.252]                             if (!grepl(pattern, name)) 
[13:20:25.252]                               next
[13:20:25.252]                             invokeRestart(restart)
[13:20:25.252]                             muffled <- TRUE
[13:20:25.252]                             break
[13:20:25.252]                           }
[13:20:25.252]                         }
[13:20:25.252]                       }
[13:20:25.252]                       invisible(muffled)
[13:20:25.252]                     }
[13:20:25.252]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.252]                   }
[13:20:25.252]                 }
[13:20:25.252]             }
[13:20:25.252]         }))
[13:20:25.252]     }, error = function(ex) {
[13:20:25.252]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.252]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.252]                 ...future.rng), started = ...future.startTime, 
[13:20:25.252]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.252]             version = "1.8"), class = "FutureResult")
[13:20:25.252]     }, finally = {
[13:20:25.252]         if (!identical(...future.workdir, getwd())) 
[13:20:25.252]             setwd(...future.workdir)
[13:20:25.252]         {
[13:20:25.252]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.252]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.252]             }
[13:20:25.252]             base::options(...future.oldOptions)
[13:20:25.252]             if (.Platform$OS.type == "windows") {
[13:20:25.252]                 old_names <- names(...future.oldEnvVars)
[13:20:25.252]                 envs <- base::Sys.getenv()
[13:20:25.252]                 names <- names(envs)
[13:20:25.252]                 common <- intersect(names, old_names)
[13:20:25.252]                 added <- setdiff(names, old_names)
[13:20:25.252]                 removed <- setdiff(old_names, names)
[13:20:25.252]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.252]                   envs[common]]
[13:20:25.252]                 NAMES <- toupper(changed)
[13:20:25.252]                 args <- list()
[13:20:25.252]                 for (kk in seq_along(NAMES)) {
[13:20:25.252]                   name <- changed[[kk]]
[13:20:25.252]                   NAME <- NAMES[[kk]]
[13:20:25.252]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.252]                     next
[13:20:25.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.252]                 }
[13:20:25.252]                 NAMES <- toupper(added)
[13:20:25.252]                 for (kk in seq_along(NAMES)) {
[13:20:25.252]                   name <- added[[kk]]
[13:20:25.252]                   NAME <- NAMES[[kk]]
[13:20:25.252]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.252]                     next
[13:20:25.252]                   args[[name]] <- ""
[13:20:25.252]                 }
[13:20:25.252]                 NAMES <- toupper(removed)
[13:20:25.252]                 for (kk in seq_along(NAMES)) {
[13:20:25.252]                   name <- removed[[kk]]
[13:20:25.252]                   NAME <- NAMES[[kk]]
[13:20:25.252]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.252]                     next
[13:20:25.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.252]                 }
[13:20:25.252]                 if (length(args) > 0) 
[13:20:25.252]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.252]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.252]             }
[13:20:25.252]             else {
[13:20:25.252]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.252]             }
[13:20:25.252]             {
[13:20:25.252]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.252]                   0L) {
[13:20:25.252]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.252]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.252]                   base::options(opts)
[13:20:25.252]                 }
[13:20:25.252]                 {
[13:20:25.252]                   {
[13:20:25.252]                     NULL
[13:20:25.252]                     RNGkind("Mersenne-Twister")
[13:20:25.252]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.252]                       inherits = FALSE)
[13:20:25.252]                   }
[13:20:25.252]                   options(future.plan = NULL)
[13:20:25.252]                   if (is.na(NA_character_)) 
[13:20:25.252]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.252]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.252]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.252]                   {
[13:20:25.252]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.252]                     if (!future$lazy) 
[13:20:25.252]                       future <- run(future)
[13:20:25.252]                     invisible(future)
[13:20:25.252]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.252]                 }
[13:20:25.252]             }
[13:20:25.252]         }
[13:20:25.252]     })
[13:20:25.252]     if (TRUE) {
[13:20:25.252]         base::sink(type = "output", split = FALSE)
[13:20:25.252]         if (TRUE) {
[13:20:25.252]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.252]         }
[13:20:25.252]         else {
[13:20:25.252]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.252]         }
[13:20:25.252]         base::close(...future.stdout)
[13:20:25.252]         ...future.stdout <- NULL
[13:20:25.252]     }
[13:20:25.252]     ...future.result$conditions <- ...future.conditions
[13:20:25.252]     ...future.result$finished <- base::Sys.time()
[13:20:25.252]     ...future.result
[13:20:25.252] }
[13:20:25.254] plan(): Setting new future strategy stack:
[13:20:25.254] List of future strategies:
[13:20:25.254] 1. sequential:
[13:20:25.254]    - args: function (..., envir = parent.frame())
[13:20:25.254]    - tweaked: FALSE
[13:20:25.254]    - call: NULL
[13:20:25.254] plan(): nbrOfWorkers() = 1
[13:20:25.255] plan(): Setting new future strategy stack:
[13:20:25.255] List of future strategies:
[13:20:25.255] 1. sequential:
[13:20:25.255]    - args: function (..., envir = parent.frame())
[13:20:25.255]    - tweaked: FALSE
[13:20:25.255]    - call: plan(strategy)
[13:20:25.255] plan(): nbrOfWorkers() = 1
[13:20:25.256] SequentialFuture started (and completed)
[13:20:25.256] - Launch lazy future ... done
[13:20:25.256] run() for ‘SequentialFuture’ ... done
[13:20:25.256] getGlobalsAndPackages() ...
[13:20:25.256] Searching for globals...
[13:20:25.257] - globals found: [1] ‘{’
[13:20:25.257] Searching for globals ... DONE
[13:20:25.257] Resolving globals: FALSE
[13:20:25.257] 
[13:20:25.257] 
[13:20:25.258] getGlobalsAndPackages() ... DONE
[13:20:25.258] run() for ‘Future’ ...
[13:20:25.258] - state: ‘created’
[13:20:25.258] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.258] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.258]   - Field: ‘label’
[13:20:25.259]   - Field: ‘local’
[13:20:25.259]   - Field: ‘owner’
[13:20:25.259]   - Field: ‘envir’
[13:20:25.259]   - Field: ‘packages’
[13:20:25.259]   - Field: ‘gc’
[13:20:25.259]   - Field: ‘conditions’
[13:20:25.259]   - Field: ‘expr’
[13:20:25.259]   - Field: ‘uuid’
[13:20:25.259]   - Field: ‘seed’
[13:20:25.259]   - Field: ‘version’
[13:20:25.259]   - Field: ‘result’
[13:20:25.260]   - Field: ‘asynchronous’
[13:20:25.260]   - Field: ‘calls’
[13:20:25.260]   - Field: ‘globals’
[13:20:25.260]   - Field: ‘stdout’
[13:20:25.260]   - Field: ‘earlySignal’
[13:20:25.260]   - Field: ‘lazy’
[13:20:25.260]   - Field: ‘state’
[13:20:25.260] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.260] - Launch lazy future ...
[13:20:25.260] Packages needed by the future expression (n = 0): <none>
[13:20:25.261] Packages needed by future strategies (n = 0): <none>
[13:20:25.261] {
[13:20:25.261]     {
[13:20:25.261]         {
[13:20:25.261]             ...future.startTime <- base::Sys.time()
[13:20:25.261]             {
[13:20:25.261]                 {
[13:20:25.261]                   {
[13:20:25.261]                     base::local({
[13:20:25.261]                       has_future <- base::requireNamespace("future", 
[13:20:25.261]                         quietly = TRUE)
[13:20:25.261]                       if (has_future) {
[13:20:25.261]                         ns <- base::getNamespace("future")
[13:20:25.261]                         version <- ns[[".package"]][["version"]]
[13:20:25.261]                         if (is.null(version)) 
[13:20:25.261]                           version <- utils::packageVersion("future")
[13:20:25.261]                       }
[13:20:25.261]                       else {
[13:20:25.261]                         version <- NULL
[13:20:25.261]                       }
[13:20:25.261]                       if (!has_future || version < "1.8.0") {
[13:20:25.261]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.261]                           "", base::R.version$version.string), 
[13:20:25.261]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.261]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.261]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.261]                             "release", "version")], collapse = " "), 
[13:20:25.261]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.261]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.261]                           info)
[13:20:25.261]                         info <- base::paste(info, collapse = "; ")
[13:20:25.261]                         if (!has_future) {
[13:20:25.261]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.261]                             info)
[13:20:25.261]                         }
[13:20:25.261]                         else {
[13:20:25.261]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.261]                             info, version)
[13:20:25.261]                         }
[13:20:25.261]                         base::stop(msg)
[13:20:25.261]                       }
[13:20:25.261]                     })
[13:20:25.261]                   }
[13:20:25.261]                   options(future.plan = NULL)
[13:20:25.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.261]                 }
[13:20:25.261]                 ...future.workdir <- getwd()
[13:20:25.261]             }
[13:20:25.261]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.261]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.261]         }
[13:20:25.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.261]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.261]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.261]             base::names(...future.oldOptions))
[13:20:25.261]     }
[13:20:25.261]     if (FALSE) {
[13:20:25.261]     }
[13:20:25.261]     else {
[13:20:25.261]         if (TRUE) {
[13:20:25.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.261]                 open = "w")
[13:20:25.261]         }
[13:20:25.261]         else {
[13:20:25.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.261]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.261]         }
[13:20:25.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.261]             base::sink(type = "output", split = FALSE)
[13:20:25.261]             base::close(...future.stdout)
[13:20:25.261]         }, add = TRUE)
[13:20:25.261]     }
[13:20:25.261]     ...future.frame <- base::sys.nframe()
[13:20:25.261]     ...future.conditions <- base::list()
[13:20:25.261]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.261]     if (FALSE) {
[13:20:25.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.261]     }
[13:20:25.261]     ...future.result <- base::tryCatch({
[13:20:25.261]         base::withCallingHandlers({
[13:20:25.261]             ...future.value <- base::withVisible(base::local({
[13:20:25.261]                 4
[13:20:25.261]             }))
[13:20:25.261]             future::FutureResult(value = ...future.value$value, 
[13:20:25.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.261]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.261]                     ...future.globalenv.names))
[13:20:25.261]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.261]         }, condition = base::local({
[13:20:25.261]             c <- base::c
[13:20:25.261]             inherits <- base::inherits
[13:20:25.261]             invokeRestart <- base::invokeRestart
[13:20:25.261]             length <- base::length
[13:20:25.261]             list <- base::list
[13:20:25.261]             seq.int <- base::seq.int
[13:20:25.261]             signalCondition <- base::signalCondition
[13:20:25.261]             sys.calls <- base::sys.calls
[13:20:25.261]             `[[` <- base::`[[`
[13:20:25.261]             `+` <- base::`+`
[13:20:25.261]             `<<-` <- base::`<<-`
[13:20:25.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.261]                   3L)]
[13:20:25.261]             }
[13:20:25.261]             function(cond) {
[13:20:25.261]                 is_error <- inherits(cond, "error")
[13:20:25.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.261]                   NULL)
[13:20:25.261]                 if (is_error) {
[13:20:25.261]                   sessionInformation <- function() {
[13:20:25.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.261]                       search = base::search(), system = base::Sys.info())
[13:20:25.261]                   }
[13:20:25.261]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.261]                     cond$call), session = sessionInformation(), 
[13:20:25.261]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.261]                   signalCondition(cond)
[13:20:25.261]                 }
[13:20:25.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.261]                 "immediateCondition"))) {
[13:20:25.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.261]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.261]                   if (TRUE && !signal) {
[13:20:25.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.261]                     {
[13:20:25.261]                       inherits <- base::inherits
[13:20:25.261]                       invokeRestart <- base::invokeRestart
[13:20:25.261]                       is.null <- base::is.null
[13:20:25.261]                       muffled <- FALSE
[13:20:25.261]                       if (inherits(cond, "message")) {
[13:20:25.261]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.261]                         if (muffled) 
[13:20:25.261]                           invokeRestart("muffleMessage")
[13:20:25.261]                       }
[13:20:25.261]                       else if (inherits(cond, "warning")) {
[13:20:25.261]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.261]                         if (muffled) 
[13:20:25.261]                           invokeRestart("muffleWarning")
[13:20:25.261]                       }
[13:20:25.261]                       else if (inherits(cond, "condition")) {
[13:20:25.261]                         if (!is.null(pattern)) {
[13:20:25.261]                           computeRestarts <- base::computeRestarts
[13:20:25.261]                           grepl <- base::grepl
[13:20:25.261]                           restarts <- computeRestarts(cond)
[13:20:25.261]                           for (restart in restarts) {
[13:20:25.261]                             name <- restart$name
[13:20:25.261]                             if (is.null(name)) 
[13:20:25.261]                               next
[13:20:25.261]                             if (!grepl(pattern, name)) 
[13:20:25.261]                               next
[13:20:25.261]                             invokeRestart(restart)
[13:20:25.261]                             muffled <- TRUE
[13:20:25.261]                             break
[13:20:25.261]                           }
[13:20:25.261]                         }
[13:20:25.261]                       }
[13:20:25.261]                       invisible(muffled)
[13:20:25.261]                     }
[13:20:25.261]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.261]                   }
[13:20:25.261]                 }
[13:20:25.261]                 else {
[13:20:25.261]                   if (TRUE) {
[13:20:25.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.261]                     {
[13:20:25.261]                       inherits <- base::inherits
[13:20:25.261]                       invokeRestart <- base::invokeRestart
[13:20:25.261]                       is.null <- base::is.null
[13:20:25.261]                       muffled <- FALSE
[13:20:25.261]                       if (inherits(cond, "message")) {
[13:20:25.261]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.261]                         if (muffled) 
[13:20:25.261]                           invokeRestart("muffleMessage")
[13:20:25.261]                       }
[13:20:25.261]                       else if (inherits(cond, "warning")) {
[13:20:25.261]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.261]                         if (muffled) 
[13:20:25.261]                           invokeRestart("muffleWarning")
[13:20:25.261]                       }
[13:20:25.261]                       else if (inherits(cond, "condition")) {
[13:20:25.261]                         if (!is.null(pattern)) {
[13:20:25.261]                           computeRestarts <- base::computeRestarts
[13:20:25.261]                           grepl <- base::grepl
[13:20:25.261]                           restarts <- computeRestarts(cond)
[13:20:25.261]                           for (restart in restarts) {
[13:20:25.261]                             name <- restart$name
[13:20:25.261]                             if (is.null(name)) 
[13:20:25.261]                               next
[13:20:25.261]                             if (!grepl(pattern, name)) 
[13:20:25.261]                               next
[13:20:25.261]                             invokeRestart(restart)
[13:20:25.261]                             muffled <- TRUE
[13:20:25.261]                             break
[13:20:25.261]                           }
[13:20:25.261]                         }
[13:20:25.261]                       }
[13:20:25.261]                       invisible(muffled)
[13:20:25.261]                     }
[13:20:25.261]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.261]                   }
[13:20:25.261]                 }
[13:20:25.261]             }
[13:20:25.261]         }))
[13:20:25.261]     }, error = function(ex) {
[13:20:25.261]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.261]                 ...future.rng), started = ...future.startTime, 
[13:20:25.261]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.261]             version = "1.8"), class = "FutureResult")
[13:20:25.261]     }, finally = {
[13:20:25.261]         if (!identical(...future.workdir, getwd())) 
[13:20:25.261]             setwd(...future.workdir)
[13:20:25.261]         {
[13:20:25.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.261]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.261]             }
[13:20:25.261]             base::options(...future.oldOptions)
[13:20:25.261]             if (.Platform$OS.type == "windows") {
[13:20:25.261]                 old_names <- names(...future.oldEnvVars)
[13:20:25.261]                 envs <- base::Sys.getenv()
[13:20:25.261]                 names <- names(envs)
[13:20:25.261]                 common <- intersect(names, old_names)
[13:20:25.261]                 added <- setdiff(names, old_names)
[13:20:25.261]                 removed <- setdiff(old_names, names)
[13:20:25.261]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.261]                   envs[common]]
[13:20:25.261]                 NAMES <- toupper(changed)
[13:20:25.261]                 args <- list()
[13:20:25.261]                 for (kk in seq_along(NAMES)) {
[13:20:25.261]                   name <- changed[[kk]]
[13:20:25.261]                   NAME <- NAMES[[kk]]
[13:20:25.261]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.261]                     next
[13:20:25.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.261]                 }
[13:20:25.261]                 NAMES <- toupper(added)
[13:20:25.261]                 for (kk in seq_along(NAMES)) {
[13:20:25.261]                   name <- added[[kk]]
[13:20:25.261]                   NAME <- NAMES[[kk]]
[13:20:25.261]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.261]                     next
[13:20:25.261]                   args[[name]] <- ""
[13:20:25.261]                 }
[13:20:25.261]                 NAMES <- toupper(removed)
[13:20:25.261]                 for (kk in seq_along(NAMES)) {
[13:20:25.261]                   name <- removed[[kk]]
[13:20:25.261]                   NAME <- NAMES[[kk]]
[13:20:25.261]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.261]                     next
[13:20:25.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.261]                 }
[13:20:25.261]                 if (length(args) > 0) 
[13:20:25.261]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.261]             }
[13:20:25.261]             else {
[13:20:25.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.261]             }
[13:20:25.261]             {
[13:20:25.261]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.261]                   0L) {
[13:20:25.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.261]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.261]                   base::options(opts)
[13:20:25.261]                 }
[13:20:25.261]                 {
[13:20:25.261]                   {
[13:20:25.261]                     NULL
[13:20:25.261]                     RNGkind("Mersenne-Twister")
[13:20:25.261]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.261]                       inherits = FALSE)
[13:20:25.261]                   }
[13:20:25.261]                   options(future.plan = NULL)
[13:20:25.261]                   if (is.na(NA_character_)) 
[13:20:25.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.261]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.261]                   {
[13:20:25.261]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.261]                     if (!future$lazy) 
[13:20:25.261]                       future <- run(future)
[13:20:25.261]                     invisible(future)
[13:20:25.261]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.261]                 }
[13:20:25.261]             }
[13:20:25.261]         }
[13:20:25.261]     })
[13:20:25.261]     if (TRUE) {
[13:20:25.261]         base::sink(type = "output", split = FALSE)
[13:20:25.261]         if (TRUE) {
[13:20:25.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.261]         }
[13:20:25.261]         else {
[13:20:25.261]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.261]         }
[13:20:25.261]         base::close(...future.stdout)
[13:20:25.261]         ...future.stdout <- NULL
[13:20:25.261]     }
[13:20:25.261]     ...future.result$conditions <- ...future.conditions
[13:20:25.261]     ...future.result$finished <- base::Sys.time()
[13:20:25.261]     ...future.result
[13:20:25.261] }
[13:20:25.263] plan(): Setting new future strategy stack:
[13:20:25.263] List of future strategies:
[13:20:25.263] 1. sequential:
[13:20:25.263]    - args: function (..., envir = parent.frame())
[13:20:25.263]    - tweaked: FALSE
[13:20:25.263]    - call: NULL
[13:20:25.263] plan(): nbrOfWorkers() = 1
[13:20:25.264] plan(): Setting new future strategy stack:
[13:20:25.264] List of future strategies:
[13:20:25.264] 1. sequential:
[13:20:25.264]    - args: function (..., envir = parent.frame())
[13:20:25.264]    - tweaked: FALSE
[13:20:25.264]    - call: plan(strategy)
[13:20:25.264] plan(): nbrOfWorkers() = 1
[13:20:25.265] SequentialFuture started (and completed)
[13:20:25.265] - Launch lazy future ... done
[13:20:25.265] run() for ‘SequentialFuture’ ... done
<environment: 0x55659bfba500> 
<environment: 0x55659be26c68> 
[13:20:25.266] resolved() for ‘SequentialFuture’ ...
[13:20:25.266] - state: ‘finished’
[13:20:25.266] - run: TRUE
[13:20:25.266] - result: ‘FutureResult’
[13:20:25.266] resolved() for ‘SequentialFuture’ ... done
[13:20:25.267] resolved() for ‘SequentialFuture’ ...
[13:20:25.267] - state: ‘finished’
[13:20:25.267] - run: TRUE
[13:20:25.267] - result: ‘FutureResult’
[13:20:25.267] resolved() for ‘SequentialFuture’ ... done
[13:20:25.267] resolved() for ‘SequentialFuture’ ...
[13:20:25.267] - state: ‘finished’
[13:20:25.267] - run: TRUE
[13:20:25.267] - result: ‘FutureResult’
[13:20:25.267] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:25.268] resolve() on environment ...
[13:20:25.269]  recursive: 0
[13:20:25.271]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:25.271] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.271] - nx: 4
[13:20:25.271] - relay: TRUE
[13:20:25.272] - stdout: TRUE
[13:20:25.272] - signal: TRUE
[13:20:25.272] - resignal: FALSE
[13:20:25.272] - force: TRUE
[13:20:25.272] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.272] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.272]  - until=2
[13:20:25.272]  - relaying element #2
[13:20:25.272] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:25.272] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.272] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.273]  length: 3 (resolved future 1)
[13:20:25.273] resolved() for ‘SequentialFuture’ ...
[13:20:25.273] - state: ‘finished’
[13:20:25.273] - run: TRUE
[13:20:25.273] - result: ‘FutureResult’
[13:20:25.273] resolved() for ‘SequentialFuture’ ... done
[13:20:25.273] Future #2
[13:20:25.273] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.273] - nx: 4
[13:20:25.274] - relay: TRUE
[13:20:25.274] - stdout: TRUE
[13:20:25.274] - signal: TRUE
[13:20:25.274] - resignal: FALSE
[13:20:25.274] - force: TRUE
[13:20:25.274] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:25.274] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.274]  - until=2
[13:20:25.274]  - relaying element #2
[13:20:25.274] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:25.274] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:25.275] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.275]  length: 2 (resolved future 2)
[13:20:25.275] resolved() for ‘SequentialFuture’ ...
[13:20:25.275] - state: ‘finished’
[13:20:25.275] - run: TRUE
[13:20:25.275] - result: ‘FutureResult’
[13:20:25.275] resolved() for ‘SequentialFuture’ ... done
[13:20:25.275] Future #3
[13:20:25.275] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.275] - nx: 4
[13:20:25.276] - relay: TRUE
[13:20:25.276] - stdout: TRUE
[13:20:25.276] - signal: TRUE
[13:20:25.276] - resignal: FALSE
[13:20:25.276] - force: TRUE
[13:20:25.276] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:25.276] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:25.276]  - until=3
[13:20:25.276]  - relaying element #3
[13:20:25.276] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:25.277] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:25.277] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.277]  length: 1 (resolved future 3)
[13:20:25.277] resolved() for ‘SequentialFuture’ ...
[13:20:25.277] - state: ‘finished’
[13:20:25.277] - run: TRUE
[13:20:25.277] - result: ‘FutureResult’
[13:20:25.277] resolved() for ‘SequentialFuture’ ... done
[13:20:25.277] Future #4
[13:20:25.277] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:20:25.278] - nx: 4
[13:20:25.278] - relay: TRUE
[13:20:25.278] - stdout: TRUE
[13:20:25.278] - signal: TRUE
[13:20:25.278] - resignal: FALSE
[13:20:25.278] - force: TRUE
[13:20:25.278] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:25.278] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:25.278]  - until=4
[13:20:25.278]  - relaying element #4
[13:20:25.278] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.279] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:25.279] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:20:25.279]  length: 0 (resolved future 4)
[13:20:25.279] Relaying remaining futures
[13:20:25.279] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.279] - nx: 4
[13:20:25.279] - relay: TRUE
[13:20:25.279] - stdout: TRUE
[13:20:25.279] - signal: TRUE
[13:20:25.279] - resignal: FALSE
[13:20:25.279] - force: TRUE
[13:20:25.280] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.280] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:25.280] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.280] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:25.280] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.280] resolve() on environment ... DONE
<environment: 0x55659bff37c0> 
Dimensions: c(2, 1, 3, 1)
[13:20:25.281] getGlobalsAndPackages() ...
[13:20:25.281] Searching for globals...
[13:20:25.281] 
[13:20:25.281] Searching for globals ... DONE
[13:20:25.281] - globals: [0] <none>
[13:20:25.281] getGlobalsAndPackages() ... DONE
[13:20:25.281] run() for ‘Future’ ...
[13:20:25.282] - state: ‘created’
[13:20:25.282] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.282] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.282] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.282]   - Field: ‘label’
[13:20:25.282]   - Field: ‘local’
[13:20:25.282]   - Field: ‘owner’
[13:20:25.282]   - Field: ‘envir’
[13:20:25.282]   - Field: ‘packages’
[13:20:25.283]   - Field: ‘gc’
[13:20:25.283]   - Field: ‘conditions’
[13:20:25.283]   - Field: ‘expr’
[13:20:25.283]   - Field: ‘uuid’
[13:20:25.283]   - Field: ‘seed’
[13:20:25.283]   - Field: ‘version’
[13:20:25.283]   - Field: ‘result’
[13:20:25.283]   - Field: ‘asynchronous’
[13:20:25.283]   - Field: ‘calls’
[13:20:25.283]   - Field: ‘globals’
[13:20:25.283]   - Field: ‘stdout’
[13:20:25.284]   - Field: ‘earlySignal’
[13:20:25.284]   - Field: ‘lazy’
[13:20:25.284]   - Field: ‘state’
[13:20:25.284] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.284] - Launch lazy future ...
[13:20:25.284] Packages needed by the future expression (n = 0): <none>
[13:20:25.284] Packages needed by future strategies (n = 0): <none>
[13:20:25.285] {
[13:20:25.285]     {
[13:20:25.285]         {
[13:20:25.285]             ...future.startTime <- base::Sys.time()
[13:20:25.285]             {
[13:20:25.285]                 {
[13:20:25.285]                   {
[13:20:25.285]                     base::local({
[13:20:25.285]                       has_future <- base::requireNamespace("future", 
[13:20:25.285]                         quietly = TRUE)
[13:20:25.285]                       if (has_future) {
[13:20:25.285]                         ns <- base::getNamespace("future")
[13:20:25.285]                         version <- ns[[".package"]][["version"]]
[13:20:25.285]                         if (is.null(version)) 
[13:20:25.285]                           version <- utils::packageVersion("future")
[13:20:25.285]                       }
[13:20:25.285]                       else {
[13:20:25.285]                         version <- NULL
[13:20:25.285]                       }
[13:20:25.285]                       if (!has_future || version < "1.8.0") {
[13:20:25.285]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.285]                           "", base::R.version$version.string), 
[13:20:25.285]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.285]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.285]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.285]                             "release", "version")], collapse = " "), 
[13:20:25.285]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.285]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.285]                           info)
[13:20:25.285]                         info <- base::paste(info, collapse = "; ")
[13:20:25.285]                         if (!has_future) {
[13:20:25.285]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.285]                             info)
[13:20:25.285]                         }
[13:20:25.285]                         else {
[13:20:25.285]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.285]                             info, version)
[13:20:25.285]                         }
[13:20:25.285]                         base::stop(msg)
[13:20:25.285]                       }
[13:20:25.285]                     })
[13:20:25.285]                   }
[13:20:25.285]                   options(future.plan = NULL)
[13:20:25.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.285]                 }
[13:20:25.285]                 ...future.workdir <- getwd()
[13:20:25.285]             }
[13:20:25.285]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.285]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.285]         }
[13:20:25.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.285]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.285]             base::names(...future.oldOptions))
[13:20:25.285]     }
[13:20:25.285]     if (FALSE) {
[13:20:25.285]     }
[13:20:25.285]     else {
[13:20:25.285]         if (TRUE) {
[13:20:25.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.285]                 open = "w")
[13:20:25.285]         }
[13:20:25.285]         else {
[13:20:25.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.285]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.285]         }
[13:20:25.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.285]             base::sink(type = "output", split = FALSE)
[13:20:25.285]             base::close(...future.stdout)
[13:20:25.285]         }, add = TRUE)
[13:20:25.285]     }
[13:20:25.285]     ...future.frame <- base::sys.nframe()
[13:20:25.285]     ...future.conditions <- base::list()
[13:20:25.285]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.285]     if (FALSE) {
[13:20:25.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.285]     }
[13:20:25.285]     ...future.result <- base::tryCatch({
[13:20:25.285]         base::withCallingHandlers({
[13:20:25.285]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.285]             future::FutureResult(value = ...future.value$value, 
[13:20:25.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.285]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.285]                     ...future.globalenv.names))
[13:20:25.285]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.285]         }, condition = base::local({
[13:20:25.285]             c <- base::c
[13:20:25.285]             inherits <- base::inherits
[13:20:25.285]             invokeRestart <- base::invokeRestart
[13:20:25.285]             length <- base::length
[13:20:25.285]             list <- base::list
[13:20:25.285]             seq.int <- base::seq.int
[13:20:25.285]             signalCondition <- base::signalCondition
[13:20:25.285]             sys.calls <- base::sys.calls
[13:20:25.285]             `[[` <- base::`[[`
[13:20:25.285]             `+` <- base::`+`
[13:20:25.285]             `<<-` <- base::`<<-`
[13:20:25.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.285]                   3L)]
[13:20:25.285]             }
[13:20:25.285]             function(cond) {
[13:20:25.285]                 is_error <- inherits(cond, "error")
[13:20:25.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.285]                   NULL)
[13:20:25.285]                 if (is_error) {
[13:20:25.285]                   sessionInformation <- function() {
[13:20:25.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.285]                       search = base::search(), system = base::Sys.info())
[13:20:25.285]                   }
[13:20:25.285]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.285]                     cond$call), session = sessionInformation(), 
[13:20:25.285]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.285]                   signalCondition(cond)
[13:20:25.285]                 }
[13:20:25.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.285]                 "immediateCondition"))) {
[13:20:25.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.285]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.285]                   if (TRUE && !signal) {
[13:20:25.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.285]                     {
[13:20:25.285]                       inherits <- base::inherits
[13:20:25.285]                       invokeRestart <- base::invokeRestart
[13:20:25.285]                       is.null <- base::is.null
[13:20:25.285]                       muffled <- FALSE
[13:20:25.285]                       if (inherits(cond, "message")) {
[13:20:25.285]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.285]                         if (muffled) 
[13:20:25.285]                           invokeRestart("muffleMessage")
[13:20:25.285]                       }
[13:20:25.285]                       else if (inherits(cond, "warning")) {
[13:20:25.285]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.285]                         if (muffled) 
[13:20:25.285]                           invokeRestart("muffleWarning")
[13:20:25.285]                       }
[13:20:25.285]                       else if (inherits(cond, "condition")) {
[13:20:25.285]                         if (!is.null(pattern)) {
[13:20:25.285]                           computeRestarts <- base::computeRestarts
[13:20:25.285]                           grepl <- base::grepl
[13:20:25.285]                           restarts <- computeRestarts(cond)
[13:20:25.285]                           for (restart in restarts) {
[13:20:25.285]                             name <- restart$name
[13:20:25.285]                             if (is.null(name)) 
[13:20:25.285]                               next
[13:20:25.285]                             if (!grepl(pattern, name)) 
[13:20:25.285]                               next
[13:20:25.285]                             invokeRestart(restart)
[13:20:25.285]                             muffled <- TRUE
[13:20:25.285]                             break
[13:20:25.285]                           }
[13:20:25.285]                         }
[13:20:25.285]                       }
[13:20:25.285]                       invisible(muffled)
[13:20:25.285]                     }
[13:20:25.285]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.285]                   }
[13:20:25.285]                 }
[13:20:25.285]                 else {
[13:20:25.285]                   if (TRUE) {
[13:20:25.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.285]                     {
[13:20:25.285]                       inherits <- base::inherits
[13:20:25.285]                       invokeRestart <- base::invokeRestart
[13:20:25.285]                       is.null <- base::is.null
[13:20:25.285]                       muffled <- FALSE
[13:20:25.285]                       if (inherits(cond, "message")) {
[13:20:25.285]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.285]                         if (muffled) 
[13:20:25.285]                           invokeRestart("muffleMessage")
[13:20:25.285]                       }
[13:20:25.285]                       else if (inherits(cond, "warning")) {
[13:20:25.285]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.285]                         if (muffled) 
[13:20:25.285]                           invokeRestart("muffleWarning")
[13:20:25.285]                       }
[13:20:25.285]                       else if (inherits(cond, "condition")) {
[13:20:25.285]                         if (!is.null(pattern)) {
[13:20:25.285]                           computeRestarts <- base::computeRestarts
[13:20:25.285]                           grepl <- base::grepl
[13:20:25.285]                           restarts <- computeRestarts(cond)
[13:20:25.285]                           for (restart in restarts) {
[13:20:25.285]                             name <- restart$name
[13:20:25.285]                             if (is.null(name)) 
[13:20:25.285]                               next
[13:20:25.285]                             if (!grepl(pattern, name)) 
[13:20:25.285]                               next
[13:20:25.285]                             invokeRestart(restart)
[13:20:25.285]                             muffled <- TRUE
[13:20:25.285]                             break
[13:20:25.285]                           }
[13:20:25.285]                         }
[13:20:25.285]                       }
[13:20:25.285]                       invisible(muffled)
[13:20:25.285]                     }
[13:20:25.285]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.285]                   }
[13:20:25.285]                 }
[13:20:25.285]             }
[13:20:25.285]         }))
[13:20:25.285]     }, error = function(ex) {
[13:20:25.285]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.285]                 ...future.rng), started = ...future.startTime, 
[13:20:25.285]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.285]             version = "1.8"), class = "FutureResult")
[13:20:25.285]     }, finally = {
[13:20:25.285]         if (!identical(...future.workdir, getwd())) 
[13:20:25.285]             setwd(...future.workdir)
[13:20:25.285]         {
[13:20:25.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.285]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.285]             }
[13:20:25.285]             base::options(...future.oldOptions)
[13:20:25.285]             if (.Platform$OS.type == "windows") {
[13:20:25.285]                 old_names <- names(...future.oldEnvVars)
[13:20:25.285]                 envs <- base::Sys.getenv()
[13:20:25.285]                 names <- names(envs)
[13:20:25.285]                 common <- intersect(names, old_names)
[13:20:25.285]                 added <- setdiff(names, old_names)
[13:20:25.285]                 removed <- setdiff(old_names, names)
[13:20:25.285]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.285]                   envs[common]]
[13:20:25.285]                 NAMES <- toupper(changed)
[13:20:25.285]                 args <- list()
[13:20:25.285]                 for (kk in seq_along(NAMES)) {
[13:20:25.285]                   name <- changed[[kk]]
[13:20:25.285]                   NAME <- NAMES[[kk]]
[13:20:25.285]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.285]                     next
[13:20:25.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.285]                 }
[13:20:25.285]                 NAMES <- toupper(added)
[13:20:25.285]                 for (kk in seq_along(NAMES)) {
[13:20:25.285]                   name <- added[[kk]]
[13:20:25.285]                   NAME <- NAMES[[kk]]
[13:20:25.285]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.285]                     next
[13:20:25.285]                   args[[name]] <- ""
[13:20:25.285]                 }
[13:20:25.285]                 NAMES <- toupper(removed)
[13:20:25.285]                 for (kk in seq_along(NAMES)) {
[13:20:25.285]                   name <- removed[[kk]]
[13:20:25.285]                   NAME <- NAMES[[kk]]
[13:20:25.285]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.285]                     next
[13:20:25.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.285]                 }
[13:20:25.285]                 if (length(args) > 0) 
[13:20:25.285]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.285]             }
[13:20:25.285]             else {
[13:20:25.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.285]             }
[13:20:25.285]             {
[13:20:25.285]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.285]                   0L) {
[13:20:25.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.285]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.285]                   base::options(opts)
[13:20:25.285]                 }
[13:20:25.285]                 {
[13:20:25.285]                   {
[13:20:25.285]                     NULL
[13:20:25.285]                     RNGkind("Mersenne-Twister")
[13:20:25.285]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.285]                       inherits = FALSE)
[13:20:25.285]                   }
[13:20:25.285]                   options(future.plan = NULL)
[13:20:25.285]                   if (is.na(NA_character_)) 
[13:20:25.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.285]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.285]                   {
[13:20:25.285]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.285]                     if (!future$lazy) 
[13:20:25.285]                       future <- run(future)
[13:20:25.285]                     invisible(future)
[13:20:25.285]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.285]                 }
[13:20:25.285]             }
[13:20:25.285]         }
[13:20:25.285]     })
[13:20:25.285]     if (TRUE) {
[13:20:25.285]         base::sink(type = "output", split = FALSE)
[13:20:25.285]         if (TRUE) {
[13:20:25.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.285]         }
[13:20:25.285]         else {
[13:20:25.285]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.285]         }
[13:20:25.285]         base::close(...future.stdout)
[13:20:25.285]         ...future.stdout <- NULL
[13:20:25.285]     }
[13:20:25.285]     ...future.result$conditions <- ...future.conditions
[13:20:25.285]     ...future.result$finished <- base::Sys.time()
[13:20:25.285]     ...future.result
[13:20:25.285] }
[13:20:25.286] plan(): Setting new future strategy stack:
[13:20:25.286] List of future strategies:
[13:20:25.286] 1. sequential:
[13:20:25.286]    - args: function (..., envir = parent.frame())
[13:20:25.286]    - tweaked: FALSE
[13:20:25.286]    - call: NULL
[13:20:25.287] plan(): nbrOfWorkers() = 1
[13:20:25.288] plan(): Setting new future strategy stack:
[13:20:25.288] List of future strategies:
[13:20:25.288] 1. sequential:
[13:20:25.288]    - args: function (..., envir = parent.frame())
[13:20:25.288]    - tweaked: FALSE
[13:20:25.288]    - call: plan(strategy)
[13:20:25.288] plan(): nbrOfWorkers() = 1
[13:20:25.288] SequentialFuture started (and completed)
[13:20:25.288] - Launch lazy future ... done
[13:20:25.288] run() for ‘SequentialFuture’ ... done
[13:20:25.288] getGlobalsAndPackages() ...
[13:20:25.289] Searching for globals...
[13:20:25.289] 
[13:20:25.289] Searching for globals ... DONE
[13:20:25.289] - globals: [0] <none>
[13:20:25.289] getGlobalsAndPackages() ... DONE
[13:20:25.289] run() for ‘Future’ ...
[13:20:25.289] - state: ‘created’
[13:20:25.290] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.290] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.290] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.290]   - Field: ‘label’
[13:20:25.290]   - Field: ‘local’
[13:20:25.290]   - Field: ‘owner’
[13:20:25.290]   - Field: ‘envir’
[13:20:25.290]   - Field: ‘packages’
[13:20:25.290]   - Field: ‘gc’
[13:20:25.291]   - Field: ‘conditions’
[13:20:25.291]   - Field: ‘expr’
[13:20:25.291]   - Field: ‘uuid’
[13:20:25.291]   - Field: ‘seed’
[13:20:25.291]   - Field: ‘version’
[13:20:25.291]   - Field: ‘result’
[13:20:25.291]   - Field: ‘asynchronous’
[13:20:25.291]   - Field: ‘calls’
[13:20:25.291]   - Field: ‘globals’
[13:20:25.291]   - Field: ‘stdout’
[13:20:25.291]   - Field: ‘earlySignal’
[13:20:25.292]   - Field: ‘lazy’
[13:20:25.292]   - Field: ‘state’
[13:20:25.292] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.292] - Launch lazy future ...
[13:20:25.292] Packages needed by the future expression (n = 0): <none>
[13:20:25.292] Packages needed by future strategies (n = 0): <none>
[13:20:25.292] {
[13:20:25.292]     {
[13:20:25.292]         {
[13:20:25.292]             ...future.startTime <- base::Sys.time()
[13:20:25.292]             {
[13:20:25.292]                 {
[13:20:25.292]                   {
[13:20:25.292]                     base::local({
[13:20:25.292]                       has_future <- base::requireNamespace("future", 
[13:20:25.292]                         quietly = TRUE)
[13:20:25.292]                       if (has_future) {
[13:20:25.292]                         ns <- base::getNamespace("future")
[13:20:25.292]                         version <- ns[[".package"]][["version"]]
[13:20:25.292]                         if (is.null(version)) 
[13:20:25.292]                           version <- utils::packageVersion("future")
[13:20:25.292]                       }
[13:20:25.292]                       else {
[13:20:25.292]                         version <- NULL
[13:20:25.292]                       }
[13:20:25.292]                       if (!has_future || version < "1.8.0") {
[13:20:25.292]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.292]                           "", base::R.version$version.string), 
[13:20:25.292]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.292]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.292]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.292]                             "release", "version")], collapse = " "), 
[13:20:25.292]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.292]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.292]                           info)
[13:20:25.292]                         info <- base::paste(info, collapse = "; ")
[13:20:25.292]                         if (!has_future) {
[13:20:25.292]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.292]                             info)
[13:20:25.292]                         }
[13:20:25.292]                         else {
[13:20:25.292]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.292]                             info, version)
[13:20:25.292]                         }
[13:20:25.292]                         base::stop(msg)
[13:20:25.292]                       }
[13:20:25.292]                     })
[13:20:25.292]                   }
[13:20:25.292]                   options(future.plan = NULL)
[13:20:25.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.292]                 }
[13:20:25.292]                 ...future.workdir <- getwd()
[13:20:25.292]             }
[13:20:25.292]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.292]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.292]         }
[13:20:25.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.292]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.292]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.292]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.292]             base::names(...future.oldOptions))
[13:20:25.292]     }
[13:20:25.292]     if (FALSE) {
[13:20:25.292]     }
[13:20:25.292]     else {
[13:20:25.292]         if (TRUE) {
[13:20:25.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.292]                 open = "w")
[13:20:25.292]         }
[13:20:25.292]         else {
[13:20:25.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.292]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.292]         }
[13:20:25.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.292]             base::sink(type = "output", split = FALSE)
[13:20:25.292]             base::close(...future.stdout)
[13:20:25.292]         }, add = TRUE)
[13:20:25.292]     }
[13:20:25.292]     ...future.frame <- base::sys.nframe()
[13:20:25.292]     ...future.conditions <- base::list()
[13:20:25.292]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.292]     if (FALSE) {
[13:20:25.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.292]     }
[13:20:25.292]     ...future.result <- base::tryCatch({
[13:20:25.292]         base::withCallingHandlers({
[13:20:25.292]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.292]             future::FutureResult(value = ...future.value$value, 
[13:20:25.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.292]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.292]                     ...future.globalenv.names))
[13:20:25.292]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.292]         }, condition = base::local({
[13:20:25.292]             c <- base::c
[13:20:25.292]             inherits <- base::inherits
[13:20:25.292]             invokeRestart <- base::invokeRestart
[13:20:25.292]             length <- base::length
[13:20:25.292]             list <- base::list
[13:20:25.292]             seq.int <- base::seq.int
[13:20:25.292]             signalCondition <- base::signalCondition
[13:20:25.292]             sys.calls <- base::sys.calls
[13:20:25.292]             `[[` <- base::`[[`
[13:20:25.292]             `+` <- base::`+`
[13:20:25.292]             `<<-` <- base::`<<-`
[13:20:25.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.292]                   3L)]
[13:20:25.292]             }
[13:20:25.292]             function(cond) {
[13:20:25.292]                 is_error <- inherits(cond, "error")
[13:20:25.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.292]                   NULL)
[13:20:25.292]                 if (is_error) {
[13:20:25.292]                   sessionInformation <- function() {
[13:20:25.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.292]                       search = base::search(), system = base::Sys.info())
[13:20:25.292]                   }
[13:20:25.292]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.292]                     cond$call), session = sessionInformation(), 
[13:20:25.292]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.292]                   signalCondition(cond)
[13:20:25.292]                 }
[13:20:25.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.292]                 "immediateCondition"))) {
[13:20:25.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.292]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.292]                   if (TRUE && !signal) {
[13:20:25.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.292]                     {
[13:20:25.292]                       inherits <- base::inherits
[13:20:25.292]                       invokeRestart <- base::invokeRestart
[13:20:25.292]                       is.null <- base::is.null
[13:20:25.292]                       muffled <- FALSE
[13:20:25.292]                       if (inherits(cond, "message")) {
[13:20:25.292]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.292]                         if (muffled) 
[13:20:25.292]                           invokeRestart("muffleMessage")
[13:20:25.292]                       }
[13:20:25.292]                       else if (inherits(cond, "warning")) {
[13:20:25.292]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.292]                         if (muffled) 
[13:20:25.292]                           invokeRestart("muffleWarning")
[13:20:25.292]                       }
[13:20:25.292]                       else if (inherits(cond, "condition")) {
[13:20:25.292]                         if (!is.null(pattern)) {
[13:20:25.292]                           computeRestarts <- base::computeRestarts
[13:20:25.292]                           grepl <- base::grepl
[13:20:25.292]                           restarts <- computeRestarts(cond)
[13:20:25.292]                           for (restart in restarts) {
[13:20:25.292]                             name <- restart$name
[13:20:25.292]                             if (is.null(name)) 
[13:20:25.292]                               next
[13:20:25.292]                             if (!grepl(pattern, name)) 
[13:20:25.292]                               next
[13:20:25.292]                             invokeRestart(restart)
[13:20:25.292]                             muffled <- TRUE
[13:20:25.292]                             break
[13:20:25.292]                           }
[13:20:25.292]                         }
[13:20:25.292]                       }
[13:20:25.292]                       invisible(muffled)
[13:20:25.292]                     }
[13:20:25.292]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.292]                   }
[13:20:25.292]                 }
[13:20:25.292]                 else {
[13:20:25.292]                   if (TRUE) {
[13:20:25.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.292]                     {
[13:20:25.292]                       inherits <- base::inherits
[13:20:25.292]                       invokeRestart <- base::invokeRestart
[13:20:25.292]                       is.null <- base::is.null
[13:20:25.292]                       muffled <- FALSE
[13:20:25.292]                       if (inherits(cond, "message")) {
[13:20:25.292]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.292]                         if (muffled) 
[13:20:25.292]                           invokeRestart("muffleMessage")
[13:20:25.292]                       }
[13:20:25.292]                       else if (inherits(cond, "warning")) {
[13:20:25.292]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.292]                         if (muffled) 
[13:20:25.292]                           invokeRestart("muffleWarning")
[13:20:25.292]                       }
[13:20:25.292]                       else if (inherits(cond, "condition")) {
[13:20:25.292]                         if (!is.null(pattern)) {
[13:20:25.292]                           computeRestarts <- base::computeRestarts
[13:20:25.292]                           grepl <- base::grepl
[13:20:25.292]                           restarts <- computeRestarts(cond)
[13:20:25.292]                           for (restart in restarts) {
[13:20:25.292]                             name <- restart$name
[13:20:25.292]                             if (is.null(name)) 
[13:20:25.292]                               next
[13:20:25.292]                             if (!grepl(pattern, name)) 
[13:20:25.292]                               next
[13:20:25.292]                             invokeRestart(restart)
[13:20:25.292]                             muffled <- TRUE
[13:20:25.292]                             break
[13:20:25.292]                           }
[13:20:25.292]                         }
[13:20:25.292]                       }
[13:20:25.292]                       invisible(muffled)
[13:20:25.292]                     }
[13:20:25.292]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.292]                   }
[13:20:25.292]                 }
[13:20:25.292]             }
[13:20:25.292]         }))
[13:20:25.292]     }, error = function(ex) {
[13:20:25.292]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.292]                 ...future.rng), started = ...future.startTime, 
[13:20:25.292]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.292]             version = "1.8"), class = "FutureResult")
[13:20:25.292]     }, finally = {
[13:20:25.292]         if (!identical(...future.workdir, getwd())) 
[13:20:25.292]             setwd(...future.workdir)
[13:20:25.292]         {
[13:20:25.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.292]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.292]             }
[13:20:25.292]             base::options(...future.oldOptions)
[13:20:25.292]             if (.Platform$OS.type == "windows") {
[13:20:25.292]                 old_names <- names(...future.oldEnvVars)
[13:20:25.292]                 envs <- base::Sys.getenv()
[13:20:25.292]                 names <- names(envs)
[13:20:25.292]                 common <- intersect(names, old_names)
[13:20:25.292]                 added <- setdiff(names, old_names)
[13:20:25.292]                 removed <- setdiff(old_names, names)
[13:20:25.292]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.292]                   envs[common]]
[13:20:25.292]                 NAMES <- toupper(changed)
[13:20:25.292]                 args <- list()
[13:20:25.292]                 for (kk in seq_along(NAMES)) {
[13:20:25.292]                   name <- changed[[kk]]
[13:20:25.292]                   NAME <- NAMES[[kk]]
[13:20:25.292]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.292]                     next
[13:20:25.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.292]                 }
[13:20:25.292]                 NAMES <- toupper(added)
[13:20:25.292]                 for (kk in seq_along(NAMES)) {
[13:20:25.292]                   name <- added[[kk]]
[13:20:25.292]                   NAME <- NAMES[[kk]]
[13:20:25.292]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.292]                     next
[13:20:25.292]                   args[[name]] <- ""
[13:20:25.292]                 }
[13:20:25.292]                 NAMES <- toupper(removed)
[13:20:25.292]                 for (kk in seq_along(NAMES)) {
[13:20:25.292]                   name <- removed[[kk]]
[13:20:25.292]                   NAME <- NAMES[[kk]]
[13:20:25.292]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.292]                     next
[13:20:25.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.292]                 }
[13:20:25.292]                 if (length(args) > 0) 
[13:20:25.292]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.292]             }
[13:20:25.292]             else {
[13:20:25.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.292]             }
[13:20:25.292]             {
[13:20:25.292]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.292]                   0L) {
[13:20:25.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.292]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.292]                   base::options(opts)
[13:20:25.292]                 }
[13:20:25.292]                 {
[13:20:25.292]                   {
[13:20:25.292]                     NULL
[13:20:25.292]                     RNGkind("Mersenne-Twister")
[13:20:25.292]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.292]                       inherits = FALSE)
[13:20:25.292]                   }
[13:20:25.292]                   options(future.plan = NULL)
[13:20:25.292]                   if (is.na(NA_character_)) 
[13:20:25.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.292]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.292]                   {
[13:20:25.292]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.292]                     if (!future$lazy) 
[13:20:25.292]                       future <- run(future)
[13:20:25.292]                     invisible(future)
[13:20:25.292]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.292]                 }
[13:20:25.292]             }
[13:20:25.292]         }
[13:20:25.292]     })
[13:20:25.292]     if (TRUE) {
[13:20:25.292]         base::sink(type = "output", split = FALSE)
[13:20:25.292]         if (TRUE) {
[13:20:25.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.292]         }
[13:20:25.292]         else {
[13:20:25.292]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.292]         }
[13:20:25.292]         base::close(...future.stdout)
[13:20:25.292]         ...future.stdout <- NULL
[13:20:25.292]     }
[13:20:25.292]     ...future.result$conditions <- ...future.conditions
[13:20:25.292]     ...future.result$finished <- base::Sys.time()
[13:20:25.292]     ...future.result
[13:20:25.292] }
[13:20:25.294] plan(): Setting new future strategy stack:
[13:20:25.294] List of future strategies:
[13:20:25.294] 1. sequential:
[13:20:25.294]    - args: function (..., envir = parent.frame())
[13:20:25.294]    - tweaked: FALSE
[13:20:25.294]    - call: NULL
[13:20:25.295] plan(): nbrOfWorkers() = 1
[13:20:25.295] plan(): Setting new future strategy stack:
[13:20:25.295] List of future strategies:
[13:20:25.295] 1. sequential:
[13:20:25.295]    - args: function (..., envir = parent.frame())
[13:20:25.295]    - tweaked: FALSE
[13:20:25.295]    - call: plan(strategy)
[13:20:25.296] plan(): nbrOfWorkers() = 1
[13:20:25.296] SequentialFuture started (and completed)
[13:20:25.296] - Launch lazy future ... done
[13:20:25.296] run() for ‘SequentialFuture’ ... done
[13:20:25.298] getGlobalsAndPackages() ...
[13:20:25.298] Searching for globals...
[13:20:25.299] - globals found: [1] ‘{’
[13:20:25.299] Searching for globals ... DONE
[13:20:25.299] Resolving globals: FALSE
[13:20:25.299] 
[13:20:25.300] 
[13:20:25.300] getGlobalsAndPackages() ... DONE
[13:20:25.300] run() for ‘Future’ ...
[13:20:25.300] - state: ‘created’
[13:20:25.300] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.300] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.301] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.301]   - Field: ‘label’
[13:20:25.301]   - Field: ‘local’
[13:20:25.301]   - Field: ‘owner’
[13:20:25.301]   - Field: ‘envir’
[13:20:25.301]   - Field: ‘packages’
[13:20:25.301]   - Field: ‘gc’
[13:20:25.301]   - Field: ‘conditions’
[13:20:25.301]   - Field: ‘expr’
[13:20:25.301]   - Field: ‘uuid’
[13:20:25.302]   - Field: ‘seed’
[13:20:25.302]   - Field: ‘version’
[13:20:25.302]   - Field: ‘result’
[13:20:25.302]   - Field: ‘asynchronous’
[13:20:25.302]   - Field: ‘calls’
[13:20:25.302]   - Field: ‘globals’
[13:20:25.302]   - Field: ‘stdout’
[13:20:25.302]   - Field: ‘earlySignal’
[13:20:25.302]   - Field: ‘lazy’
[13:20:25.302]   - Field: ‘state’
[13:20:25.302] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.303] - Launch lazy future ...
[13:20:25.303] Packages needed by the future expression (n = 0): <none>
[13:20:25.303] Packages needed by future strategies (n = 0): <none>
[13:20:25.303] {
[13:20:25.303]     {
[13:20:25.303]         {
[13:20:25.303]             ...future.startTime <- base::Sys.time()
[13:20:25.303]             {
[13:20:25.303]                 {
[13:20:25.303]                   {
[13:20:25.303]                     base::local({
[13:20:25.303]                       has_future <- base::requireNamespace("future", 
[13:20:25.303]                         quietly = TRUE)
[13:20:25.303]                       if (has_future) {
[13:20:25.303]                         ns <- base::getNamespace("future")
[13:20:25.303]                         version <- ns[[".package"]][["version"]]
[13:20:25.303]                         if (is.null(version)) 
[13:20:25.303]                           version <- utils::packageVersion("future")
[13:20:25.303]                       }
[13:20:25.303]                       else {
[13:20:25.303]                         version <- NULL
[13:20:25.303]                       }
[13:20:25.303]                       if (!has_future || version < "1.8.0") {
[13:20:25.303]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.303]                           "", base::R.version$version.string), 
[13:20:25.303]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.303]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.303]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.303]                             "release", "version")], collapse = " "), 
[13:20:25.303]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.303]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.303]                           info)
[13:20:25.303]                         info <- base::paste(info, collapse = "; ")
[13:20:25.303]                         if (!has_future) {
[13:20:25.303]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.303]                             info)
[13:20:25.303]                         }
[13:20:25.303]                         else {
[13:20:25.303]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.303]                             info, version)
[13:20:25.303]                         }
[13:20:25.303]                         base::stop(msg)
[13:20:25.303]                       }
[13:20:25.303]                     })
[13:20:25.303]                   }
[13:20:25.303]                   options(future.plan = NULL)
[13:20:25.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.303]                 }
[13:20:25.303]                 ...future.workdir <- getwd()
[13:20:25.303]             }
[13:20:25.303]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.303]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.303]         }
[13:20:25.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.303]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.303]             base::names(...future.oldOptions))
[13:20:25.303]     }
[13:20:25.303]     if (FALSE) {
[13:20:25.303]     }
[13:20:25.303]     else {
[13:20:25.303]         if (TRUE) {
[13:20:25.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.303]                 open = "w")
[13:20:25.303]         }
[13:20:25.303]         else {
[13:20:25.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.303]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.303]         }
[13:20:25.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.303]             base::sink(type = "output", split = FALSE)
[13:20:25.303]             base::close(...future.stdout)
[13:20:25.303]         }, add = TRUE)
[13:20:25.303]     }
[13:20:25.303]     ...future.frame <- base::sys.nframe()
[13:20:25.303]     ...future.conditions <- base::list()
[13:20:25.303]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.303]     if (FALSE) {
[13:20:25.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.303]     }
[13:20:25.303]     ...future.result <- base::tryCatch({
[13:20:25.303]         base::withCallingHandlers({
[13:20:25.303]             ...future.value <- base::withVisible(base::local({
[13:20:25.303]                 4
[13:20:25.303]             }))
[13:20:25.303]             future::FutureResult(value = ...future.value$value, 
[13:20:25.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.303]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.303]                     ...future.globalenv.names))
[13:20:25.303]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.303]         }, condition = base::local({
[13:20:25.303]             c <- base::c
[13:20:25.303]             inherits <- base::inherits
[13:20:25.303]             invokeRestart <- base::invokeRestart
[13:20:25.303]             length <- base::length
[13:20:25.303]             list <- base::list
[13:20:25.303]             seq.int <- base::seq.int
[13:20:25.303]             signalCondition <- base::signalCondition
[13:20:25.303]             sys.calls <- base::sys.calls
[13:20:25.303]             `[[` <- base::`[[`
[13:20:25.303]             `+` <- base::`+`
[13:20:25.303]             `<<-` <- base::`<<-`
[13:20:25.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.303]                   3L)]
[13:20:25.303]             }
[13:20:25.303]             function(cond) {
[13:20:25.303]                 is_error <- inherits(cond, "error")
[13:20:25.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.303]                   NULL)
[13:20:25.303]                 if (is_error) {
[13:20:25.303]                   sessionInformation <- function() {
[13:20:25.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.303]                       search = base::search(), system = base::Sys.info())
[13:20:25.303]                   }
[13:20:25.303]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.303]                     cond$call), session = sessionInformation(), 
[13:20:25.303]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.303]                   signalCondition(cond)
[13:20:25.303]                 }
[13:20:25.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.303]                 "immediateCondition"))) {
[13:20:25.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.303]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.303]                   if (TRUE && !signal) {
[13:20:25.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.303]                     {
[13:20:25.303]                       inherits <- base::inherits
[13:20:25.303]                       invokeRestart <- base::invokeRestart
[13:20:25.303]                       is.null <- base::is.null
[13:20:25.303]                       muffled <- FALSE
[13:20:25.303]                       if (inherits(cond, "message")) {
[13:20:25.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.303]                         if (muffled) 
[13:20:25.303]                           invokeRestart("muffleMessage")
[13:20:25.303]                       }
[13:20:25.303]                       else if (inherits(cond, "warning")) {
[13:20:25.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.303]                         if (muffled) 
[13:20:25.303]                           invokeRestart("muffleWarning")
[13:20:25.303]                       }
[13:20:25.303]                       else if (inherits(cond, "condition")) {
[13:20:25.303]                         if (!is.null(pattern)) {
[13:20:25.303]                           computeRestarts <- base::computeRestarts
[13:20:25.303]                           grepl <- base::grepl
[13:20:25.303]                           restarts <- computeRestarts(cond)
[13:20:25.303]                           for (restart in restarts) {
[13:20:25.303]                             name <- restart$name
[13:20:25.303]                             if (is.null(name)) 
[13:20:25.303]                               next
[13:20:25.303]                             if (!grepl(pattern, name)) 
[13:20:25.303]                               next
[13:20:25.303]                             invokeRestart(restart)
[13:20:25.303]                             muffled <- TRUE
[13:20:25.303]                             break
[13:20:25.303]                           }
[13:20:25.303]                         }
[13:20:25.303]                       }
[13:20:25.303]                       invisible(muffled)
[13:20:25.303]                     }
[13:20:25.303]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.303]                   }
[13:20:25.303]                 }
[13:20:25.303]                 else {
[13:20:25.303]                   if (TRUE) {
[13:20:25.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.303]                     {
[13:20:25.303]                       inherits <- base::inherits
[13:20:25.303]                       invokeRestart <- base::invokeRestart
[13:20:25.303]                       is.null <- base::is.null
[13:20:25.303]                       muffled <- FALSE
[13:20:25.303]                       if (inherits(cond, "message")) {
[13:20:25.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.303]                         if (muffled) 
[13:20:25.303]                           invokeRestart("muffleMessage")
[13:20:25.303]                       }
[13:20:25.303]                       else if (inherits(cond, "warning")) {
[13:20:25.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.303]                         if (muffled) 
[13:20:25.303]                           invokeRestart("muffleWarning")
[13:20:25.303]                       }
[13:20:25.303]                       else if (inherits(cond, "condition")) {
[13:20:25.303]                         if (!is.null(pattern)) {
[13:20:25.303]                           computeRestarts <- base::computeRestarts
[13:20:25.303]                           grepl <- base::grepl
[13:20:25.303]                           restarts <- computeRestarts(cond)
[13:20:25.303]                           for (restart in restarts) {
[13:20:25.303]                             name <- restart$name
[13:20:25.303]                             if (is.null(name)) 
[13:20:25.303]                               next
[13:20:25.303]                             if (!grepl(pattern, name)) 
[13:20:25.303]                               next
[13:20:25.303]                             invokeRestart(restart)
[13:20:25.303]                             muffled <- TRUE
[13:20:25.303]                             break
[13:20:25.303]                           }
[13:20:25.303]                         }
[13:20:25.303]                       }
[13:20:25.303]                       invisible(muffled)
[13:20:25.303]                     }
[13:20:25.303]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.303]                   }
[13:20:25.303]                 }
[13:20:25.303]             }
[13:20:25.303]         }))
[13:20:25.303]     }, error = function(ex) {
[13:20:25.303]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.303]                 ...future.rng), started = ...future.startTime, 
[13:20:25.303]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.303]             version = "1.8"), class = "FutureResult")
[13:20:25.303]     }, finally = {
[13:20:25.303]         if (!identical(...future.workdir, getwd())) 
[13:20:25.303]             setwd(...future.workdir)
[13:20:25.303]         {
[13:20:25.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.303]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.303]             }
[13:20:25.303]             base::options(...future.oldOptions)
[13:20:25.303]             if (.Platform$OS.type == "windows") {
[13:20:25.303]                 old_names <- names(...future.oldEnvVars)
[13:20:25.303]                 envs <- base::Sys.getenv()
[13:20:25.303]                 names <- names(envs)
[13:20:25.303]                 common <- intersect(names, old_names)
[13:20:25.303]                 added <- setdiff(names, old_names)
[13:20:25.303]                 removed <- setdiff(old_names, names)
[13:20:25.303]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.303]                   envs[common]]
[13:20:25.303]                 NAMES <- toupper(changed)
[13:20:25.303]                 args <- list()
[13:20:25.303]                 for (kk in seq_along(NAMES)) {
[13:20:25.303]                   name <- changed[[kk]]
[13:20:25.303]                   NAME <- NAMES[[kk]]
[13:20:25.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.303]                     next
[13:20:25.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.303]                 }
[13:20:25.303]                 NAMES <- toupper(added)
[13:20:25.303]                 for (kk in seq_along(NAMES)) {
[13:20:25.303]                   name <- added[[kk]]
[13:20:25.303]                   NAME <- NAMES[[kk]]
[13:20:25.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.303]                     next
[13:20:25.303]                   args[[name]] <- ""
[13:20:25.303]                 }
[13:20:25.303]                 NAMES <- toupper(removed)
[13:20:25.303]                 for (kk in seq_along(NAMES)) {
[13:20:25.303]                   name <- removed[[kk]]
[13:20:25.303]                   NAME <- NAMES[[kk]]
[13:20:25.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.303]                     next
[13:20:25.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.303]                 }
[13:20:25.303]                 if (length(args) > 0) 
[13:20:25.303]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.303]             }
[13:20:25.303]             else {
[13:20:25.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.303]             }
[13:20:25.303]             {
[13:20:25.303]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.303]                   0L) {
[13:20:25.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.303]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.303]                   base::options(opts)
[13:20:25.303]                 }
[13:20:25.303]                 {
[13:20:25.303]                   {
[13:20:25.303]                     NULL
[13:20:25.303]                     RNGkind("Mersenne-Twister")
[13:20:25.303]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.303]                       inherits = FALSE)
[13:20:25.303]                   }
[13:20:25.303]                   options(future.plan = NULL)
[13:20:25.303]                   if (is.na(NA_character_)) 
[13:20:25.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.303]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.303]                   {
[13:20:25.303]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.303]                     if (!future$lazy) 
[13:20:25.303]                       future <- run(future)
[13:20:25.303]                     invisible(future)
[13:20:25.303]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.303]                 }
[13:20:25.303]             }
[13:20:25.303]         }
[13:20:25.303]     })
[13:20:25.303]     if (TRUE) {
[13:20:25.303]         base::sink(type = "output", split = FALSE)
[13:20:25.303]         if (TRUE) {
[13:20:25.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.303]         }
[13:20:25.303]         else {
[13:20:25.303]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.303]         }
[13:20:25.303]         base::close(...future.stdout)
[13:20:25.303]         ...future.stdout <- NULL
[13:20:25.303]     }
[13:20:25.303]     ...future.result$conditions <- ...future.conditions
[13:20:25.303]     ...future.result$finished <- base::Sys.time()
[13:20:25.303]     ...future.result
[13:20:25.303] }
[13:20:25.305] plan(): Setting new future strategy stack:
[13:20:25.305] List of future strategies:
[13:20:25.305] 1. sequential:
[13:20:25.305]    - args: function (..., envir = parent.frame())
[13:20:25.305]    - tweaked: FALSE
[13:20:25.305]    - call: NULL
[13:20:25.306] plan(): nbrOfWorkers() = 1
[13:20:25.306] plan(): Setting new future strategy stack:
[13:20:25.306] List of future strategies:
[13:20:25.306] 1. sequential:
[13:20:25.306]    - args: function (..., envir = parent.frame())
[13:20:25.306]    - tweaked: FALSE
[13:20:25.306]    - call: plan(strategy)
[13:20:25.307] plan(): nbrOfWorkers() = 1
[13:20:25.307] SequentialFuture started (and completed)
[13:20:25.307] - Launch lazy future ... done
[13:20:25.307] run() for ‘SequentialFuture’ ... done
<environment: 0x55659b650d20> 
<environment: 0x55659b4782d0> 
[13:20:25.308] resolved() for ‘SequentialFuture’ ...
[13:20:25.308] - state: ‘finished’
[13:20:25.308] - run: TRUE
[13:20:25.309] - result: ‘FutureResult’
[13:20:25.309] resolved() for ‘SequentialFuture’ ... done
[13:20:25.309] resolved() for ‘SequentialFuture’ ...
[13:20:25.309] - state: ‘finished’
[13:20:25.309] - run: TRUE
[13:20:25.309] - result: ‘FutureResult’
[13:20:25.309] resolved() for ‘SequentialFuture’ ... done
[13:20:25.309] resolved() for ‘SequentialFuture’ ...
[13:20:25.309] - state: ‘finished’
[13:20:25.309] - run: TRUE
[13:20:25.310] - result: ‘FutureResult’
[13:20:25.310] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:25.311] resolve() on environment ...
[13:20:25.311]  recursive: 0
[13:20:25.311]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:25.311] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.312] - nx: 4
[13:20:25.312] - relay: TRUE
[13:20:25.312] - stdout: TRUE
[13:20:25.312] - signal: TRUE
[13:20:25.312] - resignal: FALSE
[13:20:25.312] - force: TRUE
[13:20:25.312] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.312] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.312]  - until=2
[13:20:25.312]  - relaying element #2
[13:20:25.312] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:25.312] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.313] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.313]  length: 3 (resolved future 1)
[13:20:25.313] resolved() for ‘SequentialFuture’ ...
[13:20:25.313] - state: ‘finished’
[13:20:25.313] - run: TRUE
[13:20:25.313] - result: ‘FutureResult’
[13:20:25.313] resolved() for ‘SequentialFuture’ ... done
[13:20:25.313] Future #2
[13:20:25.313] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.313] - nx: 4
[13:20:25.314] - relay: TRUE
[13:20:25.314] - stdout: TRUE
[13:20:25.314] - signal: TRUE
[13:20:25.314] - resignal: FALSE
[13:20:25.314] - force: TRUE
[13:20:25.314] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:25.314] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:25.314]  - until=2
[13:20:25.314]  - relaying element #2
[13:20:25.314] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:25.315] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:25.315] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.315]  length: 2 (resolved future 2)
[13:20:25.315] resolved() for ‘SequentialFuture’ ...
[13:20:25.315] - state: ‘finished’
[13:20:25.315] - run: TRUE
[13:20:25.315] - result: ‘FutureResult’
[13:20:25.315] resolved() for ‘SequentialFuture’ ... done
[13:20:25.315] Future #3
[13:20:25.315] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.315] - nx: 4
[13:20:25.316] - relay: TRUE
[13:20:25.316] - stdout: TRUE
[13:20:25.316] - signal: TRUE
[13:20:25.316] - resignal: FALSE
[13:20:25.316] - force: TRUE
[13:20:25.316] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:25.316] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:25.316]  - until=3
[13:20:25.316]  - relaying element #3
[13:20:25.316] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:25.316] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:25.317] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.317]  length: 1 (resolved future 3)
[13:20:25.317] resolved() for ‘SequentialFuture’ ...
[13:20:25.317] - state: ‘finished’
[13:20:25.317] - run: TRUE
[13:20:25.317] - result: ‘FutureResult’
[13:20:25.317] resolved() for ‘SequentialFuture’ ... done
[13:20:25.317] Future #4
[13:20:25.317] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:20:25.317] - nx: 4
[13:20:25.318] - relay: TRUE
[13:20:25.318] - stdout: TRUE
[13:20:25.318] - signal: TRUE
[13:20:25.318] - resignal: FALSE
[13:20:25.318] - force: TRUE
[13:20:25.318] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:25.318] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:25.318]  - until=4
[13:20:25.318]  - relaying element #4
[13:20:25.318] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.319] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:25.319] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:20:25.319]  length: 0 (resolved future 4)
[13:20:25.319] Relaying remaining futures
[13:20:25.319] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.319] - nx: 4
[13:20:25.319] - relay: TRUE
[13:20:25.319] - stdout: TRUE
[13:20:25.319] - signal: TRUE
[13:20:25.319] - resignal: FALSE
[13:20:25.319] - force: TRUE
[13:20:25.319] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.319] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:25.320] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:25.320] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:25.320] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.320] resolve() on environment ... DONE
<environment: 0x55659b6c2f98> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[13:20:25.321] plan(): Setting new future strategy stack:
[13:20:25.321] List of future strategies:
[13:20:25.321] 1. sequential:
[13:20:25.321]    - args: function (..., envir = parent.frame())
[13:20:25.321]    - tweaked: FALSE
[13:20:25.321]    - call: plan(strategy)
[13:20:25.321] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[13:20:25.322] getGlobalsAndPackages() ...
[13:20:25.322] Searching for globals...
[13:20:25.322] 
[13:20:25.324] Searching for globals ... DONE
[13:20:25.324] - globals: [0] <none>
[13:20:25.324] getGlobalsAndPackages() ... DONE
[13:20:25.324] run() for ‘Future’ ...
[13:20:25.324] - state: ‘created’
[13:20:25.324] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.325] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.325] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.325]   - Field: ‘label’
[13:20:25.325]   - Field: ‘local’
[13:20:25.325]   - Field: ‘owner’
[13:20:25.325]   - Field: ‘envir’
[13:20:25.325]   - Field: ‘packages’
[13:20:25.326]   - Field: ‘gc’
[13:20:25.326]   - Field: ‘conditions’
[13:20:25.326]   - Field: ‘expr’
[13:20:25.326]   - Field: ‘uuid’
[13:20:25.326]   - Field: ‘seed’
[13:20:25.326]   - Field: ‘version’
[13:20:25.326]   - Field: ‘result’
[13:20:25.326]   - Field: ‘asynchronous’
[13:20:25.326]   - Field: ‘calls’
[13:20:25.326]   - Field: ‘globals’
[13:20:25.326]   - Field: ‘stdout’
[13:20:25.327]   - Field: ‘earlySignal’
[13:20:25.327]   - Field: ‘lazy’
[13:20:25.327]   - Field: ‘state’
[13:20:25.327] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.327] - Launch lazy future ...
[13:20:25.327] Packages needed by the future expression (n = 0): <none>
[13:20:25.327] Packages needed by future strategies (n = 0): <none>
[13:20:25.328] {
[13:20:25.328]     {
[13:20:25.328]         {
[13:20:25.328]             ...future.startTime <- base::Sys.time()
[13:20:25.328]             {
[13:20:25.328]                 {
[13:20:25.328]                   {
[13:20:25.328]                     base::local({
[13:20:25.328]                       has_future <- base::requireNamespace("future", 
[13:20:25.328]                         quietly = TRUE)
[13:20:25.328]                       if (has_future) {
[13:20:25.328]                         ns <- base::getNamespace("future")
[13:20:25.328]                         version <- ns[[".package"]][["version"]]
[13:20:25.328]                         if (is.null(version)) 
[13:20:25.328]                           version <- utils::packageVersion("future")
[13:20:25.328]                       }
[13:20:25.328]                       else {
[13:20:25.328]                         version <- NULL
[13:20:25.328]                       }
[13:20:25.328]                       if (!has_future || version < "1.8.0") {
[13:20:25.328]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.328]                           "", base::R.version$version.string), 
[13:20:25.328]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.328]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.328]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.328]                             "release", "version")], collapse = " "), 
[13:20:25.328]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.328]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.328]                           info)
[13:20:25.328]                         info <- base::paste(info, collapse = "; ")
[13:20:25.328]                         if (!has_future) {
[13:20:25.328]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.328]                             info)
[13:20:25.328]                         }
[13:20:25.328]                         else {
[13:20:25.328]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.328]                             info, version)
[13:20:25.328]                         }
[13:20:25.328]                         base::stop(msg)
[13:20:25.328]                       }
[13:20:25.328]                     })
[13:20:25.328]                   }
[13:20:25.328]                   options(future.plan = NULL)
[13:20:25.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.328]                 }
[13:20:25.328]                 ...future.workdir <- getwd()
[13:20:25.328]             }
[13:20:25.328]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.328]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.328]         }
[13:20:25.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.328]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.328]             base::names(...future.oldOptions))
[13:20:25.328]     }
[13:20:25.328]     if (FALSE) {
[13:20:25.328]     }
[13:20:25.328]     else {
[13:20:25.328]         if (TRUE) {
[13:20:25.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.328]                 open = "w")
[13:20:25.328]         }
[13:20:25.328]         else {
[13:20:25.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.328]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.328]         }
[13:20:25.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.328]             base::sink(type = "output", split = FALSE)
[13:20:25.328]             base::close(...future.stdout)
[13:20:25.328]         }, add = TRUE)
[13:20:25.328]     }
[13:20:25.328]     ...future.frame <- base::sys.nframe()
[13:20:25.328]     ...future.conditions <- base::list()
[13:20:25.328]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.328]     if (FALSE) {
[13:20:25.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.328]     }
[13:20:25.328]     ...future.result <- base::tryCatch({
[13:20:25.328]         base::withCallingHandlers({
[13:20:25.328]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.328]             future::FutureResult(value = ...future.value$value, 
[13:20:25.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.328]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.328]                     ...future.globalenv.names))
[13:20:25.328]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.328]         }, condition = base::local({
[13:20:25.328]             c <- base::c
[13:20:25.328]             inherits <- base::inherits
[13:20:25.328]             invokeRestart <- base::invokeRestart
[13:20:25.328]             length <- base::length
[13:20:25.328]             list <- base::list
[13:20:25.328]             seq.int <- base::seq.int
[13:20:25.328]             signalCondition <- base::signalCondition
[13:20:25.328]             sys.calls <- base::sys.calls
[13:20:25.328]             `[[` <- base::`[[`
[13:20:25.328]             `+` <- base::`+`
[13:20:25.328]             `<<-` <- base::`<<-`
[13:20:25.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.328]                   3L)]
[13:20:25.328]             }
[13:20:25.328]             function(cond) {
[13:20:25.328]                 is_error <- inherits(cond, "error")
[13:20:25.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.328]                   NULL)
[13:20:25.328]                 if (is_error) {
[13:20:25.328]                   sessionInformation <- function() {
[13:20:25.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.328]                       search = base::search(), system = base::Sys.info())
[13:20:25.328]                   }
[13:20:25.328]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.328]                     cond$call), session = sessionInformation(), 
[13:20:25.328]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.328]                   signalCondition(cond)
[13:20:25.328]                 }
[13:20:25.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.328]                 "immediateCondition"))) {
[13:20:25.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.328]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.328]                   if (TRUE && !signal) {
[13:20:25.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.328]                     {
[13:20:25.328]                       inherits <- base::inherits
[13:20:25.328]                       invokeRestart <- base::invokeRestart
[13:20:25.328]                       is.null <- base::is.null
[13:20:25.328]                       muffled <- FALSE
[13:20:25.328]                       if (inherits(cond, "message")) {
[13:20:25.328]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.328]                         if (muffled) 
[13:20:25.328]                           invokeRestart("muffleMessage")
[13:20:25.328]                       }
[13:20:25.328]                       else if (inherits(cond, "warning")) {
[13:20:25.328]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.328]                         if (muffled) 
[13:20:25.328]                           invokeRestart("muffleWarning")
[13:20:25.328]                       }
[13:20:25.328]                       else if (inherits(cond, "condition")) {
[13:20:25.328]                         if (!is.null(pattern)) {
[13:20:25.328]                           computeRestarts <- base::computeRestarts
[13:20:25.328]                           grepl <- base::grepl
[13:20:25.328]                           restarts <- computeRestarts(cond)
[13:20:25.328]                           for (restart in restarts) {
[13:20:25.328]                             name <- restart$name
[13:20:25.328]                             if (is.null(name)) 
[13:20:25.328]                               next
[13:20:25.328]                             if (!grepl(pattern, name)) 
[13:20:25.328]                               next
[13:20:25.328]                             invokeRestart(restart)
[13:20:25.328]                             muffled <- TRUE
[13:20:25.328]                             break
[13:20:25.328]                           }
[13:20:25.328]                         }
[13:20:25.328]                       }
[13:20:25.328]                       invisible(muffled)
[13:20:25.328]                     }
[13:20:25.328]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.328]                   }
[13:20:25.328]                 }
[13:20:25.328]                 else {
[13:20:25.328]                   if (TRUE) {
[13:20:25.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.328]                     {
[13:20:25.328]                       inherits <- base::inherits
[13:20:25.328]                       invokeRestart <- base::invokeRestart
[13:20:25.328]                       is.null <- base::is.null
[13:20:25.328]                       muffled <- FALSE
[13:20:25.328]                       if (inherits(cond, "message")) {
[13:20:25.328]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.328]                         if (muffled) 
[13:20:25.328]                           invokeRestart("muffleMessage")
[13:20:25.328]                       }
[13:20:25.328]                       else if (inherits(cond, "warning")) {
[13:20:25.328]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.328]                         if (muffled) 
[13:20:25.328]                           invokeRestart("muffleWarning")
[13:20:25.328]                       }
[13:20:25.328]                       else if (inherits(cond, "condition")) {
[13:20:25.328]                         if (!is.null(pattern)) {
[13:20:25.328]                           computeRestarts <- base::computeRestarts
[13:20:25.328]                           grepl <- base::grepl
[13:20:25.328]                           restarts <- computeRestarts(cond)
[13:20:25.328]                           for (restart in restarts) {
[13:20:25.328]                             name <- restart$name
[13:20:25.328]                             if (is.null(name)) 
[13:20:25.328]                               next
[13:20:25.328]                             if (!grepl(pattern, name)) 
[13:20:25.328]                               next
[13:20:25.328]                             invokeRestart(restart)
[13:20:25.328]                             muffled <- TRUE
[13:20:25.328]                             break
[13:20:25.328]                           }
[13:20:25.328]                         }
[13:20:25.328]                       }
[13:20:25.328]                       invisible(muffled)
[13:20:25.328]                     }
[13:20:25.328]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.328]                   }
[13:20:25.328]                 }
[13:20:25.328]             }
[13:20:25.328]         }))
[13:20:25.328]     }, error = function(ex) {
[13:20:25.328]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.328]                 ...future.rng), started = ...future.startTime, 
[13:20:25.328]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.328]             version = "1.8"), class = "FutureResult")
[13:20:25.328]     }, finally = {
[13:20:25.328]         if (!identical(...future.workdir, getwd())) 
[13:20:25.328]             setwd(...future.workdir)
[13:20:25.328]         {
[13:20:25.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.328]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.328]             }
[13:20:25.328]             base::options(...future.oldOptions)
[13:20:25.328]             if (.Platform$OS.type == "windows") {
[13:20:25.328]                 old_names <- names(...future.oldEnvVars)
[13:20:25.328]                 envs <- base::Sys.getenv()
[13:20:25.328]                 names <- names(envs)
[13:20:25.328]                 common <- intersect(names, old_names)
[13:20:25.328]                 added <- setdiff(names, old_names)
[13:20:25.328]                 removed <- setdiff(old_names, names)
[13:20:25.328]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.328]                   envs[common]]
[13:20:25.328]                 NAMES <- toupper(changed)
[13:20:25.328]                 args <- list()
[13:20:25.328]                 for (kk in seq_along(NAMES)) {
[13:20:25.328]                   name <- changed[[kk]]
[13:20:25.328]                   NAME <- NAMES[[kk]]
[13:20:25.328]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.328]                     next
[13:20:25.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.328]                 }
[13:20:25.328]                 NAMES <- toupper(added)
[13:20:25.328]                 for (kk in seq_along(NAMES)) {
[13:20:25.328]                   name <- added[[kk]]
[13:20:25.328]                   NAME <- NAMES[[kk]]
[13:20:25.328]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.328]                     next
[13:20:25.328]                   args[[name]] <- ""
[13:20:25.328]                 }
[13:20:25.328]                 NAMES <- toupper(removed)
[13:20:25.328]                 for (kk in seq_along(NAMES)) {
[13:20:25.328]                   name <- removed[[kk]]
[13:20:25.328]                   NAME <- NAMES[[kk]]
[13:20:25.328]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.328]                     next
[13:20:25.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.328]                 }
[13:20:25.328]                 if (length(args) > 0) 
[13:20:25.328]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.328]             }
[13:20:25.328]             else {
[13:20:25.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.328]             }
[13:20:25.328]             {
[13:20:25.328]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.328]                   0L) {
[13:20:25.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.328]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.328]                   base::options(opts)
[13:20:25.328]                 }
[13:20:25.328]                 {
[13:20:25.328]                   {
[13:20:25.328]                     NULL
[13:20:25.328]                     RNGkind("Mersenne-Twister")
[13:20:25.328]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.328]                       inherits = FALSE)
[13:20:25.328]                   }
[13:20:25.328]                   options(future.plan = NULL)
[13:20:25.328]                   if (is.na(NA_character_)) 
[13:20:25.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.328]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.328]                   {
[13:20:25.328]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.328]                     if (!future$lazy) 
[13:20:25.328]                       future <- run(future)
[13:20:25.328]                     invisible(future)
[13:20:25.328]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.328]                 }
[13:20:25.328]             }
[13:20:25.328]         }
[13:20:25.328]     })
[13:20:25.328]     if (TRUE) {
[13:20:25.328]         base::sink(type = "output", split = FALSE)
[13:20:25.328]         if (TRUE) {
[13:20:25.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.328]         }
[13:20:25.328]         else {
[13:20:25.328]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.328]         }
[13:20:25.328]         base::close(...future.stdout)
[13:20:25.328]         ...future.stdout <- NULL
[13:20:25.328]     }
[13:20:25.328]     ...future.result$conditions <- ...future.conditions
[13:20:25.328]     ...future.result$finished <- base::Sys.time()
[13:20:25.328]     ...future.result
[13:20:25.328] }
[13:20:25.329] plan(): Setting new future strategy stack:
[13:20:25.329] List of future strategies:
[13:20:25.329] 1. sequential:
[13:20:25.329]    - args: function (..., envir = parent.frame())
[13:20:25.329]    - tweaked: FALSE
[13:20:25.329]    - call: NULL
[13:20:25.330] plan(): nbrOfWorkers() = 1
[13:20:25.330] plan(): Setting new future strategy stack:
[13:20:25.331] List of future strategies:
[13:20:25.331] 1. sequential:
[13:20:25.331]    - args: function (..., envir = parent.frame())
[13:20:25.331]    - tweaked: FALSE
[13:20:25.331]    - call: plan(strategy)
[13:20:25.331] plan(): nbrOfWorkers() = 1
[13:20:25.331] SequentialFuture started (and completed)
[13:20:25.331] - Launch lazy future ... done
[13:20:25.331] run() for ‘SequentialFuture’ ... done
[13:20:25.331] getGlobalsAndPackages() ...
[13:20:25.331] Searching for globals...
[13:20:25.332] 
[13:20:25.332] Searching for globals ... DONE
[13:20:25.332] - globals: [0] <none>
[13:20:25.332] getGlobalsAndPackages() ... DONE
[13:20:25.332] run() for ‘Future’ ...
[13:20:25.332] - state: ‘created’
[13:20:25.332] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.333] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.333]   - Field: ‘label’
[13:20:25.333]   - Field: ‘local’
[13:20:25.333]   - Field: ‘owner’
[13:20:25.333]   - Field: ‘envir’
[13:20:25.333]   - Field: ‘packages’
[13:20:25.333]   - Field: ‘gc’
[13:20:25.333]   - Field: ‘conditions’
[13:20:25.334]   - Field: ‘expr’
[13:20:25.334]   - Field: ‘uuid’
[13:20:25.334]   - Field: ‘seed’
[13:20:25.334]   - Field: ‘version’
[13:20:25.334]   - Field: ‘result’
[13:20:25.334]   - Field: ‘asynchronous’
[13:20:25.334]   - Field: ‘calls’
[13:20:25.334]   - Field: ‘globals’
[13:20:25.334]   - Field: ‘stdout’
[13:20:25.334]   - Field: ‘earlySignal’
[13:20:25.334]   - Field: ‘lazy’
[13:20:25.335]   - Field: ‘state’
[13:20:25.335] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.335] - Launch lazy future ...
[13:20:25.335] Packages needed by the future expression (n = 0): <none>
[13:20:25.335] Packages needed by future strategies (n = 0): <none>
[13:20:25.335] {
[13:20:25.335]     {
[13:20:25.335]         {
[13:20:25.335]             ...future.startTime <- base::Sys.time()
[13:20:25.335]             {
[13:20:25.335]                 {
[13:20:25.335]                   {
[13:20:25.335]                     base::local({
[13:20:25.335]                       has_future <- base::requireNamespace("future", 
[13:20:25.335]                         quietly = TRUE)
[13:20:25.335]                       if (has_future) {
[13:20:25.335]                         ns <- base::getNamespace("future")
[13:20:25.335]                         version <- ns[[".package"]][["version"]]
[13:20:25.335]                         if (is.null(version)) 
[13:20:25.335]                           version <- utils::packageVersion("future")
[13:20:25.335]                       }
[13:20:25.335]                       else {
[13:20:25.335]                         version <- NULL
[13:20:25.335]                       }
[13:20:25.335]                       if (!has_future || version < "1.8.0") {
[13:20:25.335]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.335]                           "", base::R.version$version.string), 
[13:20:25.335]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.335]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.335]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.335]                             "release", "version")], collapse = " "), 
[13:20:25.335]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.335]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.335]                           info)
[13:20:25.335]                         info <- base::paste(info, collapse = "; ")
[13:20:25.335]                         if (!has_future) {
[13:20:25.335]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.335]                             info)
[13:20:25.335]                         }
[13:20:25.335]                         else {
[13:20:25.335]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.335]                             info, version)
[13:20:25.335]                         }
[13:20:25.335]                         base::stop(msg)
[13:20:25.335]                       }
[13:20:25.335]                     })
[13:20:25.335]                   }
[13:20:25.335]                   options(future.plan = NULL)
[13:20:25.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.335]                 }
[13:20:25.335]                 ...future.workdir <- getwd()
[13:20:25.335]             }
[13:20:25.335]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.335]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.335]         }
[13:20:25.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.335]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.335]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.335]             base::names(...future.oldOptions))
[13:20:25.335]     }
[13:20:25.335]     if (FALSE) {
[13:20:25.335]     }
[13:20:25.335]     else {
[13:20:25.335]         if (TRUE) {
[13:20:25.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.335]                 open = "w")
[13:20:25.335]         }
[13:20:25.335]         else {
[13:20:25.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.335]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.335]         }
[13:20:25.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.335]             base::sink(type = "output", split = FALSE)
[13:20:25.335]             base::close(...future.stdout)
[13:20:25.335]         }, add = TRUE)
[13:20:25.335]     }
[13:20:25.335]     ...future.frame <- base::sys.nframe()
[13:20:25.335]     ...future.conditions <- base::list()
[13:20:25.335]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.335]     if (FALSE) {
[13:20:25.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.335]     }
[13:20:25.335]     ...future.result <- base::tryCatch({
[13:20:25.335]         base::withCallingHandlers({
[13:20:25.335]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.335]             future::FutureResult(value = ...future.value$value, 
[13:20:25.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.335]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.335]                     ...future.globalenv.names))
[13:20:25.335]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.335]         }, condition = base::local({
[13:20:25.335]             c <- base::c
[13:20:25.335]             inherits <- base::inherits
[13:20:25.335]             invokeRestart <- base::invokeRestart
[13:20:25.335]             length <- base::length
[13:20:25.335]             list <- base::list
[13:20:25.335]             seq.int <- base::seq.int
[13:20:25.335]             signalCondition <- base::signalCondition
[13:20:25.335]             sys.calls <- base::sys.calls
[13:20:25.335]             `[[` <- base::`[[`
[13:20:25.335]             `+` <- base::`+`
[13:20:25.335]             `<<-` <- base::`<<-`
[13:20:25.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.335]                   3L)]
[13:20:25.335]             }
[13:20:25.335]             function(cond) {
[13:20:25.335]                 is_error <- inherits(cond, "error")
[13:20:25.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.335]                   NULL)
[13:20:25.335]                 if (is_error) {
[13:20:25.335]                   sessionInformation <- function() {
[13:20:25.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.335]                       search = base::search(), system = base::Sys.info())
[13:20:25.335]                   }
[13:20:25.335]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.335]                     cond$call), session = sessionInformation(), 
[13:20:25.335]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.335]                   signalCondition(cond)
[13:20:25.335]                 }
[13:20:25.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.335]                 "immediateCondition"))) {
[13:20:25.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.335]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.335]                   if (TRUE && !signal) {
[13:20:25.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.335]                     {
[13:20:25.335]                       inherits <- base::inherits
[13:20:25.335]                       invokeRestart <- base::invokeRestart
[13:20:25.335]                       is.null <- base::is.null
[13:20:25.335]                       muffled <- FALSE
[13:20:25.335]                       if (inherits(cond, "message")) {
[13:20:25.335]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.335]                         if (muffled) 
[13:20:25.335]                           invokeRestart("muffleMessage")
[13:20:25.335]                       }
[13:20:25.335]                       else if (inherits(cond, "warning")) {
[13:20:25.335]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.335]                         if (muffled) 
[13:20:25.335]                           invokeRestart("muffleWarning")
[13:20:25.335]                       }
[13:20:25.335]                       else if (inherits(cond, "condition")) {
[13:20:25.335]                         if (!is.null(pattern)) {
[13:20:25.335]                           computeRestarts <- base::computeRestarts
[13:20:25.335]                           grepl <- base::grepl
[13:20:25.335]                           restarts <- computeRestarts(cond)
[13:20:25.335]                           for (restart in restarts) {
[13:20:25.335]                             name <- restart$name
[13:20:25.335]                             if (is.null(name)) 
[13:20:25.335]                               next
[13:20:25.335]                             if (!grepl(pattern, name)) 
[13:20:25.335]                               next
[13:20:25.335]                             invokeRestart(restart)
[13:20:25.335]                             muffled <- TRUE
[13:20:25.335]                             break
[13:20:25.335]                           }
[13:20:25.335]                         }
[13:20:25.335]                       }
[13:20:25.335]                       invisible(muffled)
[13:20:25.335]                     }
[13:20:25.335]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.335]                   }
[13:20:25.335]                 }
[13:20:25.335]                 else {
[13:20:25.335]                   if (TRUE) {
[13:20:25.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.335]                     {
[13:20:25.335]                       inherits <- base::inherits
[13:20:25.335]                       invokeRestart <- base::invokeRestart
[13:20:25.335]                       is.null <- base::is.null
[13:20:25.335]                       muffled <- FALSE
[13:20:25.335]                       if (inherits(cond, "message")) {
[13:20:25.335]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.335]                         if (muffled) 
[13:20:25.335]                           invokeRestart("muffleMessage")
[13:20:25.335]                       }
[13:20:25.335]                       else if (inherits(cond, "warning")) {
[13:20:25.335]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.335]                         if (muffled) 
[13:20:25.335]                           invokeRestart("muffleWarning")
[13:20:25.335]                       }
[13:20:25.335]                       else if (inherits(cond, "condition")) {
[13:20:25.335]                         if (!is.null(pattern)) {
[13:20:25.335]                           computeRestarts <- base::computeRestarts
[13:20:25.335]                           grepl <- base::grepl
[13:20:25.335]                           restarts <- computeRestarts(cond)
[13:20:25.335]                           for (restart in restarts) {
[13:20:25.335]                             name <- restart$name
[13:20:25.335]                             if (is.null(name)) 
[13:20:25.335]                               next
[13:20:25.335]                             if (!grepl(pattern, name)) 
[13:20:25.335]                               next
[13:20:25.335]                             invokeRestart(restart)
[13:20:25.335]                             muffled <- TRUE
[13:20:25.335]                             break
[13:20:25.335]                           }
[13:20:25.335]                         }
[13:20:25.335]                       }
[13:20:25.335]                       invisible(muffled)
[13:20:25.335]                     }
[13:20:25.335]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.335]                   }
[13:20:25.335]                 }
[13:20:25.335]             }
[13:20:25.335]         }))
[13:20:25.335]     }, error = function(ex) {
[13:20:25.335]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.335]                 ...future.rng), started = ...future.startTime, 
[13:20:25.335]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.335]             version = "1.8"), class = "FutureResult")
[13:20:25.335]     }, finally = {
[13:20:25.335]         if (!identical(...future.workdir, getwd())) 
[13:20:25.335]             setwd(...future.workdir)
[13:20:25.335]         {
[13:20:25.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.335]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.335]             }
[13:20:25.335]             base::options(...future.oldOptions)
[13:20:25.335]             if (.Platform$OS.type == "windows") {
[13:20:25.335]                 old_names <- names(...future.oldEnvVars)
[13:20:25.335]                 envs <- base::Sys.getenv()
[13:20:25.335]                 names <- names(envs)
[13:20:25.335]                 common <- intersect(names, old_names)
[13:20:25.335]                 added <- setdiff(names, old_names)
[13:20:25.335]                 removed <- setdiff(old_names, names)
[13:20:25.335]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.335]                   envs[common]]
[13:20:25.335]                 NAMES <- toupper(changed)
[13:20:25.335]                 args <- list()
[13:20:25.335]                 for (kk in seq_along(NAMES)) {
[13:20:25.335]                   name <- changed[[kk]]
[13:20:25.335]                   NAME <- NAMES[[kk]]
[13:20:25.335]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.335]                     next
[13:20:25.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.335]                 }
[13:20:25.335]                 NAMES <- toupper(added)
[13:20:25.335]                 for (kk in seq_along(NAMES)) {
[13:20:25.335]                   name <- added[[kk]]
[13:20:25.335]                   NAME <- NAMES[[kk]]
[13:20:25.335]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.335]                     next
[13:20:25.335]                   args[[name]] <- ""
[13:20:25.335]                 }
[13:20:25.335]                 NAMES <- toupper(removed)
[13:20:25.335]                 for (kk in seq_along(NAMES)) {
[13:20:25.335]                   name <- removed[[kk]]
[13:20:25.335]                   NAME <- NAMES[[kk]]
[13:20:25.335]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.335]                     next
[13:20:25.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.335]                 }
[13:20:25.335]                 if (length(args) > 0) 
[13:20:25.335]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.335]             }
[13:20:25.335]             else {
[13:20:25.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.335]             }
[13:20:25.335]             {
[13:20:25.335]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.335]                   0L) {
[13:20:25.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.335]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.335]                   base::options(opts)
[13:20:25.335]                 }
[13:20:25.335]                 {
[13:20:25.335]                   {
[13:20:25.335]                     NULL
[13:20:25.335]                     RNGkind("Mersenne-Twister")
[13:20:25.335]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.335]                       inherits = FALSE)
[13:20:25.335]                   }
[13:20:25.335]                   options(future.plan = NULL)
[13:20:25.335]                   if (is.na(NA_character_)) 
[13:20:25.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.335]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.335]                   {
[13:20:25.335]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.335]                     if (!future$lazy) 
[13:20:25.335]                       future <- run(future)
[13:20:25.335]                     invisible(future)
[13:20:25.335]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.335]                 }
[13:20:25.335]             }
[13:20:25.335]         }
[13:20:25.335]     })
[13:20:25.335]     if (TRUE) {
[13:20:25.335]         base::sink(type = "output", split = FALSE)
[13:20:25.335]         if (TRUE) {
[13:20:25.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.335]         }
[13:20:25.335]         else {
[13:20:25.335]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.335]         }
[13:20:25.335]         base::close(...future.stdout)
[13:20:25.335]         ...future.stdout <- NULL
[13:20:25.335]     }
[13:20:25.335]     ...future.result$conditions <- ...future.conditions
[13:20:25.335]     ...future.result$finished <- base::Sys.time()
[13:20:25.335]     ...future.result
[13:20:25.335] }
[13:20:25.337] plan(): Setting new future strategy stack:
[13:20:25.337] List of future strategies:
[13:20:25.337] 1. sequential:
[13:20:25.337]    - args: function (..., envir = parent.frame())
[13:20:25.337]    - tweaked: FALSE
[13:20:25.337]    - call: NULL
[13:20:25.338] plan(): nbrOfWorkers() = 1
[13:20:25.338] plan(): Setting new future strategy stack:
[13:20:25.338] List of future strategies:
[13:20:25.338] 1. sequential:
[13:20:25.338]    - args: function (..., envir = parent.frame())
[13:20:25.338]    - tweaked: FALSE
[13:20:25.338]    - call: plan(strategy)
[13:20:25.339] plan(): nbrOfWorkers() = 1
[13:20:25.339] SequentialFuture started (and completed)
[13:20:25.339] - Launch lazy future ... done
[13:20:25.339] run() for ‘SequentialFuture’ ... done
[13:20:25.340] getGlobalsAndPackages() ...
[13:20:25.340] Searching for globals...
[13:20:25.340] - globals found: [1] ‘{’
[13:20:25.340] Searching for globals ... DONE
[13:20:25.341] Resolving globals: FALSE
[13:20:25.341] 
[13:20:25.341] 
[13:20:25.341] getGlobalsAndPackages() ... DONE
[13:20:25.341] run() for ‘Future’ ...
[13:20:25.341] - state: ‘created’
[13:20:25.341] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.342] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.342] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.342]   - Field: ‘label’
[13:20:25.342]   - Field: ‘local’
[13:20:25.342]   - Field: ‘owner’
[13:20:25.342]   - Field: ‘envir’
[13:20:25.342]   - Field: ‘packages’
[13:20:25.342]   - Field: ‘gc’
[13:20:25.342]   - Field: ‘conditions’
[13:20:25.343]   - Field: ‘expr’
[13:20:25.343]   - Field: ‘uuid’
[13:20:25.343]   - Field: ‘seed’
[13:20:25.343]   - Field: ‘version’
[13:20:25.343]   - Field: ‘result’
[13:20:25.343]   - Field: ‘asynchronous’
[13:20:25.343]   - Field: ‘calls’
[13:20:25.343]   - Field: ‘globals’
[13:20:25.343]   - Field: ‘stdout’
[13:20:25.343]   - Field: ‘earlySignal’
[13:20:25.343]   - Field: ‘lazy’
[13:20:25.344]   - Field: ‘state’
[13:20:25.344] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.344] - Launch lazy future ...
[13:20:25.344] Packages needed by the future expression (n = 0): <none>
[13:20:25.344] Packages needed by future strategies (n = 0): <none>
[13:20:25.344] {
[13:20:25.344]     {
[13:20:25.344]         {
[13:20:25.344]             ...future.startTime <- base::Sys.time()
[13:20:25.344]             {
[13:20:25.344]                 {
[13:20:25.344]                   {
[13:20:25.344]                     base::local({
[13:20:25.344]                       has_future <- base::requireNamespace("future", 
[13:20:25.344]                         quietly = TRUE)
[13:20:25.344]                       if (has_future) {
[13:20:25.344]                         ns <- base::getNamespace("future")
[13:20:25.344]                         version <- ns[[".package"]][["version"]]
[13:20:25.344]                         if (is.null(version)) 
[13:20:25.344]                           version <- utils::packageVersion("future")
[13:20:25.344]                       }
[13:20:25.344]                       else {
[13:20:25.344]                         version <- NULL
[13:20:25.344]                       }
[13:20:25.344]                       if (!has_future || version < "1.8.0") {
[13:20:25.344]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.344]                           "", base::R.version$version.string), 
[13:20:25.344]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.344]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.344]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.344]                             "release", "version")], collapse = " "), 
[13:20:25.344]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.344]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.344]                           info)
[13:20:25.344]                         info <- base::paste(info, collapse = "; ")
[13:20:25.344]                         if (!has_future) {
[13:20:25.344]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.344]                             info)
[13:20:25.344]                         }
[13:20:25.344]                         else {
[13:20:25.344]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.344]                             info, version)
[13:20:25.344]                         }
[13:20:25.344]                         base::stop(msg)
[13:20:25.344]                       }
[13:20:25.344]                     })
[13:20:25.344]                   }
[13:20:25.344]                   options(future.plan = NULL)
[13:20:25.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.344]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.344]                 }
[13:20:25.344]                 ...future.workdir <- getwd()
[13:20:25.344]             }
[13:20:25.344]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.344]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.344]         }
[13:20:25.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.344]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.344]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.344]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.344]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.344]             base::names(...future.oldOptions))
[13:20:25.344]     }
[13:20:25.344]     if (FALSE) {
[13:20:25.344]     }
[13:20:25.344]     else {
[13:20:25.344]         if (TRUE) {
[13:20:25.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.344]                 open = "w")
[13:20:25.344]         }
[13:20:25.344]         else {
[13:20:25.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.344]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.344]         }
[13:20:25.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.344]             base::sink(type = "output", split = FALSE)
[13:20:25.344]             base::close(...future.stdout)
[13:20:25.344]         }, add = TRUE)
[13:20:25.344]     }
[13:20:25.344]     ...future.frame <- base::sys.nframe()
[13:20:25.344]     ...future.conditions <- base::list()
[13:20:25.344]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.344]     if (FALSE) {
[13:20:25.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.344]     }
[13:20:25.344]     ...future.result <- base::tryCatch({
[13:20:25.344]         base::withCallingHandlers({
[13:20:25.344]             ...future.value <- base::withVisible(base::local({
[13:20:25.344]                 4
[13:20:25.344]             }))
[13:20:25.344]             future::FutureResult(value = ...future.value$value, 
[13:20:25.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.344]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.344]                     ...future.globalenv.names))
[13:20:25.344]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.344]         }, condition = base::local({
[13:20:25.344]             c <- base::c
[13:20:25.344]             inherits <- base::inherits
[13:20:25.344]             invokeRestart <- base::invokeRestart
[13:20:25.344]             length <- base::length
[13:20:25.344]             list <- base::list
[13:20:25.344]             seq.int <- base::seq.int
[13:20:25.344]             signalCondition <- base::signalCondition
[13:20:25.344]             sys.calls <- base::sys.calls
[13:20:25.344]             `[[` <- base::`[[`
[13:20:25.344]             `+` <- base::`+`
[13:20:25.344]             `<<-` <- base::`<<-`
[13:20:25.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.344]                   3L)]
[13:20:25.344]             }
[13:20:25.344]             function(cond) {
[13:20:25.344]                 is_error <- inherits(cond, "error")
[13:20:25.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.344]                   NULL)
[13:20:25.344]                 if (is_error) {
[13:20:25.344]                   sessionInformation <- function() {
[13:20:25.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.344]                       search = base::search(), system = base::Sys.info())
[13:20:25.344]                   }
[13:20:25.344]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.344]                     cond$call), session = sessionInformation(), 
[13:20:25.344]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.344]                   signalCondition(cond)
[13:20:25.344]                 }
[13:20:25.344]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.344]                 "immediateCondition"))) {
[13:20:25.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.344]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.344]                   if (TRUE && !signal) {
[13:20:25.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.344]                     {
[13:20:25.344]                       inherits <- base::inherits
[13:20:25.344]                       invokeRestart <- base::invokeRestart
[13:20:25.344]                       is.null <- base::is.null
[13:20:25.344]                       muffled <- FALSE
[13:20:25.344]                       if (inherits(cond, "message")) {
[13:20:25.344]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.344]                         if (muffled) 
[13:20:25.344]                           invokeRestart("muffleMessage")
[13:20:25.344]                       }
[13:20:25.344]                       else if (inherits(cond, "warning")) {
[13:20:25.344]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.344]                         if (muffled) 
[13:20:25.344]                           invokeRestart("muffleWarning")
[13:20:25.344]                       }
[13:20:25.344]                       else if (inherits(cond, "condition")) {
[13:20:25.344]                         if (!is.null(pattern)) {
[13:20:25.344]                           computeRestarts <- base::computeRestarts
[13:20:25.344]                           grepl <- base::grepl
[13:20:25.344]                           restarts <- computeRestarts(cond)
[13:20:25.344]                           for (restart in restarts) {
[13:20:25.344]                             name <- restart$name
[13:20:25.344]                             if (is.null(name)) 
[13:20:25.344]                               next
[13:20:25.344]                             if (!grepl(pattern, name)) 
[13:20:25.344]                               next
[13:20:25.344]                             invokeRestart(restart)
[13:20:25.344]                             muffled <- TRUE
[13:20:25.344]                             break
[13:20:25.344]                           }
[13:20:25.344]                         }
[13:20:25.344]                       }
[13:20:25.344]                       invisible(muffled)
[13:20:25.344]                     }
[13:20:25.344]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.344]                   }
[13:20:25.344]                 }
[13:20:25.344]                 else {
[13:20:25.344]                   if (TRUE) {
[13:20:25.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.344]                     {
[13:20:25.344]                       inherits <- base::inherits
[13:20:25.344]                       invokeRestart <- base::invokeRestart
[13:20:25.344]                       is.null <- base::is.null
[13:20:25.344]                       muffled <- FALSE
[13:20:25.344]                       if (inherits(cond, "message")) {
[13:20:25.344]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.344]                         if (muffled) 
[13:20:25.344]                           invokeRestart("muffleMessage")
[13:20:25.344]                       }
[13:20:25.344]                       else if (inherits(cond, "warning")) {
[13:20:25.344]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.344]                         if (muffled) 
[13:20:25.344]                           invokeRestart("muffleWarning")
[13:20:25.344]                       }
[13:20:25.344]                       else if (inherits(cond, "condition")) {
[13:20:25.344]                         if (!is.null(pattern)) {
[13:20:25.344]                           computeRestarts <- base::computeRestarts
[13:20:25.344]                           grepl <- base::grepl
[13:20:25.344]                           restarts <- computeRestarts(cond)
[13:20:25.344]                           for (restart in restarts) {
[13:20:25.344]                             name <- restart$name
[13:20:25.344]                             if (is.null(name)) 
[13:20:25.344]                               next
[13:20:25.344]                             if (!grepl(pattern, name)) 
[13:20:25.344]                               next
[13:20:25.344]                             invokeRestart(restart)
[13:20:25.344]                             muffled <- TRUE
[13:20:25.344]                             break
[13:20:25.344]                           }
[13:20:25.344]                         }
[13:20:25.344]                       }
[13:20:25.344]                       invisible(muffled)
[13:20:25.344]                     }
[13:20:25.344]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.344]                   }
[13:20:25.344]                 }
[13:20:25.344]             }
[13:20:25.344]         }))
[13:20:25.344]     }, error = function(ex) {
[13:20:25.344]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.344]                 ...future.rng), started = ...future.startTime, 
[13:20:25.344]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.344]             version = "1.8"), class = "FutureResult")
[13:20:25.344]     }, finally = {
[13:20:25.344]         if (!identical(...future.workdir, getwd())) 
[13:20:25.344]             setwd(...future.workdir)
[13:20:25.344]         {
[13:20:25.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.344]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.344]             }
[13:20:25.344]             base::options(...future.oldOptions)
[13:20:25.344]             if (.Platform$OS.type == "windows") {
[13:20:25.344]                 old_names <- names(...future.oldEnvVars)
[13:20:25.344]                 envs <- base::Sys.getenv()
[13:20:25.344]                 names <- names(envs)
[13:20:25.344]                 common <- intersect(names, old_names)
[13:20:25.344]                 added <- setdiff(names, old_names)
[13:20:25.344]                 removed <- setdiff(old_names, names)
[13:20:25.344]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.344]                   envs[common]]
[13:20:25.344]                 NAMES <- toupper(changed)
[13:20:25.344]                 args <- list()
[13:20:25.344]                 for (kk in seq_along(NAMES)) {
[13:20:25.344]                   name <- changed[[kk]]
[13:20:25.344]                   NAME <- NAMES[[kk]]
[13:20:25.344]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.344]                     next
[13:20:25.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.344]                 }
[13:20:25.344]                 NAMES <- toupper(added)
[13:20:25.344]                 for (kk in seq_along(NAMES)) {
[13:20:25.344]                   name <- added[[kk]]
[13:20:25.344]                   NAME <- NAMES[[kk]]
[13:20:25.344]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.344]                     next
[13:20:25.344]                   args[[name]] <- ""
[13:20:25.344]                 }
[13:20:25.344]                 NAMES <- toupper(removed)
[13:20:25.344]                 for (kk in seq_along(NAMES)) {
[13:20:25.344]                   name <- removed[[kk]]
[13:20:25.344]                   NAME <- NAMES[[kk]]
[13:20:25.344]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.344]                     next
[13:20:25.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.344]                 }
[13:20:25.344]                 if (length(args) > 0) 
[13:20:25.344]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.344]             }
[13:20:25.344]             else {
[13:20:25.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.344]             }
[13:20:25.344]             {
[13:20:25.344]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.344]                   0L) {
[13:20:25.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.344]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.344]                   base::options(opts)
[13:20:25.344]                 }
[13:20:25.344]                 {
[13:20:25.344]                   {
[13:20:25.344]                     NULL
[13:20:25.344]                     RNGkind("Mersenne-Twister")
[13:20:25.344]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.344]                       inherits = FALSE)
[13:20:25.344]                   }
[13:20:25.344]                   options(future.plan = NULL)
[13:20:25.344]                   if (is.na(NA_character_)) 
[13:20:25.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.344]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.344]                   {
[13:20:25.344]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.344]                     if (!future$lazy) 
[13:20:25.344]                       future <- run(future)
[13:20:25.344]                     invisible(future)
[13:20:25.344]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.344]                 }
[13:20:25.344]             }
[13:20:25.344]         }
[13:20:25.344]     })
[13:20:25.344]     if (TRUE) {
[13:20:25.344]         base::sink(type = "output", split = FALSE)
[13:20:25.344]         if (TRUE) {
[13:20:25.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.344]         }
[13:20:25.344]         else {
[13:20:25.344]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.344]         }
[13:20:25.344]         base::close(...future.stdout)
[13:20:25.344]         ...future.stdout <- NULL
[13:20:25.344]     }
[13:20:25.344]     ...future.result$conditions <- ...future.conditions
[13:20:25.344]     ...future.result$finished <- base::Sys.time()
[13:20:25.344]     ...future.result
[13:20:25.344] }
[13:20:25.346] plan(): Setting new future strategy stack:
[13:20:25.346] List of future strategies:
[13:20:25.346] 1. sequential:
[13:20:25.346]    - args: function (..., envir = parent.frame())
[13:20:25.346]    - tweaked: FALSE
[13:20:25.346]    - call: NULL
[13:20:25.347] plan(): nbrOfWorkers() = 1
[13:20:25.347] plan(): Setting new future strategy stack:
[13:20:25.347] List of future strategies:
[13:20:25.347] 1. sequential:
[13:20:25.347]    - args: function (..., envir = parent.frame())
[13:20:25.347]    - tweaked: FALSE
[13:20:25.347]    - call: plan(strategy)
[13:20:25.348] plan(): nbrOfWorkers() = 1
[13:20:25.348] SequentialFuture started (and completed)
[13:20:25.348] - Launch lazy future ... done
[13:20:25.348] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55659bfe1be0> 
Classes 'listenv', 'environment' <environment: 0x55659bf375e0> 
[13:20:25.353] resolved() for ‘SequentialFuture’ ...
[13:20:25.353] - state: ‘finished’
[13:20:25.353] - run: TRUE
[13:20:25.354] - result: ‘FutureResult’
[13:20:25.354] resolved() for ‘SequentialFuture’ ... done
[13:20:25.354] resolved() for ‘SequentialFuture’ ...
[13:20:25.354] - state: ‘finished’
[13:20:25.354] - run: TRUE
[13:20:25.354] - result: ‘FutureResult’
[13:20:25.354] resolved() for ‘SequentialFuture’ ... done
[13:20:25.354] resolved() for ‘SequentialFuture’ ...
[13:20:25.354] - state: ‘finished’
[13:20:25.354] - run: TRUE
[13:20:25.355] - result: ‘FutureResult’
[13:20:25.355] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:25.356] resolve() on list environment ...
[13:20:25.357]  recursive: 0
[13:20:25.357]  length: 6
[13:20:25.357]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:25.358] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.358] - nx: 6
[13:20:25.358] - relay: TRUE
[13:20:25.358] - stdout: TRUE
[13:20:25.358] - signal: TRUE
[13:20:25.358] - resignal: FALSE
[13:20:25.358] - force: TRUE
[13:20:25.358] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.358] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.358]  - until=2
[13:20:25.358]  - relaying element #2
[13:20:25.359] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.359] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.359] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.359]  length: 5 (resolved future 1)
[13:20:25.359] resolved() for ‘SequentialFuture’ ...
[13:20:25.359] - state: ‘finished’
[13:20:25.359] - run: TRUE
[13:20:25.359] - result: ‘FutureResult’
[13:20:25.359] resolved() for ‘SequentialFuture’ ... done
[13:20:25.359] Future #2
[13:20:25.360] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.360] - nx: 6
[13:20:25.360] - relay: TRUE
[13:20:25.360] - stdout: TRUE
[13:20:25.360] - signal: TRUE
[13:20:25.360] - resignal: FALSE
[13:20:25.360] - force: TRUE
[13:20:25.360] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.360] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.360]  - until=2
[13:20:25.360]  - relaying element #2
[13:20:25.361] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.361] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.361] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.361]  length: 4 (resolved future 2)
[13:20:25.361] resolved() for ‘SequentialFuture’ ...
[13:20:25.361] - state: ‘finished’
[13:20:25.361] - run: TRUE
[13:20:25.361] - result: ‘FutureResult’
[13:20:25.361] resolved() for ‘SequentialFuture’ ... done
[13:20:25.361] Future #3
[13:20:25.362] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.362] - nx: 6
[13:20:25.362] - relay: TRUE
[13:20:25.362] - stdout: TRUE
[13:20:25.362] - signal: TRUE
[13:20:25.362] - resignal: FALSE
[13:20:25.362] - force: TRUE
[13:20:25.362] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.362] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.362]  - until=3
[13:20:25.362]  - relaying element #3
[13:20:25.363] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.363] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.363] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.363]  length: 3 (resolved future 3)
[13:20:25.363] resolved() for ‘SequentialFuture’ ...
[13:20:25.363] - state: ‘finished’
[13:20:25.363] - run: TRUE
[13:20:25.363] - result: ‘FutureResult’
[13:20:25.363] resolved() for ‘SequentialFuture’ ... done
[13:20:25.363] Future #4
[13:20:25.364] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:20:25.364] - nx: 6
[13:20:25.364] - relay: TRUE
[13:20:25.364] - stdout: TRUE
[13:20:25.364] - signal: TRUE
[13:20:25.364] - resignal: FALSE
[13:20:25.364] - force: TRUE
[13:20:25.364] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.364] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.364]  - until=4
[13:20:25.364]  - relaying element #4
[13:20:25.365] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.365] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.365] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:20:25.365]  length: 2 (resolved future 4)
[13:20:25.365] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.365] - nx: 6
[13:20:25.365] - relay: TRUE
[13:20:25.365] - stdout: TRUE
[13:20:25.365] - signal: TRUE
[13:20:25.365] - resignal: FALSE
[13:20:25.365] - force: TRUE
[13:20:25.366] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.366] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.366]  - until=6
[13:20:25.366]  - relaying element #6
[13:20:25.366] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.366] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.366] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.366]  length: 1 (resolved future 5)
[13:20:25.366] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.366] - nx: 6
[13:20:25.366] - relay: TRUE
[13:20:25.366] - stdout: TRUE
[13:20:25.367] - signal: TRUE
[13:20:25.367] - resignal: FALSE
[13:20:25.367] - force: TRUE
[13:20:25.367] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.367] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.367]  - until=6
[13:20:25.367] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.367] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.367] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.367]  length: 0 (resolved future 6)
[13:20:25.367] Relaying remaining futures
[13:20:25.368] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.368] - nx: 6
[13:20:25.368] - relay: TRUE
[13:20:25.368] - stdout: TRUE
[13:20:25.368] - signal: TRUE
[13:20:25.368] - resignal: FALSE
[13:20:25.368] - force: TRUE
[13:20:25.368] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.368] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:25.368] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.368] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.368] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.369] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55659a2f63d8> 
Dimensions: c(1, 6)
[13:20:25.369] getGlobalsAndPackages() ...
[13:20:25.369] Searching for globals...
[13:20:25.370] 
[13:20:25.370] Searching for globals ... DONE
[13:20:25.370] - globals: [0] <none>
[13:20:25.370] getGlobalsAndPackages() ... DONE
[13:20:25.370] run() for ‘Future’ ...
[13:20:25.370] - state: ‘created’
[13:20:25.370] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.371] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.371] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.371]   - Field: ‘label’
[13:20:25.371]   - Field: ‘local’
[13:20:25.371]   - Field: ‘owner’
[13:20:25.371]   - Field: ‘envir’
[13:20:25.371]   - Field: ‘packages’
[13:20:25.371]   - Field: ‘gc’
[13:20:25.371]   - Field: ‘conditions’
[13:20:25.371]   - Field: ‘expr’
[13:20:25.372]   - Field: ‘uuid’
[13:20:25.372]   - Field: ‘seed’
[13:20:25.372]   - Field: ‘version’
[13:20:25.372]   - Field: ‘result’
[13:20:25.372]   - Field: ‘asynchronous’
[13:20:25.372]   - Field: ‘calls’
[13:20:25.372]   - Field: ‘globals’
[13:20:25.372]   - Field: ‘stdout’
[13:20:25.372]   - Field: ‘earlySignal’
[13:20:25.372]   - Field: ‘lazy’
[13:20:25.372]   - Field: ‘state’
[13:20:25.372] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.373] - Launch lazy future ...
[13:20:25.373] Packages needed by the future expression (n = 0): <none>
[13:20:25.373] Packages needed by future strategies (n = 0): <none>
[13:20:25.398] {
[13:20:25.398]     {
[13:20:25.398]         {
[13:20:25.398]             ...future.startTime <- base::Sys.time()
[13:20:25.398]             {
[13:20:25.398]                 {
[13:20:25.398]                   {
[13:20:25.398]                     base::local({
[13:20:25.398]                       has_future <- base::requireNamespace("future", 
[13:20:25.398]                         quietly = TRUE)
[13:20:25.398]                       if (has_future) {
[13:20:25.398]                         ns <- base::getNamespace("future")
[13:20:25.398]                         version <- ns[[".package"]][["version"]]
[13:20:25.398]                         if (is.null(version)) 
[13:20:25.398]                           version <- utils::packageVersion("future")
[13:20:25.398]                       }
[13:20:25.398]                       else {
[13:20:25.398]                         version <- NULL
[13:20:25.398]                       }
[13:20:25.398]                       if (!has_future || version < "1.8.0") {
[13:20:25.398]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.398]                           "", base::R.version$version.string), 
[13:20:25.398]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.398]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.398]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.398]                             "release", "version")], collapse = " "), 
[13:20:25.398]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.398]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.398]                           info)
[13:20:25.398]                         info <- base::paste(info, collapse = "; ")
[13:20:25.398]                         if (!has_future) {
[13:20:25.398]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.398]                             info)
[13:20:25.398]                         }
[13:20:25.398]                         else {
[13:20:25.398]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.398]                             info, version)
[13:20:25.398]                         }
[13:20:25.398]                         base::stop(msg)
[13:20:25.398]                       }
[13:20:25.398]                     })
[13:20:25.398]                   }
[13:20:25.398]                   options(future.plan = NULL)
[13:20:25.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.398]                 }
[13:20:25.398]                 ...future.workdir <- getwd()
[13:20:25.398]             }
[13:20:25.398]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.398]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.398]         }
[13:20:25.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.398]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.398]             base::names(...future.oldOptions))
[13:20:25.398]     }
[13:20:25.398]     if (FALSE) {
[13:20:25.398]     }
[13:20:25.398]     else {
[13:20:25.398]         if (TRUE) {
[13:20:25.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.398]                 open = "w")
[13:20:25.398]         }
[13:20:25.398]         else {
[13:20:25.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.398]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.398]         }
[13:20:25.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.398]             base::sink(type = "output", split = FALSE)
[13:20:25.398]             base::close(...future.stdout)
[13:20:25.398]         }, add = TRUE)
[13:20:25.398]     }
[13:20:25.398]     ...future.frame <- base::sys.nframe()
[13:20:25.398]     ...future.conditions <- base::list()
[13:20:25.398]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.398]     if (FALSE) {
[13:20:25.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.398]     }
[13:20:25.398]     ...future.result <- base::tryCatch({
[13:20:25.398]         base::withCallingHandlers({
[13:20:25.398]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.398]             future::FutureResult(value = ...future.value$value, 
[13:20:25.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.398]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.398]                     ...future.globalenv.names))
[13:20:25.398]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.398]         }, condition = base::local({
[13:20:25.398]             c <- base::c
[13:20:25.398]             inherits <- base::inherits
[13:20:25.398]             invokeRestart <- base::invokeRestart
[13:20:25.398]             length <- base::length
[13:20:25.398]             list <- base::list
[13:20:25.398]             seq.int <- base::seq.int
[13:20:25.398]             signalCondition <- base::signalCondition
[13:20:25.398]             sys.calls <- base::sys.calls
[13:20:25.398]             `[[` <- base::`[[`
[13:20:25.398]             `+` <- base::`+`
[13:20:25.398]             `<<-` <- base::`<<-`
[13:20:25.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.398]                   3L)]
[13:20:25.398]             }
[13:20:25.398]             function(cond) {
[13:20:25.398]                 is_error <- inherits(cond, "error")
[13:20:25.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.398]                   NULL)
[13:20:25.398]                 if (is_error) {
[13:20:25.398]                   sessionInformation <- function() {
[13:20:25.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.398]                       search = base::search(), system = base::Sys.info())
[13:20:25.398]                   }
[13:20:25.398]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.398]                     cond$call), session = sessionInformation(), 
[13:20:25.398]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.398]                   signalCondition(cond)
[13:20:25.398]                 }
[13:20:25.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.398]                 "immediateCondition"))) {
[13:20:25.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.398]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.398]                   if (TRUE && !signal) {
[13:20:25.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.398]                     {
[13:20:25.398]                       inherits <- base::inherits
[13:20:25.398]                       invokeRestart <- base::invokeRestart
[13:20:25.398]                       is.null <- base::is.null
[13:20:25.398]                       muffled <- FALSE
[13:20:25.398]                       if (inherits(cond, "message")) {
[13:20:25.398]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.398]                         if (muffled) 
[13:20:25.398]                           invokeRestart("muffleMessage")
[13:20:25.398]                       }
[13:20:25.398]                       else if (inherits(cond, "warning")) {
[13:20:25.398]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.398]                         if (muffled) 
[13:20:25.398]                           invokeRestart("muffleWarning")
[13:20:25.398]                       }
[13:20:25.398]                       else if (inherits(cond, "condition")) {
[13:20:25.398]                         if (!is.null(pattern)) {
[13:20:25.398]                           computeRestarts <- base::computeRestarts
[13:20:25.398]                           grepl <- base::grepl
[13:20:25.398]                           restarts <- computeRestarts(cond)
[13:20:25.398]                           for (restart in restarts) {
[13:20:25.398]                             name <- restart$name
[13:20:25.398]                             if (is.null(name)) 
[13:20:25.398]                               next
[13:20:25.398]                             if (!grepl(pattern, name)) 
[13:20:25.398]                               next
[13:20:25.398]                             invokeRestart(restart)
[13:20:25.398]                             muffled <- TRUE
[13:20:25.398]                             break
[13:20:25.398]                           }
[13:20:25.398]                         }
[13:20:25.398]                       }
[13:20:25.398]                       invisible(muffled)
[13:20:25.398]                     }
[13:20:25.398]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.398]                   }
[13:20:25.398]                 }
[13:20:25.398]                 else {
[13:20:25.398]                   if (TRUE) {
[13:20:25.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.398]                     {
[13:20:25.398]                       inherits <- base::inherits
[13:20:25.398]                       invokeRestart <- base::invokeRestart
[13:20:25.398]                       is.null <- base::is.null
[13:20:25.398]                       muffled <- FALSE
[13:20:25.398]                       if (inherits(cond, "message")) {
[13:20:25.398]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.398]                         if (muffled) 
[13:20:25.398]                           invokeRestart("muffleMessage")
[13:20:25.398]                       }
[13:20:25.398]                       else if (inherits(cond, "warning")) {
[13:20:25.398]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.398]                         if (muffled) 
[13:20:25.398]                           invokeRestart("muffleWarning")
[13:20:25.398]                       }
[13:20:25.398]                       else if (inherits(cond, "condition")) {
[13:20:25.398]                         if (!is.null(pattern)) {
[13:20:25.398]                           computeRestarts <- base::computeRestarts
[13:20:25.398]                           grepl <- base::grepl
[13:20:25.398]                           restarts <- computeRestarts(cond)
[13:20:25.398]                           for (restart in restarts) {
[13:20:25.398]                             name <- restart$name
[13:20:25.398]                             if (is.null(name)) 
[13:20:25.398]                               next
[13:20:25.398]                             if (!grepl(pattern, name)) 
[13:20:25.398]                               next
[13:20:25.398]                             invokeRestart(restart)
[13:20:25.398]                             muffled <- TRUE
[13:20:25.398]                             break
[13:20:25.398]                           }
[13:20:25.398]                         }
[13:20:25.398]                       }
[13:20:25.398]                       invisible(muffled)
[13:20:25.398]                     }
[13:20:25.398]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.398]                   }
[13:20:25.398]                 }
[13:20:25.398]             }
[13:20:25.398]         }))
[13:20:25.398]     }, error = function(ex) {
[13:20:25.398]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.398]                 ...future.rng), started = ...future.startTime, 
[13:20:25.398]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.398]             version = "1.8"), class = "FutureResult")
[13:20:25.398]     }, finally = {
[13:20:25.398]         if (!identical(...future.workdir, getwd())) 
[13:20:25.398]             setwd(...future.workdir)
[13:20:25.398]         {
[13:20:25.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.398]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.398]             }
[13:20:25.398]             base::options(...future.oldOptions)
[13:20:25.398]             if (.Platform$OS.type == "windows") {
[13:20:25.398]                 old_names <- names(...future.oldEnvVars)
[13:20:25.398]                 envs <- base::Sys.getenv()
[13:20:25.398]                 names <- names(envs)
[13:20:25.398]                 common <- intersect(names, old_names)
[13:20:25.398]                 added <- setdiff(names, old_names)
[13:20:25.398]                 removed <- setdiff(old_names, names)
[13:20:25.398]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.398]                   envs[common]]
[13:20:25.398]                 NAMES <- toupper(changed)
[13:20:25.398]                 args <- list()
[13:20:25.398]                 for (kk in seq_along(NAMES)) {
[13:20:25.398]                   name <- changed[[kk]]
[13:20:25.398]                   NAME <- NAMES[[kk]]
[13:20:25.398]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.398]                     next
[13:20:25.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.398]                 }
[13:20:25.398]                 NAMES <- toupper(added)
[13:20:25.398]                 for (kk in seq_along(NAMES)) {
[13:20:25.398]                   name <- added[[kk]]
[13:20:25.398]                   NAME <- NAMES[[kk]]
[13:20:25.398]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.398]                     next
[13:20:25.398]                   args[[name]] <- ""
[13:20:25.398]                 }
[13:20:25.398]                 NAMES <- toupper(removed)
[13:20:25.398]                 for (kk in seq_along(NAMES)) {
[13:20:25.398]                   name <- removed[[kk]]
[13:20:25.398]                   NAME <- NAMES[[kk]]
[13:20:25.398]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.398]                     next
[13:20:25.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.398]                 }
[13:20:25.398]                 if (length(args) > 0) 
[13:20:25.398]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.398]             }
[13:20:25.398]             else {
[13:20:25.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.398]             }
[13:20:25.398]             {
[13:20:25.398]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.398]                   0L) {
[13:20:25.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.398]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.398]                   base::options(opts)
[13:20:25.398]                 }
[13:20:25.398]                 {
[13:20:25.398]                   {
[13:20:25.398]                     NULL
[13:20:25.398]                     RNGkind("Mersenne-Twister")
[13:20:25.398]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.398]                       inherits = FALSE)
[13:20:25.398]                   }
[13:20:25.398]                   options(future.plan = NULL)
[13:20:25.398]                   if (is.na(NA_character_)) 
[13:20:25.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.398]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.398]                   {
[13:20:25.398]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.398]                     if (!future$lazy) 
[13:20:25.398]                       future <- run(future)
[13:20:25.398]                     invisible(future)
[13:20:25.398]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.398]                 }
[13:20:25.398]             }
[13:20:25.398]         }
[13:20:25.398]     })
[13:20:25.398]     if (TRUE) {
[13:20:25.398]         base::sink(type = "output", split = FALSE)
[13:20:25.398]         if (TRUE) {
[13:20:25.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.398]         }
[13:20:25.398]         else {
[13:20:25.398]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.398]         }
[13:20:25.398]         base::close(...future.stdout)
[13:20:25.398]         ...future.stdout <- NULL
[13:20:25.398]     }
[13:20:25.398]     ...future.result$conditions <- ...future.conditions
[13:20:25.398]     ...future.result$finished <- base::Sys.time()
[13:20:25.398]     ...future.result
[13:20:25.398] }
[13:20:25.400] plan(): Setting new future strategy stack:
[13:20:25.400] List of future strategies:
[13:20:25.400] 1. sequential:
[13:20:25.400]    - args: function (..., envir = parent.frame())
[13:20:25.400]    - tweaked: FALSE
[13:20:25.400]    - call: NULL
[13:20:25.400] plan(): nbrOfWorkers() = 1
[13:20:25.401] plan(): Setting new future strategy stack:
[13:20:25.401] List of future strategies:
[13:20:25.401] 1. sequential:
[13:20:25.401]    - args: function (..., envir = parent.frame())
[13:20:25.401]    - tweaked: FALSE
[13:20:25.401]    - call: plan(strategy)
[13:20:25.402] plan(): nbrOfWorkers() = 1
[13:20:25.402] SequentialFuture started (and completed)
[13:20:25.402] - Launch lazy future ... done
[13:20:25.402] run() for ‘SequentialFuture’ ... done
[13:20:25.402] getGlobalsAndPackages() ...
[13:20:25.402] Searching for globals...
[13:20:25.403] 
[13:20:25.403] Searching for globals ... DONE
[13:20:25.403] - globals: [0] <none>
[13:20:25.403] getGlobalsAndPackages() ... DONE
[13:20:25.403] run() for ‘Future’ ...
[13:20:25.403] - state: ‘created’
[13:20:25.403] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.404] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.404]   - Field: ‘label’
[13:20:25.404]   - Field: ‘local’
[13:20:25.404]   - Field: ‘owner’
[13:20:25.404]   - Field: ‘envir’
[13:20:25.404]   - Field: ‘packages’
[13:20:25.404]   - Field: ‘gc’
[13:20:25.404]   - Field: ‘conditions’
[13:20:25.404]   - Field: ‘expr’
[13:20:25.404]   - Field: ‘uuid’
[13:20:25.405]   - Field: ‘seed’
[13:20:25.405]   - Field: ‘version’
[13:20:25.405]   - Field: ‘result’
[13:20:25.405]   - Field: ‘asynchronous’
[13:20:25.405]   - Field: ‘calls’
[13:20:25.405]   - Field: ‘globals’
[13:20:25.405]   - Field: ‘stdout’
[13:20:25.405]   - Field: ‘earlySignal’
[13:20:25.405]   - Field: ‘lazy’
[13:20:25.405]   - Field: ‘state’
[13:20:25.405] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.406] - Launch lazy future ...
[13:20:25.406] Packages needed by the future expression (n = 0): <none>
[13:20:25.406] Packages needed by future strategies (n = 0): <none>
[13:20:25.406] {
[13:20:25.406]     {
[13:20:25.406]         {
[13:20:25.406]             ...future.startTime <- base::Sys.time()
[13:20:25.406]             {
[13:20:25.406]                 {
[13:20:25.406]                   {
[13:20:25.406]                     base::local({
[13:20:25.406]                       has_future <- base::requireNamespace("future", 
[13:20:25.406]                         quietly = TRUE)
[13:20:25.406]                       if (has_future) {
[13:20:25.406]                         ns <- base::getNamespace("future")
[13:20:25.406]                         version <- ns[[".package"]][["version"]]
[13:20:25.406]                         if (is.null(version)) 
[13:20:25.406]                           version <- utils::packageVersion("future")
[13:20:25.406]                       }
[13:20:25.406]                       else {
[13:20:25.406]                         version <- NULL
[13:20:25.406]                       }
[13:20:25.406]                       if (!has_future || version < "1.8.0") {
[13:20:25.406]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.406]                           "", base::R.version$version.string), 
[13:20:25.406]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.406]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.406]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.406]                             "release", "version")], collapse = " "), 
[13:20:25.406]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.406]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.406]                           info)
[13:20:25.406]                         info <- base::paste(info, collapse = "; ")
[13:20:25.406]                         if (!has_future) {
[13:20:25.406]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.406]                             info)
[13:20:25.406]                         }
[13:20:25.406]                         else {
[13:20:25.406]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.406]                             info, version)
[13:20:25.406]                         }
[13:20:25.406]                         base::stop(msg)
[13:20:25.406]                       }
[13:20:25.406]                     })
[13:20:25.406]                   }
[13:20:25.406]                   options(future.plan = NULL)
[13:20:25.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.406]                 }
[13:20:25.406]                 ...future.workdir <- getwd()
[13:20:25.406]             }
[13:20:25.406]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.406]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.406]         }
[13:20:25.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.406]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.406]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.406]             base::names(...future.oldOptions))
[13:20:25.406]     }
[13:20:25.406]     if (FALSE) {
[13:20:25.406]     }
[13:20:25.406]     else {
[13:20:25.406]         if (TRUE) {
[13:20:25.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.406]                 open = "w")
[13:20:25.406]         }
[13:20:25.406]         else {
[13:20:25.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.406]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.406]         }
[13:20:25.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.406]             base::sink(type = "output", split = FALSE)
[13:20:25.406]             base::close(...future.stdout)
[13:20:25.406]         }, add = TRUE)
[13:20:25.406]     }
[13:20:25.406]     ...future.frame <- base::sys.nframe()
[13:20:25.406]     ...future.conditions <- base::list()
[13:20:25.406]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.406]     if (FALSE) {
[13:20:25.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.406]     }
[13:20:25.406]     ...future.result <- base::tryCatch({
[13:20:25.406]         base::withCallingHandlers({
[13:20:25.406]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.406]             future::FutureResult(value = ...future.value$value, 
[13:20:25.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.406]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.406]                     ...future.globalenv.names))
[13:20:25.406]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.406]         }, condition = base::local({
[13:20:25.406]             c <- base::c
[13:20:25.406]             inherits <- base::inherits
[13:20:25.406]             invokeRestart <- base::invokeRestart
[13:20:25.406]             length <- base::length
[13:20:25.406]             list <- base::list
[13:20:25.406]             seq.int <- base::seq.int
[13:20:25.406]             signalCondition <- base::signalCondition
[13:20:25.406]             sys.calls <- base::sys.calls
[13:20:25.406]             `[[` <- base::`[[`
[13:20:25.406]             `+` <- base::`+`
[13:20:25.406]             `<<-` <- base::`<<-`
[13:20:25.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.406]                   3L)]
[13:20:25.406]             }
[13:20:25.406]             function(cond) {
[13:20:25.406]                 is_error <- inherits(cond, "error")
[13:20:25.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.406]                   NULL)
[13:20:25.406]                 if (is_error) {
[13:20:25.406]                   sessionInformation <- function() {
[13:20:25.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.406]                       search = base::search(), system = base::Sys.info())
[13:20:25.406]                   }
[13:20:25.406]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.406]                     cond$call), session = sessionInformation(), 
[13:20:25.406]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.406]                   signalCondition(cond)
[13:20:25.406]                 }
[13:20:25.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.406]                 "immediateCondition"))) {
[13:20:25.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.406]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.406]                   if (TRUE && !signal) {
[13:20:25.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.406]                     {
[13:20:25.406]                       inherits <- base::inherits
[13:20:25.406]                       invokeRestart <- base::invokeRestart
[13:20:25.406]                       is.null <- base::is.null
[13:20:25.406]                       muffled <- FALSE
[13:20:25.406]                       if (inherits(cond, "message")) {
[13:20:25.406]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.406]                         if (muffled) 
[13:20:25.406]                           invokeRestart("muffleMessage")
[13:20:25.406]                       }
[13:20:25.406]                       else if (inherits(cond, "warning")) {
[13:20:25.406]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.406]                         if (muffled) 
[13:20:25.406]                           invokeRestart("muffleWarning")
[13:20:25.406]                       }
[13:20:25.406]                       else if (inherits(cond, "condition")) {
[13:20:25.406]                         if (!is.null(pattern)) {
[13:20:25.406]                           computeRestarts <- base::computeRestarts
[13:20:25.406]                           grepl <- base::grepl
[13:20:25.406]                           restarts <- computeRestarts(cond)
[13:20:25.406]                           for (restart in restarts) {
[13:20:25.406]                             name <- restart$name
[13:20:25.406]                             if (is.null(name)) 
[13:20:25.406]                               next
[13:20:25.406]                             if (!grepl(pattern, name)) 
[13:20:25.406]                               next
[13:20:25.406]                             invokeRestart(restart)
[13:20:25.406]                             muffled <- TRUE
[13:20:25.406]                             break
[13:20:25.406]                           }
[13:20:25.406]                         }
[13:20:25.406]                       }
[13:20:25.406]                       invisible(muffled)
[13:20:25.406]                     }
[13:20:25.406]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.406]                   }
[13:20:25.406]                 }
[13:20:25.406]                 else {
[13:20:25.406]                   if (TRUE) {
[13:20:25.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.406]                     {
[13:20:25.406]                       inherits <- base::inherits
[13:20:25.406]                       invokeRestart <- base::invokeRestart
[13:20:25.406]                       is.null <- base::is.null
[13:20:25.406]                       muffled <- FALSE
[13:20:25.406]                       if (inherits(cond, "message")) {
[13:20:25.406]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.406]                         if (muffled) 
[13:20:25.406]                           invokeRestart("muffleMessage")
[13:20:25.406]                       }
[13:20:25.406]                       else if (inherits(cond, "warning")) {
[13:20:25.406]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.406]                         if (muffled) 
[13:20:25.406]                           invokeRestart("muffleWarning")
[13:20:25.406]                       }
[13:20:25.406]                       else if (inherits(cond, "condition")) {
[13:20:25.406]                         if (!is.null(pattern)) {
[13:20:25.406]                           computeRestarts <- base::computeRestarts
[13:20:25.406]                           grepl <- base::grepl
[13:20:25.406]                           restarts <- computeRestarts(cond)
[13:20:25.406]                           for (restart in restarts) {
[13:20:25.406]                             name <- restart$name
[13:20:25.406]                             if (is.null(name)) 
[13:20:25.406]                               next
[13:20:25.406]                             if (!grepl(pattern, name)) 
[13:20:25.406]                               next
[13:20:25.406]                             invokeRestart(restart)
[13:20:25.406]                             muffled <- TRUE
[13:20:25.406]                             break
[13:20:25.406]                           }
[13:20:25.406]                         }
[13:20:25.406]                       }
[13:20:25.406]                       invisible(muffled)
[13:20:25.406]                     }
[13:20:25.406]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.406]                   }
[13:20:25.406]                 }
[13:20:25.406]             }
[13:20:25.406]         }))
[13:20:25.406]     }, error = function(ex) {
[13:20:25.406]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.406]                 ...future.rng), started = ...future.startTime, 
[13:20:25.406]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.406]             version = "1.8"), class = "FutureResult")
[13:20:25.406]     }, finally = {
[13:20:25.406]         if (!identical(...future.workdir, getwd())) 
[13:20:25.406]             setwd(...future.workdir)
[13:20:25.406]         {
[13:20:25.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.406]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.406]             }
[13:20:25.406]             base::options(...future.oldOptions)
[13:20:25.406]             if (.Platform$OS.type == "windows") {
[13:20:25.406]                 old_names <- names(...future.oldEnvVars)
[13:20:25.406]                 envs <- base::Sys.getenv()
[13:20:25.406]                 names <- names(envs)
[13:20:25.406]                 common <- intersect(names, old_names)
[13:20:25.406]                 added <- setdiff(names, old_names)
[13:20:25.406]                 removed <- setdiff(old_names, names)
[13:20:25.406]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.406]                   envs[common]]
[13:20:25.406]                 NAMES <- toupper(changed)
[13:20:25.406]                 args <- list()
[13:20:25.406]                 for (kk in seq_along(NAMES)) {
[13:20:25.406]                   name <- changed[[kk]]
[13:20:25.406]                   NAME <- NAMES[[kk]]
[13:20:25.406]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.406]                     next
[13:20:25.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.406]                 }
[13:20:25.406]                 NAMES <- toupper(added)
[13:20:25.406]                 for (kk in seq_along(NAMES)) {
[13:20:25.406]                   name <- added[[kk]]
[13:20:25.406]                   NAME <- NAMES[[kk]]
[13:20:25.406]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.406]                     next
[13:20:25.406]                   args[[name]] <- ""
[13:20:25.406]                 }
[13:20:25.406]                 NAMES <- toupper(removed)
[13:20:25.406]                 for (kk in seq_along(NAMES)) {
[13:20:25.406]                   name <- removed[[kk]]
[13:20:25.406]                   NAME <- NAMES[[kk]]
[13:20:25.406]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.406]                     next
[13:20:25.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.406]                 }
[13:20:25.406]                 if (length(args) > 0) 
[13:20:25.406]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.406]             }
[13:20:25.406]             else {
[13:20:25.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.406]             }
[13:20:25.406]             {
[13:20:25.406]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.406]                   0L) {
[13:20:25.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.406]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.406]                   base::options(opts)
[13:20:25.406]                 }
[13:20:25.406]                 {
[13:20:25.406]                   {
[13:20:25.406]                     NULL
[13:20:25.406]                     RNGkind("Mersenne-Twister")
[13:20:25.406]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.406]                       inherits = FALSE)
[13:20:25.406]                   }
[13:20:25.406]                   options(future.plan = NULL)
[13:20:25.406]                   if (is.na(NA_character_)) 
[13:20:25.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.406]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.406]                   {
[13:20:25.406]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.406]                     if (!future$lazy) 
[13:20:25.406]                       future <- run(future)
[13:20:25.406]                     invisible(future)
[13:20:25.406]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.406]                 }
[13:20:25.406]             }
[13:20:25.406]         }
[13:20:25.406]     })
[13:20:25.406]     if (TRUE) {
[13:20:25.406]         base::sink(type = "output", split = FALSE)
[13:20:25.406]         if (TRUE) {
[13:20:25.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.406]         }
[13:20:25.406]         else {
[13:20:25.406]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.406]         }
[13:20:25.406]         base::close(...future.stdout)
[13:20:25.406]         ...future.stdout <- NULL
[13:20:25.406]     }
[13:20:25.406]     ...future.result$conditions <- ...future.conditions
[13:20:25.406]     ...future.result$finished <- base::Sys.time()
[13:20:25.406]     ...future.result
[13:20:25.406] }
[13:20:25.408] plan(): Setting new future strategy stack:
[13:20:25.408] List of future strategies:
[13:20:25.408] 1. sequential:
[13:20:25.408]    - args: function (..., envir = parent.frame())
[13:20:25.408]    - tweaked: FALSE
[13:20:25.408]    - call: NULL
[13:20:25.408] plan(): nbrOfWorkers() = 1
[13:20:25.409] plan(): Setting new future strategy stack:
[13:20:25.409] List of future strategies:
[13:20:25.409] 1. sequential:
[13:20:25.409]    - args: function (..., envir = parent.frame())
[13:20:25.409]    - tweaked: FALSE
[13:20:25.409]    - call: plan(strategy)
[13:20:25.410] plan(): nbrOfWorkers() = 1
[13:20:25.410] SequentialFuture started (and completed)
[13:20:25.410] - Launch lazy future ... done
[13:20:25.410] run() for ‘SequentialFuture’ ... done
[13:20:25.410] getGlobalsAndPackages() ...
[13:20:25.410] Searching for globals...
[13:20:25.411] - globals found: [1] ‘{’
[13:20:25.411] Searching for globals ... DONE
[13:20:25.411] Resolving globals: FALSE
[13:20:25.411] 
[13:20:25.411] 
[13:20:25.412] getGlobalsAndPackages() ... DONE
[13:20:25.412] run() for ‘Future’ ...
[13:20:25.412] - state: ‘created’
[13:20:25.412] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.412] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.412]   - Field: ‘label’
[13:20:25.413]   - Field: ‘local’
[13:20:25.413]   - Field: ‘owner’
[13:20:25.413]   - Field: ‘envir’
[13:20:25.413]   - Field: ‘packages’
[13:20:25.413]   - Field: ‘gc’
[13:20:25.413]   - Field: ‘conditions’
[13:20:25.413]   - Field: ‘expr’
[13:20:25.413]   - Field: ‘uuid’
[13:20:25.413]   - Field: ‘seed’
[13:20:25.413]   - Field: ‘version’
[13:20:25.413]   - Field: ‘result’
[13:20:25.414]   - Field: ‘asynchronous’
[13:20:25.414]   - Field: ‘calls’
[13:20:25.414]   - Field: ‘globals’
[13:20:25.414]   - Field: ‘stdout’
[13:20:25.414]   - Field: ‘earlySignal’
[13:20:25.414]   - Field: ‘lazy’
[13:20:25.414]   - Field: ‘state’
[13:20:25.414] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.414] - Launch lazy future ...
[13:20:25.414] Packages needed by the future expression (n = 0): <none>
[13:20:25.415] Packages needed by future strategies (n = 0): <none>
[13:20:25.415] {
[13:20:25.415]     {
[13:20:25.415]         {
[13:20:25.415]             ...future.startTime <- base::Sys.time()
[13:20:25.415]             {
[13:20:25.415]                 {
[13:20:25.415]                   {
[13:20:25.415]                     base::local({
[13:20:25.415]                       has_future <- base::requireNamespace("future", 
[13:20:25.415]                         quietly = TRUE)
[13:20:25.415]                       if (has_future) {
[13:20:25.415]                         ns <- base::getNamespace("future")
[13:20:25.415]                         version <- ns[[".package"]][["version"]]
[13:20:25.415]                         if (is.null(version)) 
[13:20:25.415]                           version <- utils::packageVersion("future")
[13:20:25.415]                       }
[13:20:25.415]                       else {
[13:20:25.415]                         version <- NULL
[13:20:25.415]                       }
[13:20:25.415]                       if (!has_future || version < "1.8.0") {
[13:20:25.415]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.415]                           "", base::R.version$version.string), 
[13:20:25.415]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.415]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.415]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.415]                             "release", "version")], collapse = " "), 
[13:20:25.415]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.415]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.415]                           info)
[13:20:25.415]                         info <- base::paste(info, collapse = "; ")
[13:20:25.415]                         if (!has_future) {
[13:20:25.415]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.415]                             info)
[13:20:25.415]                         }
[13:20:25.415]                         else {
[13:20:25.415]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.415]                             info, version)
[13:20:25.415]                         }
[13:20:25.415]                         base::stop(msg)
[13:20:25.415]                       }
[13:20:25.415]                     })
[13:20:25.415]                   }
[13:20:25.415]                   options(future.plan = NULL)
[13:20:25.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.415]                 }
[13:20:25.415]                 ...future.workdir <- getwd()
[13:20:25.415]             }
[13:20:25.415]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.415]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.415]         }
[13:20:25.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.415]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.415]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.415]             base::names(...future.oldOptions))
[13:20:25.415]     }
[13:20:25.415]     if (FALSE) {
[13:20:25.415]     }
[13:20:25.415]     else {
[13:20:25.415]         if (TRUE) {
[13:20:25.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.415]                 open = "w")
[13:20:25.415]         }
[13:20:25.415]         else {
[13:20:25.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.415]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.415]         }
[13:20:25.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.415]             base::sink(type = "output", split = FALSE)
[13:20:25.415]             base::close(...future.stdout)
[13:20:25.415]         }, add = TRUE)
[13:20:25.415]     }
[13:20:25.415]     ...future.frame <- base::sys.nframe()
[13:20:25.415]     ...future.conditions <- base::list()
[13:20:25.415]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.415]     if (FALSE) {
[13:20:25.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.415]     }
[13:20:25.415]     ...future.result <- base::tryCatch({
[13:20:25.415]         base::withCallingHandlers({
[13:20:25.415]             ...future.value <- base::withVisible(base::local({
[13:20:25.415]                 4
[13:20:25.415]             }))
[13:20:25.415]             future::FutureResult(value = ...future.value$value, 
[13:20:25.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.415]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.415]                     ...future.globalenv.names))
[13:20:25.415]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.415]         }, condition = base::local({
[13:20:25.415]             c <- base::c
[13:20:25.415]             inherits <- base::inherits
[13:20:25.415]             invokeRestart <- base::invokeRestart
[13:20:25.415]             length <- base::length
[13:20:25.415]             list <- base::list
[13:20:25.415]             seq.int <- base::seq.int
[13:20:25.415]             signalCondition <- base::signalCondition
[13:20:25.415]             sys.calls <- base::sys.calls
[13:20:25.415]             `[[` <- base::`[[`
[13:20:25.415]             `+` <- base::`+`
[13:20:25.415]             `<<-` <- base::`<<-`
[13:20:25.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.415]                   3L)]
[13:20:25.415]             }
[13:20:25.415]             function(cond) {
[13:20:25.415]                 is_error <- inherits(cond, "error")
[13:20:25.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.415]                   NULL)
[13:20:25.415]                 if (is_error) {
[13:20:25.415]                   sessionInformation <- function() {
[13:20:25.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.415]                       search = base::search(), system = base::Sys.info())
[13:20:25.415]                   }
[13:20:25.415]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.415]                     cond$call), session = sessionInformation(), 
[13:20:25.415]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.415]                   signalCondition(cond)
[13:20:25.415]                 }
[13:20:25.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.415]                 "immediateCondition"))) {
[13:20:25.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.415]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.415]                   if (TRUE && !signal) {
[13:20:25.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.415]                     {
[13:20:25.415]                       inherits <- base::inherits
[13:20:25.415]                       invokeRestart <- base::invokeRestart
[13:20:25.415]                       is.null <- base::is.null
[13:20:25.415]                       muffled <- FALSE
[13:20:25.415]                       if (inherits(cond, "message")) {
[13:20:25.415]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.415]                         if (muffled) 
[13:20:25.415]                           invokeRestart("muffleMessage")
[13:20:25.415]                       }
[13:20:25.415]                       else if (inherits(cond, "warning")) {
[13:20:25.415]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.415]                         if (muffled) 
[13:20:25.415]                           invokeRestart("muffleWarning")
[13:20:25.415]                       }
[13:20:25.415]                       else if (inherits(cond, "condition")) {
[13:20:25.415]                         if (!is.null(pattern)) {
[13:20:25.415]                           computeRestarts <- base::computeRestarts
[13:20:25.415]                           grepl <- base::grepl
[13:20:25.415]                           restarts <- computeRestarts(cond)
[13:20:25.415]                           for (restart in restarts) {
[13:20:25.415]                             name <- restart$name
[13:20:25.415]                             if (is.null(name)) 
[13:20:25.415]                               next
[13:20:25.415]                             if (!grepl(pattern, name)) 
[13:20:25.415]                               next
[13:20:25.415]                             invokeRestart(restart)
[13:20:25.415]                             muffled <- TRUE
[13:20:25.415]                             break
[13:20:25.415]                           }
[13:20:25.415]                         }
[13:20:25.415]                       }
[13:20:25.415]                       invisible(muffled)
[13:20:25.415]                     }
[13:20:25.415]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.415]                   }
[13:20:25.415]                 }
[13:20:25.415]                 else {
[13:20:25.415]                   if (TRUE) {
[13:20:25.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.415]                     {
[13:20:25.415]                       inherits <- base::inherits
[13:20:25.415]                       invokeRestart <- base::invokeRestart
[13:20:25.415]                       is.null <- base::is.null
[13:20:25.415]                       muffled <- FALSE
[13:20:25.415]                       if (inherits(cond, "message")) {
[13:20:25.415]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.415]                         if (muffled) 
[13:20:25.415]                           invokeRestart("muffleMessage")
[13:20:25.415]                       }
[13:20:25.415]                       else if (inherits(cond, "warning")) {
[13:20:25.415]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.415]                         if (muffled) 
[13:20:25.415]                           invokeRestart("muffleWarning")
[13:20:25.415]                       }
[13:20:25.415]                       else if (inherits(cond, "condition")) {
[13:20:25.415]                         if (!is.null(pattern)) {
[13:20:25.415]                           computeRestarts <- base::computeRestarts
[13:20:25.415]                           grepl <- base::grepl
[13:20:25.415]                           restarts <- computeRestarts(cond)
[13:20:25.415]                           for (restart in restarts) {
[13:20:25.415]                             name <- restart$name
[13:20:25.415]                             if (is.null(name)) 
[13:20:25.415]                               next
[13:20:25.415]                             if (!grepl(pattern, name)) 
[13:20:25.415]                               next
[13:20:25.415]                             invokeRestart(restart)
[13:20:25.415]                             muffled <- TRUE
[13:20:25.415]                             break
[13:20:25.415]                           }
[13:20:25.415]                         }
[13:20:25.415]                       }
[13:20:25.415]                       invisible(muffled)
[13:20:25.415]                     }
[13:20:25.415]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.415]                   }
[13:20:25.415]                 }
[13:20:25.415]             }
[13:20:25.415]         }))
[13:20:25.415]     }, error = function(ex) {
[13:20:25.415]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.415]                 ...future.rng), started = ...future.startTime, 
[13:20:25.415]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.415]             version = "1.8"), class = "FutureResult")
[13:20:25.415]     }, finally = {
[13:20:25.415]         if (!identical(...future.workdir, getwd())) 
[13:20:25.415]             setwd(...future.workdir)
[13:20:25.415]         {
[13:20:25.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.415]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.415]             }
[13:20:25.415]             base::options(...future.oldOptions)
[13:20:25.415]             if (.Platform$OS.type == "windows") {
[13:20:25.415]                 old_names <- names(...future.oldEnvVars)
[13:20:25.415]                 envs <- base::Sys.getenv()
[13:20:25.415]                 names <- names(envs)
[13:20:25.415]                 common <- intersect(names, old_names)
[13:20:25.415]                 added <- setdiff(names, old_names)
[13:20:25.415]                 removed <- setdiff(old_names, names)
[13:20:25.415]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.415]                   envs[common]]
[13:20:25.415]                 NAMES <- toupper(changed)
[13:20:25.415]                 args <- list()
[13:20:25.415]                 for (kk in seq_along(NAMES)) {
[13:20:25.415]                   name <- changed[[kk]]
[13:20:25.415]                   NAME <- NAMES[[kk]]
[13:20:25.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.415]                     next
[13:20:25.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.415]                 }
[13:20:25.415]                 NAMES <- toupper(added)
[13:20:25.415]                 for (kk in seq_along(NAMES)) {
[13:20:25.415]                   name <- added[[kk]]
[13:20:25.415]                   NAME <- NAMES[[kk]]
[13:20:25.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.415]                     next
[13:20:25.415]                   args[[name]] <- ""
[13:20:25.415]                 }
[13:20:25.415]                 NAMES <- toupper(removed)
[13:20:25.415]                 for (kk in seq_along(NAMES)) {
[13:20:25.415]                   name <- removed[[kk]]
[13:20:25.415]                   NAME <- NAMES[[kk]]
[13:20:25.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.415]                     next
[13:20:25.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.415]                 }
[13:20:25.415]                 if (length(args) > 0) 
[13:20:25.415]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.415]             }
[13:20:25.415]             else {
[13:20:25.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.415]             }
[13:20:25.415]             {
[13:20:25.415]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.415]                   0L) {
[13:20:25.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.415]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.415]                   base::options(opts)
[13:20:25.415]                 }
[13:20:25.415]                 {
[13:20:25.415]                   {
[13:20:25.415]                     NULL
[13:20:25.415]                     RNGkind("Mersenne-Twister")
[13:20:25.415]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.415]                       inherits = FALSE)
[13:20:25.415]                   }
[13:20:25.415]                   options(future.plan = NULL)
[13:20:25.415]                   if (is.na(NA_character_)) 
[13:20:25.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.415]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.415]                   {
[13:20:25.415]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.415]                     if (!future$lazy) 
[13:20:25.415]                       future <- run(future)
[13:20:25.415]                     invisible(future)
[13:20:25.415]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.415]                 }
[13:20:25.415]             }
[13:20:25.415]         }
[13:20:25.415]     })
[13:20:25.415]     if (TRUE) {
[13:20:25.415]         base::sink(type = "output", split = FALSE)
[13:20:25.415]         if (TRUE) {
[13:20:25.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.415]         }
[13:20:25.415]         else {
[13:20:25.415]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.415]         }
[13:20:25.415]         base::close(...future.stdout)
[13:20:25.415]         ...future.stdout <- NULL
[13:20:25.415]     }
[13:20:25.415]     ...future.result$conditions <- ...future.conditions
[13:20:25.415]     ...future.result$finished <- base::Sys.time()
[13:20:25.415]     ...future.result
[13:20:25.415] }
[13:20:25.417] plan(): Setting new future strategy stack:
[13:20:25.417] List of future strategies:
[13:20:25.417] 1. sequential:
[13:20:25.417]    - args: function (..., envir = parent.frame())
[13:20:25.417]    - tweaked: FALSE
[13:20:25.417]    - call: NULL
[13:20:25.417] plan(): nbrOfWorkers() = 1
[13:20:25.418] plan(): Setting new future strategy stack:
[13:20:25.418] List of future strategies:
[13:20:25.418] 1. sequential:
[13:20:25.418]    - args: function (..., envir = parent.frame())
[13:20:25.418]    - tweaked: FALSE
[13:20:25.418]    - call: plan(strategy)
[13:20:25.418] plan(): nbrOfWorkers() = 1
[13:20:25.419] SequentialFuture started (and completed)
[13:20:25.419] - Launch lazy future ... done
[13:20:25.419] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55659bd92248> 
Classes 'listenv', 'environment' <environment: 0x55659bc37130> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:20:25.422] resolved() for ‘SequentialFuture’ ...
[13:20:25.423] - state: ‘finished’
[13:20:25.423] - run: TRUE
[13:20:25.423] - result: ‘FutureResult’
[13:20:25.423] resolved() for ‘SequentialFuture’ ... done
[13:20:25.423] resolved() for ‘SequentialFuture’ ...
[13:20:25.423] - state: ‘finished’
[13:20:25.423] - run: TRUE
[13:20:25.423] - result: ‘FutureResult’
[13:20:25.423] resolved() for ‘SequentialFuture’ ... done
[13:20:25.423] resolved() for ‘SequentialFuture’ ...
[13:20:25.424] - state: ‘finished’
[13:20:25.424] - run: TRUE
[13:20:25.424] - result: ‘FutureResult’
[13:20:25.424] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:25.426] resolve() on list environment ...
[13:20:25.426]  recursive: 0
[13:20:25.429]  length: 6
[13:20:25.429]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:25.429] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.429] - nx: 6
[13:20:25.430] - relay: TRUE
[13:20:25.430] - stdout: TRUE
[13:20:25.430] - signal: TRUE
[13:20:25.430] - resignal: FALSE
[13:20:25.430] - force: TRUE
[13:20:25.430] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.430] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.430]  - until=2
[13:20:25.430]  - relaying element #2
[13:20:25.431] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.431] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.431] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.431]  length: 5 (resolved future 1)
[13:20:25.431] resolved() for ‘SequentialFuture’ ...
[13:20:25.431] - state: ‘finished’
[13:20:25.431] - run: TRUE
[13:20:25.431] - result: ‘FutureResult’
[13:20:25.431] resolved() for ‘SequentialFuture’ ... done
[13:20:25.432] Future #2
[13:20:25.432] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.432] - nx: 6
[13:20:25.432] - relay: TRUE
[13:20:25.432] - stdout: TRUE
[13:20:25.432] - signal: TRUE
[13:20:25.432] - resignal: FALSE
[13:20:25.432] - force: TRUE
[13:20:25.432] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.432] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.433]  - until=2
[13:20:25.433]  - relaying element #2
[13:20:25.433] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.433] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.433] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.433]  length: 4 (resolved future 2)
[13:20:25.433] resolved() for ‘SequentialFuture’ ...
[13:20:25.433] - state: ‘finished’
[13:20:25.433] - run: TRUE
[13:20:25.434] - result: ‘FutureResult’
[13:20:25.434] resolved() for ‘SequentialFuture’ ... done
[13:20:25.434] Future #3
[13:20:25.434] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.434] - nx: 6
[13:20:25.434] - relay: TRUE
[13:20:25.434] - stdout: TRUE
[13:20:25.434] - signal: TRUE
[13:20:25.434] - resignal: FALSE
[13:20:25.434] - force: TRUE
[13:20:25.434] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.435] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.435]  - until=3
[13:20:25.435]  - relaying element #3
[13:20:25.435] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.435] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.435] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.435]  length: 3 (resolved future 3)
[13:20:25.435] resolved() for ‘SequentialFuture’ ...
[13:20:25.435] - state: ‘finished’
[13:20:25.436] - run: TRUE
[13:20:25.436] - result: ‘FutureResult’
[13:20:25.436] resolved() for ‘SequentialFuture’ ... done
[13:20:25.436] Future #4
[13:20:25.436] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:20:25.436] - nx: 6
[13:20:25.436] - relay: TRUE
[13:20:25.436] - stdout: TRUE
[13:20:25.436] - signal: TRUE
[13:20:25.436] - resignal: FALSE
[13:20:25.436] - force: TRUE
[13:20:25.437] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.437] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.437]  - until=4
[13:20:25.437]  - relaying element #4
[13:20:25.437] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.437] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.437] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:20:25.437]  length: 2 (resolved future 4)
[13:20:25.437] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.438] - nx: 6
[13:20:25.438] - relay: TRUE
[13:20:25.438] - stdout: TRUE
[13:20:25.438] - signal: TRUE
[13:20:25.438] - resignal: FALSE
[13:20:25.438] - force: TRUE
[13:20:25.438] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.438] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.438]  - until=6
[13:20:25.438]  - relaying element #6
[13:20:25.438] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.438] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.439] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.439]  length: 1 (resolved future 5)
[13:20:25.439] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.439] - nx: 6
[13:20:25.439] - relay: TRUE
[13:20:25.439] - stdout: TRUE
[13:20:25.439] - signal: TRUE
[13:20:25.439] - resignal: FALSE
[13:20:25.439] - force: TRUE
[13:20:25.439] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.439] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.440]  - until=6
[13:20:25.440] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.440] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.440] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.440]  length: 0 (resolved future 6)
[13:20:25.440] Relaying remaining futures
[13:20:25.440] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.440] - nx: 6
[13:20:25.440] - relay: TRUE
[13:20:25.440] - stdout: TRUE
[13:20:25.440] - signal: TRUE
[13:20:25.441] - resignal: FALSE
[13:20:25.441] - force: TRUE
[13:20:25.441] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.441] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:25.441] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.441] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.441] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.441] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55659c0b8a08> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:20:25.443] getGlobalsAndPackages() ...
[13:20:25.444] Searching for globals...
[13:20:25.444] 
[13:20:25.444] Searching for globals ... DONE
[13:20:25.444] - globals: [0] <none>
[13:20:25.444] getGlobalsAndPackages() ... DONE
[13:20:25.445] run() for ‘Future’ ...
[13:20:25.445] - state: ‘created’
[13:20:25.445] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.445] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.445] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.445]   - Field: ‘label’
[13:20:25.445]   - Field: ‘local’
[13:20:25.445]   - Field: ‘owner’
[13:20:25.446]   - Field: ‘envir’
[13:20:25.446]   - Field: ‘packages’
[13:20:25.446]   - Field: ‘gc’
[13:20:25.446]   - Field: ‘conditions’
[13:20:25.446]   - Field: ‘expr’
[13:20:25.446]   - Field: ‘uuid’
[13:20:25.446]   - Field: ‘seed’
[13:20:25.446]   - Field: ‘version’
[13:20:25.446]   - Field: ‘result’
[13:20:25.446]   - Field: ‘asynchronous’
[13:20:25.447]   - Field: ‘calls’
[13:20:25.447]   - Field: ‘globals’
[13:20:25.447]   - Field: ‘stdout’
[13:20:25.447]   - Field: ‘earlySignal’
[13:20:25.447]   - Field: ‘lazy’
[13:20:25.447]   - Field: ‘state’
[13:20:25.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.447] - Launch lazy future ...
[13:20:25.447] Packages needed by the future expression (n = 0): <none>
[13:20:25.448] Packages needed by future strategies (n = 0): <none>
[13:20:25.448] {
[13:20:25.448]     {
[13:20:25.448]         {
[13:20:25.448]             ...future.startTime <- base::Sys.time()
[13:20:25.448]             {
[13:20:25.448]                 {
[13:20:25.448]                   {
[13:20:25.448]                     base::local({
[13:20:25.448]                       has_future <- base::requireNamespace("future", 
[13:20:25.448]                         quietly = TRUE)
[13:20:25.448]                       if (has_future) {
[13:20:25.448]                         ns <- base::getNamespace("future")
[13:20:25.448]                         version <- ns[[".package"]][["version"]]
[13:20:25.448]                         if (is.null(version)) 
[13:20:25.448]                           version <- utils::packageVersion("future")
[13:20:25.448]                       }
[13:20:25.448]                       else {
[13:20:25.448]                         version <- NULL
[13:20:25.448]                       }
[13:20:25.448]                       if (!has_future || version < "1.8.0") {
[13:20:25.448]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.448]                           "", base::R.version$version.string), 
[13:20:25.448]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.448]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.448]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.448]                             "release", "version")], collapse = " "), 
[13:20:25.448]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.448]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.448]                           info)
[13:20:25.448]                         info <- base::paste(info, collapse = "; ")
[13:20:25.448]                         if (!has_future) {
[13:20:25.448]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.448]                             info)
[13:20:25.448]                         }
[13:20:25.448]                         else {
[13:20:25.448]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.448]                             info, version)
[13:20:25.448]                         }
[13:20:25.448]                         base::stop(msg)
[13:20:25.448]                       }
[13:20:25.448]                     })
[13:20:25.448]                   }
[13:20:25.448]                   options(future.plan = NULL)
[13:20:25.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.448]                 }
[13:20:25.448]                 ...future.workdir <- getwd()
[13:20:25.448]             }
[13:20:25.448]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.448]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.448]         }
[13:20:25.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.448]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.448]             base::names(...future.oldOptions))
[13:20:25.448]     }
[13:20:25.448]     if (FALSE) {
[13:20:25.448]     }
[13:20:25.448]     else {
[13:20:25.448]         if (TRUE) {
[13:20:25.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.448]                 open = "w")
[13:20:25.448]         }
[13:20:25.448]         else {
[13:20:25.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.448]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.448]         }
[13:20:25.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.448]             base::sink(type = "output", split = FALSE)
[13:20:25.448]             base::close(...future.stdout)
[13:20:25.448]         }, add = TRUE)
[13:20:25.448]     }
[13:20:25.448]     ...future.frame <- base::sys.nframe()
[13:20:25.448]     ...future.conditions <- base::list()
[13:20:25.448]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.448]     if (FALSE) {
[13:20:25.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.448]     }
[13:20:25.448]     ...future.result <- base::tryCatch({
[13:20:25.448]         base::withCallingHandlers({
[13:20:25.448]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.448]             future::FutureResult(value = ...future.value$value, 
[13:20:25.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.448]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.448]                     ...future.globalenv.names))
[13:20:25.448]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.448]         }, condition = base::local({
[13:20:25.448]             c <- base::c
[13:20:25.448]             inherits <- base::inherits
[13:20:25.448]             invokeRestart <- base::invokeRestart
[13:20:25.448]             length <- base::length
[13:20:25.448]             list <- base::list
[13:20:25.448]             seq.int <- base::seq.int
[13:20:25.448]             signalCondition <- base::signalCondition
[13:20:25.448]             sys.calls <- base::sys.calls
[13:20:25.448]             `[[` <- base::`[[`
[13:20:25.448]             `+` <- base::`+`
[13:20:25.448]             `<<-` <- base::`<<-`
[13:20:25.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.448]                   3L)]
[13:20:25.448]             }
[13:20:25.448]             function(cond) {
[13:20:25.448]                 is_error <- inherits(cond, "error")
[13:20:25.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.448]                   NULL)
[13:20:25.448]                 if (is_error) {
[13:20:25.448]                   sessionInformation <- function() {
[13:20:25.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.448]                       search = base::search(), system = base::Sys.info())
[13:20:25.448]                   }
[13:20:25.448]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.448]                     cond$call), session = sessionInformation(), 
[13:20:25.448]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.448]                   signalCondition(cond)
[13:20:25.448]                 }
[13:20:25.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.448]                 "immediateCondition"))) {
[13:20:25.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.448]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.448]                   if (TRUE && !signal) {
[13:20:25.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.448]                     {
[13:20:25.448]                       inherits <- base::inherits
[13:20:25.448]                       invokeRestart <- base::invokeRestart
[13:20:25.448]                       is.null <- base::is.null
[13:20:25.448]                       muffled <- FALSE
[13:20:25.448]                       if (inherits(cond, "message")) {
[13:20:25.448]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.448]                         if (muffled) 
[13:20:25.448]                           invokeRestart("muffleMessage")
[13:20:25.448]                       }
[13:20:25.448]                       else if (inherits(cond, "warning")) {
[13:20:25.448]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.448]                         if (muffled) 
[13:20:25.448]                           invokeRestart("muffleWarning")
[13:20:25.448]                       }
[13:20:25.448]                       else if (inherits(cond, "condition")) {
[13:20:25.448]                         if (!is.null(pattern)) {
[13:20:25.448]                           computeRestarts <- base::computeRestarts
[13:20:25.448]                           grepl <- base::grepl
[13:20:25.448]                           restarts <- computeRestarts(cond)
[13:20:25.448]                           for (restart in restarts) {
[13:20:25.448]                             name <- restart$name
[13:20:25.448]                             if (is.null(name)) 
[13:20:25.448]                               next
[13:20:25.448]                             if (!grepl(pattern, name)) 
[13:20:25.448]                               next
[13:20:25.448]                             invokeRestart(restart)
[13:20:25.448]                             muffled <- TRUE
[13:20:25.448]                             break
[13:20:25.448]                           }
[13:20:25.448]                         }
[13:20:25.448]                       }
[13:20:25.448]                       invisible(muffled)
[13:20:25.448]                     }
[13:20:25.448]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.448]                   }
[13:20:25.448]                 }
[13:20:25.448]                 else {
[13:20:25.448]                   if (TRUE) {
[13:20:25.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.448]                     {
[13:20:25.448]                       inherits <- base::inherits
[13:20:25.448]                       invokeRestart <- base::invokeRestart
[13:20:25.448]                       is.null <- base::is.null
[13:20:25.448]                       muffled <- FALSE
[13:20:25.448]                       if (inherits(cond, "message")) {
[13:20:25.448]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.448]                         if (muffled) 
[13:20:25.448]                           invokeRestart("muffleMessage")
[13:20:25.448]                       }
[13:20:25.448]                       else if (inherits(cond, "warning")) {
[13:20:25.448]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.448]                         if (muffled) 
[13:20:25.448]                           invokeRestart("muffleWarning")
[13:20:25.448]                       }
[13:20:25.448]                       else if (inherits(cond, "condition")) {
[13:20:25.448]                         if (!is.null(pattern)) {
[13:20:25.448]                           computeRestarts <- base::computeRestarts
[13:20:25.448]                           grepl <- base::grepl
[13:20:25.448]                           restarts <- computeRestarts(cond)
[13:20:25.448]                           for (restart in restarts) {
[13:20:25.448]                             name <- restart$name
[13:20:25.448]                             if (is.null(name)) 
[13:20:25.448]                               next
[13:20:25.448]                             if (!grepl(pattern, name)) 
[13:20:25.448]                               next
[13:20:25.448]                             invokeRestart(restart)
[13:20:25.448]                             muffled <- TRUE
[13:20:25.448]                             break
[13:20:25.448]                           }
[13:20:25.448]                         }
[13:20:25.448]                       }
[13:20:25.448]                       invisible(muffled)
[13:20:25.448]                     }
[13:20:25.448]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.448]                   }
[13:20:25.448]                 }
[13:20:25.448]             }
[13:20:25.448]         }))
[13:20:25.448]     }, error = function(ex) {
[13:20:25.448]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.448]                 ...future.rng), started = ...future.startTime, 
[13:20:25.448]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.448]             version = "1.8"), class = "FutureResult")
[13:20:25.448]     }, finally = {
[13:20:25.448]         if (!identical(...future.workdir, getwd())) 
[13:20:25.448]             setwd(...future.workdir)
[13:20:25.448]         {
[13:20:25.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.448]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.448]             }
[13:20:25.448]             base::options(...future.oldOptions)
[13:20:25.448]             if (.Platform$OS.type == "windows") {
[13:20:25.448]                 old_names <- names(...future.oldEnvVars)
[13:20:25.448]                 envs <- base::Sys.getenv()
[13:20:25.448]                 names <- names(envs)
[13:20:25.448]                 common <- intersect(names, old_names)
[13:20:25.448]                 added <- setdiff(names, old_names)
[13:20:25.448]                 removed <- setdiff(old_names, names)
[13:20:25.448]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.448]                   envs[common]]
[13:20:25.448]                 NAMES <- toupper(changed)
[13:20:25.448]                 args <- list()
[13:20:25.448]                 for (kk in seq_along(NAMES)) {
[13:20:25.448]                   name <- changed[[kk]]
[13:20:25.448]                   NAME <- NAMES[[kk]]
[13:20:25.448]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.448]                     next
[13:20:25.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.448]                 }
[13:20:25.448]                 NAMES <- toupper(added)
[13:20:25.448]                 for (kk in seq_along(NAMES)) {
[13:20:25.448]                   name <- added[[kk]]
[13:20:25.448]                   NAME <- NAMES[[kk]]
[13:20:25.448]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.448]                     next
[13:20:25.448]                   args[[name]] <- ""
[13:20:25.448]                 }
[13:20:25.448]                 NAMES <- toupper(removed)
[13:20:25.448]                 for (kk in seq_along(NAMES)) {
[13:20:25.448]                   name <- removed[[kk]]
[13:20:25.448]                   NAME <- NAMES[[kk]]
[13:20:25.448]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.448]                     next
[13:20:25.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.448]                 }
[13:20:25.448]                 if (length(args) > 0) 
[13:20:25.448]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.448]             }
[13:20:25.448]             else {
[13:20:25.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.448]             }
[13:20:25.448]             {
[13:20:25.448]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.448]                   0L) {
[13:20:25.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.448]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.448]                   base::options(opts)
[13:20:25.448]                 }
[13:20:25.448]                 {
[13:20:25.448]                   {
[13:20:25.448]                     NULL
[13:20:25.448]                     RNGkind("Mersenne-Twister")
[13:20:25.448]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.448]                       inherits = FALSE)
[13:20:25.448]                   }
[13:20:25.448]                   options(future.plan = NULL)
[13:20:25.448]                   if (is.na(NA_character_)) 
[13:20:25.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.448]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.448]                   {
[13:20:25.448]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.448]                     if (!future$lazy) 
[13:20:25.448]                       future <- run(future)
[13:20:25.448]                     invisible(future)
[13:20:25.448]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.448]                 }
[13:20:25.448]             }
[13:20:25.448]         }
[13:20:25.448]     })
[13:20:25.448]     if (TRUE) {
[13:20:25.448]         base::sink(type = "output", split = FALSE)
[13:20:25.448]         if (TRUE) {
[13:20:25.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.448]         }
[13:20:25.448]         else {
[13:20:25.448]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.448]         }
[13:20:25.448]         base::close(...future.stdout)
[13:20:25.448]         ...future.stdout <- NULL
[13:20:25.448]     }
[13:20:25.448]     ...future.result$conditions <- ...future.conditions
[13:20:25.448]     ...future.result$finished <- base::Sys.time()
[13:20:25.448]     ...future.result
[13:20:25.448] }
[13:20:25.450] plan(): Setting new future strategy stack:
[13:20:25.450] List of future strategies:
[13:20:25.450] 1. sequential:
[13:20:25.450]    - args: function (..., envir = parent.frame())
[13:20:25.450]    - tweaked: FALSE
[13:20:25.450]    - call: NULL
[13:20:25.450] plan(): nbrOfWorkers() = 1
[13:20:25.451] plan(): Setting new future strategy stack:
[13:20:25.451] List of future strategies:
[13:20:25.451] 1. sequential:
[13:20:25.451]    - args: function (..., envir = parent.frame())
[13:20:25.451]    - tweaked: FALSE
[13:20:25.451]    - call: plan(strategy)
[13:20:25.452] plan(): nbrOfWorkers() = 1
[13:20:25.452] SequentialFuture started (and completed)
[13:20:25.452] - Launch lazy future ... done
[13:20:25.452] run() for ‘SequentialFuture’ ... done
[13:20:25.452] getGlobalsAndPackages() ...
[13:20:25.452] Searching for globals...
[13:20:25.453] 
[13:20:25.453] Searching for globals ... DONE
[13:20:25.453] - globals: [0] <none>
[13:20:25.453] getGlobalsAndPackages() ... DONE
[13:20:25.453] run() for ‘Future’ ...
[13:20:25.453] - state: ‘created’
[13:20:25.453] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.454] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.454]   - Field: ‘label’
[13:20:25.454]   - Field: ‘local’
[13:20:25.454]   - Field: ‘owner’
[13:20:25.454]   - Field: ‘envir’
[13:20:25.454]   - Field: ‘packages’
[13:20:25.454]   - Field: ‘gc’
[13:20:25.455]   - Field: ‘conditions’
[13:20:25.455]   - Field: ‘expr’
[13:20:25.455]   - Field: ‘uuid’
[13:20:25.455]   - Field: ‘seed’
[13:20:25.455]   - Field: ‘version’
[13:20:25.455]   - Field: ‘result’
[13:20:25.455]   - Field: ‘asynchronous’
[13:20:25.455]   - Field: ‘calls’
[13:20:25.455]   - Field: ‘globals’
[13:20:25.455]   - Field: ‘stdout’
[13:20:25.455]   - Field: ‘earlySignal’
[13:20:25.456]   - Field: ‘lazy’
[13:20:25.456]   - Field: ‘state’
[13:20:25.456] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.456] - Launch lazy future ...
[13:20:25.456] Packages needed by the future expression (n = 0): <none>
[13:20:25.456] Packages needed by future strategies (n = 0): <none>
[13:20:25.458] {
[13:20:25.458]     {
[13:20:25.458]         {
[13:20:25.458]             ...future.startTime <- base::Sys.time()
[13:20:25.458]             {
[13:20:25.458]                 {
[13:20:25.458]                   {
[13:20:25.458]                     base::local({
[13:20:25.458]                       has_future <- base::requireNamespace("future", 
[13:20:25.458]                         quietly = TRUE)
[13:20:25.458]                       if (has_future) {
[13:20:25.458]                         ns <- base::getNamespace("future")
[13:20:25.458]                         version <- ns[[".package"]][["version"]]
[13:20:25.458]                         if (is.null(version)) 
[13:20:25.458]                           version <- utils::packageVersion("future")
[13:20:25.458]                       }
[13:20:25.458]                       else {
[13:20:25.458]                         version <- NULL
[13:20:25.458]                       }
[13:20:25.458]                       if (!has_future || version < "1.8.0") {
[13:20:25.458]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.458]                           "", base::R.version$version.string), 
[13:20:25.458]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.458]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.458]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.458]                             "release", "version")], collapse = " "), 
[13:20:25.458]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.458]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.458]                           info)
[13:20:25.458]                         info <- base::paste(info, collapse = "; ")
[13:20:25.458]                         if (!has_future) {
[13:20:25.458]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.458]                             info)
[13:20:25.458]                         }
[13:20:25.458]                         else {
[13:20:25.458]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.458]                             info, version)
[13:20:25.458]                         }
[13:20:25.458]                         base::stop(msg)
[13:20:25.458]                       }
[13:20:25.458]                     })
[13:20:25.458]                   }
[13:20:25.458]                   options(future.plan = NULL)
[13:20:25.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.458]                 }
[13:20:25.458]                 ...future.workdir <- getwd()
[13:20:25.458]             }
[13:20:25.458]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.458]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.458]         }
[13:20:25.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.458]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.458]             base::names(...future.oldOptions))
[13:20:25.458]     }
[13:20:25.458]     if (FALSE) {
[13:20:25.458]     }
[13:20:25.458]     else {
[13:20:25.458]         if (TRUE) {
[13:20:25.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.458]                 open = "w")
[13:20:25.458]         }
[13:20:25.458]         else {
[13:20:25.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.458]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.458]         }
[13:20:25.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.458]             base::sink(type = "output", split = FALSE)
[13:20:25.458]             base::close(...future.stdout)
[13:20:25.458]         }, add = TRUE)
[13:20:25.458]     }
[13:20:25.458]     ...future.frame <- base::sys.nframe()
[13:20:25.458]     ...future.conditions <- base::list()
[13:20:25.458]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.458]     if (FALSE) {
[13:20:25.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.458]     }
[13:20:25.458]     ...future.result <- base::tryCatch({
[13:20:25.458]         base::withCallingHandlers({
[13:20:25.458]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.458]             future::FutureResult(value = ...future.value$value, 
[13:20:25.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.458]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.458]                     ...future.globalenv.names))
[13:20:25.458]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.458]         }, condition = base::local({
[13:20:25.458]             c <- base::c
[13:20:25.458]             inherits <- base::inherits
[13:20:25.458]             invokeRestart <- base::invokeRestart
[13:20:25.458]             length <- base::length
[13:20:25.458]             list <- base::list
[13:20:25.458]             seq.int <- base::seq.int
[13:20:25.458]             signalCondition <- base::signalCondition
[13:20:25.458]             sys.calls <- base::sys.calls
[13:20:25.458]             `[[` <- base::`[[`
[13:20:25.458]             `+` <- base::`+`
[13:20:25.458]             `<<-` <- base::`<<-`
[13:20:25.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.458]                   3L)]
[13:20:25.458]             }
[13:20:25.458]             function(cond) {
[13:20:25.458]                 is_error <- inherits(cond, "error")
[13:20:25.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.458]                   NULL)
[13:20:25.458]                 if (is_error) {
[13:20:25.458]                   sessionInformation <- function() {
[13:20:25.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.458]                       search = base::search(), system = base::Sys.info())
[13:20:25.458]                   }
[13:20:25.458]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.458]                     cond$call), session = sessionInformation(), 
[13:20:25.458]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.458]                   signalCondition(cond)
[13:20:25.458]                 }
[13:20:25.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.458]                 "immediateCondition"))) {
[13:20:25.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.458]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.458]                   if (TRUE && !signal) {
[13:20:25.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.458]                     {
[13:20:25.458]                       inherits <- base::inherits
[13:20:25.458]                       invokeRestart <- base::invokeRestart
[13:20:25.458]                       is.null <- base::is.null
[13:20:25.458]                       muffled <- FALSE
[13:20:25.458]                       if (inherits(cond, "message")) {
[13:20:25.458]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.458]                         if (muffled) 
[13:20:25.458]                           invokeRestart("muffleMessage")
[13:20:25.458]                       }
[13:20:25.458]                       else if (inherits(cond, "warning")) {
[13:20:25.458]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.458]                         if (muffled) 
[13:20:25.458]                           invokeRestart("muffleWarning")
[13:20:25.458]                       }
[13:20:25.458]                       else if (inherits(cond, "condition")) {
[13:20:25.458]                         if (!is.null(pattern)) {
[13:20:25.458]                           computeRestarts <- base::computeRestarts
[13:20:25.458]                           grepl <- base::grepl
[13:20:25.458]                           restarts <- computeRestarts(cond)
[13:20:25.458]                           for (restart in restarts) {
[13:20:25.458]                             name <- restart$name
[13:20:25.458]                             if (is.null(name)) 
[13:20:25.458]                               next
[13:20:25.458]                             if (!grepl(pattern, name)) 
[13:20:25.458]                               next
[13:20:25.458]                             invokeRestart(restart)
[13:20:25.458]                             muffled <- TRUE
[13:20:25.458]                             break
[13:20:25.458]                           }
[13:20:25.458]                         }
[13:20:25.458]                       }
[13:20:25.458]                       invisible(muffled)
[13:20:25.458]                     }
[13:20:25.458]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.458]                   }
[13:20:25.458]                 }
[13:20:25.458]                 else {
[13:20:25.458]                   if (TRUE) {
[13:20:25.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.458]                     {
[13:20:25.458]                       inherits <- base::inherits
[13:20:25.458]                       invokeRestart <- base::invokeRestart
[13:20:25.458]                       is.null <- base::is.null
[13:20:25.458]                       muffled <- FALSE
[13:20:25.458]                       if (inherits(cond, "message")) {
[13:20:25.458]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.458]                         if (muffled) 
[13:20:25.458]                           invokeRestart("muffleMessage")
[13:20:25.458]                       }
[13:20:25.458]                       else if (inherits(cond, "warning")) {
[13:20:25.458]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.458]                         if (muffled) 
[13:20:25.458]                           invokeRestart("muffleWarning")
[13:20:25.458]                       }
[13:20:25.458]                       else if (inherits(cond, "condition")) {
[13:20:25.458]                         if (!is.null(pattern)) {
[13:20:25.458]                           computeRestarts <- base::computeRestarts
[13:20:25.458]                           grepl <- base::grepl
[13:20:25.458]                           restarts <- computeRestarts(cond)
[13:20:25.458]                           for (restart in restarts) {
[13:20:25.458]                             name <- restart$name
[13:20:25.458]                             if (is.null(name)) 
[13:20:25.458]                               next
[13:20:25.458]                             if (!grepl(pattern, name)) 
[13:20:25.458]                               next
[13:20:25.458]                             invokeRestart(restart)
[13:20:25.458]                             muffled <- TRUE
[13:20:25.458]                             break
[13:20:25.458]                           }
[13:20:25.458]                         }
[13:20:25.458]                       }
[13:20:25.458]                       invisible(muffled)
[13:20:25.458]                     }
[13:20:25.458]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.458]                   }
[13:20:25.458]                 }
[13:20:25.458]             }
[13:20:25.458]         }))
[13:20:25.458]     }, error = function(ex) {
[13:20:25.458]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.458]                 ...future.rng), started = ...future.startTime, 
[13:20:25.458]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.458]             version = "1.8"), class = "FutureResult")
[13:20:25.458]     }, finally = {
[13:20:25.458]         if (!identical(...future.workdir, getwd())) 
[13:20:25.458]             setwd(...future.workdir)
[13:20:25.458]         {
[13:20:25.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.458]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.458]             }
[13:20:25.458]             base::options(...future.oldOptions)
[13:20:25.458]             if (.Platform$OS.type == "windows") {
[13:20:25.458]                 old_names <- names(...future.oldEnvVars)
[13:20:25.458]                 envs <- base::Sys.getenv()
[13:20:25.458]                 names <- names(envs)
[13:20:25.458]                 common <- intersect(names, old_names)
[13:20:25.458]                 added <- setdiff(names, old_names)
[13:20:25.458]                 removed <- setdiff(old_names, names)
[13:20:25.458]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.458]                   envs[common]]
[13:20:25.458]                 NAMES <- toupper(changed)
[13:20:25.458]                 args <- list()
[13:20:25.458]                 for (kk in seq_along(NAMES)) {
[13:20:25.458]                   name <- changed[[kk]]
[13:20:25.458]                   NAME <- NAMES[[kk]]
[13:20:25.458]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.458]                     next
[13:20:25.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.458]                 }
[13:20:25.458]                 NAMES <- toupper(added)
[13:20:25.458]                 for (kk in seq_along(NAMES)) {
[13:20:25.458]                   name <- added[[kk]]
[13:20:25.458]                   NAME <- NAMES[[kk]]
[13:20:25.458]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.458]                     next
[13:20:25.458]                   args[[name]] <- ""
[13:20:25.458]                 }
[13:20:25.458]                 NAMES <- toupper(removed)
[13:20:25.458]                 for (kk in seq_along(NAMES)) {
[13:20:25.458]                   name <- removed[[kk]]
[13:20:25.458]                   NAME <- NAMES[[kk]]
[13:20:25.458]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.458]                     next
[13:20:25.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.458]                 }
[13:20:25.458]                 if (length(args) > 0) 
[13:20:25.458]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.458]             }
[13:20:25.458]             else {
[13:20:25.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.458]             }
[13:20:25.458]             {
[13:20:25.458]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.458]                   0L) {
[13:20:25.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.458]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.458]                   base::options(opts)
[13:20:25.458]                 }
[13:20:25.458]                 {
[13:20:25.458]                   {
[13:20:25.458]                     NULL
[13:20:25.458]                     RNGkind("Mersenne-Twister")
[13:20:25.458]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.458]                       inherits = FALSE)
[13:20:25.458]                   }
[13:20:25.458]                   options(future.plan = NULL)
[13:20:25.458]                   if (is.na(NA_character_)) 
[13:20:25.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.458]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.458]                   {
[13:20:25.458]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.458]                     if (!future$lazy) 
[13:20:25.458]                       future <- run(future)
[13:20:25.458]                     invisible(future)
[13:20:25.458]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.458]                 }
[13:20:25.458]             }
[13:20:25.458]         }
[13:20:25.458]     })
[13:20:25.458]     if (TRUE) {
[13:20:25.458]         base::sink(type = "output", split = FALSE)
[13:20:25.458]         if (TRUE) {
[13:20:25.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.458]         }
[13:20:25.458]         else {
[13:20:25.458]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.458]         }
[13:20:25.458]         base::close(...future.stdout)
[13:20:25.458]         ...future.stdout <- NULL
[13:20:25.458]     }
[13:20:25.458]     ...future.result$conditions <- ...future.conditions
[13:20:25.458]     ...future.result$finished <- base::Sys.time()
[13:20:25.458]     ...future.result
[13:20:25.458] }
[13:20:25.460] plan(): Setting new future strategy stack:
[13:20:25.460] List of future strategies:
[13:20:25.460] 1. sequential:
[13:20:25.460]    - args: function (..., envir = parent.frame())
[13:20:25.460]    - tweaked: FALSE
[13:20:25.460]    - call: NULL
[13:20:25.461] plan(): nbrOfWorkers() = 1
[13:20:25.462] plan(): Setting new future strategy stack:
[13:20:25.462] List of future strategies:
[13:20:25.462] 1. sequential:
[13:20:25.462]    - args: function (..., envir = parent.frame())
[13:20:25.462]    - tweaked: FALSE
[13:20:25.462]    - call: plan(strategy)
[13:20:25.462] plan(): nbrOfWorkers() = 1
[13:20:25.462] SequentialFuture started (and completed)
[13:20:25.463] - Launch lazy future ... done
[13:20:25.463] run() for ‘SequentialFuture’ ... done
[13:20:25.463] getGlobalsAndPackages() ...
[13:20:25.463] Searching for globals...
[13:20:25.464] - globals found: [1] ‘{’
[13:20:25.464] Searching for globals ... DONE
[13:20:25.464] Resolving globals: FALSE
[13:20:25.464] 
[13:20:25.464] 
[13:20:25.464] getGlobalsAndPackages() ... DONE
[13:20:25.465] run() for ‘Future’ ...
[13:20:25.465] - state: ‘created’
[13:20:25.465] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.465] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.465]   - Field: ‘label’
[13:20:25.465]   - Field: ‘local’
[13:20:25.466]   - Field: ‘owner’
[13:20:25.466]   - Field: ‘envir’
[13:20:25.466]   - Field: ‘packages’
[13:20:25.466]   - Field: ‘gc’
[13:20:25.466]   - Field: ‘conditions’
[13:20:25.466]   - Field: ‘expr’
[13:20:25.466]   - Field: ‘uuid’
[13:20:25.466]   - Field: ‘seed’
[13:20:25.466]   - Field: ‘version’
[13:20:25.466]   - Field: ‘result’
[13:20:25.467]   - Field: ‘asynchronous’
[13:20:25.467]   - Field: ‘calls’
[13:20:25.467]   - Field: ‘globals’
[13:20:25.467]   - Field: ‘stdout’
[13:20:25.467]   - Field: ‘earlySignal’
[13:20:25.467]   - Field: ‘lazy’
[13:20:25.467]   - Field: ‘state’
[13:20:25.467] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.467] - Launch lazy future ...
[13:20:25.467] Packages needed by the future expression (n = 0): <none>
[13:20:25.468] Packages needed by future strategies (n = 0): <none>
[13:20:25.468] {
[13:20:25.468]     {
[13:20:25.468]         {
[13:20:25.468]             ...future.startTime <- base::Sys.time()
[13:20:25.468]             {
[13:20:25.468]                 {
[13:20:25.468]                   {
[13:20:25.468]                     base::local({
[13:20:25.468]                       has_future <- base::requireNamespace("future", 
[13:20:25.468]                         quietly = TRUE)
[13:20:25.468]                       if (has_future) {
[13:20:25.468]                         ns <- base::getNamespace("future")
[13:20:25.468]                         version <- ns[[".package"]][["version"]]
[13:20:25.468]                         if (is.null(version)) 
[13:20:25.468]                           version <- utils::packageVersion("future")
[13:20:25.468]                       }
[13:20:25.468]                       else {
[13:20:25.468]                         version <- NULL
[13:20:25.468]                       }
[13:20:25.468]                       if (!has_future || version < "1.8.0") {
[13:20:25.468]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.468]                           "", base::R.version$version.string), 
[13:20:25.468]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.468]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.468]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.468]                             "release", "version")], collapse = " "), 
[13:20:25.468]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.468]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.468]                           info)
[13:20:25.468]                         info <- base::paste(info, collapse = "; ")
[13:20:25.468]                         if (!has_future) {
[13:20:25.468]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.468]                             info)
[13:20:25.468]                         }
[13:20:25.468]                         else {
[13:20:25.468]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.468]                             info, version)
[13:20:25.468]                         }
[13:20:25.468]                         base::stop(msg)
[13:20:25.468]                       }
[13:20:25.468]                     })
[13:20:25.468]                   }
[13:20:25.468]                   options(future.plan = NULL)
[13:20:25.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.468]                 }
[13:20:25.468]                 ...future.workdir <- getwd()
[13:20:25.468]             }
[13:20:25.468]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.468]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.468]         }
[13:20:25.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.468]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.468]             base::names(...future.oldOptions))
[13:20:25.468]     }
[13:20:25.468]     if (FALSE) {
[13:20:25.468]     }
[13:20:25.468]     else {
[13:20:25.468]         if (TRUE) {
[13:20:25.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.468]                 open = "w")
[13:20:25.468]         }
[13:20:25.468]         else {
[13:20:25.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.468]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.468]         }
[13:20:25.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.468]             base::sink(type = "output", split = FALSE)
[13:20:25.468]             base::close(...future.stdout)
[13:20:25.468]         }, add = TRUE)
[13:20:25.468]     }
[13:20:25.468]     ...future.frame <- base::sys.nframe()
[13:20:25.468]     ...future.conditions <- base::list()
[13:20:25.468]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.468]     if (FALSE) {
[13:20:25.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.468]     }
[13:20:25.468]     ...future.result <- base::tryCatch({
[13:20:25.468]         base::withCallingHandlers({
[13:20:25.468]             ...future.value <- base::withVisible(base::local({
[13:20:25.468]                 4
[13:20:25.468]             }))
[13:20:25.468]             future::FutureResult(value = ...future.value$value, 
[13:20:25.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.468]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.468]                     ...future.globalenv.names))
[13:20:25.468]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.468]         }, condition = base::local({
[13:20:25.468]             c <- base::c
[13:20:25.468]             inherits <- base::inherits
[13:20:25.468]             invokeRestart <- base::invokeRestart
[13:20:25.468]             length <- base::length
[13:20:25.468]             list <- base::list
[13:20:25.468]             seq.int <- base::seq.int
[13:20:25.468]             signalCondition <- base::signalCondition
[13:20:25.468]             sys.calls <- base::sys.calls
[13:20:25.468]             `[[` <- base::`[[`
[13:20:25.468]             `+` <- base::`+`
[13:20:25.468]             `<<-` <- base::`<<-`
[13:20:25.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.468]                   3L)]
[13:20:25.468]             }
[13:20:25.468]             function(cond) {
[13:20:25.468]                 is_error <- inherits(cond, "error")
[13:20:25.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.468]                   NULL)
[13:20:25.468]                 if (is_error) {
[13:20:25.468]                   sessionInformation <- function() {
[13:20:25.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.468]                       search = base::search(), system = base::Sys.info())
[13:20:25.468]                   }
[13:20:25.468]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.468]                     cond$call), session = sessionInformation(), 
[13:20:25.468]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.468]                   signalCondition(cond)
[13:20:25.468]                 }
[13:20:25.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.468]                 "immediateCondition"))) {
[13:20:25.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.468]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.468]                   if (TRUE && !signal) {
[13:20:25.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.468]                     {
[13:20:25.468]                       inherits <- base::inherits
[13:20:25.468]                       invokeRestart <- base::invokeRestart
[13:20:25.468]                       is.null <- base::is.null
[13:20:25.468]                       muffled <- FALSE
[13:20:25.468]                       if (inherits(cond, "message")) {
[13:20:25.468]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.468]                         if (muffled) 
[13:20:25.468]                           invokeRestart("muffleMessage")
[13:20:25.468]                       }
[13:20:25.468]                       else if (inherits(cond, "warning")) {
[13:20:25.468]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.468]                         if (muffled) 
[13:20:25.468]                           invokeRestart("muffleWarning")
[13:20:25.468]                       }
[13:20:25.468]                       else if (inherits(cond, "condition")) {
[13:20:25.468]                         if (!is.null(pattern)) {
[13:20:25.468]                           computeRestarts <- base::computeRestarts
[13:20:25.468]                           grepl <- base::grepl
[13:20:25.468]                           restarts <- computeRestarts(cond)
[13:20:25.468]                           for (restart in restarts) {
[13:20:25.468]                             name <- restart$name
[13:20:25.468]                             if (is.null(name)) 
[13:20:25.468]                               next
[13:20:25.468]                             if (!grepl(pattern, name)) 
[13:20:25.468]                               next
[13:20:25.468]                             invokeRestart(restart)
[13:20:25.468]                             muffled <- TRUE
[13:20:25.468]                             break
[13:20:25.468]                           }
[13:20:25.468]                         }
[13:20:25.468]                       }
[13:20:25.468]                       invisible(muffled)
[13:20:25.468]                     }
[13:20:25.468]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.468]                   }
[13:20:25.468]                 }
[13:20:25.468]                 else {
[13:20:25.468]                   if (TRUE) {
[13:20:25.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.468]                     {
[13:20:25.468]                       inherits <- base::inherits
[13:20:25.468]                       invokeRestart <- base::invokeRestart
[13:20:25.468]                       is.null <- base::is.null
[13:20:25.468]                       muffled <- FALSE
[13:20:25.468]                       if (inherits(cond, "message")) {
[13:20:25.468]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.468]                         if (muffled) 
[13:20:25.468]                           invokeRestart("muffleMessage")
[13:20:25.468]                       }
[13:20:25.468]                       else if (inherits(cond, "warning")) {
[13:20:25.468]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.468]                         if (muffled) 
[13:20:25.468]                           invokeRestart("muffleWarning")
[13:20:25.468]                       }
[13:20:25.468]                       else if (inherits(cond, "condition")) {
[13:20:25.468]                         if (!is.null(pattern)) {
[13:20:25.468]                           computeRestarts <- base::computeRestarts
[13:20:25.468]                           grepl <- base::grepl
[13:20:25.468]                           restarts <- computeRestarts(cond)
[13:20:25.468]                           for (restart in restarts) {
[13:20:25.468]                             name <- restart$name
[13:20:25.468]                             if (is.null(name)) 
[13:20:25.468]                               next
[13:20:25.468]                             if (!grepl(pattern, name)) 
[13:20:25.468]                               next
[13:20:25.468]                             invokeRestart(restart)
[13:20:25.468]                             muffled <- TRUE
[13:20:25.468]                             break
[13:20:25.468]                           }
[13:20:25.468]                         }
[13:20:25.468]                       }
[13:20:25.468]                       invisible(muffled)
[13:20:25.468]                     }
[13:20:25.468]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.468]                   }
[13:20:25.468]                 }
[13:20:25.468]             }
[13:20:25.468]         }))
[13:20:25.468]     }, error = function(ex) {
[13:20:25.468]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.468]                 ...future.rng), started = ...future.startTime, 
[13:20:25.468]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.468]             version = "1.8"), class = "FutureResult")
[13:20:25.468]     }, finally = {
[13:20:25.468]         if (!identical(...future.workdir, getwd())) 
[13:20:25.468]             setwd(...future.workdir)
[13:20:25.468]         {
[13:20:25.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.468]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.468]             }
[13:20:25.468]             base::options(...future.oldOptions)
[13:20:25.468]             if (.Platform$OS.type == "windows") {
[13:20:25.468]                 old_names <- names(...future.oldEnvVars)
[13:20:25.468]                 envs <- base::Sys.getenv()
[13:20:25.468]                 names <- names(envs)
[13:20:25.468]                 common <- intersect(names, old_names)
[13:20:25.468]                 added <- setdiff(names, old_names)
[13:20:25.468]                 removed <- setdiff(old_names, names)
[13:20:25.468]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.468]                   envs[common]]
[13:20:25.468]                 NAMES <- toupper(changed)
[13:20:25.468]                 args <- list()
[13:20:25.468]                 for (kk in seq_along(NAMES)) {
[13:20:25.468]                   name <- changed[[kk]]
[13:20:25.468]                   NAME <- NAMES[[kk]]
[13:20:25.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.468]                     next
[13:20:25.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.468]                 }
[13:20:25.468]                 NAMES <- toupper(added)
[13:20:25.468]                 for (kk in seq_along(NAMES)) {
[13:20:25.468]                   name <- added[[kk]]
[13:20:25.468]                   NAME <- NAMES[[kk]]
[13:20:25.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.468]                     next
[13:20:25.468]                   args[[name]] <- ""
[13:20:25.468]                 }
[13:20:25.468]                 NAMES <- toupper(removed)
[13:20:25.468]                 for (kk in seq_along(NAMES)) {
[13:20:25.468]                   name <- removed[[kk]]
[13:20:25.468]                   NAME <- NAMES[[kk]]
[13:20:25.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.468]                     next
[13:20:25.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.468]                 }
[13:20:25.468]                 if (length(args) > 0) 
[13:20:25.468]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.468]             }
[13:20:25.468]             else {
[13:20:25.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.468]             }
[13:20:25.468]             {
[13:20:25.468]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.468]                   0L) {
[13:20:25.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.468]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.468]                   base::options(opts)
[13:20:25.468]                 }
[13:20:25.468]                 {
[13:20:25.468]                   {
[13:20:25.468]                     NULL
[13:20:25.468]                     RNGkind("Mersenne-Twister")
[13:20:25.468]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.468]                       inherits = FALSE)
[13:20:25.468]                   }
[13:20:25.468]                   options(future.plan = NULL)
[13:20:25.468]                   if (is.na(NA_character_)) 
[13:20:25.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.468]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.468]                   {
[13:20:25.468]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.468]                     if (!future$lazy) 
[13:20:25.468]                       future <- run(future)
[13:20:25.468]                     invisible(future)
[13:20:25.468]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.468]                 }
[13:20:25.468]             }
[13:20:25.468]         }
[13:20:25.468]     })
[13:20:25.468]     if (TRUE) {
[13:20:25.468]         base::sink(type = "output", split = FALSE)
[13:20:25.468]         if (TRUE) {
[13:20:25.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.468]         }
[13:20:25.468]         else {
[13:20:25.468]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.468]         }
[13:20:25.468]         base::close(...future.stdout)
[13:20:25.468]         ...future.stdout <- NULL
[13:20:25.468]     }
[13:20:25.468]     ...future.result$conditions <- ...future.conditions
[13:20:25.468]     ...future.result$finished <- base::Sys.time()
[13:20:25.468]     ...future.result
[13:20:25.468] }
[13:20:25.470] plan(): Setting new future strategy stack:
[13:20:25.470] List of future strategies:
[13:20:25.470] 1. sequential:
[13:20:25.470]    - args: function (..., envir = parent.frame())
[13:20:25.470]    - tweaked: FALSE
[13:20:25.470]    - call: NULL
[13:20:25.470] plan(): nbrOfWorkers() = 1
[13:20:25.471] plan(): Setting new future strategy stack:
[13:20:25.471] List of future strategies:
[13:20:25.471] 1. sequential:
[13:20:25.471]    - args: function (..., envir = parent.frame())
[13:20:25.471]    - tweaked: FALSE
[13:20:25.471]    - call: plan(strategy)
[13:20:25.471] plan(): nbrOfWorkers() = 1
[13:20:25.472] SequentialFuture started (and completed)
[13:20:25.472] - Launch lazy future ... done
[13:20:25.472] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55659ba5e8b0> 
Classes 'listenv', 'environment' <environment: 0x55659b5f0e60> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:20:25.476] resolved() for ‘SequentialFuture’ ...
[13:20:25.476] - state: ‘finished’
[13:20:25.476] - run: TRUE
[13:20:25.476] - result: ‘FutureResult’
[13:20:25.476] resolved() for ‘SequentialFuture’ ... done
[13:20:25.476] resolved() for ‘SequentialFuture’ ...
[13:20:25.476] - state: ‘finished’
[13:20:25.476] - run: TRUE
[13:20:25.477] - result: ‘FutureResult’
[13:20:25.477] resolved() for ‘SequentialFuture’ ... done
[13:20:25.477] resolved() for ‘SequentialFuture’ ...
[13:20:25.477] - state: ‘finished’
[13:20:25.477] - run: TRUE
[13:20:25.477] - result: ‘FutureResult’
[13:20:25.477] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:25.480] resolve() on list environment ...
[13:20:25.480]  recursive: 0
[13:20:25.481]  length: 6
[13:20:25.481]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:25.481] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.481] - nx: 6
[13:20:25.481] - relay: TRUE
[13:20:25.481] - stdout: TRUE
[13:20:25.481] - signal: TRUE
[13:20:25.481] - resignal: FALSE
[13:20:25.481] - force: TRUE
[13:20:25.482] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.482] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.482]  - until=2
[13:20:25.482]  - relaying element #2
[13:20:25.482] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.482] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.482] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.482]  length: 5 (resolved future 1)
[13:20:25.482] resolved() for ‘SequentialFuture’ ...
[13:20:25.482] - state: ‘finished’
[13:20:25.483] - run: TRUE
[13:20:25.483] - result: ‘FutureResult’
[13:20:25.483] resolved() for ‘SequentialFuture’ ... done
[13:20:25.483] Future #2
[13:20:25.483] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.483] - nx: 6
[13:20:25.483] - relay: TRUE
[13:20:25.483] - stdout: TRUE
[13:20:25.483] - signal: TRUE
[13:20:25.483] - resignal: FALSE
[13:20:25.483] - force: TRUE
[13:20:25.484] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.484] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.484]  - until=2
[13:20:25.484]  - relaying element #2
[13:20:25.484] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.484] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.484] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.484]  length: 4 (resolved future 2)
[13:20:25.484] resolved() for ‘SequentialFuture’ ...
[13:20:25.485] - state: ‘finished’
[13:20:25.485] - run: TRUE
[13:20:25.485] - result: ‘FutureResult’
[13:20:25.485] resolved() for ‘SequentialFuture’ ... done
[13:20:25.485] Future #3
[13:20:25.485] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.485] - nx: 6
[13:20:25.485] - relay: TRUE
[13:20:25.485] - stdout: TRUE
[13:20:25.485] - signal: TRUE
[13:20:25.485] - resignal: FALSE
[13:20:25.486] - force: TRUE
[13:20:25.486] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.486] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.486]  - until=3
[13:20:25.486]  - relaying element #3
[13:20:25.486] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.486] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.486] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.486]  length: 3 (resolved future 3)
[13:20:25.488] resolved() for ‘SequentialFuture’ ...
[13:20:25.488] - state: ‘finished’
[13:20:25.488] - run: TRUE
[13:20:25.489] - result: ‘FutureResult’
[13:20:25.489] resolved() for ‘SequentialFuture’ ... done
[13:20:25.489] Future #4
[13:20:25.489] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:20:25.489] - nx: 6
[13:20:25.489] - relay: TRUE
[13:20:25.489] - stdout: TRUE
[13:20:25.489] - signal: TRUE
[13:20:25.489] - resignal: FALSE
[13:20:25.490] - force: TRUE
[13:20:25.490] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.490] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.490]  - until=4
[13:20:25.490]  - relaying element #4
[13:20:25.490] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.490] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.490] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:20:25.490]  length: 2 (resolved future 4)
[13:20:25.491] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.491] - nx: 6
[13:20:25.491] - relay: TRUE
[13:20:25.491] - stdout: TRUE
[13:20:25.491] - signal: TRUE
[13:20:25.491] - resignal: FALSE
[13:20:25.491] - force: TRUE
[13:20:25.491] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.491] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.491]  - until=6
[13:20:25.491]  - relaying element #6
[13:20:25.492] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.492] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.492] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.492]  length: 1 (resolved future 5)
[13:20:25.492] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.492] - nx: 6
[13:20:25.492] - relay: TRUE
[13:20:25.492] - stdout: TRUE
[13:20:25.492] - signal: TRUE
[13:20:25.492] - resignal: FALSE
[13:20:25.492] - force: TRUE
[13:20:25.493] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.493] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.493]  - until=6
[13:20:25.493] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.493] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.493] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.493]  length: 0 (resolved future 6)
[13:20:25.493] Relaying remaining futures
[13:20:25.493] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.493] - nx: 6
[13:20:25.493] - relay: TRUE
[13:20:25.494] - stdout: TRUE
[13:20:25.494] - signal: TRUE
[13:20:25.494] - resignal: FALSE
[13:20:25.494] - force: TRUE
[13:20:25.494] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.494] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:25.494] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.494] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.494] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.494] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55659bc5be60> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:20:25.496] getGlobalsAndPackages() ...
[13:20:25.497] Searching for globals...
[13:20:25.497] 
[13:20:25.497] Searching for globals ... DONE
[13:20:25.497] - globals: [0] <none>
[13:20:25.497] getGlobalsAndPackages() ... DONE
[13:20:25.497] run() for ‘Future’ ...
[13:20:25.498] - state: ‘created’
[13:20:25.498] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.498] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.498] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.498]   - Field: ‘label’
[13:20:25.498]   - Field: ‘local’
[13:20:25.498]   - Field: ‘owner’
[13:20:25.499]   - Field: ‘envir’
[13:20:25.499]   - Field: ‘packages’
[13:20:25.499]   - Field: ‘gc’
[13:20:25.499]   - Field: ‘conditions’
[13:20:25.499]   - Field: ‘expr’
[13:20:25.499]   - Field: ‘uuid’
[13:20:25.499]   - Field: ‘seed’
[13:20:25.499]   - Field: ‘version’
[13:20:25.499]   - Field: ‘result’
[13:20:25.499]   - Field: ‘asynchronous’
[13:20:25.499]   - Field: ‘calls’
[13:20:25.500]   - Field: ‘globals’
[13:20:25.500]   - Field: ‘stdout’
[13:20:25.500]   - Field: ‘earlySignal’
[13:20:25.500]   - Field: ‘lazy’
[13:20:25.500]   - Field: ‘state’
[13:20:25.500] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.500] - Launch lazy future ...
[13:20:25.500] Packages needed by the future expression (n = 0): <none>
[13:20:25.500] Packages needed by future strategies (n = 0): <none>
[13:20:25.501] {
[13:20:25.501]     {
[13:20:25.501]         {
[13:20:25.501]             ...future.startTime <- base::Sys.time()
[13:20:25.501]             {
[13:20:25.501]                 {
[13:20:25.501]                   {
[13:20:25.501]                     base::local({
[13:20:25.501]                       has_future <- base::requireNamespace("future", 
[13:20:25.501]                         quietly = TRUE)
[13:20:25.501]                       if (has_future) {
[13:20:25.501]                         ns <- base::getNamespace("future")
[13:20:25.501]                         version <- ns[[".package"]][["version"]]
[13:20:25.501]                         if (is.null(version)) 
[13:20:25.501]                           version <- utils::packageVersion("future")
[13:20:25.501]                       }
[13:20:25.501]                       else {
[13:20:25.501]                         version <- NULL
[13:20:25.501]                       }
[13:20:25.501]                       if (!has_future || version < "1.8.0") {
[13:20:25.501]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.501]                           "", base::R.version$version.string), 
[13:20:25.501]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.501]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.501]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.501]                             "release", "version")], collapse = " "), 
[13:20:25.501]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.501]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.501]                           info)
[13:20:25.501]                         info <- base::paste(info, collapse = "; ")
[13:20:25.501]                         if (!has_future) {
[13:20:25.501]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.501]                             info)
[13:20:25.501]                         }
[13:20:25.501]                         else {
[13:20:25.501]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.501]                             info, version)
[13:20:25.501]                         }
[13:20:25.501]                         base::stop(msg)
[13:20:25.501]                       }
[13:20:25.501]                     })
[13:20:25.501]                   }
[13:20:25.501]                   options(future.plan = NULL)
[13:20:25.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.501]                 }
[13:20:25.501]                 ...future.workdir <- getwd()
[13:20:25.501]             }
[13:20:25.501]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.501]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.501]         }
[13:20:25.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.501]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.501]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.501]             base::names(...future.oldOptions))
[13:20:25.501]     }
[13:20:25.501]     if (FALSE) {
[13:20:25.501]     }
[13:20:25.501]     else {
[13:20:25.501]         if (TRUE) {
[13:20:25.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.501]                 open = "w")
[13:20:25.501]         }
[13:20:25.501]         else {
[13:20:25.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.501]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.501]         }
[13:20:25.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.501]             base::sink(type = "output", split = FALSE)
[13:20:25.501]             base::close(...future.stdout)
[13:20:25.501]         }, add = TRUE)
[13:20:25.501]     }
[13:20:25.501]     ...future.frame <- base::sys.nframe()
[13:20:25.501]     ...future.conditions <- base::list()
[13:20:25.501]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.501]     if (FALSE) {
[13:20:25.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.501]     }
[13:20:25.501]     ...future.result <- base::tryCatch({
[13:20:25.501]         base::withCallingHandlers({
[13:20:25.501]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.501]             future::FutureResult(value = ...future.value$value, 
[13:20:25.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.501]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.501]                     ...future.globalenv.names))
[13:20:25.501]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.501]         }, condition = base::local({
[13:20:25.501]             c <- base::c
[13:20:25.501]             inherits <- base::inherits
[13:20:25.501]             invokeRestart <- base::invokeRestart
[13:20:25.501]             length <- base::length
[13:20:25.501]             list <- base::list
[13:20:25.501]             seq.int <- base::seq.int
[13:20:25.501]             signalCondition <- base::signalCondition
[13:20:25.501]             sys.calls <- base::sys.calls
[13:20:25.501]             `[[` <- base::`[[`
[13:20:25.501]             `+` <- base::`+`
[13:20:25.501]             `<<-` <- base::`<<-`
[13:20:25.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.501]                   3L)]
[13:20:25.501]             }
[13:20:25.501]             function(cond) {
[13:20:25.501]                 is_error <- inherits(cond, "error")
[13:20:25.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.501]                   NULL)
[13:20:25.501]                 if (is_error) {
[13:20:25.501]                   sessionInformation <- function() {
[13:20:25.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.501]                       search = base::search(), system = base::Sys.info())
[13:20:25.501]                   }
[13:20:25.501]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.501]                     cond$call), session = sessionInformation(), 
[13:20:25.501]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.501]                   signalCondition(cond)
[13:20:25.501]                 }
[13:20:25.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.501]                 "immediateCondition"))) {
[13:20:25.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.501]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.501]                   if (TRUE && !signal) {
[13:20:25.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.501]                     {
[13:20:25.501]                       inherits <- base::inherits
[13:20:25.501]                       invokeRestart <- base::invokeRestart
[13:20:25.501]                       is.null <- base::is.null
[13:20:25.501]                       muffled <- FALSE
[13:20:25.501]                       if (inherits(cond, "message")) {
[13:20:25.501]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.501]                         if (muffled) 
[13:20:25.501]                           invokeRestart("muffleMessage")
[13:20:25.501]                       }
[13:20:25.501]                       else if (inherits(cond, "warning")) {
[13:20:25.501]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.501]                         if (muffled) 
[13:20:25.501]                           invokeRestart("muffleWarning")
[13:20:25.501]                       }
[13:20:25.501]                       else if (inherits(cond, "condition")) {
[13:20:25.501]                         if (!is.null(pattern)) {
[13:20:25.501]                           computeRestarts <- base::computeRestarts
[13:20:25.501]                           grepl <- base::grepl
[13:20:25.501]                           restarts <- computeRestarts(cond)
[13:20:25.501]                           for (restart in restarts) {
[13:20:25.501]                             name <- restart$name
[13:20:25.501]                             if (is.null(name)) 
[13:20:25.501]                               next
[13:20:25.501]                             if (!grepl(pattern, name)) 
[13:20:25.501]                               next
[13:20:25.501]                             invokeRestart(restart)
[13:20:25.501]                             muffled <- TRUE
[13:20:25.501]                             break
[13:20:25.501]                           }
[13:20:25.501]                         }
[13:20:25.501]                       }
[13:20:25.501]                       invisible(muffled)
[13:20:25.501]                     }
[13:20:25.501]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.501]                   }
[13:20:25.501]                 }
[13:20:25.501]                 else {
[13:20:25.501]                   if (TRUE) {
[13:20:25.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.501]                     {
[13:20:25.501]                       inherits <- base::inherits
[13:20:25.501]                       invokeRestart <- base::invokeRestart
[13:20:25.501]                       is.null <- base::is.null
[13:20:25.501]                       muffled <- FALSE
[13:20:25.501]                       if (inherits(cond, "message")) {
[13:20:25.501]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.501]                         if (muffled) 
[13:20:25.501]                           invokeRestart("muffleMessage")
[13:20:25.501]                       }
[13:20:25.501]                       else if (inherits(cond, "warning")) {
[13:20:25.501]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.501]                         if (muffled) 
[13:20:25.501]                           invokeRestart("muffleWarning")
[13:20:25.501]                       }
[13:20:25.501]                       else if (inherits(cond, "condition")) {
[13:20:25.501]                         if (!is.null(pattern)) {
[13:20:25.501]                           computeRestarts <- base::computeRestarts
[13:20:25.501]                           grepl <- base::grepl
[13:20:25.501]                           restarts <- computeRestarts(cond)
[13:20:25.501]                           for (restart in restarts) {
[13:20:25.501]                             name <- restart$name
[13:20:25.501]                             if (is.null(name)) 
[13:20:25.501]                               next
[13:20:25.501]                             if (!grepl(pattern, name)) 
[13:20:25.501]                               next
[13:20:25.501]                             invokeRestart(restart)
[13:20:25.501]                             muffled <- TRUE
[13:20:25.501]                             break
[13:20:25.501]                           }
[13:20:25.501]                         }
[13:20:25.501]                       }
[13:20:25.501]                       invisible(muffled)
[13:20:25.501]                     }
[13:20:25.501]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.501]                   }
[13:20:25.501]                 }
[13:20:25.501]             }
[13:20:25.501]         }))
[13:20:25.501]     }, error = function(ex) {
[13:20:25.501]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.501]                 ...future.rng), started = ...future.startTime, 
[13:20:25.501]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.501]             version = "1.8"), class = "FutureResult")
[13:20:25.501]     }, finally = {
[13:20:25.501]         if (!identical(...future.workdir, getwd())) 
[13:20:25.501]             setwd(...future.workdir)
[13:20:25.501]         {
[13:20:25.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.501]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.501]             }
[13:20:25.501]             base::options(...future.oldOptions)
[13:20:25.501]             if (.Platform$OS.type == "windows") {
[13:20:25.501]                 old_names <- names(...future.oldEnvVars)
[13:20:25.501]                 envs <- base::Sys.getenv()
[13:20:25.501]                 names <- names(envs)
[13:20:25.501]                 common <- intersect(names, old_names)
[13:20:25.501]                 added <- setdiff(names, old_names)
[13:20:25.501]                 removed <- setdiff(old_names, names)
[13:20:25.501]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.501]                   envs[common]]
[13:20:25.501]                 NAMES <- toupper(changed)
[13:20:25.501]                 args <- list()
[13:20:25.501]                 for (kk in seq_along(NAMES)) {
[13:20:25.501]                   name <- changed[[kk]]
[13:20:25.501]                   NAME <- NAMES[[kk]]
[13:20:25.501]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.501]                     next
[13:20:25.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.501]                 }
[13:20:25.501]                 NAMES <- toupper(added)
[13:20:25.501]                 for (kk in seq_along(NAMES)) {
[13:20:25.501]                   name <- added[[kk]]
[13:20:25.501]                   NAME <- NAMES[[kk]]
[13:20:25.501]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.501]                     next
[13:20:25.501]                   args[[name]] <- ""
[13:20:25.501]                 }
[13:20:25.501]                 NAMES <- toupper(removed)
[13:20:25.501]                 for (kk in seq_along(NAMES)) {
[13:20:25.501]                   name <- removed[[kk]]
[13:20:25.501]                   NAME <- NAMES[[kk]]
[13:20:25.501]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.501]                     next
[13:20:25.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.501]                 }
[13:20:25.501]                 if (length(args) > 0) 
[13:20:25.501]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.501]             }
[13:20:25.501]             else {
[13:20:25.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.501]             }
[13:20:25.501]             {
[13:20:25.501]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.501]                   0L) {
[13:20:25.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.501]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.501]                   base::options(opts)
[13:20:25.501]                 }
[13:20:25.501]                 {
[13:20:25.501]                   {
[13:20:25.501]                     NULL
[13:20:25.501]                     RNGkind("Mersenne-Twister")
[13:20:25.501]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.501]                       inherits = FALSE)
[13:20:25.501]                   }
[13:20:25.501]                   options(future.plan = NULL)
[13:20:25.501]                   if (is.na(NA_character_)) 
[13:20:25.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.501]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.501]                   {
[13:20:25.501]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.501]                     if (!future$lazy) 
[13:20:25.501]                       future <- run(future)
[13:20:25.501]                     invisible(future)
[13:20:25.501]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.501]                 }
[13:20:25.501]             }
[13:20:25.501]         }
[13:20:25.501]     })
[13:20:25.501]     if (TRUE) {
[13:20:25.501]         base::sink(type = "output", split = FALSE)
[13:20:25.501]         if (TRUE) {
[13:20:25.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.501]         }
[13:20:25.501]         else {
[13:20:25.501]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.501]         }
[13:20:25.501]         base::close(...future.stdout)
[13:20:25.501]         ...future.stdout <- NULL
[13:20:25.501]     }
[13:20:25.501]     ...future.result$conditions <- ...future.conditions
[13:20:25.501]     ...future.result$finished <- base::Sys.time()
[13:20:25.501]     ...future.result
[13:20:25.501] }
[13:20:25.503] plan(): Setting new future strategy stack:
[13:20:25.503] List of future strategies:
[13:20:25.503] 1. sequential:
[13:20:25.503]    - args: function (..., envir = parent.frame())
[13:20:25.503]    - tweaked: FALSE
[13:20:25.503]    - call: NULL
[13:20:25.503] plan(): nbrOfWorkers() = 1
[13:20:25.504] plan(): Setting new future strategy stack:
[13:20:25.504] List of future strategies:
[13:20:25.504] 1. sequential:
[13:20:25.504]    - args: function (..., envir = parent.frame())
[13:20:25.504]    - tweaked: FALSE
[13:20:25.504]    - call: plan(strategy)
[13:20:25.505] plan(): nbrOfWorkers() = 1
[13:20:25.505] SequentialFuture started (and completed)
[13:20:25.505] - Launch lazy future ... done
[13:20:25.505] run() for ‘SequentialFuture’ ... done
[13:20:25.505] getGlobalsAndPackages() ...
[13:20:25.505] Searching for globals...
[13:20:25.506] 
[13:20:25.506] Searching for globals ... DONE
[13:20:25.506] - globals: [0] <none>
[13:20:25.506] getGlobalsAndPackages() ... DONE
[13:20:25.506] run() for ‘Future’ ...
[13:20:25.506] - state: ‘created’
[13:20:25.506] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.507] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.507]   - Field: ‘label’
[13:20:25.507]   - Field: ‘local’
[13:20:25.507]   - Field: ‘owner’
[13:20:25.507]   - Field: ‘envir’
[13:20:25.507]   - Field: ‘packages’
[13:20:25.507]   - Field: ‘gc’
[13:20:25.507]   - Field: ‘conditions’
[13:20:25.507]   - Field: ‘expr’
[13:20:25.508]   - Field: ‘uuid’
[13:20:25.508]   - Field: ‘seed’
[13:20:25.508]   - Field: ‘version’
[13:20:25.508]   - Field: ‘result’
[13:20:25.508]   - Field: ‘asynchronous’
[13:20:25.508]   - Field: ‘calls’
[13:20:25.508]   - Field: ‘globals’
[13:20:25.508]   - Field: ‘stdout’
[13:20:25.508]   - Field: ‘earlySignal’
[13:20:25.508]   - Field: ‘lazy’
[13:20:25.508]   - Field: ‘state’
[13:20:25.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.509] - Launch lazy future ...
[13:20:25.509] Packages needed by the future expression (n = 0): <none>
[13:20:25.509] Packages needed by future strategies (n = 0): <none>
[13:20:25.509] {
[13:20:25.509]     {
[13:20:25.509]         {
[13:20:25.509]             ...future.startTime <- base::Sys.time()
[13:20:25.509]             {
[13:20:25.509]                 {
[13:20:25.509]                   {
[13:20:25.509]                     base::local({
[13:20:25.509]                       has_future <- base::requireNamespace("future", 
[13:20:25.509]                         quietly = TRUE)
[13:20:25.509]                       if (has_future) {
[13:20:25.509]                         ns <- base::getNamespace("future")
[13:20:25.509]                         version <- ns[[".package"]][["version"]]
[13:20:25.509]                         if (is.null(version)) 
[13:20:25.509]                           version <- utils::packageVersion("future")
[13:20:25.509]                       }
[13:20:25.509]                       else {
[13:20:25.509]                         version <- NULL
[13:20:25.509]                       }
[13:20:25.509]                       if (!has_future || version < "1.8.0") {
[13:20:25.509]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.509]                           "", base::R.version$version.string), 
[13:20:25.509]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.509]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.509]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.509]                             "release", "version")], collapse = " "), 
[13:20:25.509]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.509]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.509]                           info)
[13:20:25.509]                         info <- base::paste(info, collapse = "; ")
[13:20:25.509]                         if (!has_future) {
[13:20:25.509]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.509]                             info)
[13:20:25.509]                         }
[13:20:25.509]                         else {
[13:20:25.509]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.509]                             info, version)
[13:20:25.509]                         }
[13:20:25.509]                         base::stop(msg)
[13:20:25.509]                       }
[13:20:25.509]                     })
[13:20:25.509]                   }
[13:20:25.509]                   options(future.plan = NULL)
[13:20:25.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.509]                 }
[13:20:25.509]                 ...future.workdir <- getwd()
[13:20:25.509]             }
[13:20:25.509]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.509]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.509]         }
[13:20:25.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.509]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.509]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.509]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.509]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.509]             base::names(...future.oldOptions))
[13:20:25.509]     }
[13:20:25.509]     if (FALSE) {
[13:20:25.509]     }
[13:20:25.509]     else {
[13:20:25.509]         if (TRUE) {
[13:20:25.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.509]                 open = "w")
[13:20:25.509]         }
[13:20:25.509]         else {
[13:20:25.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.509]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.509]         }
[13:20:25.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.509]             base::sink(type = "output", split = FALSE)
[13:20:25.509]             base::close(...future.stdout)
[13:20:25.509]         }, add = TRUE)
[13:20:25.509]     }
[13:20:25.509]     ...future.frame <- base::sys.nframe()
[13:20:25.509]     ...future.conditions <- base::list()
[13:20:25.509]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.509]     if (FALSE) {
[13:20:25.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.509]     }
[13:20:25.509]     ...future.result <- base::tryCatch({
[13:20:25.509]         base::withCallingHandlers({
[13:20:25.509]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.509]             future::FutureResult(value = ...future.value$value, 
[13:20:25.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.509]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.509]                     ...future.globalenv.names))
[13:20:25.509]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.509]         }, condition = base::local({
[13:20:25.509]             c <- base::c
[13:20:25.509]             inherits <- base::inherits
[13:20:25.509]             invokeRestart <- base::invokeRestart
[13:20:25.509]             length <- base::length
[13:20:25.509]             list <- base::list
[13:20:25.509]             seq.int <- base::seq.int
[13:20:25.509]             signalCondition <- base::signalCondition
[13:20:25.509]             sys.calls <- base::sys.calls
[13:20:25.509]             `[[` <- base::`[[`
[13:20:25.509]             `+` <- base::`+`
[13:20:25.509]             `<<-` <- base::`<<-`
[13:20:25.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.509]                   3L)]
[13:20:25.509]             }
[13:20:25.509]             function(cond) {
[13:20:25.509]                 is_error <- inherits(cond, "error")
[13:20:25.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.509]                   NULL)
[13:20:25.509]                 if (is_error) {
[13:20:25.509]                   sessionInformation <- function() {
[13:20:25.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.509]                       search = base::search(), system = base::Sys.info())
[13:20:25.509]                   }
[13:20:25.509]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.509]                     cond$call), session = sessionInformation(), 
[13:20:25.509]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.509]                   signalCondition(cond)
[13:20:25.509]                 }
[13:20:25.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.509]                 "immediateCondition"))) {
[13:20:25.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.509]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.509]                   if (TRUE && !signal) {
[13:20:25.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.509]                     {
[13:20:25.509]                       inherits <- base::inherits
[13:20:25.509]                       invokeRestart <- base::invokeRestart
[13:20:25.509]                       is.null <- base::is.null
[13:20:25.509]                       muffled <- FALSE
[13:20:25.509]                       if (inherits(cond, "message")) {
[13:20:25.509]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.509]                         if (muffled) 
[13:20:25.509]                           invokeRestart("muffleMessage")
[13:20:25.509]                       }
[13:20:25.509]                       else if (inherits(cond, "warning")) {
[13:20:25.509]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.509]                         if (muffled) 
[13:20:25.509]                           invokeRestart("muffleWarning")
[13:20:25.509]                       }
[13:20:25.509]                       else if (inherits(cond, "condition")) {
[13:20:25.509]                         if (!is.null(pattern)) {
[13:20:25.509]                           computeRestarts <- base::computeRestarts
[13:20:25.509]                           grepl <- base::grepl
[13:20:25.509]                           restarts <- computeRestarts(cond)
[13:20:25.509]                           for (restart in restarts) {
[13:20:25.509]                             name <- restart$name
[13:20:25.509]                             if (is.null(name)) 
[13:20:25.509]                               next
[13:20:25.509]                             if (!grepl(pattern, name)) 
[13:20:25.509]                               next
[13:20:25.509]                             invokeRestart(restart)
[13:20:25.509]                             muffled <- TRUE
[13:20:25.509]                             break
[13:20:25.509]                           }
[13:20:25.509]                         }
[13:20:25.509]                       }
[13:20:25.509]                       invisible(muffled)
[13:20:25.509]                     }
[13:20:25.509]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.509]                   }
[13:20:25.509]                 }
[13:20:25.509]                 else {
[13:20:25.509]                   if (TRUE) {
[13:20:25.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.509]                     {
[13:20:25.509]                       inherits <- base::inherits
[13:20:25.509]                       invokeRestart <- base::invokeRestart
[13:20:25.509]                       is.null <- base::is.null
[13:20:25.509]                       muffled <- FALSE
[13:20:25.509]                       if (inherits(cond, "message")) {
[13:20:25.509]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.509]                         if (muffled) 
[13:20:25.509]                           invokeRestart("muffleMessage")
[13:20:25.509]                       }
[13:20:25.509]                       else if (inherits(cond, "warning")) {
[13:20:25.509]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.509]                         if (muffled) 
[13:20:25.509]                           invokeRestart("muffleWarning")
[13:20:25.509]                       }
[13:20:25.509]                       else if (inherits(cond, "condition")) {
[13:20:25.509]                         if (!is.null(pattern)) {
[13:20:25.509]                           computeRestarts <- base::computeRestarts
[13:20:25.509]                           grepl <- base::grepl
[13:20:25.509]                           restarts <- computeRestarts(cond)
[13:20:25.509]                           for (restart in restarts) {
[13:20:25.509]                             name <- restart$name
[13:20:25.509]                             if (is.null(name)) 
[13:20:25.509]                               next
[13:20:25.509]                             if (!grepl(pattern, name)) 
[13:20:25.509]                               next
[13:20:25.509]                             invokeRestart(restart)
[13:20:25.509]                             muffled <- TRUE
[13:20:25.509]                             break
[13:20:25.509]                           }
[13:20:25.509]                         }
[13:20:25.509]                       }
[13:20:25.509]                       invisible(muffled)
[13:20:25.509]                     }
[13:20:25.509]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.509]                   }
[13:20:25.509]                 }
[13:20:25.509]             }
[13:20:25.509]         }))
[13:20:25.509]     }, error = function(ex) {
[13:20:25.509]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.509]                 ...future.rng), started = ...future.startTime, 
[13:20:25.509]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.509]             version = "1.8"), class = "FutureResult")
[13:20:25.509]     }, finally = {
[13:20:25.509]         if (!identical(...future.workdir, getwd())) 
[13:20:25.509]             setwd(...future.workdir)
[13:20:25.509]         {
[13:20:25.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.509]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.509]             }
[13:20:25.509]             base::options(...future.oldOptions)
[13:20:25.509]             if (.Platform$OS.type == "windows") {
[13:20:25.509]                 old_names <- names(...future.oldEnvVars)
[13:20:25.509]                 envs <- base::Sys.getenv()
[13:20:25.509]                 names <- names(envs)
[13:20:25.509]                 common <- intersect(names, old_names)
[13:20:25.509]                 added <- setdiff(names, old_names)
[13:20:25.509]                 removed <- setdiff(old_names, names)
[13:20:25.509]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.509]                   envs[common]]
[13:20:25.509]                 NAMES <- toupper(changed)
[13:20:25.509]                 args <- list()
[13:20:25.509]                 for (kk in seq_along(NAMES)) {
[13:20:25.509]                   name <- changed[[kk]]
[13:20:25.509]                   NAME <- NAMES[[kk]]
[13:20:25.509]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.509]                     next
[13:20:25.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.509]                 }
[13:20:25.509]                 NAMES <- toupper(added)
[13:20:25.509]                 for (kk in seq_along(NAMES)) {
[13:20:25.509]                   name <- added[[kk]]
[13:20:25.509]                   NAME <- NAMES[[kk]]
[13:20:25.509]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.509]                     next
[13:20:25.509]                   args[[name]] <- ""
[13:20:25.509]                 }
[13:20:25.509]                 NAMES <- toupper(removed)
[13:20:25.509]                 for (kk in seq_along(NAMES)) {
[13:20:25.509]                   name <- removed[[kk]]
[13:20:25.509]                   NAME <- NAMES[[kk]]
[13:20:25.509]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.509]                     next
[13:20:25.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.509]                 }
[13:20:25.509]                 if (length(args) > 0) 
[13:20:25.509]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.509]             }
[13:20:25.509]             else {
[13:20:25.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.509]             }
[13:20:25.509]             {
[13:20:25.509]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.509]                   0L) {
[13:20:25.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.509]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.509]                   base::options(opts)
[13:20:25.509]                 }
[13:20:25.509]                 {
[13:20:25.509]                   {
[13:20:25.509]                     NULL
[13:20:25.509]                     RNGkind("Mersenne-Twister")
[13:20:25.509]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.509]                       inherits = FALSE)
[13:20:25.509]                   }
[13:20:25.509]                   options(future.plan = NULL)
[13:20:25.509]                   if (is.na(NA_character_)) 
[13:20:25.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.509]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.509]                   {
[13:20:25.509]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.509]                     if (!future$lazy) 
[13:20:25.509]                       future <- run(future)
[13:20:25.509]                     invisible(future)
[13:20:25.509]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.509]                 }
[13:20:25.509]             }
[13:20:25.509]         }
[13:20:25.509]     })
[13:20:25.509]     if (TRUE) {
[13:20:25.509]         base::sink(type = "output", split = FALSE)
[13:20:25.509]         if (TRUE) {
[13:20:25.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.509]         }
[13:20:25.509]         else {
[13:20:25.509]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.509]         }
[13:20:25.509]         base::close(...future.stdout)
[13:20:25.509]         ...future.stdout <- NULL
[13:20:25.509]     }
[13:20:25.509]     ...future.result$conditions <- ...future.conditions
[13:20:25.509]     ...future.result$finished <- base::Sys.time()
[13:20:25.509]     ...future.result
[13:20:25.509] }
[13:20:25.511] plan(): Setting new future strategy stack:
[13:20:25.511] List of future strategies:
[13:20:25.511] 1. sequential:
[13:20:25.511]    - args: function (..., envir = parent.frame())
[13:20:25.511]    - tweaked: FALSE
[13:20:25.511]    - call: NULL
[13:20:25.512] plan(): nbrOfWorkers() = 1
[13:20:25.512] plan(): Setting new future strategy stack:
[13:20:25.512] List of future strategies:
[13:20:25.512] 1. sequential:
[13:20:25.512]    - args: function (..., envir = parent.frame())
[13:20:25.512]    - tweaked: FALSE
[13:20:25.512]    - call: plan(strategy)
[13:20:25.513] plan(): nbrOfWorkers() = 1
[13:20:25.513] SequentialFuture started (and completed)
[13:20:25.513] - Launch lazy future ... done
[13:20:25.513] run() for ‘SequentialFuture’ ... done
[13:20:25.514] getGlobalsAndPackages() ...
[13:20:25.514] Searching for globals...
[13:20:25.514] - globals found: [1] ‘{’
[13:20:25.514] Searching for globals ... DONE
[13:20:25.514] Resolving globals: FALSE
[13:20:25.515] 
[13:20:25.515] 
[13:20:25.515] getGlobalsAndPackages() ... DONE
[13:20:25.515] run() for ‘Future’ ...
[13:20:25.515] - state: ‘created’
[13:20:25.515] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.516] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.516] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.516]   - Field: ‘label’
[13:20:25.516]   - Field: ‘local’
[13:20:25.516]   - Field: ‘owner’
[13:20:25.516]   - Field: ‘envir’
[13:20:25.516]   - Field: ‘packages’
[13:20:25.516]   - Field: ‘gc’
[13:20:25.516]   - Field: ‘conditions’
[13:20:25.517]   - Field: ‘expr’
[13:20:25.517]   - Field: ‘uuid’
[13:20:25.518]   - Field: ‘seed’
[13:20:25.519]   - Field: ‘version’
[13:20:25.519]   - Field: ‘result’
[13:20:25.519]   - Field: ‘asynchronous’
[13:20:25.519]   - Field: ‘calls’
[13:20:25.519]   - Field: ‘globals’
[13:20:25.519]   - Field: ‘stdout’
[13:20:25.519]   - Field: ‘earlySignal’
[13:20:25.519]   - Field: ‘lazy’
[13:20:25.520]   - Field: ‘state’
[13:20:25.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.520] - Launch lazy future ...
[13:20:25.520] Packages needed by the future expression (n = 0): <none>
[13:20:25.520] Packages needed by future strategies (n = 0): <none>
[13:20:25.521] {
[13:20:25.521]     {
[13:20:25.521]         {
[13:20:25.521]             ...future.startTime <- base::Sys.time()
[13:20:25.521]             {
[13:20:25.521]                 {
[13:20:25.521]                   {
[13:20:25.521]                     base::local({
[13:20:25.521]                       has_future <- base::requireNamespace("future", 
[13:20:25.521]                         quietly = TRUE)
[13:20:25.521]                       if (has_future) {
[13:20:25.521]                         ns <- base::getNamespace("future")
[13:20:25.521]                         version <- ns[[".package"]][["version"]]
[13:20:25.521]                         if (is.null(version)) 
[13:20:25.521]                           version <- utils::packageVersion("future")
[13:20:25.521]                       }
[13:20:25.521]                       else {
[13:20:25.521]                         version <- NULL
[13:20:25.521]                       }
[13:20:25.521]                       if (!has_future || version < "1.8.0") {
[13:20:25.521]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.521]                           "", base::R.version$version.string), 
[13:20:25.521]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.521]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.521]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.521]                             "release", "version")], collapse = " "), 
[13:20:25.521]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.521]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.521]                           info)
[13:20:25.521]                         info <- base::paste(info, collapse = "; ")
[13:20:25.521]                         if (!has_future) {
[13:20:25.521]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.521]                             info)
[13:20:25.521]                         }
[13:20:25.521]                         else {
[13:20:25.521]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.521]                             info, version)
[13:20:25.521]                         }
[13:20:25.521]                         base::stop(msg)
[13:20:25.521]                       }
[13:20:25.521]                     })
[13:20:25.521]                   }
[13:20:25.521]                   options(future.plan = NULL)
[13:20:25.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.521]                 }
[13:20:25.521]                 ...future.workdir <- getwd()
[13:20:25.521]             }
[13:20:25.521]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.521]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.521]         }
[13:20:25.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.521]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.521]             base::names(...future.oldOptions))
[13:20:25.521]     }
[13:20:25.521]     if (FALSE) {
[13:20:25.521]     }
[13:20:25.521]     else {
[13:20:25.521]         if (TRUE) {
[13:20:25.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.521]                 open = "w")
[13:20:25.521]         }
[13:20:25.521]         else {
[13:20:25.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.521]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.521]         }
[13:20:25.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.521]             base::sink(type = "output", split = FALSE)
[13:20:25.521]             base::close(...future.stdout)
[13:20:25.521]         }, add = TRUE)
[13:20:25.521]     }
[13:20:25.521]     ...future.frame <- base::sys.nframe()
[13:20:25.521]     ...future.conditions <- base::list()
[13:20:25.521]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.521]     if (FALSE) {
[13:20:25.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.521]     }
[13:20:25.521]     ...future.result <- base::tryCatch({
[13:20:25.521]         base::withCallingHandlers({
[13:20:25.521]             ...future.value <- base::withVisible(base::local({
[13:20:25.521]                 4
[13:20:25.521]             }))
[13:20:25.521]             future::FutureResult(value = ...future.value$value, 
[13:20:25.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.521]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.521]                     ...future.globalenv.names))
[13:20:25.521]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.521]         }, condition = base::local({
[13:20:25.521]             c <- base::c
[13:20:25.521]             inherits <- base::inherits
[13:20:25.521]             invokeRestart <- base::invokeRestart
[13:20:25.521]             length <- base::length
[13:20:25.521]             list <- base::list
[13:20:25.521]             seq.int <- base::seq.int
[13:20:25.521]             signalCondition <- base::signalCondition
[13:20:25.521]             sys.calls <- base::sys.calls
[13:20:25.521]             `[[` <- base::`[[`
[13:20:25.521]             `+` <- base::`+`
[13:20:25.521]             `<<-` <- base::`<<-`
[13:20:25.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.521]                   3L)]
[13:20:25.521]             }
[13:20:25.521]             function(cond) {
[13:20:25.521]                 is_error <- inherits(cond, "error")
[13:20:25.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.521]                   NULL)
[13:20:25.521]                 if (is_error) {
[13:20:25.521]                   sessionInformation <- function() {
[13:20:25.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.521]                       search = base::search(), system = base::Sys.info())
[13:20:25.521]                   }
[13:20:25.521]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.521]                     cond$call), session = sessionInformation(), 
[13:20:25.521]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.521]                   signalCondition(cond)
[13:20:25.521]                 }
[13:20:25.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.521]                 "immediateCondition"))) {
[13:20:25.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.521]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.521]                   if (TRUE && !signal) {
[13:20:25.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.521]                     {
[13:20:25.521]                       inherits <- base::inherits
[13:20:25.521]                       invokeRestart <- base::invokeRestart
[13:20:25.521]                       is.null <- base::is.null
[13:20:25.521]                       muffled <- FALSE
[13:20:25.521]                       if (inherits(cond, "message")) {
[13:20:25.521]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.521]                         if (muffled) 
[13:20:25.521]                           invokeRestart("muffleMessage")
[13:20:25.521]                       }
[13:20:25.521]                       else if (inherits(cond, "warning")) {
[13:20:25.521]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.521]                         if (muffled) 
[13:20:25.521]                           invokeRestart("muffleWarning")
[13:20:25.521]                       }
[13:20:25.521]                       else if (inherits(cond, "condition")) {
[13:20:25.521]                         if (!is.null(pattern)) {
[13:20:25.521]                           computeRestarts <- base::computeRestarts
[13:20:25.521]                           grepl <- base::grepl
[13:20:25.521]                           restarts <- computeRestarts(cond)
[13:20:25.521]                           for (restart in restarts) {
[13:20:25.521]                             name <- restart$name
[13:20:25.521]                             if (is.null(name)) 
[13:20:25.521]                               next
[13:20:25.521]                             if (!grepl(pattern, name)) 
[13:20:25.521]                               next
[13:20:25.521]                             invokeRestart(restart)
[13:20:25.521]                             muffled <- TRUE
[13:20:25.521]                             break
[13:20:25.521]                           }
[13:20:25.521]                         }
[13:20:25.521]                       }
[13:20:25.521]                       invisible(muffled)
[13:20:25.521]                     }
[13:20:25.521]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.521]                   }
[13:20:25.521]                 }
[13:20:25.521]                 else {
[13:20:25.521]                   if (TRUE) {
[13:20:25.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.521]                     {
[13:20:25.521]                       inherits <- base::inherits
[13:20:25.521]                       invokeRestart <- base::invokeRestart
[13:20:25.521]                       is.null <- base::is.null
[13:20:25.521]                       muffled <- FALSE
[13:20:25.521]                       if (inherits(cond, "message")) {
[13:20:25.521]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.521]                         if (muffled) 
[13:20:25.521]                           invokeRestart("muffleMessage")
[13:20:25.521]                       }
[13:20:25.521]                       else if (inherits(cond, "warning")) {
[13:20:25.521]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.521]                         if (muffled) 
[13:20:25.521]                           invokeRestart("muffleWarning")
[13:20:25.521]                       }
[13:20:25.521]                       else if (inherits(cond, "condition")) {
[13:20:25.521]                         if (!is.null(pattern)) {
[13:20:25.521]                           computeRestarts <- base::computeRestarts
[13:20:25.521]                           grepl <- base::grepl
[13:20:25.521]                           restarts <- computeRestarts(cond)
[13:20:25.521]                           for (restart in restarts) {
[13:20:25.521]                             name <- restart$name
[13:20:25.521]                             if (is.null(name)) 
[13:20:25.521]                               next
[13:20:25.521]                             if (!grepl(pattern, name)) 
[13:20:25.521]                               next
[13:20:25.521]                             invokeRestart(restart)
[13:20:25.521]                             muffled <- TRUE
[13:20:25.521]                             break
[13:20:25.521]                           }
[13:20:25.521]                         }
[13:20:25.521]                       }
[13:20:25.521]                       invisible(muffled)
[13:20:25.521]                     }
[13:20:25.521]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.521]                   }
[13:20:25.521]                 }
[13:20:25.521]             }
[13:20:25.521]         }))
[13:20:25.521]     }, error = function(ex) {
[13:20:25.521]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.521]                 ...future.rng), started = ...future.startTime, 
[13:20:25.521]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.521]             version = "1.8"), class = "FutureResult")
[13:20:25.521]     }, finally = {
[13:20:25.521]         if (!identical(...future.workdir, getwd())) 
[13:20:25.521]             setwd(...future.workdir)
[13:20:25.521]         {
[13:20:25.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.521]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.521]             }
[13:20:25.521]             base::options(...future.oldOptions)
[13:20:25.521]             if (.Platform$OS.type == "windows") {
[13:20:25.521]                 old_names <- names(...future.oldEnvVars)
[13:20:25.521]                 envs <- base::Sys.getenv()
[13:20:25.521]                 names <- names(envs)
[13:20:25.521]                 common <- intersect(names, old_names)
[13:20:25.521]                 added <- setdiff(names, old_names)
[13:20:25.521]                 removed <- setdiff(old_names, names)
[13:20:25.521]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.521]                   envs[common]]
[13:20:25.521]                 NAMES <- toupper(changed)
[13:20:25.521]                 args <- list()
[13:20:25.521]                 for (kk in seq_along(NAMES)) {
[13:20:25.521]                   name <- changed[[kk]]
[13:20:25.521]                   NAME <- NAMES[[kk]]
[13:20:25.521]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.521]                     next
[13:20:25.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.521]                 }
[13:20:25.521]                 NAMES <- toupper(added)
[13:20:25.521]                 for (kk in seq_along(NAMES)) {
[13:20:25.521]                   name <- added[[kk]]
[13:20:25.521]                   NAME <- NAMES[[kk]]
[13:20:25.521]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.521]                     next
[13:20:25.521]                   args[[name]] <- ""
[13:20:25.521]                 }
[13:20:25.521]                 NAMES <- toupper(removed)
[13:20:25.521]                 for (kk in seq_along(NAMES)) {
[13:20:25.521]                   name <- removed[[kk]]
[13:20:25.521]                   NAME <- NAMES[[kk]]
[13:20:25.521]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.521]                     next
[13:20:25.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.521]                 }
[13:20:25.521]                 if (length(args) > 0) 
[13:20:25.521]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.521]             }
[13:20:25.521]             else {
[13:20:25.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.521]             }
[13:20:25.521]             {
[13:20:25.521]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.521]                   0L) {
[13:20:25.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.521]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.521]                   base::options(opts)
[13:20:25.521]                 }
[13:20:25.521]                 {
[13:20:25.521]                   {
[13:20:25.521]                     NULL
[13:20:25.521]                     RNGkind("Mersenne-Twister")
[13:20:25.521]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.521]                       inherits = FALSE)
[13:20:25.521]                   }
[13:20:25.521]                   options(future.plan = NULL)
[13:20:25.521]                   if (is.na(NA_character_)) 
[13:20:25.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.521]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.521]                   {
[13:20:25.521]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.521]                     if (!future$lazy) 
[13:20:25.521]                       future <- run(future)
[13:20:25.521]                     invisible(future)
[13:20:25.521]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.521]                 }
[13:20:25.521]             }
[13:20:25.521]         }
[13:20:25.521]     })
[13:20:25.521]     if (TRUE) {
[13:20:25.521]         base::sink(type = "output", split = FALSE)
[13:20:25.521]         if (TRUE) {
[13:20:25.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.521]         }
[13:20:25.521]         else {
[13:20:25.521]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.521]         }
[13:20:25.521]         base::close(...future.stdout)
[13:20:25.521]         ...future.stdout <- NULL
[13:20:25.521]     }
[13:20:25.521]     ...future.result$conditions <- ...future.conditions
[13:20:25.521]     ...future.result$finished <- base::Sys.time()
[13:20:25.521]     ...future.result
[13:20:25.521] }
[13:20:25.522] plan(): Setting new future strategy stack:
[13:20:25.522] List of future strategies:
[13:20:25.522] 1. sequential:
[13:20:25.522]    - args: function (..., envir = parent.frame())
[13:20:25.522]    - tweaked: FALSE
[13:20:25.522]    - call: NULL
[13:20:25.523] plan(): nbrOfWorkers() = 1
[13:20:25.524] plan(): Setting new future strategy stack:
[13:20:25.524] List of future strategies:
[13:20:25.524] 1. sequential:
[13:20:25.524]    - args: function (..., envir = parent.frame())
[13:20:25.524]    - tweaked: FALSE
[13:20:25.524]    - call: plan(strategy)
[13:20:25.524] plan(): nbrOfWorkers() = 1
[13:20:25.524] SequentialFuture started (and completed)
[13:20:25.524] - Launch lazy future ... done
[13:20:25.524] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x556599a6ab00> 
Classes 'listenv', 'environment' <environment: 0x55659a227358> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:20:25.528] resolved() for ‘SequentialFuture’ ...
[13:20:25.528] - state: ‘finished’
[13:20:25.529] - run: TRUE
[13:20:25.529] - result: ‘FutureResult’
[13:20:25.529] resolved() for ‘SequentialFuture’ ... done
[13:20:25.529] resolved() for ‘SequentialFuture’ ...
[13:20:25.529] - state: ‘finished’
[13:20:25.529] - run: TRUE
[13:20:25.529] - result: ‘FutureResult’
[13:20:25.529] resolved() for ‘SequentialFuture’ ... done
[13:20:25.529] resolved() for ‘SequentialFuture’ ...
[13:20:25.529] - state: ‘finished’
[13:20:25.530] - run: TRUE
[13:20:25.530] - result: ‘FutureResult’
[13:20:25.530] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:25.532] resolve() on list environment ...
[13:20:25.532]  recursive: 0
[13:20:25.533]  length: 6
[13:20:25.533]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:25.534] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.534] - nx: 6
[13:20:25.534] - relay: TRUE
[13:20:25.534] - stdout: TRUE
[13:20:25.534] - signal: TRUE
[13:20:25.534] - resignal: FALSE
[13:20:25.534] - force: TRUE
[13:20:25.534] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.534] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.534]  - until=2
[13:20:25.534]  - relaying element #2
[13:20:25.534] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.535] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.535] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.535]  length: 5 (resolved future 1)
[13:20:25.535] resolved() for ‘SequentialFuture’ ...
[13:20:25.535] - state: ‘finished’
[13:20:25.535] - run: TRUE
[13:20:25.535] - result: ‘FutureResult’
[13:20:25.535] resolved() for ‘SequentialFuture’ ... done
[13:20:25.535] Future #2
[13:20:25.536] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.536] - nx: 6
[13:20:25.536] - relay: TRUE
[13:20:25.536] - stdout: TRUE
[13:20:25.536] - signal: TRUE
[13:20:25.536] - resignal: FALSE
[13:20:25.536] - force: TRUE
[13:20:25.536] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.536] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.536]  - until=2
[13:20:25.536]  - relaying element #2
[13:20:25.537] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.537] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.537] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.537]  length: 4 (resolved future 2)
[13:20:25.537] resolved() for ‘SequentialFuture’ ...
[13:20:25.537] - state: ‘finished’
[13:20:25.537] - run: TRUE
[13:20:25.537] - result: ‘FutureResult’
[13:20:25.537] resolved() for ‘SequentialFuture’ ... done
[13:20:25.537] Future #3
[13:20:25.538] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.538] - nx: 6
[13:20:25.538] - relay: TRUE
[13:20:25.538] - stdout: TRUE
[13:20:25.538] - signal: TRUE
[13:20:25.538] - resignal: FALSE
[13:20:25.538] - force: TRUE
[13:20:25.538] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.538] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.538]  - until=3
[13:20:25.538]  - relaying element #3
[13:20:25.539] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.539] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.539] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.539]  length: 3 (resolved future 3)
[13:20:25.539] resolved() for ‘SequentialFuture’ ...
[13:20:25.539] - state: ‘finished’
[13:20:25.539] - run: TRUE
[13:20:25.539] - result: ‘FutureResult’
[13:20:25.539] resolved() for ‘SequentialFuture’ ... done
[13:20:25.539] Future #4
[13:20:25.540] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:20:25.540] - nx: 6
[13:20:25.540] - relay: TRUE
[13:20:25.540] - stdout: TRUE
[13:20:25.540] - signal: TRUE
[13:20:25.540] - resignal: FALSE
[13:20:25.540] - force: TRUE
[13:20:25.540] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.540] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.540]  - until=4
[13:20:25.540]  - relaying element #4
[13:20:25.541] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.541] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.541] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:20:25.541]  length: 2 (resolved future 4)
[13:20:25.541] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.541] - nx: 6
[13:20:25.541] - relay: TRUE
[13:20:25.541] - stdout: TRUE
[13:20:25.541] - signal: TRUE
[13:20:25.541] - resignal: FALSE
[13:20:25.542] - force: TRUE
[13:20:25.542] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.542] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.542]  - until=6
[13:20:25.542]  - relaying element #6
[13:20:25.542] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.542] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.542] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.542]  length: 1 (resolved future 5)
[13:20:25.542] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.542] - nx: 6
[13:20:25.543] - relay: TRUE
[13:20:25.543] - stdout: TRUE
[13:20:25.543] - signal: TRUE
[13:20:25.543] - resignal: FALSE
[13:20:25.543] - force: TRUE
[13:20:25.543] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.543] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.543]  - until=6
[13:20:25.543] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.543] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.545] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.545]  length: 0 (resolved future 6)
[13:20:25.545] Relaying remaining futures
[13:20:25.545] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.545] - nx: 6
[13:20:25.546] - relay: TRUE
[13:20:25.546] - stdout: TRUE
[13:20:25.546] - signal: TRUE
[13:20:25.546] - resignal: FALSE
[13:20:25.546] - force: TRUE
[13:20:25.546] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.546] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:25.546] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.546] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.546] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.547] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55659b6c3008> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:20:25.549] getGlobalsAndPackages() ...
[13:20:25.549] Searching for globals...
[13:20:25.549] 
[13:20:25.549] Searching for globals ... DONE
[13:20:25.549] - globals: [0] <none>
[13:20:25.549] getGlobalsAndPackages() ... DONE
[13:20:25.550] run() for ‘Future’ ...
[13:20:25.550] - state: ‘created’
[13:20:25.550] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.550] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.550] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.550]   - Field: ‘label’
[13:20:25.551]   - Field: ‘local’
[13:20:25.551]   - Field: ‘owner’
[13:20:25.551]   - Field: ‘envir’
[13:20:25.551]   - Field: ‘packages’
[13:20:25.551]   - Field: ‘gc’
[13:20:25.551]   - Field: ‘conditions’
[13:20:25.551]   - Field: ‘expr’
[13:20:25.551]   - Field: ‘uuid’
[13:20:25.551]   - Field: ‘seed’
[13:20:25.551]   - Field: ‘version’
[13:20:25.551]   - Field: ‘result’
[13:20:25.552]   - Field: ‘asynchronous’
[13:20:25.552]   - Field: ‘calls’
[13:20:25.552]   - Field: ‘globals’
[13:20:25.552]   - Field: ‘stdout’
[13:20:25.552]   - Field: ‘earlySignal’
[13:20:25.552]   - Field: ‘lazy’
[13:20:25.552]   - Field: ‘state’
[13:20:25.552] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.552] - Launch lazy future ...
[13:20:25.552] Packages needed by the future expression (n = 0): <none>
[13:20:25.553] Packages needed by future strategies (n = 0): <none>
[13:20:25.553] {
[13:20:25.553]     {
[13:20:25.553]         {
[13:20:25.553]             ...future.startTime <- base::Sys.time()
[13:20:25.553]             {
[13:20:25.553]                 {
[13:20:25.553]                   {
[13:20:25.553]                     base::local({
[13:20:25.553]                       has_future <- base::requireNamespace("future", 
[13:20:25.553]                         quietly = TRUE)
[13:20:25.553]                       if (has_future) {
[13:20:25.553]                         ns <- base::getNamespace("future")
[13:20:25.553]                         version <- ns[[".package"]][["version"]]
[13:20:25.553]                         if (is.null(version)) 
[13:20:25.553]                           version <- utils::packageVersion("future")
[13:20:25.553]                       }
[13:20:25.553]                       else {
[13:20:25.553]                         version <- NULL
[13:20:25.553]                       }
[13:20:25.553]                       if (!has_future || version < "1.8.0") {
[13:20:25.553]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.553]                           "", base::R.version$version.string), 
[13:20:25.553]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.553]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.553]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.553]                             "release", "version")], collapse = " "), 
[13:20:25.553]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.553]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.553]                           info)
[13:20:25.553]                         info <- base::paste(info, collapse = "; ")
[13:20:25.553]                         if (!has_future) {
[13:20:25.553]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.553]                             info)
[13:20:25.553]                         }
[13:20:25.553]                         else {
[13:20:25.553]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.553]                             info, version)
[13:20:25.553]                         }
[13:20:25.553]                         base::stop(msg)
[13:20:25.553]                       }
[13:20:25.553]                     })
[13:20:25.553]                   }
[13:20:25.553]                   options(future.plan = NULL)
[13:20:25.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.553]                 }
[13:20:25.553]                 ...future.workdir <- getwd()
[13:20:25.553]             }
[13:20:25.553]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.553]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.553]         }
[13:20:25.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.553]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.553]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.553]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.553]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.553]             base::names(...future.oldOptions))
[13:20:25.553]     }
[13:20:25.553]     if (FALSE) {
[13:20:25.553]     }
[13:20:25.553]     else {
[13:20:25.553]         if (TRUE) {
[13:20:25.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.553]                 open = "w")
[13:20:25.553]         }
[13:20:25.553]         else {
[13:20:25.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.553]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.553]         }
[13:20:25.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.553]             base::sink(type = "output", split = FALSE)
[13:20:25.553]             base::close(...future.stdout)
[13:20:25.553]         }, add = TRUE)
[13:20:25.553]     }
[13:20:25.553]     ...future.frame <- base::sys.nframe()
[13:20:25.553]     ...future.conditions <- base::list()
[13:20:25.553]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.553]     if (FALSE) {
[13:20:25.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.553]     }
[13:20:25.553]     ...future.result <- base::tryCatch({
[13:20:25.553]         base::withCallingHandlers({
[13:20:25.553]             ...future.value <- base::withVisible(base::local(2))
[13:20:25.553]             future::FutureResult(value = ...future.value$value, 
[13:20:25.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.553]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.553]                     ...future.globalenv.names))
[13:20:25.553]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.553]         }, condition = base::local({
[13:20:25.553]             c <- base::c
[13:20:25.553]             inherits <- base::inherits
[13:20:25.553]             invokeRestart <- base::invokeRestart
[13:20:25.553]             length <- base::length
[13:20:25.553]             list <- base::list
[13:20:25.553]             seq.int <- base::seq.int
[13:20:25.553]             signalCondition <- base::signalCondition
[13:20:25.553]             sys.calls <- base::sys.calls
[13:20:25.553]             `[[` <- base::`[[`
[13:20:25.553]             `+` <- base::`+`
[13:20:25.553]             `<<-` <- base::`<<-`
[13:20:25.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.553]                   3L)]
[13:20:25.553]             }
[13:20:25.553]             function(cond) {
[13:20:25.553]                 is_error <- inherits(cond, "error")
[13:20:25.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.553]                   NULL)
[13:20:25.553]                 if (is_error) {
[13:20:25.553]                   sessionInformation <- function() {
[13:20:25.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.553]                       search = base::search(), system = base::Sys.info())
[13:20:25.553]                   }
[13:20:25.553]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.553]                     cond$call), session = sessionInformation(), 
[13:20:25.553]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.553]                   signalCondition(cond)
[13:20:25.553]                 }
[13:20:25.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.553]                 "immediateCondition"))) {
[13:20:25.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.553]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.553]                   if (TRUE && !signal) {
[13:20:25.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.553]                     {
[13:20:25.553]                       inherits <- base::inherits
[13:20:25.553]                       invokeRestart <- base::invokeRestart
[13:20:25.553]                       is.null <- base::is.null
[13:20:25.553]                       muffled <- FALSE
[13:20:25.553]                       if (inherits(cond, "message")) {
[13:20:25.553]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.553]                         if (muffled) 
[13:20:25.553]                           invokeRestart("muffleMessage")
[13:20:25.553]                       }
[13:20:25.553]                       else if (inherits(cond, "warning")) {
[13:20:25.553]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.553]                         if (muffled) 
[13:20:25.553]                           invokeRestart("muffleWarning")
[13:20:25.553]                       }
[13:20:25.553]                       else if (inherits(cond, "condition")) {
[13:20:25.553]                         if (!is.null(pattern)) {
[13:20:25.553]                           computeRestarts <- base::computeRestarts
[13:20:25.553]                           grepl <- base::grepl
[13:20:25.553]                           restarts <- computeRestarts(cond)
[13:20:25.553]                           for (restart in restarts) {
[13:20:25.553]                             name <- restart$name
[13:20:25.553]                             if (is.null(name)) 
[13:20:25.553]                               next
[13:20:25.553]                             if (!grepl(pattern, name)) 
[13:20:25.553]                               next
[13:20:25.553]                             invokeRestart(restart)
[13:20:25.553]                             muffled <- TRUE
[13:20:25.553]                             break
[13:20:25.553]                           }
[13:20:25.553]                         }
[13:20:25.553]                       }
[13:20:25.553]                       invisible(muffled)
[13:20:25.553]                     }
[13:20:25.553]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.553]                   }
[13:20:25.553]                 }
[13:20:25.553]                 else {
[13:20:25.553]                   if (TRUE) {
[13:20:25.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.553]                     {
[13:20:25.553]                       inherits <- base::inherits
[13:20:25.553]                       invokeRestart <- base::invokeRestart
[13:20:25.553]                       is.null <- base::is.null
[13:20:25.553]                       muffled <- FALSE
[13:20:25.553]                       if (inherits(cond, "message")) {
[13:20:25.553]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.553]                         if (muffled) 
[13:20:25.553]                           invokeRestart("muffleMessage")
[13:20:25.553]                       }
[13:20:25.553]                       else if (inherits(cond, "warning")) {
[13:20:25.553]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.553]                         if (muffled) 
[13:20:25.553]                           invokeRestart("muffleWarning")
[13:20:25.553]                       }
[13:20:25.553]                       else if (inherits(cond, "condition")) {
[13:20:25.553]                         if (!is.null(pattern)) {
[13:20:25.553]                           computeRestarts <- base::computeRestarts
[13:20:25.553]                           grepl <- base::grepl
[13:20:25.553]                           restarts <- computeRestarts(cond)
[13:20:25.553]                           for (restart in restarts) {
[13:20:25.553]                             name <- restart$name
[13:20:25.553]                             if (is.null(name)) 
[13:20:25.553]                               next
[13:20:25.553]                             if (!grepl(pattern, name)) 
[13:20:25.553]                               next
[13:20:25.553]                             invokeRestart(restart)
[13:20:25.553]                             muffled <- TRUE
[13:20:25.553]                             break
[13:20:25.553]                           }
[13:20:25.553]                         }
[13:20:25.553]                       }
[13:20:25.553]                       invisible(muffled)
[13:20:25.553]                     }
[13:20:25.553]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.553]                   }
[13:20:25.553]                 }
[13:20:25.553]             }
[13:20:25.553]         }))
[13:20:25.553]     }, error = function(ex) {
[13:20:25.553]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.553]                 ...future.rng), started = ...future.startTime, 
[13:20:25.553]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.553]             version = "1.8"), class = "FutureResult")
[13:20:25.553]     }, finally = {
[13:20:25.553]         if (!identical(...future.workdir, getwd())) 
[13:20:25.553]             setwd(...future.workdir)
[13:20:25.553]         {
[13:20:25.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.553]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.553]             }
[13:20:25.553]             base::options(...future.oldOptions)
[13:20:25.553]             if (.Platform$OS.type == "windows") {
[13:20:25.553]                 old_names <- names(...future.oldEnvVars)
[13:20:25.553]                 envs <- base::Sys.getenv()
[13:20:25.553]                 names <- names(envs)
[13:20:25.553]                 common <- intersect(names, old_names)
[13:20:25.553]                 added <- setdiff(names, old_names)
[13:20:25.553]                 removed <- setdiff(old_names, names)
[13:20:25.553]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.553]                   envs[common]]
[13:20:25.553]                 NAMES <- toupper(changed)
[13:20:25.553]                 args <- list()
[13:20:25.553]                 for (kk in seq_along(NAMES)) {
[13:20:25.553]                   name <- changed[[kk]]
[13:20:25.553]                   NAME <- NAMES[[kk]]
[13:20:25.553]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.553]                     next
[13:20:25.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.553]                 }
[13:20:25.553]                 NAMES <- toupper(added)
[13:20:25.553]                 for (kk in seq_along(NAMES)) {
[13:20:25.553]                   name <- added[[kk]]
[13:20:25.553]                   NAME <- NAMES[[kk]]
[13:20:25.553]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.553]                     next
[13:20:25.553]                   args[[name]] <- ""
[13:20:25.553]                 }
[13:20:25.553]                 NAMES <- toupper(removed)
[13:20:25.553]                 for (kk in seq_along(NAMES)) {
[13:20:25.553]                   name <- removed[[kk]]
[13:20:25.553]                   NAME <- NAMES[[kk]]
[13:20:25.553]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.553]                     next
[13:20:25.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.553]                 }
[13:20:25.553]                 if (length(args) > 0) 
[13:20:25.553]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.553]             }
[13:20:25.553]             else {
[13:20:25.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.553]             }
[13:20:25.553]             {
[13:20:25.553]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.553]                   0L) {
[13:20:25.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.553]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.553]                   base::options(opts)
[13:20:25.553]                 }
[13:20:25.553]                 {
[13:20:25.553]                   {
[13:20:25.553]                     NULL
[13:20:25.553]                     RNGkind("Mersenne-Twister")
[13:20:25.553]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.553]                       inherits = FALSE)
[13:20:25.553]                   }
[13:20:25.553]                   options(future.plan = NULL)
[13:20:25.553]                   if (is.na(NA_character_)) 
[13:20:25.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.553]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.553]                   {
[13:20:25.553]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.553]                     if (!future$lazy) 
[13:20:25.553]                       future <- run(future)
[13:20:25.553]                     invisible(future)
[13:20:25.553]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.553]                 }
[13:20:25.553]             }
[13:20:25.553]         }
[13:20:25.553]     })
[13:20:25.553]     if (TRUE) {
[13:20:25.553]         base::sink(type = "output", split = FALSE)
[13:20:25.553]         if (TRUE) {
[13:20:25.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.553]         }
[13:20:25.553]         else {
[13:20:25.553]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.553]         }
[13:20:25.553]         base::close(...future.stdout)
[13:20:25.553]         ...future.stdout <- NULL
[13:20:25.553]     }
[13:20:25.553]     ...future.result$conditions <- ...future.conditions
[13:20:25.553]     ...future.result$finished <- base::Sys.time()
[13:20:25.553]     ...future.result
[13:20:25.553] }
[13:20:25.555] plan(): Setting new future strategy stack:
[13:20:25.555] List of future strategies:
[13:20:25.555] 1. sequential:
[13:20:25.555]    - args: function (..., envir = parent.frame())
[13:20:25.555]    - tweaked: FALSE
[13:20:25.555]    - call: NULL
[13:20:25.555] plan(): nbrOfWorkers() = 1
[13:20:25.556] plan(): Setting new future strategy stack:
[13:20:25.556] List of future strategies:
[13:20:25.556] 1. sequential:
[13:20:25.556]    - args: function (..., envir = parent.frame())
[13:20:25.556]    - tweaked: FALSE
[13:20:25.556]    - call: plan(strategy)
[13:20:25.556] plan(): nbrOfWorkers() = 1
[13:20:25.557] SequentialFuture started (and completed)
[13:20:25.557] - Launch lazy future ... done
[13:20:25.557] run() for ‘SequentialFuture’ ... done
[13:20:25.557] getGlobalsAndPackages() ...
[13:20:25.557] Searching for globals...
[13:20:25.557] 
[13:20:25.557] Searching for globals ... DONE
[13:20:25.558] - globals: [0] <none>
[13:20:25.558] getGlobalsAndPackages() ... DONE
[13:20:25.558] run() for ‘Future’ ...
[13:20:25.558] - state: ‘created’
[13:20:25.558] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.558] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.558] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.559]   - Field: ‘label’
[13:20:25.559]   - Field: ‘local’
[13:20:25.559]   - Field: ‘owner’
[13:20:25.559]   - Field: ‘envir’
[13:20:25.559]   - Field: ‘packages’
[13:20:25.559]   - Field: ‘gc’
[13:20:25.559]   - Field: ‘conditions’
[13:20:25.559]   - Field: ‘expr’
[13:20:25.559]   - Field: ‘uuid’
[13:20:25.559]   - Field: ‘seed’
[13:20:25.559]   - Field: ‘version’
[13:20:25.560]   - Field: ‘result’
[13:20:25.560]   - Field: ‘asynchronous’
[13:20:25.560]   - Field: ‘calls’
[13:20:25.560]   - Field: ‘globals’
[13:20:25.560]   - Field: ‘stdout’
[13:20:25.560]   - Field: ‘earlySignal’
[13:20:25.560]   - Field: ‘lazy’
[13:20:25.560]   - Field: ‘state’
[13:20:25.560] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.560] - Launch lazy future ...
[13:20:25.561] Packages needed by the future expression (n = 0): <none>
[13:20:25.561] Packages needed by future strategies (n = 0): <none>
[13:20:25.561] {
[13:20:25.561]     {
[13:20:25.561]         {
[13:20:25.561]             ...future.startTime <- base::Sys.time()
[13:20:25.561]             {
[13:20:25.561]                 {
[13:20:25.561]                   {
[13:20:25.561]                     base::local({
[13:20:25.561]                       has_future <- base::requireNamespace("future", 
[13:20:25.561]                         quietly = TRUE)
[13:20:25.561]                       if (has_future) {
[13:20:25.561]                         ns <- base::getNamespace("future")
[13:20:25.561]                         version <- ns[[".package"]][["version"]]
[13:20:25.561]                         if (is.null(version)) 
[13:20:25.561]                           version <- utils::packageVersion("future")
[13:20:25.561]                       }
[13:20:25.561]                       else {
[13:20:25.561]                         version <- NULL
[13:20:25.561]                       }
[13:20:25.561]                       if (!has_future || version < "1.8.0") {
[13:20:25.561]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.561]                           "", base::R.version$version.string), 
[13:20:25.561]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.561]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.561]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.561]                             "release", "version")], collapse = " "), 
[13:20:25.561]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.561]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.561]                           info)
[13:20:25.561]                         info <- base::paste(info, collapse = "; ")
[13:20:25.561]                         if (!has_future) {
[13:20:25.561]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.561]                             info)
[13:20:25.561]                         }
[13:20:25.561]                         else {
[13:20:25.561]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.561]                             info, version)
[13:20:25.561]                         }
[13:20:25.561]                         base::stop(msg)
[13:20:25.561]                       }
[13:20:25.561]                     })
[13:20:25.561]                   }
[13:20:25.561]                   options(future.plan = NULL)
[13:20:25.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.561]                 }
[13:20:25.561]                 ...future.workdir <- getwd()
[13:20:25.561]             }
[13:20:25.561]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.561]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.561]         }
[13:20:25.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.561]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.561]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.561]             base::names(...future.oldOptions))
[13:20:25.561]     }
[13:20:25.561]     if (FALSE) {
[13:20:25.561]     }
[13:20:25.561]     else {
[13:20:25.561]         if (TRUE) {
[13:20:25.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.561]                 open = "w")
[13:20:25.561]         }
[13:20:25.561]         else {
[13:20:25.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.561]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.561]         }
[13:20:25.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.561]             base::sink(type = "output", split = FALSE)
[13:20:25.561]             base::close(...future.stdout)
[13:20:25.561]         }, add = TRUE)
[13:20:25.561]     }
[13:20:25.561]     ...future.frame <- base::sys.nframe()
[13:20:25.561]     ...future.conditions <- base::list()
[13:20:25.561]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.561]     if (FALSE) {
[13:20:25.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.561]     }
[13:20:25.561]     ...future.result <- base::tryCatch({
[13:20:25.561]         base::withCallingHandlers({
[13:20:25.561]             ...future.value <- base::withVisible(base::local(NULL))
[13:20:25.561]             future::FutureResult(value = ...future.value$value, 
[13:20:25.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.561]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.561]                     ...future.globalenv.names))
[13:20:25.561]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.561]         }, condition = base::local({
[13:20:25.561]             c <- base::c
[13:20:25.561]             inherits <- base::inherits
[13:20:25.561]             invokeRestart <- base::invokeRestart
[13:20:25.561]             length <- base::length
[13:20:25.561]             list <- base::list
[13:20:25.561]             seq.int <- base::seq.int
[13:20:25.561]             signalCondition <- base::signalCondition
[13:20:25.561]             sys.calls <- base::sys.calls
[13:20:25.561]             `[[` <- base::`[[`
[13:20:25.561]             `+` <- base::`+`
[13:20:25.561]             `<<-` <- base::`<<-`
[13:20:25.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.561]                   3L)]
[13:20:25.561]             }
[13:20:25.561]             function(cond) {
[13:20:25.561]                 is_error <- inherits(cond, "error")
[13:20:25.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.561]                   NULL)
[13:20:25.561]                 if (is_error) {
[13:20:25.561]                   sessionInformation <- function() {
[13:20:25.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.561]                       search = base::search(), system = base::Sys.info())
[13:20:25.561]                   }
[13:20:25.561]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.561]                     cond$call), session = sessionInformation(), 
[13:20:25.561]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.561]                   signalCondition(cond)
[13:20:25.561]                 }
[13:20:25.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.561]                 "immediateCondition"))) {
[13:20:25.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.561]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.561]                   if (TRUE && !signal) {
[13:20:25.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.561]                     {
[13:20:25.561]                       inherits <- base::inherits
[13:20:25.561]                       invokeRestart <- base::invokeRestart
[13:20:25.561]                       is.null <- base::is.null
[13:20:25.561]                       muffled <- FALSE
[13:20:25.561]                       if (inherits(cond, "message")) {
[13:20:25.561]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.561]                         if (muffled) 
[13:20:25.561]                           invokeRestart("muffleMessage")
[13:20:25.561]                       }
[13:20:25.561]                       else if (inherits(cond, "warning")) {
[13:20:25.561]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.561]                         if (muffled) 
[13:20:25.561]                           invokeRestart("muffleWarning")
[13:20:25.561]                       }
[13:20:25.561]                       else if (inherits(cond, "condition")) {
[13:20:25.561]                         if (!is.null(pattern)) {
[13:20:25.561]                           computeRestarts <- base::computeRestarts
[13:20:25.561]                           grepl <- base::grepl
[13:20:25.561]                           restarts <- computeRestarts(cond)
[13:20:25.561]                           for (restart in restarts) {
[13:20:25.561]                             name <- restart$name
[13:20:25.561]                             if (is.null(name)) 
[13:20:25.561]                               next
[13:20:25.561]                             if (!grepl(pattern, name)) 
[13:20:25.561]                               next
[13:20:25.561]                             invokeRestart(restart)
[13:20:25.561]                             muffled <- TRUE
[13:20:25.561]                             break
[13:20:25.561]                           }
[13:20:25.561]                         }
[13:20:25.561]                       }
[13:20:25.561]                       invisible(muffled)
[13:20:25.561]                     }
[13:20:25.561]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.561]                   }
[13:20:25.561]                 }
[13:20:25.561]                 else {
[13:20:25.561]                   if (TRUE) {
[13:20:25.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.561]                     {
[13:20:25.561]                       inherits <- base::inherits
[13:20:25.561]                       invokeRestart <- base::invokeRestart
[13:20:25.561]                       is.null <- base::is.null
[13:20:25.561]                       muffled <- FALSE
[13:20:25.561]                       if (inherits(cond, "message")) {
[13:20:25.561]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.561]                         if (muffled) 
[13:20:25.561]                           invokeRestart("muffleMessage")
[13:20:25.561]                       }
[13:20:25.561]                       else if (inherits(cond, "warning")) {
[13:20:25.561]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.561]                         if (muffled) 
[13:20:25.561]                           invokeRestart("muffleWarning")
[13:20:25.561]                       }
[13:20:25.561]                       else if (inherits(cond, "condition")) {
[13:20:25.561]                         if (!is.null(pattern)) {
[13:20:25.561]                           computeRestarts <- base::computeRestarts
[13:20:25.561]                           grepl <- base::grepl
[13:20:25.561]                           restarts <- computeRestarts(cond)
[13:20:25.561]                           for (restart in restarts) {
[13:20:25.561]                             name <- restart$name
[13:20:25.561]                             if (is.null(name)) 
[13:20:25.561]                               next
[13:20:25.561]                             if (!grepl(pattern, name)) 
[13:20:25.561]                               next
[13:20:25.561]                             invokeRestart(restart)
[13:20:25.561]                             muffled <- TRUE
[13:20:25.561]                             break
[13:20:25.561]                           }
[13:20:25.561]                         }
[13:20:25.561]                       }
[13:20:25.561]                       invisible(muffled)
[13:20:25.561]                     }
[13:20:25.561]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.561]                   }
[13:20:25.561]                 }
[13:20:25.561]             }
[13:20:25.561]         }))
[13:20:25.561]     }, error = function(ex) {
[13:20:25.561]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.561]                 ...future.rng), started = ...future.startTime, 
[13:20:25.561]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.561]             version = "1.8"), class = "FutureResult")
[13:20:25.561]     }, finally = {
[13:20:25.561]         if (!identical(...future.workdir, getwd())) 
[13:20:25.561]             setwd(...future.workdir)
[13:20:25.561]         {
[13:20:25.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.561]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.561]             }
[13:20:25.561]             base::options(...future.oldOptions)
[13:20:25.561]             if (.Platform$OS.type == "windows") {
[13:20:25.561]                 old_names <- names(...future.oldEnvVars)
[13:20:25.561]                 envs <- base::Sys.getenv()
[13:20:25.561]                 names <- names(envs)
[13:20:25.561]                 common <- intersect(names, old_names)
[13:20:25.561]                 added <- setdiff(names, old_names)
[13:20:25.561]                 removed <- setdiff(old_names, names)
[13:20:25.561]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.561]                   envs[common]]
[13:20:25.561]                 NAMES <- toupper(changed)
[13:20:25.561]                 args <- list()
[13:20:25.561]                 for (kk in seq_along(NAMES)) {
[13:20:25.561]                   name <- changed[[kk]]
[13:20:25.561]                   NAME <- NAMES[[kk]]
[13:20:25.561]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.561]                     next
[13:20:25.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.561]                 }
[13:20:25.561]                 NAMES <- toupper(added)
[13:20:25.561]                 for (kk in seq_along(NAMES)) {
[13:20:25.561]                   name <- added[[kk]]
[13:20:25.561]                   NAME <- NAMES[[kk]]
[13:20:25.561]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.561]                     next
[13:20:25.561]                   args[[name]] <- ""
[13:20:25.561]                 }
[13:20:25.561]                 NAMES <- toupper(removed)
[13:20:25.561]                 for (kk in seq_along(NAMES)) {
[13:20:25.561]                   name <- removed[[kk]]
[13:20:25.561]                   NAME <- NAMES[[kk]]
[13:20:25.561]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.561]                     next
[13:20:25.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.561]                 }
[13:20:25.561]                 if (length(args) > 0) 
[13:20:25.561]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.561]             }
[13:20:25.561]             else {
[13:20:25.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.561]             }
[13:20:25.561]             {
[13:20:25.561]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.561]                   0L) {
[13:20:25.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.561]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.561]                   base::options(opts)
[13:20:25.561]                 }
[13:20:25.561]                 {
[13:20:25.561]                   {
[13:20:25.561]                     NULL
[13:20:25.561]                     RNGkind("Mersenne-Twister")
[13:20:25.561]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.561]                       inherits = FALSE)
[13:20:25.561]                   }
[13:20:25.561]                   options(future.plan = NULL)
[13:20:25.561]                   if (is.na(NA_character_)) 
[13:20:25.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.561]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.561]                   {
[13:20:25.561]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.561]                     if (!future$lazy) 
[13:20:25.561]                       future <- run(future)
[13:20:25.561]                     invisible(future)
[13:20:25.561]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.561]                 }
[13:20:25.561]             }
[13:20:25.561]         }
[13:20:25.561]     })
[13:20:25.561]     if (TRUE) {
[13:20:25.561]         base::sink(type = "output", split = FALSE)
[13:20:25.561]         if (TRUE) {
[13:20:25.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.561]         }
[13:20:25.561]         else {
[13:20:25.561]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.561]         }
[13:20:25.561]         base::close(...future.stdout)
[13:20:25.561]         ...future.stdout <- NULL
[13:20:25.561]     }
[13:20:25.561]     ...future.result$conditions <- ...future.conditions
[13:20:25.561]     ...future.result$finished <- base::Sys.time()
[13:20:25.561]     ...future.result
[13:20:25.561] }
[13:20:25.563] plan(): Setting new future strategy stack:
[13:20:25.563] List of future strategies:
[13:20:25.563] 1. sequential:
[13:20:25.563]    - args: function (..., envir = parent.frame())
[13:20:25.563]    - tweaked: FALSE
[13:20:25.563]    - call: NULL
[13:20:25.563] plan(): nbrOfWorkers() = 1
[13:20:25.564] plan(): Setting new future strategy stack:
[13:20:25.564] List of future strategies:
[13:20:25.564] 1. sequential:
[13:20:25.564]    - args: function (..., envir = parent.frame())
[13:20:25.564]    - tweaked: FALSE
[13:20:25.564]    - call: plan(strategy)
[13:20:25.564] plan(): nbrOfWorkers() = 1
[13:20:25.565] SequentialFuture started (and completed)
[13:20:25.565] - Launch lazy future ... done
[13:20:25.565] run() for ‘SequentialFuture’ ... done
[13:20:25.565] getGlobalsAndPackages() ...
[13:20:25.565] Searching for globals...
[13:20:25.566] - globals found: [1] ‘{’
[13:20:25.566] Searching for globals ... DONE
[13:20:25.566] Resolving globals: FALSE
[13:20:25.566] 
[13:20:25.566] 
[13:20:25.566] getGlobalsAndPackages() ... DONE
[13:20:25.567] run() for ‘Future’ ...
[13:20:25.567] - state: ‘created’
[13:20:25.567] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:25.567] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:25.567] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:25.567]   - Field: ‘label’
[13:20:25.567]   - Field: ‘local’
[13:20:25.568]   - Field: ‘owner’
[13:20:25.568]   - Field: ‘envir’
[13:20:25.568]   - Field: ‘packages’
[13:20:25.568]   - Field: ‘gc’
[13:20:25.568]   - Field: ‘conditions’
[13:20:25.568]   - Field: ‘expr’
[13:20:25.568]   - Field: ‘uuid’
[13:20:25.568]   - Field: ‘seed’
[13:20:25.568]   - Field: ‘version’
[13:20:25.568]   - Field: ‘result’
[13:20:25.569]   - Field: ‘asynchronous’
[13:20:25.569]   - Field: ‘calls’
[13:20:25.569]   - Field: ‘globals’
[13:20:25.569]   - Field: ‘stdout’
[13:20:25.569]   - Field: ‘earlySignal’
[13:20:25.569]   - Field: ‘lazy’
[13:20:25.569]   - Field: ‘state’
[13:20:25.569] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:25.569] - Launch lazy future ...
[13:20:25.569] Packages needed by the future expression (n = 0): <none>
[13:20:25.570] Packages needed by future strategies (n = 0): <none>
[13:20:25.570] {
[13:20:25.570]     {
[13:20:25.570]         {
[13:20:25.570]             ...future.startTime <- base::Sys.time()
[13:20:25.570]             {
[13:20:25.570]                 {
[13:20:25.570]                   {
[13:20:25.570]                     base::local({
[13:20:25.570]                       has_future <- base::requireNamespace("future", 
[13:20:25.570]                         quietly = TRUE)
[13:20:25.570]                       if (has_future) {
[13:20:25.570]                         ns <- base::getNamespace("future")
[13:20:25.570]                         version <- ns[[".package"]][["version"]]
[13:20:25.570]                         if (is.null(version)) 
[13:20:25.570]                           version <- utils::packageVersion("future")
[13:20:25.570]                       }
[13:20:25.570]                       else {
[13:20:25.570]                         version <- NULL
[13:20:25.570]                       }
[13:20:25.570]                       if (!has_future || version < "1.8.0") {
[13:20:25.570]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.570]                           "", base::R.version$version.string), 
[13:20:25.570]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:25.570]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.570]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.570]                             "release", "version")], collapse = " "), 
[13:20:25.570]                           hostname = base::Sys.info()[["nodename"]])
[13:20:25.570]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.570]                           info)
[13:20:25.570]                         info <- base::paste(info, collapse = "; ")
[13:20:25.570]                         if (!has_future) {
[13:20:25.570]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.570]                             info)
[13:20:25.570]                         }
[13:20:25.570]                         else {
[13:20:25.570]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.570]                             info, version)
[13:20:25.570]                         }
[13:20:25.570]                         base::stop(msg)
[13:20:25.570]                       }
[13:20:25.570]                     })
[13:20:25.570]                   }
[13:20:25.570]                   options(future.plan = NULL)
[13:20:25.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.570]                 }
[13:20:25.570]                 ...future.workdir <- getwd()
[13:20:25.570]             }
[13:20:25.570]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.570]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.570]         }
[13:20:25.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.570]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.570]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.570]             base::names(...future.oldOptions))
[13:20:25.570]     }
[13:20:25.570]     if (FALSE) {
[13:20:25.570]     }
[13:20:25.570]     else {
[13:20:25.570]         if (TRUE) {
[13:20:25.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.570]                 open = "w")
[13:20:25.570]         }
[13:20:25.570]         else {
[13:20:25.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.570]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.570]         }
[13:20:25.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.570]             base::sink(type = "output", split = FALSE)
[13:20:25.570]             base::close(...future.stdout)
[13:20:25.570]         }, add = TRUE)
[13:20:25.570]     }
[13:20:25.570]     ...future.frame <- base::sys.nframe()
[13:20:25.570]     ...future.conditions <- base::list()
[13:20:25.570]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.570]     if (FALSE) {
[13:20:25.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.570]     }
[13:20:25.570]     ...future.result <- base::tryCatch({
[13:20:25.570]         base::withCallingHandlers({
[13:20:25.570]             ...future.value <- base::withVisible(base::local({
[13:20:25.570]                 4
[13:20:25.570]             }))
[13:20:25.570]             future::FutureResult(value = ...future.value$value, 
[13:20:25.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.570]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.570]                     ...future.globalenv.names))
[13:20:25.570]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.570]         }, condition = base::local({
[13:20:25.570]             c <- base::c
[13:20:25.570]             inherits <- base::inherits
[13:20:25.570]             invokeRestart <- base::invokeRestart
[13:20:25.570]             length <- base::length
[13:20:25.570]             list <- base::list
[13:20:25.570]             seq.int <- base::seq.int
[13:20:25.570]             signalCondition <- base::signalCondition
[13:20:25.570]             sys.calls <- base::sys.calls
[13:20:25.570]             `[[` <- base::`[[`
[13:20:25.570]             `+` <- base::`+`
[13:20:25.570]             `<<-` <- base::`<<-`
[13:20:25.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.570]                   3L)]
[13:20:25.570]             }
[13:20:25.570]             function(cond) {
[13:20:25.570]                 is_error <- inherits(cond, "error")
[13:20:25.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.570]                   NULL)
[13:20:25.570]                 if (is_error) {
[13:20:25.570]                   sessionInformation <- function() {
[13:20:25.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.570]                       search = base::search(), system = base::Sys.info())
[13:20:25.570]                   }
[13:20:25.570]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.570]                     cond$call), session = sessionInformation(), 
[13:20:25.570]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.570]                   signalCondition(cond)
[13:20:25.570]                 }
[13:20:25.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.570]                 "immediateCondition"))) {
[13:20:25.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.570]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.570]                   if (TRUE && !signal) {
[13:20:25.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.570]                     {
[13:20:25.570]                       inherits <- base::inherits
[13:20:25.570]                       invokeRestart <- base::invokeRestart
[13:20:25.570]                       is.null <- base::is.null
[13:20:25.570]                       muffled <- FALSE
[13:20:25.570]                       if (inherits(cond, "message")) {
[13:20:25.570]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.570]                         if (muffled) 
[13:20:25.570]                           invokeRestart("muffleMessage")
[13:20:25.570]                       }
[13:20:25.570]                       else if (inherits(cond, "warning")) {
[13:20:25.570]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.570]                         if (muffled) 
[13:20:25.570]                           invokeRestart("muffleWarning")
[13:20:25.570]                       }
[13:20:25.570]                       else if (inherits(cond, "condition")) {
[13:20:25.570]                         if (!is.null(pattern)) {
[13:20:25.570]                           computeRestarts <- base::computeRestarts
[13:20:25.570]                           grepl <- base::grepl
[13:20:25.570]                           restarts <- computeRestarts(cond)
[13:20:25.570]                           for (restart in restarts) {
[13:20:25.570]                             name <- restart$name
[13:20:25.570]                             if (is.null(name)) 
[13:20:25.570]                               next
[13:20:25.570]                             if (!grepl(pattern, name)) 
[13:20:25.570]                               next
[13:20:25.570]                             invokeRestart(restart)
[13:20:25.570]                             muffled <- TRUE
[13:20:25.570]                             break
[13:20:25.570]                           }
[13:20:25.570]                         }
[13:20:25.570]                       }
[13:20:25.570]                       invisible(muffled)
[13:20:25.570]                     }
[13:20:25.570]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.570]                   }
[13:20:25.570]                 }
[13:20:25.570]                 else {
[13:20:25.570]                   if (TRUE) {
[13:20:25.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.570]                     {
[13:20:25.570]                       inherits <- base::inherits
[13:20:25.570]                       invokeRestart <- base::invokeRestart
[13:20:25.570]                       is.null <- base::is.null
[13:20:25.570]                       muffled <- FALSE
[13:20:25.570]                       if (inherits(cond, "message")) {
[13:20:25.570]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.570]                         if (muffled) 
[13:20:25.570]                           invokeRestart("muffleMessage")
[13:20:25.570]                       }
[13:20:25.570]                       else if (inherits(cond, "warning")) {
[13:20:25.570]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.570]                         if (muffled) 
[13:20:25.570]                           invokeRestart("muffleWarning")
[13:20:25.570]                       }
[13:20:25.570]                       else if (inherits(cond, "condition")) {
[13:20:25.570]                         if (!is.null(pattern)) {
[13:20:25.570]                           computeRestarts <- base::computeRestarts
[13:20:25.570]                           grepl <- base::grepl
[13:20:25.570]                           restarts <- computeRestarts(cond)
[13:20:25.570]                           for (restart in restarts) {
[13:20:25.570]                             name <- restart$name
[13:20:25.570]                             if (is.null(name)) 
[13:20:25.570]                               next
[13:20:25.570]                             if (!grepl(pattern, name)) 
[13:20:25.570]                               next
[13:20:25.570]                             invokeRestart(restart)
[13:20:25.570]                             muffled <- TRUE
[13:20:25.570]                             break
[13:20:25.570]                           }
[13:20:25.570]                         }
[13:20:25.570]                       }
[13:20:25.570]                       invisible(muffled)
[13:20:25.570]                     }
[13:20:25.570]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.570]                   }
[13:20:25.570]                 }
[13:20:25.570]             }
[13:20:25.570]         }))
[13:20:25.570]     }, error = function(ex) {
[13:20:25.570]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.570]                 ...future.rng), started = ...future.startTime, 
[13:20:25.570]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.570]             version = "1.8"), class = "FutureResult")
[13:20:25.570]     }, finally = {
[13:20:25.570]         if (!identical(...future.workdir, getwd())) 
[13:20:25.570]             setwd(...future.workdir)
[13:20:25.570]         {
[13:20:25.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.570]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.570]             }
[13:20:25.570]             base::options(...future.oldOptions)
[13:20:25.570]             if (.Platform$OS.type == "windows") {
[13:20:25.570]                 old_names <- names(...future.oldEnvVars)
[13:20:25.570]                 envs <- base::Sys.getenv()
[13:20:25.570]                 names <- names(envs)
[13:20:25.570]                 common <- intersect(names, old_names)
[13:20:25.570]                 added <- setdiff(names, old_names)
[13:20:25.570]                 removed <- setdiff(old_names, names)
[13:20:25.570]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.570]                   envs[common]]
[13:20:25.570]                 NAMES <- toupper(changed)
[13:20:25.570]                 args <- list()
[13:20:25.570]                 for (kk in seq_along(NAMES)) {
[13:20:25.570]                   name <- changed[[kk]]
[13:20:25.570]                   NAME <- NAMES[[kk]]
[13:20:25.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.570]                     next
[13:20:25.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.570]                 }
[13:20:25.570]                 NAMES <- toupper(added)
[13:20:25.570]                 for (kk in seq_along(NAMES)) {
[13:20:25.570]                   name <- added[[kk]]
[13:20:25.570]                   NAME <- NAMES[[kk]]
[13:20:25.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.570]                     next
[13:20:25.570]                   args[[name]] <- ""
[13:20:25.570]                 }
[13:20:25.570]                 NAMES <- toupper(removed)
[13:20:25.570]                 for (kk in seq_along(NAMES)) {
[13:20:25.570]                   name <- removed[[kk]]
[13:20:25.570]                   NAME <- NAMES[[kk]]
[13:20:25.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.570]                     next
[13:20:25.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.570]                 }
[13:20:25.570]                 if (length(args) > 0) 
[13:20:25.570]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.570]             }
[13:20:25.570]             else {
[13:20:25.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.570]             }
[13:20:25.570]             {
[13:20:25.570]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.570]                   0L) {
[13:20:25.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.570]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.570]                   base::options(opts)
[13:20:25.570]                 }
[13:20:25.570]                 {
[13:20:25.570]                   {
[13:20:25.570]                     NULL
[13:20:25.570]                     RNGkind("Mersenne-Twister")
[13:20:25.570]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:25.570]                       inherits = FALSE)
[13:20:25.570]                   }
[13:20:25.570]                   options(future.plan = NULL)
[13:20:25.570]                   if (is.na(NA_character_)) 
[13:20:25.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.570]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:25.570]                   {
[13:20:25.570]                     future <- SequentialFuture(..., envir = envir)
[13:20:25.570]                     if (!future$lazy) 
[13:20:25.570]                       future <- run(future)
[13:20:25.570]                     invisible(future)
[13:20:25.570]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.570]                 }
[13:20:25.570]             }
[13:20:25.570]         }
[13:20:25.570]     })
[13:20:25.570]     if (TRUE) {
[13:20:25.570]         base::sink(type = "output", split = FALSE)
[13:20:25.570]         if (TRUE) {
[13:20:25.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.570]         }
[13:20:25.570]         else {
[13:20:25.570]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.570]         }
[13:20:25.570]         base::close(...future.stdout)
[13:20:25.570]         ...future.stdout <- NULL
[13:20:25.570]     }
[13:20:25.570]     ...future.result$conditions <- ...future.conditions
[13:20:25.570]     ...future.result$finished <- base::Sys.time()
[13:20:25.570]     ...future.result
[13:20:25.570] }
[13:20:25.572] plan(): Setting new future strategy stack:
[13:20:25.572] List of future strategies:
[13:20:25.572] 1. sequential:
[13:20:25.572]    - args: function (..., envir = parent.frame())
[13:20:25.572]    - tweaked: FALSE
[13:20:25.572]    - call: NULL
[13:20:25.572] plan(): nbrOfWorkers() = 1
[13:20:25.573] plan(): Setting new future strategy stack:
[13:20:25.573] List of future strategies:
[13:20:25.573] 1. sequential:
[13:20:25.573]    - args: function (..., envir = parent.frame())
[13:20:25.573]    - tweaked: FALSE
[13:20:25.573]    - call: plan(strategy)
[13:20:25.574] plan(): nbrOfWorkers() = 1
[13:20:25.574] SequentialFuture started (and completed)
[13:20:25.574] - Launch lazy future ... done
[13:20:25.574] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55659a6634b0> 
Classes 'listenv', 'environment' <environment: 0x55659c1cc038> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:20:25.580] resolved() for ‘SequentialFuture’ ...
[13:20:25.581] - state: ‘finished’
[13:20:25.581] - run: TRUE
[13:20:25.581] - result: ‘FutureResult’
[13:20:25.581] resolved() for ‘SequentialFuture’ ... done
[13:20:25.581] resolved() for ‘SequentialFuture’ ...
[13:20:25.581] - state: ‘finished’
[13:20:25.581] - run: TRUE
[13:20:25.581] - result: ‘FutureResult’
[13:20:25.581] resolved() for ‘SequentialFuture’ ... done
[13:20:25.581] resolved() for ‘SequentialFuture’ ...
[13:20:25.582] - state: ‘finished’
[13:20:25.582] - run: TRUE
[13:20:25.582] - result: ‘FutureResult’
[13:20:25.582] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:25.585] resolve() on list environment ...
[13:20:25.585]  recursive: 0
[13:20:25.586]  length: 6
[13:20:25.586]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:25.586] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.586] - nx: 6
[13:20:25.586] - relay: TRUE
[13:20:25.586] - stdout: TRUE
[13:20:25.586] - signal: TRUE
[13:20:25.586] - resignal: FALSE
[13:20:25.586] - force: TRUE
[13:20:25.587] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.587] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.587]  - until=2
[13:20:25.587]  - relaying element #2
[13:20:25.587] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.587] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.587] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.587]  length: 5 (resolved future 1)
[13:20:25.587] resolved() for ‘SequentialFuture’ ...
[13:20:25.587] - state: ‘finished’
[13:20:25.588] - run: TRUE
[13:20:25.588] - result: ‘FutureResult’
[13:20:25.588] resolved() for ‘SequentialFuture’ ... done
[13:20:25.588] Future #2
[13:20:25.588] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:20:25.588] - nx: 6
[13:20:25.588] - relay: TRUE
[13:20:25.588] - stdout: TRUE
[13:20:25.588] - signal: TRUE
[13:20:25.588] - resignal: FALSE
[13:20:25.589] - force: TRUE
[13:20:25.589] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.589] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.589]  - until=2
[13:20:25.589]  - relaying element #2
[13:20:25.589] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.589] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.589] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:20:25.589]  length: 4 (resolved future 2)
[13:20:25.590] resolved() for ‘SequentialFuture’ ...
[13:20:25.590] - state: ‘finished’
[13:20:25.590] - run: TRUE
[13:20:25.590] - result: ‘FutureResult’
[13:20:25.590] resolved() for ‘SequentialFuture’ ... done
[13:20:25.590] Future #3
[13:20:25.590] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:20:25.590] - nx: 6
[13:20:25.590] - relay: TRUE
[13:20:25.590] - stdout: TRUE
[13:20:25.590] - signal: TRUE
[13:20:25.591] - resignal: FALSE
[13:20:25.591] - force: TRUE
[13:20:25.591] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.591] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.591]  - until=3
[13:20:25.591]  - relaying element #3
[13:20:25.591] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.591] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.591] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:20:25.591]  length: 3 (resolved future 3)
[13:20:25.592] resolved() for ‘SequentialFuture’ ...
[13:20:25.592] - state: ‘finished’
[13:20:25.592] - run: TRUE
[13:20:25.592] - result: ‘FutureResult’
[13:20:25.592] resolved() for ‘SequentialFuture’ ... done
[13:20:25.592] Future #4
[13:20:25.592] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:20:25.592] - nx: 6
[13:20:25.592] - relay: TRUE
[13:20:25.592] - stdout: TRUE
[13:20:25.593] - signal: TRUE
[13:20:25.593] - resignal: FALSE
[13:20:25.593] - force: TRUE
[13:20:25.593] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.593] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.593]  - until=4
[13:20:25.593]  - relaying element #4
[13:20:25.593] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.593] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.593] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:20:25.594]  length: 2 (resolved future 4)
[13:20:25.594] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.594] - nx: 6
[13:20:25.594] - relay: TRUE
[13:20:25.594] - stdout: TRUE
[13:20:25.594] - signal: TRUE
[13:20:25.594] - resignal: FALSE
[13:20:25.594] - force: TRUE
[13:20:25.594] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.594] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.594]  - until=6
[13:20:25.595]  - relaying element #6
[13:20:25.595] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.595] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.595] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.595]  length: 1 (resolved future 5)
[13:20:25.595] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.595] - nx: 6
[13:20:25.595] - relay: TRUE
[13:20:25.595] - stdout: TRUE
[13:20:25.595] - signal: TRUE
[13:20:25.595] - resignal: FALSE
[13:20:25.595] - force: TRUE
[13:20:25.596] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.596] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.596]  - until=6
[13:20:25.596] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.596] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.596] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.596]  length: 0 (resolved future 6)
[13:20:25.596] Relaying remaining futures
[13:20:25.596] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.596] - nx: 6
[13:20:25.596] - relay: TRUE
[13:20:25.597] - stdout: TRUE
[13:20:25.597] - signal: TRUE
[13:20:25.597] - resignal: FALSE
[13:20:25.597] - force: TRUE
[13:20:25.597] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.597] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:25.597] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.597] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.597] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.597] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55659b43a950> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[13:20:25.602] plan(): Setting new future strategy stack:
[13:20:25.603] List of future strategies:
[13:20:25.603] 1. multicore:
[13:20:25.603]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:25.603]    - tweaked: FALSE
[13:20:25.603]    - call: plan(strategy)
[13:20:25.607] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:20:25.607] getGlobalsAndPackages() ...
[13:20:25.607] Searching for globals...
[13:20:25.607] 
[13:20:25.608] Searching for globals ... DONE
[13:20:25.608] - globals: [0] <none>
[13:20:25.608] getGlobalsAndPackages() ... DONE
[13:20:25.608] run() for ‘Future’ ...
[13:20:25.608] - state: ‘created’
[13:20:25.608] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:25.612] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:25.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:25.612]   - Field: ‘label’
[13:20:25.612]   - Field: ‘local’
[13:20:25.612]   - Field: ‘owner’
[13:20:25.612]   - Field: ‘envir’
[13:20:25.612]   - Field: ‘workers’
[13:20:25.613]   - Field: ‘packages’
[13:20:25.613]   - Field: ‘gc’
[13:20:25.613]   - Field: ‘job’
[13:20:25.613]   - Field: ‘conditions’
[13:20:25.613]   - Field: ‘expr’
[13:20:25.613]   - Field: ‘uuid’
[13:20:25.613]   - Field: ‘seed’
[13:20:25.613]   - Field: ‘version’
[13:20:25.613]   - Field: ‘result’
[13:20:25.613]   - Field: ‘asynchronous’
[13:20:25.614]   - Field: ‘calls’
[13:20:25.614]   - Field: ‘globals’
[13:20:25.614]   - Field: ‘stdout’
[13:20:25.614]   - Field: ‘earlySignal’
[13:20:25.614]   - Field: ‘lazy’
[13:20:25.614]   - Field: ‘state’
[13:20:25.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:25.614] - Launch lazy future ...
[13:20:25.615] Packages needed by the future expression (n = 0): <none>
[13:20:25.615] Packages needed by future strategies (n = 0): <none>
[13:20:25.616] {
[13:20:25.616]     {
[13:20:25.616]         {
[13:20:25.616]             ...future.startTime <- base::Sys.time()
[13:20:25.616]             {
[13:20:25.616]                 {
[13:20:25.616]                   {
[13:20:25.616]                     {
[13:20:25.616]                       base::local({
[13:20:25.616]                         has_future <- base::requireNamespace("future", 
[13:20:25.616]                           quietly = TRUE)
[13:20:25.616]                         if (has_future) {
[13:20:25.616]                           ns <- base::getNamespace("future")
[13:20:25.616]                           version <- ns[[".package"]][["version"]]
[13:20:25.616]                           if (is.null(version)) 
[13:20:25.616]                             version <- utils::packageVersion("future")
[13:20:25.616]                         }
[13:20:25.616]                         else {
[13:20:25.616]                           version <- NULL
[13:20:25.616]                         }
[13:20:25.616]                         if (!has_future || version < "1.8.0") {
[13:20:25.616]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.616]                             "", base::R.version$version.string), 
[13:20:25.616]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:25.616]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.616]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.616]                               "release", "version")], collapse = " "), 
[13:20:25.616]                             hostname = base::Sys.info()[["nodename"]])
[13:20:25.616]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.616]                             info)
[13:20:25.616]                           info <- base::paste(info, collapse = "; ")
[13:20:25.616]                           if (!has_future) {
[13:20:25.616]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.616]                               info)
[13:20:25.616]                           }
[13:20:25.616]                           else {
[13:20:25.616]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.616]                               info, version)
[13:20:25.616]                           }
[13:20:25.616]                           base::stop(msg)
[13:20:25.616]                         }
[13:20:25.616]                       })
[13:20:25.616]                     }
[13:20:25.616]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:25.616]                     base::options(mc.cores = 1L)
[13:20:25.616]                   }
[13:20:25.616]                   options(future.plan = NULL)
[13:20:25.616]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.616]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.616]                 }
[13:20:25.616]                 ...future.workdir <- getwd()
[13:20:25.616]             }
[13:20:25.616]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.616]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.616]         }
[13:20:25.616]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.616]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.616]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.616]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.616]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.616]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.616]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.616]             base::names(...future.oldOptions))
[13:20:25.616]     }
[13:20:25.616]     if (FALSE) {
[13:20:25.616]     }
[13:20:25.616]     else {
[13:20:25.616]         if (TRUE) {
[13:20:25.616]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.616]                 open = "w")
[13:20:25.616]         }
[13:20:25.616]         else {
[13:20:25.616]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.616]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.616]         }
[13:20:25.616]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.616]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.616]             base::sink(type = "output", split = FALSE)
[13:20:25.616]             base::close(...future.stdout)
[13:20:25.616]         }, add = TRUE)
[13:20:25.616]     }
[13:20:25.616]     ...future.frame <- base::sys.nframe()
[13:20:25.616]     ...future.conditions <- base::list()
[13:20:25.616]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.616]     if (FALSE) {
[13:20:25.616]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.616]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.616]     }
[13:20:25.616]     ...future.result <- base::tryCatch({
[13:20:25.616]         base::withCallingHandlers({
[13:20:25.616]             ...future.value <- base::withVisible(base::local({
[13:20:25.616]                 withCallingHandlers({
[13:20:25.616]                   2
[13:20:25.616]                 }, immediateCondition = function(cond) {
[13:20:25.616]                   save_rds <- function (object, pathname, ...) 
[13:20:25.616]                   {
[13:20:25.616]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:25.616]                     if (file_test("-f", pathname_tmp)) {
[13:20:25.616]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.616]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:25.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.616]                         fi_tmp[["mtime"]])
[13:20:25.616]                     }
[13:20:25.616]                     tryCatch({
[13:20:25.616]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:25.616]                     }, error = function(ex) {
[13:20:25.616]                       msg <- conditionMessage(ex)
[13:20:25.616]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.616]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:25.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.616]                         fi_tmp[["mtime"]], msg)
[13:20:25.616]                       ex$message <- msg
[13:20:25.616]                       stop(ex)
[13:20:25.616]                     })
[13:20:25.616]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:25.616]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:25.616]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:25.616]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.616]                       fi <- file.info(pathname)
[13:20:25.616]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:25.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.616]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:25.616]                         fi[["size"]], fi[["mtime"]])
[13:20:25.616]                       stop(msg)
[13:20:25.616]                     }
[13:20:25.616]                     invisible(pathname)
[13:20:25.616]                   }
[13:20:25.616]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:25.616]                     rootPath = tempdir()) 
[13:20:25.616]                   {
[13:20:25.616]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:25.616]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:25.616]                       tmpdir = path, fileext = ".rds")
[13:20:25.616]                     save_rds(obj, file)
[13:20:25.616]                   }
[13:20:25.616]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:25.616]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.616]                   {
[13:20:25.616]                     inherits <- base::inherits
[13:20:25.616]                     invokeRestart <- base::invokeRestart
[13:20:25.616]                     is.null <- base::is.null
[13:20:25.616]                     muffled <- FALSE
[13:20:25.616]                     if (inherits(cond, "message")) {
[13:20:25.616]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:25.616]                       if (muffled) 
[13:20:25.616]                         invokeRestart("muffleMessage")
[13:20:25.616]                     }
[13:20:25.616]                     else if (inherits(cond, "warning")) {
[13:20:25.616]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:25.616]                       if (muffled) 
[13:20:25.616]                         invokeRestart("muffleWarning")
[13:20:25.616]                     }
[13:20:25.616]                     else if (inherits(cond, "condition")) {
[13:20:25.616]                       if (!is.null(pattern)) {
[13:20:25.616]                         computeRestarts <- base::computeRestarts
[13:20:25.616]                         grepl <- base::grepl
[13:20:25.616]                         restarts <- computeRestarts(cond)
[13:20:25.616]                         for (restart in restarts) {
[13:20:25.616]                           name <- restart$name
[13:20:25.616]                           if (is.null(name)) 
[13:20:25.616]                             next
[13:20:25.616]                           if (!grepl(pattern, name)) 
[13:20:25.616]                             next
[13:20:25.616]                           invokeRestart(restart)
[13:20:25.616]                           muffled <- TRUE
[13:20:25.616]                           break
[13:20:25.616]                         }
[13:20:25.616]                       }
[13:20:25.616]                     }
[13:20:25.616]                     invisible(muffled)
[13:20:25.616]                   }
[13:20:25.616]                   muffleCondition(cond)
[13:20:25.616]                 })
[13:20:25.616]             }))
[13:20:25.616]             future::FutureResult(value = ...future.value$value, 
[13:20:25.616]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.616]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.616]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.616]                     ...future.globalenv.names))
[13:20:25.616]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.616]         }, condition = base::local({
[13:20:25.616]             c <- base::c
[13:20:25.616]             inherits <- base::inherits
[13:20:25.616]             invokeRestart <- base::invokeRestart
[13:20:25.616]             length <- base::length
[13:20:25.616]             list <- base::list
[13:20:25.616]             seq.int <- base::seq.int
[13:20:25.616]             signalCondition <- base::signalCondition
[13:20:25.616]             sys.calls <- base::sys.calls
[13:20:25.616]             `[[` <- base::`[[`
[13:20:25.616]             `+` <- base::`+`
[13:20:25.616]             `<<-` <- base::`<<-`
[13:20:25.616]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.616]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.616]                   3L)]
[13:20:25.616]             }
[13:20:25.616]             function(cond) {
[13:20:25.616]                 is_error <- inherits(cond, "error")
[13:20:25.616]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.616]                   NULL)
[13:20:25.616]                 if (is_error) {
[13:20:25.616]                   sessionInformation <- function() {
[13:20:25.616]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.616]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.616]                       search = base::search(), system = base::Sys.info())
[13:20:25.616]                   }
[13:20:25.616]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.616]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.616]                     cond$call), session = sessionInformation(), 
[13:20:25.616]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.616]                   signalCondition(cond)
[13:20:25.616]                 }
[13:20:25.616]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.616]                 "immediateCondition"))) {
[13:20:25.616]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.616]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.616]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.616]                   if (TRUE && !signal) {
[13:20:25.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.616]                     {
[13:20:25.616]                       inherits <- base::inherits
[13:20:25.616]                       invokeRestart <- base::invokeRestart
[13:20:25.616]                       is.null <- base::is.null
[13:20:25.616]                       muffled <- FALSE
[13:20:25.616]                       if (inherits(cond, "message")) {
[13:20:25.616]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.616]                         if (muffled) 
[13:20:25.616]                           invokeRestart("muffleMessage")
[13:20:25.616]                       }
[13:20:25.616]                       else if (inherits(cond, "warning")) {
[13:20:25.616]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.616]                         if (muffled) 
[13:20:25.616]                           invokeRestart("muffleWarning")
[13:20:25.616]                       }
[13:20:25.616]                       else if (inherits(cond, "condition")) {
[13:20:25.616]                         if (!is.null(pattern)) {
[13:20:25.616]                           computeRestarts <- base::computeRestarts
[13:20:25.616]                           grepl <- base::grepl
[13:20:25.616]                           restarts <- computeRestarts(cond)
[13:20:25.616]                           for (restart in restarts) {
[13:20:25.616]                             name <- restart$name
[13:20:25.616]                             if (is.null(name)) 
[13:20:25.616]                               next
[13:20:25.616]                             if (!grepl(pattern, name)) 
[13:20:25.616]                               next
[13:20:25.616]                             invokeRestart(restart)
[13:20:25.616]                             muffled <- TRUE
[13:20:25.616]                             break
[13:20:25.616]                           }
[13:20:25.616]                         }
[13:20:25.616]                       }
[13:20:25.616]                       invisible(muffled)
[13:20:25.616]                     }
[13:20:25.616]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.616]                   }
[13:20:25.616]                 }
[13:20:25.616]                 else {
[13:20:25.616]                   if (TRUE) {
[13:20:25.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.616]                     {
[13:20:25.616]                       inherits <- base::inherits
[13:20:25.616]                       invokeRestart <- base::invokeRestart
[13:20:25.616]                       is.null <- base::is.null
[13:20:25.616]                       muffled <- FALSE
[13:20:25.616]                       if (inherits(cond, "message")) {
[13:20:25.616]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.616]                         if (muffled) 
[13:20:25.616]                           invokeRestart("muffleMessage")
[13:20:25.616]                       }
[13:20:25.616]                       else if (inherits(cond, "warning")) {
[13:20:25.616]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.616]                         if (muffled) 
[13:20:25.616]                           invokeRestart("muffleWarning")
[13:20:25.616]                       }
[13:20:25.616]                       else if (inherits(cond, "condition")) {
[13:20:25.616]                         if (!is.null(pattern)) {
[13:20:25.616]                           computeRestarts <- base::computeRestarts
[13:20:25.616]                           grepl <- base::grepl
[13:20:25.616]                           restarts <- computeRestarts(cond)
[13:20:25.616]                           for (restart in restarts) {
[13:20:25.616]                             name <- restart$name
[13:20:25.616]                             if (is.null(name)) 
[13:20:25.616]                               next
[13:20:25.616]                             if (!grepl(pattern, name)) 
[13:20:25.616]                               next
[13:20:25.616]                             invokeRestart(restart)
[13:20:25.616]                             muffled <- TRUE
[13:20:25.616]                             break
[13:20:25.616]                           }
[13:20:25.616]                         }
[13:20:25.616]                       }
[13:20:25.616]                       invisible(muffled)
[13:20:25.616]                     }
[13:20:25.616]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.616]                   }
[13:20:25.616]                 }
[13:20:25.616]             }
[13:20:25.616]         }))
[13:20:25.616]     }, error = function(ex) {
[13:20:25.616]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.616]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.616]                 ...future.rng), started = ...future.startTime, 
[13:20:25.616]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.616]             version = "1.8"), class = "FutureResult")
[13:20:25.616]     }, finally = {
[13:20:25.616]         if (!identical(...future.workdir, getwd())) 
[13:20:25.616]             setwd(...future.workdir)
[13:20:25.616]         {
[13:20:25.616]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.616]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.616]             }
[13:20:25.616]             base::options(...future.oldOptions)
[13:20:25.616]             if (.Platform$OS.type == "windows") {
[13:20:25.616]                 old_names <- names(...future.oldEnvVars)
[13:20:25.616]                 envs <- base::Sys.getenv()
[13:20:25.616]                 names <- names(envs)
[13:20:25.616]                 common <- intersect(names, old_names)
[13:20:25.616]                 added <- setdiff(names, old_names)
[13:20:25.616]                 removed <- setdiff(old_names, names)
[13:20:25.616]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.616]                   envs[common]]
[13:20:25.616]                 NAMES <- toupper(changed)
[13:20:25.616]                 args <- list()
[13:20:25.616]                 for (kk in seq_along(NAMES)) {
[13:20:25.616]                   name <- changed[[kk]]
[13:20:25.616]                   NAME <- NAMES[[kk]]
[13:20:25.616]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.616]                     next
[13:20:25.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.616]                 }
[13:20:25.616]                 NAMES <- toupper(added)
[13:20:25.616]                 for (kk in seq_along(NAMES)) {
[13:20:25.616]                   name <- added[[kk]]
[13:20:25.616]                   NAME <- NAMES[[kk]]
[13:20:25.616]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.616]                     next
[13:20:25.616]                   args[[name]] <- ""
[13:20:25.616]                 }
[13:20:25.616]                 NAMES <- toupper(removed)
[13:20:25.616]                 for (kk in seq_along(NAMES)) {
[13:20:25.616]                   name <- removed[[kk]]
[13:20:25.616]                   NAME <- NAMES[[kk]]
[13:20:25.616]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.616]                     next
[13:20:25.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.616]                 }
[13:20:25.616]                 if (length(args) > 0) 
[13:20:25.616]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.616]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.616]             }
[13:20:25.616]             else {
[13:20:25.616]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.616]             }
[13:20:25.616]             {
[13:20:25.616]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.616]                   0L) {
[13:20:25.616]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.616]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.616]                   base::options(opts)
[13:20:25.616]                 }
[13:20:25.616]                 {
[13:20:25.616]                   {
[13:20:25.616]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:25.616]                     NULL
[13:20:25.616]                   }
[13:20:25.616]                   options(future.plan = NULL)
[13:20:25.616]                   if (is.na(NA_character_)) 
[13:20:25.616]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.616]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.616]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:25.616]                     envir = parent.frame()) 
[13:20:25.616]                   {
[13:20:25.616]                     default_workers <- missing(workers)
[13:20:25.616]                     if (is.function(workers)) 
[13:20:25.616]                       workers <- workers()
[13:20:25.616]                     workers <- structure(as.integer(workers), 
[13:20:25.616]                       class = class(workers))
[13:20:25.616]                     stop_if_not(is.finite(workers), workers >= 
[13:20:25.616]                       1L)
[13:20:25.616]                     if ((workers == 1L && !inherits(workers, 
[13:20:25.616]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:25.616]                       if (default_workers) 
[13:20:25.616]                         supportsMulticore(warn = TRUE)
[13:20:25.616]                       return(sequential(..., envir = envir))
[13:20:25.616]                     }
[13:20:25.616]                     oopts <- options(mc.cores = workers)
[13:20:25.616]                     on.exit(options(oopts))
[13:20:25.616]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:25.616]                       envir = envir)
[13:20:25.616]                     if (!future$lazy) 
[13:20:25.616]                       future <- run(future)
[13:20:25.616]                     invisible(future)
[13:20:25.616]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.616]                 }
[13:20:25.616]             }
[13:20:25.616]         }
[13:20:25.616]     })
[13:20:25.616]     if (TRUE) {
[13:20:25.616]         base::sink(type = "output", split = FALSE)
[13:20:25.616]         if (TRUE) {
[13:20:25.616]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.616]         }
[13:20:25.616]         else {
[13:20:25.616]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.616]         }
[13:20:25.616]         base::close(...future.stdout)
[13:20:25.616]         ...future.stdout <- NULL
[13:20:25.616]     }
[13:20:25.616]     ...future.result$conditions <- ...future.conditions
[13:20:25.616]     ...future.result$finished <- base::Sys.time()
[13:20:25.616]     ...future.result
[13:20:25.616] }
[13:20:25.618] requestCore(): workers = 2
[13:20:25.621] MulticoreFuture started
[13:20:25.622] - Launch lazy future ... done
[13:20:25.622] plan(): Setting new future strategy stack:
[13:20:25.622] run() for ‘MulticoreFuture’ ... done
[13:20:25.623] getGlobalsAndPackages() ...
[13:20:25.623] Searching for globals...
[13:20:25.622] List of future strategies:
[13:20:25.622] 1. sequential:
[13:20:25.622]    - args: function (..., envir = parent.frame())
[13:20:25.622]    - tweaked: FALSE
[13:20:25.622]    - call: NULL
[13:20:25.623] plan(): nbrOfWorkers() = 1
[13:20:25.624] 
[13:20:25.624] Searching for globals ... DONE
[13:20:25.624] - globals: [0] <none>
[13:20:25.625] getGlobalsAndPackages() ... DONE
[13:20:25.625] plan(): Setting new future strategy stack:
[13:20:25.625] run() for ‘Future’ ...
[13:20:25.626] - state: ‘created’
[13:20:25.625] List of future strategies:
[13:20:25.625] 1. multicore:
[13:20:25.625]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:25.625]    - tweaked: FALSE
[13:20:25.625]    - call: plan(strategy)
[13:20:25.626] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:25.630] plan(): nbrOfWorkers() = 2
[13:20:25.630] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:25.631] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:25.631]   - Field: ‘label’
[13:20:25.631]   - Field: ‘local’
[13:20:25.631]   - Field: ‘owner’
[13:20:25.631]   - Field: ‘envir’
[13:20:25.632]   - Field: ‘workers’
[13:20:25.632]   - Field: ‘packages’
[13:20:25.632]   - Field: ‘gc’
[13:20:25.632]   - Field: ‘job’
[13:20:25.632]   - Field: ‘conditions’
[13:20:25.632]   - Field: ‘expr’
[13:20:25.632]   - Field: ‘uuid’
[13:20:25.633]   - Field: ‘seed’
[13:20:25.633]   - Field: ‘version’
[13:20:25.633]   - Field: ‘result’
[13:20:25.633]   - Field: ‘asynchronous’
[13:20:25.633]   - Field: ‘calls’
[13:20:25.633]   - Field: ‘globals’
[13:20:25.634]   - Field: ‘stdout’
[13:20:25.634]   - Field: ‘earlySignal’
[13:20:25.634]   - Field: ‘lazy’
[13:20:25.634]   - Field: ‘state’
[13:20:25.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:25.634] - Launch lazy future ...
[13:20:25.635] Packages needed by the future expression (n = 0): <none>
[13:20:25.635] Packages needed by future strategies (n = 0): <none>
[13:20:25.636] {
[13:20:25.636]     {
[13:20:25.636]         {
[13:20:25.636]             ...future.startTime <- base::Sys.time()
[13:20:25.636]             {
[13:20:25.636]                 {
[13:20:25.636]                   {
[13:20:25.636]                     {
[13:20:25.636]                       base::local({
[13:20:25.636]                         has_future <- base::requireNamespace("future", 
[13:20:25.636]                           quietly = TRUE)
[13:20:25.636]                         if (has_future) {
[13:20:25.636]                           ns <- base::getNamespace("future")
[13:20:25.636]                           version <- ns[[".package"]][["version"]]
[13:20:25.636]                           if (is.null(version)) 
[13:20:25.636]                             version <- utils::packageVersion("future")
[13:20:25.636]                         }
[13:20:25.636]                         else {
[13:20:25.636]                           version <- NULL
[13:20:25.636]                         }
[13:20:25.636]                         if (!has_future || version < "1.8.0") {
[13:20:25.636]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.636]                             "", base::R.version$version.string), 
[13:20:25.636]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:25.636]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.636]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.636]                               "release", "version")], collapse = " "), 
[13:20:25.636]                             hostname = base::Sys.info()[["nodename"]])
[13:20:25.636]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.636]                             info)
[13:20:25.636]                           info <- base::paste(info, collapse = "; ")
[13:20:25.636]                           if (!has_future) {
[13:20:25.636]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.636]                               info)
[13:20:25.636]                           }
[13:20:25.636]                           else {
[13:20:25.636]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.636]                               info, version)
[13:20:25.636]                           }
[13:20:25.636]                           base::stop(msg)
[13:20:25.636]                         }
[13:20:25.636]                       })
[13:20:25.636]                     }
[13:20:25.636]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:25.636]                     base::options(mc.cores = 1L)
[13:20:25.636]                   }
[13:20:25.636]                   options(future.plan = NULL)
[13:20:25.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.636]                 }
[13:20:25.636]                 ...future.workdir <- getwd()
[13:20:25.636]             }
[13:20:25.636]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.636]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.636]         }
[13:20:25.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.636]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.636]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.636]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.636]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.636]             base::names(...future.oldOptions))
[13:20:25.636]     }
[13:20:25.636]     if (FALSE) {
[13:20:25.636]     }
[13:20:25.636]     else {
[13:20:25.636]         if (TRUE) {
[13:20:25.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.636]                 open = "w")
[13:20:25.636]         }
[13:20:25.636]         else {
[13:20:25.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.636]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.636]         }
[13:20:25.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.636]             base::sink(type = "output", split = FALSE)
[13:20:25.636]             base::close(...future.stdout)
[13:20:25.636]         }, add = TRUE)
[13:20:25.636]     }
[13:20:25.636]     ...future.frame <- base::sys.nframe()
[13:20:25.636]     ...future.conditions <- base::list()
[13:20:25.636]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.636]     if (FALSE) {
[13:20:25.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.636]     }
[13:20:25.636]     ...future.result <- base::tryCatch({
[13:20:25.636]         base::withCallingHandlers({
[13:20:25.636]             ...future.value <- base::withVisible(base::local({
[13:20:25.636]                 withCallingHandlers({
[13:20:25.636]                   NULL
[13:20:25.636]                 }, immediateCondition = function(cond) {
[13:20:25.636]                   save_rds <- function (object, pathname, ...) 
[13:20:25.636]                   {
[13:20:25.636]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:25.636]                     if (file_test("-f", pathname_tmp)) {
[13:20:25.636]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.636]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:25.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.636]                         fi_tmp[["mtime"]])
[13:20:25.636]                     }
[13:20:25.636]                     tryCatch({
[13:20:25.636]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:25.636]                     }, error = function(ex) {
[13:20:25.636]                       msg <- conditionMessage(ex)
[13:20:25.636]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.636]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:25.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.636]                         fi_tmp[["mtime"]], msg)
[13:20:25.636]                       ex$message <- msg
[13:20:25.636]                       stop(ex)
[13:20:25.636]                     })
[13:20:25.636]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:25.636]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:25.636]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:25.636]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.636]                       fi <- file.info(pathname)
[13:20:25.636]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:25.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.636]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:25.636]                         fi[["size"]], fi[["mtime"]])
[13:20:25.636]                       stop(msg)
[13:20:25.636]                     }
[13:20:25.636]                     invisible(pathname)
[13:20:25.636]                   }
[13:20:25.636]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:25.636]                     rootPath = tempdir()) 
[13:20:25.636]                   {
[13:20:25.636]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:25.636]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:25.636]                       tmpdir = path, fileext = ".rds")
[13:20:25.636]                     save_rds(obj, file)
[13:20:25.636]                   }
[13:20:25.636]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:25.636]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.636]                   {
[13:20:25.636]                     inherits <- base::inherits
[13:20:25.636]                     invokeRestart <- base::invokeRestart
[13:20:25.636]                     is.null <- base::is.null
[13:20:25.636]                     muffled <- FALSE
[13:20:25.636]                     if (inherits(cond, "message")) {
[13:20:25.636]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:25.636]                       if (muffled) 
[13:20:25.636]                         invokeRestart("muffleMessage")
[13:20:25.636]                     }
[13:20:25.636]                     else if (inherits(cond, "warning")) {
[13:20:25.636]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:25.636]                       if (muffled) 
[13:20:25.636]                         invokeRestart("muffleWarning")
[13:20:25.636]                     }
[13:20:25.636]                     else if (inherits(cond, "condition")) {
[13:20:25.636]                       if (!is.null(pattern)) {
[13:20:25.636]                         computeRestarts <- base::computeRestarts
[13:20:25.636]                         grepl <- base::grepl
[13:20:25.636]                         restarts <- computeRestarts(cond)
[13:20:25.636]                         for (restart in restarts) {
[13:20:25.636]                           name <- restart$name
[13:20:25.636]                           if (is.null(name)) 
[13:20:25.636]                             next
[13:20:25.636]                           if (!grepl(pattern, name)) 
[13:20:25.636]                             next
[13:20:25.636]                           invokeRestart(restart)
[13:20:25.636]                           muffled <- TRUE
[13:20:25.636]                           break
[13:20:25.636]                         }
[13:20:25.636]                       }
[13:20:25.636]                     }
[13:20:25.636]                     invisible(muffled)
[13:20:25.636]                   }
[13:20:25.636]                   muffleCondition(cond)
[13:20:25.636]                 })
[13:20:25.636]             }))
[13:20:25.636]             future::FutureResult(value = ...future.value$value, 
[13:20:25.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.636]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.636]                     ...future.globalenv.names))
[13:20:25.636]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.636]         }, condition = base::local({
[13:20:25.636]             c <- base::c
[13:20:25.636]             inherits <- base::inherits
[13:20:25.636]             invokeRestart <- base::invokeRestart
[13:20:25.636]             length <- base::length
[13:20:25.636]             list <- base::list
[13:20:25.636]             seq.int <- base::seq.int
[13:20:25.636]             signalCondition <- base::signalCondition
[13:20:25.636]             sys.calls <- base::sys.calls
[13:20:25.636]             `[[` <- base::`[[`
[13:20:25.636]             `+` <- base::`+`
[13:20:25.636]             `<<-` <- base::`<<-`
[13:20:25.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.636]                   3L)]
[13:20:25.636]             }
[13:20:25.636]             function(cond) {
[13:20:25.636]                 is_error <- inherits(cond, "error")
[13:20:25.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.636]                   NULL)
[13:20:25.636]                 if (is_error) {
[13:20:25.636]                   sessionInformation <- function() {
[13:20:25.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.636]                       search = base::search(), system = base::Sys.info())
[13:20:25.636]                   }
[13:20:25.636]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.636]                     cond$call), session = sessionInformation(), 
[13:20:25.636]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.636]                   signalCondition(cond)
[13:20:25.636]                 }
[13:20:25.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.636]                 "immediateCondition"))) {
[13:20:25.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.636]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.636]                   if (TRUE && !signal) {
[13:20:25.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.636]                     {
[13:20:25.636]                       inherits <- base::inherits
[13:20:25.636]                       invokeRestart <- base::invokeRestart
[13:20:25.636]                       is.null <- base::is.null
[13:20:25.636]                       muffled <- FALSE
[13:20:25.636]                       if (inherits(cond, "message")) {
[13:20:25.636]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.636]                         if (muffled) 
[13:20:25.636]                           invokeRestart("muffleMessage")
[13:20:25.636]                       }
[13:20:25.636]                       else if (inherits(cond, "warning")) {
[13:20:25.636]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.636]                         if (muffled) 
[13:20:25.636]                           invokeRestart("muffleWarning")
[13:20:25.636]                       }
[13:20:25.636]                       else if (inherits(cond, "condition")) {
[13:20:25.636]                         if (!is.null(pattern)) {
[13:20:25.636]                           computeRestarts <- base::computeRestarts
[13:20:25.636]                           grepl <- base::grepl
[13:20:25.636]                           restarts <- computeRestarts(cond)
[13:20:25.636]                           for (restart in restarts) {
[13:20:25.636]                             name <- restart$name
[13:20:25.636]                             if (is.null(name)) 
[13:20:25.636]                               next
[13:20:25.636]                             if (!grepl(pattern, name)) 
[13:20:25.636]                               next
[13:20:25.636]                             invokeRestart(restart)
[13:20:25.636]                             muffled <- TRUE
[13:20:25.636]                             break
[13:20:25.636]                           }
[13:20:25.636]                         }
[13:20:25.636]                       }
[13:20:25.636]                       invisible(muffled)
[13:20:25.636]                     }
[13:20:25.636]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.636]                   }
[13:20:25.636]                 }
[13:20:25.636]                 else {
[13:20:25.636]                   if (TRUE) {
[13:20:25.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.636]                     {
[13:20:25.636]                       inherits <- base::inherits
[13:20:25.636]                       invokeRestart <- base::invokeRestart
[13:20:25.636]                       is.null <- base::is.null
[13:20:25.636]                       muffled <- FALSE
[13:20:25.636]                       if (inherits(cond, "message")) {
[13:20:25.636]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.636]                         if (muffled) 
[13:20:25.636]                           invokeRestart("muffleMessage")
[13:20:25.636]                       }
[13:20:25.636]                       else if (inherits(cond, "warning")) {
[13:20:25.636]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.636]                         if (muffled) 
[13:20:25.636]                           invokeRestart("muffleWarning")
[13:20:25.636]                       }
[13:20:25.636]                       else if (inherits(cond, "condition")) {
[13:20:25.636]                         if (!is.null(pattern)) {
[13:20:25.636]                           computeRestarts <- base::computeRestarts
[13:20:25.636]                           grepl <- base::grepl
[13:20:25.636]                           restarts <- computeRestarts(cond)
[13:20:25.636]                           for (restart in restarts) {
[13:20:25.636]                             name <- restart$name
[13:20:25.636]                             if (is.null(name)) 
[13:20:25.636]                               next
[13:20:25.636]                             if (!grepl(pattern, name)) 
[13:20:25.636]                               next
[13:20:25.636]                             invokeRestart(restart)
[13:20:25.636]                             muffled <- TRUE
[13:20:25.636]                             break
[13:20:25.636]                           }
[13:20:25.636]                         }
[13:20:25.636]                       }
[13:20:25.636]                       invisible(muffled)
[13:20:25.636]                     }
[13:20:25.636]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.636]                   }
[13:20:25.636]                 }
[13:20:25.636]             }
[13:20:25.636]         }))
[13:20:25.636]     }, error = function(ex) {
[13:20:25.636]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.636]                 ...future.rng), started = ...future.startTime, 
[13:20:25.636]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.636]             version = "1.8"), class = "FutureResult")
[13:20:25.636]     }, finally = {
[13:20:25.636]         if (!identical(...future.workdir, getwd())) 
[13:20:25.636]             setwd(...future.workdir)
[13:20:25.636]         {
[13:20:25.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.636]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.636]             }
[13:20:25.636]             base::options(...future.oldOptions)
[13:20:25.636]             if (.Platform$OS.type == "windows") {
[13:20:25.636]                 old_names <- names(...future.oldEnvVars)
[13:20:25.636]                 envs <- base::Sys.getenv()
[13:20:25.636]                 names <- names(envs)
[13:20:25.636]                 common <- intersect(names, old_names)
[13:20:25.636]                 added <- setdiff(names, old_names)
[13:20:25.636]                 removed <- setdiff(old_names, names)
[13:20:25.636]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.636]                   envs[common]]
[13:20:25.636]                 NAMES <- toupper(changed)
[13:20:25.636]                 args <- list()
[13:20:25.636]                 for (kk in seq_along(NAMES)) {
[13:20:25.636]                   name <- changed[[kk]]
[13:20:25.636]                   NAME <- NAMES[[kk]]
[13:20:25.636]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.636]                     next
[13:20:25.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.636]                 }
[13:20:25.636]                 NAMES <- toupper(added)
[13:20:25.636]                 for (kk in seq_along(NAMES)) {
[13:20:25.636]                   name <- added[[kk]]
[13:20:25.636]                   NAME <- NAMES[[kk]]
[13:20:25.636]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.636]                     next
[13:20:25.636]                   args[[name]] <- ""
[13:20:25.636]                 }
[13:20:25.636]                 NAMES <- toupper(removed)
[13:20:25.636]                 for (kk in seq_along(NAMES)) {
[13:20:25.636]                   name <- removed[[kk]]
[13:20:25.636]                   NAME <- NAMES[[kk]]
[13:20:25.636]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.636]                     next
[13:20:25.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.636]                 }
[13:20:25.636]                 if (length(args) > 0) 
[13:20:25.636]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.636]             }
[13:20:25.636]             else {
[13:20:25.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.636]             }
[13:20:25.636]             {
[13:20:25.636]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.636]                   0L) {
[13:20:25.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.636]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.636]                   base::options(opts)
[13:20:25.636]                 }
[13:20:25.636]                 {
[13:20:25.636]                   {
[13:20:25.636]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:25.636]                     NULL
[13:20:25.636]                   }
[13:20:25.636]                   options(future.plan = NULL)
[13:20:25.636]                   if (is.na(NA_character_)) 
[13:20:25.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.636]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:25.636]                     envir = parent.frame()) 
[13:20:25.636]                   {
[13:20:25.636]                     default_workers <- missing(workers)
[13:20:25.636]                     if (is.function(workers)) 
[13:20:25.636]                       workers <- workers()
[13:20:25.636]                     workers <- structure(as.integer(workers), 
[13:20:25.636]                       class = class(workers))
[13:20:25.636]                     stop_if_not(is.finite(workers), workers >= 
[13:20:25.636]                       1L)
[13:20:25.636]                     if ((workers == 1L && !inherits(workers, 
[13:20:25.636]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:25.636]                       if (default_workers) 
[13:20:25.636]                         supportsMulticore(warn = TRUE)
[13:20:25.636]                       return(sequential(..., envir = envir))
[13:20:25.636]                     }
[13:20:25.636]                     oopts <- options(mc.cores = workers)
[13:20:25.636]                     on.exit(options(oopts))
[13:20:25.636]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:25.636]                       envir = envir)
[13:20:25.636]                     if (!future$lazy) 
[13:20:25.636]                       future <- run(future)
[13:20:25.636]                     invisible(future)
[13:20:25.636]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.636]                 }
[13:20:25.636]             }
[13:20:25.636]         }
[13:20:25.636]     })
[13:20:25.636]     if (TRUE) {
[13:20:25.636]         base::sink(type = "output", split = FALSE)
[13:20:25.636]         if (TRUE) {
[13:20:25.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.636]         }
[13:20:25.636]         else {
[13:20:25.636]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.636]         }
[13:20:25.636]         base::close(...future.stdout)
[13:20:25.636]         ...future.stdout <- NULL
[13:20:25.636]     }
[13:20:25.636]     ...future.result$conditions <- ...future.conditions
[13:20:25.636]     ...future.result$finished <- base::Sys.time()
[13:20:25.636]     ...future.result
[13:20:25.636] }
[13:20:25.639] requestCore(): workers = 2
[13:20:25.646] MulticoreFuture started
[13:20:25.646] - Launch lazy future ... done
[13:20:25.646] run() for ‘MulticoreFuture’ ... done
List of 6
[13:20:25.647] plan(): Setting new future strategy stack:
 $ a:[13:20:25.647] List of future strategies:
[13:20:25.647] 1. sequential:
[13:20:25.647]    - args: function (..., envir = parent.frame())
[13:20:25.647]    - tweaked: FALSE
[13:20:25.647]    - call: NULL
 num 1
 $ b:[13:20:25.648] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659a6b1698> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659b5de788> 
 $  : NULL
 $  : NULL
 $  :[13:20:25.650] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ a:[13:20:25.650] List of future strategies:
[13:20:25.650] 1. multicore:
[13:20:25.650]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:25.650]    - tweaked: FALSE
[13:20:25.650]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659a6b1698> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659b5de788> 
 $  : NULL
 $  : NULL
 $  : num 6
[13:20:25.655] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:25.656] resolve() on list ...
[13:20:25.656]  recursive: 0
[13:20:25.656]  length: 6
[13:20:25.657]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:25.657] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.657] - nx: 6
[13:20:25.662] - relay: TRUE
[13:20:25.663] - stdout: TRUE
[13:20:25.663] - signal: TRUE
[13:20:25.663] - resignal: FALSE
[13:20:25.663] - force: TRUE
[13:20:25.664] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.664] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.664]  - until=2
[13:20:25.664]  - relaying element #2
[13:20:25.665] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.665] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.665] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.666]  length: 5 (resolved future 1)
[13:20:25.666] Future #2
[13:20:25.668] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:25.669] - nx: 6
[13:20:25.669] - relay: TRUE
[13:20:25.669] - stdout: TRUE
[13:20:25.669] - signal: TRUE
[13:20:25.669] - resignal: FALSE
[13:20:25.669] - force: TRUE
[13:20:25.669] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.670] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.670]  - until=2
[13:20:25.670]  - relaying element #2
[13:20:25.670] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.670] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.671] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:25.671]  length: 4 (resolved future 2)
[13:20:25.671] Future #3
[13:20:25.672] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:25.673] - nx: 6
[13:20:25.673] - relay: TRUE
[13:20:25.673] - stdout: TRUE
[13:20:25.673] - signal: TRUE
[13:20:25.673] - resignal: FALSE
[13:20:25.673] - force: TRUE
[13:20:25.673] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.673] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.674]  - until=3
[13:20:25.674]  - relaying element #3
[13:20:25.674] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.674] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.674] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:25.674]  length: 3 (resolved future 3)
[13:20:25.674] signalConditionsASAP(NULL, pos=4) ...
[13:20:25.675] - nx: 6
[13:20:25.675] - relay: TRUE
[13:20:25.675] - stdout: TRUE
[13:20:25.675] - signal: TRUE
[13:20:25.675] - resignal: FALSE
[13:20:25.675] - force: TRUE
[13:20:25.675] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.675] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.675]  - until=5
[13:20:25.675]  - relaying element #5
[13:20:25.676] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.676] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.676] signalConditionsASAP(NULL, pos=4) ... done
[13:20:25.676]  length: 2 (resolved future 4)
[13:20:25.676] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.676] - nx: 6
[13:20:25.676] - relay: TRUE
[13:20:25.676] - stdout: TRUE
[13:20:25.676] - signal: TRUE
[13:20:25.676] - resignal: FALSE
[13:20:25.677] - force: TRUE
[13:20:25.677] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.677] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.677]  - until=6
[13:20:25.677]  - relaying element #6
[13:20:25.677] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.677] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.677] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.677]  length: 1 (resolved future 5)
[13:20:25.678] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.678] - nx: 6
[13:20:25.678] - relay: TRUE
[13:20:25.678] - stdout: TRUE
[13:20:25.678] - signal: TRUE
[13:20:25.678] - resignal: FALSE
[13:20:25.678] - force: TRUE
[13:20:25.678] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.678] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.678]  - until=6
[13:20:25.679] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.679] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.679] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.679]  length: 0 (resolved future 6)
[13:20:25.679] Relaying remaining futures
[13:20:25.679] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.679] - nx: 6
[13:20:25.679] - relay: TRUE
[13:20:25.679] - stdout: TRUE
[13:20:25.680] - signal: TRUE
[13:20:25.680] - resignal: FALSE
[13:20:25.680] - force: TRUE
[13:20:25.680] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.680] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:25.680] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.680] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.680] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.680] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[13:20:25.683] getGlobalsAndPackages() ...
[13:20:25.683] Searching for globals...
[13:20:25.683] 
[13:20:25.684] Searching for globals ... DONE
[13:20:25.684] - globals: [0] <none>
[13:20:25.684] getGlobalsAndPackages() ... DONE
[13:20:25.684] run() for ‘Future’ ...
[13:20:25.684] - state: ‘created’
[13:20:25.684] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:25.688] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:25.688] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:25.688]   - Field: ‘label’
[13:20:25.689]   - Field: ‘local’
[13:20:25.689]   - Field: ‘owner’
[13:20:25.689]   - Field: ‘envir’
[13:20:25.689]   - Field: ‘workers’
[13:20:25.689]   - Field: ‘packages’
[13:20:25.689]   - Field: ‘gc’
[13:20:25.689]   - Field: ‘job’
[13:20:25.689]   - Field: ‘conditions’
[13:20:25.689]   - Field: ‘expr’
[13:20:25.690]   - Field: ‘uuid’
[13:20:25.690]   - Field: ‘seed’
[13:20:25.690]   - Field: ‘version’
[13:20:25.690]   - Field: ‘result’
[13:20:25.690]   - Field: ‘asynchronous’
[13:20:25.690]   - Field: ‘calls’
[13:20:25.690]   - Field: ‘globals’
[13:20:25.690]   - Field: ‘stdout’
[13:20:25.690]   - Field: ‘earlySignal’
[13:20:25.690]   - Field: ‘lazy’
[13:20:25.691]   - Field: ‘state’
[13:20:25.691] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:25.691] - Launch lazy future ...
[13:20:25.691] Packages needed by the future expression (n = 0): <none>
[13:20:25.691] Packages needed by future strategies (n = 0): <none>
[13:20:25.692] {
[13:20:25.692]     {
[13:20:25.692]         {
[13:20:25.692]             ...future.startTime <- base::Sys.time()
[13:20:25.692]             {
[13:20:25.692]                 {
[13:20:25.692]                   {
[13:20:25.692]                     {
[13:20:25.692]                       base::local({
[13:20:25.692]                         has_future <- base::requireNamespace("future", 
[13:20:25.692]                           quietly = TRUE)
[13:20:25.692]                         if (has_future) {
[13:20:25.692]                           ns <- base::getNamespace("future")
[13:20:25.692]                           version <- ns[[".package"]][["version"]]
[13:20:25.692]                           if (is.null(version)) 
[13:20:25.692]                             version <- utils::packageVersion("future")
[13:20:25.692]                         }
[13:20:25.692]                         else {
[13:20:25.692]                           version <- NULL
[13:20:25.692]                         }
[13:20:25.692]                         if (!has_future || version < "1.8.0") {
[13:20:25.692]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.692]                             "", base::R.version$version.string), 
[13:20:25.692]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:25.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.692]                               "release", "version")], collapse = " "), 
[13:20:25.692]                             hostname = base::Sys.info()[["nodename"]])
[13:20:25.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.692]                             info)
[13:20:25.692]                           info <- base::paste(info, collapse = "; ")
[13:20:25.692]                           if (!has_future) {
[13:20:25.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.692]                               info)
[13:20:25.692]                           }
[13:20:25.692]                           else {
[13:20:25.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.692]                               info, version)
[13:20:25.692]                           }
[13:20:25.692]                           base::stop(msg)
[13:20:25.692]                         }
[13:20:25.692]                       })
[13:20:25.692]                     }
[13:20:25.692]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:25.692]                     base::options(mc.cores = 1L)
[13:20:25.692]                   }
[13:20:25.692]                   options(future.plan = NULL)
[13:20:25.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.692]                 }
[13:20:25.692]                 ...future.workdir <- getwd()
[13:20:25.692]             }
[13:20:25.692]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.692]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.692]         }
[13:20:25.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.692]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.692]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.692]             base::names(...future.oldOptions))
[13:20:25.692]     }
[13:20:25.692]     if (FALSE) {
[13:20:25.692]     }
[13:20:25.692]     else {
[13:20:25.692]         if (TRUE) {
[13:20:25.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.692]                 open = "w")
[13:20:25.692]         }
[13:20:25.692]         else {
[13:20:25.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.692]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.692]         }
[13:20:25.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.692]             base::sink(type = "output", split = FALSE)
[13:20:25.692]             base::close(...future.stdout)
[13:20:25.692]         }, add = TRUE)
[13:20:25.692]     }
[13:20:25.692]     ...future.frame <- base::sys.nframe()
[13:20:25.692]     ...future.conditions <- base::list()
[13:20:25.692]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.692]     if (FALSE) {
[13:20:25.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.692]     }
[13:20:25.692]     ...future.result <- base::tryCatch({
[13:20:25.692]         base::withCallingHandlers({
[13:20:25.692]             ...future.value <- base::withVisible(base::local({
[13:20:25.692]                 withCallingHandlers({
[13:20:25.692]                   2
[13:20:25.692]                 }, immediateCondition = function(cond) {
[13:20:25.692]                   save_rds <- function (object, pathname, ...) 
[13:20:25.692]                   {
[13:20:25.692]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:25.692]                     if (file_test("-f", pathname_tmp)) {
[13:20:25.692]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.692]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:25.692]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.692]                         fi_tmp[["mtime"]])
[13:20:25.692]                     }
[13:20:25.692]                     tryCatch({
[13:20:25.692]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:25.692]                     }, error = function(ex) {
[13:20:25.692]                       msg <- conditionMessage(ex)
[13:20:25.692]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.692]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:25.692]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.692]                         fi_tmp[["mtime"]], msg)
[13:20:25.692]                       ex$message <- msg
[13:20:25.692]                       stop(ex)
[13:20:25.692]                     })
[13:20:25.692]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:25.692]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:25.692]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:25.692]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.692]                       fi <- file.info(pathname)
[13:20:25.692]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:25.692]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.692]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:25.692]                         fi[["size"]], fi[["mtime"]])
[13:20:25.692]                       stop(msg)
[13:20:25.692]                     }
[13:20:25.692]                     invisible(pathname)
[13:20:25.692]                   }
[13:20:25.692]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:25.692]                     rootPath = tempdir()) 
[13:20:25.692]                   {
[13:20:25.692]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:25.692]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:25.692]                       tmpdir = path, fileext = ".rds")
[13:20:25.692]                     save_rds(obj, file)
[13:20:25.692]                   }
[13:20:25.692]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:25.692]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.692]                   {
[13:20:25.692]                     inherits <- base::inherits
[13:20:25.692]                     invokeRestart <- base::invokeRestart
[13:20:25.692]                     is.null <- base::is.null
[13:20:25.692]                     muffled <- FALSE
[13:20:25.692]                     if (inherits(cond, "message")) {
[13:20:25.692]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:25.692]                       if (muffled) 
[13:20:25.692]                         invokeRestart("muffleMessage")
[13:20:25.692]                     }
[13:20:25.692]                     else if (inherits(cond, "warning")) {
[13:20:25.692]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:25.692]                       if (muffled) 
[13:20:25.692]                         invokeRestart("muffleWarning")
[13:20:25.692]                     }
[13:20:25.692]                     else if (inherits(cond, "condition")) {
[13:20:25.692]                       if (!is.null(pattern)) {
[13:20:25.692]                         computeRestarts <- base::computeRestarts
[13:20:25.692]                         grepl <- base::grepl
[13:20:25.692]                         restarts <- computeRestarts(cond)
[13:20:25.692]                         for (restart in restarts) {
[13:20:25.692]                           name <- restart$name
[13:20:25.692]                           if (is.null(name)) 
[13:20:25.692]                             next
[13:20:25.692]                           if (!grepl(pattern, name)) 
[13:20:25.692]                             next
[13:20:25.692]                           invokeRestart(restart)
[13:20:25.692]                           muffled <- TRUE
[13:20:25.692]                           break
[13:20:25.692]                         }
[13:20:25.692]                       }
[13:20:25.692]                     }
[13:20:25.692]                     invisible(muffled)
[13:20:25.692]                   }
[13:20:25.692]                   muffleCondition(cond)
[13:20:25.692]                 })
[13:20:25.692]             }))
[13:20:25.692]             future::FutureResult(value = ...future.value$value, 
[13:20:25.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.692]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.692]                     ...future.globalenv.names))
[13:20:25.692]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.692]         }, condition = base::local({
[13:20:25.692]             c <- base::c
[13:20:25.692]             inherits <- base::inherits
[13:20:25.692]             invokeRestart <- base::invokeRestart
[13:20:25.692]             length <- base::length
[13:20:25.692]             list <- base::list
[13:20:25.692]             seq.int <- base::seq.int
[13:20:25.692]             signalCondition <- base::signalCondition
[13:20:25.692]             sys.calls <- base::sys.calls
[13:20:25.692]             `[[` <- base::`[[`
[13:20:25.692]             `+` <- base::`+`
[13:20:25.692]             `<<-` <- base::`<<-`
[13:20:25.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.692]                   3L)]
[13:20:25.692]             }
[13:20:25.692]             function(cond) {
[13:20:25.692]                 is_error <- inherits(cond, "error")
[13:20:25.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.692]                   NULL)
[13:20:25.692]                 if (is_error) {
[13:20:25.692]                   sessionInformation <- function() {
[13:20:25.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.692]                       search = base::search(), system = base::Sys.info())
[13:20:25.692]                   }
[13:20:25.692]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.692]                     cond$call), session = sessionInformation(), 
[13:20:25.692]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.692]                   signalCondition(cond)
[13:20:25.692]                 }
[13:20:25.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.692]                 "immediateCondition"))) {
[13:20:25.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.692]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.692]                   if (TRUE && !signal) {
[13:20:25.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.692]                     {
[13:20:25.692]                       inherits <- base::inherits
[13:20:25.692]                       invokeRestart <- base::invokeRestart
[13:20:25.692]                       is.null <- base::is.null
[13:20:25.692]                       muffled <- FALSE
[13:20:25.692]                       if (inherits(cond, "message")) {
[13:20:25.692]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.692]                         if (muffled) 
[13:20:25.692]                           invokeRestart("muffleMessage")
[13:20:25.692]                       }
[13:20:25.692]                       else if (inherits(cond, "warning")) {
[13:20:25.692]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.692]                         if (muffled) 
[13:20:25.692]                           invokeRestart("muffleWarning")
[13:20:25.692]                       }
[13:20:25.692]                       else if (inherits(cond, "condition")) {
[13:20:25.692]                         if (!is.null(pattern)) {
[13:20:25.692]                           computeRestarts <- base::computeRestarts
[13:20:25.692]                           grepl <- base::grepl
[13:20:25.692]                           restarts <- computeRestarts(cond)
[13:20:25.692]                           for (restart in restarts) {
[13:20:25.692]                             name <- restart$name
[13:20:25.692]                             if (is.null(name)) 
[13:20:25.692]                               next
[13:20:25.692]                             if (!grepl(pattern, name)) 
[13:20:25.692]                               next
[13:20:25.692]                             invokeRestart(restart)
[13:20:25.692]                             muffled <- TRUE
[13:20:25.692]                             break
[13:20:25.692]                           }
[13:20:25.692]                         }
[13:20:25.692]                       }
[13:20:25.692]                       invisible(muffled)
[13:20:25.692]                     }
[13:20:25.692]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.692]                   }
[13:20:25.692]                 }
[13:20:25.692]                 else {
[13:20:25.692]                   if (TRUE) {
[13:20:25.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.692]                     {
[13:20:25.692]                       inherits <- base::inherits
[13:20:25.692]                       invokeRestart <- base::invokeRestart
[13:20:25.692]                       is.null <- base::is.null
[13:20:25.692]                       muffled <- FALSE
[13:20:25.692]                       if (inherits(cond, "message")) {
[13:20:25.692]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.692]                         if (muffled) 
[13:20:25.692]                           invokeRestart("muffleMessage")
[13:20:25.692]                       }
[13:20:25.692]                       else if (inherits(cond, "warning")) {
[13:20:25.692]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.692]                         if (muffled) 
[13:20:25.692]                           invokeRestart("muffleWarning")
[13:20:25.692]                       }
[13:20:25.692]                       else if (inherits(cond, "condition")) {
[13:20:25.692]                         if (!is.null(pattern)) {
[13:20:25.692]                           computeRestarts <- base::computeRestarts
[13:20:25.692]                           grepl <- base::grepl
[13:20:25.692]                           restarts <- computeRestarts(cond)
[13:20:25.692]                           for (restart in restarts) {
[13:20:25.692]                             name <- restart$name
[13:20:25.692]                             if (is.null(name)) 
[13:20:25.692]                               next
[13:20:25.692]                             if (!grepl(pattern, name)) 
[13:20:25.692]                               next
[13:20:25.692]                             invokeRestart(restart)
[13:20:25.692]                             muffled <- TRUE
[13:20:25.692]                             break
[13:20:25.692]                           }
[13:20:25.692]                         }
[13:20:25.692]                       }
[13:20:25.692]                       invisible(muffled)
[13:20:25.692]                     }
[13:20:25.692]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.692]                   }
[13:20:25.692]                 }
[13:20:25.692]             }
[13:20:25.692]         }))
[13:20:25.692]     }, error = function(ex) {
[13:20:25.692]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.692]                 ...future.rng), started = ...future.startTime, 
[13:20:25.692]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.692]             version = "1.8"), class = "FutureResult")
[13:20:25.692]     }, finally = {
[13:20:25.692]         if (!identical(...future.workdir, getwd())) 
[13:20:25.692]             setwd(...future.workdir)
[13:20:25.692]         {
[13:20:25.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.692]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.692]             }
[13:20:25.692]             base::options(...future.oldOptions)
[13:20:25.692]             if (.Platform$OS.type == "windows") {
[13:20:25.692]                 old_names <- names(...future.oldEnvVars)
[13:20:25.692]                 envs <- base::Sys.getenv()
[13:20:25.692]                 names <- names(envs)
[13:20:25.692]                 common <- intersect(names, old_names)
[13:20:25.692]                 added <- setdiff(names, old_names)
[13:20:25.692]                 removed <- setdiff(old_names, names)
[13:20:25.692]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.692]                   envs[common]]
[13:20:25.692]                 NAMES <- toupper(changed)
[13:20:25.692]                 args <- list()
[13:20:25.692]                 for (kk in seq_along(NAMES)) {
[13:20:25.692]                   name <- changed[[kk]]
[13:20:25.692]                   NAME <- NAMES[[kk]]
[13:20:25.692]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.692]                     next
[13:20:25.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.692]                 }
[13:20:25.692]                 NAMES <- toupper(added)
[13:20:25.692]                 for (kk in seq_along(NAMES)) {
[13:20:25.692]                   name <- added[[kk]]
[13:20:25.692]                   NAME <- NAMES[[kk]]
[13:20:25.692]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.692]                     next
[13:20:25.692]                   args[[name]] <- ""
[13:20:25.692]                 }
[13:20:25.692]                 NAMES <- toupper(removed)
[13:20:25.692]                 for (kk in seq_along(NAMES)) {
[13:20:25.692]                   name <- removed[[kk]]
[13:20:25.692]                   NAME <- NAMES[[kk]]
[13:20:25.692]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.692]                     next
[13:20:25.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.692]                 }
[13:20:25.692]                 if (length(args) > 0) 
[13:20:25.692]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.692]             }
[13:20:25.692]             else {
[13:20:25.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.692]             }
[13:20:25.692]             {
[13:20:25.692]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.692]                   0L) {
[13:20:25.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.692]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.692]                   base::options(opts)
[13:20:25.692]                 }
[13:20:25.692]                 {
[13:20:25.692]                   {
[13:20:25.692]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:25.692]                     NULL
[13:20:25.692]                   }
[13:20:25.692]                   options(future.plan = NULL)
[13:20:25.692]                   if (is.na(NA_character_)) 
[13:20:25.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.692]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:25.692]                     envir = parent.frame()) 
[13:20:25.692]                   {
[13:20:25.692]                     default_workers <- missing(workers)
[13:20:25.692]                     if (is.function(workers)) 
[13:20:25.692]                       workers <- workers()
[13:20:25.692]                     workers <- structure(as.integer(workers), 
[13:20:25.692]                       class = class(workers))
[13:20:25.692]                     stop_if_not(is.finite(workers), workers >= 
[13:20:25.692]                       1L)
[13:20:25.692]                     if ((workers == 1L && !inherits(workers, 
[13:20:25.692]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:25.692]                       if (default_workers) 
[13:20:25.692]                         supportsMulticore(warn = TRUE)
[13:20:25.692]                       return(sequential(..., envir = envir))
[13:20:25.692]                     }
[13:20:25.692]                     oopts <- options(mc.cores = workers)
[13:20:25.692]                     on.exit(options(oopts))
[13:20:25.692]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:25.692]                       envir = envir)
[13:20:25.692]                     if (!future$lazy) 
[13:20:25.692]                       future <- run(future)
[13:20:25.692]                     invisible(future)
[13:20:25.692]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.692]                 }
[13:20:25.692]             }
[13:20:25.692]         }
[13:20:25.692]     })
[13:20:25.692]     if (TRUE) {
[13:20:25.692]         base::sink(type = "output", split = FALSE)
[13:20:25.692]         if (TRUE) {
[13:20:25.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.692]         }
[13:20:25.692]         else {
[13:20:25.692]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.692]         }
[13:20:25.692]         base::close(...future.stdout)
[13:20:25.692]         ...future.stdout <- NULL
[13:20:25.692]     }
[13:20:25.692]     ...future.result$conditions <- ...future.conditions
[13:20:25.692]     ...future.result$finished <- base::Sys.time()
[13:20:25.692]     ...future.result
[13:20:25.692] }
[13:20:25.694] requestCore(): workers = 2
[13:20:25.696] MulticoreFuture started
[13:20:25.696] - Launch lazy future ... done
[13:20:25.696] run() for ‘MulticoreFuture’ ... done
[13:20:25.697] getGlobalsAndPackages() ...
[13:20:25.697] Searching for globals...
[13:20:25.697] plan(): Setting new future strategy stack:
[13:20:25.698] 
[13:20:25.697] List of future strategies:
[13:20:25.697] 1. sequential:
[13:20:25.697]    - args: function (..., envir = parent.frame())
[13:20:25.697]    - tweaked: FALSE
[13:20:25.697]    - call: NULL
[13:20:25.698] Searching for globals ... DONE
[13:20:25.698] - globals: [0] <none>
[13:20:25.698] plan(): nbrOfWorkers() = 1
[13:20:25.698] getGlobalsAndPackages() ... DONE
[13:20:25.699] run() for ‘Future’ ...
[13:20:25.699] - state: ‘created’
[13:20:25.699] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:25.700] plan(): Setting new future strategy stack:
[13:20:25.700] List of future strategies:
[13:20:25.700] 1. multicore:
[13:20:25.700]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:25.700]    - tweaked: FALSE
[13:20:25.700]    - call: plan(strategy)
[13:20:25.704] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:25.704] plan(): nbrOfWorkers() = 2
[13:20:25.704] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:25.705]   - Field: ‘label’
[13:20:25.705]   - Field: ‘local’
[13:20:25.705]   - Field: ‘owner’
[13:20:25.705]   - Field: ‘envir’
[13:20:25.705]   - Field: ‘workers’
[13:20:25.706]   - Field: ‘packages’
[13:20:25.706]   - Field: ‘gc’
[13:20:25.706]   - Field: ‘job’
[13:20:25.706]   - Field: ‘conditions’
[13:20:25.706]   - Field: ‘expr’
[13:20:25.706]   - Field: ‘uuid’
[13:20:25.711]   - Field: ‘seed’
[13:20:25.711]   - Field: ‘version’
[13:20:25.711]   - Field: ‘result’
[13:20:25.712]   - Field: ‘asynchronous’
[13:20:25.712]   - Field: ‘calls’
[13:20:25.712]   - Field: ‘globals’
[13:20:25.712]   - Field: ‘stdout’
[13:20:25.713]   - Field: ‘earlySignal’
[13:20:25.713]   - Field: ‘lazy’
[13:20:25.713]   - Field: ‘state’
[13:20:25.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:25.714] - Launch lazy future ...
[13:20:25.715] Packages needed by the future expression (n = 0): <none>
[13:20:25.715] Packages needed by future strategies (n = 0): <none>
[13:20:25.716] {
[13:20:25.716]     {
[13:20:25.716]         {
[13:20:25.716]             ...future.startTime <- base::Sys.time()
[13:20:25.716]             {
[13:20:25.716]                 {
[13:20:25.716]                   {
[13:20:25.716]                     {
[13:20:25.716]                       base::local({
[13:20:25.716]                         has_future <- base::requireNamespace("future", 
[13:20:25.716]                           quietly = TRUE)
[13:20:25.716]                         if (has_future) {
[13:20:25.716]                           ns <- base::getNamespace("future")
[13:20:25.716]                           version <- ns[[".package"]][["version"]]
[13:20:25.716]                           if (is.null(version)) 
[13:20:25.716]                             version <- utils::packageVersion("future")
[13:20:25.716]                         }
[13:20:25.716]                         else {
[13:20:25.716]                           version <- NULL
[13:20:25.716]                         }
[13:20:25.716]                         if (!has_future || version < "1.8.0") {
[13:20:25.716]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.716]                             "", base::R.version$version.string), 
[13:20:25.716]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:25.716]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.716]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.716]                               "release", "version")], collapse = " "), 
[13:20:25.716]                             hostname = base::Sys.info()[["nodename"]])
[13:20:25.716]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.716]                             info)
[13:20:25.716]                           info <- base::paste(info, collapse = "; ")
[13:20:25.716]                           if (!has_future) {
[13:20:25.716]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.716]                               info)
[13:20:25.716]                           }
[13:20:25.716]                           else {
[13:20:25.716]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.716]                               info, version)
[13:20:25.716]                           }
[13:20:25.716]                           base::stop(msg)
[13:20:25.716]                         }
[13:20:25.716]                       })
[13:20:25.716]                     }
[13:20:25.716]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:25.716]                     base::options(mc.cores = 1L)
[13:20:25.716]                   }
[13:20:25.716]                   options(future.plan = NULL)
[13:20:25.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.716]                 }
[13:20:25.716]                 ...future.workdir <- getwd()
[13:20:25.716]             }
[13:20:25.716]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.716]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.716]         }
[13:20:25.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.716]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.716]             base::names(...future.oldOptions))
[13:20:25.716]     }
[13:20:25.716]     if (FALSE) {
[13:20:25.716]     }
[13:20:25.716]     else {
[13:20:25.716]         if (TRUE) {
[13:20:25.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.716]                 open = "w")
[13:20:25.716]         }
[13:20:25.716]         else {
[13:20:25.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.716]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.716]         }
[13:20:25.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.716]             base::sink(type = "output", split = FALSE)
[13:20:25.716]             base::close(...future.stdout)
[13:20:25.716]         }, add = TRUE)
[13:20:25.716]     }
[13:20:25.716]     ...future.frame <- base::sys.nframe()
[13:20:25.716]     ...future.conditions <- base::list()
[13:20:25.716]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.716]     if (FALSE) {
[13:20:25.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.716]     }
[13:20:25.716]     ...future.result <- base::tryCatch({
[13:20:25.716]         base::withCallingHandlers({
[13:20:25.716]             ...future.value <- base::withVisible(base::local({
[13:20:25.716]                 withCallingHandlers({
[13:20:25.716]                   NULL
[13:20:25.716]                 }, immediateCondition = function(cond) {
[13:20:25.716]                   save_rds <- function (object, pathname, ...) 
[13:20:25.716]                   {
[13:20:25.716]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:25.716]                     if (file_test("-f", pathname_tmp)) {
[13:20:25.716]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.716]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:25.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.716]                         fi_tmp[["mtime"]])
[13:20:25.716]                     }
[13:20:25.716]                     tryCatch({
[13:20:25.716]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:25.716]                     }, error = function(ex) {
[13:20:25.716]                       msg <- conditionMessage(ex)
[13:20:25.716]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.716]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:25.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.716]                         fi_tmp[["mtime"]], msg)
[13:20:25.716]                       ex$message <- msg
[13:20:25.716]                       stop(ex)
[13:20:25.716]                     })
[13:20:25.716]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:25.716]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:25.716]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:25.716]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.716]                       fi <- file.info(pathname)
[13:20:25.716]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:25.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.716]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:25.716]                         fi[["size"]], fi[["mtime"]])
[13:20:25.716]                       stop(msg)
[13:20:25.716]                     }
[13:20:25.716]                     invisible(pathname)
[13:20:25.716]                   }
[13:20:25.716]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:25.716]                     rootPath = tempdir()) 
[13:20:25.716]                   {
[13:20:25.716]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:25.716]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:25.716]                       tmpdir = path, fileext = ".rds")
[13:20:25.716]                     save_rds(obj, file)
[13:20:25.716]                   }
[13:20:25.716]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:25.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.716]                   {
[13:20:25.716]                     inherits <- base::inherits
[13:20:25.716]                     invokeRestart <- base::invokeRestart
[13:20:25.716]                     is.null <- base::is.null
[13:20:25.716]                     muffled <- FALSE
[13:20:25.716]                     if (inherits(cond, "message")) {
[13:20:25.716]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:25.716]                       if (muffled) 
[13:20:25.716]                         invokeRestart("muffleMessage")
[13:20:25.716]                     }
[13:20:25.716]                     else if (inherits(cond, "warning")) {
[13:20:25.716]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:25.716]                       if (muffled) 
[13:20:25.716]                         invokeRestart("muffleWarning")
[13:20:25.716]                     }
[13:20:25.716]                     else if (inherits(cond, "condition")) {
[13:20:25.716]                       if (!is.null(pattern)) {
[13:20:25.716]                         computeRestarts <- base::computeRestarts
[13:20:25.716]                         grepl <- base::grepl
[13:20:25.716]                         restarts <- computeRestarts(cond)
[13:20:25.716]                         for (restart in restarts) {
[13:20:25.716]                           name <- restart$name
[13:20:25.716]                           if (is.null(name)) 
[13:20:25.716]                             next
[13:20:25.716]                           if (!grepl(pattern, name)) 
[13:20:25.716]                             next
[13:20:25.716]                           invokeRestart(restart)
[13:20:25.716]                           muffled <- TRUE
[13:20:25.716]                           break
[13:20:25.716]                         }
[13:20:25.716]                       }
[13:20:25.716]                     }
[13:20:25.716]                     invisible(muffled)
[13:20:25.716]                   }
[13:20:25.716]                   muffleCondition(cond)
[13:20:25.716]                 })
[13:20:25.716]             }))
[13:20:25.716]             future::FutureResult(value = ...future.value$value, 
[13:20:25.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.716]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.716]                     ...future.globalenv.names))
[13:20:25.716]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.716]         }, condition = base::local({
[13:20:25.716]             c <- base::c
[13:20:25.716]             inherits <- base::inherits
[13:20:25.716]             invokeRestart <- base::invokeRestart
[13:20:25.716]             length <- base::length
[13:20:25.716]             list <- base::list
[13:20:25.716]             seq.int <- base::seq.int
[13:20:25.716]             signalCondition <- base::signalCondition
[13:20:25.716]             sys.calls <- base::sys.calls
[13:20:25.716]             `[[` <- base::`[[`
[13:20:25.716]             `+` <- base::`+`
[13:20:25.716]             `<<-` <- base::`<<-`
[13:20:25.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.716]                   3L)]
[13:20:25.716]             }
[13:20:25.716]             function(cond) {
[13:20:25.716]                 is_error <- inherits(cond, "error")
[13:20:25.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.716]                   NULL)
[13:20:25.716]                 if (is_error) {
[13:20:25.716]                   sessionInformation <- function() {
[13:20:25.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.716]                       search = base::search(), system = base::Sys.info())
[13:20:25.716]                   }
[13:20:25.716]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.716]                     cond$call), session = sessionInformation(), 
[13:20:25.716]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.716]                   signalCondition(cond)
[13:20:25.716]                 }
[13:20:25.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.716]                 "immediateCondition"))) {
[13:20:25.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.716]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.716]                   if (TRUE && !signal) {
[13:20:25.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.716]                     {
[13:20:25.716]                       inherits <- base::inherits
[13:20:25.716]                       invokeRestart <- base::invokeRestart
[13:20:25.716]                       is.null <- base::is.null
[13:20:25.716]                       muffled <- FALSE
[13:20:25.716]                       if (inherits(cond, "message")) {
[13:20:25.716]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.716]                         if (muffled) 
[13:20:25.716]                           invokeRestart("muffleMessage")
[13:20:25.716]                       }
[13:20:25.716]                       else if (inherits(cond, "warning")) {
[13:20:25.716]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.716]                         if (muffled) 
[13:20:25.716]                           invokeRestart("muffleWarning")
[13:20:25.716]                       }
[13:20:25.716]                       else if (inherits(cond, "condition")) {
[13:20:25.716]                         if (!is.null(pattern)) {
[13:20:25.716]                           computeRestarts <- base::computeRestarts
[13:20:25.716]                           grepl <- base::grepl
[13:20:25.716]                           restarts <- computeRestarts(cond)
[13:20:25.716]                           for (restart in restarts) {
[13:20:25.716]                             name <- restart$name
[13:20:25.716]                             if (is.null(name)) 
[13:20:25.716]                               next
[13:20:25.716]                             if (!grepl(pattern, name)) 
[13:20:25.716]                               next
[13:20:25.716]                             invokeRestart(restart)
[13:20:25.716]                             muffled <- TRUE
[13:20:25.716]                             break
[13:20:25.716]                           }
[13:20:25.716]                         }
[13:20:25.716]                       }
[13:20:25.716]                       invisible(muffled)
[13:20:25.716]                     }
[13:20:25.716]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.716]                   }
[13:20:25.716]                 }
[13:20:25.716]                 else {
[13:20:25.716]                   if (TRUE) {
[13:20:25.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.716]                     {
[13:20:25.716]                       inherits <- base::inherits
[13:20:25.716]                       invokeRestart <- base::invokeRestart
[13:20:25.716]                       is.null <- base::is.null
[13:20:25.716]                       muffled <- FALSE
[13:20:25.716]                       if (inherits(cond, "message")) {
[13:20:25.716]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.716]                         if (muffled) 
[13:20:25.716]                           invokeRestart("muffleMessage")
[13:20:25.716]                       }
[13:20:25.716]                       else if (inherits(cond, "warning")) {
[13:20:25.716]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.716]                         if (muffled) 
[13:20:25.716]                           invokeRestart("muffleWarning")
[13:20:25.716]                       }
[13:20:25.716]                       else if (inherits(cond, "condition")) {
[13:20:25.716]                         if (!is.null(pattern)) {
[13:20:25.716]                           computeRestarts <- base::computeRestarts
[13:20:25.716]                           grepl <- base::grepl
[13:20:25.716]                           restarts <- computeRestarts(cond)
[13:20:25.716]                           for (restart in restarts) {
[13:20:25.716]                             name <- restart$name
[13:20:25.716]                             if (is.null(name)) 
[13:20:25.716]                               next
[13:20:25.716]                             if (!grepl(pattern, name)) 
[13:20:25.716]                               next
[13:20:25.716]                             invokeRestart(restart)
[13:20:25.716]                             muffled <- TRUE
[13:20:25.716]                             break
[13:20:25.716]                           }
[13:20:25.716]                         }
[13:20:25.716]                       }
[13:20:25.716]                       invisible(muffled)
[13:20:25.716]                     }
[13:20:25.716]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.716]                   }
[13:20:25.716]                 }
[13:20:25.716]             }
[13:20:25.716]         }))
[13:20:25.716]     }, error = function(ex) {
[13:20:25.716]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.716]                 ...future.rng), started = ...future.startTime, 
[13:20:25.716]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.716]             version = "1.8"), class = "FutureResult")
[13:20:25.716]     }, finally = {
[13:20:25.716]         if (!identical(...future.workdir, getwd())) 
[13:20:25.716]             setwd(...future.workdir)
[13:20:25.716]         {
[13:20:25.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.716]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.716]             }
[13:20:25.716]             base::options(...future.oldOptions)
[13:20:25.716]             if (.Platform$OS.type == "windows") {
[13:20:25.716]                 old_names <- names(...future.oldEnvVars)
[13:20:25.716]                 envs <- base::Sys.getenv()
[13:20:25.716]                 names <- names(envs)
[13:20:25.716]                 common <- intersect(names, old_names)
[13:20:25.716]                 added <- setdiff(names, old_names)
[13:20:25.716]                 removed <- setdiff(old_names, names)
[13:20:25.716]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.716]                   envs[common]]
[13:20:25.716]                 NAMES <- toupper(changed)
[13:20:25.716]                 args <- list()
[13:20:25.716]                 for (kk in seq_along(NAMES)) {
[13:20:25.716]                   name <- changed[[kk]]
[13:20:25.716]                   NAME <- NAMES[[kk]]
[13:20:25.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.716]                     next
[13:20:25.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.716]                 }
[13:20:25.716]                 NAMES <- toupper(added)
[13:20:25.716]                 for (kk in seq_along(NAMES)) {
[13:20:25.716]                   name <- added[[kk]]
[13:20:25.716]                   NAME <- NAMES[[kk]]
[13:20:25.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.716]                     next
[13:20:25.716]                   args[[name]] <- ""
[13:20:25.716]                 }
[13:20:25.716]                 NAMES <- toupper(removed)
[13:20:25.716]                 for (kk in seq_along(NAMES)) {
[13:20:25.716]                   name <- removed[[kk]]
[13:20:25.716]                   NAME <- NAMES[[kk]]
[13:20:25.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.716]                     next
[13:20:25.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.716]                 }
[13:20:25.716]                 if (length(args) > 0) 
[13:20:25.716]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.716]             }
[13:20:25.716]             else {
[13:20:25.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.716]             }
[13:20:25.716]             {
[13:20:25.716]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.716]                   0L) {
[13:20:25.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.716]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.716]                   base::options(opts)
[13:20:25.716]                 }
[13:20:25.716]                 {
[13:20:25.716]                   {
[13:20:25.716]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:25.716]                     NULL
[13:20:25.716]                   }
[13:20:25.716]                   options(future.plan = NULL)
[13:20:25.716]                   if (is.na(NA_character_)) 
[13:20:25.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.716]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:25.716]                     envir = parent.frame()) 
[13:20:25.716]                   {
[13:20:25.716]                     default_workers <- missing(workers)
[13:20:25.716]                     if (is.function(workers)) 
[13:20:25.716]                       workers <- workers()
[13:20:25.716]                     workers <- structure(as.integer(workers), 
[13:20:25.716]                       class = class(workers))
[13:20:25.716]                     stop_if_not(is.finite(workers), workers >= 
[13:20:25.716]                       1L)
[13:20:25.716]                     if ((workers == 1L && !inherits(workers, 
[13:20:25.716]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:25.716]                       if (default_workers) 
[13:20:25.716]                         supportsMulticore(warn = TRUE)
[13:20:25.716]                       return(sequential(..., envir = envir))
[13:20:25.716]                     }
[13:20:25.716]                     oopts <- options(mc.cores = workers)
[13:20:25.716]                     on.exit(options(oopts))
[13:20:25.716]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:25.716]                       envir = envir)
[13:20:25.716]                     if (!future$lazy) 
[13:20:25.716]                       future <- run(future)
[13:20:25.716]                     invisible(future)
[13:20:25.716]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.716]                 }
[13:20:25.716]             }
[13:20:25.716]         }
[13:20:25.716]     })
[13:20:25.716]     if (TRUE) {
[13:20:25.716]         base::sink(type = "output", split = FALSE)
[13:20:25.716]         if (TRUE) {
[13:20:25.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.716]         }
[13:20:25.716]         else {
[13:20:25.716]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.716]         }
[13:20:25.716]         base::close(...future.stdout)
[13:20:25.716]         ...future.stdout <- NULL
[13:20:25.716]     }
[13:20:25.716]     ...future.result$conditions <- ...future.conditions
[13:20:25.716]     ...future.result$finished <- base::Sys.time()
[13:20:25.716]     ...future.result
[13:20:25.716] }
[13:20:25.719] requestCore(): workers = 2
[13:20:25.721] MulticoreFuture started
[13:20:25.722] - Launch lazy future ... done
[13:20:25.722] run() for ‘MulticoreFuture’ ... done
[13:20:25.722] plan(): Setting new future strategy stack:
List of 6
 $ a:[13:20:25.723] List of future strategies:
[13:20:25.723] 1. sequential:
[13:20:25.723]    - args: function (..., envir = parent.frame())
[13:20:25.723]    - tweaked: FALSE
[13:20:25.723]    - call: NULL
 num 1
 $ b:[13:20:25.724] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659ba83ab8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659be88058> 
 $  : NULL
 $  :[13:20:25.726] plan(): Setting new future strategy stack:
 NULL
 $  :[13:20:25.726] List of future strategies:
[13:20:25.726] 1. multicore:
[13:20:25.726]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:25.726]    - tweaked: FALSE
[13:20:25.726]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659ba83ab8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659be88058> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ :[13:20:25.732] plan(): nbrOfWorkers() = 2
 chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:25.736] resolve() on list ...
[13:20:25.736]  recursive: 0
[13:20:25.736]  length: 6
[13:20:25.736]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:25.736] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.737] - nx: 6
[13:20:25.737] - relay: TRUE
[13:20:25.737] - stdout: TRUE
[13:20:25.737] - signal: TRUE
[13:20:25.737] - resignal: FALSE
[13:20:25.737] - force: TRUE
[13:20:25.737] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.738] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.738]  - until=2
[13:20:25.738]  - relaying element #2
[13:20:25.738] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.738] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.738] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.738]  length: 5 (resolved future 1)
[13:20:25.739] Future #2
[13:20:25.740] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:25.740] - nx: 6
[13:20:25.740] - relay: TRUE
[13:20:25.740] - stdout: TRUE
[13:20:25.740] - signal: TRUE
[13:20:25.741] - resignal: FALSE
[13:20:25.741] - force: TRUE
[13:20:25.741] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.741] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.741]  - until=2
[13:20:25.741]  - relaying element #2
[13:20:25.742] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.742] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.742] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:25.742]  length: 4 (resolved future 2)
[13:20:25.742] Future #3
[13:20:25.743] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:25.743] - nx: 6
[13:20:25.743] - relay: TRUE
[13:20:25.744] - stdout: TRUE
[13:20:25.744] - signal: TRUE
[13:20:25.744] - resignal: FALSE
[13:20:25.744] - force: TRUE
[13:20:25.744] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.744] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.744]  - until=3
[13:20:25.744]  - relaying element #3
[13:20:25.745] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.745] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.745] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:25.745]  length: 3 (resolved future 3)
[13:20:25.745] signalConditionsASAP(NULL, pos=4) ...
[13:20:25.745] - nx: 6
[13:20:25.746] - relay: TRUE
[13:20:25.746] - stdout: TRUE
[13:20:25.746] - signal: TRUE
[13:20:25.746] - resignal: FALSE
[13:20:25.746] - force: TRUE
[13:20:25.746] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.746] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.746]  - until=5
[13:20:25.746]  - relaying element #5
[13:20:25.747] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.747] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.747] signalConditionsASAP(NULL, pos=4) ... done
[13:20:25.747]  length: 2 (resolved future 4)
[13:20:25.747] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.747] - nx: 6
[13:20:25.747] - relay: TRUE
[13:20:25.747] - stdout: TRUE
[13:20:25.747] - signal: TRUE
[13:20:25.747] - resignal: FALSE
[13:20:25.748] - force: TRUE
[13:20:25.748] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.748] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.748]  - until=6
[13:20:25.748]  - relaying element #6
[13:20:25.748] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.748] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.748] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.748]  length: 1 (resolved future 5)
[13:20:25.749] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.749] - nx: 6
[13:20:25.749] - relay: TRUE
[13:20:25.749] - stdout: TRUE
[13:20:25.749] - signal: TRUE
[13:20:25.749] - resignal: FALSE
[13:20:25.749] - force: TRUE
[13:20:25.749] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.749] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.750]  - until=6
[13:20:25.750] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.750] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.750] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.750]  length: 0 (resolved future 6)
[13:20:25.750] Relaying remaining futures
[13:20:25.750] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.750] - nx: 6
[13:20:25.750] - relay: TRUE
[13:20:25.750] - stdout: TRUE
[13:20:25.751] - signal: TRUE
[13:20:25.751] - resignal: FALSE
[13:20:25.751] - force: TRUE
[13:20:25.751] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.751] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:25.751] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.751] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.751] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.751] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:20:25.758] getGlobalsAndPackages() ...
[13:20:25.759] Searching for globals...
[13:20:25.759] 
[13:20:25.759] Searching for globals ... DONE
[13:20:25.759] - globals: [0] <none>
[13:20:25.759] getGlobalsAndPackages() ... DONE
[13:20:25.760] run() for ‘Future’ ...
[13:20:25.760] - state: ‘created’
[13:20:25.760] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:25.764] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:25.764] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:25.764]   - Field: ‘label’
[13:20:25.765]   - Field: ‘local’
[13:20:25.765]   - Field: ‘owner’
[13:20:25.765]   - Field: ‘envir’
[13:20:25.765]   - Field: ‘workers’
[13:20:25.765]   - Field: ‘packages’
[13:20:25.765]   - Field: ‘gc’
[13:20:25.765]   - Field: ‘job’
[13:20:25.765]   - Field: ‘conditions’
[13:20:25.765]   - Field: ‘expr’
[13:20:25.766]   - Field: ‘uuid’
[13:20:25.766]   - Field: ‘seed’
[13:20:25.766]   - Field: ‘version’
[13:20:25.766]   - Field: ‘result’
[13:20:25.766]   - Field: ‘asynchronous’
[13:20:25.766]   - Field: ‘calls’
[13:20:25.766]   - Field: ‘globals’
[13:20:25.766]   - Field: ‘stdout’
[13:20:25.766]   - Field: ‘earlySignal’
[13:20:25.766]   - Field: ‘lazy’
[13:20:25.766]   - Field: ‘state’
[13:20:25.767] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:25.767] - Launch lazy future ...
[13:20:25.767] Packages needed by the future expression (n = 0): <none>
[13:20:25.767] Packages needed by future strategies (n = 0): <none>
[13:20:25.768] {
[13:20:25.768]     {
[13:20:25.768]         {
[13:20:25.768]             ...future.startTime <- base::Sys.time()
[13:20:25.768]             {
[13:20:25.768]                 {
[13:20:25.768]                   {
[13:20:25.768]                     {
[13:20:25.768]                       base::local({
[13:20:25.768]                         has_future <- base::requireNamespace("future", 
[13:20:25.768]                           quietly = TRUE)
[13:20:25.768]                         if (has_future) {
[13:20:25.768]                           ns <- base::getNamespace("future")
[13:20:25.768]                           version <- ns[[".package"]][["version"]]
[13:20:25.768]                           if (is.null(version)) 
[13:20:25.768]                             version <- utils::packageVersion("future")
[13:20:25.768]                         }
[13:20:25.768]                         else {
[13:20:25.768]                           version <- NULL
[13:20:25.768]                         }
[13:20:25.768]                         if (!has_future || version < "1.8.0") {
[13:20:25.768]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.768]                             "", base::R.version$version.string), 
[13:20:25.768]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:25.768]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.768]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.768]                               "release", "version")], collapse = " "), 
[13:20:25.768]                             hostname = base::Sys.info()[["nodename"]])
[13:20:25.768]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.768]                             info)
[13:20:25.768]                           info <- base::paste(info, collapse = "; ")
[13:20:25.768]                           if (!has_future) {
[13:20:25.768]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.768]                               info)
[13:20:25.768]                           }
[13:20:25.768]                           else {
[13:20:25.768]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.768]                               info, version)
[13:20:25.768]                           }
[13:20:25.768]                           base::stop(msg)
[13:20:25.768]                         }
[13:20:25.768]                       })
[13:20:25.768]                     }
[13:20:25.768]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:25.768]                     base::options(mc.cores = 1L)
[13:20:25.768]                   }
[13:20:25.768]                   options(future.plan = NULL)
[13:20:25.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.768]                 }
[13:20:25.768]                 ...future.workdir <- getwd()
[13:20:25.768]             }
[13:20:25.768]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.768]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.768]         }
[13:20:25.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.768]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.768]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.768]             base::names(...future.oldOptions))
[13:20:25.768]     }
[13:20:25.768]     if (FALSE) {
[13:20:25.768]     }
[13:20:25.768]     else {
[13:20:25.768]         if (TRUE) {
[13:20:25.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.768]                 open = "w")
[13:20:25.768]         }
[13:20:25.768]         else {
[13:20:25.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.768]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.768]         }
[13:20:25.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.768]             base::sink(type = "output", split = FALSE)
[13:20:25.768]             base::close(...future.stdout)
[13:20:25.768]         }, add = TRUE)
[13:20:25.768]     }
[13:20:25.768]     ...future.frame <- base::sys.nframe()
[13:20:25.768]     ...future.conditions <- base::list()
[13:20:25.768]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.768]     if (FALSE) {
[13:20:25.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.768]     }
[13:20:25.768]     ...future.result <- base::tryCatch({
[13:20:25.768]         base::withCallingHandlers({
[13:20:25.768]             ...future.value <- base::withVisible(base::local({
[13:20:25.768]                 withCallingHandlers({
[13:20:25.768]                   2
[13:20:25.768]                 }, immediateCondition = function(cond) {
[13:20:25.768]                   save_rds <- function (object, pathname, ...) 
[13:20:25.768]                   {
[13:20:25.768]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:25.768]                     if (file_test("-f", pathname_tmp)) {
[13:20:25.768]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.768]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:25.768]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.768]                         fi_tmp[["mtime"]])
[13:20:25.768]                     }
[13:20:25.768]                     tryCatch({
[13:20:25.768]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:25.768]                     }, error = function(ex) {
[13:20:25.768]                       msg <- conditionMessage(ex)
[13:20:25.768]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.768]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:25.768]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.768]                         fi_tmp[["mtime"]], msg)
[13:20:25.768]                       ex$message <- msg
[13:20:25.768]                       stop(ex)
[13:20:25.768]                     })
[13:20:25.768]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:25.768]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:25.768]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:25.768]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.768]                       fi <- file.info(pathname)
[13:20:25.768]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:25.768]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.768]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:25.768]                         fi[["size"]], fi[["mtime"]])
[13:20:25.768]                       stop(msg)
[13:20:25.768]                     }
[13:20:25.768]                     invisible(pathname)
[13:20:25.768]                   }
[13:20:25.768]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:25.768]                     rootPath = tempdir()) 
[13:20:25.768]                   {
[13:20:25.768]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:25.768]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:25.768]                       tmpdir = path, fileext = ".rds")
[13:20:25.768]                     save_rds(obj, file)
[13:20:25.768]                   }
[13:20:25.768]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:25.768]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.768]                   {
[13:20:25.768]                     inherits <- base::inherits
[13:20:25.768]                     invokeRestart <- base::invokeRestart
[13:20:25.768]                     is.null <- base::is.null
[13:20:25.768]                     muffled <- FALSE
[13:20:25.768]                     if (inherits(cond, "message")) {
[13:20:25.768]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:25.768]                       if (muffled) 
[13:20:25.768]                         invokeRestart("muffleMessage")
[13:20:25.768]                     }
[13:20:25.768]                     else if (inherits(cond, "warning")) {
[13:20:25.768]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:25.768]                       if (muffled) 
[13:20:25.768]                         invokeRestart("muffleWarning")
[13:20:25.768]                     }
[13:20:25.768]                     else if (inherits(cond, "condition")) {
[13:20:25.768]                       if (!is.null(pattern)) {
[13:20:25.768]                         computeRestarts <- base::computeRestarts
[13:20:25.768]                         grepl <- base::grepl
[13:20:25.768]                         restarts <- computeRestarts(cond)
[13:20:25.768]                         for (restart in restarts) {
[13:20:25.768]                           name <- restart$name
[13:20:25.768]                           if (is.null(name)) 
[13:20:25.768]                             next
[13:20:25.768]                           if (!grepl(pattern, name)) 
[13:20:25.768]                             next
[13:20:25.768]                           invokeRestart(restart)
[13:20:25.768]                           muffled <- TRUE
[13:20:25.768]                           break
[13:20:25.768]                         }
[13:20:25.768]                       }
[13:20:25.768]                     }
[13:20:25.768]                     invisible(muffled)
[13:20:25.768]                   }
[13:20:25.768]                   muffleCondition(cond)
[13:20:25.768]                 })
[13:20:25.768]             }))
[13:20:25.768]             future::FutureResult(value = ...future.value$value, 
[13:20:25.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.768]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.768]                     ...future.globalenv.names))
[13:20:25.768]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.768]         }, condition = base::local({
[13:20:25.768]             c <- base::c
[13:20:25.768]             inherits <- base::inherits
[13:20:25.768]             invokeRestart <- base::invokeRestart
[13:20:25.768]             length <- base::length
[13:20:25.768]             list <- base::list
[13:20:25.768]             seq.int <- base::seq.int
[13:20:25.768]             signalCondition <- base::signalCondition
[13:20:25.768]             sys.calls <- base::sys.calls
[13:20:25.768]             `[[` <- base::`[[`
[13:20:25.768]             `+` <- base::`+`
[13:20:25.768]             `<<-` <- base::`<<-`
[13:20:25.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.768]                   3L)]
[13:20:25.768]             }
[13:20:25.768]             function(cond) {
[13:20:25.768]                 is_error <- inherits(cond, "error")
[13:20:25.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.768]                   NULL)
[13:20:25.768]                 if (is_error) {
[13:20:25.768]                   sessionInformation <- function() {
[13:20:25.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.768]                       search = base::search(), system = base::Sys.info())
[13:20:25.768]                   }
[13:20:25.768]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.768]                     cond$call), session = sessionInformation(), 
[13:20:25.768]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.768]                   signalCondition(cond)
[13:20:25.768]                 }
[13:20:25.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.768]                 "immediateCondition"))) {
[13:20:25.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.768]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.768]                   if (TRUE && !signal) {
[13:20:25.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.768]                     {
[13:20:25.768]                       inherits <- base::inherits
[13:20:25.768]                       invokeRestart <- base::invokeRestart
[13:20:25.768]                       is.null <- base::is.null
[13:20:25.768]                       muffled <- FALSE
[13:20:25.768]                       if (inherits(cond, "message")) {
[13:20:25.768]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.768]                         if (muffled) 
[13:20:25.768]                           invokeRestart("muffleMessage")
[13:20:25.768]                       }
[13:20:25.768]                       else if (inherits(cond, "warning")) {
[13:20:25.768]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.768]                         if (muffled) 
[13:20:25.768]                           invokeRestart("muffleWarning")
[13:20:25.768]                       }
[13:20:25.768]                       else if (inherits(cond, "condition")) {
[13:20:25.768]                         if (!is.null(pattern)) {
[13:20:25.768]                           computeRestarts <- base::computeRestarts
[13:20:25.768]                           grepl <- base::grepl
[13:20:25.768]                           restarts <- computeRestarts(cond)
[13:20:25.768]                           for (restart in restarts) {
[13:20:25.768]                             name <- restart$name
[13:20:25.768]                             if (is.null(name)) 
[13:20:25.768]                               next
[13:20:25.768]                             if (!grepl(pattern, name)) 
[13:20:25.768]                               next
[13:20:25.768]                             invokeRestart(restart)
[13:20:25.768]                             muffled <- TRUE
[13:20:25.768]                             break
[13:20:25.768]                           }
[13:20:25.768]                         }
[13:20:25.768]                       }
[13:20:25.768]                       invisible(muffled)
[13:20:25.768]                     }
[13:20:25.768]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.768]                   }
[13:20:25.768]                 }
[13:20:25.768]                 else {
[13:20:25.768]                   if (TRUE) {
[13:20:25.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.768]                     {
[13:20:25.768]                       inherits <- base::inherits
[13:20:25.768]                       invokeRestart <- base::invokeRestart
[13:20:25.768]                       is.null <- base::is.null
[13:20:25.768]                       muffled <- FALSE
[13:20:25.768]                       if (inherits(cond, "message")) {
[13:20:25.768]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.768]                         if (muffled) 
[13:20:25.768]                           invokeRestart("muffleMessage")
[13:20:25.768]                       }
[13:20:25.768]                       else if (inherits(cond, "warning")) {
[13:20:25.768]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.768]                         if (muffled) 
[13:20:25.768]                           invokeRestart("muffleWarning")
[13:20:25.768]                       }
[13:20:25.768]                       else if (inherits(cond, "condition")) {
[13:20:25.768]                         if (!is.null(pattern)) {
[13:20:25.768]                           computeRestarts <- base::computeRestarts
[13:20:25.768]                           grepl <- base::grepl
[13:20:25.768]                           restarts <- computeRestarts(cond)
[13:20:25.768]                           for (restart in restarts) {
[13:20:25.768]                             name <- restart$name
[13:20:25.768]                             if (is.null(name)) 
[13:20:25.768]                               next
[13:20:25.768]                             if (!grepl(pattern, name)) 
[13:20:25.768]                               next
[13:20:25.768]                             invokeRestart(restart)
[13:20:25.768]                             muffled <- TRUE
[13:20:25.768]                             break
[13:20:25.768]                           }
[13:20:25.768]                         }
[13:20:25.768]                       }
[13:20:25.768]                       invisible(muffled)
[13:20:25.768]                     }
[13:20:25.768]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.768]                   }
[13:20:25.768]                 }
[13:20:25.768]             }
[13:20:25.768]         }))
[13:20:25.768]     }, error = function(ex) {
[13:20:25.768]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.768]                 ...future.rng), started = ...future.startTime, 
[13:20:25.768]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.768]             version = "1.8"), class = "FutureResult")
[13:20:25.768]     }, finally = {
[13:20:25.768]         if (!identical(...future.workdir, getwd())) 
[13:20:25.768]             setwd(...future.workdir)
[13:20:25.768]         {
[13:20:25.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.768]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.768]             }
[13:20:25.768]             base::options(...future.oldOptions)
[13:20:25.768]             if (.Platform$OS.type == "windows") {
[13:20:25.768]                 old_names <- names(...future.oldEnvVars)
[13:20:25.768]                 envs <- base::Sys.getenv()
[13:20:25.768]                 names <- names(envs)
[13:20:25.768]                 common <- intersect(names, old_names)
[13:20:25.768]                 added <- setdiff(names, old_names)
[13:20:25.768]                 removed <- setdiff(old_names, names)
[13:20:25.768]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.768]                   envs[common]]
[13:20:25.768]                 NAMES <- toupper(changed)
[13:20:25.768]                 args <- list()
[13:20:25.768]                 for (kk in seq_along(NAMES)) {
[13:20:25.768]                   name <- changed[[kk]]
[13:20:25.768]                   NAME <- NAMES[[kk]]
[13:20:25.768]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.768]                     next
[13:20:25.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.768]                 }
[13:20:25.768]                 NAMES <- toupper(added)
[13:20:25.768]                 for (kk in seq_along(NAMES)) {
[13:20:25.768]                   name <- added[[kk]]
[13:20:25.768]                   NAME <- NAMES[[kk]]
[13:20:25.768]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.768]                     next
[13:20:25.768]                   args[[name]] <- ""
[13:20:25.768]                 }
[13:20:25.768]                 NAMES <- toupper(removed)
[13:20:25.768]                 for (kk in seq_along(NAMES)) {
[13:20:25.768]                   name <- removed[[kk]]
[13:20:25.768]                   NAME <- NAMES[[kk]]
[13:20:25.768]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.768]                     next
[13:20:25.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.768]                 }
[13:20:25.768]                 if (length(args) > 0) 
[13:20:25.768]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.768]             }
[13:20:25.768]             else {
[13:20:25.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.768]             }
[13:20:25.768]             {
[13:20:25.768]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.768]                   0L) {
[13:20:25.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.768]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.768]                   base::options(opts)
[13:20:25.768]                 }
[13:20:25.768]                 {
[13:20:25.768]                   {
[13:20:25.768]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:25.768]                     NULL
[13:20:25.768]                   }
[13:20:25.768]                   options(future.plan = NULL)
[13:20:25.768]                   if (is.na(NA_character_)) 
[13:20:25.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.768]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:25.768]                     envir = parent.frame()) 
[13:20:25.768]                   {
[13:20:25.768]                     default_workers <- missing(workers)
[13:20:25.768]                     if (is.function(workers)) 
[13:20:25.768]                       workers <- workers()
[13:20:25.768]                     workers <- structure(as.integer(workers), 
[13:20:25.768]                       class = class(workers))
[13:20:25.768]                     stop_if_not(is.finite(workers), workers >= 
[13:20:25.768]                       1L)
[13:20:25.768]                     if ((workers == 1L && !inherits(workers, 
[13:20:25.768]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:25.768]                       if (default_workers) 
[13:20:25.768]                         supportsMulticore(warn = TRUE)
[13:20:25.768]                       return(sequential(..., envir = envir))
[13:20:25.768]                     }
[13:20:25.768]                     oopts <- options(mc.cores = workers)
[13:20:25.768]                     on.exit(options(oopts))
[13:20:25.768]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:25.768]                       envir = envir)
[13:20:25.768]                     if (!future$lazy) 
[13:20:25.768]                       future <- run(future)
[13:20:25.768]                     invisible(future)
[13:20:25.768]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.768]                 }
[13:20:25.768]             }
[13:20:25.768]         }
[13:20:25.768]     })
[13:20:25.768]     if (TRUE) {
[13:20:25.768]         base::sink(type = "output", split = FALSE)
[13:20:25.768]         if (TRUE) {
[13:20:25.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.768]         }
[13:20:25.768]         else {
[13:20:25.768]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.768]         }
[13:20:25.768]         base::close(...future.stdout)
[13:20:25.768]         ...future.stdout <- NULL
[13:20:25.768]     }
[13:20:25.768]     ...future.result$conditions <- ...future.conditions
[13:20:25.768]     ...future.result$finished <- base::Sys.time()
[13:20:25.768]     ...future.result
[13:20:25.768] }
[13:20:25.770] requestCore(): workers = 2
[13:20:25.772] MulticoreFuture started
[13:20:25.772] - Launch lazy future ... done
[13:20:25.773] run() for ‘MulticoreFuture’ ... done
[13:20:25.773] getGlobalsAndPackages() ...
[13:20:25.773] Searching for globals...
[13:20:25.773] plan(): Setting new future strategy stack:
[13:20:25.774] 
[13:20:25.774] List of future strategies:
[13:20:25.774] 1. sequential:
[13:20:25.774]    - args: function (..., envir = parent.frame())
[13:20:25.774]    - tweaked: FALSE
[13:20:25.774]    - call: NULL
[13:20:25.774] Searching for globals ... DONE
[13:20:25.774] - globals: [0] <none>
[13:20:25.775] plan(): nbrOfWorkers() = 1
[13:20:25.775] getGlobalsAndPackages() ... DONE
[13:20:25.775] run() for ‘Future’ ...
[13:20:25.775] - state: ‘created’
[13:20:25.776] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:25.776] plan(): Setting new future strategy stack:
[13:20:25.777] List of future strategies:
[13:20:25.777] 1. multicore:
[13:20:25.777]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:25.777]    - tweaked: FALSE
[13:20:25.777]    - call: plan(strategy)
[13:20:25.781] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:25.782] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:25.782] plan(): nbrOfWorkers() = 2
[13:20:25.782]   - Field: ‘label’
[13:20:25.782]   - Field: ‘local’
[13:20:25.783]   - Field: ‘owner’
[13:20:25.783]   - Field: ‘envir’
[13:20:25.783]   - Field: ‘workers’
[13:20:25.783]   - Field: ‘packages’
[13:20:25.783]   - Field: ‘gc’
[13:20:25.783]   - Field: ‘job’
[13:20:25.783]   - Field: ‘conditions’
[13:20:25.784]   - Field: ‘expr’
[13:20:25.784]   - Field: ‘uuid’
[13:20:25.784]   - Field: ‘seed’
[13:20:25.784]   - Field: ‘version’
[13:20:25.784]   - Field: ‘result’
[13:20:25.784]   - Field: ‘asynchronous’
[13:20:25.784]   - Field: ‘calls’
[13:20:25.785]   - Field: ‘globals’
[13:20:25.785]   - Field: ‘stdout’
[13:20:25.785]   - Field: ‘earlySignal’
[13:20:25.785]   - Field: ‘lazy’
[13:20:25.785]   - Field: ‘state’
[13:20:25.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:25.786] - Launch lazy future ...
[13:20:25.786] Packages needed by the future expression (n = 0): <none>
[13:20:25.786] Packages needed by future strategies (n = 0): <none>
[13:20:25.787] {
[13:20:25.787]     {
[13:20:25.787]         {
[13:20:25.787]             ...future.startTime <- base::Sys.time()
[13:20:25.787]             {
[13:20:25.787]                 {
[13:20:25.787]                   {
[13:20:25.787]                     {
[13:20:25.787]                       base::local({
[13:20:25.787]                         has_future <- base::requireNamespace("future", 
[13:20:25.787]                           quietly = TRUE)
[13:20:25.787]                         if (has_future) {
[13:20:25.787]                           ns <- base::getNamespace("future")
[13:20:25.787]                           version <- ns[[".package"]][["version"]]
[13:20:25.787]                           if (is.null(version)) 
[13:20:25.787]                             version <- utils::packageVersion("future")
[13:20:25.787]                         }
[13:20:25.787]                         else {
[13:20:25.787]                           version <- NULL
[13:20:25.787]                         }
[13:20:25.787]                         if (!has_future || version < "1.8.0") {
[13:20:25.787]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.787]                             "", base::R.version$version.string), 
[13:20:25.787]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:25.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.787]                               "release", "version")], collapse = " "), 
[13:20:25.787]                             hostname = base::Sys.info()[["nodename"]])
[13:20:25.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.787]                             info)
[13:20:25.787]                           info <- base::paste(info, collapse = "; ")
[13:20:25.787]                           if (!has_future) {
[13:20:25.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.787]                               info)
[13:20:25.787]                           }
[13:20:25.787]                           else {
[13:20:25.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.787]                               info, version)
[13:20:25.787]                           }
[13:20:25.787]                           base::stop(msg)
[13:20:25.787]                         }
[13:20:25.787]                       })
[13:20:25.787]                     }
[13:20:25.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:25.787]                     base::options(mc.cores = 1L)
[13:20:25.787]                   }
[13:20:25.787]                   options(future.plan = NULL)
[13:20:25.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.787]                 }
[13:20:25.787]                 ...future.workdir <- getwd()
[13:20:25.787]             }
[13:20:25.787]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.787]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.787]         }
[13:20:25.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.787]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.787]             base::names(...future.oldOptions))
[13:20:25.787]     }
[13:20:25.787]     if (FALSE) {
[13:20:25.787]     }
[13:20:25.787]     else {
[13:20:25.787]         if (TRUE) {
[13:20:25.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.787]                 open = "w")
[13:20:25.787]         }
[13:20:25.787]         else {
[13:20:25.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.787]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.787]         }
[13:20:25.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.787]             base::sink(type = "output", split = FALSE)
[13:20:25.787]             base::close(...future.stdout)
[13:20:25.787]         }, add = TRUE)
[13:20:25.787]     }
[13:20:25.787]     ...future.frame <- base::sys.nframe()
[13:20:25.787]     ...future.conditions <- base::list()
[13:20:25.787]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.787]     if (FALSE) {
[13:20:25.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.787]     }
[13:20:25.787]     ...future.result <- base::tryCatch({
[13:20:25.787]         base::withCallingHandlers({
[13:20:25.787]             ...future.value <- base::withVisible(base::local({
[13:20:25.787]                 withCallingHandlers({
[13:20:25.787]                   NULL
[13:20:25.787]                 }, immediateCondition = function(cond) {
[13:20:25.787]                   save_rds <- function (object, pathname, ...) 
[13:20:25.787]                   {
[13:20:25.787]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:25.787]                     if (file_test("-f", pathname_tmp)) {
[13:20:25.787]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.787]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:25.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.787]                         fi_tmp[["mtime"]])
[13:20:25.787]                     }
[13:20:25.787]                     tryCatch({
[13:20:25.787]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:25.787]                     }, error = function(ex) {
[13:20:25.787]                       msg <- conditionMessage(ex)
[13:20:25.787]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.787]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:25.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.787]                         fi_tmp[["mtime"]], msg)
[13:20:25.787]                       ex$message <- msg
[13:20:25.787]                       stop(ex)
[13:20:25.787]                     })
[13:20:25.787]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:25.787]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:25.787]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:25.787]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.787]                       fi <- file.info(pathname)
[13:20:25.787]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:25.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.787]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:25.787]                         fi[["size"]], fi[["mtime"]])
[13:20:25.787]                       stop(msg)
[13:20:25.787]                     }
[13:20:25.787]                     invisible(pathname)
[13:20:25.787]                   }
[13:20:25.787]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:25.787]                     rootPath = tempdir()) 
[13:20:25.787]                   {
[13:20:25.787]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:25.787]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:25.787]                       tmpdir = path, fileext = ".rds")
[13:20:25.787]                     save_rds(obj, file)
[13:20:25.787]                   }
[13:20:25.787]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:25.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.787]                   {
[13:20:25.787]                     inherits <- base::inherits
[13:20:25.787]                     invokeRestart <- base::invokeRestart
[13:20:25.787]                     is.null <- base::is.null
[13:20:25.787]                     muffled <- FALSE
[13:20:25.787]                     if (inherits(cond, "message")) {
[13:20:25.787]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:25.787]                       if (muffled) 
[13:20:25.787]                         invokeRestart("muffleMessage")
[13:20:25.787]                     }
[13:20:25.787]                     else if (inherits(cond, "warning")) {
[13:20:25.787]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:25.787]                       if (muffled) 
[13:20:25.787]                         invokeRestart("muffleWarning")
[13:20:25.787]                     }
[13:20:25.787]                     else if (inherits(cond, "condition")) {
[13:20:25.787]                       if (!is.null(pattern)) {
[13:20:25.787]                         computeRestarts <- base::computeRestarts
[13:20:25.787]                         grepl <- base::grepl
[13:20:25.787]                         restarts <- computeRestarts(cond)
[13:20:25.787]                         for (restart in restarts) {
[13:20:25.787]                           name <- restart$name
[13:20:25.787]                           if (is.null(name)) 
[13:20:25.787]                             next
[13:20:25.787]                           if (!grepl(pattern, name)) 
[13:20:25.787]                             next
[13:20:25.787]                           invokeRestart(restart)
[13:20:25.787]                           muffled <- TRUE
[13:20:25.787]                           break
[13:20:25.787]                         }
[13:20:25.787]                       }
[13:20:25.787]                     }
[13:20:25.787]                     invisible(muffled)
[13:20:25.787]                   }
[13:20:25.787]                   muffleCondition(cond)
[13:20:25.787]                 })
[13:20:25.787]             }))
[13:20:25.787]             future::FutureResult(value = ...future.value$value, 
[13:20:25.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.787]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.787]                     ...future.globalenv.names))
[13:20:25.787]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.787]         }, condition = base::local({
[13:20:25.787]             c <- base::c
[13:20:25.787]             inherits <- base::inherits
[13:20:25.787]             invokeRestart <- base::invokeRestart
[13:20:25.787]             length <- base::length
[13:20:25.787]             list <- base::list
[13:20:25.787]             seq.int <- base::seq.int
[13:20:25.787]             signalCondition <- base::signalCondition
[13:20:25.787]             sys.calls <- base::sys.calls
[13:20:25.787]             `[[` <- base::`[[`
[13:20:25.787]             `+` <- base::`+`
[13:20:25.787]             `<<-` <- base::`<<-`
[13:20:25.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.787]                   3L)]
[13:20:25.787]             }
[13:20:25.787]             function(cond) {
[13:20:25.787]                 is_error <- inherits(cond, "error")
[13:20:25.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.787]                   NULL)
[13:20:25.787]                 if (is_error) {
[13:20:25.787]                   sessionInformation <- function() {
[13:20:25.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.787]                       search = base::search(), system = base::Sys.info())
[13:20:25.787]                   }
[13:20:25.787]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.787]                     cond$call), session = sessionInformation(), 
[13:20:25.787]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.787]                   signalCondition(cond)
[13:20:25.787]                 }
[13:20:25.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.787]                 "immediateCondition"))) {
[13:20:25.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.787]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.787]                   if (TRUE && !signal) {
[13:20:25.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.787]                     {
[13:20:25.787]                       inherits <- base::inherits
[13:20:25.787]                       invokeRestart <- base::invokeRestart
[13:20:25.787]                       is.null <- base::is.null
[13:20:25.787]                       muffled <- FALSE
[13:20:25.787]                       if (inherits(cond, "message")) {
[13:20:25.787]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.787]                         if (muffled) 
[13:20:25.787]                           invokeRestart("muffleMessage")
[13:20:25.787]                       }
[13:20:25.787]                       else if (inherits(cond, "warning")) {
[13:20:25.787]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.787]                         if (muffled) 
[13:20:25.787]                           invokeRestart("muffleWarning")
[13:20:25.787]                       }
[13:20:25.787]                       else if (inherits(cond, "condition")) {
[13:20:25.787]                         if (!is.null(pattern)) {
[13:20:25.787]                           computeRestarts <- base::computeRestarts
[13:20:25.787]                           grepl <- base::grepl
[13:20:25.787]                           restarts <- computeRestarts(cond)
[13:20:25.787]                           for (restart in restarts) {
[13:20:25.787]                             name <- restart$name
[13:20:25.787]                             if (is.null(name)) 
[13:20:25.787]                               next
[13:20:25.787]                             if (!grepl(pattern, name)) 
[13:20:25.787]                               next
[13:20:25.787]                             invokeRestart(restart)
[13:20:25.787]                             muffled <- TRUE
[13:20:25.787]                             break
[13:20:25.787]                           }
[13:20:25.787]                         }
[13:20:25.787]                       }
[13:20:25.787]                       invisible(muffled)
[13:20:25.787]                     }
[13:20:25.787]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.787]                   }
[13:20:25.787]                 }
[13:20:25.787]                 else {
[13:20:25.787]                   if (TRUE) {
[13:20:25.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.787]                     {
[13:20:25.787]                       inherits <- base::inherits
[13:20:25.787]                       invokeRestart <- base::invokeRestart
[13:20:25.787]                       is.null <- base::is.null
[13:20:25.787]                       muffled <- FALSE
[13:20:25.787]                       if (inherits(cond, "message")) {
[13:20:25.787]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.787]                         if (muffled) 
[13:20:25.787]                           invokeRestart("muffleMessage")
[13:20:25.787]                       }
[13:20:25.787]                       else if (inherits(cond, "warning")) {
[13:20:25.787]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.787]                         if (muffled) 
[13:20:25.787]                           invokeRestart("muffleWarning")
[13:20:25.787]                       }
[13:20:25.787]                       else if (inherits(cond, "condition")) {
[13:20:25.787]                         if (!is.null(pattern)) {
[13:20:25.787]                           computeRestarts <- base::computeRestarts
[13:20:25.787]                           grepl <- base::grepl
[13:20:25.787]                           restarts <- computeRestarts(cond)
[13:20:25.787]                           for (restart in restarts) {
[13:20:25.787]                             name <- restart$name
[13:20:25.787]                             if (is.null(name)) 
[13:20:25.787]                               next
[13:20:25.787]                             if (!grepl(pattern, name)) 
[13:20:25.787]                               next
[13:20:25.787]                             invokeRestart(restart)
[13:20:25.787]                             muffled <- TRUE
[13:20:25.787]                             break
[13:20:25.787]                           }
[13:20:25.787]                         }
[13:20:25.787]                       }
[13:20:25.787]                       invisible(muffled)
[13:20:25.787]                     }
[13:20:25.787]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.787]                   }
[13:20:25.787]                 }
[13:20:25.787]             }
[13:20:25.787]         }))
[13:20:25.787]     }, error = function(ex) {
[13:20:25.787]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.787]                 ...future.rng), started = ...future.startTime, 
[13:20:25.787]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.787]             version = "1.8"), class = "FutureResult")
[13:20:25.787]     }, finally = {
[13:20:25.787]         if (!identical(...future.workdir, getwd())) 
[13:20:25.787]             setwd(...future.workdir)
[13:20:25.787]         {
[13:20:25.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.787]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.787]             }
[13:20:25.787]             base::options(...future.oldOptions)
[13:20:25.787]             if (.Platform$OS.type == "windows") {
[13:20:25.787]                 old_names <- names(...future.oldEnvVars)
[13:20:25.787]                 envs <- base::Sys.getenv()
[13:20:25.787]                 names <- names(envs)
[13:20:25.787]                 common <- intersect(names, old_names)
[13:20:25.787]                 added <- setdiff(names, old_names)
[13:20:25.787]                 removed <- setdiff(old_names, names)
[13:20:25.787]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.787]                   envs[common]]
[13:20:25.787]                 NAMES <- toupper(changed)
[13:20:25.787]                 args <- list()
[13:20:25.787]                 for (kk in seq_along(NAMES)) {
[13:20:25.787]                   name <- changed[[kk]]
[13:20:25.787]                   NAME <- NAMES[[kk]]
[13:20:25.787]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.787]                     next
[13:20:25.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.787]                 }
[13:20:25.787]                 NAMES <- toupper(added)
[13:20:25.787]                 for (kk in seq_along(NAMES)) {
[13:20:25.787]                   name <- added[[kk]]
[13:20:25.787]                   NAME <- NAMES[[kk]]
[13:20:25.787]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.787]                     next
[13:20:25.787]                   args[[name]] <- ""
[13:20:25.787]                 }
[13:20:25.787]                 NAMES <- toupper(removed)
[13:20:25.787]                 for (kk in seq_along(NAMES)) {
[13:20:25.787]                   name <- removed[[kk]]
[13:20:25.787]                   NAME <- NAMES[[kk]]
[13:20:25.787]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.787]                     next
[13:20:25.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.787]                 }
[13:20:25.787]                 if (length(args) > 0) 
[13:20:25.787]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.787]             }
[13:20:25.787]             else {
[13:20:25.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.787]             }
[13:20:25.787]             {
[13:20:25.787]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.787]                   0L) {
[13:20:25.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.787]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.787]                   base::options(opts)
[13:20:25.787]                 }
[13:20:25.787]                 {
[13:20:25.787]                   {
[13:20:25.787]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:25.787]                     NULL
[13:20:25.787]                   }
[13:20:25.787]                   options(future.plan = NULL)
[13:20:25.787]                   if (is.na(NA_character_)) 
[13:20:25.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.787]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:25.787]                     envir = parent.frame()) 
[13:20:25.787]                   {
[13:20:25.787]                     default_workers <- missing(workers)
[13:20:25.787]                     if (is.function(workers)) 
[13:20:25.787]                       workers <- workers()
[13:20:25.787]                     workers <- structure(as.integer(workers), 
[13:20:25.787]                       class = class(workers))
[13:20:25.787]                     stop_if_not(is.finite(workers), workers >= 
[13:20:25.787]                       1L)
[13:20:25.787]                     if ((workers == 1L && !inherits(workers, 
[13:20:25.787]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:25.787]                       if (default_workers) 
[13:20:25.787]                         supportsMulticore(warn = TRUE)
[13:20:25.787]                       return(sequential(..., envir = envir))
[13:20:25.787]                     }
[13:20:25.787]                     oopts <- options(mc.cores = workers)
[13:20:25.787]                     on.exit(options(oopts))
[13:20:25.787]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:25.787]                       envir = envir)
[13:20:25.787]                     if (!future$lazy) 
[13:20:25.787]                       future <- run(future)
[13:20:25.787]                     invisible(future)
[13:20:25.787]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.787]                 }
[13:20:25.787]             }
[13:20:25.787]         }
[13:20:25.787]     })
[13:20:25.787]     if (TRUE) {
[13:20:25.787]         base::sink(type = "output", split = FALSE)
[13:20:25.787]         if (TRUE) {
[13:20:25.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.787]         }
[13:20:25.787]         else {
[13:20:25.787]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.787]         }
[13:20:25.787]         base::close(...future.stdout)
[13:20:25.787]         ...future.stdout <- NULL
[13:20:25.787]     }
[13:20:25.787]     ...future.result$conditions <- ...future.conditions
[13:20:25.787]     ...future.result$finished <- base::Sys.time()
[13:20:25.787]     ...future.result
[13:20:25.787] }
[13:20:25.791] requestCore(): workers = 2
[13:20:25.793] MulticoreFuture started
[13:20:25.793] - Launch lazy future ... done
[13:20:25.793] run() for ‘MulticoreFuture’ ... done
List of 6
[13:20:25.794] plan(): Setting new future strategy stack:
 $ a:[13:20:25.794] List of future strategies:
[13:20:25.794] 1. sequential:
[13:20:25.794]    - args: function (..., envir = parent.frame())
[13:20:25.794]    - tweaked: FALSE
[13:20:25.794]    - call: NULL
 num 1
 $ b:[13:20:25.795] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659b0e9110> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659b42bb08> 
 $  : NULL
 $  : NULL
 $  :[13:20:25.797] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ a:[13:20:25.797] List of future strategies:
[13:20:25.797] 1. multicore:
[13:20:25.797]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:25.797]    - tweaked: FALSE
[13:20:25.797]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659b0e9110> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659b42bb08> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ :[13:20:25.802] plan(): nbrOfWorkers() = 2
 chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:25.806] resolve() on list ...
[13:20:25.807]  recursive: 0
[13:20:25.807]  length: 6
[13:20:25.807]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:25.807] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.808] - nx: 6
[13:20:25.808] - relay: TRUE
[13:20:25.808] - stdout: TRUE
[13:20:25.808] - signal: TRUE
[13:20:25.808] - resignal: FALSE
[13:20:25.809] - force: TRUE
[13:20:25.809] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.809] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.809]  - until=2
[13:20:25.809]  - relaying element #2
[13:20:25.809] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.809] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.810] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.810]  length: 5 (resolved future 1)
[13:20:25.810] Future #2
[13:20:25.811] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:25.812] - nx: 6
[13:20:25.812] - relay: TRUE
[13:20:25.817] - stdout: TRUE
[13:20:25.817] - signal: TRUE
[13:20:25.817] - resignal: FALSE
[13:20:25.818] - force: TRUE
[13:20:25.818] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.818] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.818]  - until=2
[13:20:25.819]  - relaying element #2
[13:20:25.819] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.819] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.820] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:25.820]  length: 4 (resolved future 2)
[13:20:25.820] Future #3
[13:20:25.821] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:25.822] - nx: 6
[13:20:25.822] - relay: TRUE
[13:20:25.822] - stdout: TRUE
[13:20:25.822] - signal: TRUE
[13:20:25.822] - resignal: FALSE
[13:20:25.822] - force: TRUE
[13:20:25.822] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.822] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.823]  - until=3
[13:20:25.823]  - relaying element #3
[13:20:25.823] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.823] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.823] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:25.823]  length: 3 (resolved future 3)
[13:20:25.824] signalConditionsASAP(NULL, pos=4) ...
[13:20:25.824] - nx: 6
[13:20:25.824] - relay: TRUE
[13:20:25.824] - stdout: TRUE
[13:20:25.824] - signal: TRUE
[13:20:25.824] - resignal: FALSE
[13:20:25.824] - force: TRUE
[13:20:25.825] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.825] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.825]  - until=5
[13:20:25.825]  - relaying element #5
[13:20:25.825] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.825] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.825] signalConditionsASAP(NULL, pos=4) ... done
[13:20:25.825]  length: 2 (resolved future 4)
[13:20:25.825] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.826] - nx: 6
[13:20:25.826] - relay: TRUE
[13:20:25.826] - stdout: TRUE
[13:20:25.826] - signal: TRUE
[13:20:25.826] - resignal: FALSE
[13:20:25.826] - force: TRUE
[13:20:25.826] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.826] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.826]  - until=6
[13:20:25.827]  - relaying element #6
[13:20:25.827] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.827] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.827] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.827]  length: 1 (resolved future 5)
[13:20:25.827] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.827] - nx: 6
[13:20:25.827] - relay: TRUE
[13:20:25.827] - stdout: TRUE
[13:20:25.828] - signal: TRUE
[13:20:25.828] - resignal: FALSE
[13:20:25.828] - force: TRUE
[13:20:25.828] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.828] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.828]  - until=6
[13:20:25.828] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.828] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.828] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.828]  length: 0 (resolved future 6)
[13:20:25.829] Relaying remaining futures
[13:20:25.829] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.829] - nx: 6
[13:20:25.829] - relay: TRUE
[13:20:25.829] - stdout: TRUE
[13:20:25.829] - signal: TRUE
[13:20:25.829] - resignal: FALSE
[13:20:25.829] - force: TRUE
[13:20:25.829] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.829] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:25.830] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.830] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.830] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.830] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:20:25.834] getGlobalsAndPackages() ...
[13:20:25.834] Searching for globals...
[13:20:25.834] 
[13:20:25.834] Searching for globals ... DONE
[13:20:25.835] - globals: [0] <none>
[13:20:25.835] getGlobalsAndPackages() ... DONE
[13:20:25.835] run() for ‘Future’ ...
[13:20:25.835] - state: ‘created’
[13:20:25.835] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:25.839] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:25.839] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:25.839]   - Field: ‘label’
[13:20:25.840]   - Field: ‘local’
[13:20:25.840]   - Field: ‘owner’
[13:20:25.840]   - Field: ‘envir’
[13:20:25.840]   - Field: ‘workers’
[13:20:25.840]   - Field: ‘packages’
[13:20:25.840]   - Field: ‘gc’
[13:20:25.840]   - Field: ‘job’
[13:20:25.840]   - Field: ‘conditions’
[13:20:25.840]   - Field: ‘expr’
[13:20:25.840]   - Field: ‘uuid’
[13:20:25.841]   - Field: ‘seed’
[13:20:25.841]   - Field: ‘version’
[13:20:25.841]   - Field: ‘result’
[13:20:25.841]   - Field: ‘asynchronous’
[13:20:25.841]   - Field: ‘calls’
[13:20:25.841]   - Field: ‘globals’
[13:20:25.841]   - Field: ‘stdout’
[13:20:25.841]   - Field: ‘earlySignal’
[13:20:25.841]   - Field: ‘lazy’
[13:20:25.842]   - Field: ‘state’
[13:20:25.842] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:25.842] - Launch lazy future ...
[13:20:25.842] Packages needed by the future expression (n = 0): <none>
[13:20:25.842] Packages needed by future strategies (n = 0): <none>
[13:20:25.843] {
[13:20:25.843]     {
[13:20:25.843]         {
[13:20:25.843]             ...future.startTime <- base::Sys.time()
[13:20:25.843]             {
[13:20:25.843]                 {
[13:20:25.843]                   {
[13:20:25.843]                     {
[13:20:25.843]                       base::local({
[13:20:25.843]                         has_future <- base::requireNamespace("future", 
[13:20:25.843]                           quietly = TRUE)
[13:20:25.843]                         if (has_future) {
[13:20:25.843]                           ns <- base::getNamespace("future")
[13:20:25.843]                           version <- ns[[".package"]][["version"]]
[13:20:25.843]                           if (is.null(version)) 
[13:20:25.843]                             version <- utils::packageVersion("future")
[13:20:25.843]                         }
[13:20:25.843]                         else {
[13:20:25.843]                           version <- NULL
[13:20:25.843]                         }
[13:20:25.843]                         if (!has_future || version < "1.8.0") {
[13:20:25.843]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.843]                             "", base::R.version$version.string), 
[13:20:25.843]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:25.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.843]                               "release", "version")], collapse = " "), 
[13:20:25.843]                             hostname = base::Sys.info()[["nodename"]])
[13:20:25.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.843]                             info)
[13:20:25.843]                           info <- base::paste(info, collapse = "; ")
[13:20:25.843]                           if (!has_future) {
[13:20:25.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.843]                               info)
[13:20:25.843]                           }
[13:20:25.843]                           else {
[13:20:25.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.843]                               info, version)
[13:20:25.843]                           }
[13:20:25.843]                           base::stop(msg)
[13:20:25.843]                         }
[13:20:25.843]                       })
[13:20:25.843]                     }
[13:20:25.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:25.843]                     base::options(mc.cores = 1L)
[13:20:25.843]                   }
[13:20:25.843]                   options(future.plan = NULL)
[13:20:25.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.843]                 }
[13:20:25.843]                 ...future.workdir <- getwd()
[13:20:25.843]             }
[13:20:25.843]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.843]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.843]         }
[13:20:25.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.843]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.843]             base::names(...future.oldOptions))
[13:20:25.843]     }
[13:20:25.843]     if (FALSE) {
[13:20:25.843]     }
[13:20:25.843]     else {
[13:20:25.843]         if (TRUE) {
[13:20:25.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.843]                 open = "w")
[13:20:25.843]         }
[13:20:25.843]         else {
[13:20:25.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.843]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.843]         }
[13:20:25.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.843]             base::sink(type = "output", split = FALSE)
[13:20:25.843]             base::close(...future.stdout)
[13:20:25.843]         }, add = TRUE)
[13:20:25.843]     }
[13:20:25.843]     ...future.frame <- base::sys.nframe()
[13:20:25.843]     ...future.conditions <- base::list()
[13:20:25.843]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.843]     if (FALSE) {
[13:20:25.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.843]     }
[13:20:25.843]     ...future.result <- base::tryCatch({
[13:20:25.843]         base::withCallingHandlers({
[13:20:25.843]             ...future.value <- base::withVisible(base::local({
[13:20:25.843]                 withCallingHandlers({
[13:20:25.843]                   2
[13:20:25.843]                 }, immediateCondition = function(cond) {
[13:20:25.843]                   save_rds <- function (object, pathname, ...) 
[13:20:25.843]                   {
[13:20:25.843]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:25.843]                     if (file_test("-f", pathname_tmp)) {
[13:20:25.843]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.843]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:25.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.843]                         fi_tmp[["mtime"]])
[13:20:25.843]                     }
[13:20:25.843]                     tryCatch({
[13:20:25.843]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:25.843]                     }, error = function(ex) {
[13:20:25.843]                       msg <- conditionMessage(ex)
[13:20:25.843]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.843]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:25.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.843]                         fi_tmp[["mtime"]], msg)
[13:20:25.843]                       ex$message <- msg
[13:20:25.843]                       stop(ex)
[13:20:25.843]                     })
[13:20:25.843]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:25.843]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:25.843]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:25.843]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.843]                       fi <- file.info(pathname)
[13:20:25.843]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:25.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.843]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:25.843]                         fi[["size"]], fi[["mtime"]])
[13:20:25.843]                       stop(msg)
[13:20:25.843]                     }
[13:20:25.843]                     invisible(pathname)
[13:20:25.843]                   }
[13:20:25.843]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:25.843]                     rootPath = tempdir()) 
[13:20:25.843]                   {
[13:20:25.843]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:25.843]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:25.843]                       tmpdir = path, fileext = ".rds")
[13:20:25.843]                     save_rds(obj, file)
[13:20:25.843]                   }
[13:20:25.843]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:25.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.843]                   {
[13:20:25.843]                     inherits <- base::inherits
[13:20:25.843]                     invokeRestart <- base::invokeRestart
[13:20:25.843]                     is.null <- base::is.null
[13:20:25.843]                     muffled <- FALSE
[13:20:25.843]                     if (inherits(cond, "message")) {
[13:20:25.843]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:25.843]                       if (muffled) 
[13:20:25.843]                         invokeRestart("muffleMessage")
[13:20:25.843]                     }
[13:20:25.843]                     else if (inherits(cond, "warning")) {
[13:20:25.843]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:25.843]                       if (muffled) 
[13:20:25.843]                         invokeRestart("muffleWarning")
[13:20:25.843]                     }
[13:20:25.843]                     else if (inherits(cond, "condition")) {
[13:20:25.843]                       if (!is.null(pattern)) {
[13:20:25.843]                         computeRestarts <- base::computeRestarts
[13:20:25.843]                         grepl <- base::grepl
[13:20:25.843]                         restarts <- computeRestarts(cond)
[13:20:25.843]                         for (restart in restarts) {
[13:20:25.843]                           name <- restart$name
[13:20:25.843]                           if (is.null(name)) 
[13:20:25.843]                             next
[13:20:25.843]                           if (!grepl(pattern, name)) 
[13:20:25.843]                             next
[13:20:25.843]                           invokeRestart(restart)
[13:20:25.843]                           muffled <- TRUE
[13:20:25.843]                           break
[13:20:25.843]                         }
[13:20:25.843]                       }
[13:20:25.843]                     }
[13:20:25.843]                     invisible(muffled)
[13:20:25.843]                   }
[13:20:25.843]                   muffleCondition(cond)
[13:20:25.843]                 })
[13:20:25.843]             }))
[13:20:25.843]             future::FutureResult(value = ...future.value$value, 
[13:20:25.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.843]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.843]                     ...future.globalenv.names))
[13:20:25.843]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.843]         }, condition = base::local({
[13:20:25.843]             c <- base::c
[13:20:25.843]             inherits <- base::inherits
[13:20:25.843]             invokeRestart <- base::invokeRestart
[13:20:25.843]             length <- base::length
[13:20:25.843]             list <- base::list
[13:20:25.843]             seq.int <- base::seq.int
[13:20:25.843]             signalCondition <- base::signalCondition
[13:20:25.843]             sys.calls <- base::sys.calls
[13:20:25.843]             `[[` <- base::`[[`
[13:20:25.843]             `+` <- base::`+`
[13:20:25.843]             `<<-` <- base::`<<-`
[13:20:25.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.843]                   3L)]
[13:20:25.843]             }
[13:20:25.843]             function(cond) {
[13:20:25.843]                 is_error <- inherits(cond, "error")
[13:20:25.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.843]                   NULL)
[13:20:25.843]                 if (is_error) {
[13:20:25.843]                   sessionInformation <- function() {
[13:20:25.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.843]                       search = base::search(), system = base::Sys.info())
[13:20:25.843]                   }
[13:20:25.843]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.843]                     cond$call), session = sessionInformation(), 
[13:20:25.843]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.843]                   signalCondition(cond)
[13:20:25.843]                 }
[13:20:25.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.843]                 "immediateCondition"))) {
[13:20:25.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.843]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.843]                   if (TRUE && !signal) {
[13:20:25.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.843]                     {
[13:20:25.843]                       inherits <- base::inherits
[13:20:25.843]                       invokeRestart <- base::invokeRestart
[13:20:25.843]                       is.null <- base::is.null
[13:20:25.843]                       muffled <- FALSE
[13:20:25.843]                       if (inherits(cond, "message")) {
[13:20:25.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.843]                         if (muffled) 
[13:20:25.843]                           invokeRestart("muffleMessage")
[13:20:25.843]                       }
[13:20:25.843]                       else if (inherits(cond, "warning")) {
[13:20:25.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.843]                         if (muffled) 
[13:20:25.843]                           invokeRestart("muffleWarning")
[13:20:25.843]                       }
[13:20:25.843]                       else if (inherits(cond, "condition")) {
[13:20:25.843]                         if (!is.null(pattern)) {
[13:20:25.843]                           computeRestarts <- base::computeRestarts
[13:20:25.843]                           grepl <- base::grepl
[13:20:25.843]                           restarts <- computeRestarts(cond)
[13:20:25.843]                           for (restart in restarts) {
[13:20:25.843]                             name <- restart$name
[13:20:25.843]                             if (is.null(name)) 
[13:20:25.843]                               next
[13:20:25.843]                             if (!grepl(pattern, name)) 
[13:20:25.843]                               next
[13:20:25.843]                             invokeRestart(restart)
[13:20:25.843]                             muffled <- TRUE
[13:20:25.843]                             break
[13:20:25.843]                           }
[13:20:25.843]                         }
[13:20:25.843]                       }
[13:20:25.843]                       invisible(muffled)
[13:20:25.843]                     }
[13:20:25.843]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.843]                   }
[13:20:25.843]                 }
[13:20:25.843]                 else {
[13:20:25.843]                   if (TRUE) {
[13:20:25.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.843]                     {
[13:20:25.843]                       inherits <- base::inherits
[13:20:25.843]                       invokeRestart <- base::invokeRestart
[13:20:25.843]                       is.null <- base::is.null
[13:20:25.843]                       muffled <- FALSE
[13:20:25.843]                       if (inherits(cond, "message")) {
[13:20:25.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.843]                         if (muffled) 
[13:20:25.843]                           invokeRestart("muffleMessage")
[13:20:25.843]                       }
[13:20:25.843]                       else if (inherits(cond, "warning")) {
[13:20:25.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.843]                         if (muffled) 
[13:20:25.843]                           invokeRestart("muffleWarning")
[13:20:25.843]                       }
[13:20:25.843]                       else if (inherits(cond, "condition")) {
[13:20:25.843]                         if (!is.null(pattern)) {
[13:20:25.843]                           computeRestarts <- base::computeRestarts
[13:20:25.843]                           grepl <- base::grepl
[13:20:25.843]                           restarts <- computeRestarts(cond)
[13:20:25.843]                           for (restart in restarts) {
[13:20:25.843]                             name <- restart$name
[13:20:25.843]                             if (is.null(name)) 
[13:20:25.843]                               next
[13:20:25.843]                             if (!grepl(pattern, name)) 
[13:20:25.843]                               next
[13:20:25.843]                             invokeRestart(restart)
[13:20:25.843]                             muffled <- TRUE
[13:20:25.843]                             break
[13:20:25.843]                           }
[13:20:25.843]                         }
[13:20:25.843]                       }
[13:20:25.843]                       invisible(muffled)
[13:20:25.843]                     }
[13:20:25.843]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.843]                   }
[13:20:25.843]                 }
[13:20:25.843]             }
[13:20:25.843]         }))
[13:20:25.843]     }, error = function(ex) {
[13:20:25.843]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.843]                 ...future.rng), started = ...future.startTime, 
[13:20:25.843]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.843]             version = "1.8"), class = "FutureResult")
[13:20:25.843]     }, finally = {
[13:20:25.843]         if (!identical(...future.workdir, getwd())) 
[13:20:25.843]             setwd(...future.workdir)
[13:20:25.843]         {
[13:20:25.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.843]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.843]             }
[13:20:25.843]             base::options(...future.oldOptions)
[13:20:25.843]             if (.Platform$OS.type == "windows") {
[13:20:25.843]                 old_names <- names(...future.oldEnvVars)
[13:20:25.843]                 envs <- base::Sys.getenv()
[13:20:25.843]                 names <- names(envs)
[13:20:25.843]                 common <- intersect(names, old_names)
[13:20:25.843]                 added <- setdiff(names, old_names)
[13:20:25.843]                 removed <- setdiff(old_names, names)
[13:20:25.843]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.843]                   envs[common]]
[13:20:25.843]                 NAMES <- toupper(changed)
[13:20:25.843]                 args <- list()
[13:20:25.843]                 for (kk in seq_along(NAMES)) {
[13:20:25.843]                   name <- changed[[kk]]
[13:20:25.843]                   NAME <- NAMES[[kk]]
[13:20:25.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.843]                     next
[13:20:25.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.843]                 }
[13:20:25.843]                 NAMES <- toupper(added)
[13:20:25.843]                 for (kk in seq_along(NAMES)) {
[13:20:25.843]                   name <- added[[kk]]
[13:20:25.843]                   NAME <- NAMES[[kk]]
[13:20:25.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.843]                     next
[13:20:25.843]                   args[[name]] <- ""
[13:20:25.843]                 }
[13:20:25.843]                 NAMES <- toupper(removed)
[13:20:25.843]                 for (kk in seq_along(NAMES)) {
[13:20:25.843]                   name <- removed[[kk]]
[13:20:25.843]                   NAME <- NAMES[[kk]]
[13:20:25.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.843]                     next
[13:20:25.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.843]                 }
[13:20:25.843]                 if (length(args) > 0) 
[13:20:25.843]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.843]             }
[13:20:25.843]             else {
[13:20:25.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.843]             }
[13:20:25.843]             {
[13:20:25.843]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.843]                   0L) {
[13:20:25.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.843]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.843]                   base::options(opts)
[13:20:25.843]                 }
[13:20:25.843]                 {
[13:20:25.843]                   {
[13:20:25.843]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:25.843]                     NULL
[13:20:25.843]                   }
[13:20:25.843]                   options(future.plan = NULL)
[13:20:25.843]                   if (is.na(NA_character_)) 
[13:20:25.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.843]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:25.843]                     envir = parent.frame()) 
[13:20:25.843]                   {
[13:20:25.843]                     default_workers <- missing(workers)
[13:20:25.843]                     if (is.function(workers)) 
[13:20:25.843]                       workers <- workers()
[13:20:25.843]                     workers <- structure(as.integer(workers), 
[13:20:25.843]                       class = class(workers))
[13:20:25.843]                     stop_if_not(is.finite(workers), workers >= 
[13:20:25.843]                       1L)
[13:20:25.843]                     if ((workers == 1L && !inherits(workers, 
[13:20:25.843]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:25.843]                       if (default_workers) 
[13:20:25.843]                         supportsMulticore(warn = TRUE)
[13:20:25.843]                       return(sequential(..., envir = envir))
[13:20:25.843]                     }
[13:20:25.843]                     oopts <- options(mc.cores = workers)
[13:20:25.843]                     on.exit(options(oopts))
[13:20:25.843]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:25.843]                       envir = envir)
[13:20:25.843]                     if (!future$lazy) 
[13:20:25.843]                       future <- run(future)
[13:20:25.843]                     invisible(future)
[13:20:25.843]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.843]                 }
[13:20:25.843]             }
[13:20:25.843]         }
[13:20:25.843]     })
[13:20:25.843]     if (TRUE) {
[13:20:25.843]         base::sink(type = "output", split = FALSE)
[13:20:25.843]         if (TRUE) {
[13:20:25.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.843]         }
[13:20:25.843]         else {
[13:20:25.843]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.843]         }
[13:20:25.843]         base::close(...future.stdout)
[13:20:25.843]         ...future.stdout <- NULL
[13:20:25.843]     }
[13:20:25.843]     ...future.result$conditions <- ...future.conditions
[13:20:25.843]     ...future.result$finished <- base::Sys.time()
[13:20:25.843]     ...future.result
[13:20:25.843] }
[13:20:25.845] requestCore(): workers = 2
[13:20:25.847] MulticoreFuture started
[13:20:25.848] - Launch lazy future ... done
[13:20:25.848] run() for ‘MulticoreFuture’ ... done
[13:20:25.848] getGlobalsAndPackages() ...
[13:20:25.848] Searching for globals...
[13:20:25.848] plan(): Setting new future strategy stack:
[13:20:25.849] 
[13:20:25.849] List of future strategies:
[13:20:25.849] 1. sequential:
[13:20:25.849]    - args: function (..., envir = parent.frame())
[13:20:25.849]    - tweaked: FALSE
[13:20:25.849]    - call: NULL
[13:20:25.849] Searching for globals ... DONE
[13:20:25.850] - globals: [0] <none>
[13:20:25.850] plan(): nbrOfWorkers() = 1
[13:20:25.850] getGlobalsAndPackages() ... DONE
[13:20:25.850] run() for ‘Future’ ...
[13:20:25.850] - state: ‘created’
[13:20:25.851] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:25.851] plan(): Setting new future strategy stack:
[13:20:25.852] List of future strategies:
[13:20:25.852] 1. multicore:
[13:20:25.852]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:25.852]    - tweaked: FALSE
[13:20:25.852]    - call: plan(strategy)
[13:20:25.856] plan(): nbrOfWorkers() = 2
[13:20:25.856] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:25.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:25.857]   - Field: ‘label’
[13:20:25.857]   - Field: ‘local’
[13:20:25.857]   - Field: ‘owner’
[13:20:25.857]   - Field: ‘envir’
[13:20:25.858]   - Field: ‘workers’
[13:20:25.858]   - Field: ‘packages’
[13:20:25.858]   - Field: ‘gc’
[13:20:25.858]   - Field: ‘job’
[13:20:25.858]   - Field: ‘conditions’
[13:20:25.858]   - Field: ‘expr’
[13:20:25.858]   - Field: ‘uuid’
[13:20:25.859]   - Field: ‘seed’
[13:20:25.859]   - Field: ‘version’
[13:20:25.859]   - Field: ‘result’
[13:20:25.859]   - Field: ‘asynchronous’
[13:20:25.859]   - Field: ‘calls’
[13:20:25.863]   - Field: ‘globals’
[13:20:25.864]   - Field: ‘stdout’
[13:20:25.864]   - Field: ‘earlySignal’
[13:20:25.864]   - Field: ‘lazy’
[13:20:25.864]   - Field: ‘state’
[13:20:25.865] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:25.865] - Launch lazy future ...
[13:20:25.866] Packages needed by the future expression (n = 0): <none>
[13:20:25.866] Packages needed by future strategies (n = 0): <none>
[13:20:25.868] {
[13:20:25.868]     {
[13:20:25.868]         {
[13:20:25.868]             ...future.startTime <- base::Sys.time()
[13:20:25.868]             {
[13:20:25.868]                 {
[13:20:25.868]                   {
[13:20:25.868]                     {
[13:20:25.868]                       base::local({
[13:20:25.868]                         has_future <- base::requireNamespace("future", 
[13:20:25.868]                           quietly = TRUE)
[13:20:25.868]                         if (has_future) {
[13:20:25.868]                           ns <- base::getNamespace("future")
[13:20:25.868]                           version <- ns[[".package"]][["version"]]
[13:20:25.868]                           if (is.null(version)) 
[13:20:25.868]                             version <- utils::packageVersion("future")
[13:20:25.868]                         }
[13:20:25.868]                         else {
[13:20:25.868]                           version <- NULL
[13:20:25.868]                         }
[13:20:25.868]                         if (!has_future || version < "1.8.0") {
[13:20:25.868]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.868]                             "", base::R.version$version.string), 
[13:20:25.868]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:25.868]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.868]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.868]                               "release", "version")], collapse = " "), 
[13:20:25.868]                             hostname = base::Sys.info()[["nodename"]])
[13:20:25.868]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.868]                             info)
[13:20:25.868]                           info <- base::paste(info, collapse = "; ")
[13:20:25.868]                           if (!has_future) {
[13:20:25.868]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.868]                               info)
[13:20:25.868]                           }
[13:20:25.868]                           else {
[13:20:25.868]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.868]                               info, version)
[13:20:25.868]                           }
[13:20:25.868]                           base::stop(msg)
[13:20:25.868]                         }
[13:20:25.868]                       })
[13:20:25.868]                     }
[13:20:25.868]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:25.868]                     base::options(mc.cores = 1L)
[13:20:25.868]                   }
[13:20:25.868]                   options(future.plan = NULL)
[13:20:25.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.868]                 }
[13:20:25.868]                 ...future.workdir <- getwd()
[13:20:25.868]             }
[13:20:25.868]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.868]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.868]         }
[13:20:25.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.868]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.868]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.868]             base::names(...future.oldOptions))
[13:20:25.868]     }
[13:20:25.868]     if (FALSE) {
[13:20:25.868]     }
[13:20:25.868]     else {
[13:20:25.868]         if (TRUE) {
[13:20:25.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.868]                 open = "w")
[13:20:25.868]         }
[13:20:25.868]         else {
[13:20:25.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.868]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.868]         }
[13:20:25.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.868]             base::sink(type = "output", split = FALSE)
[13:20:25.868]             base::close(...future.stdout)
[13:20:25.868]         }, add = TRUE)
[13:20:25.868]     }
[13:20:25.868]     ...future.frame <- base::sys.nframe()
[13:20:25.868]     ...future.conditions <- base::list()
[13:20:25.868]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.868]     if (FALSE) {
[13:20:25.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.868]     }
[13:20:25.868]     ...future.result <- base::tryCatch({
[13:20:25.868]         base::withCallingHandlers({
[13:20:25.868]             ...future.value <- base::withVisible(base::local({
[13:20:25.868]                 withCallingHandlers({
[13:20:25.868]                   NULL
[13:20:25.868]                 }, immediateCondition = function(cond) {
[13:20:25.868]                   save_rds <- function (object, pathname, ...) 
[13:20:25.868]                   {
[13:20:25.868]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:25.868]                     if (file_test("-f", pathname_tmp)) {
[13:20:25.868]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.868]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:25.868]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.868]                         fi_tmp[["mtime"]])
[13:20:25.868]                     }
[13:20:25.868]                     tryCatch({
[13:20:25.868]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:25.868]                     }, error = function(ex) {
[13:20:25.868]                       msg <- conditionMessage(ex)
[13:20:25.868]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.868]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:25.868]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.868]                         fi_tmp[["mtime"]], msg)
[13:20:25.868]                       ex$message <- msg
[13:20:25.868]                       stop(ex)
[13:20:25.868]                     })
[13:20:25.868]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:25.868]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:25.868]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:25.868]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.868]                       fi <- file.info(pathname)
[13:20:25.868]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:25.868]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.868]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:25.868]                         fi[["size"]], fi[["mtime"]])
[13:20:25.868]                       stop(msg)
[13:20:25.868]                     }
[13:20:25.868]                     invisible(pathname)
[13:20:25.868]                   }
[13:20:25.868]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:25.868]                     rootPath = tempdir()) 
[13:20:25.868]                   {
[13:20:25.868]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:25.868]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:25.868]                       tmpdir = path, fileext = ".rds")
[13:20:25.868]                     save_rds(obj, file)
[13:20:25.868]                   }
[13:20:25.868]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:25.868]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.868]                   {
[13:20:25.868]                     inherits <- base::inherits
[13:20:25.868]                     invokeRestart <- base::invokeRestart
[13:20:25.868]                     is.null <- base::is.null
[13:20:25.868]                     muffled <- FALSE
[13:20:25.868]                     if (inherits(cond, "message")) {
[13:20:25.868]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:25.868]                       if (muffled) 
[13:20:25.868]                         invokeRestart("muffleMessage")
[13:20:25.868]                     }
[13:20:25.868]                     else if (inherits(cond, "warning")) {
[13:20:25.868]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:25.868]                       if (muffled) 
[13:20:25.868]                         invokeRestart("muffleWarning")
[13:20:25.868]                     }
[13:20:25.868]                     else if (inherits(cond, "condition")) {
[13:20:25.868]                       if (!is.null(pattern)) {
[13:20:25.868]                         computeRestarts <- base::computeRestarts
[13:20:25.868]                         grepl <- base::grepl
[13:20:25.868]                         restarts <- computeRestarts(cond)
[13:20:25.868]                         for (restart in restarts) {
[13:20:25.868]                           name <- restart$name
[13:20:25.868]                           if (is.null(name)) 
[13:20:25.868]                             next
[13:20:25.868]                           if (!grepl(pattern, name)) 
[13:20:25.868]                             next
[13:20:25.868]                           invokeRestart(restart)
[13:20:25.868]                           muffled <- TRUE
[13:20:25.868]                           break
[13:20:25.868]                         }
[13:20:25.868]                       }
[13:20:25.868]                     }
[13:20:25.868]                     invisible(muffled)
[13:20:25.868]                   }
[13:20:25.868]                   muffleCondition(cond)
[13:20:25.868]                 })
[13:20:25.868]             }))
[13:20:25.868]             future::FutureResult(value = ...future.value$value, 
[13:20:25.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.868]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.868]                     ...future.globalenv.names))
[13:20:25.868]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.868]         }, condition = base::local({
[13:20:25.868]             c <- base::c
[13:20:25.868]             inherits <- base::inherits
[13:20:25.868]             invokeRestart <- base::invokeRestart
[13:20:25.868]             length <- base::length
[13:20:25.868]             list <- base::list
[13:20:25.868]             seq.int <- base::seq.int
[13:20:25.868]             signalCondition <- base::signalCondition
[13:20:25.868]             sys.calls <- base::sys.calls
[13:20:25.868]             `[[` <- base::`[[`
[13:20:25.868]             `+` <- base::`+`
[13:20:25.868]             `<<-` <- base::`<<-`
[13:20:25.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.868]                   3L)]
[13:20:25.868]             }
[13:20:25.868]             function(cond) {
[13:20:25.868]                 is_error <- inherits(cond, "error")
[13:20:25.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.868]                   NULL)
[13:20:25.868]                 if (is_error) {
[13:20:25.868]                   sessionInformation <- function() {
[13:20:25.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.868]                       search = base::search(), system = base::Sys.info())
[13:20:25.868]                   }
[13:20:25.868]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.868]                     cond$call), session = sessionInformation(), 
[13:20:25.868]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.868]                   signalCondition(cond)
[13:20:25.868]                 }
[13:20:25.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.868]                 "immediateCondition"))) {
[13:20:25.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.868]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.868]                   if (TRUE && !signal) {
[13:20:25.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.868]                     {
[13:20:25.868]                       inherits <- base::inherits
[13:20:25.868]                       invokeRestart <- base::invokeRestart
[13:20:25.868]                       is.null <- base::is.null
[13:20:25.868]                       muffled <- FALSE
[13:20:25.868]                       if (inherits(cond, "message")) {
[13:20:25.868]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.868]                         if (muffled) 
[13:20:25.868]                           invokeRestart("muffleMessage")
[13:20:25.868]                       }
[13:20:25.868]                       else if (inherits(cond, "warning")) {
[13:20:25.868]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.868]                         if (muffled) 
[13:20:25.868]                           invokeRestart("muffleWarning")
[13:20:25.868]                       }
[13:20:25.868]                       else if (inherits(cond, "condition")) {
[13:20:25.868]                         if (!is.null(pattern)) {
[13:20:25.868]                           computeRestarts <- base::computeRestarts
[13:20:25.868]                           grepl <- base::grepl
[13:20:25.868]                           restarts <- computeRestarts(cond)
[13:20:25.868]                           for (restart in restarts) {
[13:20:25.868]                             name <- restart$name
[13:20:25.868]                             if (is.null(name)) 
[13:20:25.868]                               next
[13:20:25.868]                             if (!grepl(pattern, name)) 
[13:20:25.868]                               next
[13:20:25.868]                             invokeRestart(restart)
[13:20:25.868]                             muffled <- TRUE
[13:20:25.868]                             break
[13:20:25.868]                           }
[13:20:25.868]                         }
[13:20:25.868]                       }
[13:20:25.868]                       invisible(muffled)
[13:20:25.868]                     }
[13:20:25.868]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.868]                   }
[13:20:25.868]                 }
[13:20:25.868]                 else {
[13:20:25.868]                   if (TRUE) {
[13:20:25.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.868]                     {
[13:20:25.868]                       inherits <- base::inherits
[13:20:25.868]                       invokeRestart <- base::invokeRestart
[13:20:25.868]                       is.null <- base::is.null
[13:20:25.868]                       muffled <- FALSE
[13:20:25.868]                       if (inherits(cond, "message")) {
[13:20:25.868]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.868]                         if (muffled) 
[13:20:25.868]                           invokeRestart("muffleMessage")
[13:20:25.868]                       }
[13:20:25.868]                       else if (inherits(cond, "warning")) {
[13:20:25.868]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.868]                         if (muffled) 
[13:20:25.868]                           invokeRestart("muffleWarning")
[13:20:25.868]                       }
[13:20:25.868]                       else if (inherits(cond, "condition")) {
[13:20:25.868]                         if (!is.null(pattern)) {
[13:20:25.868]                           computeRestarts <- base::computeRestarts
[13:20:25.868]                           grepl <- base::grepl
[13:20:25.868]                           restarts <- computeRestarts(cond)
[13:20:25.868]                           for (restart in restarts) {
[13:20:25.868]                             name <- restart$name
[13:20:25.868]                             if (is.null(name)) 
[13:20:25.868]                               next
[13:20:25.868]                             if (!grepl(pattern, name)) 
[13:20:25.868]                               next
[13:20:25.868]                             invokeRestart(restart)
[13:20:25.868]                             muffled <- TRUE
[13:20:25.868]                             break
[13:20:25.868]                           }
[13:20:25.868]                         }
[13:20:25.868]                       }
[13:20:25.868]                       invisible(muffled)
[13:20:25.868]                     }
[13:20:25.868]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.868]                   }
[13:20:25.868]                 }
[13:20:25.868]             }
[13:20:25.868]         }))
[13:20:25.868]     }, error = function(ex) {
[13:20:25.868]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.868]                 ...future.rng), started = ...future.startTime, 
[13:20:25.868]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.868]             version = "1.8"), class = "FutureResult")
[13:20:25.868]     }, finally = {
[13:20:25.868]         if (!identical(...future.workdir, getwd())) 
[13:20:25.868]             setwd(...future.workdir)
[13:20:25.868]         {
[13:20:25.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.868]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.868]             }
[13:20:25.868]             base::options(...future.oldOptions)
[13:20:25.868]             if (.Platform$OS.type == "windows") {
[13:20:25.868]                 old_names <- names(...future.oldEnvVars)
[13:20:25.868]                 envs <- base::Sys.getenv()
[13:20:25.868]                 names <- names(envs)
[13:20:25.868]                 common <- intersect(names, old_names)
[13:20:25.868]                 added <- setdiff(names, old_names)
[13:20:25.868]                 removed <- setdiff(old_names, names)
[13:20:25.868]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.868]                   envs[common]]
[13:20:25.868]                 NAMES <- toupper(changed)
[13:20:25.868]                 args <- list()
[13:20:25.868]                 for (kk in seq_along(NAMES)) {
[13:20:25.868]                   name <- changed[[kk]]
[13:20:25.868]                   NAME <- NAMES[[kk]]
[13:20:25.868]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.868]                     next
[13:20:25.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.868]                 }
[13:20:25.868]                 NAMES <- toupper(added)
[13:20:25.868]                 for (kk in seq_along(NAMES)) {
[13:20:25.868]                   name <- added[[kk]]
[13:20:25.868]                   NAME <- NAMES[[kk]]
[13:20:25.868]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.868]                     next
[13:20:25.868]                   args[[name]] <- ""
[13:20:25.868]                 }
[13:20:25.868]                 NAMES <- toupper(removed)
[13:20:25.868]                 for (kk in seq_along(NAMES)) {
[13:20:25.868]                   name <- removed[[kk]]
[13:20:25.868]                   NAME <- NAMES[[kk]]
[13:20:25.868]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.868]                     next
[13:20:25.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.868]                 }
[13:20:25.868]                 if (length(args) > 0) 
[13:20:25.868]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.868]             }
[13:20:25.868]             else {
[13:20:25.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.868]             }
[13:20:25.868]             {
[13:20:25.868]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.868]                   0L) {
[13:20:25.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.868]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.868]                   base::options(opts)
[13:20:25.868]                 }
[13:20:25.868]                 {
[13:20:25.868]                   {
[13:20:25.868]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:25.868]                     NULL
[13:20:25.868]                   }
[13:20:25.868]                   options(future.plan = NULL)
[13:20:25.868]                   if (is.na(NA_character_)) 
[13:20:25.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.868]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:25.868]                     envir = parent.frame()) 
[13:20:25.868]                   {
[13:20:25.868]                     default_workers <- missing(workers)
[13:20:25.868]                     if (is.function(workers)) 
[13:20:25.868]                       workers <- workers()
[13:20:25.868]                     workers <- structure(as.integer(workers), 
[13:20:25.868]                       class = class(workers))
[13:20:25.868]                     stop_if_not(is.finite(workers), workers >= 
[13:20:25.868]                       1L)
[13:20:25.868]                     if ((workers == 1L && !inherits(workers, 
[13:20:25.868]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:25.868]                       if (default_workers) 
[13:20:25.868]                         supportsMulticore(warn = TRUE)
[13:20:25.868]                       return(sequential(..., envir = envir))
[13:20:25.868]                     }
[13:20:25.868]                     oopts <- options(mc.cores = workers)
[13:20:25.868]                     on.exit(options(oopts))
[13:20:25.868]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:25.868]                       envir = envir)
[13:20:25.868]                     if (!future$lazy) 
[13:20:25.868]                       future <- run(future)
[13:20:25.868]                     invisible(future)
[13:20:25.868]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.868]                 }
[13:20:25.868]             }
[13:20:25.868]         }
[13:20:25.868]     })
[13:20:25.868]     if (TRUE) {
[13:20:25.868]         base::sink(type = "output", split = FALSE)
[13:20:25.868]         if (TRUE) {
[13:20:25.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.868]         }
[13:20:25.868]         else {
[13:20:25.868]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.868]         }
[13:20:25.868]         base::close(...future.stdout)
[13:20:25.868]         ...future.stdout <- NULL
[13:20:25.868]     }
[13:20:25.868]     ...future.result$conditions <- ...future.conditions
[13:20:25.868]     ...future.result$finished <- base::Sys.time()
[13:20:25.868]     ...future.result
[13:20:25.868] }
[13:20:25.871] requestCore(): workers = 2
[13:20:25.873] MulticoreFuture started
[13:20:25.874] - Launch lazy future ... done
[13:20:25.874] run() for ‘MulticoreFuture’ ... done
[13:20:25.875] plan(): Setting new future strategy stack:
List of 6
 $ a:[13:20:25.875] List of future strategies:
[13:20:25.875] 1. sequential:
[13:20:25.875]    - args: function (..., envir = parent.frame())
[13:20:25.875]    - tweaked: FALSE
[13:20:25.875]    - call: NULL
[13:20:25.876] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659ba0a288> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659bdf39c0> 
 $  : NULL
 $  : NULL
[13:20:25.878] plan(): Setting new future strategy stack:
 $  :[13:20:25.878] List of future strategies:
[13:20:25.878] 1. multicore:
[13:20:25.878]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:25.878]    - tweaked: FALSE
[13:20:25.878]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659ba0a288> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659bdf39c0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ :[13:20:25.885] plan(): nbrOfWorkers() = 2
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:25.890] resolve() on list ...
[13:20:25.890]  recursive: 0
[13:20:25.890]  length: 6
[13:20:25.890]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:25.890] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.891] - nx: 6
[13:20:25.891] - relay: TRUE
[13:20:25.891] - stdout: TRUE
[13:20:25.891] - signal: TRUE
[13:20:25.891] - resignal: FALSE
[13:20:25.891] - force: TRUE
[13:20:25.891] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.892] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.892]  - until=2
[13:20:25.892]  - relaying element #2
[13:20:25.892] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.892] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.892] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.893]  length: 5 (resolved future 1)
[13:20:25.893] Future #2
[13:20:25.894] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:25.894] - nx: 6
[13:20:25.894] - relay: TRUE
[13:20:25.894] - stdout: TRUE
[13:20:25.894] - signal: TRUE
[13:20:25.895] - resignal: FALSE
[13:20:25.895] - force: TRUE
[13:20:25.895] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.895] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.895]  - until=2
[13:20:25.895]  - relaying element #2
[13:20:25.896] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.896] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.896] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:25.896]  length: 4 (resolved future 2)
[13:20:25.896] Future #3
[13:20:25.897] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:25.897] - nx: 6
[13:20:25.898] - relay: TRUE
[13:20:25.898] - stdout: TRUE
[13:20:25.898] - signal: TRUE
[13:20:25.898] - resignal: FALSE
[13:20:25.898] - force: TRUE
[13:20:25.898] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.898] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.899]  - until=3
[13:20:25.899]  - relaying element #3
[13:20:25.899] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.899] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.900] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:25.900]  length: 3 (resolved future 3)
[13:20:25.900] signalConditionsASAP(NULL, pos=4) ...
[13:20:25.900] - nx: 6
[13:20:25.900] - relay: TRUE
[13:20:25.900] - stdout: TRUE
[13:20:25.900] - signal: TRUE
[13:20:25.901] - resignal: FALSE
[13:20:25.901] - force: TRUE
[13:20:25.901] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.901] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.901]  - until=5
[13:20:25.901]  - relaying element #5
[13:20:25.901] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.901] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.901] signalConditionsASAP(NULL, pos=4) ... done
[13:20:25.902]  length: 2 (resolved future 4)
[13:20:25.902] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.902] - nx: 6
[13:20:25.902] - relay: TRUE
[13:20:25.902] - stdout: TRUE
[13:20:25.902] - signal: TRUE
[13:20:25.902] - resignal: FALSE
[13:20:25.902] - force: TRUE
[13:20:25.902] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.903] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.903]  - until=6
[13:20:25.903]  - relaying element #6
[13:20:25.903] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.903] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.903] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.903]  length: 1 (resolved future 5)
[13:20:25.903] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.903] - nx: 6
[13:20:25.903] - relay: TRUE
[13:20:25.904] - stdout: TRUE
[13:20:25.904] - signal: TRUE
[13:20:25.904] - resignal: FALSE
[13:20:25.904] - force: TRUE
[13:20:25.904] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.904] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.904]  - until=6
[13:20:25.904] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.904] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.904] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.905]  length: 0 (resolved future 6)
[13:20:25.905] Relaying remaining futures
[13:20:25.905] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.905] - nx: 6
[13:20:25.905] - relay: TRUE
[13:20:25.905] - stdout: TRUE
[13:20:25.905] - signal: TRUE
[13:20:25.905] - resignal: FALSE
[13:20:25.905] - force: TRUE
[13:20:25.905] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.906] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:25.906] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.906] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.906] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.906] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:20:25.913] getGlobalsAndPackages() ...
[13:20:25.914] Searching for globals...
[13:20:25.914] 
[13:20:25.914] Searching for globals ... DONE
[13:20:25.914] - globals: [0] <none>
[13:20:25.914] getGlobalsAndPackages() ... DONE
[13:20:25.914] run() for ‘Future’ ...
[13:20:25.915] - state: ‘created’
[13:20:25.915] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:25.919] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:25.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:25.919]   - Field: ‘label’
[13:20:25.919]   - Field: ‘local’
[13:20:25.919]   - Field: ‘owner’
[13:20:25.919]   - Field: ‘envir’
[13:20:25.919]   - Field: ‘workers’
[13:20:25.919]   - Field: ‘packages’
[13:20:25.919]   - Field: ‘gc’
[13:20:25.920]   - Field: ‘job’
[13:20:25.920]   - Field: ‘conditions’
[13:20:25.920]   - Field: ‘expr’
[13:20:25.920]   - Field: ‘uuid’
[13:20:25.920]   - Field: ‘seed’
[13:20:25.920]   - Field: ‘version’
[13:20:25.920]   - Field: ‘result’
[13:20:25.920]   - Field: ‘asynchronous’
[13:20:25.920]   - Field: ‘calls’
[13:20:25.920]   - Field: ‘globals’
[13:20:25.921]   - Field: ‘stdout’
[13:20:25.921]   - Field: ‘earlySignal’
[13:20:25.921]   - Field: ‘lazy’
[13:20:25.921]   - Field: ‘state’
[13:20:25.921] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:25.921] - Launch lazy future ...
[13:20:25.921] Packages needed by the future expression (n = 0): <none>
[13:20:25.921] Packages needed by future strategies (n = 0): <none>
[13:20:25.922] {
[13:20:25.922]     {
[13:20:25.922]         {
[13:20:25.922]             ...future.startTime <- base::Sys.time()
[13:20:25.922]             {
[13:20:25.922]                 {
[13:20:25.922]                   {
[13:20:25.922]                     {
[13:20:25.922]                       base::local({
[13:20:25.922]                         has_future <- base::requireNamespace("future", 
[13:20:25.922]                           quietly = TRUE)
[13:20:25.922]                         if (has_future) {
[13:20:25.922]                           ns <- base::getNamespace("future")
[13:20:25.922]                           version <- ns[[".package"]][["version"]]
[13:20:25.922]                           if (is.null(version)) 
[13:20:25.922]                             version <- utils::packageVersion("future")
[13:20:25.922]                         }
[13:20:25.922]                         else {
[13:20:25.922]                           version <- NULL
[13:20:25.922]                         }
[13:20:25.922]                         if (!has_future || version < "1.8.0") {
[13:20:25.922]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.922]                             "", base::R.version$version.string), 
[13:20:25.922]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:25.922]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.922]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.922]                               "release", "version")], collapse = " "), 
[13:20:25.922]                             hostname = base::Sys.info()[["nodename"]])
[13:20:25.922]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.922]                             info)
[13:20:25.922]                           info <- base::paste(info, collapse = "; ")
[13:20:25.922]                           if (!has_future) {
[13:20:25.922]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.922]                               info)
[13:20:25.922]                           }
[13:20:25.922]                           else {
[13:20:25.922]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.922]                               info, version)
[13:20:25.922]                           }
[13:20:25.922]                           base::stop(msg)
[13:20:25.922]                         }
[13:20:25.922]                       })
[13:20:25.922]                     }
[13:20:25.922]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:25.922]                     base::options(mc.cores = 1L)
[13:20:25.922]                   }
[13:20:25.922]                   options(future.plan = NULL)
[13:20:25.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.922]                 }
[13:20:25.922]                 ...future.workdir <- getwd()
[13:20:25.922]             }
[13:20:25.922]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.922]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.922]         }
[13:20:25.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.922]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.922]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.922]             base::names(...future.oldOptions))
[13:20:25.922]     }
[13:20:25.922]     if (FALSE) {
[13:20:25.922]     }
[13:20:25.922]     else {
[13:20:25.922]         if (TRUE) {
[13:20:25.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.922]                 open = "w")
[13:20:25.922]         }
[13:20:25.922]         else {
[13:20:25.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.922]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.922]         }
[13:20:25.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.922]             base::sink(type = "output", split = FALSE)
[13:20:25.922]             base::close(...future.stdout)
[13:20:25.922]         }, add = TRUE)
[13:20:25.922]     }
[13:20:25.922]     ...future.frame <- base::sys.nframe()
[13:20:25.922]     ...future.conditions <- base::list()
[13:20:25.922]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.922]     if (FALSE) {
[13:20:25.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.922]     }
[13:20:25.922]     ...future.result <- base::tryCatch({
[13:20:25.922]         base::withCallingHandlers({
[13:20:25.922]             ...future.value <- base::withVisible(base::local({
[13:20:25.922]                 withCallingHandlers({
[13:20:25.922]                   2
[13:20:25.922]                 }, immediateCondition = function(cond) {
[13:20:25.922]                   save_rds <- function (object, pathname, ...) 
[13:20:25.922]                   {
[13:20:25.922]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:25.922]                     if (file_test("-f", pathname_tmp)) {
[13:20:25.922]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.922]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:25.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.922]                         fi_tmp[["mtime"]])
[13:20:25.922]                     }
[13:20:25.922]                     tryCatch({
[13:20:25.922]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:25.922]                     }, error = function(ex) {
[13:20:25.922]                       msg <- conditionMessage(ex)
[13:20:25.922]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.922]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:25.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.922]                         fi_tmp[["mtime"]], msg)
[13:20:25.922]                       ex$message <- msg
[13:20:25.922]                       stop(ex)
[13:20:25.922]                     })
[13:20:25.922]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:25.922]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:25.922]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:25.922]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.922]                       fi <- file.info(pathname)
[13:20:25.922]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:25.922]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.922]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:25.922]                         fi[["size"]], fi[["mtime"]])
[13:20:25.922]                       stop(msg)
[13:20:25.922]                     }
[13:20:25.922]                     invisible(pathname)
[13:20:25.922]                   }
[13:20:25.922]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:25.922]                     rootPath = tempdir()) 
[13:20:25.922]                   {
[13:20:25.922]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:25.922]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:25.922]                       tmpdir = path, fileext = ".rds")
[13:20:25.922]                     save_rds(obj, file)
[13:20:25.922]                   }
[13:20:25.922]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:25.922]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.922]                   {
[13:20:25.922]                     inherits <- base::inherits
[13:20:25.922]                     invokeRestart <- base::invokeRestart
[13:20:25.922]                     is.null <- base::is.null
[13:20:25.922]                     muffled <- FALSE
[13:20:25.922]                     if (inherits(cond, "message")) {
[13:20:25.922]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:25.922]                       if (muffled) 
[13:20:25.922]                         invokeRestart("muffleMessage")
[13:20:25.922]                     }
[13:20:25.922]                     else if (inherits(cond, "warning")) {
[13:20:25.922]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:25.922]                       if (muffled) 
[13:20:25.922]                         invokeRestart("muffleWarning")
[13:20:25.922]                     }
[13:20:25.922]                     else if (inherits(cond, "condition")) {
[13:20:25.922]                       if (!is.null(pattern)) {
[13:20:25.922]                         computeRestarts <- base::computeRestarts
[13:20:25.922]                         grepl <- base::grepl
[13:20:25.922]                         restarts <- computeRestarts(cond)
[13:20:25.922]                         for (restart in restarts) {
[13:20:25.922]                           name <- restart$name
[13:20:25.922]                           if (is.null(name)) 
[13:20:25.922]                             next
[13:20:25.922]                           if (!grepl(pattern, name)) 
[13:20:25.922]                             next
[13:20:25.922]                           invokeRestart(restart)
[13:20:25.922]                           muffled <- TRUE
[13:20:25.922]                           break
[13:20:25.922]                         }
[13:20:25.922]                       }
[13:20:25.922]                     }
[13:20:25.922]                     invisible(muffled)
[13:20:25.922]                   }
[13:20:25.922]                   muffleCondition(cond)
[13:20:25.922]                 })
[13:20:25.922]             }))
[13:20:25.922]             future::FutureResult(value = ...future.value$value, 
[13:20:25.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.922]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.922]                     ...future.globalenv.names))
[13:20:25.922]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.922]         }, condition = base::local({
[13:20:25.922]             c <- base::c
[13:20:25.922]             inherits <- base::inherits
[13:20:25.922]             invokeRestart <- base::invokeRestart
[13:20:25.922]             length <- base::length
[13:20:25.922]             list <- base::list
[13:20:25.922]             seq.int <- base::seq.int
[13:20:25.922]             signalCondition <- base::signalCondition
[13:20:25.922]             sys.calls <- base::sys.calls
[13:20:25.922]             `[[` <- base::`[[`
[13:20:25.922]             `+` <- base::`+`
[13:20:25.922]             `<<-` <- base::`<<-`
[13:20:25.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.922]                   3L)]
[13:20:25.922]             }
[13:20:25.922]             function(cond) {
[13:20:25.922]                 is_error <- inherits(cond, "error")
[13:20:25.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.922]                   NULL)
[13:20:25.922]                 if (is_error) {
[13:20:25.922]                   sessionInformation <- function() {
[13:20:25.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.922]                       search = base::search(), system = base::Sys.info())
[13:20:25.922]                   }
[13:20:25.922]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.922]                     cond$call), session = sessionInformation(), 
[13:20:25.922]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.922]                   signalCondition(cond)
[13:20:25.922]                 }
[13:20:25.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.922]                 "immediateCondition"))) {
[13:20:25.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.922]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.922]                   if (TRUE && !signal) {
[13:20:25.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.922]                     {
[13:20:25.922]                       inherits <- base::inherits
[13:20:25.922]                       invokeRestart <- base::invokeRestart
[13:20:25.922]                       is.null <- base::is.null
[13:20:25.922]                       muffled <- FALSE
[13:20:25.922]                       if (inherits(cond, "message")) {
[13:20:25.922]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.922]                         if (muffled) 
[13:20:25.922]                           invokeRestart("muffleMessage")
[13:20:25.922]                       }
[13:20:25.922]                       else if (inherits(cond, "warning")) {
[13:20:25.922]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.922]                         if (muffled) 
[13:20:25.922]                           invokeRestart("muffleWarning")
[13:20:25.922]                       }
[13:20:25.922]                       else if (inherits(cond, "condition")) {
[13:20:25.922]                         if (!is.null(pattern)) {
[13:20:25.922]                           computeRestarts <- base::computeRestarts
[13:20:25.922]                           grepl <- base::grepl
[13:20:25.922]                           restarts <- computeRestarts(cond)
[13:20:25.922]                           for (restart in restarts) {
[13:20:25.922]                             name <- restart$name
[13:20:25.922]                             if (is.null(name)) 
[13:20:25.922]                               next
[13:20:25.922]                             if (!grepl(pattern, name)) 
[13:20:25.922]                               next
[13:20:25.922]                             invokeRestart(restart)
[13:20:25.922]                             muffled <- TRUE
[13:20:25.922]                             break
[13:20:25.922]                           }
[13:20:25.922]                         }
[13:20:25.922]                       }
[13:20:25.922]                       invisible(muffled)
[13:20:25.922]                     }
[13:20:25.922]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.922]                   }
[13:20:25.922]                 }
[13:20:25.922]                 else {
[13:20:25.922]                   if (TRUE) {
[13:20:25.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.922]                     {
[13:20:25.922]                       inherits <- base::inherits
[13:20:25.922]                       invokeRestart <- base::invokeRestart
[13:20:25.922]                       is.null <- base::is.null
[13:20:25.922]                       muffled <- FALSE
[13:20:25.922]                       if (inherits(cond, "message")) {
[13:20:25.922]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.922]                         if (muffled) 
[13:20:25.922]                           invokeRestart("muffleMessage")
[13:20:25.922]                       }
[13:20:25.922]                       else if (inherits(cond, "warning")) {
[13:20:25.922]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.922]                         if (muffled) 
[13:20:25.922]                           invokeRestart("muffleWarning")
[13:20:25.922]                       }
[13:20:25.922]                       else if (inherits(cond, "condition")) {
[13:20:25.922]                         if (!is.null(pattern)) {
[13:20:25.922]                           computeRestarts <- base::computeRestarts
[13:20:25.922]                           grepl <- base::grepl
[13:20:25.922]                           restarts <- computeRestarts(cond)
[13:20:25.922]                           for (restart in restarts) {
[13:20:25.922]                             name <- restart$name
[13:20:25.922]                             if (is.null(name)) 
[13:20:25.922]                               next
[13:20:25.922]                             if (!grepl(pattern, name)) 
[13:20:25.922]                               next
[13:20:25.922]                             invokeRestart(restart)
[13:20:25.922]                             muffled <- TRUE
[13:20:25.922]                             break
[13:20:25.922]                           }
[13:20:25.922]                         }
[13:20:25.922]                       }
[13:20:25.922]                       invisible(muffled)
[13:20:25.922]                     }
[13:20:25.922]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.922]                   }
[13:20:25.922]                 }
[13:20:25.922]             }
[13:20:25.922]         }))
[13:20:25.922]     }, error = function(ex) {
[13:20:25.922]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.922]                 ...future.rng), started = ...future.startTime, 
[13:20:25.922]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.922]             version = "1.8"), class = "FutureResult")
[13:20:25.922]     }, finally = {
[13:20:25.922]         if (!identical(...future.workdir, getwd())) 
[13:20:25.922]             setwd(...future.workdir)
[13:20:25.922]         {
[13:20:25.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.922]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.922]             }
[13:20:25.922]             base::options(...future.oldOptions)
[13:20:25.922]             if (.Platform$OS.type == "windows") {
[13:20:25.922]                 old_names <- names(...future.oldEnvVars)
[13:20:25.922]                 envs <- base::Sys.getenv()
[13:20:25.922]                 names <- names(envs)
[13:20:25.922]                 common <- intersect(names, old_names)
[13:20:25.922]                 added <- setdiff(names, old_names)
[13:20:25.922]                 removed <- setdiff(old_names, names)
[13:20:25.922]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.922]                   envs[common]]
[13:20:25.922]                 NAMES <- toupper(changed)
[13:20:25.922]                 args <- list()
[13:20:25.922]                 for (kk in seq_along(NAMES)) {
[13:20:25.922]                   name <- changed[[kk]]
[13:20:25.922]                   NAME <- NAMES[[kk]]
[13:20:25.922]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.922]                     next
[13:20:25.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.922]                 }
[13:20:25.922]                 NAMES <- toupper(added)
[13:20:25.922]                 for (kk in seq_along(NAMES)) {
[13:20:25.922]                   name <- added[[kk]]
[13:20:25.922]                   NAME <- NAMES[[kk]]
[13:20:25.922]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.922]                     next
[13:20:25.922]                   args[[name]] <- ""
[13:20:25.922]                 }
[13:20:25.922]                 NAMES <- toupper(removed)
[13:20:25.922]                 for (kk in seq_along(NAMES)) {
[13:20:25.922]                   name <- removed[[kk]]
[13:20:25.922]                   NAME <- NAMES[[kk]]
[13:20:25.922]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.922]                     next
[13:20:25.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.922]                 }
[13:20:25.922]                 if (length(args) > 0) 
[13:20:25.922]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.922]             }
[13:20:25.922]             else {
[13:20:25.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.922]             }
[13:20:25.922]             {
[13:20:25.922]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.922]                   0L) {
[13:20:25.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.922]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.922]                   base::options(opts)
[13:20:25.922]                 }
[13:20:25.922]                 {
[13:20:25.922]                   {
[13:20:25.922]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:25.922]                     NULL
[13:20:25.922]                   }
[13:20:25.922]                   options(future.plan = NULL)
[13:20:25.922]                   if (is.na(NA_character_)) 
[13:20:25.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.922]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:25.922]                     envir = parent.frame()) 
[13:20:25.922]                   {
[13:20:25.922]                     default_workers <- missing(workers)
[13:20:25.922]                     if (is.function(workers)) 
[13:20:25.922]                       workers <- workers()
[13:20:25.922]                     workers <- structure(as.integer(workers), 
[13:20:25.922]                       class = class(workers))
[13:20:25.922]                     stop_if_not(is.finite(workers), workers >= 
[13:20:25.922]                       1L)
[13:20:25.922]                     if ((workers == 1L && !inherits(workers, 
[13:20:25.922]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:25.922]                       if (default_workers) 
[13:20:25.922]                         supportsMulticore(warn = TRUE)
[13:20:25.922]                       return(sequential(..., envir = envir))
[13:20:25.922]                     }
[13:20:25.922]                     oopts <- options(mc.cores = workers)
[13:20:25.922]                     on.exit(options(oopts))
[13:20:25.922]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:25.922]                       envir = envir)
[13:20:25.922]                     if (!future$lazy) 
[13:20:25.922]                       future <- run(future)
[13:20:25.922]                     invisible(future)
[13:20:25.922]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.922]                 }
[13:20:25.922]             }
[13:20:25.922]         }
[13:20:25.922]     })
[13:20:25.922]     if (TRUE) {
[13:20:25.922]         base::sink(type = "output", split = FALSE)
[13:20:25.922]         if (TRUE) {
[13:20:25.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.922]         }
[13:20:25.922]         else {
[13:20:25.922]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.922]         }
[13:20:25.922]         base::close(...future.stdout)
[13:20:25.922]         ...future.stdout <- NULL
[13:20:25.922]     }
[13:20:25.922]     ...future.result$conditions <- ...future.conditions
[13:20:25.922]     ...future.result$finished <- base::Sys.time()
[13:20:25.922]     ...future.result
[13:20:25.922] }
[13:20:25.924] requestCore(): workers = 2
[13:20:25.926] MulticoreFuture started
[13:20:25.927] - Launch lazy future ... done
[13:20:25.927] run() for ‘MulticoreFuture’ ... done
[13:20:25.927] getGlobalsAndPackages() ...
[13:20:25.927] plan(): Setting new future strategy stack:
[13:20:25.928] Searching for globals...
[13:20:25.928] List of future strategies:
[13:20:25.928] 1. sequential:
[13:20:25.928]    - args: function (..., envir = parent.frame())
[13:20:25.928]    - tweaked: FALSE
[13:20:25.928]    - call: NULL
[13:20:25.928] 
[13:20:25.929] Searching for globals ... DONE
[13:20:25.929] plan(): nbrOfWorkers() = 1
[13:20:25.929] - globals: [0] <none>
[13:20:25.929] getGlobalsAndPackages() ... DONE
[13:20:25.930] run() for ‘Future’ ...
[13:20:25.930] - state: ‘created’
[13:20:25.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:25.931] plan(): Setting new future strategy stack:
[13:20:25.931] List of future strategies:
[13:20:25.931] 1. multicore:
[13:20:25.931]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:25.931]    - tweaked: FALSE
[13:20:25.931]    - call: plan(strategy)
[13:20:25.935] plan(): nbrOfWorkers() = 2
[13:20:25.936] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:25.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:25.936]   - Field: ‘label’
[13:20:25.936]   - Field: ‘local’
[13:20:25.936]   - Field: ‘owner’
[13:20:25.937]   - Field: ‘envir’
[13:20:25.937]   - Field: ‘workers’
[13:20:25.937]   - Field: ‘packages’
[13:20:25.937]   - Field: ‘gc’
[13:20:25.937]   - Field: ‘job’
[13:20:25.937]   - Field: ‘conditions’
[13:20:25.938]   - Field: ‘expr’
[13:20:25.938]   - Field: ‘uuid’
[13:20:25.938]   - Field: ‘seed’
[13:20:25.938]   - Field: ‘version’
[13:20:25.938]   - Field: ‘result’
[13:20:25.938]   - Field: ‘asynchronous’
[13:20:25.938]   - Field: ‘calls’
[13:20:25.939]   - Field: ‘globals’
[13:20:25.939]   - Field: ‘stdout’
[13:20:25.939]   - Field: ‘earlySignal’
[13:20:25.939]   - Field: ‘lazy’
[13:20:25.939]   - Field: ‘state’
[13:20:25.939] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:25.940] - Launch lazy future ...
[13:20:25.940] Packages needed by the future expression (n = 0): <none>
[13:20:25.940] Packages needed by future strategies (n = 0): <none>
[13:20:25.941] {
[13:20:25.941]     {
[13:20:25.941]         {
[13:20:25.941]             ...future.startTime <- base::Sys.time()
[13:20:25.941]             {
[13:20:25.941]                 {
[13:20:25.941]                   {
[13:20:25.941]                     {
[13:20:25.941]                       base::local({
[13:20:25.941]                         has_future <- base::requireNamespace("future", 
[13:20:25.941]                           quietly = TRUE)
[13:20:25.941]                         if (has_future) {
[13:20:25.941]                           ns <- base::getNamespace("future")
[13:20:25.941]                           version <- ns[[".package"]][["version"]]
[13:20:25.941]                           if (is.null(version)) 
[13:20:25.941]                             version <- utils::packageVersion("future")
[13:20:25.941]                         }
[13:20:25.941]                         else {
[13:20:25.941]                           version <- NULL
[13:20:25.941]                         }
[13:20:25.941]                         if (!has_future || version < "1.8.0") {
[13:20:25.941]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:25.941]                             "", base::R.version$version.string), 
[13:20:25.941]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:25.941]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:25.941]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:25.941]                               "release", "version")], collapse = " "), 
[13:20:25.941]                             hostname = base::Sys.info()[["nodename"]])
[13:20:25.941]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:25.941]                             info)
[13:20:25.941]                           info <- base::paste(info, collapse = "; ")
[13:20:25.941]                           if (!has_future) {
[13:20:25.941]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:25.941]                               info)
[13:20:25.941]                           }
[13:20:25.941]                           else {
[13:20:25.941]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:25.941]                               info, version)
[13:20:25.941]                           }
[13:20:25.941]                           base::stop(msg)
[13:20:25.941]                         }
[13:20:25.941]                       })
[13:20:25.941]                     }
[13:20:25.941]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:25.941]                     base::options(mc.cores = 1L)
[13:20:25.941]                   }
[13:20:25.941]                   options(future.plan = NULL)
[13:20:25.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:25.941]                 }
[13:20:25.941]                 ...future.workdir <- getwd()
[13:20:25.941]             }
[13:20:25.941]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:25.941]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:25.941]         }
[13:20:25.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:25.941]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:25.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:25.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:25.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:25.941]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:25.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:25.941]             base::names(...future.oldOptions))
[13:20:25.941]     }
[13:20:25.941]     if (FALSE) {
[13:20:25.941]     }
[13:20:25.941]     else {
[13:20:25.941]         if (TRUE) {
[13:20:25.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:25.941]                 open = "w")
[13:20:25.941]         }
[13:20:25.941]         else {
[13:20:25.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:25.941]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:25.941]         }
[13:20:25.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:25.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:25.941]             base::sink(type = "output", split = FALSE)
[13:20:25.941]             base::close(...future.stdout)
[13:20:25.941]         }, add = TRUE)
[13:20:25.941]     }
[13:20:25.941]     ...future.frame <- base::sys.nframe()
[13:20:25.941]     ...future.conditions <- base::list()
[13:20:25.941]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:25.941]     if (FALSE) {
[13:20:25.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:25.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:25.941]     }
[13:20:25.941]     ...future.result <- base::tryCatch({
[13:20:25.941]         base::withCallingHandlers({
[13:20:25.941]             ...future.value <- base::withVisible(base::local({
[13:20:25.941]                 withCallingHandlers({
[13:20:25.941]                   NULL
[13:20:25.941]                 }, immediateCondition = function(cond) {
[13:20:25.941]                   save_rds <- function (object, pathname, ...) 
[13:20:25.941]                   {
[13:20:25.941]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:25.941]                     if (file_test("-f", pathname_tmp)) {
[13:20:25.941]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.941]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:25.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.941]                         fi_tmp[["mtime"]])
[13:20:25.941]                     }
[13:20:25.941]                     tryCatch({
[13:20:25.941]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:25.941]                     }, error = function(ex) {
[13:20:25.941]                       msg <- conditionMessage(ex)
[13:20:25.941]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.941]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:25.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.941]                         fi_tmp[["mtime"]], msg)
[13:20:25.941]                       ex$message <- msg
[13:20:25.941]                       stop(ex)
[13:20:25.941]                     })
[13:20:25.941]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:25.941]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:25.941]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:25.941]                       fi_tmp <- file.info(pathname_tmp)
[13:20:25.941]                       fi <- file.info(pathname)
[13:20:25.941]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:25.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:25.941]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:25.941]                         fi[["size"]], fi[["mtime"]])
[13:20:25.941]                       stop(msg)
[13:20:25.941]                     }
[13:20:25.941]                     invisible(pathname)
[13:20:25.941]                   }
[13:20:25.941]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:25.941]                     rootPath = tempdir()) 
[13:20:25.941]                   {
[13:20:25.941]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:25.941]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:25.941]                       tmpdir = path, fileext = ".rds")
[13:20:25.941]                     save_rds(obj, file)
[13:20:25.941]                   }
[13:20:25.941]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:25.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.941]                   {
[13:20:25.941]                     inherits <- base::inherits
[13:20:25.941]                     invokeRestart <- base::invokeRestart
[13:20:25.941]                     is.null <- base::is.null
[13:20:25.941]                     muffled <- FALSE
[13:20:25.941]                     if (inherits(cond, "message")) {
[13:20:25.941]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:25.941]                       if (muffled) 
[13:20:25.941]                         invokeRestart("muffleMessage")
[13:20:25.941]                     }
[13:20:25.941]                     else if (inherits(cond, "warning")) {
[13:20:25.941]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:25.941]                       if (muffled) 
[13:20:25.941]                         invokeRestart("muffleWarning")
[13:20:25.941]                     }
[13:20:25.941]                     else if (inherits(cond, "condition")) {
[13:20:25.941]                       if (!is.null(pattern)) {
[13:20:25.941]                         computeRestarts <- base::computeRestarts
[13:20:25.941]                         grepl <- base::grepl
[13:20:25.941]                         restarts <- computeRestarts(cond)
[13:20:25.941]                         for (restart in restarts) {
[13:20:25.941]                           name <- restart$name
[13:20:25.941]                           if (is.null(name)) 
[13:20:25.941]                             next
[13:20:25.941]                           if (!grepl(pattern, name)) 
[13:20:25.941]                             next
[13:20:25.941]                           invokeRestart(restart)
[13:20:25.941]                           muffled <- TRUE
[13:20:25.941]                           break
[13:20:25.941]                         }
[13:20:25.941]                       }
[13:20:25.941]                     }
[13:20:25.941]                     invisible(muffled)
[13:20:25.941]                   }
[13:20:25.941]                   muffleCondition(cond)
[13:20:25.941]                 })
[13:20:25.941]             }))
[13:20:25.941]             future::FutureResult(value = ...future.value$value, 
[13:20:25.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.941]                   ...future.rng), globalenv = if (FALSE) 
[13:20:25.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:25.941]                     ...future.globalenv.names))
[13:20:25.941]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:25.941]         }, condition = base::local({
[13:20:25.941]             c <- base::c
[13:20:25.941]             inherits <- base::inherits
[13:20:25.941]             invokeRestart <- base::invokeRestart
[13:20:25.941]             length <- base::length
[13:20:25.941]             list <- base::list
[13:20:25.941]             seq.int <- base::seq.int
[13:20:25.941]             signalCondition <- base::signalCondition
[13:20:25.941]             sys.calls <- base::sys.calls
[13:20:25.941]             `[[` <- base::`[[`
[13:20:25.941]             `+` <- base::`+`
[13:20:25.941]             `<<-` <- base::`<<-`
[13:20:25.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:25.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:25.941]                   3L)]
[13:20:25.941]             }
[13:20:25.941]             function(cond) {
[13:20:25.941]                 is_error <- inherits(cond, "error")
[13:20:25.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:25.941]                   NULL)
[13:20:25.941]                 if (is_error) {
[13:20:25.941]                   sessionInformation <- function() {
[13:20:25.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:25.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:25.941]                       search = base::search(), system = base::Sys.info())
[13:20:25.941]                   }
[13:20:25.941]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:25.941]                     cond$call), session = sessionInformation(), 
[13:20:25.941]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:25.941]                   signalCondition(cond)
[13:20:25.941]                 }
[13:20:25.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:25.941]                 "immediateCondition"))) {
[13:20:25.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:25.941]                   ...future.conditions[[length(...future.conditions) + 
[13:20:25.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:25.941]                   if (TRUE && !signal) {
[13:20:25.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.941]                     {
[13:20:25.941]                       inherits <- base::inherits
[13:20:25.941]                       invokeRestart <- base::invokeRestart
[13:20:25.941]                       is.null <- base::is.null
[13:20:25.941]                       muffled <- FALSE
[13:20:25.941]                       if (inherits(cond, "message")) {
[13:20:25.941]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.941]                         if (muffled) 
[13:20:25.941]                           invokeRestart("muffleMessage")
[13:20:25.941]                       }
[13:20:25.941]                       else if (inherits(cond, "warning")) {
[13:20:25.941]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.941]                         if (muffled) 
[13:20:25.941]                           invokeRestart("muffleWarning")
[13:20:25.941]                       }
[13:20:25.941]                       else if (inherits(cond, "condition")) {
[13:20:25.941]                         if (!is.null(pattern)) {
[13:20:25.941]                           computeRestarts <- base::computeRestarts
[13:20:25.941]                           grepl <- base::grepl
[13:20:25.941]                           restarts <- computeRestarts(cond)
[13:20:25.941]                           for (restart in restarts) {
[13:20:25.941]                             name <- restart$name
[13:20:25.941]                             if (is.null(name)) 
[13:20:25.941]                               next
[13:20:25.941]                             if (!grepl(pattern, name)) 
[13:20:25.941]                               next
[13:20:25.941]                             invokeRestart(restart)
[13:20:25.941]                             muffled <- TRUE
[13:20:25.941]                             break
[13:20:25.941]                           }
[13:20:25.941]                         }
[13:20:25.941]                       }
[13:20:25.941]                       invisible(muffled)
[13:20:25.941]                     }
[13:20:25.941]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.941]                   }
[13:20:25.941]                 }
[13:20:25.941]                 else {
[13:20:25.941]                   if (TRUE) {
[13:20:25.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:25.941]                     {
[13:20:25.941]                       inherits <- base::inherits
[13:20:25.941]                       invokeRestart <- base::invokeRestart
[13:20:25.941]                       is.null <- base::is.null
[13:20:25.941]                       muffled <- FALSE
[13:20:25.941]                       if (inherits(cond, "message")) {
[13:20:25.941]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:25.941]                         if (muffled) 
[13:20:25.941]                           invokeRestart("muffleMessage")
[13:20:25.941]                       }
[13:20:25.941]                       else if (inherits(cond, "warning")) {
[13:20:25.941]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:25.941]                         if (muffled) 
[13:20:25.941]                           invokeRestart("muffleWarning")
[13:20:25.941]                       }
[13:20:25.941]                       else if (inherits(cond, "condition")) {
[13:20:25.941]                         if (!is.null(pattern)) {
[13:20:25.941]                           computeRestarts <- base::computeRestarts
[13:20:25.941]                           grepl <- base::grepl
[13:20:25.941]                           restarts <- computeRestarts(cond)
[13:20:25.941]                           for (restart in restarts) {
[13:20:25.941]                             name <- restart$name
[13:20:25.941]                             if (is.null(name)) 
[13:20:25.941]                               next
[13:20:25.941]                             if (!grepl(pattern, name)) 
[13:20:25.941]                               next
[13:20:25.941]                             invokeRestart(restart)
[13:20:25.941]                             muffled <- TRUE
[13:20:25.941]                             break
[13:20:25.941]                           }
[13:20:25.941]                         }
[13:20:25.941]                       }
[13:20:25.941]                       invisible(muffled)
[13:20:25.941]                     }
[13:20:25.941]                     muffleCondition(cond, pattern = "^muffle")
[13:20:25.941]                   }
[13:20:25.941]                 }
[13:20:25.941]             }
[13:20:25.941]         }))
[13:20:25.941]     }, error = function(ex) {
[13:20:25.941]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:25.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:25.941]                 ...future.rng), started = ...future.startTime, 
[13:20:25.941]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:25.941]             version = "1.8"), class = "FutureResult")
[13:20:25.941]     }, finally = {
[13:20:25.941]         if (!identical(...future.workdir, getwd())) 
[13:20:25.941]             setwd(...future.workdir)
[13:20:25.941]         {
[13:20:25.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:25.941]                 ...future.oldOptions$nwarnings <- NULL
[13:20:25.941]             }
[13:20:25.941]             base::options(...future.oldOptions)
[13:20:25.941]             if (.Platform$OS.type == "windows") {
[13:20:25.941]                 old_names <- names(...future.oldEnvVars)
[13:20:25.941]                 envs <- base::Sys.getenv()
[13:20:25.941]                 names <- names(envs)
[13:20:25.941]                 common <- intersect(names, old_names)
[13:20:25.941]                 added <- setdiff(names, old_names)
[13:20:25.941]                 removed <- setdiff(old_names, names)
[13:20:25.941]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:25.941]                   envs[common]]
[13:20:25.941]                 NAMES <- toupper(changed)
[13:20:25.941]                 args <- list()
[13:20:25.941]                 for (kk in seq_along(NAMES)) {
[13:20:25.941]                   name <- changed[[kk]]
[13:20:25.941]                   NAME <- NAMES[[kk]]
[13:20:25.941]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.941]                     next
[13:20:25.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.941]                 }
[13:20:25.941]                 NAMES <- toupper(added)
[13:20:25.941]                 for (kk in seq_along(NAMES)) {
[13:20:25.941]                   name <- added[[kk]]
[13:20:25.941]                   NAME <- NAMES[[kk]]
[13:20:25.941]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.941]                     next
[13:20:25.941]                   args[[name]] <- ""
[13:20:25.941]                 }
[13:20:25.941]                 NAMES <- toupper(removed)
[13:20:25.941]                 for (kk in seq_along(NAMES)) {
[13:20:25.941]                   name <- removed[[kk]]
[13:20:25.941]                   NAME <- NAMES[[kk]]
[13:20:25.941]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:25.941]                     next
[13:20:25.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:25.941]                 }
[13:20:25.941]                 if (length(args) > 0) 
[13:20:25.941]                   base::do.call(base::Sys.setenv, args = args)
[13:20:25.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:25.941]             }
[13:20:25.941]             else {
[13:20:25.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:25.941]             }
[13:20:25.941]             {
[13:20:25.941]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:25.941]                   0L) {
[13:20:25.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:25.941]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:25.941]                   base::options(opts)
[13:20:25.941]                 }
[13:20:25.941]                 {
[13:20:25.941]                   {
[13:20:25.941]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:25.941]                     NULL
[13:20:25.941]                   }
[13:20:25.941]                   options(future.plan = NULL)
[13:20:25.941]                   if (is.na(NA_character_)) 
[13:20:25.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:25.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:25.941]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:25.941]                     envir = parent.frame()) 
[13:20:25.941]                   {
[13:20:25.941]                     default_workers <- missing(workers)
[13:20:25.941]                     if (is.function(workers)) 
[13:20:25.941]                       workers <- workers()
[13:20:25.941]                     workers <- structure(as.integer(workers), 
[13:20:25.941]                       class = class(workers))
[13:20:25.941]                     stop_if_not(is.finite(workers), workers >= 
[13:20:25.941]                       1L)
[13:20:25.941]                     if ((workers == 1L && !inherits(workers, 
[13:20:25.941]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:25.941]                       if (default_workers) 
[13:20:25.941]                         supportsMulticore(warn = TRUE)
[13:20:25.941]                       return(sequential(..., envir = envir))
[13:20:25.941]                     }
[13:20:25.941]                     oopts <- options(mc.cores = workers)
[13:20:25.941]                     on.exit(options(oopts))
[13:20:25.941]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:25.941]                       envir = envir)
[13:20:25.941]                     if (!future$lazy) 
[13:20:25.941]                       future <- run(future)
[13:20:25.941]                     invisible(future)
[13:20:25.941]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:25.941]                 }
[13:20:25.941]             }
[13:20:25.941]         }
[13:20:25.941]     })
[13:20:25.941]     if (TRUE) {
[13:20:25.941]         base::sink(type = "output", split = FALSE)
[13:20:25.941]         if (TRUE) {
[13:20:25.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:25.941]         }
[13:20:25.941]         else {
[13:20:25.941]             ...future.result["stdout"] <- base::list(NULL)
[13:20:25.941]         }
[13:20:25.941]         base::close(...future.stdout)
[13:20:25.941]         ...future.stdout <- NULL
[13:20:25.941]     }
[13:20:25.941]     ...future.result$conditions <- ...future.conditions
[13:20:25.941]     ...future.result$finished <- base::Sys.time()
[13:20:25.941]     ...future.result
[13:20:25.941] }
[13:20:25.945] requestCore(): workers = 2
[13:20:25.947] MulticoreFuture started
[13:20:25.947] - Launch lazy future ... done
[13:20:25.947] run() for ‘MulticoreFuture’ ... done
List of 6
[13:20:25.948] plan(): Setting new future strategy stack:
 $ a:[13:20:25.948] List of future strategies:
[13:20:25.948] 1. sequential:
[13:20:25.948]    - args: function (..., envir = parent.frame())
[13:20:25.948]    - tweaked: FALSE
[13:20:25.948]    - call: NULL
 num 1
 $ b:[13:20:25.949] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659ac94b58> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659b4a6688> 
 $  : NULL
 $  : NULL
 $  :[13:20:25.951] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ a:[13:20:25.951] List of future strategies:
[13:20:25.951] 1. multicore:
[13:20:25.951]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:25.951]    - tweaked: FALSE
[13:20:25.951]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659ac94b58> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659b4a6688> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] [13:20:25.957] plan(): nbrOfWorkers() = 2
"a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:25.961] resolve() on list ...
[13:20:25.961]  recursive: 0
[13:20:25.962]  length: 6
[13:20:25.966]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:25.966] signalConditionsASAP(numeric, pos=1) ...
[13:20:25.966] - nx: 6
[13:20:25.967] - relay: TRUE
[13:20:25.967] - stdout: TRUE
[13:20:25.967] - signal: TRUE
[13:20:25.967] - resignal: FALSE
[13:20:25.968] - force: TRUE
[13:20:25.968] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.968] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.968]  - until=2
[13:20:25.969]  - relaying element #2
[13:20:25.969] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.969] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.970] signalConditionsASAP(NULL, pos=1) ... done
[13:20:25.970]  length: 5 (resolved future 1)
[13:20:25.970] Future #2
[13:20:25.971] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:25.971] - nx: 6
[13:20:25.972] - relay: TRUE
[13:20:25.972] - stdout: TRUE
[13:20:25.972] - signal: TRUE
[13:20:25.972] - resignal: FALSE
[13:20:25.972] - force: TRUE
[13:20:25.972] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.972] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:25.973]  - until=2
[13:20:25.973]  - relaying element #2
[13:20:25.973] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.973] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.973] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:25.974]  length: 4 (resolved future 2)
[13:20:25.974] Future #3
[13:20:25.975] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:25.975] - nx: 6
[13:20:25.976] - relay: TRUE
[13:20:25.976] - stdout: TRUE
[13:20:25.976] - signal: TRUE
[13:20:25.976] - resignal: FALSE
[13:20:25.976] - force: TRUE
[13:20:25.976] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.977] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:25.977]  - until=3
[13:20:25.977]  - relaying element #3
[13:20:25.977] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.978] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.978] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:25.978]  length: 3 (resolved future 3)
[13:20:25.978] signalConditionsASAP(NULL, pos=4) ...
[13:20:25.978] - nx: 6
[13:20:25.978] - relay: TRUE
[13:20:25.979] - stdout: TRUE
[13:20:25.979] - signal: TRUE
[13:20:25.979] - resignal: FALSE
[13:20:25.979] - force: TRUE
[13:20:25.979] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.979] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.979]  - until=5
[13:20:25.979]  - relaying element #5
[13:20:25.979] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.979] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.980] signalConditionsASAP(NULL, pos=4) ... done
[13:20:25.980]  length: 2 (resolved future 4)
[13:20:25.980] signalConditionsASAP(NULL, pos=5) ...
[13:20:25.980] - nx: 6
[13:20:25.980] - relay: TRUE
[13:20:25.980] - stdout: TRUE
[13:20:25.980] - signal: TRUE
[13:20:25.980] - resignal: FALSE
[13:20:25.980] - force: TRUE
[13:20:25.980] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:25.981] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.981]  - until=6
[13:20:25.981]  - relaying element #6
[13:20:25.981] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.981] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.981] signalConditionsASAP(NULL, pos=5) ... done
[13:20:25.981]  length: 1 (resolved future 5)
[13:20:25.981] signalConditionsASAP(numeric, pos=6) ...
[13:20:25.981] - nx: 6
[13:20:25.982] - relay: TRUE
[13:20:25.982] - stdout: TRUE
[13:20:25.982] - signal: TRUE
[13:20:25.982] - resignal: FALSE
[13:20:25.982] - force: TRUE
[13:20:25.982] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:25.982] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.982]  - until=6
[13:20:25.982] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.982] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.983] signalConditionsASAP(numeric, pos=6) ... done
[13:20:25.983]  length: 0 (resolved future 6)
[13:20:25.983] Relaying remaining futures
[13:20:25.983] signalConditionsASAP(NULL, pos=0) ...
[13:20:25.983] - nx: 6
[13:20:25.983] - relay: TRUE
[13:20:25.983] - stdout: TRUE
[13:20:25.983] - signal: TRUE
[13:20:25.983] - resignal: FALSE
[13:20:25.983] - force: TRUE
[13:20:25.984] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.984] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:25.984] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:25.984] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:25.984] signalConditionsASAP(NULL, pos=0) ... done
[13:20:25.984] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[13:20:25.988] plan(): Setting new future strategy stack:
[13:20:25.989] List of future strategies:
[13:20:25.989] 1. multisession:
[13:20:25.989]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:25.989]    - tweaked: FALSE
[13:20:25.989]    - call: plan(strategy)
[13:20:25.989] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:20:25.989] multisession:
[13:20:25.989] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:25.989] - tweaked: FALSE
[13:20:25.989] - call: plan(strategy)
[13:20:25.995] getGlobalsAndPackages() ...
[13:20:25.995] Not searching for globals
[13:20:25.996] - globals: [0] <none>
[13:20:25.996] getGlobalsAndPackages() ... DONE
[13:20:25.996] [local output] makeClusterPSOCK() ...
[13:20:26.040] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:20:26.045] [local output] Base port: 11641
[13:20:26.045] [local output] Getting setup options for 2 cluster nodes ...
[13:20:26.045] [local output]  - Node 1 of 2 ...
[13:20:26.046] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:26.047] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpXOy31R/worker.rank=1.parallelly.parent=84392.149a8c12f04.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpXOy31R/worker.rank=1.parallelly.parent=84392.149a8c12f04.pid")'’
[13:20:26.235] - Possible to infer worker's PID: TRUE
[13:20:26.235] [local output] Rscript port: 11641

[13:20:26.236] [local output]  - Node 2 of 2 ...
[13:20:26.236] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:26.237] [local output] Rscript port: 11641

[13:20:26.237] [local output] Getting setup options for 2 cluster nodes ... done
[13:20:26.237] [local output]  - Parallel setup requested for some PSOCK nodes
[13:20:26.238] [local output] Setting up PSOCK nodes in parallel
[13:20:26.238] List of 36
[13:20:26.238]  $ worker          : chr "localhost"
[13:20:26.238]   ..- attr(*, "localhost")= logi TRUE
[13:20:26.238]  $ master          : chr "localhost"
[13:20:26.238]  $ port            : int 11641
[13:20:26.238]  $ connectTimeout  : num 120
[13:20:26.238]  $ timeout         : num 2592000
[13:20:26.238]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:20:26.238]  $ homogeneous     : logi TRUE
[13:20:26.238]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:20:26.238]  $ rscript_envs    : NULL
[13:20:26.238]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:26.238]  $ rscript_startup : NULL
[13:20:26.238]  $ rscript_sh      : chr "sh"
[13:20:26.238]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:26.238]  $ methods         : logi TRUE
[13:20:26.238]  $ socketOptions   : chr "no-delay"
[13:20:26.238]  $ useXDR          : logi FALSE
[13:20:26.238]  $ outfile         : chr "/dev/null"
[13:20:26.238]  $ renice          : int NA
[13:20:26.238]  $ rshcmd          : NULL
[13:20:26.238]  $ user            : chr(0) 
[13:20:26.238]  $ revtunnel       : logi FALSE
[13:20:26.238]  $ rshlogfile      : NULL
[13:20:26.238]  $ rshopts         : chr(0) 
[13:20:26.238]  $ rank            : int 1
[13:20:26.238]  $ manual          : logi FALSE
[13:20:26.238]  $ dryrun          : logi FALSE
[13:20:26.238]  $ quiet           : logi FALSE
[13:20:26.238]  $ setup_strategy  : chr "parallel"
[13:20:26.238]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:26.238]  $ pidfile         : chr "/tmp/RtmpXOy31R/worker.rank=1.parallelly.parent=84392.149a8c12f04.pid"
[13:20:26.238]  $ rshcmd_label    : NULL
[13:20:26.238]  $ rsh_call        : NULL
[13:20:26.238]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:26.238]  $ localMachine    : logi TRUE
[13:20:26.238]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:20:26.238]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:20:26.238]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:20:26.238]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:20:26.238]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:20:26.238]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:20:26.238]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:20:26.238]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:20:26.238]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:20:26.238]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:20:26.238]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:20:26.238]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:20:26.238]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:20:26.238]  $ arguments       :List of 28
[13:20:26.238]   ..$ worker          : chr "localhost"
[13:20:26.238]   ..$ master          : NULL
[13:20:26.238]   ..$ port            : int 11641
[13:20:26.238]   ..$ connectTimeout  : num 120
[13:20:26.238]   ..$ timeout         : num 2592000
[13:20:26.238]   ..$ rscript         : NULL
[13:20:26.238]   ..$ homogeneous     : NULL
[13:20:26.238]   ..$ rscript_args    : NULL
[13:20:26.238]   ..$ rscript_envs    : NULL
[13:20:26.238]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:26.238]   ..$ rscript_startup : NULL
[13:20:26.238]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:20:26.238]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:26.238]   ..$ methods         : logi TRUE
[13:20:26.238]   ..$ socketOptions   : chr "no-delay"
[13:20:26.238]   ..$ useXDR          : logi FALSE
[13:20:26.238]   ..$ outfile         : chr "/dev/null"
[13:20:26.238]   ..$ renice          : int NA
[13:20:26.238]   ..$ rshcmd          : NULL
[13:20:26.238]   ..$ user            : NULL
[13:20:26.238]   ..$ revtunnel       : logi NA
[13:20:26.238]   ..$ rshlogfile      : NULL
[13:20:26.238]   ..$ rshopts         : NULL
[13:20:26.238]   ..$ rank            : int 1
[13:20:26.238]   ..$ manual          : logi FALSE
[13:20:26.238]   ..$ dryrun          : logi FALSE
[13:20:26.238]   ..$ quiet           : logi FALSE
[13:20:26.238]   ..$ setup_strategy  : chr "parallel"
[13:20:26.238]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:20:26.255] [local output] System call to launch all workers:
[13:20:26.255] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpXOy31R/worker.rank=1.parallelly.parent=84392.149a8c12f04.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11641 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:20:26.255] [local output] Starting PSOCK main server
[13:20:26.257] [local output] Workers launched
[13:20:26.257] [local output] Waiting for workers to connect back
[13:20:26.257]  - [local output] 0 workers out of 2 ready
[13:20:26.518]  - [local output] 0 workers out of 2 ready
[13:20:26.518]  - [local output] 1 workers out of 2 ready
[13:20:26.529]  - [local output] 1 workers out of 2 ready
[13:20:26.529]  - [local output] 2 workers out of 2 ready
[13:20:26.529] [local output] Launching of workers completed
[13:20:26.529] [local output] Collecting session information from workers
[13:20:26.530] [local output]  - Worker #1 of 2
[13:20:26.531] [local output]  - Worker #2 of 2
[13:20:26.531] [local output] makeClusterPSOCK() ... done
[13:20:26.543] Packages needed by the future expression (n = 0): <none>
[13:20:26.543] Packages needed by future strategies (n = 0): <none>
[13:20:26.543] {
[13:20:26.543]     {
[13:20:26.543]         {
[13:20:26.543]             ...future.startTime <- base::Sys.time()
[13:20:26.543]             {
[13:20:26.543]                 {
[13:20:26.543]                   {
[13:20:26.543]                     {
[13:20:26.543]                       base::local({
[13:20:26.543]                         has_future <- base::requireNamespace("future", 
[13:20:26.543]                           quietly = TRUE)
[13:20:26.543]                         if (has_future) {
[13:20:26.543]                           ns <- base::getNamespace("future")
[13:20:26.543]                           version <- ns[[".package"]][["version"]]
[13:20:26.543]                           if (is.null(version)) 
[13:20:26.543]                             version <- utils::packageVersion("future")
[13:20:26.543]                         }
[13:20:26.543]                         else {
[13:20:26.543]                           version <- NULL
[13:20:26.543]                         }
[13:20:26.543]                         if (!has_future || version < "1.8.0") {
[13:20:26.543]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:26.543]                             "", base::R.version$version.string), 
[13:20:26.543]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:26.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:26.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:26.543]                               "release", "version")], collapse = " "), 
[13:20:26.543]                             hostname = base::Sys.info()[["nodename"]])
[13:20:26.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:26.543]                             info)
[13:20:26.543]                           info <- base::paste(info, collapse = "; ")
[13:20:26.543]                           if (!has_future) {
[13:20:26.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:26.543]                               info)
[13:20:26.543]                           }
[13:20:26.543]                           else {
[13:20:26.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:26.543]                               info, version)
[13:20:26.543]                           }
[13:20:26.543]                           base::stop(msg)
[13:20:26.543]                         }
[13:20:26.543]                       })
[13:20:26.543]                     }
[13:20:26.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:26.543]                     base::options(mc.cores = 1L)
[13:20:26.543]                   }
[13:20:26.543]                   options(future.plan = NULL)
[13:20:26.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:26.543]                 }
[13:20:26.543]                 ...future.workdir <- getwd()
[13:20:26.543]             }
[13:20:26.543]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:26.543]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:26.543]         }
[13:20:26.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:26.543]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:26.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:26.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:26.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:26.543]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:26.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:26.543]             base::names(...future.oldOptions))
[13:20:26.543]     }
[13:20:26.543]     if (FALSE) {
[13:20:26.543]     }
[13:20:26.543]     else {
[13:20:26.543]         if (TRUE) {
[13:20:26.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:26.543]                 open = "w")
[13:20:26.543]         }
[13:20:26.543]         else {
[13:20:26.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:26.543]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:26.543]         }
[13:20:26.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:26.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:26.543]             base::sink(type = "output", split = FALSE)
[13:20:26.543]             base::close(...future.stdout)
[13:20:26.543]         }, add = TRUE)
[13:20:26.543]     }
[13:20:26.543]     ...future.frame <- base::sys.nframe()
[13:20:26.543]     ...future.conditions <- base::list()
[13:20:26.543]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:26.543]     if (FALSE) {
[13:20:26.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:26.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:26.543]     }
[13:20:26.543]     ...future.result <- base::tryCatch({
[13:20:26.543]         base::withCallingHandlers({
[13:20:26.543]             ...future.value <- base::withVisible(base::local({
[13:20:26.543]                 ...future.makeSendCondition <- local({
[13:20:26.543]                   sendCondition <- NULL
[13:20:26.543]                   function(frame = 1L) {
[13:20:26.543]                     if (is.function(sendCondition)) 
[13:20:26.543]                       return(sendCondition)
[13:20:26.543]                     ns <- getNamespace("parallel")
[13:20:26.543]                     if (exists("sendData", mode = "function", 
[13:20:26.543]                       envir = ns)) {
[13:20:26.543]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:26.543]                         envir = ns)
[13:20:26.543]                       envir <- sys.frame(frame)
[13:20:26.543]                       master <- NULL
[13:20:26.543]                       while (!identical(envir, .GlobalEnv) && 
[13:20:26.543]                         !identical(envir, emptyenv())) {
[13:20:26.543]                         if (exists("master", mode = "list", envir = envir, 
[13:20:26.543]                           inherits = FALSE)) {
[13:20:26.543]                           master <- get("master", mode = "list", 
[13:20:26.543]                             envir = envir, inherits = FALSE)
[13:20:26.543]                           if (inherits(master, c("SOCKnode", 
[13:20:26.543]                             "SOCK0node"))) {
[13:20:26.543]                             sendCondition <<- function(cond) {
[13:20:26.543]                               data <- list(type = "VALUE", value = cond, 
[13:20:26.543]                                 success = TRUE)
[13:20:26.543]                               parallel_sendData(master, data)
[13:20:26.543]                             }
[13:20:26.543]                             return(sendCondition)
[13:20:26.543]                           }
[13:20:26.543]                         }
[13:20:26.543]                         frame <- frame + 1L
[13:20:26.543]                         envir <- sys.frame(frame)
[13:20:26.543]                       }
[13:20:26.543]                     }
[13:20:26.543]                     sendCondition <<- function(cond) NULL
[13:20:26.543]                   }
[13:20:26.543]                 })
[13:20:26.543]                 withCallingHandlers({
[13:20:26.543]                   NA
[13:20:26.543]                 }, immediateCondition = function(cond) {
[13:20:26.543]                   sendCondition <- ...future.makeSendCondition()
[13:20:26.543]                   sendCondition(cond)
[13:20:26.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.543]                   {
[13:20:26.543]                     inherits <- base::inherits
[13:20:26.543]                     invokeRestart <- base::invokeRestart
[13:20:26.543]                     is.null <- base::is.null
[13:20:26.543]                     muffled <- FALSE
[13:20:26.543]                     if (inherits(cond, "message")) {
[13:20:26.543]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:26.543]                       if (muffled) 
[13:20:26.543]                         invokeRestart("muffleMessage")
[13:20:26.543]                     }
[13:20:26.543]                     else if (inherits(cond, "warning")) {
[13:20:26.543]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:26.543]                       if (muffled) 
[13:20:26.543]                         invokeRestart("muffleWarning")
[13:20:26.543]                     }
[13:20:26.543]                     else if (inherits(cond, "condition")) {
[13:20:26.543]                       if (!is.null(pattern)) {
[13:20:26.543]                         computeRestarts <- base::computeRestarts
[13:20:26.543]                         grepl <- base::grepl
[13:20:26.543]                         restarts <- computeRestarts(cond)
[13:20:26.543]                         for (restart in restarts) {
[13:20:26.543]                           name <- restart$name
[13:20:26.543]                           if (is.null(name)) 
[13:20:26.543]                             next
[13:20:26.543]                           if (!grepl(pattern, name)) 
[13:20:26.543]                             next
[13:20:26.543]                           invokeRestart(restart)
[13:20:26.543]                           muffled <- TRUE
[13:20:26.543]                           break
[13:20:26.543]                         }
[13:20:26.543]                       }
[13:20:26.543]                     }
[13:20:26.543]                     invisible(muffled)
[13:20:26.543]                   }
[13:20:26.543]                   muffleCondition(cond)
[13:20:26.543]                 })
[13:20:26.543]             }))
[13:20:26.543]             future::FutureResult(value = ...future.value$value, 
[13:20:26.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.543]                   ...future.rng), globalenv = if (FALSE) 
[13:20:26.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:26.543]                     ...future.globalenv.names))
[13:20:26.543]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:26.543]         }, condition = base::local({
[13:20:26.543]             c <- base::c
[13:20:26.543]             inherits <- base::inherits
[13:20:26.543]             invokeRestart <- base::invokeRestart
[13:20:26.543]             length <- base::length
[13:20:26.543]             list <- base::list
[13:20:26.543]             seq.int <- base::seq.int
[13:20:26.543]             signalCondition <- base::signalCondition
[13:20:26.543]             sys.calls <- base::sys.calls
[13:20:26.543]             `[[` <- base::`[[`
[13:20:26.543]             `+` <- base::`+`
[13:20:26.543]             `<<-` <- base::`<<-`
[13:20:26.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:26.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:26.543]                   3L)]
[13:20:26.543]             }
[13:20:26.543]             function(cond) {
[13:20:26.543]                 is_error <- inherits(cond, "error")
[13:20:26.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:26.543]                   NULL)
[13:20:26.543]                 if (is_error) {
[13:20:26.543]                   sessionInformation <- function() {
[13:20:26.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:26.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:26.543]                       search = base::search(), system = base::Sys.info())
[13:20:26.543]                   }
[13:20:26.543]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:26.543]                     cond$call), session = sessionInformation(), 
[13:20:26.543]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:26.543]                   signalCondition(cond)
[13:20:26.543]                 }
[13:20:26.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:26.543]                 "immediateCondition"))) {
[13:20:26.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:26.543]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:26.543]                   if (TRUE && !signal) {
[13:20:26.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.543]                     {
[13:20:26.543]                       inherits <- base::inherits
[13:20:26.543]                       invokeRestart <- base::invokeRestart
[13:20:26.543]                       is.null <- base::is.null
[13:20:26.543]                       muffled <- FALSE
[13:20:26.543]                       if (inherits(cond, "message")) {
[13:20:26.543]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.543]                         if (muffled) 
[13:20:26.543]                           invokeRestart("muffleMessage")
[13:20:26.543]                       }
[13:20:26.543]                       else if (inherits(cond, "warning")) {
[13:20:26.543]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.543]                         if (muffled) 
[13:20:26.543]                           invokeRestart("muffleWarning")
[13:20:26.543]                       }
[13:20:26.543]                       else if (inherits(cond, "condition")) {
[13:20:26.543]                         if (!is.null(pattern)) {
[13:20:26.543]                           computeRestarts <- base::computeRestarts
[13:20:26.543]                           grepl <- base::grepl
[13:20:26.543]                           restarts <- computeRestarts(cond)
[13:20:26.543]                           for (restart in restarts) {
[13:20:26.543]                             name <- restart$name
[13:20:26.543]                             if (is.null(name)) 
[13:20:26.543]                               next
[13:20:26.543]                             if (!grepl(pattern, name)) 
[13:20:26.543]                               next
[13:20:26.543]                             invokeRestart(restart)
[13:20:26.543]                             muffled <- TRUE
[13:20:26.543]                             break
[13:20:26.543]                           }
[13:20:26.543]                         }
[13:20:26.543]                       }
[13:20:26.543]                       invisible(muffled)
[13:20:26.543]                     }
[13:20:26.543]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.543]                   }
[13:20:26.543]                 }
[13:20:26.543]                 else {
[13:20:26.543]                   if (TRUE) {
[13:20:26.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.543]                     {
[13:20:26.543]                       inherits <- base::inherits
[13:20:26.543]                       invokeRestart <- base::invokeRestart
[13:20:26.543]                       is.null <- base::is.null
[13:20:26.543]                       muffled <- FALSE
[13:20:26.543]                       if (inherits(cond, "message")) {
[13:20:26.543]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.543]                         if (muffled) 
[13:20:26.543]                           invokeRestart("muffleMessage")
[13:20:26.543]                       }
[13:20:26.543]                       else if (inherits(cond, "warning")) {
[13:20:26.543]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.543]                         if (muffled) 
[13:20:26.543]                           invokeRestart("muffleWarning")
[13:20:26.543]                       }
[13:20:26.543]                       else if (inherits(cond, "condition")) {
[13:20:26.543]                         if (!is.null(pattern)) {
[13:20:26.543]                           computeRestarts <- base::computeRestarts
[13:20:26.543]                           grepl <- base::grepl
[13:20:26.543]                           restarts <- computeRestarts(cond)
[13:20:26.543]                           for (restart in restarts) {
[13:20:26.543]                             name <- restart$name
[13:20:26.543]                             if (is.null(name)) 
[13:20:26.543]                               next
[13:20:26.543]                             if (!grepl(pattern, name)) 
[13:20:26.543]                               next
[13:20:26.543]                             invokeRestart(restart)
[13:20:26.543]                             muffled <- TRUE
[13:20:26.543]                             break
[13:20:26.543]                           }
[13:20:26.543]                         }
[13:20:26.543]                       }
[13:20:26.543]                       invisible(muffled)
[13:20:26.543]                     }
[13:20:26.543]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.543]                   }
[13:20:26.543]                 }
[13:20:26.543]             }
[13:20:26.543]         }))
[13:20:26.543]     }, error = function(ex) {
[13:20:26.543]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:26.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.543]                 ...future.rng), started = ...future.startTime, 
[13:20:26.543]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:26.543]             version = "1.8"), class = "FutureResult")
[13:20:26.543]     }, finally = {
[13:20:26.543]         if (!identical(...future.workdir, getwd())) 
[13:20:26.543]             setwd(...future.workdir)
[13:20:26.543]         {
[13:20:26.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:26.543]                 ...future.oldOptions$nwarnings <- NULL
[13:20:26.543]             }
[13:20:26.543]             base::options(...future.oldOptions)
[13:20:26.543]             if (.Platform$OS.type == "windows") {
[13:20:26.543]                 old_names <- names(...future.oldEnvVars)
[13:20:26.543]                 envs <- base::Sys.getenv()
[13:20:26.543]                 names <- names(envs)
[13:20:26.543]                 common <- intersect(names, old_names)
[13:20:26.543]                 added <- setdiff(names, old_names)
[13:20:26.543]                 removed <- setdiff(old_names, names)
[13:20:26.543]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:26.543]                   envs[common]]
[13:20:26.543]                 NAMES <- toupper(changed)
[13:20:26.543]                 args <- list()
[13:20:26.543]                 for (kk in seq_along(NAMES)) {
[13:20:26.543]                   name <- changed[[kk]]
[13:20:26.543]                   NAME <- NAMES[[kk]]
[13:20:26.543]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.543]                     next
[13:20:26.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.543]                 }
[13:20:26.543]                 NAMES <- toupper(added)
[13:20:26.543]                 for (kk in seq_along(NAMES)) {
[13:20:26.543]                   name <- added[[kk]]
[13:20:26.543]                   NAME <- NAMES[[kk]]
[13:20:26.543]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.543]                     next
[13:20:26.543]                   args[[name]] <- ""
[13:20:26.543]                 }
[13:20:26.543]                 NAMES <- toupper(removed)
[13:20:26.543]                 for (kk in seq_along(NAMES)) {
[13:20:26.543]                   name <- removed[[kk]]
[13:20:26.543]                   NAME <- NAMES[[kk]]
[13:20:26.543]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.543]                     next
[13:20:26.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.543]                 }
[13:20:26.543]                 if (length(args) > 0) 
[13:20:26.543]                   base::do.call(base::Sys.setenv, args = args)
[13:20:26.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:26.543]             }
[13:20:26.543]             else {
[13:20:26.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:26.543]             }
[13:20:26.543]             {
[13:20:26.543]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:26.543]                   0L) {
[13:20:26.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:26.543]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:26.543]                   base::options(opts)
[13:20:26.543]                 }
[13:20:26.543]                 {
[13:20:26.543]                   {
[13:20:26.543]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:26.543]                     NULL
[13:20:26.543]                   }
[13:20:26.543]                   options(future.plan = NULL)
[13:20:26.543]                   if (is.na(NA_character_)) 
[13:20:26.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:26.543]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:26.543]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:26.543]                     envir = parent.frame()) 
[13:20:26.543]                   {
[13:20:26.543]                     if (is.function(workers)) 
[13:20:26.543]                       workers <- workers()
[13:20:26.543]                     workers <- structure(as.integer(workers), 
[13:20:26.543]                       class = class(workers))
[13:20:26.543]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:26.543]                       workers >= 1)
[13:20:26.543]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:26.543]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:26.543]                     }
[13:20:26.543]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:26.543]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:26.543]                       envir = envir)
[13:20:26.543]                     if (!future$lazy) 
[13:20:26.543]                       future <- run(future)
[13:20:26.543]                     invisible(future)
[13:20:26.543]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:26.543]                 }
[13:20:26.543]             }
[13:20:26.543]         }
[13:20:26.543]     })
[13:20:26.543]     if (TRUE) {
[13:20:26.543]         base::sink(type = "output", split = FALSE)
[13:20:26.543]         if (TRUE) {
[13:20:26.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:26.543]         }
[13:20:26.543]         else {
[13:20:26.543]             ...future.result["stdout"] <- base::list(NULL)
[13:20:26.543]         }
[13:20:26.543]         base::close(...future.stdout)
[13:20:26.543]         ...future.stdout <- NULL
[13:20:26.543]     }
[13:20:26.543]     ...future.result$conditions <- ...future.conditions
[13:20:26.543]     ...future.result$finished <- base::Sys.time()
[13:20:26.543]     ...future.result
[13:20:26.543] }
[13:20:26.614] MultisessionFuture started
[13:20:26.615] result() for ClusterFuture ...
[13:20:26.615] receiveMessageFromWorker() for ClusterFuture ...
[13:20:26.616] - Validating connection of MultisessionFuture
[13:20:26.647] - received message: FutureResult
[13:20:26.647] - Received FutureResult
[13:20:26.648] - Erased future from FutureRegistry
[13:20:26.648] result() for ClusterFuture ...
[13:20:26.648] - result already collected: FutureResult
[13:20:26.648] result() for ClusterFuture ... done
[13:20:26.648] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:26.648] result() for ClusterFuture ... done
[13:20:26.648] result() for ClusterFuture ...
[13:20:26.648] - result already collected: FutureResult
[13:20:26.649] result() for ClusterFuture ... done
[13:20:26.649] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:20:26.653] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:20:26.653] getGlobalsAndPackages() ...
[13:20:26.653] Searching for globals...
[13:20:26.654] 
[13:20:26.654] Searching for globals ... DONE
[13:20:26.654] - globals: [0] <none>
[13:20:26.654] getGlobalsAndPackages() ... DONE
[13:20:26.654] run() for ‘Future’ ...
[13:20:26.654] - state: ‘created’
[13:20:26.655] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:26.670] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:26.670] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:26.670]   - Field: ‘node’
[13:20:26.670]   - Field: ‘label’
[13:20:26.671]   - Field: ‘local’
[13:20:26.671]   - Field: ‘owner’
[13:20:26.671]   - Field: ‘envir’
[13:20:26.671]   - Field: ‘workers’
[13:20:26.671]   - Field: ‘packages’
[13:20:26.671]   - Field: ‘gc’
[13:20:26.671]   - Field: ‘conditions’
[13:20:26.671]   - Field: ‘persistent’
[13:20:26.671]   - Field: ‘expr’
[13:20:26.672]   - Field: ‘uuid’
[13:20:26.672]   - Field: ‘seed’
[13:20:26.672]   - Field: ‘version’
[13:20:26.672]   - Field: ‘result’
[13:20:26.672]   - Field: ‘asynchronous’
[13:20:26.672]   - Field: ‘calls’
[13:20:26.672]   - Field: ‘globals’
[13:20:26.672]   - Field: ‘stdout’
[13:20:26.673]   - Field: ‘earlySignal’
[13:20:26.673]   - Field: ‘lazy’
[13:20:26.673]   - Field: ‘state’
[13:20:26.673] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:26.673] - Launch lazy future ...
[13:20:26.673] Packages needed by the future expression (n = 0): <none>
[13:20:26.674] Packages needed by future strategies (n = 0): <none>
[13:20:26.674] {
[13:20:26.674]     {
[13:20:26.674]         {
[13:20:26.674]             ...future.startTime <- base::Sys.time()
[13:20:26.674]             {
[13:20:26.674]                 {
[13:20:26.674]                   {
[13:20:26.674]                     {
[13:20:26.674]                       base::local({
[13:20:26.674]                         has_future <- base::requireNamespace("future", 
[13:20:26.674]                           quietly = TRUE)
[13:20:26.674]                         if (has_future) {
[13:20:26.674]                           ns <- base::getNamespace("future")
[13:20:26.674]                           version <- ns[[".package"]][["version"]]
[13:20:26.674]                           if (is.null(version)) 
[13:20:26.674]                             version <- utils::packageVersion("future")
[13:20:26.674]                         }
[13:20:26.674]                         else {
[13:20:26.674]                           version <- NULL
[13:20:26.674]                         }
[13:20:26.674]                         if (!has_future || version < "1.8.0") {
[13:20:26.674]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:26.674]                             "", base::R.version$version.string), 
[13:20:26.674]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:26.674]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:26.674]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:26.674]                               "release", "version")], collapse = " "), 
[13:20:26.674]                             hostname = base::Sys.info()[["nodename"]])
[13:20:26.674]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:26.674]                             info)
[13:20:26.674]                           info <- base::paste(info, collapse = "; ")
[13:20:26.674]                           if (!has_future) {
[13:20:26.674]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:26.674]                               info)
[13:20:26.674]                           }
[13:20:26.674]                           else {
[13:20:26.674]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:26.674]                               info, version)
[13:20:26.674]                           }
[13:20:26.674]                           base::stop(msg)
[13:20:26.674]                         }
[13:20:26.674]                       })
[13:20:26.674]                     }
[13:20:26.674]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:26.674]                     base::options(mc.cores = 1L)
[13:20:26.674]                   }
[13:20:26.674]                   options(future.plan = NULL)
[13:20:26.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:26.674]                 }
[13:20:26.674]                 ...future.workdir <- getwd()
[13:20:26.674]             }
[13:20:26.674]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:26.674]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:26.674]         }
[13:20:26.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:26.674]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:26.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:26.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:26.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:26.674]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:26.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:26.674]             base::names(...future.oldOptions))
[13:20:26.674]     }
[13:20:26.674]     if (FALSE) {
[13:20:26.674]     }
[13:20:26.674]     else {
[13:20:26.674]         if (TRUE) {
[13:20:26.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:26.674]                 open = "w")
[13:20:26.674]         }
[13:20:26.674]         else {
[13:20:26.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:26.674]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:26.674]         }
[13:20:26.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:26.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:26.674]             base::sink(type = "output", split = FALSE)
[13:20:26.674]             base::close(...future.stdout)
[13:20:26.674]         }, add = TRUE)
[13:20:26.674]     }
[13:20:26.674]     ...future.frame <- base::sys.nframe()
[13:20:26.674]     ...future.conditions <- base::list()
[13:20:26.674]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:26.674]     if (FALSE) {
[13:20:26.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:26.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:26.674]     }
[13:20:26.674]     ...future.result <- base::tryCatch({
[13:20:26.674]         base::withCallingHandlers({
[13:20:26.674]             ...future.value <- base::withVisible(base::local({
[13:20:26.674]                 ...future.makeSendCondition <- local({
[13:20:26.674]                   sendCondition <- NULL
[13:20:26.674]                   function(frame = 1L) {
[13:20:26.674]                     if (is.function(sendCondition)) 
[13:20:26.674]                       return(sendCondition)
[13:20:26.674]                     ns <- getNamespace("parallel")
[13:20:26.674]                     if (exists("sendData", mode = "function", 
[13:20:26.674]                       envir = ns)) {
[13:20:26.674]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:26.674]                         envir = ns)
[13:20:26.674]                       envir <- sys.frame(frame)
[13:20:26.674]                       master <- NULL
[13:20:26.674]                       while (!identical(envir, .GlobalEnv) && 
[13:20:26.674]                         !identical(envir, emptyenv())) {
[13:20:26.674]                         if (exists("master", mode = "list", envir = envir, 
[13:20:26.674]                           inherits = FALSE)) {
[13:20:26.674]                           master <- get("master", mode = "list", 
[13:20:26.674]                             envir = envir, inherits = FALSE)
[13:20:26.674]                           if (inherits(master, c("SOCKnode", 
[13:20:26.674]                             "SOCK0node"))) {
[13:20:26.674]                             sendCondition <<- function(cond) {
[13:20:26.674]                               data <- list(type = "VALUE", value = cond, 
[13:20:26.674]                                 success = TRUE)
[13:20:26.674]                               parallel_sendData(master, data)
[13:20:26.674]                             }
[13:20:26.674]                             return(sendCondition)
[13:20:26.674]                           }
[13:20:26.674]                         }
[13:20:26.674]                         frame <- frame + 1L
[13:20:26.674]                         envir <- sys.frame(frame)
[13:20:26.674]                       }
[13:20:26.674]                     }
[13:20:26.674]                     sendCondition <<- function(cond) NULL
[13:20:26.674]                   }
[13:20:26.674]                 })
[13:20:26.674]                 withCallingHandlers({
[13:20:26.674]                   2
[13:20:26.674]                 }, immediateCondition = function(cond) {
[13:20:26.674]                   sendCondition <- ...future.makeSendCondition()
[13:20:26.674]                   sendCondition(cond)
[13:20:26.674]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.674]                   {
[13:20:26.674]                     inherits <- base::inherits
[13:20:26.674]                     invokeRestart <- base::invokeRestart
[13:20:26.674]                     is.null <- base::is.null
[13:20:26.674]                     muffled <- FALSE
[13:20:26.674]                     if (inherits(cond, "message")) {
[13:20:26.674]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:26.674]                       if (muffled) 
[13:20:26.674]                         invokeRestart("muffleMessage")
[13:20:26.674]                     }
[13:20:26.674]                     else if (inherits(cond, "warning")) {
[13:20:26.674]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:26.674]                       if (muffled) 
[13:20:26.674]                         invokeRestart("muffleWarning")
[13:20:26.674]                     }
[13:20:26.674]                     else if (inherits(cond, "condition")) {
[13:20:26.674]                       if (!is.null(pattern)) {
[13:20:26.674]                         computeRestarts <- base::computeRestarts
[13:20:26.674]                         grepl <- base::grepl
[13:20:26.674]                         restarts <- computeRestarts(cond)
[13:20:26.674]                         for (restart in restarts) {
[13:20:26.674]                           name <- restart$name
[13:20:26.674]                           if (is.null(name)) 
[13:20:26.674]                             next
[13:20:26.674]                           if (!grepl(pattern, name)) 
[13:20:26.674]                             next
[13:20:26.674]                           invokeRestart(restart)
[13:20:26.674]                           muffled <- TRUE
[13:20:26.674]                           break
[13:20:26.674]                         }
[13:20:26.674]                       }
[13:20:26.674]                     }
[13:20:26.674]                     invisible(muffled)
[13:20:26.674]                   }
[13:20:26.674]                   muffleCondition(cond)
[13:20:26.674]                 })
[13:20:26.674]             }))
[13:20:26.674]             future::FutureResult(value = ...future.value$value, 
[13:20:26.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.674]                   ...future.rng), globalenv = if (FALSE) 
[13:20:26.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:26.674]                     ...future.globalenv.names))
[13:20:26.674]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:26.674]         }, condition = base::local({
[13:20:26.674]             c <- base::c
[13:20:26.674]             inherits <- base::inherits
[13:20:26.674]             invokeRestart <- base::invokeRestart
[13:20:26.674]             length <- base::length
[13:20:26.674]             list <- base::list
[13:20:26.674]             seq.int <- base::seq.int
[13:20:26.674]             signalCondition <- base::signalCondition
[13:20:26.674]             sys.calls <- base::sys.calls
[13:20:26.674]             `[[` <- base::`[[`
[13:20:26.674]             `+` <- base::`+`
[13:20:26.674]             `<<-` <- base::`<<-`
[13:20:26.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:26.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:26.674]                   3L)]
[13:20:26.674]             }
[13:20:26.674]             function(cond) {
[13:20:26.674]                 is_error <- inherits(cond, "error")
[13:20:26.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:26.674]                   NULL)
[13:20:26.674]                 if (is_error) {
[13:20:26.674]                   sessionInformation <- function() {
[13:20:26.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:26.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:26.674]                       search = base::search(), system = base::Sys.info())
[13:20:26.674]                   }
[13:20:26.674]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:26.674]                     cond$call), session = sessionInformation(), 
[13:20:26.674]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:26.674]                   signalCondition(cond)
[13:20:26.674]                 }
[13:20:26.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:26.674]                 "immediateCondition"))) {
[13:20:26.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:26.674]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:26.674]                   if (TRUE && !signal) {
[13:20:26.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.674]                     {
[13:20:26.674]                       inherits <- base::inherits
[13:20:26.674]                       invokeRestart <- base::invokeRestart
[13:20:26.674]                       is.null <- base::is.null
[13:20:26.674]                       muffled <- FALSE
[13:20:26.674]                       if (inherits(cond, "message")) {
[13:20:26.674]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.674]                         if (muffled) 
[13:20:26.674]                           invokeRestart("muffleMessage")
[13:20:26.674]                       }
[13:20:26.674]                       else if (inherits(cond, "warning")) {
[13:20:26.674]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.674]                         if (muffled) 
[13:20:26.674]                           invokeRestart("muffleWarning")
[13:20:26.674]                       }
[13:20:26.674]                       else if (inherits(cond, "condition")) {
[13:20:26.674]                         if (!is.null(pattern)) {
[13:20:26.674]                           computeRestarts <- base::computeRestarts
[13:20:26.674]                           grepl <- base::grepl
[13:20:26.674]                           restarts <- computeRestarts(cond)
[13:20:26.674]                           for (restart in restarts) {
[13:20:26.674]                             name <- restart$name
[13:20:26.674]                             if (is.null(name)) 
[13:20:26.674]                               next
[13:20:26.674]                             if (!grepl(pattern, name)) 
[13:20:26.674]                               next
[13:20:26.674]                             invokeRestart(restart)
[13:20:26.674]                             muffled <- TRUE
[13:20:26.674]                             break
[13:20:26.674]                           }
[13:20:26.674]                         }
[13:20:26.674]                       }
[13:20:26.674]                       invisible(muffled)
[13:20:26.674]                     }
[13:20:26.674]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.674]                   }
[13:20:26.674]                 }
[13:20:26.674]                 else {
[13:20:26.674]                   if (TRUE) {
[13:20:26.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.674]                     {
[13:20:26.674]                       inherits <- base::inherits
[13:20:26.674]                       invokeRestart <- base::invokeRestart
[13:20:26.674]                       is.null <- base::is.null
[13:20:26.674]                       muffled <- FALSE
[13:20:26.674]                       if (inherits(cond, "message")) {
[13:20:26.674]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.674]                         if (muffled) 
[13:20:26.674]                           invokeRestart("muffleMessage")
[13:20:26.674]                       }
[13:20:26.674]                       else if (inherits(cond, "warning")) {
[13:20:26.674]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.674]                         if (muffled) 
[13:20:26.674]                           invokeRestart("muffleWarning")
[13:20:26.674]                       }
[13:20:26.674]                       else if (inherits(cond, "condition")) {
[13:20:26.674]                         if (!is.null(pattern)) {
[13:20:26.674]                           computeRestarts <- base::computeRestarts
[13:20:26.674]                           grepl <- base::grepl
[13:20:26.674]                           restarts <- computeRestarts(cond)
[13:20:26.674]                           for (restart in restarts) {
[13:20:26.674]                             name <- restart$name
[13:20:26.674]                             if (is.null(name)) 
[13:20:26.674]                               next
[13:20:26.674]                             if (!grepl(pattern, name)) 
[13:20:26.674]                               next
[13:20:26.674]                             invokeRestart(restart)
[13:20:26.674]                             muffled <- TRUE
[13:20:26.674]                             break
[13:20:26.674]                           }
[13:20:26.674]                         }
[13:20:26.674]                       }
[13:20:26.674]                       invisible(muffled)
[13:20:26.674]                     }
[13:20:26.674]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.674]                   }
[13:20:26.674]                 }
[13:20:26.674]             }
[13:20:26.674]         }))
[13:20:26.674]     }, error = function(ex) {
[13:20:26.674]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:26.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.674]                 ...future.rng), started = ...future.startTime, 
[13:20:26.674]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:26.674]             version = "1.8"), class = "FutureResult")
[13:20:26.674]     }, finally = {
[13:20:26.674]         if (!identical(...future.workdir, getwd())) 
[13:20:26.674]             setwd(...future.workdir)
[13:20:26.674]         {
[13:20:26.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:26.674]                 ...future.oldOptions$nwarnings <- NULL
[13:20:26.674]             }
[13:20:26.674]             base::options(...future.oldOptions)
[13:20:26.674]             if (.Platform$OS.type == "windows") {
[13:20:26.674]                 old_names <- names(...future.oldEnvVars)
[13:20:26.674]                 envs <- base::Sys.getenv()
[13:20:26.674]                 names <- names(envs)
[13:20:26.674]                 common <- intersect(names, old_names)
[13:20:26.674]                 added <- setdiff(names, old_names)
[13:20:26.674]                 removed <- setdiff(old_names, names)
[13:20:26.674]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:26.674]                   envs[common]]
[13:20:26.674]                 NAMES <- toupper(changed)
[13:20:26.674]                 args <- list()
[13:20:26.674]                 for (kk in seq_along(NAMES)) {
[13:20:26.674]                   name <- changed[[kk]]
[13:20:26.674]                   NAME <- NAMES[[kk]]
[13:20:26.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.674]                     next
[13:20:26.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.674]                 }
[13:20:26.674]                 NAMES <- toupper(added)
[13:20:26.674]                 for (kk in seq_along(NAMES)) {
[13:20:26.674]                   name <- added[[kk]]
[13:20:26.674]                   NAME <- NAMES[[kk]]
[13:20:26.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.674]                     next
[13:20:26.674]                   args[[name]] <- ""
[13:20:26.674]                 }
[13:20:26.674]                 NAMES <- toupper(removed)
[13:20:26.674]                 for (kk in seq_along(NAMES)) {
[13:20:26.674]                   name <- removed[[kk]]
[13:20:26.674]                   NAME <- NAMES[[kk]]
[13:20:26.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.674]                     next
[13:20:26.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.674]                 }
[13:20:26.674]                 if (length(args) > 0) 
[13:20:26.674]                   base::do.call(base::Sys.setenv, args = args)
[13:20:26.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:26.674]             }
[13:20:26.674]             else {
[13:20:26.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:26.674]             }
[13:20:26.674]             {
[13:20:26.674]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:26.674]                   0L) {
[13:20:26.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:26.674]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:26.674]                   base::options(opts)
[13:20:26.674]                 }
[13:20:26.674]                 {
[13:20:26.674]                   {
[13:20:26.674]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:26.674]                     NULL
[13:20:26.674]                   }
[13:20:26.674]                   options(future.plan = NULL)
[13:20:26.674]                   if (is.na(NA_character_)) 
[13:20:26.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:26.674]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:26.674]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:26.674]                     envir = parent.frame()) 
[13:20:26.674]                   {
[13:20:26.674]                     if (is.function(workers)) 
[13:20:26.674]                       workers <- workers()
[13:20:26.674]                     workers <- structure(as.integer(workers), 
[13:20:26.674]                       class = class(workers))
[13:20:26.674]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:26.674]                       workers >= 1)
[13:20:26.674]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:26.674]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:26.674]                     }
[13:20:26.674]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:26.674]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:26.674]                       envir = envir)
[13:20:26.674]                     if (!future$lazy) 
[13:20:26.674]                       future <- run(future)
[13:20:26.674]                     invisible(future)
[13:20:26.674]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:26.674]                 }
[13:20:26.674]             }
[13:20:26.674]         }
[13:20:26.674]     })
[13:20:26.674]     if (TRUE) {
[13:20:26.674]         base::sink(type = "output", split = FALSE)
[13:20:26.674]         if (TRUE) {
[13:20:26.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:26.674]         }
[13:20:26.674]         else {
[13:20:26.674]             ...future.result["stdout"] <- base::list(NULL)
[13:20:26.674]         }
[13:20:26.674]         base::close(...future.stdout)
[13:20:26.674]         ...future.stdout <- NULL
[13:20:26.674]     }
[13:20:26.674]     ...future.result$conditions <- ...future.conditions
[13:20:26.674]     ...future.result$finished <- base::Sys.time()
[13:20:26.674]     ...future.result
[13:20:26.674] }
[13:20:26.678] MultisessionFuture started
[13:20:26.678] - Launch lazy future ... done
[13:20:26.678] run() for ‘MultisessionFuture’ ... done
[13:20:26.678] getGlobalsAndPackages() ...
[13:20:26.678] Searching for globals...
[13:20:26.679] 
[13:20:26.679] Searching for globals ... DONE
[13:20:26.679] - globals: [0] <none>
[13:20:26.679] getGlobalsAndPackages() ... DONE
[13:20:26.680] run() for ‘Future’ ...
[13:20:26.680] - state: ‘created’
[13:20:26.680] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:26.696] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:26.697] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:26.697]   - Field: ‘node’
[13:20:26.697]   - Field: ‘label’
[13:20:26.697]   - Field: ‘local’
[13:20:26.697]   - Field: ‘owner’
[13:20:26.697]   - Field: ‘envir’
[13:20:26.697]   - Field: ‘workers’
[13:20:26.697]   - Field: ‘packages’
[13:20:26.698]   - Field: ‘gc’
[13:20:26.698]   - Field: ‘conditions’
[13:20:26.698]   - Field: ‘persistent’
[13:20:26.698]   - Field: ‘expr’
[13:20:26.698]   - Field: ‘uuid’
[13:20:26.698]   - Field: ‘seed’
[13:20:26.698]   - Field: ‘version’
[13:20:26.698]   - Field: ‘result’
[13:20:26.699]   - Field: ‘asynchronous’
[13:20:26.699]   - Field: ‘calls’
[13:20:26.699]   - Field: ‘globals’
[13:20:26.699]   - Field: ‘stdout’
[13:20:26.699]   - Field: ‘earlySignal’
[13:20:26.699]   - Field: ‘lazy’
[13:20:26.699]   - Field: ‘state’
[13:20:26.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:26.699] - Launch lazy future ...
[13:20:26.700] Packages needed by the future expression (n = 0): <none>
[13:20:26.700] Packages needed by future strategies (n = 0): <none>
[13:20:26.701] {
[13:20:26.701]     {
[13:20:26.701]         {
[13:20:26.701]             ...future.startTime <- base::Sys.time()
[13:20:26.701]             {
[13:20:26.701]                 {
[13:20:26.701]                   {
[13:20:26.701]                     {
[13:20:26.701]                       base::local({
[13:20:26.701]                         has_future <- base::requireNamespace("future", 
[13:20:26.701]                           quietly = TRUE)
[13:20:26.701]                         if (has_future) {
[13:20:26.701]                           ns <- base::getNamespace("future")
[13:20:26.701]                           version <- ns[[".package"]][["version"]]
[13:20:26.701]                           if (is.null(version)) 
[13:20:26.701]                             version <- utils::packageVersion("future")
[13:20:26.701]                         }
[13:20:26.701]                         else {
[13:20:26.701]                           version <- NULL
[13:20:26.701]                         }
[13:20:26.701]                         if (!has_future || version < "1.8.0") {
[13:20:26.701]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:26.701]                             "", base::R.version$version.string), 
[13:20:26.701]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:26.701]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:26.701]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:26.701]                               "release", "version")], collapse = " "), 
[13:20:26.701]                             hostname = base::Sys.info()[["nodename"]])
[13:20:26.701]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:26.701]                             info)
[13:20:26.701]                           info <- base::paste(info, collapse = "; ")
[13:20:26.701]                           if (!has_future) {
[13:20:26.701]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:26.701]                               info)
[13:20:26.701]                           }
[13:20:26.701]                           else {
[13:20:26.701]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:26.701]                               info, version)
[13:20:26.701]                           }
[13:20:26.701]                           base::stop(msg)
[13:20:26.701]                         }
[13:20:26.701]                       })
[13:20:26.701]                     }
[13:20:26.701]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:26.701]                     base::options(mc.cores = 1L)
[13:20:26.701]                   }
[13:20:26.701]                   options(future.plan = NULL)
[13:20:26.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:26.701]                 }
[13:20:26.701]                 ...future.workdir <- getwd()
[13:20:26.701]             }
[13:20:26.701]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:26.701]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:26.701]         }
[13:20:26.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:26.701]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:26.701]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:26.701]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:26.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:26.701]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:26.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:26.701]             base::names(...future.oldOptions))
[13:20:26.701]     }
[13:20:26.701]     if (FALSE) {
[13:20:26.701]     }
[13:20:26.701]     else {
[13:20:26.701]         if (TRUE) {
[13:20:26.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:26.701]                 open = "w")
[13:20:26.701]         }
[13:20:26.701]         else {
[13:20:26.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:26.701]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:26.701]         }
[13:20:26.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:26.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:26.701]             base::sink(type = "output", split = FALSE)
[13:20:26.701]             base::close(...future.stdout)
[13:20:26.701]         }, add = TRUE)
[13:20:26.701]     }
[13:20:26.701]     ...future.frame <- base::sys.nframe()
[13:20:26.701]     ...future.conditions <- base::list()
[13:20:26.701]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:26.701]     if (FALSE) {
[13:20:26.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:26.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:26.701]     }
[13:20:26.701]     ...future.result <- base::tryCatch({
[13:20:26.701]         base::withCallingHandlers({
[13:20:26.701]             ...future.value <- base::withVisible(base::local({
[13:20:26.701]                 ...future.makeSendCondition <- local({
[13:20:26.701]                   sendCondition <- NULL
[13:20:26.701]                   function(frame = 1L) {
[13:20:26.701]                     if (is.function(sendCondition)) 
[13:20:26.701]                       return(sendCondition)
[13:20:26.701]                     ns <- getNamespace("parallel")
[13:20:26.701]                     if (exists("sendData", mode = "function", 
[13:20:26.701]                       envir = ns)) {
[13:20:26.701]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:26.701]                         envir = ns)
[13:20:26.701]                       envir <- sys.frame(frame)
[13:20:26.701]                       master <- NULL
[13:20:26.701]                       while (!identical(envir, .GlobalEnv) && 
[13:20:26.701]                         !identical(envir, emptyenv())) {
[13:20:26.701]                         if (exists("master", mode = "list", envir = envir, 
[13:20:26.701]                           inherits = FALSE)) {
[13:20:26.701]                           master <- get("master", mode = "list", 
[13:20:26.701]                             envir = envir, inherits = FALSE)
[13:20:26.701]                           if (inherits(master, c("SOCKnode", 
[13:20:26.701]                             "SOCK0node"))) {
[13:20:26.701]                             sendCondition <<- function(cond) {
[13:20:26.701]                               data <- list(type = "VALUE", value = cond, 
[13:20:26.701]                                 success = TRUE)
[13:20:26.701]                               parallel_sendData(master, data)
[13:20:26.701]                             }
[13:20:26.701]                             return(sendCondition)
[13:20:26.701]                           }
[13:20:26.701]                         }
[13:20:26.701]                         frame <- frame + 1L
[13:20:26.701]                         envir <- sys.frame(frame)
[13:20:26.701]                       }
[13:20:26.701]                     }
[13:20:26.701]                     sendCondition <<- function(cond) NULL
[13:20:26.701]                   }
[13:20:26.701]                 })
[13:20:26.701]                 withCallingHandlers({
[13:20:26.701]                   NULL
[13:20:26.701]                 }, immediateCondition = function(cond) {
[13:20:26.701]                   sendCondition <- ...future.makeSendCondition()
[13:20:26.701]                   sendCondition(cond)
[13:20:26.701]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.701]                   {
[13:20:26.701]                     inherits <- base::inherits
[13:20:26.701]                     invokeRestart <- base::invokeRestart
[13:20:26.701]                     is.null <- base::is.null
[13:20:26.701]                     muffled <- FALSE
[13:20:26.701]                     if (inherits(cond, "message")) {
[13:20:26.701]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:26.701]                       if (muffled) 
[13:20:26.701]                         invokeRestart("muffleMessage")
[13:20:26.701]                     }
[13:20:26.701]                     else if (inherits(cond, "warning")) {
[13:20:26.701]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:26.701]                       if (muffled) 
[13:20:26.701]                         invokeRestart("muffleWarning")
[13:20:26.701]                     }
[13:20:26.701]                     else if (inherits(cond, "condition")) {
[13:20:26.701]                       if (!is.null(pattern)) {
[13:20:26.701]                         computeRestarts <- base::computeRestarts
[13:20:26.701]                         grepl <- base::grepl
[13:20:26.701]                         restarts <- computeRestarts(cond)
[13:20:26.701]                         for (restart in restarts) {
[13:20:26.701]                           name <- restart$name
[13:20:26.701]                           if (is.null(name)) 
[13:20:26.701]                             next
[13:20:26.701]                           if (!grepl(pattern, name)) 
[13:20:26.701]                             next
[13:20:26.701]                           invokeRestart(restart)
[13:20:26.701]                           muffled <- TRUE
[13:20:26.701]                           break
[13:20:26.701]                         }
[13:20:26.701]                       }
[13:20:26.701]                     }
[13:20:26.701]                     invisible(muffled)
[13:20:26.701]                   }
[13:20:26.701]                   muffleCondition(cond)
[13:20:26.701]                 })
[13:20:26.701]             }))
[13:20:26.701]             future::FutureResult(value = ...future.value$value, 
[13:20:26.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.701]                   ...future.rng), globalenv = if (FALSE) 
[13:20:26.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:26.701]                     ...future.globalenv.names))
[13:20:26.701]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:26.701]         }, condition = base::local({
[13:20:26.701]             c <- base::c
[13:20:26.701]             inherits <- base::inherits
[13:20:26.701]             invokeRestart <- base::invokeRestart
[13:20:26.701]             length <- base::length
[13:20:26.701]             list <- base::list
[13:20:26.701]             seq.int <- base::seq.int
[13:20:26.701]             signalCondition <- base::signalCondition
[13:20:26.701]             sys.calls <- base::sys.calls
[13:20:26.701]             `[[` <- base::`[[`
[13:20:26.701]             `+` <- base::`+`
[13:20:26.701]             `<<-` <- base::`<<-`
[13:20:26.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:26.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:26.701]                   3L)]
[13:20:26.701]             }
[13:20:26.701]             function(cond) {
[13:20:26.701]                 is_error <- inherits(cond, "error")
[13:20:26.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:26.701]                   NULL)
[13:20:26.701]                 if (is_error) {
[13:20:26.701]                   sessionInformation <- function() {
[13:20:26.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:26.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:26.701]                       search = base::search(), system = base::Sys.info())
[13:20:26.701]                   }
[13:20:26.701]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:26.701]                     cond$call), session = sessionInformation(), 
[13:20:26.701]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:26.701]                   signalCondition(cond)
[13:20:26.701]                 }
[13:20:26.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:26.701]                 "immediateCondition"))) {
[13:20:26.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:26.701]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:26.701]                   if (TRUE && !signal) {
[13:20:26.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.701]                     {
[13:20:26.701]                       inherits <- base::inherits
[13:20:26.701]                       invokeRestart <- base::invokeRestart
[13:20:26.701]                       is.null <- base::is.null
[13:20:26.701]                       muffled <- FALSE
[13:20:26.701]                       if (inherits(cond, "message")) {
[13:20:26.701]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.701]                         if (muffled) 
[13:20:26.701]                           invokeRestart("muffleMessage")
[13:20:26.701]                       }
[13:20:26.701]                       else if (inherits(cond, "warning")) {
[13:20:26.701]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.701]                         if (muffled) 
[13:20:26.701]                           invokeRestart("muffleWarning")
[13:20:26.701]                       }
[13:20:26.701]                       else if (inherits(cond, "condition")) {
[13:20:26.701]                         if (!is.null(pattern)) {
[13:20:26.701]                           computeRestarts <- base::computeRestarts
[13:20:26.701]                           grepl <- base::grepl
[13:20:26.701]                           restarts <- computeRestarts(cond)
[13:20:26.701]                           for (restart in restarts) {
[13:20:26.701]                             name <- restart$name
[13:20:26.701]                             if (is.null(name)) 
[13:20:26.701]                               next
[13:20:26.701]                             if (!grepl(pattern, name)) 
[13:20:26.701]                               next
[13:20:26.701]                             invokeRestart(restart)
[13:20:26.701]                             muffled <- TRUE
[13:20:26.701]                             break
[13:20:26.701]                           }
[13:20:26.701]                         }
[13:20:26.701]                       }
[13:20:26.701]                       invisible(muffled)
[13:20:26.701]                     }
[13:20:26.701]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.701]                   }
[13:20:26.701]                 }
[13:20:26.701]                 else {
[13:20:26.701]                   if (TRUE) {
[13:20:26.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.701]                     {
[13:20:26.701]                       inherits <- base::inherits
[13:20:26.701]                       invokeRestart <- base::invokeRestart
[13:20:26.701]                       is.null <- base::is.null
[13:20:26.701]                       muffled <- FALSE
[13:20:26.701]                       if (inherits(cond, "message")) {
[13:20:26.701]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.701]                         if (muffled) 
[13:20:26.701]                           invokeRestart("muffleMessage")
[13:20:26.701]                       }
[13:20:26.701]                       else if (inherits(cond, "warning")) {
[13:20:26.701]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.701]                         if (muffled) 
[13:20:26.701]                           invokeRestart("muffleWarning")
[13:20:26.701]                       }
[13:20:26.701]                       else if (inherits(cond, "condition")) {
[13:20:26.701]                         if (!is.null(pattern)) {
[13:20:26.701]                           computeRestarts <- base::computeRestarts
[13:20:26.701]                           grepl <- base::grepl
[13:20:26.701]                           restarts <- computeRestarts(cond)
[13:20:26.701]                           for (restart in restarts) {
[13:20:26.701]                             name <- restart$name
[13:20:26.701]                             if (is.null(name)) 
[13:20:26.701]                               next
[13:20:26.701]                             if (!grepl(pattern, name)) 
[13:20:26.701]                               next
[13:20:26.701]                             invokeRestart(restart)
[13:20:26.701]                             muffled <- TRUE
[13:20:26.701]                             break
[13:20:26.701]                           }
[13:20:26.701]                         }
[13:20:26.701]                       }
[13:20:26.701]                       invisible(muffled)
[13:20:26.701]                     }
[13:20:26.701]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.701]                   }
[13:20:26.701]                 }
[13:20:26.701]             }
[13:20:26.701]         }))
[13:20:26.701]     }, error = function(ex) {
[13:20:26.701]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:26.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.701]                 ...future.rng), started = ...future.startTime, 
[13:20:26.701]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:26.701]             version = "1.8"), class = "FutureResult")
[13:20:26.701]     }, finally = {
[13:20:26.701]         if (!identical(...future.workdir, getwd())) 
[13:20:26.701]             setwd(...future.workdir)
[13:20:26.701]         {
[13:20:26.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:26.701]                 ...future.oldOptions$nwarnings <- NULL
[13:20:26.701]             }
[13:20:26.701]             base::options(...future.oldOptions)
[13:20:26.701]             if (.Platform$OS.type == "windows") {
[13:20:26.701]                 old_names <- names(...future.oldEnvVars)
[13:20:26.701]                 envs <- base::Sys.getenv()
[13:20:26.701]                 names <- names(envs)
[13:20:26.701]                 common <- intersect(names, old_names)
[13:20:26.701]                 added <- setdiff(names, old_names)
[13:20:26.701]                 removed <- setdiff(old_names, names)
[13:20:26.701]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:26.701]                   envs[common]]
[13:20:26.701]                 NAMES <- toupper(changed)
[13:20:26.701]                 args <- list()
[13:20:26.701]                 for (kk in seq_along(NAMES)) {
[13:20:26.701]                   name <- changed[[kk]]
[13:20:26.701]                   NAME <- NAMES[[kk]]
[13:20:26.701]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.701]                     next
[13:20:26.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.701]                 }
[13:20:26.701]                 NAMES <- toupper(added)
[13:20:26.701]                 for (kk in seq_along(NAMES)) {
[13:20:26.701]                   name <- added[[kk]]
[13:20:26.701]                   NAME <- NAMES[[kk]]
[13:20:26.701]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.701]                     next
[13:20:26.701]                   args[[name]] <- ""
[13:20:26.701]                 }
[13:20:26.701]                 NAMES <- toupper(removed)
[13:20:26.701]                 for (kk in seq_along(NAMES)) {
[13:20:26.701]                   name <- removed[[kk]]
[13:20:26.701]                   NAME <- NAMES[[kk]]
[13:20:26.701]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.701]                     next
[13:20:26.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.701]                 }
[13:20:26.701]                 if (length(args) > 0) 
[13:20:26.701]                   base::do.call(base::Sys.setenv, args = args)
[13:20:26.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:26.701]             }
[13:20:26.701]             else {
[13:20:26.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:26.701]             }
[13:20:26.701]             {
[13:20:26.701]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:26.701]                   0L) {
[13:20:26.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:26.701]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:26.701]                   base::options(opts)
[13:20:26.701]                 }
[13:20:26.701]                 {
[13:20:26.701]                   {
[13:20:26.701]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:26.701]                     NULL
[13:20:26.701]                   }
[13:20:26.701]                   options(future.plan = NULL)
[13:20:26.701]                   if (is.na(NA_character_)) 
[13:20:26.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:26.701]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:26.701]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:26.701]                     envir = parent.frame()) 
[13:20:26.701]                   {
[13:20:26.701]                     if (is.function(workers)) 
[13:20:26.701]                       workers <- workers()
[13:20:26.701]                     workers <- structure(as.integer(workers), 
[13:20:26.701]                       class = class(workers))
[13:20:26.701]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:26.701]                       workers >= 1)
[13:20:26.701]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:26.701]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:26.701]                     }
[13:20:26.701]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:26.701]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:26.701]                       envir = envir)
[13:20:26.701]                     if (!future$lazy) 
[13:20:26.701]                       future <- run(future)
[13:20:26.701]                     invisible(future)
[13:20:26.701]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:26.701]                 }
[13:20:26.701]             }
[13:20:26.701]         }
[13:20:26.701]     })
[13:20:26.701]     if (TRUE) {
[13:20:26.701]         base::sink(type = "output", split = FALSE)
[13:20:26.701]         if (TRUE) {
[13:20:26.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:26.701]         }
[13:20:26.701]         else {
[13:20:26.701]             ...future.result["stdout"] <- base::list(NULL)
[13:20:26.701]         }
[13:20:26.701]         base::close(...future.stdout)
[13:20:26.701]         ...future.stdout <- NULL
[13:20:26.701]     }
[13:20:26.701]     ...future.result$conditions <- ...future.conditions
[13:20:26.701]     ...future.result$finished <- base::Sys.time()
[13:20:26.701]     ...future.result
[13:20:26.701] }
[13:20:26.775] MultisessionFuture started
[13:20:26.775] - Launch lazy future ... done
[13:20:26.775] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659cc69a68> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659d0da4c8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659cc69a68> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659d0da4c8> 
 $  : NULL
 $  : NULL
 $  : num 6
[13:20:26.781] receiveMessageFromWorker() for ClusterFuture ...
[13:20:26.782] - Validating connection of MultisessionFuture
[13:20:26.782] - received message: FutureResult
[13:20:26.782] - Received FutureResult
[13:20:26.782] - Erased future from FutureRegistry
[13:20:26.782] result() for ClusterFuture ...
[13:20:26.782] - result already collected: FutureResult
[13:20:26.782] result() for ClusterFuture ... done
[13:20:26.783] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:26.794] resolve() on list ...
[13:20:26.794]  recursive: 0
[13:20:26.794]  length: 6
[13:20:26.794]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:26.795] signalConditionsASAP(numeric, pos=1) ...
[13:20:26.795] - nx: 6
[13:20:26.795] - relay: TRUE
[13:20:26.795] - stdout: TRUE
[13:20:26.795] - signal: TRUE
[13:20:26.795] - resignal: FALSE
[13:20:26.795] - force: TRUE
[13:20:26.795] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.795] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.796]  - until=2
[13:20:26.796]  - relaying element #2
[13:20:26.796] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.796] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.796] signalConditionsASAP(NULL, pos=1) ... done
[13:20:26.796]  length: 5 (resolved future 1)
[13:20:26.796] Future #2
[13:20:26.796] result() for ClusterFuture ...
[13:20:26.797] - result already collected: FutureResult
[13:20:26.797] result() for ClusterFuture ... done
[13:20:26.797] result() for ClusterFuture ...
[13:20:26.797] - result already collected: FutureResult
[13:20:26.797] result() for ClusterFuture ... done
[13:20:26.797] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:26.797] - nx: 6
[13:20:26.797] - relay: TRUE
[13:20:26.797] - stdout: TRUE
[13:20:26.798] - signal: TRUE
[13:20:26.798] - resignal: FALSE
[13:20:26.798] - force: TRUE
[13:20:26.798] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.798] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.798]  - until=2
[13:20:26.798]  - relaying element #2
[13:20:26.798] result() for ClusterFuture ...
[13:20:26.798] - result already collected: FutureResult
[13:20:26.799] result() for ClusterFuture ... done
[13:20:26.799] result() for ClusterFuture ...
[13:20:26.799] - result already collected: FutureResult
[13:20:26.799] result() for ClusterFuture ... done
[13:20:26.799] result() for ClusterFuture ...
[13:20:26.799] - result already collected: FutureResult
[13:20:26.799] result() for ClusterFuture ... done
[13:20:26.799] result() for ClusterFuture ...
[13:20:26.800] - result already collected: FutureResult
[13:20:26.800] result() for ClusterFuture ... done
[13:20:26.800] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.800] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.800] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:26.800]  length: 4 (resolved future 2)
[13:20:26.807] receiveMessageFromWorker() for ClusterFuture ...
[13:20:26.808] - Validating connection of MultisessionFuture
[13:20:26.808] - received message: FutureResult
[13:20:26.808] - Received FutureResult
[13:20:26.808] - Erased future from FutureRegistry
[13:20:26.808] result() for ClusterFuture ...
[13:20:26.808] - result already collected: FutureResult
[13:20:26.808] result() for ClusterFuture ... done
[13:20:26.809] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:26.809] Future #3
[13:20:26.809] result() for ClusterFuture ...
[13:20:26.809] - result already collected: FutureResult
[13:20:26.809] result() for ClusterFuture ... done
[13:20:26.809] result() for ClusterFuture ...
[13:20:26.809] - result already collected: FutureResult
[13:20:26.809] result() for ClusterFuture ... done
[13:20:26.810] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:26.810] - nx: 6
[13:20:26.810] - relay: TRUE
[13:20:26.810] - stdout: TRUE
[13:20:26.810] - signal: TRUE
[13:20:26.810] - resignal: FALSE
[13:20:26.810] - force: TRUE
[13:20:26.810] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.810] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.811]  - until=3
[13:20:26.811]  - relaying element #3
[13:20:26.811] result() for ClusterFuture ...
[13:20:26.811] - result already collected: FutureResult
[13:20:26.811] result() for ClusterFuture ... done
[13:20:26.811] result() for ClusterFuture ...
[13:20:26.811] - result already collected: FutureResult
[13:20:26.811] result() for ClusterFuture ... done
[13:20:26.811] result() for ClusterFuture ...
[13:20:26.812] - result already collected: FutureResult
[13:20:26.812] result() for ClusterFuture ... done
[13:20:26.812] result() for ClusterFuture ...
[13:20:26.812] - result already collected: FutureResult
[13:20:26.812] result() for ClusterFuture ... done
[13:20:26.812] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.812] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.812] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:26.812]  length: 3 (resolved future 3)
[13:20:26.813] signalConditionsASAP(NULL, pos=4) ...
[13:20:26.813] - nx: 6
[13:20:26.813] - relay: TRUE
[13:20:26.813] - stdout: TRUE
[13:20:26.813] - signal: TRUE
[13:20:26.813] - resignal: FALSE
[13:20:26.813] - force: TRUE
[13:20:26.813] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.813] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.814]  - until=5
[13:20:26.814]  - relaying element #5
[13:20:26.814] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:26.814] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.814] signalConditionsASAP(NULL, pos=4) ... done
[13:20:26.814]  length: 2 (resolved future 4)
[13:20:26.814] signalConditionsASAP(NULL, pos=5) ...
[13:20:26.814] - nx: 6
[13:20:26.814] - relay: TRUE
[13:20:26.815] - stdout: TRUE
[13:20:26.815] - signal: TRUE
[13:20:26.815] - resignal: FALSE
[13:20:26.815] - force: TRUE
[13:20:26.815] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:26.815] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.815]  - until=6
[13:20:26.815]  - relaying element #6
[13:20:26.815] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:26.816] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.816] signalConditionsASAP(NULL, pos=5) ... done
[13:20:26.816]  length: 1 (resolved future 5)
[13:20:26.816] signalConditionsASAP(numeric, pos=6) ...
[13:20:26.816] - nx: 6
[13:20:26.816] - relay: TRUE
[13:20:26.816] - stdout: TRUE
[13:20:26.816] - signal: TRUE
[13:20:26.816] - resignal: FALSE
[13:20:26.817] - force: TRUE
[13:20:26.817] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:26.817] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.817]  - until=6
[13:20:26.817] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:26.817] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.817] signalConditionsASAP(numeric, pos=6) ... done
[13:20:26.817]  length: 0 (resolved future 6)
[13:20:26.817] Relaying remaining futures
[13:20:26.818] signalConditionsASAP(NULL, pos=0) ...
[13:20:26.818] - nx: 6
[13:20:26.818] - relay: TRUE
[13:20:26.818] - stdout: TRUE
[13:20:26.818] - signal: TRUE
[13:20:26.821] - resignal: FALSE
[13:20:26.821] - force: TRUE
[13:20:26.821] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:26.821] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:26.821] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:26.821] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.821] signalConditionsASAP(NULL, pos=0) ... done
[13:20:26.821] resolve() on list ... DONE
[13:20:26.821] result() for ClusterFuture ...
[13:20:26.821] - result already collected: FutureResult
[13:20:26.822] result() for ClusterFuture ... done
[13:20:26.822] result() for ClusterFuture ...
[13:20:26.822] - result already collected: FutureResult
[13:20:26.822] result() for ClusterFuture ... done
[13:20:26.822] result() for ClusterFuture ...
[13:20:26.822] - result already collected: FutureResult
[13:20:26.822] result() for ClusterFuture ... done
[13:20:26.822] result() for ClusterFuture ...
[13:20:26.822] - result already collected: FutureResult
[13:20:26.822] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[13:20:26.824] getGlobalsAndPackages() ...
[13:20:26.825] Searching for globals...
[13:20:26.825] 
[13:20:26.825] Searching for globals ... DONE
[13:20:26.825] - globals: [0] <none>
[13:20:26.825] getGlobalsAndPackages() ... DONE
[13:20:26.826] run() for ‘Future’ ...
[13:20:26.826] - state: ‘created’
[13:20:26.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:26.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:26.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:26.841]   - Field: ‘node’
[13:20:26.841]   - Field: ‘label’
[13:20:26.841]   - Field: ‘local’
[13:20:26.841]   - Field: ‘owner’
[13:20:26.841]   - Field: ‘envir’
[13:20:26.841]   - Field: ‘workers’
[13:20:26.841]   - Field: ‘packages’
[13:20:26.841]   - Field: ‘gc’
[13:20:26.841]   - Field: ‘conditions’
[13:20:26.841]   - Field: ‘persistent’
[13:20:26.842]   - Field: ‘expr’
[13:20:26.842]   - Field: ‘uuid’
[13:20:26.842]   - Field: ‘seed’
[13:20:26.842]   - Field: ‘version’
[13:20:26.842]   - Field: ‘result’
[13:20:26.842]   - Field: ‘asynchronous’
[13:20:26.842]   - Field: ‘calls’
[13:20:26.842]   - Field: ‘globals’
[13:20:26.842]   - Field: ‘stdout’
[13:20:26.842]   - Field: ‘earlySignal’
[13:20:26.842]   - Field: ‘lazy’
[13:20:26.842]   - Field: ‘state’
[13:20:26.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:26.843] - Launch lazy future ...
[13:20:26.843] Packages needed by the future expression (n = 0): <none>
[13:20:26.843] Packages needed by future strategies (n = 0): <none>
[13:20:26.843] {
[13:20:26.843]     {
[13:20:26.843]         {
[13:20:26.843]             ...future.startTime <- base::Sys.time()
[13:20:26.843]             {
[13:20:26.843]                 {
[13:20:26.843]                   {
[13:20:26.843]                     {
[13:20:26.843]                       base::local({
[13:20:26.843]                         has_future <- base::requireNamespace("future", 
[13:20:26.843]                           quietly = TRUE)
[13:20:26.843]                         if (has_future) {
[13:20:26.843]                           ns <- base::getNamespace("future")
[13:20:26.843]                           version <- ns[[".package"]][["version"]]
[13:20:26.843]                           if (is.null(version)) 
[13:20:26.843]                             version <- utils::packageVersion("future")
[13:20:26.843]                         }
[13:20:26.843]                         else {
[13:20:26.843]                           version <- NULL
[13:20:26.843]                         }
[13:20:26.843]                         if (!has_future || version < "1.8.0") {
[13:20:26.843]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:26.843]                             "", base::R.version$version.string), 
[13:20:26.843]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:26.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:26.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:26.843]                               "release", "version")], collapse = " "), 
[13:20:26.843]                             hostname = base::Sys.info()[["nodename"]])
[13:20:26.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:26.843]                             info)
[13:20:26.843]                           info <- base::paste(info, collapse = "; ")
[13:20:26.843]                           if (!has_future) {
[13:20:26.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:26.843]                               info)
[13:20:26.843]                           }
[13:20:26.843]                           else {
[13:20:26.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:26.843]                               info, version)
[13:20:26.843]                           }
[13:20:26.843]                           base::stop(msg)
[13:20:26.843]                         }
[13:20:26.843]                       })
[13:20:26.843]                     }
[13:20:26.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:26.843]                     base::options(mc.cores = 1L)
[13:20:26.843]                   }
[13:20:26.843]                   options(future.plan = NULL)
[13:20:26.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:26.843]                 }
[13:20:26.843]                 ...future.workdir <- getwd()
[13:20:26.843]             }
[13:20:26.843]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:26.843]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:26.843]         }
[13:20:26.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:26.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:26.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:26.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:26.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:26.843]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:26.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:26.843]             base::names(...future.oldOptions))
[13:20:26.843]     }
[13:20:26.843]     if (FALSE) {
[13:20:26.843]     }
[13:20:26.843]     else {
[13:20:26.843]         if (TRUE) {
[13:20:26.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:26.843]                 open = "w")
[13:20:26.843]         }
[13:20:26.843]         else {
[13:20:26.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:26.843]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:26.843]         }
[13:20:26.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:26.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:26.843]             base::sink(type = "output", split = FALSE)
[13:20:26.843]             base::close(...future.stdout)
[13:20:26.843]         }, add = TRUE)
[13:20:26.843]     }
[13:20:26.843]     ...future.frame <- base::sys.nframe()
[13:20:26.843]     ...future.conditions <- base::list()
[13:20:26.843]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:26.843]     if (FALSE) {
[13:20:26.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:26.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:26.843]     }
[13:20:26.843]     ...future.result <- base::tryCatch({
[13:20:26.843]         base::withCallingHandlers({
[13:20:26.843]             ...future.value <- base::withVisible(base::local({
[13:20:26.843]                 ...future.makeSendCondition <- local({
[13:20:26.843]                   sendCondition <- NULL
[13:20:26.843]                   function(frame = 1L) {
[13:20:26.843]                     if (is.function(sendCondition)) 
[13:20:26.843]                       return(sendCondition)
[13:20:26.843]                     ns <- getNamespace("parallel")
[13:20:26.843]                     if (exists("sendData", mode = "function", 
[13:20:26.843]                       envir = ns)) {
[13:20:26.843]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:26.843]                         envir = ns)
[13:20:26.843]                       envir <- sys.frame(frame)
[13:20:26.843]                       master <- NULL
[13:20:26.843]                       while (!identical(envir, .GlobalEnv) && 
[13:20:26.843]                         !identical(envir, emptyenv())) {
[13:20:26.843]                         if (exists("master", mode = "list", envir = envir, 
[13:20:26.843]                           inherits = FALSE)) {
[13:20:26.843]                           master <- get("master", mode = "list", 
[13:20:26.843]                             envir = envir, inherits = FALSE)
[13:20:26.843]                           if (inherits(master, c("SOCKnode", 
[13:20:26.843]                             "SOCK0node"))) {
[13:20:26.843]                             sendCondition <<- function(cond) {
[13:20:26.843]                               data <- list(type = "VALUE", value = cond, 
[13:20:26.843]                                 success = TRUE)
[13:20:26.843]                               parallel_sendData(master, data)
[13:20:26.843]                             }
[13:20:26.843]                             return(sendCondition)
[13:20:26.843]                           }
[13:20:26.843]                         }
[13:20:26.843]                         frame <- frame + 1L
[13:20:26.843]                         envir <- sys.frame(frame)
[13:20:26.843]                       }
[13:20:26.843]                     }
[13:20:26.843]                     sendCondition <<- function(cond) NULL
[13:20:26.843]                   }
[13:20:26.843]                 })
[13:20:26.843]                 withCallingHandlers({
[13:20:26.843]                   2
[13:20:26.843]                 }, immediateCondition = function(cond) {
[13:20:26.843]                   sendCondition <- ...future.makeSendCondition()
[13:20:26.843]                   sendCondition(cond)
[13:20:26.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.843]                   {
[13:20:26.843]                     inherits <- base::inherits
[13:20:26.843]                     invokeRestart <- base::invokeRestart
[13:20:26.843]                     is.null <- base::is.null
[13:20:26.843]                     muffled <- FALSE
[13:20:26.843]                     if (inherits(cond, "message")) {
[13:20:26.843]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:26.843]                       if (muffled) 
[13:20:26.843]                         invokeRestart("muffleMessage")
[13:20:26.843]                     }
[13:20:26.843]                     else if (inherits(cond, "warning")) {
[13:20:26.843]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:26.843]                       if (muffled) 
[13:20:26.843]                         invokeRestart("muffleWarning")
[13:20:26.843]                     }
[13:20:26.843]                     else if (inherits(cond, "condition")) {
[13:20:26.843]                       if (!is.null(pattern)) {
[13:20:26.843]                         computeRestarts <- base::computeRestarts
[13:20:26.843]                         grepl <- base::grepl
[13:20:26.843]                         restarts <- computeRestarts(cond)
[13:20:26.843]                         for (restart in restarts) {
[13:20:26.843]                           name <- restart$name
[13:20:26.843]                           if (is.null(name)) 
[13:20:26.843]                             next
[13:20:26.843]                           if (!grepl(pattern, name)) 
[13:20:26.843]                             next
[13:20:26.843]                           invokeRestart(restart)
[13:20:26.843]                           muffled <- TRUE
[13:20:26.843]                           break
[13:20:26.843]                         }
[13:20:26.843]                       }
[13:20:26.843]                     }
[13:20:26.843]                     invisible(muffled)
[13:20:26.843]                   }
[13:20:26.843]                   muffleCondition(cond)
[13:20:26.843]                 })
[13:20:26.843]             }))
[13:20:26.843]             future::FutureResult(value = ...future.value$value, 
[13:20:26.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.843]                   ...future.rng), globalenv = if (FALSE) 
[13:20:26.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:26.843]                     ...future.globalenv.names))
[13:20:26.843]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:26.843]         }, condition = base::local({
[13:20:26.843]             c <- base::c
[13:20:26.843]             inherits <- base::inherits
[13:20:26.843]             invokeRestart <- base::invokeRestart
[13:20:26.843]             length <- base::length
[13:20:26.843]             list <- base::list
[13:20:26.843]             seq.int <- base::seq.int
[13:20:26.843]             signalCondition <- base::signalCondition
[13:20:26.843]             sys.calls <- base::sys.calls
[13:20:26.843]             `[[` <- base::`[[`
[13:20:26.843]             `+` <- base::`+`
[13:20:26.843]             `<<-` <- base::`<<-`
[13:20:26.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:26.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:26.843]                   3L)]
[13:20:26.843]             }
[13:20:26.843]             function(cond) {
[13:20:26.843]                 is_error <- inherits(cond, "error")
[13:20:26.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:26.843]                   NULL)
[13:20:26.843]                 if (is_error) {
[13:20:26.843]                   sessionInformation <- function() {
[13:20:26.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:26.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:26.843]                       search = base::search(), system = base::Sys.info())
[13:20:26.843]                   }
[13:20:26.843]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:26.843]                     cond$call), session = sessionInformation(), 
[13:20:26.843]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:26.843]                   signalCondition(cond)
[13:20:26.843]                 }
[13:20:26.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:26.843]                 "immediateCondition"))) {
[13:20:26.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:26.843]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:26.843]                   if (TRUE && !signal) {
[13:20:26.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.843]                     {
[13:20:26.843]                       inherits <- base::inherits
[13:20:26.843]                       invokeRestart <- base::invokeRestart
[13:20:26.843]                       is.null <- base::is.null
[13:20:26.843]                       muffled <- FALSE
[13:20:26.843]                       if (inherits(cond, "message")) {
[13:20:26.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.843]                         if (muffled) 
[13:20:26.843]                           invokeRestart("muffleMessage")
[13:20:26.843]                       }
[13:20:26.843]                       else if (inherits(cond, "warning")) {
[13:20:26.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.843]                         if (muffled) 
[13:20:26.843]                           invokeRestart("muffleWarning")
[13:20:26.843]                       }
[13:20:26.843]                       else if (inherits(cond, "condition")) {
[13:20:26.843]                         if (!is.null(pattern)) {
[13:20:26.843]                           computeRestarts <- base::computeRestarts
[13:20:26.843]                           grepl <- base::grepl
[13:20:26.843]                           restarts <- computeRestarts(cond)
[13:20:26.843]                           for (restart in restarts) {
[13:20:26.843]                             name <- restart$name
[13:20:26.843]                             if (is.null(name)) 
[13:20:26.843]                               next
[13:20:26.843]                             if (!grepl(pattern, name)) 
[13:20:26.843]                               next
[13:20:26.843]                             invokeRestart(restart)
[13:20:26.843]                             muffled <- TRUE
[13:20:26.843]                             break
[13:20:26.843]                           }
[13:20:26.843]                         }
[13:20:26.843]                       }
[13:20:26.843]                       invisible(muffled)
[13:20:26.843]                     }
[13:20:26.843]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.843]                   }
[13:20:26.843]                 }
[13:20:26.843]                 else {
[13:20:26.843]                   if (TRUE) {
[13:20:26.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.843]                     {
[13:20:26.843]                       inherits <- base::inherits
[13:20:26.843]                       invokeRestart <- base::invokeRestart
[13:20:26.843]                       is.null <- base::is.null
[13:20:26.843]                       muffled <- FALSE
[13:20:26.843]                       if (inherits(cond, "message")) {
[13:20:26.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.843]                         if (muffled) 
[13:20:26.843]                           invokeRestart("muffleMessage")
[13:20:26.843]                       }
[13:20:26.843]                       else if (inherits(cond, "warning")) {
[13:20:26.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.843]                         if (muffled) 
[13:20:26.843]                           invokeRestart("muffleWarning")
[13:20:26.843]                       }
[13:20:26.843]                       else if (inherits(cond, "condition")) {
[13:20:26.843]                         if (!is.null(pattern)) {
[13:20:26.843]                           computeRestarts <- base::computeRestarts
[13:20:26.843]                           grepl <- base::grepl
[13:20:26.843]                           restarts <- computeRestarts(cond)
[13:20:26.843]                           for (restart in restarts) {
[13:20:26.843]                             name <- restart$name
[13:20:26.843]                             if (is.null(name)) 
[13:20:26.843]                               next
[13:20:26.843]                             if (!grepl(pattern, name)) 
[13:20:26.843]                               next
[13:20:26.843]                             invokeRestart(restart)
[13:20:26.843]                             muffled <- TRUE
[13:20:26.843]                             break
[13:20:26.843]                           }
[13:20:26.843]                         }
[13:20:26.843]                       }
[13:20:26.843]                       invisible(muffled)
[13:20:26.843]                     }
[13:20:26.843]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.843]                   }
[13:20:26.843]                 }
[13:20:26.843]             }
[13:20:26.843]         }))
[13:20:26.843]     }, error = function(ex) {
[13:20:26.843]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:26.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.843]                 ...future.rng), started = ...future.startTime, 
[13:20:26.843]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:26.843]             version = "1.8"), class = "FutureResult")
[13:20:26.843]     }, finally = {
[13:20:26.843]         if (!identical(...future.workdir, getwd())) 
[13:20:26.843]             setwd(...future.workdir)
[13:20:26.843]         {
[13:20:26.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:26.843]                 ...future.oldOptions$nwarnings <- NULL
[13:20:26.843]             }
[13:20:26.843]             base::options(...future.oldOptions)
[13:20:26.843]             if (.Platform$OS.type == "windows") {
[13:20:26.843]                 old_names <- names(...future.oldEnvVars)
[13:20:26.843]                 envs <- base::Sys.getenv()
[13:20:26.843]                 names <- names(envs)
[13:20:26.843]                 common <- intersect(names, old_names)
[13:20:26.843]                 added <- setdiff(names, old_names)
[13:20:26.843]                 removed <- setdiff(old_names, names)
[13:20:26.843]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:26.843]                   envs[common]]
[13:20:26.843]                 NAMES <- toupper(changed)
[13:20:26.843]                 args <- list()
[13:20:26.843]                 for (kk in seq_along(NAMES)) {
[13:20:26.843]                   name <- changed[[kk]]
[13:20:26.843]                   NAME <- NAMES[[kk]]
[13:20:26.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.843]                     next
[13:20:26.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.843]                 }
[13:20:26.843]                 NAMES <- toupper(added)
[13:20:26.843]                 for (kk in seq_along(NAMES)) {
[13:20:26.843]                   name <- added[[kk]]
[13:20:26.843]                   NAME <- NAMES[[kk]]
[13:20:26.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.843]                     next
[13:20:26.843]                   args[[name]] <- ""
[13:20:26.843]                 }
[13:20:26.843]                 NAMES <- toupper(removed)
[13:20:26.843]                 for (kk in seq_along(NAMES)) {
[13:20:26.843]                   name <- removed[[kk]]
[13:20:26.843]                   NAME <- NAMES[[kk]]
[13:20:26.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.843]                     next
[13:20:26.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.843]                 }
[13:20:26.843]                 if (length(args) > 0) 
[13:20:26.843]                   base::do.call(base::Sys.setenv, args = args)
[13:20:26.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:26.843]             }
[13:20:26.843]             else {
[13:20:26.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:26.843]             }
[13:20:26.843]             {
[13:20:26.843]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:26.843]                   0L) {
[13:20:26.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:26.843]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:26.843]                   base::options(opts)
[13:20:26.843]                 }
[13:20:26.843]                 {
[13:20:26.843]                   {
[13:20:26.843]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:26.843]                     NULL
[13:20:26.843]                   }
[13:20:26.843]                   options(future.plan = NULL)
[13:20:26.843]                   if (is.na(NA_character_)) 
[13:20:26.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:26.843]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:26.843]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:26.843]                     envir = parent.frame()) 
[13:20:26.843]                   {
[13:20:26.843]                     if (is.function(workers)) 
[13:20:26.843]                       workers <- workers()
[13:20:26.843]                     workers <- structure(as.integer(workers), 
[13:20:26.843]                       class = class(workers))
[13:20:26.843]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:26.843]                       workers >= 1)
[13:20:26.843]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:26.843]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:26.843]                     }
[13:20:26.843]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:26.843]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:26.843]                       envir = envir)
[13:20:26.843]                     if (!future$lazy) 
[13:20:26.843]                       future <- run(future)
[13:20:26.843]                     invisible(future)
[13:20:26.843]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:26.843]                 }
[13:20:26.843]             }
[13:20:26.843]         }
[13:20:26.843]     })
[13:20:26.843]     if (TRUE) {
[13:20:26.843]         base::sink(type = "output", split = FALSE)
[13:20:26.843]         if (TRUE) {
[13:20:26.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:26.843]         }
[13:20:26.843]         else {
[13:20:26.843]             ...future.result["stdout"] <- base::list(NULL)
[13:20:26.843]         }
[13:20:26.843]         base::close(...future.stdout)
[13:20:26.843]         ...future.stdout <- NULL
[13:20:26.843]     }
[13:20:26.843]     ...future.result$conditions <- ...future.conditions
[13:20:26.843]     ...future.result$finished <- base::Sys.time()
[13:20:26.843]     ...future.result
[13:20:26.843] }
[13:20:26.847] MultisessionFuture started
[13:20:26.847] - Launch lazy future ... done
[13:20:26.847] run() for ‘MultisessionFuture’ ... done
[13:20:26.847] getGlobalsAndPackages() ...
[13:20:26.847] Searching for globals...
[13:20:26.847] 
[13:20:26.847] Searching for globals ... DONE
[13:20:26.847] - globals: [0] <none>
[13:20:26.848] getGlobalsAndPackages() ... DONE
[13:20:26.848] run() for ‘Future’ ...
[13:20:26.848] - state: ‘created’
[13:20:26.848] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:26.862] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:26.862] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:26.862]   - Field: ‘node’
[13:20:26.862]   - Field: ‘label’
[13:20:26.863]   - Field: ‘local’
[13:20:26.863]   - Field: ‘owner’
[13:20:26.863]   - Field: ‘envir’
[13:20:26.863]   - Field: ‘workers’
[13:20:26.863]   - Field: ‘packages’
[13:20:26.863]   - Field: ‘gc’
[13:20:26.863]   - Field: ‘conditions’
[13:20:26.863]   - Field: ‘persistent’
[13:20:26.863]   - Field: ‘expr’
[13:20:26.863]   - Field: ‘uuid’
[13:20:26.863]   - Field: ‘seed’
[13:20:26.864]   - Field: ‘version’
[13:20:26.864]   - Field: ‘result’
[13:20:26.864]   - Field: ‘asynchronous’
[13:20:26.864]   - Field: ‘calls’
[13:20:26.864]   - Field: ‘globals’
[13:20:26.864]   - Field: ‘stdout’
[13:20:26.864]   - Field: ‘earlySignal’
[13:20:26.864]   - Field: ‘lazy’
[13:20:26.864]   - Field: ‘state’
[13:20:26.864] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:26.864] - Launch lazy future ...
[13:20:26.865] Packages needed by the future expression (n = 0): <none>
[13:20:26.865] Packages needed by future strategies (n = 0): <none>
[13:20:26.865] {
[13:20:26.865]     {
[13:20:26.865]         {
[13:20:26.865]             ...future.startTime <- base::Sys.time()
[13:20:26.865]             {
[13:20:26.865]                 {
[13:20:26.865]                   {
[13:20:26.865]                     {
[13:20:26.865]                       base::local({
[13:20:26.865]                         has_future <- base::requireNamespace("future", 
[13:20:26.865]                           quietly = TRUE)
[13:20:26.865]                         if (has_future) {
[13:20:26.865]                           ns <- base::getNamespace("future")
[13:20:26.865]                           version <- ns[[".package"]][["version"]]
[13:20:26.865]                           if (is.null(version)) 
[13:20:26.865]                             version <- utils::packageVersion("future")
[13:20:26.865]                         }
[13:20:26.865]                         else {
[13:20:26.865]                           version <- NULL
[13:20:26.865]                         }
[13:20:26.865]                         if (!has_future || version < "1.8.0") {
[13:20:26.865]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:26.865]                             "", base::R.version$version.string), 
[13:20:26.865]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:26.865]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:26.865]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:26.865]                               "release", "version")], collapse = " "), 
[13:20:26.865]                             hostname = base::Sys.info()[["nodename"]])
[13:20:26.865]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:26.865]                             info)
[13:20:26.865]                           info <- base::paste(info, collapse = "; ")
[13:20:26.865]                           if (!has_future) {
[13:20:26.865]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:26.865]                               info)
[13:20:26.865]                           }
[13:20:26.865]                           else {
[13:20:26.865]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:26.865]                               info, version)
[13:20:26.865]                           }
[13:20:26.865]                           base::stop(msg)
[13:20:26.865]                         }
[13:20:26.865]                       })
[13:20:26.865]                     }
[13:20:26.865]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:26.865]                     base::options(mc.cores = 1L)
[13:20:26.865]                   }
[13:20:26.865]                   options(future.plan = NULL)
[13:20:26.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:26.865]                 }
[13:20:26.865]                 ...future.workdir <- getwd()
[13:20:26.865]             }
[13:20:26.865]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:26.865]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:26.865]         }
[13:20:26.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:26.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:26.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:26.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:26.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:26.865]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:26.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:26.865]             base::names(...future.oldOptions))
[13:20:26.865]     }
[13:20:26.865]     if (FALSE) {
[13:20:26.865]     }
[13:20:26.865]     else {
[13:20:26.865]         if (TRUE) {
[13:20:26.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:26.865]                 open = "w")
[13:20:26.865]         }
[13:20:26.865]         else {
[13:20:26.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:26.865]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:26.865]         }
[13:20:26.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:26.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:26.865]             base::sink(type = "output", split = FALSE)
[13:20:26.865]             base::close(...future.stdout)
[13:20:26.865]         }, add = TRUE)
[13:20:26.865]     }
[13:20:26.865]     ...future.frame <- base::sys.nframe()
[13:20:26.865]     ...future.conditions <- base::list()
[13:20:26.865]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:26.865]     if (FALSE) {
[13:20:26.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:26.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:26.865]     }
[13:20:26.865]     ...future.result <- base::tryCatch({
[13:20:26.865]         base::withCallingHandlers({
[13:20:26.865]             ...future.value <- base::withVisible(base::local({
[13:20:26.865]                 ...future.makeSendCondition <- local({
[13:20:26.865]                   sendCondition <- NULL
[13:20:26.865]                   function(frame = 1L) {
[13:20:26.865]                     if (is.function(sendCondition)) 
[13:20:26.865]                       return(sendCondition)
[13:20:26.865]                     ns <- getNamespace("parallel")
[13:20:26.865]                     if (exists("sendData", mode = "function", 
[13:20:26.865]                       envir = ns)) {
[13:20:26.865]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:26.865]                         envir = ns)
[13:20:26.865]                       envir <- sys.frame(frame)
[13:20:26.865]                       master <- NULL
[13:20:26.865]                       while (!identical(envir, .GlobalEnv) && 
[13:20:26.865]                         !identical(envir, emptyenv())) {
[13:20:26.865]                         if (exists("master", mode = "list", envir = envir, 
[13:20:26.865]                           inherits = FALSE)) {
[13:20:26.865]                           master <- get("master", mode = "list", 
[13:20:26.865]                             envir = envir, inherits = FALSE)
[13:20:26.865]                           if (inherits(master, c("SOCKnode", 
[13:20:26.865]                             "SOCK0node"))) {
[13:20:26.865]                             sendCondition <<- function(cond) {
[13:20:26.865]                               data <- list(type = "VALUE", value = cond, 
[13:20:26.865]                                 success = TRUE)
[13:20:26.865]                               parallel_sendData(master, data)
[13:20:26.865]                             }
[13:20:26.865]                             return(sendCondition)
[13:20:26.865]                           }
[13:20:26.865]                         }
[13:20:26.865]                         frame <- frame + 1L
[13:20:26.865]                         envir <- sys.frame(frame)
[13:20:26.865]                       }
[13:20:26.865]                     }
[13:20:26.865]                     sendCondition <<- function(cond) NULL
[13:20:26.865]                   }
[13:20:26.865]                 })
[13:20:26.865]                 withCallingHandlers({
[13:20:26.865]                   NULL
[13:20:26.865]                 }, immediateCondition = function(cond) {
[13:20:26.865]                   sendCondition <- ...future.makeSendCondition()
[13:20:26.865]                   sendCondition(cond)
[13:20:26.865]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.865]                   {
[13:20:26.865]                     inherits <- base::inherits
[13:20:26.865]                     invokeRestart <- base::invokeRestart
[13:20:26.865]                     is.null <- base::is.null
[13:20:26.865]                     muffled <- FALSE
[13:20:26.865]                     if (inherits(cond, "message")) {
[13:20:26.865]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:26.865]                       if (muffled) 
[13:20:26.865]                         invokeRestart("muffleMessage")
[13:20:26.865]                     }
[13:20:26.865]                     else if (inherits(cond, "warning")) {
[13:20:26.865]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:26.865]                       if (muffled) 
[13:20:26.865]                         invokeRestart("muffleWarning")
[13:20:26.865]                     }
[13:20:26.865]                     else if (inherits(cond, "condition")) {
[13:20:26.865]                       if (!is.null(pattern)) {
[13:20:26.865]                         computeRestarts <- base::computeRestarts
[13:20:26.865]                         grepl <- base::grepl
[13:20:26.865]                         restarts <- computeRestarts(cond)
[13:20:26.865]                         for (restart in restarts) {
[13:20:26.865]                           name <- restart$name
[13:20:26.865]                           if (is.null(name)) 
[13:20:26.865]                             next
[13:20:26.865]                           if (!grepl(pattern, name)) 
[13:20:26.865]                             next
[13:20:26.865]                           invokeRestart(restart)
[13:20:26.865]                           muffled <- TRUE
[13:20:26.865]                           break
[13:20:26.865]                         }
[13:20:26.865]                       }
[13:20:26.865]                     }
[13:20:26.865]                     invisible(muffled)
[13:20:26.865]                   }
[13:20:26.865]                   muffleCondition(cond)
[13:20:26.865]                 })
[13:20:26.865]             }))
[13:20:26.865]             future::FutureResult(value = ...future.value$value, 
[13:20:26.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.865]                   ...future.rng), globalenv = if (FALSE) 
[13:20:26.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:26.865]                     ...future.globalenv.names))
[13:20:26.865]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:26.865]         }, condition = base::local({
[13:20:26.865]             c <- base::c
[13:20:26.865]             inherits <- base::inherits
[13:20:26.865]             invokeRestart <- base::invokeRestart
[13:20:26.865]             length <- base::length
[13:20:26.865]             list <- base::list
[13:20:26.865]             seq.int <- base::seq.int
[13:20:26.865]             signalCondition <- base::signalCondition
[13:20:26.865]             sys.calls <- base::sys.calls
[13:20:26.865]             `[[` <- base::`[[`
[13:20:26.865]             `+` <- base::`+`
[13:20:26.865]             `<<-` <- base::`<<-`
[13:20:26.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:26.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:26.865]                   3L)]
[13:20:26.865]             }
[13:20:26.865]             function(cond) {
[13:20:26.865]                 is_error <- inherits(cond, "error")
[13:20:26.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:26.865]                   NULL)
[13:20:26.865]                 if (is_error) {
[13:20:26.865]                   sessionInformation <- function() {
[13:20:26.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:26.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:26.865]                       search = base::search(), system = base::Sys.info())
[13:20:26.865]                   }
[13:20:26.865]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:26.865]                     cond$call), session = sessionInformation(), 
[13:20:26.865]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:26.865]                   signalCondition(cond)
[13:20:26.865]                 }
[13:20:26.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:26.865]                 "immediateCondition"))) {
[13:20:26.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:26.865]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:26.865]                   if (TRUE && !signal) {
[13:20:26.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.865]                     {
[13:20:26.865]                       inherits <- base::inherits
[13:20:26.865]                       invokeRestart <- base::invokeRestart
[13:20:26.865]                       is.null <- base::is.null
[13:20:26.865]                       muffled <- FALSE
[13:20:26.865]                       if (inherits(cond, "message")) {
[13:20:26.865]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.865]                         if (muffled) 
[13:20:26.865]                           invokeRestart("muffleMessage")
[13:20:26.865]                       }
[13:20:26.865]                       else if (inherits(cond, "warning")) {
[13:20:26.865]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.865]                         if (muffled) 
[13:20:26.865]                           invokeRestart("muffleWarning")
[13:20:26.865]                       }
[13:20:26.865]                       else if (inherits(cond, "condition")) {
[13:20:26.865]                         if (!is.null(pattern)) {
[13:20:26.865]                           computeRestarts <- base::computeRestarts
[13:20:26.865]                           grepl <- base::grepl
[13:20:26.865]                           restarts <- computeRestarts(cond)
[13:20:26.865]                           for (restart in restarts) {
[13:20:26.865]                             name <- restart$name
[13:20:26.865]                             if (is.null(name)) 
[13:20:26.865]                               next
[13:20:26.865]                             if (!grepl(pattern, name)) 
[13:20:26.865]                               next
[13:20:26.865]                             invokeRestart(restart)
[13:20:26.865]                             muffled <- TRUE
[13:20:26.865]                             break
[13:20:26.865]                           }
[13:20:26.865]                         }
[13:20:26.865]                       }
[13:20:26.865]                       invisible(muffled)
[13:20:26.865]                     }
[13:20:26.865]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.865]                   }
[13:20:26.865]                 }
[13:20:26.865]                 else {
[13:20:26.865]                   if (TRUE) {
[13:20:26.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.865]                     {
[13:20:26.865]                       inherits <- base::inherits
[13:20:26.865]                       invokeRestart <- base::invokeRestart
[13:20:26.865]                       is.null <- base::is.null
[13:20:26.865]                       muffled <- FALSE
[13:20:26.865]                       if (inherits(cond, "message")) {
[13:20:26.865]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.865]                         if (muffled) 
[13:20:26.865]                           invokeRestart("muffleMessage")
[13:20:26.865]                       }
[13:20:26.865]                       else if (inherits(cond, "warning")) {
[13:20:26.865]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.865]                         if (muffled) 
[13:20:26.865]                           invokeRestart("muffleWarning")
[13:20:26.865]                       }
[13:20:26.865]                       else if (inherits(cond, "condition")) {
[13:20:26.865]                         if (!is.null(pattern)) {
[13:20:26.865]                           computeRestarts <- base::computeRestarts
[13:20:26.865]                           grepl <- base::grepl
[13:20:26.865]                           restarts <- computeRestarts(cond)
[13:20:26.865]                           for (restart in restarts) {
[13:20:26.865]                             name <- restart$name
[13:20:26.865]                             if (is.null(name)) 
[13:20:26.865]                               next
[13:20:26.865]                             if (!grepl(pattern, name)) 
[13:20:26.865]                               next
[13:20:26.865]                             invokeRestart(restart)
[13:20:26.865]                             muffled <- TRUE
[13:20:26.865]                             break
[13:20:26.865]                           }
[13:20:26.865]                         }
[13:20:26.865]                       }
[13:20:26.865]                       invisible(muffled)
[13:20:26.865]                     }
[13:20:26.865]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.865]                   }
[13:20:26.865]                 }
[13:20:26.865]             }
[13:20:26.865]         }))
[13:20:26.865]     }, error = function(ex) {
[13:20:26.865]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:26.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.865]                 ...future.rng), started = ...future.startTime, 
[13:20:26.865]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:26.865]             version = "1.8"), class = "FutureResult")
[13:20:26.865]     }, finally = {
[13:20:26.865]         if (!identical(...future.workdir, getwd())) 
[13:20:26.865]             setwd(...future.workdir)
[13:20:26.865]         {
[13:20:26.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:26.865]                 ...future.oldOptions$nwarnings <- NULL
[13:20:26.865]             }
[13:20:26.865]             base::options(...future.oldOptions)
[13:20:26.865]             if (.Platform$OS.type == "windows") {
[13:20:26.865]                 old_names <- names(...future.oldEnvVars)
[13:20:26.865]                 envs <- base::Sys.getenv()
[13:20:26.865]                 names <- names(envs)
[13:20:26.865]                 common <- intersect(names, old_names)
[13:20:26.865]                 added <- setdiff(names, old_names)
[13:20:26.865]                 removed <- setdiff(old_names, names)
[13:20:26.865]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:26.865]                   envs[common]]
[13:20:26.865]                 NAMES <- toupper(changed)
[13:20:26.865]                 args <- list()
[13:20:26.865]                 for (kk in seq_along(NAMES)) {
[13:20:26.865]                   name <- changed[[kk]]
[13:20:26.865]                   NAME <- NAMES[[kk]]
[13:20:26.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.865]                     next
[13:20:26.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.865]                 }
[13:20:26.865]                 NAMES <- toupper(added)
[13:20:26.865]                 for (kk in seq_along(NAMES)) {
[13:20:26.865]                   name <- added[[kk]]
[13:20:26.865]                   NAME <- NAMES[[kk]]
[13:20:26.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.865]                     next
[13:20:26.865]                   args[[name]] <- ""
[13:20:26.865]                 }
[13:20:26.865]                 NAMES <- toupper(removed)
[13:20:26.865]                 for (kk in seq_along(NAMES)) {
[13:20:26.865]                   name <- removed[[kk]]
[13:20:26.865]                   NAME <- NAMES[[kk]]
[13:20:26.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.865]                     next
[13:20:26.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.865]                 }
[13:20:26.865]                 if (length(args) > 0) 
[13:20:26.865]                   base::do.call(base::Sys.setenv, args = args)
[13:20:26.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:26.865]             }
[13:20:26.865]             else {
[13:20:26.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:26.865]             }
[13:20:26.865]             {
[13:20:26.865]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:26.865]                   0L) {
[13:20:26.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:26.865]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:26.865]                   base::options(opts)
[13:20:26.865]                 }
[13:20:26.865]                 {
[13:20:26.865]                   {
[13:20:26.865]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:26.865]                     NULL
[13:20:26.865]                   }
[13:20:26.865]                   options(future.plan = NULL)
[13:20:26.865]                   if (is.na(NA_character_)) 
[13:20:26.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:26.865]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:26.865]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:26.865]                     envir = parent.frame()) 
[13:20:26.865]                   {
[13:20:26.865]                     if (is.function(workers)) 
[13:20:26.865]                       workers <- workers()
[13:20:26.865]                     workers <- structure(as.integer(workers), 
[13:20:26.865]                       class = class(workers))
[13:20:26.865]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:26.865]                       workers >= 1)
[13:20:26.865]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:26.865]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:26.865]                     }
[13:20:26.865]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:26.865]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:26.865]                       envir = envir)
[13:20:26.865]                     if (!future$lazy) 
[13:20:26.865]                       future <- run(future)
[13:20:26.865]                     invisible(future)
[13:20:26.865]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:26.865]                 }
[13:20:26.865]             }
[13:20:26.865]         }
[13:20:26.865]     })
[13:20:26.865]     if (TRUE) {
[13:20:26.865]         base::sink(type = "output", split = FALSE)
[13:20:26.865]         if (TRUE) {
[13:20:26.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:26.865]         }
[13:20:26.865]         else {
[13:20:26.865]             ...future.result["stdout"] <- base::list(NULL)
[13:20:26.865]         }
[13:20:26.865]         base::close(...future.stdout)
[13:20:26.865]         ...future.stdout <- NULL
[13:20:26.865]     }
[13:20:26.865]     ...future.result$conditions <- ...future.conditions
[13:20:26.865]     ...future.result$finished <- base::Sys.time()
[13:20:26.865]     ...future.result
[13:20:26.865] }
[13:20:26.868] MultisessionFuture started
[13:20:26.869] - Launch lazy future ... done
[13:20:26.869] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659bfb11e8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659b9ba468> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659bfb11e8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659b9ba468> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:26.896] resolve() on list ...
[13:20:26.896]  recursive: 0
[13:20:26.897]  length: 6
[13:20:26.897]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:26.897] signalConditionsASAP(numeric, pos=1) ...
[13:20:26.897] - nx: 6
[13:20:26.897] - relay: TRUE
[13:20:26.897] - stdout: TRUE
[13:20:26.897] - signal: TRUE
[13:20:26.897] - resignal: FALSE
[13:20:26.897] - force: TRUE
[13:20:26.897] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.898] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.898]  - until=2
[13:20:26.898]  - relaying element #2
[13:20:26.898] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.898] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.898] signalConditionsASAP(NULL, pos=1) ... done
[13:20:26.898]  length: 5 (resolved future 1)
[13:20:26.899] receiveMessageFromWorker() for ClusterFuture ...
[13:20:26.899] - Validating connection of MultisessionFuture
[13:20:26.899] - received message: FutureResult
[13:20:26.899] - Received FutureResult
[13:20:26.899] - Erased future from FutureRegistry
[13:20:26.899] result() for ClusterFuture ...
[13:20:26.899] - result already collected: FutureResult
[13:20:26.899] result() for ClusterFuture ... done
[13:20:26.899] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:26.900] Future #2
[13:20:26.900] result() for ClusterFuture ...
[13:20:26.900] - result already collected: FutureResult
[13:20:26.900] result() for ClusterFuture ... done
[13:20:26.900] result() for ClusterFuture ...
[13:20:26.900] - result already collected: FutureResult
[13:20:26.900] result() for ClusterFuture ... done
[13:20:26.900] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:26.900] - nx: 6
[13:20:26.900] - relay: TRUE
[13:20:26.900] - stdout: TRUE
[13:20:26.901] - signal: TRUE
[13:20:26.901] - resignal: FALSE
[13:20:26.901] - force: TRUE
[13:20:26.901] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.901] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:26.901]  - until=2
[13:20:26.901]  - relaying element #2
[13:20:26.901] result() for ClusterFuture ...
[13:20:26.901] - result already collected: FutureResult
[13:20:26.901] result() for ClusterFuture ... done
[13:20:26.901] result() for ClusterFuture ...
[13:20:26.902] - result already collected: FutureResult
[13:20:26.902] result() for ClusterFuture ... done
[13:20:26.902] result() for ClusterFuture ...
[13:20:26.902] - result already collected: FutureResult
[13:20:26.902] result() for ClusterFuture ... done
[13:20:26.902] result() for ClusterFuture ...
[13:20:26.902] - result already collected: FutureResult
[13:20:26.902] result() for ClusterFuture ... done
[13:20:26.902] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.902] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.902] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:26.903]  length: 4 (resolved future 2)
[13:20:26.913] signalConditionsASAP(NULL, pos=4) ...
[13:20:26.913] - nx: 6
[13:20:26.913] - relay: TRUE
[13:20:26.913] - stdout: TRUE
[13:20:26.914] - signal: TRUE
[13:20:26.914] - resignal: FALSE
[13:20:26.914] - force: TRUE
[13:20:26.914] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.914] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.914]  - until=5
[13:20:26.914]  - relaying element #3
[13:20:26.914]  - relaying element #5
[13:20:26.914] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:20:26.914] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.914] signalConditionsASAP(NULL, pos=4) ... done
[13:20:26.915]  length: 3 (resolved future 4)
[13:20:26.915] signalConditionsASAP(NULL, pos=5) ...
[13:20:26.915] - nx: 6
[13:20:26.915] - relay: TRUE
[13:20:26.915] - stdout: TRUE
[13:20:26.915] - signal: TRUE
[13:20:26.915] - resignal: FALSE
[13:20:26.915] - force: TRUE
[13:20:26.915] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:20:26.915] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.915]  - until=6
[13:20:26.915]  - relaying element #3
[13:20:26.916]  - relaying element #6
[13:20:26.916] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:20:26.916] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.916] signalConditionsASAP(NULL, pos=5) ... done
[13:20:26.916]  length: 2 (resolved future 5)
[13:20:26.916] signalConditionsASAP(numeric, pos=6) ...
[13:20:26.916] - nx: 6
[13:20:26.916] - relay: TRUE
[13:20:26.916] - stdout: TRUE
[13:20:26.916] - signal: TRUE
[13:20:26.916] - resignal: FALSE
[13:20:26.916] - force: TRUE
[13:20:26.917] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:20:26.917] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.917]  - until=6
[13:20:26.917]  - relaying element #3
[13:20:26.917] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:20:26.917] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.917] signalConditionsASAP(NULL, pos=6) ... done
[13:20:26.917]  length: 1 (resolved future 6)
[13:20:26.928] receiveMessageFromWorker() for ClusterFuture ...
[13:20:26.928] - Validating connection of MultisessionFuture
[13:20:26.928] - received message: FutureResult
[13:20:26.929] - Received FutureResult
[13:20:26.929] - Erased future from FutureRegistry
[13:20:26.929] result() for ClusterFuture ...
[13:20:26.929] - result already collected: FutureResult
[13:20:26.929] result() for ClusterFuture ... done
[13:20:26.929] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:26.929] Future #3
[13:20:26.929] result() for ClusterFuture ...
[13:20:26.929] - result already collected: FutureResult
[13:20:26.930] result() for ClusterFuture ... done
[13:20:26.930] result() for ClusterFuture ...
[13:20:26.930] - result already collected: FutureResult
[13:20:26.930] result() for ClusterFuture ... done
[13:20:26.930] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:26.930] - nx: 6
[13:20:26.930] - relay: TRUE
[13:20:26.930] - stdout: TRUE
[13:20:26.930] - signal: TRUE
[13:20:26.930] - resignal: FALSE
[13:20:26.930] - force: TRUE
[13:20:26.931] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:20:26.931] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:26.931]  - until=6
[13:20:26.931]  - relaying element #3
[13:20:26.931] result() for ClusterFuture ...
[13:20:26.931] - result already collected: FutureResult
[13:20:26.931] result() for ClusterFuture ... done
[13:20:26.931] result() for ClusterFuture ...
[13:20:26.931] - result already collected: FutureResult
[13:20:26.931] result() for ClusterFuture ... done
[13:20:26.931] result() for ClusterFuture ...
[13:20:26.932] - result already collected: FutureResult
[13:20:26.932] result() for ClusterFuture ... done
[13:20:26.932] result() for ClusterFuture ...
[13:20:26.932] - result already collected: FutureResult
[13:20:26.932] result() for ClusterFuture ... done
[13:20:26.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:26.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.932] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:26.932]  length: 0 (resolved future 3)
[13:20:26.932] Relaying remaining futures
[13:20:26.932] signalConditionsASAP(NULL, pos=0) ...
[13:20:26.933] - nx: 6
[13:20:26.933] - relay: TRUE
[13:20:26.933] - stdout: TRUE
[13:20:26.933] - signal: TRUE
[13:20:26.933] - resignal: FALSE
[13:20:26.933] - force: TRUE
[13:20:26.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:26.933] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:26.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:26.933] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:26.934] signalConditionsASAP(NULL, pos=0) ... done
[13:20:26.934] resolve() on list ... DONE
[13:20:26.934] result() for ClusterFuture ...
[13:20:26.934] - result already collected: FutureResult
[13:20:26.934] result() for ClusterFuture ... done
[13:20:26.934] result() for ClusterFuture ...
[13:20:26.934] - result already collected: FutureResult
[13:20:26.934] result() for ClusterFuture ... done
[13:20:26.934] result() for ClusterFuture ...
[13:20:26.934] - result already collected: FutureResult
[13:20:26.934] result() for ClusterFuture ... done
[13:20:26.935] result() for ClusterFuture ...
[13:20:26.935] - result already collected: FutureResult
[13:20:26.935] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:20:26.938] getGlobalsAndPackages() ...
[13:20:26.938] Searching for globals...
[13:20:26.939] 
[13:20:26.939] Searching for globals ... DONE
[13:20:26.939] - globals: [0] <none>
[13:20:26.939] getGlobalsAndPackages() ... DONE
[13:20:26.939] run() for ‘Future’ ...
[13:20:26.939] - state: ‘created’
[13:20:26.939] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:26.954] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:26.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:26.954]   - Field: ‘node’
[13:20:26.954]   - Field: ‘label’
[13:20:26.955]   - Field: ‘local’
[13:20:26.955]   - Field: ‘owner’
[13:20:26.955]   - Field: ‘envir’
[13:20:26.955]   - Field: ‘workers’
[13:20:26.955]   - Field: ‘packages’
[13:20:26.955]   - Field: ‘gc’
[13:20:26.955]   - Field: ‘conditions’
[13:20:26.955]   - Field: ‘persistent’
[13:20:26.955]   - Field: ‘expr’
[13:20:26.955]   - Field: ‘uuid’
[13:20:26.955]   - Field: ‘seed’
[13:20:26.956]   - Field: ‘version’
[13:20:26.956]   - Field: ‘result’
[13:20:26.956]   - Field: ‘asynchronous’
[13:20:26.956]   - Field: ‘calls’
[13:20:26.956]   - Field: ‘globals’
[13:20:26.956]   - Field: ‘stdout’
[13:20:26.956]   - Field: ‘earlySignal’
[13:20:26.956]   - Field: ‘lazy’
[13:20:26.956]   - Field: ‘state’
[13:20:26.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:26.957] - Launch lazy future ...
[13:20:26.957] Packages needed by the future expression (n = 0): <none>
[13:20:26.957] Packages needed by future strategies (n = 0): <none>
[13:20:26.957] {
[13:20:26.957]     {
[13:20:26.957]         {
[13:20:26.957]             ...future.startTime <- base::Sys.time()
[13:20:26.957]             {
[13:20:26.957]                 {
[13:20:26.957]                   {
[13:20:26.957]                     {
[13:20:26.957]                       base::local({
[13:20:26.957]                         has_future <- base::requireNamespace("future", 
[13:20:26.957]                           quietly = TRUE)
[13:20:26.957]                         if (has_future) {
[13:20:26.957]                           ns <- base::getNamespace("future")
[13:20:26.957]                           version <- ns[[".package"]][["version"]]
[13:20:26.957]                           if (is.null(version)) 
[13:20:26.957]                             version <- utils::packageVersion("future")
[13:20:26.957]                         }
[13:20:26.957]                         else {
[13:20:26.957]                           version <- NULL
[13:20:26.957]                         }
[13:20:26.957]                         if (!has_future || version < "1.8.0") {
[13:20:26.957]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:26.957]                             "", base::R.version$version.string), 
[13:20:26.957]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:26.957]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:26.957]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:26.957]                               "release", "version")], collapse = " "), 
[13:20:26.957]                             hostname = base::Sys.info()[["nodename"]])
[13:20:26.957]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:26.957]                             info)
[13:20:26.957]                           info <- base::paste(info, collapse = "; ")
[13:20:26.957]                           if (!has_future) {
[13:20:26.957]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:26.957]                               info)
[13:20:26.957]                           }
[13:20:26.957]                           else {
[13:20:26.957]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:26.957]                               info, version)
[13:20:26.957]                           }
[13:20:26.957]                           base::stop(msg)
[13:20:26.957]                         }
[13:20:26.957]                       })
[13:20:26.957]                     }
[13:20:26.957]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:26.957]                     base::options(mc.cores = 1L)
[13:20:26.957]                   }
[13:20:26.957]                   options(future.plan = NULL)
[13:20:26.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:26.957]                 }
[13:20:26.957]                 ...future.workdir <- getwd()
[13:20:26.957]             }
[13:20:26.957]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:26.957]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:26.957]         }
[13:20:26.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:26.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:26.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:26.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:26.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:26.957]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:26.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:26.957]             base::names(...future.oldOptions))
[13:20:26.957]     }
[13:20:26.957]     if (FALSE) {
[13:20:26.957]     }
[13:20:26.957]     else {
[13:20:26.957]         if (TRUE) {
[13:20:26.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:26.957]                 open = "w")
[13:20:26.957]         }
[13:20:26.957]         else {
[13:20:26.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:26.957]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:26.957]         }
[13:20:26.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:26.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:26.957]             base::sink(type = "output", split = FALSE)
[13:20:26.957]             base::close(...future.stdout)
[13:20:26.957]         }, add = TRUE)
[13:20:26.957]     }
[13:20:26.957]     ...future.frame <- base::sys.nframe()
[13:20:26.957]     ...future.conditions <- base::list()
[13:20:26.957]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:26.957]     if (FALSE) {
[13:20:26.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:26.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:26.957]     }
[13:20:26.957]     ...future.result <- base::tryCatch({
[13:20:26.957]         base::withCallingHandlers({
[13:20:26.957]             ...future.value <- base::withVisible(base::local({
[13:20:26.957]                 ...future.makeSendCondition <- local({
[13:20:26.957]                   sendCondition <- NULL
[13:20:26.957]                   function(frame = 1L) {
[13:20:26.957]                     if (is.function(sendCondition)) 
[13:20:26.957]                       return(sendCondition)
[13:20:26.957]                     ns <- getNamespace("parallel")
[13:20:26.957]                     if (exists("sendData", mode = "function", 
[13:20:26.957]                       envir = ns)) {
[13:20:26.957]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:26.957]                         envir = ns)
[13:20:26.957]                       envir <- sys.frame(frame)
[13:20:26.957]                       master <- NULL
[13:20:26.957]                       while (!identical(envir, .GlobalEnv) && 
[13:20:26.957]                         !identical(envir, emptyenv())) {
[13:20:26.957]                         if (exists("master", mode = "list", envir = envir, 
[13:20:26.957]                           inherits = FALSE)) {
[13:20:26.957]                           master <- get("master", mode = "list", 
[13:20:26.957]                             envir = envir, inherits = FALSE)
[13:20:26.957]                           if (inherits(master, c("SOCKnode", 
[13:20:26.957]                             "SOCK0node"))) {
[13:20:26.957]                             sendCondition <<- function(cond) {
[13:20:26.957]                               data <- list(type = "VALUE", value = cond, 
[13:20:26.957]                                 success = TRUE)
[13:20:26.957]                               parallel_sendData(master, data)
[13:20:26.957]                             }
[13:20:26.957]                             return(sendCondition)
[13:20:26.957]                           }
[13:20:26.957]                         }
[13:20:26.957]                         frame <- frame + 1L
[13:20:26.957]                         envir <- sys.frame(frame)
[13:20:26.957]                       }
[13:20:26.957]                     }
[13:20:26.957]                     sendCondition <<- function(cond) NULL
[13:20:26.957]                   }
[13:20:26.957]                 })
[13:20:26.957]                 withCallingHandlers({
[13:20:26.957]                   2
[13:20:26.957]                 }, immediateCondition = function(cond) {
[13:20:26.957]                   sendCondition <- ...future.makeSendCondition()
[13:20:26.957]                   sendCondition(cond)
[13:20:26.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.957]                   {
[13:20:26.957]                     inherits <- base::inherits
[13:20:26.957]                     invokeRestart <- base::invokeRestart
[13:20:26.957]                     is.null <- base::is.null
[13:20:26.957]                     muffled <- FALSE
[13:20:26.957]                     if (inherits(cond, "message")) {
[13:20:26.957]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:26.957]                       if (muffled) 
[13:20:26.957]                         invokeRestart("muffleMessage")
[13:20:26.957]                     }
[13:20:26.957]                     else if (inherits(cond, "warning")) {
[13:20:26.957]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:26.957]                       if (muffled) 
[13:20:26.957]                         invokeRestart("muffleWarning")
[13:20:26.957]                     }
[13:20:26.957]                     else if (inherits(cond, "condition")) {
[13:20:26.957]                       if (!is.null(pattern)) {
[13:20:26.957]                         computeRestarts <- base::computeRestarts
[13:20:26.957]                         grepl <- base::grepl
[13:20:26.957]                         restarts <- computeRestarts(cond)
[13:20:26.957]                         for (restart in restarts) {
[13:20:26.957]                           name <- restart$name
[13:20:26.957]                           if (is.null(name)) 
[13:20:26.957]                             next
[13:20:26.957]                           if (!grepl(pattern, name)) 
[13:20:26.957]                             next
[13:20:26.957]                           invokeRestart(restart)
[13:20:26.957]                           muffled <- TRUE
[13:20:26.957]                           break
[13:20:26.957]                         }
[13:20:26.957]                       }
[13:20:26.957]                     }
[13:20:26.957]                     invisible(muffled)
[13:20:26.957]                   }
[13:20:26.957]                   muffleCondition(cond)
[13:20:26.957]                 })
[13:20:26.957]             }))
[13:20:26.957]             future::FutureResult(value = ...future.value$value, 
[13:20:26.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.957]                   ...future.rng), globalenv = if (FALSE) 
[13:20:26.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:26.957]                     ...future.globalenv.names))
[13:20:26.957]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:26.957]         }, condition = base::local({
[13:20:26.957]             c <- base::c
[13:20:26.957]             inherits <- base::inherits
[13:20:26.957]             invokeRestart <- base::invokeRestart
[13:20:26.957]             length <- base::length
[13:20:26.957]             list <- base::list
[13:20:26.957]             seq.int <- base::seq.int
[13:20:26.957]             signalCondition <- base::signalCondition
[13:20:26.957]             sys.calls <- base::sys.calls
[13:20:26.957]             `[[` <- base::`[[`
[13:20:26.957]             `+` <- base::`+`
[13:20:26.957]             `<<-` <- base::`<<-`
[13:20:26.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:26.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:26.957]                   3L)]
[13:20:26.957]             }
[13:20:26.957]             function(cond) {
[13:20:26.957]                 is_error <- inherits(cond, "error")
[13:20:26.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:26.957]                   NULL)
[13:20:26.957]                 if (is_error) {
[13:20:26.957]                   sessionInformation <- function() {
[13:20:26.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:26.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:26.957]                       search = base::search(), system = base::Sys.info())
[13:20:26.957]                   }
[13:20:26.957]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:26.957]                     cond$call), session = sessionInformation(), 
[13:20:26.957]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:26.957]                   signalCondition(cond)
[13:20:26.957]                 }
[13:20:26.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:26.957]                 "immediateCondition"))) {
[13:20:26.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:26.957]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:26.957]                   if (TRUE && !signal) {
[13:20:26.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.957]                     {
[13:20:26.957]                       inherits <- base::inherits
[13:20:26.957]                       invokeRestart <- base::invokeRestart
[13:20:26.957]                       is.null <- base::is.null
[13:20:26.957]                       muffled <- FALSE
[13:20:26.957]                       if (inherits(cond, "message")) {
[13:20:26.957]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.957]                         if (muffled) 
[13:20:26.957]                           invokeRestart("muffleMessage")
[13:20:26.957]                       }
[13:20:26.957]                       else if (inherits(cond, "warning")) {
[13:20:26.957]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.957]                         if (muffled) 
[13:20:26.957]                           invokeRestart("muffleWarning")
[13:20:26.957]                       }
[13:20:26.957]                       else if (inherits(cond, "condition")) {
[13:20:26.957]                         if (!is.null(pattern)) {
[13:20:26.957]                           computeRestarts <- base::computeRestarts
[13:20:26.957]                           grepl <- base::grepl
[13:20:26.957]                           restarts <- computeRestarts(cond)
[13:20:26.957]                           for (restart in restarts) {
[13:20:26.957]                             name <- restart$name
[13:20:26.957]                             if (is.null(name)) 
[13:20:26.957]                               next
[13:20:26.957]                             if (!grepl(pattern, name)) 
[13:20:26.957]                               next
[13:20:26.957]                             invokeRestart(restart)
[13:20:26.957]                             muffled <- TRUE
[13:20:26.957]                             break
[13:20:26.957]                           }
[13:20:26.957]                         }
[13:20:26.957]                       }
[13:20:26.957]                       invisible(muffled)
[13:20:26.957]                     }
[13:20:26.957]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.957]                   }
[13:20:26.957]                 }
[13:20:26.957]                 else {
[13:20:26.957]                   if (TRUE) {
[13:20:26.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.957]                     {
[13:20:26.957]                       inherits <- base::inherits
[13:20:26.957]                       invokeRestart <- base::invokeRestart
[13:20:26.957]                       is.null <- base::is.null
[13:20:26.957]                       muffled <- FALSE
[13:20:26.957]                       if (inherits(cond, "message")) {
[13:20:26.957]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.957]                         if (muffled) 
[13:20:26.957]                           invokeRestart("muffleMessage")
[13:20:26.957]                       }
[13:20:26.957]                       else if (inherits(cond, "warning")) {
[13:20:26.957]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.957]                         if (muffled) 
[13:20:26.957]                           invokeRestart("muffleWarning")
[13:20:26.957]                       }
[13:20:26.957]                       else if (inherits(cond, "condition")) {
[13:20:26.957]                         if (!is.null(pattern)) {
[13:20:26.957]                           computeRestarts <- base::computeRestarts
[13:20:26.957]                           grepl <- base::grepl
[13:20:26.957]                           restarts <- computeRestarts(cond)
[13:20:26.957]                           for (restart in restarts) {
[13:20:26.957]                             name <- restart$name
[13:20:26.957]                             if (is.null(name)) 
[13:20:26.957]                               next
[13:20:26.957]                             if (!grepl(pattern, name)) 
[13:20:26.957]                               next
[13:20:26.957]                             invokeRestart(restart)
[13:20:26.957]                             muffled <- TRUE
[13:20:26.957]                             break
[13:20:26.957]                           }
[13:20:26.957]                         }
[13:20:26.957]                       }
[13:20:26.957]                       invisible(muffled)
[13:20:26.957]                     }
[13:20:26.957]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.957]                   }
[13:20:26.957]                 }
[13:20:26.957]             }
[13:20:26.957]         }))
[13:20:26.957]     }, error = function(ex) {
[13:20:26.957]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:26.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.957]                 ...future.rng), started = ...future.startTime, 
[13:20:26.957]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:26.957]             version = "1.8"), class = "FutureResult")
[13:20:26.957]     }, finally = {
[13:20:26.957]         if (!identical(...future.workdir, getwd())) 
[13:20:26.957]             setwd(...future.workdir)
[13:20:26.957]         {
[13:20:26.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:26.957]                 ...future.oldOptions$nwarnings <- NULL
[13:20:26.957]             }
[13:20:26.957]             base::options(...future.oldOptions)
[13:20:26.957]             if (.Platform$OS.type == "windows") {
[13:20:26.957]                 old_names <- names(...future.oldEnvVars)
[13:20:26.957]                 envs <- base::Sys.getenv()
[13:20:26.957]                 names <- names(envs)
[13:20:26.957]                 common <- intersect(names, old_names)
[13:20:26.957]                 added <- setdiff(names, old_names)
[13:20:26.957]                 removed <- setdiff(old_names, names)
[13:20:26.957]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:26.957]                   envs[common]]
[13:20:26.957]                 NAMES <- toupper(changed)
[13:20:26.957]                 args <- list()
[13:20:26.957]                 for (kk in seq_along(NAMES)) {
[13:20:26.957]                   name <- changed[[kk]]
[13:20:26.957]                   NAME <- NAMES[[kk]]
[13:20:26.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.957]                     next
[13:20:26.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.957]                 }
[13:20:26.957]                 NAMES <- toupper(added)
[13:20:26.957]                 for (kk in seq_along(NAMES)) {
[13:20:26.957]                   name <- added[[kk]]
[13:20:26.957]                   NAME <- NAMES[[kk]]
[13:20:26.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.957]                     next
[13:20:26.957]                   args[[name]] <- ""
[13:20:26.957]                 }
[13:20:26.957]                 NAMES <- toupper(removed)
[13:20:26.957]                 for (kk in seq_along(NAMES)) {
[13:20:26.957]                   name <- removed[[kk]]
[13:20:26.957]                   NAME <- NAMES[[kk]]
[13:20:26.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.957]                     next
[13:20:26.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.957]                 }
[13:20:26.957]                 if (length(args) > 0) 
[13:20:26.957]                   base::do.call(base::Sys.setenv, args = args)
[13:20:26.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:26.957]             }
[13:20:26.957]             else {
[13:20:26.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:26.957]             }
[13:20:26.957]             {
[13:20:26.957]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:26.957]                   0L) {
[13:20:26.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:26.957]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:26.957]                   base::options(opts)
[13:20:26.957]                 }
[13:20:26.957]                 {
[13:20:26.957]                   {
[13:20:26.957]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:26.957]                     NULL
[13:20:26.957]                   }
[13:20:26.957]                   options(future.plan = NULL)
[13:20:26.957]                   if (is.na(NA_character_)) 
[13:20:26.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:26.957]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:26.957]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:26.957]                     envir = parent.frame()) 
[13:20:26.957]                   {
[13:20:26.957]                     if (is.function(workers)) 
[13:20:26.957]                       workers <- workers()
[13:20:26.957]                     workers <- structure(as.integer(workers), 
[13:20:26.957]                       class = class(workers))
[13:20:26.957]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:26.957]                       workers >= 1)
[13:20:26.957]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:26.957]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:26.957]                     }
[13:20:26.957]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:26.957]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:26.957]                       envir = envir)
[13:20:26.957]                     if (!future$lazy) 
[13:20:26.957]                       future <- run(future)
[13:20:26.957]                     invisible(future)
[13:20:26.957]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:26.957]                 }
[13:20:26.957]             }
[13:20:26.957]         }
[13:20:26.957]     })
[13:20:26.957]     if (TRUE) {
[13:20:26.957]         base::sink(type = "output", split = FALSE)
[13:20:26.957]         if (TRUE) {
[13:20:26.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:26.957]         }
[13:20:26.957]         else {
[13:20:26.957]             ...future.result["stdout"] <- base::list(NULL)
[13:20:26.957]         }
[13:20:26.957]         base::close(...future.stdout)
[13:20:26.957]         ...future.stdout <- NULL
[13:20:26.957]     }
[13:20:26.957]     ...future.result$conditions <- ...future.conditions
[13:20:26.957]     ...future.result$finished <- base::Sys.time()
[13:20:26.957]     ...future.result
[13:20:26.957] }
[13:20:26.961] MultisessionFuture started
[13:20:26.961] - Launch lazy future ... done
[13:20:26.961] run() for ‘MultisessionFuture’ ... done
[13:20:26.961] getGlobalsAndPackages() ...
[13:20:26.961] Searching for globals...
[13:20:26.961] 
[13:20:26.961] Searching for globals ... DONE
[13:20:26.962] - globals: [0] <none>
[13:20:26.962] getGlobalsAndPackages() ... DONE
[13:20:26.962] run() for ‘Future’ ...
[13:20:26.962] - state: ‘created’
[13:20:26.962] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:26.977] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:26.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:26.977]   - Field: ‘node’
[13:20:26.977]   - Field: ‘label’
[13:20:26.978]   - Field: ‘local’
[13:20:26.978]   - Field: ‘owner’
[13:20:26.978]   - Field: ‘envir’
[13:20:26.978]   - Field: ‘workers’
[13:20:26.978]   - Field: ‘packages’
[13:20:26.978]   - Field: ‘gc’
[13:20:26.978]   - Field: ‘conditions’
[13:20:26.978]   - Field: ‘persistent’
[13:20:26.978]   - Field: ‘expr’
[13:20:26.978]   - Field: ‘uuid’
[13:20:26.979]   - Field: ‘seed’
[13:20:26.979]   - Field: ‘version’
[13:20:26.979]   - Field: ‘result’
[13:20:26.979]   - Field: ‘asynchronous’
[13:20:26.979]   - Field: ‘calls’
[13:20:26.979]   - Field: ‘globals’
[13:20:26.979]   - Field: ‘stdout’
[13:20:26.979]   - Field: ‘earlySignal’
[13:20:26.979]   - Field: ‘lazy’
[13:20:26.979]   - Field: ‘state’
[13:20:26.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:26.980] - Launch lazy future ...
[13:20:26.980] Packages needed by the future expression (n = 0): <none>
[13:20:26.980] Packages needed by future strategies (n = 0): <none>
[13:20:26.980] {
[13:20:26.980]     {
[13:20:26.980]         {
[13:20:26.980]             ...future.startTime <- base::Sys.time()
[13:20:26.980]             {
[13:20:26.980]                 {
[13:20:26.980]                   {
[13:20:26.980]                     {
[13:20:26.980]                       base::local({
[13:20:26.980]                         has_future <- base::requireNamespace("future", 
[13:20:26.980]                           quietly = TRUE)
[13:20:26.980]                         if (has_future) {
[13:20:26.980]                           ns <- base::getNamespace("future")
[13:20:26.980]                           version <- ns[[".package"]][["version"]]
[13:20:26.980]                           if (is.null(version)) 
[13:20:26.980]                             version <- utils::packageVersion("future")
[13:20:26.980]                         }
[13:20:26.980]                         else {
[13:20:26.980]                           version <- NULL
[13:20:26.980]                         }
[13:20:26.980]                         if (!has_future || version < "1.8.0") {
[13:20:26.980]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:26.980]                             "", base::R.version$version.string), 
[13:20:26.980]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:26.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:26.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:26.980]                               "release", "version")], collapse = " "), 
[13:20:26.980]                             hostname = base::Sys.info()[["nodename"]])
[13:20:26.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:26.980]                             info)
[13:20:26.980]                           info <- base::paste(info, collapse = "; ")
[13:20:26.980]                           if (!has_future) {
[13:20:26.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:26.980]                               info)
[13:20:26.980]                           }
[13:20:26.980]                           else {
[13:20:26.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:26.980]                               info, version)
[13:20:26.980]                           }
[13:20:26.980]                           base::stop(msg)
[13:20:26.980]                         }
[13:20:26.980]                       })
[13:20:26.980]                     }
[13:20:26.980]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:26.980]                     base::options(mc.cores = 1L)
[13:20:26.980]                   }
[13:20:26.980]                   options(future.plan = NULL)
[13:20:26.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:26.980]                 }
[13:20:26.980]                 ...future.workdir <- getwd()
[13:20:26.980]             }
[13:20:26.980]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:26.980]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:26.980]         }
[13:20:26.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:26.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:26.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:26.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:26.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:26.980]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:26.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:26.980]             base::names(...future.oldOptions))
[13:20:26.980]     }
[13:20:26.980]     if (FALSE) {
[13:20:26.980]     }
[13:20:26.980]     else {
[13:20:26.980]         if (TRUE) {
[13:20:26.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:26.980]                 open = "w")
[13:20:26.980]         }
[13:20:26.980]         else {
[13:20:26.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:26.980]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:26.980]         }
[13:20:26.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:26.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:26.980]             base::sink(type = "output", split = FALSE)
[13:20:26.980]             base::close(...future.stdout)
[13:20:26.980]         }, add = TRUE)
[13:20:26.980]     }
[13:20:26.980]     ...future.frame <- base::sys.nframe()
[13:20:26.980]     ...future.conditions <- base::list()
[13:20:26.980]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:26.980]     if (FALSE) {
[13:20:26.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:26.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:26.980]     }
[13:20:26.980]     ...future.result <- base::tryCatch({
[13:20:26.980]         base::withCallingHandlers({
[13:20:26.980]             ...future.value <- base::withVisible(base::local({
[13:20:26.980]                 ...future.makeSendCondition <- local({
[13:20:26.980]                   sendCondition <- NULL
[13:20:26.980]                   function(frame = 1L) {
[13:20:26.980]                     if (is.function(sendCondition)) 
[13:20:26.980]                       return(sendCondition)
[13:20:26.980]                     ns <- getNamespace("parallel")
[13:20:26.980]                     if (exists("sendData", mode = "function", 
[13:20:26.980]                       envir = ns)) {
[13:20:26.980]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:26.980]                         envir = ns)
[13:20:26.980]                       envir <- sys.frame(frame)
[13:20:26.980]                       master <- NULL
[13:20:26.980]                       while (!identical(envir, .GlobalEnv) && 
[13:20:26.980]                         !identical(envir, emptyenv())) {
[13:20:26.980]                         if (exists("master", mode = "list", envir = envir, 
[13:20:26.980]                           inherits = FALSE)) {
[13:20:26.980]                           master <- get("master", mode = "list", 
[13:20:26.980]                             envir = envir, inherits = FALSE)
[13:20:26.980]                           if (inherits(master, c("SOCKnode", 
[13:20:26.980]                             "SOCK0node"))) {
[13:20:26.980]                             sendCondition <<- function(cond) {
[13:20:26.980]                               data <- list(type = "VALUE", value = cond, 
[13:20:26.980]                                 success = TRUE)
[13:20:26.980]                               parallel_sendData(master, data)
[13:20:26.980]                             }
[13:20:26.980]                             return(sendCondition)
[13:20:26.980]                           }
[13:20:26.980]                         }
[13:20:26.980]                         frame <- frame + 1L
[13:20:26.980]                         envir <- sys.frame(frame)
[13:20:26.980]                       }
[13:20:26.980]                     }
[13:20:26.980]                     sendCondition <<- function(cond) NULL
[13:20:26.980]                   }
[13:20:26.980]                 })
[13:20:26.980]                 withCallingHandlers({
[13:20:26.980]                   NULL
[13:20:26.980]                 }, immediateCondition = function(cond) {
[13:20:26.980]                   sendCondition <- ...future.makeSendCondition()
[13:20:26.980]                   sendCondition(cond)
[13:20:26.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.980]                   {
[13:20:26.980]                     inherits <- base::inherits
[13:20:26.980]                     invokeRestart <- base::invokeRestart
[13:20:26.980]                     is.null <- base::is.null
[13:20:26.980]                     muffled <- FALSE
[13:20:26.980]                     if (inherits(cond, "message")) {
[13:20:26.980]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:26.980]                       if (muffled) 
[13:20:26.980]                         invokeRestart("muffleMessage")
[13:20:26.980]                     }
[13:20:26.980]                     else if (inherits(cond, "warning")) {
[13:20:26.980]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:26.980]                       if (muffled) 
[13:20:26.980]                         invokeRestart("muffleWarning")
[13:20:26.980]                     }
[13:20:26.980]                     else if (inherits(cond, "condition")) {
[13:20:26.980]                       if (!is.null(pattern)) {
[13:20:26.980]                         computeRestarts <- base::computeRestarts
[13:20:26.980]                         grepl <- base::grepl
[13:20:26.980]                         restarts <- computeRestarts(cond)
[13:20:26.980]                         for (restart in restarts) {
[13:20:26.980]                           name <- restart$name
[13:20:26.980]                           if (is.null(name)) 
[13:20:26.980]                             next
[13:20:26.980]                           if (!grepl(pattern, name)) 
[13:20:26.980]                             next
[13:20:26.980]                           invokeRestart(restart)
[13:20:26.980]                           muffled <- TRUE
[13:20:26.980]                           break
[13:20:26.980]                         }
[13:20:26.980]                       }
[13:20:26.980]                     }
[13:20:26.980]                     invisible(muffled)
[13:20:26.980]                   }
[13:20:26.980]                   muffleCondition(cond)
[13:20:26.980]                 })
[13:20:26.980]             }))
[13:20:26.980]             future::FutureResult(value = ...future.value$value, 
[13:20:26.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.980]                   ...future.rng), globalenv = if (FALSE) 
[13:20:26.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:26.980]                     ...future.globalenv.names))
[13:20:26.980]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:26.980]         }, condition = base::local({
[13:20:26.980]             c <- base::c
[13:20:26.980]             inherits <- base::inherits
[13:20:26.980]             invokeRestart <- base::invokeRestart
[13:20:26.980]             length <- base::length
[13:20:26.980]             list <- base::list
[13:20:26.980]             seq.int <- base::seq.int
[13:20:26.980]             signalCondition <- base::signalCondition
[13:20:26.980]             sys.calls <- base::sys.calls
[13:20:26.980]             `[[` <- base::`[[`
[13:20:26.980]             `+` <- base::`+`
[13:20:26.980]             `<<-` <- base::`<<-`
[13:20:26.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:26.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:26.980]                   3L)]
[13:20:26.980]             }
[13:20:26.980]             function(cond) {
[13:20:26.980]                 is_error <- inherits(cond, "error")
[13:20:26.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:26.980]                   NULL)
[13:20:26.980]                 if (is_error) {
[13:20:26.980]                   sessionInformation <- function() {
[13:20:26.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:26.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:26.980]                       search = base::search(), system = base::Sys.info())
[13:20:26.980]                   }
[13:20:26.980]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:26.980]                     cond$call), session = sessionInformation(), 
[13:20:26.980]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:26.980]                   signalCondition(cond)
[13:20:26.980]                 }
[13:20:26.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:26.980]                 "immediateCondition"))) {
[13:20:26.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:26.980]                   ...future.conditions[[length(...future.conditions) + 
[13:20:26.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:26.980]                   if (TRUE && !signal) {
[13:20:26.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.980]                     {
[13:20:26.980]                       inherits <- base::inherits
[13:20:26.980]                       invokeRestart <- base::invokeRestart
[13:20:26.980]                       is.null <- base::is.null
[13:20:26.980]                       muffled <- FALSE
[13:20:26.980]                       if (inherits(cond, "message")) {
[13:20:26.980]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.980]                         if (muffled) 
[13:20:26.980]                           invokeRestart("muffleMessage")
[13:20:26.980]                       }
[13:20:26.980]                       else if (inherits(cond, "warning")) {
[13:20:26.980]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.980]                         if (muffled) 
[13:20:26.980]                           invokeRestart("muffleWarning")
[13:20:26.980]                       }
[13:20:26.980]                       else if (inherits(cond, "condition")) {
[13:20:26.980]                         if (!is.null(pattern)) {
[13:20:26.980]                           computeRestarts <- base::computeRestarts
[13:20:26.980]                           grepl <- base::grepl
[13:20:26.980]                           restarts <- computeRestarts(cond)
[13:20:26.980]                           for (restart in restarts) {
[13:20:26.980]                             name <- restart$name
[13:20:26.980]                             if (is.null(name)) 
[13:20:26.980]                               next
[13:20:26.980]                             if (!grepl(pattern, name)) 
[13:20:26.980]                               next
[13:20:26.980]                             invokeRestart(restart)
[13:20:26.980]                             muffled <- TRUE
[13:20:26.980]                             break
[13:20:26.980]                           }
[13:20:26.980]                         }
[13:20:26.980]                       }
[13:20:26.980]                       invisible(muffled)
[13:20:26.980]                     }
[13:20:26.980]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.980]                   }
[13:20:26.980]                 }
[13:20:26.980]                 else {
[13:20:26.980]                   if (TRUE) {
[13:20:26.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:26.980]                     {
[13:20:26.980]                       inherits <- base::inherits
[13:20:26.980]                       invokeRestart <- base::invokeRestart
[13:20:26.980]                       is.null <- base::is.null
[13:20:26.980]                       muffled <- FALSE
[13:20:26.980]                       if (inherits(cond, "message")) {
[13:20:26.980]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:26.980]                         if (muffled) 
[13:20:26.980]                           invokeRestart("muffleMessage")
[13:20:26.980]                       }
[13:20:26.980]                       else if (inherits(cond, "warning")) {
[13:20:26.980]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:26.980]                         if (muffled) 
[13:20:26.980]                           invokeRestart("muffleWarning")
[13:20:26.980]                       }
[13:20:26.980]                       else if (inherits(cond, "condition")) {
[13:20:26.980]                         if (!is.null(pattern)) {
[13:20:26.980]                           computeRestarts <- base::computeRestarts
[13:20:26.980]                           grepl <- base::grepl
[13:20:26.980]                           restarts <- computeRestarts(cond)
[13:20:26.980]                           for (restart in restarts) {
[13:20:26.980]                             name <- restart$name
[13:20:26.980]                             if (is.null(name)) 
[13:20:26.980]                               next
[13:20:26.980]                             if (!grepl(pattern, name)) 
[13:20:26.980]                               next
[13:20:26.980]                             invokeRestart(restart)
[13:20:26.980]                             muffled <- TRUE
[13:20:26.980]                             break
[13:20:26.980]                           }
[13:20:26.980]                         }
[13:20:26.980]                       }
[13:20:26.980]                       invisible(muffled)
[13:20:26.980]                     }
[13:20:26.980]                     muffleCondition(cond, pattern = "^muffle")
[13:20:26.980]                   }
[13:20:26.980]                 }
[13:20:26.980]             }
[13:20:26.980]         }))
[13:20:26.980]     }, error = function(ex) {
[13:20:26.980]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:26.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:26.980]                 ...future.rng), started = ...future.startTime, 
[13:20:26.980]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:26.980]             version = "1.8"), class = "FutureResult")
[13:20:26.980]     }, finally = {
[13:20:26.980]         if (!identical(...future.workdir, getwd())) 
[13:20:26.980]             setwd(...future.workdir)
[13:20:26.980]         {
[13:20:26.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:26.980]                 ...future.oldOptions$nwarnings <- NULL
[13:20:26.980]             }
[13:20:26.980]             base::options(...future.oldOptions)
[13:20:26.980]             if (.Platform$OS.type == "windows") {
[13:20:26.980]                 old_names <- names(...future.oldEnvVars)
[13:20:26.980]                 envs <- base::Sys.getenv()
[13:20:26.980]                 names <- names(envs)
[13:20:26.980]                 common <- intersect(names, old_names)
[13:20:26.980]                 added <- setdiff(names, old_names)
[13:20:26.980]                 removed <- setdiff(old_names, names)
[13:20:26.980]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:26.980]                   envs[common]]
[13:20:26.980]                 NAMES <- toupper(changed)
[13:20:26.980]                 args <- list()
[13:20:26.980]                 for (kk in seq_along(NAMES)) {
[13:20:26.980]                   name <- changed[[kk]]
[13:20:26.980]                   NAME <- NAMES[[kk]]
[13:20:26.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.980]                     next
[13:20:26.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.980]                 }
[13:20:26.980]                 NAMES <- toupper(added)
[13:20:26.980]                 for (kk in seq_along(NAMES)) {
[13:20:26.980]                   name <- added[[kk]]
[13:20:26.980]                   NAME <- NAMES[[kk]]
[13:20:26.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.980]                     next
[13:20:26.980]                   args[[name]] <- ""
[13:20:26.980]                 }
[13:20:26.980]                 NAMES <- toupper(removed)
[13:20:26.980]                 for (kk in seq_along(NAMES)) {
[13:20:26.980]                   name <- removed[[kk]]
[13:20:26.980]                   NAME <- NAMES[[kk]]
[13:20:26.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:26.980]                     next
[13:20:26.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:26.980]                 }
[13:20:26.980]                 if (length(args) > 0) 
[13:20:26.980]                   base::do.call(base::Sys.setenv, args = args)
[13:20:26.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:26.980]             }
[13:20:26.980]             else {
[13:20:26.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:26.980]             }
[13:20:26.980]             {
[13:20:26.980]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:26.980]                   0L) {
[13:20:26.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:26.980]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:26.980]                   base::options(opts)
[13:20:26.980]                 }
[13:20:26.980]                 {
[13:20:26.980]                   {
[13:20:26.980]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:26.980]                     NULL
[13:20:26.980]                   }
[13:20:26.980]                   options(future.plan = NULL)
[13:20:26.980]                   if (is.na(NA_character_)) 
[13:20:26.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:26.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:26.980]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:26.980]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:26.980]                     envir = parent.frame()) 
[13:20:26.980]                   {
[13:20:26.980]                     if (is.function(workers)) 
[13:20:26.980]                       workers <- workers()
[13:20:26.980]                     workers <- structure(as.integer(workers), 
[13:20:26.980]                       class = class(workers))
[13:20:26.980]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:26.980]                       workers >= 1)
[13:20:26.980]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:26.980]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:26.980]                     }
[13:20:26.980]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:26.980]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:26.980]                       envir = envir)
[13:20:26.980]                     if (!future$lazy) 
[13:20:26.980]                       future <- run(future)
[13:20:26.980]                     invisible(future)
[13:20:26.980]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:26.980]                 }
[13:20:26.980]             }
[13:20:26.980]         }
[13:20:26.980]     })
[13:20:26.980]     if (TRUE) {
[13:20:26.980]         base::sink(type = "output", split = FALSE)
[13:20:26.980]         if (TRUE) {
[13:20:26.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:26.980]         }
[13:20:26.980]         else {
[13:20:26.980]             ...future.result["stdout"] <- base::list(NULL)
[13:20:26.980]         }
[13:20:26.980]         base::close(...future.stdout)
[13:20:26.980]         ...future.stdout <- NULL
[13:20:26.980]     }
[13:20:26.980]     ...future.result$conditions <- ...future.conditions
[13:20:26.980]     ...future.result$finished <- base::Sys.time()
[13:20:26.980]     ...future.result
[13:20:26.980] }
[13:20:26.984] MultisessionFuture started
[13:20:26.984] - Launch lazy future ... done
[13:20:26.984] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659d5045b0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659d861f80> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659d5045b0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659d861f80> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:27.015] resolve() on list ...
[13:20:27.015]  recursive: 0
[13:20:27.015]  length: 6
[13:20:27.015]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:27.015] signalConditionsASAP(numeric, pos=1) ...
[13:20:27.015] - nx: 6
[13:20:27.016] - relay: TRUE
[13:20:27.016] - stdout: TRUE
[13:20:27.016] - signal: TRUE
[13:20:27.016] - resignal: FALSE
[13:20:27.016] - force: TRUE
[13:20:27.016] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.016] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.016]  - until=2
[13:20:27.016]  - relaying element #2
[13:20:27.016] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.016] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.017] signalConditionsASAP(NULL, pos=1) ... done
[13:20:27.017]  length: 5 (resolved future 1)
[13:20:27.017] receiveMessageFromWorker() for ClusterFuture ...
[13:20:27.017] - Validating connection of MultisessionFuture
[13:20:27.018] - received message: FutureResult
[13:20:27.018] - Received FutureResult
[13:20:27.018] - Erased future from FutureRegistry
[13:20:27.018] result() for ClusterFuture ...
[13:20:27.018] - result already collected: FutureResult
[13:20:27.018] result() for ClusterFuture ... done
[13:20:27.018] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:27.018] Future #2
[13:20:27.018] result() for ClusterFuture ...
[13:20:27.018] - result already collected: FutureResult
[13:20:27.019] result() for ClusterFuture ... done
[13:20:27.019] result() for ClusterFuture ...
[13:20:27.019] - result already collected: FutureResult
[13:20:27.019] result() for ClusterFuture ... done
[13:20:27.019] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:27.019] - nx: 6
[13:20:27.019] - relay: TRUE
[13:20:27.019] - stdout: TRUE
[13:20:27.019] - signal: TRUE
[13:20:27.019] - resignal: FALSE
[13:20:27.019] - force: TRUE
[13:20:27.020] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.020] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.020]  - until=2
[13:20:27.020]  - relaying element #2
[13:20:27.020] result() for ClusterFuture ...
[13:20:27.020] - result already collected: FutureResult
[13:20:27.020] result() for ClusterFuture ... done
[13:20:27.020] result() for ClusterFuture ...
[13:20:27.020] - result already collected: FutureResult
[13:20:27.020] result() for ClusterFuture ... done
[13:20:27.020] result() for ClusterFuture ...
[13:20:27.021] - result already collected: FutureResult
[13:20:27.021] result() for ClusterFuture ... done
[13:20:27.021] result() for ClusterFuture ...
[13:20:27.021] - result already collected: FutureResult
[13:20:27.021] result() for ClusterFuture ... done
[13:20:27.021] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.021] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.021] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:27.021]  length: 4 (resolved future 2)
[13:20:27.030] receiveMessageFromWorker() for ClusterFuture ...
[13:20:27.030] - Validating connection of MultisessionFuture
[13:20:27.030] - received message: FutureResult
[13:20:27.030] - Received FutureResult
[13:20:27.031] - Erased future from FutureRegistry
[13:20:27.031] result() for ClusterFuture ...
[13:20:27.031] - result already collected: FutureResult
[13:20:27.031] result() for ClusterFuture ... done
[13:20:27.031] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:27.031] Future #3
[13:20:27.031] result() for ClusterFuture ...
[13:20:27.031] - result already collected: FutureResult
[13:20:27.031] result() for ClusterFuture ... done
[13:20:27.031] result() for ClusterFuture ...
[13:20:27.031] - result already collected: FutureResult
[13:20:27.032] result() for ClusterFuture ... done
[13:20:27.032] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:27.032] - nx: 6
[13:20:27.032] - relay: TRUE
[13:20:27.032] - stdout: TRUE
[13:20:27.032] - signal: TRUE
[13:20:27.032] - resignal: FALSE
[13:20:27.032] - force: TRUE
[13:20:27.032] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.032] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.032]  - until=3
[13:20:27.033]  - relaying element #3
[13:20:27.033] result() for ClusterFuture ...
[13:20:27.033] - result already collected: FutureResult
[13:20:27.033] result() for ClusterFuture ... done
[13:20:27.033] result() for ClusterFuture ...
[13:20:27.033] - result already collected: FutureResult
[13:20:27.033] result() for ClusterFuture ... done
[13:20:27.033] result() for ClusterFuture ...
[13:20:27.033] - result already collected: FutureResult
[13:20:27.033] result() for ClusterFuture ... done
[13:20:27.033] result() for ClusterFuture ...
[13:20:27.034] - result already collected: FutureResult
[13:20:27.034] result() for ClusterFuture ... done
[13:20:27.034] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.034] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.034] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:27.034]  length: 3 (resolved future 3)
[13:20:27.034] signalConditionsASAP(NULL, pos=4) ...
[13:20:27.034] - nx: 6
[13:20:27.034] - relay: TRUE
[13:20:27.034] - stdout: TRUE
[13:20:27.034] - signal: TRUE
[13:20:27.035] - resignal: FALSE
[13:20:27.035] - force: TRUE
[13:20:27.035] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.035] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.035]  - until=5
[13:20:27.035]  - relaying element #5
[13:20:27.035] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:27.035] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.035] signalConditionsASAP(NULL, pos=4) ... done
[13:20:27.035]  length: 2 (resolved future 4)
[13:20:27.035] signalConditionsASAP(NULL, pos=5) ...
[13:20:27.035] - nx: 6
[13:20:27.036] - relay: TRUE
[13:20:27.036] - stdout: TRUE
[13:20:27.036] - signal: TRUE
[13:20:27.036] - resignal: FALSE
[13:20:27.036] - force: TRUE
[13:20:27.036] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:27.036] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.036]  - until=6
[13:20:27.036]  - relaying element #6
[13:20:27.036] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:27.036] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.037] signalConditionsASAP(NULL, pos=5) ... done
[13:20:27.037]  length: 1 (resolved future 5)
[13:20:27.037] signalConditionsASAP(numeric, pos=6) ...
[13:20:27.037] - nx: 6
[13:20:27.037] - relay: TRUE
[13:20:27.037] - stdout: TRUE
[13:20:27.037] - signal: TRUE
[13:20:27.037] - resignal: FALSE
[13:20:27.037] - force: TRUE
[13:20:27.037] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:27.037] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.037]  - until=6
[13:20:27.038] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:27.038] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.038] signalConditionsASAP(numeric, pos=6) ... done
[13:20:27.038]  length: 0 (resolved future 6)
[13:20:27.038] Relaying remaining futures
[13:20:27.038] signalConditionsASAP(NULL, pos=0) ...
[13:20:27.038] - nx: 6
[13:20:27.038] - relay: TRUE
[13:20:27.038] - stdout: TRUE
[13:20:27.038] - signal: TRUE
[13:20:27.038] - resignal: FALSE
[13:20:27.039] - force: TRUE
[13:20:27.039] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:27.039] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:27.039] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:27.039] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.039] signalConditionsASAP(NULL, pos=0) ... done
[13:20:27.039] resolve() on list ... DONE
[13:20:27.039] result() for ClusterFuture ...
[13:20:27.039] - result already collected: FutureResult
[13:20:27.039] result() for ClusterFuture ... done
[13:20:27.039] result() for ClusterFuture ...
[13:20:27.040] - result already collected: FutureResult
[13:20:27.040] result() for ClusterFuture ... done
[13:20:27.040] result() for ClusterFuture ...
[13:20:27.040] - result already collected: FutureResult
[13:20:27.040] result() for ClusterFuture ... done
[13:20:27.040] result() for ClusterFuture ...
[13:20:27.040] - result already collected: FutureResult
[13:20:27.040] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:20:27.044] getGlobalsAndPackages() ...
[13:20:27.044] Searching for globals...
[13:20:27.044] 
[13:20:27.044] Searching for globals ... DONE
[13:20:27.044] - globals: [0] <none>
[13:20:27.044] getGlobalsAndPackages() ... DONE
[13:20:27.045] run() for ‘Future’ ...
[13:20:27.045] - state: ‘created’
[13:20:27.045] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.061] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:27.061]   - Field: ‘node’
[13:20:27.061]   - Field: ‘label’
[13:20:27.061]   - Field: ‘local’
[13:20:27.061]   - Field: ‘owner’
[13:20:27.061]   - Field: ‘envir’
[13:20:27.062]   - Field: ‘workers’
[13:20:27.062]   - Field: ‘packages’
[13:20:27.062]   - Field: ‘gc’
[13:20:27.062]   - Field: ‘conditions’
[13:20:27.062]   - Field: ‘persistent’
[13:20:27.062]   - Field: ‘expr’
[13:20:27.062]   - Field: ‘uuid’
[13:20:27.062]   - Field: ‘seed’
[13:20:27.062]   - Field: ‘version’
[13:20:27.062]   - Field: ‘result’
[13:20:27.063]   - Field: ‘asynchronous’
[13:20:27.063]   - Field: ‘calls’
[13:20:27.063]   - Field: ‘globals’
[13:20:27.063]   - Field: ‘stdout’
[13:20:27.063]   - Field: ‘earlySignal’
[13:20:27.063]   - Field: ‘lazy’
[13:20:27.063]   - Field: ‘state’
[13:20:27.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:27.063] - Launch lazy future ...
[13:20:27.064] Packages needed by the future expression (n = 0): <none>
[13:20:27.064] Packages needed by future strategies (n = 0): <none>
[13:20:27.064] {
[13:20:27.064]     {
[13:20:27.064]         {
[13:20:27.064]             ...future.startTime <- base::Sys.time()
[13:20:27.064]             {
[13:20:27.064]                 {
[13:20:27.064]                   {
[13:20:27.064]                     {
[13:20:27.064]                       base::local({
[13:20:27.064]                         has_future <- base::requireNamespace("future", 
[13:20:27.064]                           quietly = TRUE)
[13:20:27.064]                         if (has_future) {
[13:20:27.064]                           ns <- base::getNamespace("future")
[13:20:27.064]                           version <- ns[[".package"]][["version"]]
[13:20:27.064]                           if (is.null(version)) 
[13:20:27.064]                             version <- utils::packageVersion("future")
[13:20:27.064]                         }
[13:20:27.064]                         else {
[13:20:27.064]                           version <- NULL
[13:20:27.064]                         }
[13:20:27.064]                         if (!has_future || version < "1.8.0") {
[13:20:27.064]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.064]                             "", base::R.version$version.string), 
[13:20:27.064]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.064]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.064]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.064]                               "release", "version")], collapse = " "), 
[13:20:27.064]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.064]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.064]                             info)
[13:20:27.064]                           info <- base::paste(info, collapse = "; ")
[13:20:27.064]                           if (!has_future) {
[13:20:27.064]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.064]                               info)
[13:20:27.064]                           }
[13:20:27.064]                           else {
[13:20:27.064]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.064]                               info, version)
[13:20:27.064]                           }
[13:20:27.064]                           base::stop(msg)
[13:20:27.064]                         }
[13:20:27.064]                       })
[13:20:27.064]                     }
[13:20:27.064]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.064]                     base::options(mc.cores = 1L)
[13:20:27.064]                   }
[13:20:27.064]                   options(future.plan = NULL)
[13:20:27.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.064]                 }
[13:20:27.064]                 ...future.workdir <- getwd()
[13:20:27.064]             }
[13:20:27.064]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.064]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.064]         }
[13:20:27.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.064]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.064]             base::names(...future.oldOptions))
[13:20:27.064]     }
[13:20:27.064]     if (FALSE) {
[13:20:27.064]     }
[13:20:27.064]     else {
[13:20:27.064]         if (TRUE) {
[13:20:27.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.064]                 open = "w")
[13:20:27.064]         }
[13:20:27.064]         else {
[13:20:27.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.064]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.064]         }
[13:20:27.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.064]             base::sink(type = "output", split = FALSE)
[13:20:27.064]             base::close(...future.stdout)
[13:20:27.064]         }, add = TRUE)
[13:20:27.064]     }
[13:20:27.064]     ...future.frame <- base::sys.nframe()
[13:20:27.064]     ...future.conditions <- base::list()
[13:20:27.064]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.064]     if (FALSE) {
[13:20:27.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.064]     }
[13:20:27.064]     ...future.result <- base::tryCatch({
[13:20:27.064]         base::withCallingHandlers({
[13:20:27.064]             ...future.value <- base::withVisible(base::local({
[13:20:27.064]                 ...future.makeSendCondition <- local({
[13:20:27.064]                   sendCondition <- NULL
[13:20:27.064]                   function(frame = 1L) {
[13:20:27.064]                     if (is.function(sendCondition)) 
[13:20:27.064]                       return(sendCondition)
[13:20:27.064]                     ns <- getNamespace("parallel")
[13:20:27.064]                     if (exists("sendData", mode = "function", 
[13:20:27.064]                       envir = ns)) {
[13:20:27.064]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:27.064]                         envir = ns)
[13:20:27.064]                       envir <- sys.frame(frame)
[13:20:27.064]                       master <- NULL
[13:20:27.064]                       while (!identical(envir, .GlobalEnv) && 
[13:20:27.064]                         !identical(envir, emptyenv())) {
[13:20:27.064]                         if (exists("master", mode = "list", envir = envir, 
[13:20:27.064]                           inherits = FALSE)) {
[13:20:27.064]                           master <- get("master", mode = "list", 
[13:20:27.064]                             envir = envir, inherits = FALSE)
[13:20:27.064]                           if (inherits(master, c("SOCKnode", 
[13:20:27.064]                             "SOCK0node"))) {
[13:20:27.064]                             sendCondition <<- function(cond) {
[13:20:27.064]                               data <- list(type = "VALUE", value = cond, 
[13:20:27.064]                                 success = TRUE)
[13:20:27.064]                               parallel_sendData(master, data)
[13:20:27.064]                             }
[13:20:27.064]                             return(sendCondition)
[13:20:27.064]                           }
[13:20:27.064]                         }
[13:20:27.064]                         frame <- frame + 1L
[13:20:27.064]                         envir <- sys.frame(frame)
[13:20:27.064]                       }
[13:20:27.064]                     }
[13:20:27.064]                     sendCondition <<- function(cond) NULL
[13:20:27.064]                   }
[13:20:27.064]                 })
[13:20:27.064]                 withCallingHandlers({
[13:20:27.064]                   2
[13:20:27.064]                 }, immediateCondition = function(cond) {
[13:20:27.064]                   sendCondition <- ...future.makeSendCondition()
[13:20:27.064]                   sendCondition(cond)
[13:20:27.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.064]                   {
[13:20:27.064]                     inherits <- base::inherits
[13:20:27.064]                     invokeRestart <- base::invokeRestart
[13:20:27.064]                     is.null <- base::is.null
[13:20:27.064]                     muffled <- FALSE
[13:20:27.064]                     if (inherits(cond, "message")) {
[13:20:27.064]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.064]                       if (muffled) 
[13:20:27.064]                         invokeRestart("muffleMessage")
[13:20:27.064]                     }
[13:20:27.064]                     else if (inherits(cond, "warning")) {
[13:20:27.064]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.064]                       if (muffled) 
[13:20:27.064]                         invokeRestart("muffleWarning")
[13:20:27.064]                     }
[13:20:27.064]                     else if (inherits(cond, "condition")) {
[13:20:27.064]                       if (!is.null(pattern)) {
[13:20:27.064]                         computeRestarts <- base::computeRestarts
[13:20:27.064]                         grepl <- base::grepl
[13:20:27.064]                         restarts <- computeRestarts(cond)
[13:20:27.064]                         for (restart in restarts) {
[13:20:27.064]                           name <- restart$name
[13:20:27.064]                           if (is.null(name)) 
[13:20:27.064]                             next
[13:20:27.064]                           if (!grepl(pattern, name)) 
[13:20:27.064]                             next
[13:20:27.064]                           invokeRestart(restart)
[13:20:27.064]                           muffled <- TRUE
[13:20:27.064]                           break
[13:20:27.064]                         }
[13:20:27.064]                       }
[13:20:27.064]                     }
[13:20:27.064]                     invisible(muffled)
[13:20:27.064]                   }
[13:20:27.064]                   muffleCondition(cond)
[13:20:27.064]                 })
[13:20:27.064]             }))
[13:20:27.064]             future::FutureResult(value = ...future.value$value, 
[13:20:27.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.064]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.064]                     ...future.globalenv.names))
[13:20:27.064]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.064]         }, condition = base::local({
[13:20:27.064]             c <- base::c
[13:20:27.064]             inherits <- base::inherits
[13:20:27.064]             invokeRestart <- base::invokeRestart
[13:20:27.064]             length <- base::length
[13:20:27.064]             list <- base::list
[13:20:27.064]             seq.int <- base::seq.int
[13:20:27.064]             signalCondition <- base::signalCondition
[13:20:27.064]             sys.calls <- base::sys.calls
[13:20:27.064]             `[[` <- base::`[[`
[13:20:27.064]             `+` <- base::`+`
[13:20:27.064]             `<<-` <- base::`<<-`
[13:20:27.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.064]                   3L)]
[13:20:27.064]             }
[13:20:27.064]             function(cond) {
[13:20:27.064]                 is_error <- inherits(cond, "error")
[13:20:27.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.064]                   NULL)
[13:20:27.064]                 if (is_error) {
[13:20:27.064]                   sessionInformation <- function() {
[13:20:27.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.064]                       search = base::search(), system = base::Sys.info())
[13:20:27.064]                   }
[13:20:27.064]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.064]                     cond$call), session = sessionInformation(), 
[13:20:27.064]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.064]                   signalCondition(cond)
[13:20:27.064]                 }
[13:20:27.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.064]                 "immediateCondition"))) {
[13:20:27.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.064]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.064]                   if (TRUE && !signal) {
[13:20:27.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.064]                     {
[13:20:27.064]                       inherits <- base::inherits
[13:20:27.064]                       invokeRestart <- base::invokeRestart
[13:20:27.064]                       is.null <- base::is.null
[13:20:27.064]                       muffled <- FALSE
[13:20:27.064]                       if (inherits(cond, "message")) {
[13:20:27.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.064]                         if (muffled) 
[13:20:27.064]                           invokeRestart("muffleMessage")
[13:20:27.064]                       }
[13:20:27.064]                       else if (inherits(cond, "warning")) {
[13:20:27.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.064]                         if (muffled) 
[13:20:27.064]                           invokeRestart("muffleWarning")
[13:20:27.064]                       }
[13:20:27.064]                       else if (inherits(cond, "condition")) {
[13:20:27.064]                         if (!is.null(pattern)) {
[13:20:27.064]                           computeRestarts <- base::computeRestarts
[13:20:27.064]                           grepl <- base::grepl
[13:20:27.064]                           restarts <- computeRestarts(cond)
[13:20:27.064]                           for (restart in restarts) {
[13:20:27.064]                             name <- restart$name
[13:20:27.064]                             if (is.null(name)) 
[13:20:27.064]                               next
[13:20:27.064]                             if (!grepl(pattern, name)) 
[13:20:27.064]                               next
[13:20:27.064]                             invokeRestart(restart)
[13:20:27.064]                             muffled <- TRUE
[13:20:27.064]                             break
[13:20:27.064]                           }
[13:20:27.064]                         }
[13:20:27.064]                       }
[13:20:27.064]                       invisible(muffled)
[13:20:27.064]                     }
[13:20:27.064]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.064]                   }
[13:20:27.064]                 }
[13:20:27.064]                 else {
[13:20:27.064]                   if (TRUE) {
[13:20:27.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.064]                     {
[13:20:27.064]                       inherits <- base::inherits
[13:20:27.064]                       invokeRestart <- base::invokeRestart
[13:20:27.064]                       is.null <- base::is.null
[13:20:27.064]                       muffled <- FALSE
[13:20:27.064]                       if (inherits(cond, "message")) {
[13:20:27.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.064]                         if (muffled) 
[13:20:27.064]                           invokeRestart("muffleMessage")
[13:20:27.064]                       }
[13:20:27.064]                       else if (inherits(cond, "warning")) {
[13:20:27.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.064]                         if (muffled) 
[13:20:27.064]                           invokeRestart("muffleWarning")
[13:20:27.064]                       }
[13:20:27.064]                       else if (inherits(cond, "condition")) {
[13:20:27.064]                         if (!is.null(pattern)) {
[13:20:27.064]                           computeRestarts <- base::computeRestarts
[13:20:27.064]                           grepl <- base::grepl
[13:20:27.064]                           restarts <- computeRestarts(cond)
[13:20:27.064]                           for (restart in restarts) {
[13:20:27.064]                             name <- restart$name
[13:20:27.064]                             if (is.null(name)) 
[13:20:27.064]                               next
[13:20:27.064]                             if (!grepl(pattern, name)) 
[13:20:27.064]                               next
[13:20:27.064]                             invokeRestart(restart)
[13:20:27.064]                             muffled <- TRUE
[13:20:27.064]                             break
[13:20:27.064]                           }
[13:20:27.064]                         }
[13:20:27.064]                       }
[13:20:27.064]                       invisible(muffled)
[13:20:27.064]                     }
[13:20:27.064]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.064]                   }
[13:20:27.064]                 }
[13:20:27.064]             }
[13:20:27.064]         }))
[13:20:27.064]     }, error = function(ex) {
[13:20:27.064]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.064]                 ...future.rng), started = ...future.startTime, 
[13:20:27.064]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.064]             version = "1.8"), class = "FutureResult")
[13:20:27.064]     }, finally = {
[13:20:27.064]         if (!identical(...future.workdir, getwd())) 
[13:20:27.064]             setwd(...future.workdir)
[13:20:27.064]         {
[13:20:27.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.064]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.064]             }
[13:20:27.064]             base::options(...future.oldOptions)
[13:20:27.064]             if (.Platform$OS.type == "windows") {
[13:20:27.064]                 old_names <- names(...future.oldEnvVars)
[13:20:27.064]                 envs <- base::Sys.getenv()
[13:20:27.064]                 names <- names(envs)
[13:20:27.064]                 common <- intersect(names, old_names)
[13:20:27.064]                 added <- setdiff(names, old_names)
[13:20:27.064]                 removed <- setdiff(old_names, names)
[13:20:27.064]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.064]                   envs[common]]
[13:20:27.064]                 NAMES <- toupper(changed)
[13:20:27.064]                 args <- list()
[13:20:27.064]                 for (kk in seq_along(NAMES)) {
[13:20:27.064]                   name <- changed[[kk]]
[13:20:27.064]                   NAME <- NAMES[[kk]]
[13:20:27.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.064]                     next
[13:20:27.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.064]                 }
[13:20:27.064]                 NAMES <- toupper(added)
[13:20:27.064]                 for (kk in seq_along(NAMES)) {
[13:20:27.064]                   name <- added[[kk]]
[13:20:27.064]                   NAME <- NAMES[[kk]]
[13:20:27.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.064]                     next
[13:20:27.064]                   args[[name]] <- ""
[13:20:27.064]                 }
[13:20:27.064]                 NAMES <- toupper(removed)
[13:20:27.064]                 for (kk in seq_along(NAMES)) {
[13:20:27.064]                   name <- removed[[kk]]
[13:20:27.064]                   NAME <- NAMES[[kk]]
[13:20:27.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.064]                     next
[13:20:27.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.064]                 }
[13:20:27.064]                 if (length(args) > 0) 
[13:20:27.064]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.064]             }
[13:20:27.064]             else {
[13:20:27.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.064]             }
[13:20:27.064]             {
[13:20:27.064]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.064]                   0L) {
[13:20:27.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.064]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.064]                   base::options(opts)
[13:20:27.064]                 }
[13:20:27.064]                 {
[13:20:27.064]                   {
[13:20:27.064]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.064]                     NULL
[13:20:27.064]                   }
[13:20:27.064]                   options(future.plan = NULL)
[13:20:27.064]                   if (is.na(NA_character_)) 
[13:20:27.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.064]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:27.064]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:27.064]                     envir = parent.frame()) 
[13:20:27.064]                   {
[13:20:27.064]                     if (is.function(workers)) 
[13:20:27.064]                       workers <- workers()
[13:20:27.064]                     workers <- structure(as.integer(workers), 
[13:20:27.064]                       class = class(workers))
[13:20:27.064]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:27.064]                       workers >= 1)
[13:20:27.064]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:27.064]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:27.064]                     }
[13:20:27.064]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:27.064]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:27.064]                       envir = envir)
[13:20:27.064]                     if (!future$lazy) 
[13:20:27.064]                       future <- run(future)
[13:20:27.064]                     invisible(future)
[13:20:27.064]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.064]                 }
[13:20:27.064]             }
[13:20:27.064]         }
[13:20:27.064]     })
[13:20:27.064]     if (TRUE) {
[13:20:27.064]         base::sink(type = "output", split = FALSE)
[13:20:27.064]         if (TRUE) {
[13:20:27.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.064]         }
[13:20:27.064]         else {
[13:20:27.064]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.064]         }
[13:20:27.064]         base::close(...future.stdout)
[13:20:27.064]         ...future.stdout <- NULL
[13:20:27.064]     }
[13:20:27.064]     ...future.result$conditions <- ...future.conditions
[13:20:27.064]     ...future.result$finished <- base::Sys.time()
[13:20:27.064]     ...future.result
[13:20:27.064] }
[13:20:27.068] MultisessionFuture started
[13:20:27.068] - Launch lazy future ... done
[13:20:27.068] run() for ‘MultisessionFuture’ ... done
[13:20:27.068] getGlobalsAndPackages() ...
[13:20:27.068] Searching for globals...
[13:20:27.068] 
[13:20:27.069] Searching for globals ... DONE
[13:20:27.069] - globals: [0] <none>
[13:20:27.069] getGlobalsAndPackages() ... DONE
[13:20:27.069] run() for ‘Future’ ...
[13:20:27.069] - state: ‘created’
[13:20:27.069] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.084] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.084] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:27.085]   - Field: ‘node’
[13:20:27.085]   - Field: ‘label’
[13:20:27.085]   - Field: ‘local’
[13:20:27.085]   - Field: ‘owner’
[13:20:27.085]   - Field: ‘envir’
[13:20:27.085]   - Field: ‘workers’
[13:20:27.085]   - Field: ‘packages’
[13:20:27.085]   - Field: ‘gc’
[13:20:27.085]   - Field: ‘conditions’
[13:20:27.086]   - Field: ‘persistent’
[13:20:27.086]   - Field: ‘expr’
[13:20:27.086]   - Field: ‘uuid’
[13:20:27.086]   - Field: ‘seed’
[13:20:27.086]   - Field: ‘version’
[13:20:27.086]   - Field: ‘result’
[13:20:27.086]   - Field: ‘asynchronous’
[13:20:27.086]   - Field: ‘calls’
[13:20:27.086]   - Field: ‘globals’
[13:20:27.086]   - Field: ‘stdout’
[13:20:27.086]   - Field: ‘earlySignal’
[13:20:27.087]   - Field: ‘lazy’
[13:20:27.087]   - Field: ‘state’
[13:20:27.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:27.087] - Launch lazy future ...
[13:20:27.087] Packages needed by the future expression (n = 0): <none>
[13:20:27.087] Packages needed by future strategies (n = 0): <none>
[13:20:27.088] {
[13:20:27.088]     {
[13:20:27.088]         {
[13:20:27.088]             ...future.startTime <- base::Sys.time()
[13:20:27.088]             {
[13:20:27.088]                 {
[13:20:27.088]                   {
[13:20:27.088]                     {
[13:20:27.088]                       base::local({
[13:20:27.088]                         has_future <- base::requireNamespace("future", 
[13:20:27.088]                           quietly = TRUE)
[13:20:27.088]                         if (has_future) {
[13:20:27.088]                           ns <- base::getNamespace("future")
[13:20:27.088]                           version <- ns[[".package"]][["version"]]
[13:20:27.088]                           if (is.null(version)) 
[13:20:27.088]                             version <- utils::packageVersion("future")
[13:20:27.088]                         }
[13:20:27.088]                         else {
[13:20:27.088]                           version <- NULL
[13:20:27.088]                         }
[13:20:27.088]                         if (!has_future || version < "1.8.0") {
[13:20:27.088]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.088]                             "", base::R.version$version.string), 
[13:20:27.088]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.088]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.088]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.088]                               "release", "version")], collapse = " "), 
[13:20:27.088]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.088]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.088]                             info)
[13:20:27.088]                           info <- base::paste(info, collapse = "; ")
[13:20:27.088]                           if (!has_future) {
[13:20:27.088]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.088]                               info)
[13:20:27.088]                           }
[13:20:27.088]                           else {
[13:20:27.088]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.088]                               info, version)
[13:20:27.088]                           }
[13:20:27.088]                           base::stop(msg)
[13:20:27.088]                         }
[13:20:27.088]                       })
[13:20:27.088]                     }
[13:20:27.088]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.088]                     base::options(mc.cores = 1L)
[13:20:27.088]                   }
[13:20:27.088]                   options(future.plan = NULL)
[13:20:27.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.088]                 }
[13:20:27.088]                 ...future.workdir <- getwd()
[13:20:27.088]             }
[13:20:27.088]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.088]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.088]         }
[13:20:27.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.088]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.088]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.088]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.088]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.088]             base::names(...future.oldOptions))
[13:20:27.088]     }
[13:20:27.088]     if (FALSE) {
[13:20:27.088]     }
[13:20:27.088]     else {
[13:20:27.088]         if (TRUE) {
[13:20:27.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.088]                 open = "w")
[13:20:27.088]         }
[13:20:27.088]         else {
[13:20:27.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.088]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.088]         }
[13:20:27.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.088]             base::sink(type = "output", split = FALSE)
[13:20:27.088]             base::close(...future.stdout)
[13:20:27.088]         }, add = TRUE)
[13:20:27.088]     }
[13:20:27.088]     ...future.frame <- base::sys.nframe()
[13:20:27.088]     ...future.conditions <- base::list()
[13:20:27.088]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.088]     if (FALSE) {
[13:20:27.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.088]     }
[13:20:27.088]     ...future.result <- base::tryCatch({
[13:20:27.088]         base::withCallingHandlers({
[13:20:27.088]             ...future.value <- base::withVisible(base::local({
[13:20:27.088]                 ...future.makeSendCondition <- local({
[13:20:27.088]                   sendCondition <- NULL
[13:20:27.088]                   function(frame = 1L) {
[13:20:27.088]                     if (is.function(sendCondition)) 
[13:20:27.088]                       return(sendCondition)
[13:20:27.088]                     ns <- getNamespace("parallel")
[13:20:27.088]                     if (exists("sendData", mode = "function", 
[13:20:27.088]                       envir = ns)) {
[13:20:27.088]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:27.088]                         envir = ns)
[13:20:27.088]                       envir <- sys.frame(frame)
[13:20:27.088]                       master <- NULL
[13:20:27.088]                       while (!identical(envir, .GlobalEnv) && 
[13:20:27.088]                         !identical(envir, emptyenv())) {
[13:20:27.088]                         if (exists("master", mode = "list", envir = envir, 
[13:20:27.088]                           inherits = FALSE)) {
[13:20:27.088]                           master <- get("master", mode = "list", 
[13:20:27.088]                             envir = envir, inherits = FALSE)
[13:20:27.088]                           if (inherits(master, c("SOCKnode", 
[13:20:27.088]                             "SOCK0node"))) {
[13:20:27.088]                             sendCondition <<- function(cond) {
[13:20:27.088]                               data <- list(type = "VALUE", value = cond, 
[13:20:27.088]                                 success = TRUE)
[13:20:27.088]                               parallel_sendData(master, data)
[13:20:27.088]                             }
[13:20:27.088]                             return(sendCondition)
[13:20:27.088]                           }
[13:20:27.088]                         }
[13:20:27.088]                         frame <- frame + 1L
[13:20:27.088]                         envir <- sys.frame(frame)
[13:20:27.088]                       }
[13:20:27.088]                     }
[13:20:27.088]                     sendCondition <<- function(cond) NULL
[13:20:27.088]                   }
[13:20:27.088]                 })
[13:20:27.088]                 withCallingHandlers({
[13:20:27.088]                   NULL
[13:20:27.088]                 }, immediateCondition = function(cond) {
[13:20:27.088]                   sendCondition <- ...future.makeSendCondition()
[13:20:27.088]                   sendCondition(cond)
[13:20:27.088]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.088]                   {
[13:20:27.088]                     inherits <- base::inherits
[13:20:27.088]                     invokeRestart <- base::invokeRestart
[13:20:27.088]                     is.null <- base::is.null
[13:20:27.088]                     muffled <- FALSE
[13:20:27.088]                     if (inherits(cond, "message")) {
[13:20:27.088]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.088]                       if (muffled) 
[13:20:27.088]                         invokeRestart("muffleMessage")
[13:20:27.088]                     }
[13:20:27.088]                     else if (inherits(cond, "warning")) {
[13:20:27.088]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.088]                       if (muffled) 
[13:20:27.088]                         invokeRestart("muffleWarning")
[13:20:27.088]                     }
[13:20:27.088]                     else if (inherits(cond, "condition")) {
[13:20:27.088]                       if (!is.null(pattern)) {
[13:20:27.088]                         computeRestarts <- base::computeRestarts
[13:20:27.088]                         grepl <- base::grepl
[13:20:27.088]                         restarts <- computeRestarts(cond)
[13:20:27.088]                         for (restart in restarts) {
[13:20:27.088]                           name <- restart$name
[13:20:27.088]                           if (is.null(name)) 
[13:20:27.088]                             next
[13:20:27.088]                           if (!grepl(pattern, name)) 
[13:20:27.088]                             next
[13:20:27.088]                           invokeRestart(restart)
[13:20:27.088]                           muffled <- TRUE
[13:20:27.088]                           break
[13:20:27.088]                         }
[13:20:27.088]                       }
[13:20:27.088]                     }
[13:20:27.088]                     invisible(muffled)
[13:20:27.088]                   }
[13:20:27.088]                   muffleCondition(cond)
[13:20:27.088]                 })
[13:20:27.088]             }))
[13:20:27.088]             future::FutureResult(value = ...future.value$value, 
[13:20:27.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.088]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.088]                     ...future.globalenv.names))
[13:20:27.088]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.088]         }, condition = base::local({
[13:20:27.088]             c <- base::c
[13:20:27.088]             inherits <- base::inherits
[13:20:27.088]             invokeRestart <- base::invokeRestart
[13:20:27.088]             length <- base::length
[13:20:27.088]             list <- base::list
[13:20:27.088]             seq.int <- base::seq.int
[13:20:27.088]             signalCondition <- base::signalCondition
[13:20:27.088]             sys.calls <- base::sys.calls
[13:20:27.088]             `[[` <- base::`[[`
[13:20:27.088]             `+` <- base::`+`
[13:20:27.088]             `<<-` <- base::`<<-`
[13:20:27.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.088]                   3L)]
[13:20:27.088]             }
[13:20:27.088]             function(cond) {
[13:20:27.088]                 is_error <- inherits(cond, "error")
[13:20:27.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.088]                   NULL)
[13:20:27.088]                 if (is_error) {
[13:20:27.088]                   sessionInformation <- function() {
[13:20:27.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.088]                       search = base::search(), system = base::Sys.info())
[13:20:27.088]                   }
[13:20:27.088]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.088]                     cond$call), session = sessionInformation(), 
[13:20:27.088]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.088]                   signalCondition(cond)
[13:20:27.088]                 }
[13:20:27.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.088]                 "immediateCondition"))) {
[13:20:27.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.088]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.088]                   if (TRUE && !signal) {
[13:20:27.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.088]                     {
[13:20:27.088]                       inherits <- base::inherits
[13:20:27.088]                       invokeRestart <- base::invokeRestart
[13:20:27.088]                       is.null <- base::is.null
[13:20:27.088]                       muffled <- FALSE
[13:20:27.088]                       if (inherits(cond, "message")) {
[13:20:27.088]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.088]                         if (muffled) 
[13:20:27.088]                           invokeRestart("muffleMessage")
[13:20:27.088]                       }
[13:20:27.088]                       else if (inherits(cond, "warning")) {
[13:20:27.088]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.088]                         if (muffled) 
[13:20:27.088]                           invokeRestart("muffleWarning")
[13:20:27.088]                       }
[13:20:27.088]                       else if (inherits(cond, "condition")) {
[13:20:27.088]                         if (!is.null(pattern)) {
[13:20:27.088]                           computeRestarts <- base::computeRestarts
[13:20:27.088]                           grepl <- base::grepl
[13:20:27.088]                           restarts <- computeRestarts(cond)
[13:20:27.088]                           for (restart in restarts) {
[13:20:27.088]                             name <- restart$name
[13:20:27.088]                             if (is.null(name)) 
[13:20:27.088]                               next
[13:20:27.088]                             if (!grepl(pattern, name)) 
[13:20:27.088]                               next
[13:20:27.088]                             invokeRestart(restart)
[13:20:27.088]                             muffled <- TRUE
[13:20:27.088]                             break
[13:20:27.088]                           }
[13:20:27.088]                         }
[13:20:27.088]                       }
[13:20:27.088]                       invisible(muffled)
[13:20:27.088]                     }
[13:20:27.088]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.088]                   }
[13:20:27.088]                 }
[13:20:27.088]                 else {
[13:20:27.088]                   if (TRUE) {
[13:20:27.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.088]                     {
[13:20:27.088]                       inherits <- base::inherits
[13:20:27.088]                       invokeRestart <- base::invokeRestart
[13:20:27.088]                       is.null <- base::is.null
[13:20:27.088]                       muffled <- FALSE
[13:20:27.088]                       if (inherits(cond, "message")) {
[13:20:27.088]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.088]                         if (muffled) 
[13:20:27.088]                           invokeRestart("muffleMessage")
[13:20:27.088]                       }
[13:20:27.088]                       else if (inherits(cond, "warning")) {
[13:20:27.088]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.088]                         if (muffled) 
[13:20:27.088]                           invokeRestart("muffleWarning")
[13:20:27.088]                       }
[13:20:27.088]                       else if (inherits(cond, "condition")) {
[13:20:27.088]                         if (!is.null(pattern)) {
[13:20:27.088]                           computeRestarts <- base::computeRestarts
[13:20:27.088]                           grepl <- base::grepl
[13:20:27.088]                           restarts <- computeRestarts(cond)
[13:20:27.088]                           for (restart in restarts) {
[13:20:27.088]                             name <- restart$name
[13:20:27.088]                             if (is.null(name)) 
[13:20:27.088]                               next
[13:20:27.088]                             if (!grepl(pattern, name)) 
[13:20:27.088]                               next
[13:20:27.088]                             invokeRestart(restart)
[13:20:27.088]                             muffled <- TRUE
[13:20:27.088]                             break
[13:20:27.088]                           }
[13:20:27.088]                         }
[13:20:27.088]                       }
[13:20:27.088]                       invisible(muffled)
[13:20:27.088]                     }
[13:20:27.088]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.088]                   }
[13:20:27.088]                 }
[13:20:27.088]             }
[13:20:27.088]         }))
[13:20:27.088]     }, error = function(ex) {
[13:20:27.088]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.088]                 ...future.rng), started = ...future.startTime, 
[13:20:27.088]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.088]             version = "1.8"), class = "FutureResult")
[13:20:27.088]     }, finally = {
[13:20:27.088]         if (!identical(...future.workdir, getwd())) 
[13:20:27.088]             setwd(...future.workdir)
[13:20:27.088]         {
[13:20:27.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.088]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.088]             }
[13:20:27.088]             base::options(...future.oldOptions)
[13:20:27.088]             if (.Platform$OS.type == "windows") {
[13:20:27.088]                 old_names <- names(...future.oldEnvVars)
[13:20:27.088]                 envs <- base::Sys.getenv()
[13:20:27.088]                 names <- names(envs)
[13:20:27.088]                 common <- intersect(names, old_names)
[13:20:27.088]                 added <- setdiff(names, old_names)
[13:20:27.088]                 removed <- setdiff(old_names, names)
[13:20:27.088]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.088]                   envs[common]]
[13:20:27.088]                 NAMES <- toupper(changed)
[13:20:27.088]                 args <- list()
[13:20:27.088]                 for (kk in seq_along(NAMES)) {
[13:20:27.088]                   name <- changed[[kk]]
[13:20:27.088]                   NAME <- NAMES[[kk]]
[13:20:27.088]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.088]                     next
[13:20:27.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.088]                 }
[13:20:27.088]                 NAMES <- toupper(added)
[13:20:27.088]                 for (kk in seq_along(NAMES)) {
[13:20:27.088]                   name <- added[[kk]]
[13:20:27.088]                   NAME <- NAMES[[kk]]
[13:20:27.088]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.088]                     next
[13:20:27.088]                   args[[name]] <- ""
[13:20:27.088]                 }
[13:20:27.088]                 NAMES <- toupper(removed)
[13:20:27.088]                 for (kk in seq_along(NAMES)) {
[13:20:27.088]                   name <- removed[[kk]]
[13:20:27.088]                   NAME <- NAMES[[kk]]
[13:20:27.088]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.088]                     next
[13:20:27.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.088]                 }
[13:20:27.088]                 if (length(args) > 0) 
[13:20:27.088]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.088]             }
[13:20:27.088]             else {
[13:20:27.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.088]             }
[13:20:27.088]             {
[13:20:27.088]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.088]                   0L) {
[13:20:27.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.088]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.088]                   base::options(opts)
[13:20:27.088]                 }
[13:20:27.088]                 {
[13:20:27.088]                   {
[13:20:27.088]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.088]                     NULL
[13:20:27.088]                   }
[13:20:27.088]                   options(future.plan = NULL)
[13:20:27.088]                   if (is.na(NA_character_)) 
[13:20:27.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.088]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:27.088]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:27.088]                     envir = parent.frame()) 
[13:20:27.088]                   {
[13:20:27.088]                     if (is.function(workers)) 
[13:20:27.088]                       workers <- workers()
[13:20:27.088]                     workers <- structure(as.integer(workers), 
[13:20:27.088]                       class = class(workers))
[13:20:27.088]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:27.088]                       workers >= 1)
[13:20:27.088]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:27.088]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:27.088]                     }
[13:20:27.088]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:27.088]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:27.088]                       envir = envir)
[13:20:27.088]                     if (!future$lazy) 
[13:20:27.088]                       future <- run(future)
[13:20:27.088]                     invisible(future)
[13:20:27.088]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.088]                 }
[13:20:27.088]             }
[13:20:27.088]         }
[13:20:27.088]     })
[13:20:27.088]     if (TRUE) {
[13:20:27.088]         base::sink(type = "output", split = FALSE)
[13:20:27.088]         if (TRUE) {
[13:20:27.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.088]         }
[13:20:27.088]         else {
[13:20:27.088]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.088]         }
[13:20:27.088]         base::close(...future.stdout)
[13:20:27.088]         ...future.stdout <- NULL
[13:20:27.088]     }
[13:20:27.088]     ...future.result$conditions <- ...future.conditions
[13:20:27.088]     ...future.result$finished <- base::Sys.time()
[13:20:27.088]     ...future.result
[13:20:27.088] }
[13:20:27.091] MultisessionFuture started
[13:20:27.091] - Launch lazy future ... done
[13:20:27.091] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x556599a81988> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659cb60c10> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x556599a81988> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659cb60c10> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:27.119] resolve() on list ...
[13:20:27.120]  recursive: 0
[13:20:27.120]  length: 6
[13:20:27.120]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:27.120] signalConditionsASAP(numeric, pos=1) ...
[13:20:27.120] - nx: 6
[13:20:27.120] - relay: TRUE
[13:20:27.120] - stdout: TRUE
[13:20:27.120] - signal: TRUE
[13:20:27.120] - resignal: FALSE
[13:20:27.120] - force: TRUE
[13:20:27.120] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.121] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.121]  - until=2
[13:20:27.121]  - relaying element #2
[13:20:27.121] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.121] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.121] signalConditionsASAP(NULL, pos=1) ... done
[13:20:27.121]  length: 5 (resolved future 1)
[13:20:27.122] receiveMessageFromWorker() for ClusterFuture ...
[13:20:27.122] - Validating connection of MultisessionFuture
[13:20:27.122] - received message: FutureResult
[13:20:27.122] - Received FutureResult
[13:20:27.122] - Erased future from FutureRegistry
[13:20:27.122] result() for ClusterFuture ...
[13:20:27.122] - result already collected: FutureResult
[13:20:27.122] result() for ClusterFuture ... done
[13:20:27.123] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:27.123] Future #2
[13:20:27.123] result() for ClusterFuture ...
[13:20:27.123] - result already collected: FutureResult
[13:20:27.123] result() for ClusterFuture ... done
[13:20:27.123] result() for ClusterFuture ...
[13:20:27.123] - result already collected: FutureResult
[13:20:27.123] result() for ClusterFuture ... done
[13:20:27.123] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:27.123] - nx: 6
[13:20:27.123] - relay: TRUE
[13:20:27.124] - stdout: TRUE
[13:20:27.124] - signal: TRUE
[13:20:27.124] - resignal: FALSE
[13:20:27.124] - force: TRUE
[13:20:27.124] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.124] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.124]  - until=2
[13:20:27.124]  - relaying element #2
[13:20:27.124] result() for ClusterFuture ...
[13:20:27.124] - result already collected: FutureResult
[13:20:27.124] result() for ClusterFuture ... done
[13:20:27.124] result() for ClusterFuture ...
[13:20:27.125] - result already collected: FutureResult
[13:20:27.125] result() for ClusterFuture ... done
[13:20:27.125] result() for ClusterFuture ...
[13:20:27.125] - result already collected: FutureResult
[13:20:27.125] result() for ClusterFuture ... done
[13:20:27.125] result() for ClusterFuture ...
[13:20:27.125] - result already collected: FutureResult
[13:20:27.125] result() for ClusterFuture ... done
[13:20:27.125] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.125] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.126] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:27.126]  length: 4 (resolved future 2)
[13:20:27.136] signalConditionsASAP(NULL, pos=4) ...
[13:20:27.136] - nx: 6
[13:20:27.136] - relay: TRUE
[13:20:27.137] - stdout: TRUE
[13:20:27.137] - signal: TRUE
[13:20:27.137] - resignal: FALSE
[13:20:27.137] - force: TRUE
[13:20:27.137] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.137] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.137]  - until=5
[13:20:27.137]  - relaying element #3
[13:20:27.137]  - relaying element #5
[13:20:27.137] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:20:27.138] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.138] signalConditionsASAP(NULL, pos=4) ... done
[13:20:27.138]  length: 3 (resolved future 4)
[13:20:27.138] signalConditionsASAP(NULL, pos=5) ...
[13:20:27.138] - nx: 6
[13:20:27.138] - relay: TRUE
[13:20:27.138] - stdout: TRUE
[13:20:27.138] - signal: TRUE
[13:20:27.138] - resignal: FALSE
[13:20:27.138] - force: TRUE
[13:20:27.138] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:20:27.139] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.139]  - until=6
[13:20:27.139]  - relaying element #3
[13:20:27.139]  - relaying element #6
[13:20:27.139] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:20:27.139] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.139] signalConditionsASAP(NULL, pos=5) ... done
[13:20:27.139]  length: 2 (resolved future 5)
[13:20:27.139] signalConditionsASAP(numeric, pos=6) ...
[13:20:27.139] - nx: 6
[13:20:27.139] - relay: TRUE
[13:20:27.140] - stdout: TRUE
[13:20:27.140] - signal: TRUE
[13:20:27.140] - resignal: FALSE
[13:20:27.140] - force: TRUE
[13:20:27.140] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:20:27.140] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.140]  - until=6
[13:20:27.140]  - relaying element #3
[13:20:27.140] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:20:27.140] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.140] signalConditionsASAP(NULL, pos=6) ... done
[13:20:27.140]  length: 1 (resolved future 6)
[13:20:27.151] receiveMessageFromWorker() for ClusterFuture ...
[13:20:27.151] - Validating connection of MultisessionFuture
[13:20:27.151] - received message: FutureResult
[13:20:27.152] - Received FutureResult
[13:20:27.152] - Erased future from FutureRegistry
[13:20:27.152] result() for ClusterFuture ...
[13:20:27.152] - result already collected: FutureResult
[13:20:27.152] result() for ClusterFuture ... done
[13:20:27.152] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:27.152] Future #3
[13:20:27.152] result() for ClusterFuture ...
[13:20:27.152] - result already collected: FutureResult
[13:20:27.152] result() for ClusterFuture ... done
[13:20:27.153] result() for ClusterFuture ...
[13:20:27.153] - result already collected: FutureResult
[13:20:27.153] result() for ClusterFuture ... done
[13:20:27.153] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:27.153] - nx: 6
[13:20:27.153] - relay: TRUE
[13:20:27.153] - stdout: TRUE
[13:20:27.153] - signal: TRUE
[13:20:27.153] - resignal: FALSE
[13:20:27.153] - force: TRUE
[13:20:27.153] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:20:27.154] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.154]  - until=6
[13:20:27.154]  - relaying element #3
[13:20:27.154] result() for ClusterFuture ...
[13:20:27.154] - result already collected: FutureResult
[13:20:27.154] result() for ClusterFuture ... done
[13:20:27.154] result() for ClusterFuture ...
[13:20:27.154] - result already collected: FutureResult
[13:20:27.154] result() for ClusterFuture ... done
[13:20:27.154] result() for ClusterFuture ...
[13:20:27.154] - result already collected: FutureResult
[13:20:27.155] result() for ClusterFuture ... done
[13:20:27.155] result() for ClusterFuture ...
[13:20:27.155] - result already collected: FutureResult
[13:20:27.155] result() for ClusterFuture ... done
[13:20:27.155] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:27.155] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.155] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:27.155]  length: 0 (resolved future 3)
[13:20:27.155] Relaying remaining futures
[13:20:27.155] signalConditionsASAP(NULL, pos=0) ...
[13:20:27.155] - nx: 6
[13:20:27.156] - relay: TRUE
[13:20:27.156] - stdout: TRUE
[13:20:27.156] - signal: TRUE
[13:20:27.156] - resignal: FALSE
[13:20:27.156] - force: TRUE
[13:20:27.156] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:27.156] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:27.156] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:27.156] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.156] signalConditionsASAP(NULL, pos=0) ... done
[13:20:27.156] resolve() on list ... DONE
[13:20:27.157] result() for ClusterFuture ...
[13:20:27.157] - result already collected: FutureResult
[13:20:27.157] result() for ClusterFuture ... done
[13:20:27.157] result() for ClusterFuture ...
[13:20:27.157] - result already collected: FutureResult
[13:20:27.157] result() for ClusterFuture ... done
[13:20:27.157] result() for ClusterFuture ...
[13:20:27.157] - result already collected: FutureResult
[13:20:27.157] result() for ClusterFuture ... done
[13:20:27.157] result() for ClusterFuture ...
[13:20:27.157] - result already collected: FutureResult
[13:20:27.158] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:20:27.161] getGlobalsAndPackages() ...
[13:20:27.163] Searching for globals...
[13:20:27.163] 
[13:20:27.164] Searching for globals ... DONE
[13:20:27.164] - globals: [0] <none>
[13:20:27.164] getGlobalsAndPackages() ... DONE
[13:20:27.164] run() for ‘Future’ ...
[13:20:27.164] - state: ‘created’
[13:20:27.164] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.179] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.179] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:27.179]   - Field: ‘node’
[13:20:27.179]   - Field: ‘label’
[13:20:27.179]   - Field: ‘local’
[13:20:27.179]   - Field: ‘owner’
[13:20:27.179]   - Field: ‘envir’
[13:20:27.180]   - Field: ‘workers’
[13:20:27.180]   - Field: ‘packages’
[13:20:27.180]   - Field: ‘gc’
[13:20:27.180]   - Field: ‘conditions’
[13:20:27.180]   - Field: ‘persistent’
[13:20:27.180]   - Field: ‘expr’
[13:20:27.180]   - Field: ‘uuid’
[13:20:27.180]   - Field: ‘seed’
[13:20:27.180]   - Field: ‘version’
[13:20:27.180]   - Field: ‘result’
[13:20:27.180]   - Field: ‘asynchronous’
[13:20:27.180]   - Field: ‘calls’
[13:20:27.181]   - Field: ‘globals’
[13:20:27.181]   - Field: ‘stdout’
[13:20:27.181]   - Field: ‘earlySignal’
[13:20:27.181]   - Field: ‘lazy’
[13:20:27.181]   - Field: ‘state’
[13:20:27.181] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:27.181] - Launch lazy future ...
[13:20:27.181] Packages needed by the future expression (n = 0): <none>
[13:20:27.182] Packages needed by future strategies (n = 0): <none>
[13:20:27.182] {
[13:20:27.182]     {
[13:20:27.182]         {
[13:20:27.182]             ...future.startTime <- base::Sys.time()
[13:20:27.182]             {
[13:20:27.182]                 {
[13:20:27.182]                   {
[13:20:27.182]                     {
[13:20:27.182]                       base::local({
[13:20:27.182]                         has_future <- base::requireNamespace("future", 
[13:20:27.182]                           quietly = TRUE)
[13:20:27.182]                         if (has_future) {
[13:20:27.182]                           ns <- base::getNamespace("future")
[13:20:27.182]                           version <- ns[[".package"]][["version"]]
[13:20:27.182]                           if (is.null(version)) 
[13:20:27.182]                             version <- utils::packageVersion("future")
[13:20:27.182]                         }
[13:20:27.182]                         else {
[13:20:27.182]                           version <- NULL
[13:20:27.182]                         }
[13:20:27.182]                         if (!has_future || version < "1.8.0") {
[13:20:27.182]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.182]                             "", base::R.version$version.string), 
[13:20:27.182]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.182]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.182]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.182]                               "release", "version")], collapse = " "), 
[13:20:27.182]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.182]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.182]                             info)
[13:20:27.182]                           info <- base::paste(info, collapse = "; ")
[13:20:27.182]                           if (!has_future) {
[13:20:27.182]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.182]                               info)
[13:20:27.182]                           }
[13:20:27.182]                           else {
[13:20:27.182]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.182]                               info, version)
[13:20:27.182]                           }
[13:20:27.182]                           base::stop(msg)
[13:20:27.182]                         }
[13:20:27.182]                       })
[13:20:27.182]                     }
[13:20:27.182]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.182]                     base::options(mc.cores = 1L)
[13:20:27.182]                   }
[13:20:27.182]                   options(future.plan = NULL)
[13:20:27.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.182]                 }
[13:20:27.182]                 ...future.workdir <- getwd()
[13:20:27.182]             }
[13:20:27.182]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.182]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.182]         }
[13:20:27.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.182]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.182]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.182]             base::names(...future.oldOptions))
[13:20:27.182]     }
[13:20:27.182]     if (FALSE) {
[13:20:27.182]     }
[13:20:27.182]     else {
[13:20:27.182]         if (TRUE) {
[13:20:27.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.182]                 open = "w")
[13:20:27.182]         }
[13:20:27.182]         else {
[13:20:27.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.182]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.182]         }
[13:20:27.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.182]             base::sink(type = "output", split = FALSE)
[13:20:27.182]             base::close(...future.stdout)
[13:20:27.182]         }, add = TRUE)
[13:20:27.182]     }
[13:20:27.182]     ...future.frame <- base::sys.nframe()
[13:20:27.182]     ...future.conditions <- base::list()
[13:20:27.182]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.182]     if (FALSE) {
[13:20:27.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.182]     }
[13:20:27.182]     ...future.result <- base::tryCatch({
[13:20:27.182]         base::withCallingHandlers({
[13:20:27.182]             ...future.value <- base::withVisible(base::local({
[13:20:27.182]                 ...future.makeSendCondition <- local({
[13:20:27.182]                   sendCondition <- NULL
[13:20:27.182]                   function(frame = 1L) {
[13:20:27.182]                     if (is.function(sendCondition)) 
[13:20:27.182]                       return(sendCondition)
[13:20:27.182]                     ns <- getNamespace("parallel")
[13:20:27.182]                     if (exists("sendData", mode = "function", 
[13:20:27.182]                       envir = ns)) {
[13:20:27.182]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:27.182]                         envir = ns)
[13:20:27.182]                       envir <- sys.frame(frame)
[13:20:27.182]                       master <- NULL
[13:20:27.182]                       while (!identical(envir, .GlobalEnv) && 
[13:20:27.182]                         !identical(envir, emptyenv())) {
[13:20:27.182]                         if (exists("master", mode = "list", envir = envir, 
[13:20:27.182]                           inherits = FALSE)) {
[13:20:27.182]                           master <- get("master", mode = "list", 
[13:20:27.182]                             envir = envir, inherits = FALSE)
[13:20:27.182]                           if (inherits(master, c("SOCKnode", 
[13:20:27.182]                             "SOCK0node"))) {
[13:20:27.182]                             sendCondition <<- function(cond) {
[13:20:27.182]                               data <- list(type = "VALUE", value = cond, 
[13:20:27.182]                                 success = TRUE)
[13:20:27.182]                               parallel_sendData(master, data)
[13:20:27.182]                             }
[13:20:27.182]                             return(sendCondition)
[13:20:27.182]                           }
[13:20:27.182]                         }
[13:20:27.182]                         frame <- frame + 1L
[13:20:27.182]                         envir <- sys.frame(frame)
[13:20:27.182]                       }
[13:20:27.182]                     }
[13:20:27.182]                     sendCondition <<- function(cond) NULL
[13:20:27.182]                   }
[13:20:27.182]                 })
[13:20:27.182]                 withCallingHandlers({
[13:20:27.182]                   2
[13:20:27.182]                 }, immediateCondition = function(cond) {
[13:20:27.182]                   sendCondition <- ...future.makeSendCondition()
[13:20:27.182]                   sendCondition(cond)
[13:20:27.182]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.182]                   {
[13:20:27.182]                     inherits <- base::inherits
[13:20:27.182]                     invokeRestart <- base::invokeRestart
[13:20:27.182]                     is.null <- base::is.null
[13:20:27.182]                     muffled <- FALSE
[13:20:27.182]                     if (inherits(cond, "message")) {
[13:20:27.182]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.182]                       if (muffled) 
[13:20:27.182]                         invokeRestart("muffleMessage")
[13:20:27.182]                     }
[13:20:27.182]                     else if (inherits(cond, "warning")) {
[13:20:27.182]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.182]                       if (muffled) 
[13:20:27.182]                         invokeRestart("muffleWarning")
[13:20:27.182]                     }
[13:20:27.182]                     else if (inherits(cond, "condition")) {
[13:20:27.182]                       if (!is.null(pattern)) {
[13:20:27.182]                         computeRestarts <- base::computeRestarts
[13:20:27.182]                         grepl <- base::grepl
[13:20:27.182]                         restarts <- computeRestarts(cond)
[13:20:27.182]                         for (restart in restarts) {
[13:20:27.182]                           name <- restart$name
[13:20:27.182]                           if (is.null(name)) 
[13:20:27.182]                             next
[13:20:27.182]                           if (!grepl(pattern, name)) 
[13:20:27.182]                             next
[13:20:27.182]                           invokeRestart(restart)
[13:20:27.182]                           muffled <- TRUE
[13:20:27.182]                           break
[13:20:27.182]                         }
[13:20:27.182]                       }
[13:20:27.182]                     }
[13:20:27.182]                     invisible(muffled)
[13:20:27.182]                   }
[13:20:27.182]                   muffleCondition(cond)
[13:20:27.182]                 })
[13:20:27.182]             }))
[13:20:27.182]             future::FutureResult(value = ...future.value$value, 
[13:20:27.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.182]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.182]                     ...future.globalenv.names))
[13:20:27.182]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.182]         }, condition = base::local({
[13:20:27.182]             c <- base::c
[13:20:27.182]             inherits <- base::inherits
[13:20:27.182]             invokeRestart <- base::invokeRestart
[13:20:27.182]             length <- base::length
[13:20:27.182]             list <- base::list
[13:20:27.182]             seq.int <- base::seq.int
[13:20:27.182]             signalCondition <- base::signalCondition
[13:20:27.182]             sys.calls <- base::sys.calls
[13:20:27.182]             `[[` <- base::`[[`
[13:20:27.182]             `+` <- base::`+`
[13:20:27.182]             `<<-` <- base::`<<-`
[13:20:27.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.182]                   3L)]
[13:20:27.182]             }
[13:20:27.182]             function(cond) {
[13:20:27.182]                 is_error <- inherits(cond, "error")
[13:20:27.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.182]                   NULL)
[13:20:27.182]                 if (is_error) {
[13:20:27.182]                   sessionInformation <- function() {
[13:20:27.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.182]                       search = base::search(), system = base::Sys.info())
[13:20:27.182]                   }
[13:20:27.182]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.182]                     cond$call), session = sessionInformation(), 
[13:20:27.182]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.182]                   signalCondition(cond)
[13:20:27.182]                 }
[13:20:27.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.182]                 "immediateCondition"))) {
[13:20:27.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.182]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.182]                   if (TRUE && !signal) {
[13:20:27.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.182]                     {
[13:20:27.182]                       inherits <- base::inherits
[13:20:27.182]                       invokeRestart <- base::invokeRestart
[13:20:27.182]                       is.null <- base::is.null
[13:20:27.182]                       muffled <- FALSE
[13:20:27.182]                       if (inherits(cond, "message")) {
[13:20:27.182]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.182]                         if (muffled) 
[13:20:27.182]                           invokeRestart("muffleMessage")
[13:20:27.182]                       }
[13:20:27.182]                       else if (inherits(cond, "warning")) {
[13:20:27.182]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.182]                         if (muffled) 
[13:20:27.182]                           invokeRestart("muffleWarning")
[13:20:27.182]                       }
[13:20:27.182]                       else if (inherits(cond, "condition")) {
[13:20:27.182]                         if (!is.null(pattern)) {
[13:20:27.182]                           computeRestarts <- base::computeRestarts
[13:20:27.182]                           grepl <- base::grepl
[13:20:27.182]                           restarts <- computeRestarts(cond)
[13:20:27.182]                           for (restart in restarts) {
[13:20:27.182]                             name <- restart$name
[13:20:27.182]                             if (is.null(name)) 
[13:20:27.182]                               next
[13:20:27.182]                             if (!grepl(pattern, name)) 
[13:20:27.182]                               next
[13:20:27.182]                             invokeRestart(restart)
[13:20:27.182]                             muffled <- TRUE
[13:20:27.182]                             break
[13:20:27.182]                           }
[13:20:27.182]                         }
[13:20:27.182]                       }
[13:20:27.182]                       invisible(muffled)
[13:20:27.182]                     }
[13:20:27.182]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.182]                   }
[13:20:27.182]                 }
[13:20:27.182]                 else {
[13:20:27.182]                   if (TRUE) {
[13:20:27.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.182]                     {
[13:20:27.182]                       inherits <- base::inherits
[13:20:27.182]                       invokeRestart <- base::invokeRestart
[13:20:27.182]                       is.null <- base::is.null
[13:20:27.182]                       muffled <- FALSE
[13:20:27.182]                       if (inherits(cond, "message")) {
[13:20:27.182]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.182]                         if (muffled) 
[13:20:27.182]                           invokeRestart("muffleMessage")
[13:20:27.182]                       }
[13:20:27.182]                       else if (inherits(cond, "warning")) {
[13:20:27.182]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.182]                         if (muffled) 
[13:20:27.182]                           invokeRestart("muffleWarning")
[13:20:27.182]                       }
[13:20:27.182]                       else if (inherits(cond, "condition")) {
[13:20:27.182]                         if (!is.null(pattern)) {
[13:20:27.182]                           computeRestarts <- base::computeRestarts
[13:20:27.182]                           grepl <- base::grepl
[13:20:27.182]                           restarts <- computeRestarts(cond)
[13:20:27.182]                           for (restart in restarts) {
[13:20:27.182]                             name <- restart$name
[13:20:27.182]                             if (is.null(name)) 
[13:20:27.182]                               next
[13:20:27.182]                             if (!grepl(pattern, name)) 
[13:20:27.182]                               next
[13:20:27.182]                             invokeRestart(restart)
[13:20:27.182]                             muffled <- TRUE
[13:20:27.182]                             break
[13:20:27.182]                           }
[13:20:27.182]                         }
[13:20:27.182]                       }
[13:20:27.182]                       invisible(muffled)
[13:20:27.182]                     }
[13:20:27.182]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.182]                   }
[13:20:27.182]                 }
[13:20:27.182]             }
[13:20:27.182]         }))
[13:20:27.182]     }, error = function(ex) {
[13:20:27.182]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.182]                 ...future.rng), started = ...future.startTime, 
[13:20:27.182]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.182]             version = "1.8"), class = "FutureResult")
[13:20:27.182]     }, finally = {
[13:20:27.182]         if (!identical(...future.workdir, getwd())) 
[13:20:27.182]             setwd(...future.workdir)
[13:20:27.182]         {
[13:20:27.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.182]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.182]             }
[13:20:27.182]             base::options(...future.oldOptions)
[13:20:27.182]             if (.Platform$OS.type == "windows") {
[13:20:27.182]                 old_names <- names(...future.oldEnvVars)
[13:20:27.182]                 envs <- base::Sys.getenv()
[13:20:27.182]                 names <- names(envs)
[13:20:27.182]                 common <- intersect(names, old_names)
[13:20:27.182]                 added <- setdiff(names, old_names)
[13:20:27.182]                 removed <- setdiff(old_names, names)
[13:20:27.182]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.182]                   envs[common]]
[13:20:27.182]                 NAMES <- toupper(changed)
[13:20:27.182]                 args <- list()
[13:20:27.182]                 for (kk in seq_along(NAMES)) {
[13:20:27.182]                   name <- changed[[kk]]
[13:20:27.182]                   NAME <- NAMES[[kk]]
[13:20:27.182]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.182]                     next
[13:20:27.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.182]                 }
[13:20:27.182]                 NAMES <- toupper(added)
[13:20:27.182]                 for (kk in seq_along(NAMES)) {
[13:20:27.182]                   name <- added[[kk]]
[13:20:27.182]                   NAME <- NAMES[[kk]]
[13:20:27.182]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.182]                     next
[13:20:27.182]                   args[[name]] <- ""
[13:20:27.182]                 }
[13:20:27.182]                 NAMES <- toupper(removed)
[13:20:27.182]                 for (kk in seq_along(NAMES)) {
[13:20:27.182]                   name <- removed[[kk]]
[13:20:27.182]                   NAME <- NAMES[[kk]]
[13:20:27.182]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.182]                     next
[13:20:27.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.182]                 }
[13:20:27.182]                 if (length(args) > 0) 
[13:20:27.182]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.182]             }
[13:20:27.182]             else {
[13:20:27.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.182]             }
[13:20:27.182]             {
[13:20:27.182]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.182]                   0L) {
[13:20:27.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.182]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.182]                   base::options(opts)
[13:20:27.182]                 }
[13:20:27.182]                 {
[13:20:27.182]                   {
[13:20:27.182]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.182]                     NULL
[13:20:27.182]                   }
[13:20:27.182]                   options(future.plan = NULL)
[13:20:27.182]                   if (is.na(NA_character_)) 
[13:20:27.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.182]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:27.182]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:27.182]                     envir = parent.frame()) 
[13:20:27.182]                   {
[13:20:27.182]                     if (is.function(workers)) 
[13:20:27.182]                       workers <- workers()
[13:20:27.182]                     workers <- structure(as.integer(workers), 
[13:20:27.182]                       class = class(workers))
[13:20:27.182]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:27.182]                       workers >= 1)
[13:20:27.182]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:27.182]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:27.182]                     }
[13:20:27.182]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:27.182]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:27.182]                       envir = envir)
[13:20:27.182]                     if (!future$lazy) 
[13:20:27.182]                       future <- run(future)
[13:20:27.182]                     invisible(future)
[13:20:27.182]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.182]                 }
[13:20:27.182]             }
[13:20:27.182]         }
[13:20:27.182]     })
[13:20:27.182]     if (TRUE) {
[13:20:27.182]         base::sink(type = "output", split = FALSE)
[13:20:27.182]         if (TRUE) {
[13:20:27.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.182]         }
[13:20:27.182]         else {
[13:20:27.182]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.182]         }
[13:20:27.182]         base::close(...future.stdout)
[13:20:27.182]         ...future.stdout <- NULL
[13:20:27.182]     }
[13:20:27.182]     ...future.result$conditions <- ...future.conditions
[13:20:27.182]     ...future.result$finished <- base::Sys.time()
[13:20:27.182]     ...future.result
[13:20:27.182] }
[13:20:27.185] MultisessionFuture started
[13:20:27.185] - Launch lazy future ... done
[13:20:27.185] run() for ‘MultisessionFuture’ ... done
[13:20:27.185] getGlobalsAndPackages() ...
[13:20:27.186] Searching for globals...
[13:20:27.186] 
[13:20:27.186] Searching for globals ... DONE
[13:20:27.186] - globals: [0] <none>
[13:20:27.186] getGlobalsAndPackages() ... DONE
[13:20:27.186] run() for ‘Future’ ...
[13:20:27.186] - state: ‘created’
[13:20:27.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.201] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:27.201]   - Field: ‘node’
[13:20:27.201]   - Field: ‘label’
[13:20:27.201]   - Field: ‘local’
[13:20:27.201]   - Field: ‘owner’
[13:20:27.201]   - Field: ‘envir’
[13:20:27.201]   - Field: ‘workers’
[13:20:27.201]   - Field: ‘packages’
[13:20:27.201]   - Field: ‘gc’
[13:20:27.202]   - Field: ‘conditions’
[13:20:27.202]   - Field: ‘persistent’
[13:20:27.202]   - Field: ‘expr’
[13:20:27.202]   - Field: ‘uuid’
[13:20:27.202]   - Field: ‘seed’
[13:20:27.202]   - Field: ‘version’
[13:20:27.202]   - Field: ‘result’
[13:20:27.202]   - Field: ‘asynchronous’
[13:20:27.202]   - Field: ‘calls’
[13:20:27.202]   - Field: ‘globals’
[13:20:27.202]   - Field: ‘stdout’
[13:20:27.203]   - Field: ‘earlySignal’
[13:20:27.203]   - Field: ‘lazy’
[13:20:27.203]   - Field: ‘state’
[13:20:27.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:27.203] - Launch lazy future ...
[13:20:27.203] Packages needed by the future expression (n = 0): <none>
[13:20:27.203] Packages needed by future strategies (n = 0): <none>
[13:20:27.204] {
[13:20:27.204]     {
[13:20:27.204]         {
[13:20:27.204]             ...future.startTime <- base::Sys.time()
[13:20:27.204]             {
[13:20:27.204]                 {
[13:20:27.204]                   {
[13:20:27.204]                     {
[13:20:27.204]                       base::local({
[13:20:27.204]                         has_future <- base::requireNamespace("future", 
[13:20:27.204]                           quietly = TRUE)
[13:20:27.204]                         if (has_future) {
[13:20:27.204]                           ns <- base::getNamespace("future")
[13:20:27.204]                           version <- ns[[".package"]][["version"]]
[13:20:27.204]                           if (is.null(version)) 
[13:20:27.204]                             version <- utils::packageVersion("future")
[13:20:27.204]                         }
[13:20:27.204]                         else {
[13:20:27.204]                           version <- NULL
[13:20:27.204]                         }
[13:20:27.204]                         if (!has_future || version < "1.8.0") {
[13:20:27.204]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.204]                             "", base::R.version$version.string), 
[13:20:27.204]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.204]                               "release", "version")], collapse = " "), 
[13:20:27.204]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.204]                             info)
[13:20:27.204]                           info <- base::paste(info, collapse = "; ")
[13:20:27.204]                           if (!has_future) {
[13:20:27.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.204]                               info)
[13:20:27.204]                           }
[13:20:27.204]                           else {
[13:20:27.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.204]                               info, version)
[13:20:27.204]                           }
[13:20:27.204]                           base::stop(msg)
[13:20:27.204]                         }
[13:20:27.204]                       })
[13:20:27.204]                     }
[13:20:27.204]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.204]                     base::options(mc.cores = 1L)
[13:20:27.204]                   }
[13:20:27.204]                   options(future.plan = NULL)
[13:20:27.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.204]                 }
[13:20:27.204]                 ...future.workdir <- getwd()
[13:20:27.204]             }
[13:20:27.204]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.204]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.204]         }
[13:20:27.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.204]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.204]             base::names(...future.oldOptions))
[13:20:27.204]     }
[13:20:27.204]     if (FALSE) {
[13:20:27.204]     }
[13:20:27.204]     else {
[13:20:27.204]         if (TRUE) {
[13:20:27.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.204]                 open = "w")
[13:20:27.204]         }
[13:20:27.204]         else {
[13:20:27.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.204]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.204]         }
[13:20:27.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.204]             base::sink(type = "output", split = FALSE)
[13:20:27.204]             base::close(...future.stdout)
[13:20:27.204]         }, add = TRUE)
[13:20:27.204]     }
[13:20:27.204]     ...future.frame <- base::sys.nframe()
[13:20:27.204]     ...future.conditions <- base::list()
[13:20:27.204]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.204]     if (FALSE) {
[13:20:27.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.204]     }
[13:20:27.204]     ...future.result <- base::tryCatch({
[13:20:27.204]         base::withCallingHandlers({
[13:20:27.204]             ...future.value <- base::withVisible(base::local({
[13:20:27.204]                 ...future.makeSendCondition <- local({
[13:20:27.204]                   sendCondition <- NULL
[13:20:27.204]                   function(frame = 1L) {
[13:20:27.204]                     if (is.function(sendCondition)) 
[13:20:27.204]                       return(sendCondition)
[13:20:27.204]                     ns <- getNamespace("parallel")
[13:20:27.204]                     if (exists("sendData", mode = "function", 
[13:20:27.204]                       envir = ns)) {
[13:20:27.204]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:27.204]                         envir = ns)
[13:20:27.204]                       envir <- sys.frame(frame)
[13:20:27.204]                       master <- NULL
[13:20:27.204]                       while (!identical(envir, .GlobalEnv) && 
[13:20:27.204]                         !identical(envir, emptyenv())) {
[13:20:27.204]                         if (exists("master", mode = "list", envir = envir, 
[13:20:27.204]                           inherits = FALSE)) {
[13:20:27.204]                           master <- get("master", mode = "list", 
[13:20:27.204]                             envir = envir, inherits = FALSE)
[13:20:27.204]                           if (inherits(master, c("SOCKnode", 
[13:20:27.204]                             "SOCK0node"))) {
[13:20:27.204]                             sendCondition <<- function(cond) {
[13:20:27.204]                               data <- list(type = "VALUE", value = cond, 
[13:20:27.204]                                 success = TRUE)
[13:20:27.204]                               parallel_sendData(master, data)
[13:20:27.204]                             }
[13:20:27.204]                             return(sendCondition)
[13:20:27.204]                           }
[13:20:27.204]                         }
[13:20:27.204]                         frame <- frame + 1L
[13:20:27.204]                         envir <- sys.frame(frame)
[13:20:27.204]                       }
[13:20:27.204]                     }
[13:20:27.204]                     sendCondition <<- function(cond) NULL
[13:20:27.204]                   }
[13:20:27.204]                 })
[13:20:27.204]                 withCallingHandlers({
[13:20:27.204]                   NULL
[13:20:27.204]                 }, immediateCondition = function(cond) {
[13:20:27.204]                   sendCondition <- ...future.makeSendCondition()
[13:20:27.204]                   sendCondition(cond)
[13:20:27.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.204]                   {
[13:20:27.204]                     inherits <- base::inherits
[13:20:27.204]                     invokeRestart <- base::invokeRestart
[13:20:27.204]                     is.null <- base::is.null
[13:20:27.204]                     muffled <- FALSE
[13:20:27.204]                     if (inherits(cond, "message")) {
[13:20:27.204]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.204]                       if (muffled) 
[13:20:27.204]                         invokeRestart("muffleMessage")
[13:20:27.204]                     }
[13:20:27.204]                     else if (inherits(cond, "warning")) {
[13:20:27.204]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.204]                       if (muffled) 
[13:20:27.204]                         invokeRestart("muffleWarning")
[13:20:27.204]                     }
[13:20:27.204]                     else if (inherits(cond, "condition")) {
[13:20:27.204]                       if (!is.null(pattern)) {
[13:20:27.204]                         computeRestarts <- base::computeRestarts
[13:20:27.204]                         grepl <- base::grepl
[13:20:27.204]                         restarts <- computeRestarts(cond)
[13:20:27.204]                         for (restart in restarts) {
[13:20:27.204]                           name <- restart$name
[13:20:27.204]                           if (is.null(name)) 
[13:20:27.204]                             next
[13:20:27.204]                           if (!grepl(pattern, name)) 
[13:20:27.204]                             next
[13:20:27.204]                           invokeRestart(restart)
[13:20:27.204]                           muffled <- TRUE
[13:20:27.204]                           break
[13:20:27.204]                         }
[13:20:27.204]                       }
[13:20:27.204]                     }
[13:20:27.204]                     invisible(muffled)
[13:20:27.204]                   }
[13:20:27.204]                   muffleCondition(cond)
[13:20:27.204]                 })
[13:20:27.204]             }))
[13:20:27.204]             future::FutureResult(value = ...future.value$value, 
[13:20:27.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.204]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.204]                     ...future.globalenv.names))
[13:20:27.204]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.204]         }, condition = base::local({
[13:20:27.204]             c <- base::c
[13:20:27.204]             inherits <- base::inherits
[13:20:27.204]             invokeRestart <- base::invokeRestart
[13:20:27.204]             length <- base::length
[13:20:27.204]             list <- base::list
[13:20:27.204]             seq.int <- base::seq.int
[13:20:27.204]             signalCondition <- base::signalCondition
[13:20:27.204]             sys.calls <- base::sys.calls
[13:20:27.204]             `[[` <- base::`[[`
[13:20:27.204]             `+` <- base::`+`
[13:20:27.204]             `<<-` <- base::`<<-`
[13:20:27.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.204]                   3L)]
[13:20:27.204]             }
[13:20:27.204]             function(cond) {
[13:20:27.204]                 is_error <- inherits(cond, "error")
[13:20:27.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.204]                   NULL)
[13:20:27.204]                 if (is_error) {
[13:20:27.204]                   sessionInformation <- function() {
[13:20:27.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.204]                       search = base::search(), system = base::Sys.info())
[13:20:27.204]                   }
[13:20:27.204]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.204]                     cond$call), session = sessionInformation(), 
[13:20:27.204]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.204]                   signalCondition(cond)
[13:20:27.204]                 }
[13:20:27.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.204]                 "immediateCondition"))) {
[13:20:27.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.204]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.204]                   if (TRUE && !signal) {
[13:20:27.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.204]                     {
[13:20:27.204]                       inherits <- base::inherits
[13:20:27.204]                       invokeRestart <- base::invokeRestart
[13:20:27.204]                       is.null <- base::is.null
[13:20:27.204]                       muffled <- FALSE
[13:20:27.204]                       if (inherits(cond, "message")) {
[13:20:27.204]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.204]                         if (muffled) 
[13:20:27.204]                           invokeRestart("muffleMessage")
[13:20:27.204]                       }
[13:20:27.204]                       else if (inherits(cond, "warning")) {
[13:20:27.204]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.204]                         if (muffled) 
[13:20:27.204]                           invokeRestart("muffleWarning")
[13:20:27.204]                       }
[13:20:27.204]                       else if (inherits(cond, "condition")) {
[13:20:27.204]                         if (!is.null(pattern)) {
[13:20:27.204]                           computeRestarts <- base::computeRestarts
[13:20:27.204]                           grepl <- base::grepl
[13:20:27.204]                           restarts <- computeRestarts(cond)
[13:20:27.204]                           for (restart in restarts) {
[13:20:27.204]                             name <- restart$name
[13:20:27.204]                             if (is.null(name)) 
[13:20:27.204]                               next
[13:20:27.204]                             if (!grepl(pattern, name)) 
[13:20:27.204]                               next
[13:20:27.204]                             invokeRestart(restart)
[13:20:27.204]                             muffled <- TRUE
[13:20:27.204]                             break
[13:20:27.204]                           }
[13:20:27.204]                         }
[13:20:27.204]                       }
[13:20:27.204]                       invisible(muffled)
[13:20:27.204]                     }
[13:20:27.204]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.204]                   }
[13:20:27.204]                 }
[13:20:27.204]                 else {
[13:20:27.204]                   if (TRUE) {
[13:20:27.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.204]                     {
[13:20:27.204]                       inherits <- base::inherits
[13:20:27.204]                       invokeRestart <- base::invokeRestart
[13:20:27.204]                       is.null <- base::is.null
[13:20:27.204]                       muffled <- FALSE
[13:20:27.204]                       if (inherits(cond, "message")) {
[13:20:27.204]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.204]                         if (muffled) 
[13:20:27.204]                           invokeRestart("muffleMessage")
[13:20:27.204]                       }
[13:20:27.204]                       else if (inherits(cond, "warning")) {
[13:20:27.204]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.204]                         if (muffled) 
[13:20:27.204]                           invokeRestart("muffleWarning")
[13:20:27.204]                       }
[13:20:27.204]                       else if (inherits(cond, "condition")) {
[13:20:27.204]                         if (!is.null(pattern)) {
[13:20:27.204]                           computeRestarts <- base::computeRestarts
[13:20:27.204]                           grepl <- base::grepl
[13:20:27.204]                           restarts <- computeRestarts(cond)
[13:20:27.204]                           for (restart in restarts) {
[13:20:27.204]                             name <- restart$name
[13:20:27.204]                             if (is.null(name)) 
[13:20:27.204]                               next
[13:20:27.204]                             if (!grepl(pattern, name)) 
[13:20:27.204]                               next
[13:20:27.204]                             invokeRestart(restart)
[13:20:27.204]                             muffled <- TRUE
[13:20:27.204]                             break
[13:20:27.204]                           }
[13:20:27.204]                         }
[13:20:27.204]                       }
[13:20:27.204]                       invisible(muffled)
[13:20:27.204]                     }
[13:20:27.204]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.204]                   }
[13:20:27.204]                 }
[13:20:27.204]             }
[13:20:27.204]         }))
[13:20:27.204]     }, error = function(ex) {
[13:20:27.204]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.204]                 ...future.rng), started = ...future.startTime, 
[13:20:27.204]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.204]             version = "1.8"), class = "FutureResult")
[13:20:27.204]     }, finally = {
[13:20:27.204]         if (!identical(...future.workdir, getwd())) 
[13:20:27.204]             setwd(...future.workdir)
[13:20:27.204]         {
[13:20:27.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.204]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.204]             }
[13:20:27.204]             base::options(...future.oldOptions)
[13:20:27.204]             if (.Platform$OS.type == "windows") {
[13:20:27.204]                 old_names <- names(...future.oldEnvVars)
[13:20:27.204]                 envs <- base::Sys.getenv()
[13:20:27.204]                 names <- names(envs)
[13:20:27.204]                 common <- intersect(names, old_names)
[13:20:27.204]                 added <- setdiff(names, old_names)
[13:20:27.204]                 removed <- setdiff(old_names, names)
[13:20:27.204]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.204]                   envs[common]]
[13:20:27.204]                 NAMES <- toupper(changed)
[13:20:27.204]                 args <- list()
[13:20:27.204]                 for (kk in seq_along(NAMES)) {
[13:20:27.204]                   name <- changed[[kk]]
[13:20:27.204]                   NAME <- NAMES[[kk]]
[13:20:27.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.204]                     next
[13:20:27.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.204]                 }
[13:20:27.204]                 NAMES <- toupper(added)
[13:20:27.204]                 for (kk in seq_along(NAMES)) {
[13:20:27.204]                   name <- added[[kk]]
[13:20:27.204]                   NAME <- NAMES[[kk]]
[13:20:27.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.204]                     next
[13:20:27.204]                   args[[name]] <- ""
[13:20:27.204]                 }
[13:20:27.204]                 NAMES <- toupper(removed)
[13:20:27.204]                 for (kk in seq_along(NAMES)) {
[13:20:27.204]                   name <- removed[[kk]]
[13:20:27.204]                   NAME <- NAMES[[kk]]
[13:20:27.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.204]                     next
[13:20:27.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.204]                 }
[13:20:27.204]                 if (length(args) > 0) 
[13:20:27.204]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.204]             }
[13:20:27.204]             else {
[13:20:27.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.204]             }
[13:20:27.204]             {
[13:20:27.204]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.204]                   0L) {
[13:20:27.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.204]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.204]                   base::options(opts)
[13:20:27.204]                 }
[13:20:27.204]                 {
[13:20:27.204]                   {
[13:20:27.204]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.204]                     NULL
[13:20:27.204]                   }
[13:20:27.204]                   options(future.plan = NULL)
[13:20:27.204]                   if (is.na(NA_character_)) 
[13:20:27.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.204]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:27.204]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:27.204]                     envir = parent.frame()) 
[13:20:27.204]                   {
[13:20:27.204]                     if (is.function(workers)) 
[13:20:27.204]                       workers <- workers()
[13:20:27.204]                     workers <- structure(as.integer(workers), 
[13:20:27.204]                       class = class(workers))
[13:20:27.204]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:27.204]                       workers >= 1)
[13:20:27.204]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:27.204]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:27.204]                     }
[13:20:27.204]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:27.204]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:27.204]                       envir = envir)
[13:20:27.204]                     if (!future$lazy) 
[13:20:27.204]                       future <- run(future)
[13:20:27.204]                     invisible(future)
[13:20:27.204]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.204]                 }
[13:20:27.204]             }
[13:20:27.204]         }
[13:20:27.204]     })
[13:20:27.204]     if (TRUE) {
[13:20:27.204]         base::sink(type = "output", split = FALSE)
[13:20:27.204]         if (TRUE) {
[13:20:27.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.204]         }
[13:20:27.204]         else {
[13:20:27.204]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.204]         }
[13:20:27.204]         base::close(...future.stdout)
[13:20:27.204]         ...future.stdout <- NULL
[13:20:27.204]     }
[13:20:27.204]     ...future.result$conditions <- ...future.conditions
[13:20:27.204]     ...future.result$finished <- base::Sys.time()
[13:20:27.204]     ...future.result
[13:20:27.204] }
[13:20:27.207] MultisessionFuture started
[13:20:27.207] - Launch lazy future ... done
[13:20:27.207] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659c47e610> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659bd291e0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659c47e610> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55659bd291e0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:20:27.236] resolve() on list ...
[13:20:27.236]  recursive: 0
[13:20:27.236]  length: 6
[13:20:27.236]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:20:27.236] signalConditionsASAP(numeric, pos=1) ...
[13:20:27.236] - nx: 6
[13:20:27.236] - relay: TRUE
[13:20:27.236] - stdout: TRUE
[13:20:27.237] - signal: TRUE
[13:20:27.237] - resignal: FALSE
[13:20:27.237] - force: TRUE
[13:20:27.237] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.237] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.237]  - until=2
[13:20:27.237]  - relaying element #2
[13:20:27.237] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.237] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.237] signalConditionsASAP(NULL, pos=1) ... done
[13:20:27.237]  length: 5 (resolved future 1)
[13:20:27.238] receiveMessageFromWorker() for ClusterFuture ...
[13:20:27.238] - Validating connection of MultisessionFuture
[13:20:27.238] - received message: FutureResult
[13:20:27.238] - Received FutureResult
[13:20:27.238] - Erased future from FutureRegistry
[13:20:27.239] result() for ClusterFuture ...
[13:20:27.239] - result already collected: FutureResult
[13:20:27.239] result() for ClusterFuture ... done
[13:20:27.239] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:27.239] Future #2
[13:20:27.239] result() for ClusterFuture ...
[13:20:27.239] - result already collected: FutureResult
[13:20:27.239] result() for ClusterFuture ... done
[13:20:27.239] result() for ClusterFuture ...
[13:20:27.239] - result already collected: FutureResult
[13:20:27.239] result() for ClusterFuture ... done
[13:20:27.240] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:27.240] - nx: 6
[13:20:27.240] - relay: TRUE
[13:20:27.240] - stdout: TRUE
[13:20:27.240] - signal: TRUE
[13:20:27.240] - resignal: FALSE
[13:20:27.240] - force: TRUE
[13:20:27.240] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.240] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:27.240]  - until=2
[13:20:27.240]  - relaying element #2
[13:20:27.241] result() for ClusterFuture ...
[13:20:27.241] - result already collected: FutureResult
[13:20:27.241] result() for ClusterFuture ... done
[13:20:27.241] result() for ClusterFuture ...
[13:20:27.241] - result already collected: FutureResult
[13:20:27.241] result() for ClusterFuture ... done
[13:20:27.241] result() for ClusterFuture ...
[13:20:27.241] - result already collected: FutureResult
[13:20:27.241] result() for ClusterFuture ... done
[13:20:27.241] result() for ClusterFuture ...
[13:20:27.241] - result already collected: FutureResult
[13:20:27.242] result() for ClusterFuture ... done
[13:20:27.242] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.242] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.242] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:27.242]  length: 4 (resolved future 2)
[13:20:27.252] signalConditionsASAP(NULL, pos=4) ...
[13:20:27.253] - nx: 6
[13:20:27.253] - relay: TRUE
[13:20:27.253] - stdout: TRUE
[13:20:27.253] - signal: TRUE
[13:20:27.253] - resignal: FALSE
[13:20:27.253] - force: TRUE
[13:20:27.253] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.253] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.253]  - until=5
[13:20:27.253]  - relaying element #3
[13:20:27.254]  - relaying element #5
[13:20:27.254] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:20:27.254] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.254] signalConditionsASAP(NULL, pos=4) ... done
[13:20:27.254]  length: 3 (resolved future 4)
[13:20:27.254] signalConditionsASAP(NULL, pos=5) ...
[13:20:27.254] - nx: 6
[13:20:27.254] - relay: TRUE
[13:20:27.254] - stdout: TRUE
[13:20:27.254] - signal: TRUE
[13:20:27.254] - resignal: FALSE
[13:20:27.255] - force: TRUE
[13:20:27.255] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:20:27.255] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.255]  - until=6
[13:20:27.255]  - relaying element #3
[13:20:27.255]  - relaying element #6
[13:20:27.255] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:20:27.255] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.255] signalConditionsASAP(NULL, pos=5) ... done
[13:20:27.255]  length: 2 (resolved future 5)
[13:20:27.255] signalConditionsASAP(numeric, pos=6) ...
[13:20:27.256] - nx: 6
[13:20:27.256] - relay: TRUE
[13:20:27.256] - stdout: TRUE
[13:20:27.256] - signal: TRUE
[13:20:27.256] - resignal: FALSE
[13:20:27.256] - force: TRUE
[13:20:27.256] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:20:27.256] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.256]  - until=6
[13:20:27.256]  - relaying element #3
[13:20:27.256] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:20:27.256] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.257] signalConditionsASAP(NULL, pos=6) ... done
[13:20:27.257]  length: 1 (resolved future 6)
[13:20:27.267] receiveMessageFromWorker() for ClusterFuture ...
[13:20:27.268] - Validating connection of MultisessionFuture
[13:20:27.268] - received message: FutureResult
[13:20:27.268] - Received FutureResult
[13:20:27.268] - Erased future from FutureRegistry
[13:20:27.268] result() for ClusterFuture ...
[13:20:27.268] - result already collected: FutureResult
[13:20:27.268] result() for ClusterFuture ... done
[13:20:27.268] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:27.268] Future #3
[13:20:27.269] result() for ClusterFuture ...
[13:20:27.269] - result already collected: FutureResult
[13:20:27.269] result() for ClusterFuture ... done
[13:20:27.269] result() for ClusterFuture ...
[13:20:27.269] - result already collected: FutureResult
[13:20:27.269] result() for ClusterFuture ... done
[13:20:27.269] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:27.269] - nx: 6
[13:20:27.269] - relay: TRUE
[13:20:27.269] - stdout: TRUE
[13:20:27.269] - signal: TRUE
[13:20:27.270] - resignal: FALSE
[13:20:27.270] - force: TRUE
[13:20:27.270] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:20:27.270] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:27.270]  - until=6
[13:20:27.270]  - relaying element #3
[13:20:27.270] result() for ClusterFuture ...
[13:20:27.270] - result already collected: FutureResult
[13:20:27.270] result() for ClusterFuture ... done
[13:20:27.270] result() for ClusterFuture ...
[13:20:27.270] - result already collected: FutureResult
[13:20:27.271] result() for ClusterFuture ... done
[13:20:27.271] result() for ClusterFuture ...
[13:20:27.271] - result already collected: FutureResult
[13:20:27.271] result() for ClusterFuture ... done
[13:20:27.271] result() for ClusterFuture ...
[13:20:27.271] - result already collected: FutureResult
[13:20:27.271] result() for ClusterFuture ... done
[13:20:27.271] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:27.271] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.271] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:27.271]  length: 0 (resolved future 3)
[13:20:27.272] Relaying remaining futures
[13:20:27.272] signalConditionsASAP(NULL, pos=0) ...
[13:20:27.272] - nx: 6
[13:20:27.272] - relay: TRUE
[13:20:27.272] - stdout: TRUE
[13:20:27.272] - signal: TRUE
[13:20:27.272] - resignal: FALSE
[13:20:27.272] - force: TRUE
[13:20:27.272] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:27.272] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:20:27.272] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:27.273] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:27.273] signalConditionsASAP(NULL, pos=0) ... done
[13:20:27.273] resolve() on list ... DONE
[13:20:27.273] result() for ClusterFuture ...
[13:20:27.273] - result already collected: FutureResult
[13:20:27.273] result() for ClusterFuture ... done
[13:20:27.273] result() for ClusterFuture ...
[13:20:27.273] - result already collected: FutureResult
[13:20:27.273] result() for ClusterFuture ... done
[13:20:27.273] result() for ClusterFuture ...
[13:20:27.274] - result already collected: FutureResult
[13:20:27.274] result() for ClusterFuture ... done
[13:20:27.274] result() for ClusterFuture ...
[13:20:27.274] - result already collected: FutureResult
[13:20:27.274] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[13:20:27.278] plan(): Setting new future strategy stack:
[13:20:27.278] List of future strategies:
[13:20:27.278] 1. multicore:
[13:20:27.278]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.278]    - tweaked: FALSE
[13:20:27.278]    - call: plan(strategy)
[13:20:27.283] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:20:27.283] getGlobalsAndPackages() ...
[13:20:27.283] Searching for globals...
[13:20:27.284] 
[13:20:27.284] Searching for globals ... DONE
[13:20:27.284] - globals: [0] <none>
[13:20:27.284] getGlobalsAndPackages() ... DONE
[13:20:27.285] run() for ‘Future’ ...
[13:20:27.285] - state: ‘created’
[13:20:27.285] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.289]   - Field: ‘label’
[13:20:27.289]   - Field: ‘local’
[13:20:27.289]   - Field: ‘owner’
[13:20:27.289]   - Field: ‘envir’
[13:20:27.289]   - Field: ‘workers’
[13:20:27.289]   - Field: ‘packages’
[13:20:27.289]   - Field: ‘gc’
[13:20:27.289]   - Field: ‘job’
[13:20:27.289]   - Field: ‘conditions’
[13:20:27.289]   - Field: ‘expr’
[13:20:27.290]   - Field: ‘uuid’
[13:20:27.290]   - Field: ‘seed’
[13:20:27.290]   - Field: ‘version’
[13:20:27.290]   - Field: ‘result’
[13:20:27.290]   - Field: ‘asynchronous’
[13:20:27.290]   - Field: ‘calls’
[13:20:27.290]   - Field: ‘globals’
[13:20:27.290]   - Field: ‘stdout’
[13:20:27.290]   - Field: ‘earlySignal’
[13:20:27.290]   - Field: ‘lazy’
[13:20:27.291]   - Field: ‘state’
[13:20:27.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.291] - Launch lazy future ...
[13:20:27.291] Packages needed by the future expression (n = 0): <none>
[13:20:27.291] Packages needed by future strategies (n = 0): <none>
[13:20:27.292] {
[13:20:27.292]     {
[13:20:27.292]         {
[13:20:27.292]             ...future.startTime <- base::Sys.time()
[13:20:27.292]             {
[13:20:27.292]                 {
[13:20:27.292]                   {
[13:20:27.292]                     {
[13:20:27.292]                       base::local({
[13:20:27.292]                         has_future <- base::requireNamespace("future", 
[13:20:27.292]                           quietly = TRUE)
[13:20:27.292]                         if (has_future) {
[13:20:27.292]                           ns <- base::getNamespace("future")
[13:20:27.292]                           version <- ns[[".package"]][["version"]]
[13:20:27.292]                           if (is.null(version)) 
[13:20:27.292]                             version <- utils::packageVersion("future")
[13:20:27.292]                         }
[13:20:27.292]                         else {
[13:20:27.292]                           version <- NULL
[13:20:27.292]                         }
[13:20:27.292]                         if (!has_future || version < "1.8.0") {
[13:20:27.292]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.292]                             "", base::R.version$version.string), 
[13:20:27.292]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.292]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.292]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.292]                               "release", "version")], collapse = " "), 
[13:20:27.292]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.292]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.292]                             info)
[13:20:27.292]                           info <- base::paste(info, collapse = "; ")
[13:20:27.292]                           if (!has_future) {
[13:20:27.292]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.292]                               info)
[13:20:27.292]                           }
[13:20:27.292]                           else {
[13:20:27.292]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.292]                               info, version)
[13:20:27.292]                           }
[13:20:27.292]                           base::stop(msg)
[13:20:27.292]                         }
[13:20:27.292]                       })
[13:20:27.292]                     }
[13:20:27.292]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.292]                     base::options(mc.cores = 1L)
[13:20:27.292]                   }
[13:20:27.292]                   options(future.plan = NULL)
[13:20:27.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.292]                 }
[13:20:27.292]                 ...future.workdir <- getwd()
[13:20:27.292]             }
[13:20:27.292]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.292]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.292]         }
[13:20:27.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.292]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.292]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.292]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.292]             base::names(...future.oldOptions))
[13:20:27.292]     }
[13:20:27.292]     if (FALSE) {
[13:20:27.292]     }
[13:20:27.292]     else {
[13:20:27.292]         if (TRUE) {
[13:20:27.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.292]                 open = "w")
[13:20:27.292]         }
[13:20:27.292]         else {
[13:20:27.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.292]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.292]         }
[13:20:27.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.292]             base::sink(type = "output", split = FALSE)
[13:20:27.292]             base::close(...future.stdout)
[13:20:27.292]         }, add = TRUE)
[13:20:27.292]     }
[13:20:27.292]     ...future.frame <- base::sys.nframe()
[13:20:27.292]     ...future.conditions <- base::list()
[13:20:27.292]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.292]     if (FALSE) {
[13:20:27.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.292]     }
[13:20:27.292]     ...future.result <- base::tryCatch({
[13:20:27.292]         base::withCallingHandlers({
[13:20:27.292]             ...future.value <- base::withVisible(base::local({
[13:20:27.292]                 withCallingHandlers({
[13:20:27.292]                   2
[13:20:27.292]                 }, immediateCondition = function(cond) {
[13:20:27.292]                   save_rds <- function (object, pathname, ...) 
[13:20:27.292]                   {
[13:20:27.292]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.292]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.292]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.292]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.292]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.292]                         fi_tmp[["mtime"]])
[13:20:27.292]                     }
[13:20:27.292]                     tryCatch({
[13:20:27.292]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.292]                     }, error = function(ex) {
[13:20:27.292]                       msg <- conditionMessage(ex)
[13:20:27.292]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.292]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.292]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.292]                         fi_tmp[["mtime"]], msg)
[13:20:27.292]                       ex$message <- msg
[13:20:27.292]                       stop(ex)
[13:20:27.292]                     })
[13:20:27.292]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.292]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.292]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.292]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.292]                       fi <- file.info(pathname)
[13:20:27.292]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.292]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.292]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.292]                         fi[["size"]], fi[["mtime"]])
[13:20:27.292]                       stop(msg)
[13:20:27.292]                     }
[13:20:27.292]                     invisible(pathname)
[13:20:27.292]                   }
[13:20:27.292]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.292]                     rootPath = tempdir()) 
[13:20:27.292]                   {
[13:20:27.292]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.292]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.292]                       tmpdir = path, fileext = ".rds")
[13:20:27.292]                     save_rds(obj, file)
[13:20:27.292]                   }
[13:20:27.292]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.292]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.292]                   {
[13:20:27.292]                     inherits <- base::inherits
[13:20:27.292]                     invokeRestart <- base::invokeRestart
[13:20:27.292]                     is.null <- base::is.null
[13:20:27.292]                     muffled <- FALSE
[13:20:27.292]                     if (inherits(cond, "message")) {
[13:20:27.292]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.292]                       if (muffled) 
[13:20:27.292]                         invokeRestart("muffleMessage")
[13:20:27.292]                     }
[13:20:27.292]                     else if (inherits(cond, "warning")) {
[13:20:27.292]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.292]                       if (muffled) 
[13:20:27.292]                         invokeRestart("muffleWarning")
[13:20:27.292]                     }
[13:20:27.292]                     else if (inherits(cond, "condition")) {
[13:20:27.292]                       if (!is.null(pattern)) {
[13:20:27.292]                         computeRestarts <- base::computeRestarts
[13:20:27.292]                         grepl <- base::grepl
[13:20:27.292]                         restarts <- computeRestarts(cond)
[13:20:27.292]                         for (restart in restarts) {
[13:20:27.292]                           name <- restart$name
[13:20:27.292]                           if (is.null(name)) 
[13:20:27.292]                             next
[13:20:27.292]                           if (!grepl(pattern, name)) 
[13:20:27.292]                             next
[13:20:27.292]                           invokeRestart(restart)
[13:20:27.292]                           muffled <- TRUE
[13:20:27.292]                           break
[13:20:27.292]                         }
[13:20:27.292]                       }
[13:20:27.292]                     }
[13:20:27.292]                     invisible(muffled)
[13:20:27.292]                   }
[13:20:27.292]                   muffleCondition(cond)
[13:20:27.292]                 })
[13:20:27.292]             }))
[13:20:27.292]             future::FutureResult(value = ...future.value$value, 
[13:20:27.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.292]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.292]                     ...future.globalenv.names))
[13:20:27.292]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.292]         }, condition = base::local({
[13:20:27.292]             c <- base::c
[13:20:27.292]             inherits <- base::inherits
[13:20:27.292]             invokeRestart <- base::invokeRestart
[13:20:27.292]             length <- base::length
[13:20:27.292]             list <- base::list
[13:20:27.292]             seq.int <- base::seq.int
[13:20:27.292]             signalCondition <- base::signalCondition
[13:20:27.292]             sys.calls <- base::sys.calls
[13:20:27.292]             `[[` <- base::`[[`
[13:20:27.292]             `+` <- base::`+`
[13:20:27.292]             `<<-` <- base::`<<-`
[13:20:27.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.292]                   3L)]
[13:20:27.292]             }
[13:20:27.292]             function(cond) {
[13:20:27.292]                 is_error <- inherits(cond, "error")
[13:20:27.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.292]                   NULL)
[13:20:27.292]                 if (is_error) {
[13:20:27.292]                   sessionInformation <- function() {
[13:20:27.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.292]                       search = base::search(), system = base::Sys.info())
[13:20:27.292]                   }
[13:20:27.292]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.292]                     cond$call), session = sessionInformation(), 
[13:20:27.292]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.292]                   signalCondition(cond)
[13:20:27.292]                 }
[13:20:27.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.292]                 "immediateCondition"))) {
[13:20:27.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.292]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.292]                   if (TRUE && !signal) {
[13:20:27.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.292]                     {
[13:20:27.292]                       inherits <- base::inherits
[13:20:27.292]                       invokeRestart <- base::invokeRestart
[13:20:27.292]                       is.null <- base::is.null
[13:20:27.292]                       muffled <- FALSE
[13:20:27.292]                       if (inherits(cond, "message")) {
[13:20:27.292]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.292]                         if (muffled) 
[13:20:27.292]                           invokeRestart("muffleMessage")
[13:20:27.292]                       }
[13:20:27.292]                       else if (inherits(cond, "warning")) {
[13:20:27.292]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.292]                         if (muffled) 
[13:20:27.292]                           invokeRestart("muffleWarning")
[13:20:27.292]                       }
[13:20:27.292]                       else if (inherits(cond, "condition")) {
[13:20:27.292]                         if (!is.null(pattern)) {
[13:20:27.292]                           computeRestarts <- base::computeRestarts
[13:20:27.292]                           grepl <- base::grepl
[13:20:27.292]                           restarts <- computeRestarts(cond)
[13:20:27.292]                           for (restart in restarts) {
[13:20:27.292]                             name <- restart$name
[13:20:27.292]                             if (is.null(name)) 
[13:20:27.292]                               next
[13:20:27.292]                             if (!grepl(pattern, name)) 
[13:20:27.292]                               next
[13:20:27.292]                             invokeRestart(restart)
[13:20:27.292]                             muffled <- TRUE
[13:20:27.292]                             break
[13:20:27.292]                           }
[13:20:27.292]                         }
[13:20:27.292]                       }
[13:20:27.292]                       invisible(muffled)
[13:20:27.292]                     }
[13:20:27.292]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.292]                   }
[13:20:27.292]                 }
[13:20:27.292]                 else {
[13:20:27.292]                   if (TRUE) {
[13:20:27.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.292]                     {
[13:20:27.292]                       inherits <- base::inherits
[13:20:27.292]                       invokeRestart <- base::invokeRestart
[13:20:27.292]                       is.null <- base::is.null
[13:20:27.292]                       muffled <- FALSE
[13:20:27.292]                       if (inherits(cond, "message")) {
[13:20:27.292]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.292]                         if (muffled) 
[13:20:27.292]                           invokeRestart("muffleMessage")
[13:20:27.292]                       }
[13:20:27.292]                       else if (inherits(cond, "warning")) {
[13:20:27.292]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.292]                         if (muffled) 
[13:20:27.292]                           invokeRestart("muffleWarning")
[13:20:27.292]                       }
[13:20:27.292]                       else if (inherits(cond, "condition")) {
[13:20:27.292]                         if (!is.null(pattern)) {
[13:20:27.292]                           computeRestarts <- base::computeRestarts
[13:20:27.292]                           grepl <- base::grepl
[13:20:27.292]                           restarts <- computeRestarts(cond)
[13:20:27.292]                           for (restart in restarts) {
[13:20:27.292]                             name <- restart$name
[13:20:27.292]                             if (is.null(name)) 
[13:20:27.292]                               next
[13:20:27.292]                             if (!grepl(pattern, name)) 
[13:20:27.292]                               next
[13:20:27.292]                             invokeRestart(restart)
[13:20:27.292]                             muffled <- TRUE
[13:20:27.292]                             break
[13:20:27.292]                           }
[13:20:27.292]                         }
[13:20:27.292]                       }
[13:20:27.292]                       invisible(muffled)
[13:20:27.292]                     }
[13:20:27.292]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.292]                   }
[13:20:27.292]                 }
[13:20:27.292]             }
[13:20:27.292]         }))
[13:20:27.292]     }, error = function(ex) {
[13:20:27.292]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.292]                 ...future.rng), started = ...future.startTime, 
[13:20:27.292]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.292]             version = "1.8"), class = "FutureResult")
[13:20:27.292]     }, finally = {
[13:20:27.292]         if (!identical(...future.workdir, getwd())) 
[13:20:27.292]             setwd(...future.workdir)
[13:20:27.292]         {
[13:20:27.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.292]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.292]             }
[13:20:27.292]             base::options(...future.oldOptions)
[13:20:27.292]             if (.Platform$OS.type == "windows") {
[13:20:27.292]                 old_names <- names(...future.oldEnvVars)
[13:20:27.292]                 envs <- base::Sys.getenv()
[13:20:27.292]                 names <- names(envs)
[13:20:27.292]                 common <- intersect(names, old_names)
[13:20:27.292]                 added <- setdiff(names, old_names)
[13:20:27.292]                 removed <- setdiff(old_names, names)
[13:20:27.292]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.292]                   envs[common]]
[13:20:27.292]                 NAMES <- toupper(changed)
[13:20:27.292]                 args <- list()
[13:20:27.292]                 for (kk in seq_along(NAMES)) {
[13:20:27.292]                   name <- changed[[kk]]
[13:20:27.292]                   NAME <- NAMES[[kk]]
[13:20:27.292]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.292]                     next
[13:20:27.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.292]                 }
[13:20:27.292]                 NAMES <- toupper(added)
[13:20:27.292]                 for (kk in seq_along(NAMES)) {
[13:20:27.292]                   name <- added[[kk]]
[13:20:27.292]                   NAME <- NAMES[[kk]]
[13:20:27.292]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.292]                     next
[13:20:27.292]                   args[[name]] <- ""
[13:20:27.292]                 }
[13:20:27.292]                 NAMES <- toupper(removed)
[13:20:27.292]                 for (kk in seq_along(NAMES)) {
[13:20:27.292]                   name <- removed[[kk]]
[13:20:27.292]                   NAME <- NAMES[[kk]]
[13:20:27.292]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.292]                     next
[13:20:27.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.292]                 }
[13:20:27.292]                 if (length(args) > 0) 
[13:20:27.292]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.292]             }
[13:20:27.292]             else {
[13:20:27.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.292]             }
[13:20:27.292]             {
[13:20:27.292]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.292]                   0L) {
[13:20:27.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.292]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.292]                   base::options(opts)
[13:20:27.292]                 }
[13:20:27.292]                 {
[13:20:27.292]                   {
[13:20:27.292]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.292]                     NULL
[13:20:27.292]                   }
[13:20:27.292]                   options(future.plan = NULL)
[13:20:27.292]                   if (is.na(NA_character_)) 
[13:20:27.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.292]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.292]                     envir = parent.frame()) 
[13:20:27.292]                   {
[13:20:27.292]                     default_workers <- missing(workers)
[13:20:27.292]                     if (is.function(workers)) 
[13:20:27.292]                       workers <- workers()
[13:20:27.292]                     workers <- structure(as.integer(workers), 
[13:20:27.292]                       class = class(workers))
[13:20:27.292]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.292]                       1L)
[13:20:27.292]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.292]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.292]                       if (default_workers) 
[13:20:27.292]                         supportsMulticore(warn = TRUE)
[13:20:27.292]                       return(sequential(..., envir = envir))
[13:20:27.292]                     }
[13:20:27.292]                     oopts <- options(mc.cores = workers)
[13:20:27.292]                     on.exit(options(oopts))
[13:20:27.292]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.292]                       envir = envir)
[13:20:27.292]                     if (!future$lazy) 
[13:20:27.292]                       future <- run(future)
[13:20:27.292]                     invisible(future)
[13:20:27.292]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.292]                 }
[13:20:27.292]             }
[13:20:27.292]         }
[13:20:27.292]     })
[13:20:27.292]     if (TRUE) {
[13:20:27.292]         base::sink(type = "output", split = FALSE)
[13:20:27.292]         if (TRUE) {
[13:20:27.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.292]         }
[13:20:27.292]         else {
[13:20:27.292]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.292]         }
[13:20:27.292]         base::close(...future.stdout)
[13:20:27.292]         ...future.stdout <- NULL
[13:20:27.292]     }
[13:20:27.292]     ...future.result$conditions <- ...future.conditions
[13:20:27.292]     ...future.result$finished <- base::Sys.time()
[13:20:27.292]     ...future.result
[13:20:27.292] }
[13:20:27.294] requestCore(): workers = 2
[13:20:27.296] MulticoreFuture started
[13:20:27.297] - Launch lazy future ... done
[13:20:27.297] run() for ‘MulticoreFuture’ ... done
[13:20:27.297] getGlobalsAndPackages() ...
[13:20:27.297] Searching for globals...
[13:20:27.298] plan(): Setting new future strategy stack:
[13:20:27.298] 
[13:20:27.298] Searching for globals ... DONE
[13:20:27.298] List of future strategies:
[13:20:27.298] 1. sequential:
[13:20:27.298]    - args: function (..., envir = parent.frame())
[13:20:27.298]    - tweaked: FALSE
[13:20:27.298]    - call: NULL
[13:20:27.298] - globals: [0] <none>
[13:20:27.299] getGlobalsAndPackages() ... DONE
[13:20:27.299] plan(): nbrOfWorkers() = 1
[13:20:27.299] run() for ‘Future’ ...
[13:20:27.299] - state: ‘created’
[13:20:27.299] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.300] plan(): Setting new future strategy stack:
[13:20:27.301] List of future strategies:
[13:20:27.301] 1. multicore:
[13:20:27.301]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.301]    - tweaked: FALSE
[13:20:27.301]    - call: plan(strategy)
[13:20:27.304] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.305] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.305]   - Field: ‘label’
[13:20:27.305] plan(): nbrOfWorkers() = 2
[13:20:27.305]   - Field: ‘local’
[13:20:27.305]   - Field: ‘owner’
[13:20:27.305]   - Field: ‘envir’
[13:20:27.306]   - Field: ‘workers’
[13:20:27.306]   - Field: ‘packages’
[13:20:27.306]   - Field: ‘gc’
[13:20:27.306]   - Field: ‘job’
[13:20:27.306]   - Field: ‘conditions’
[13:20:27.306]   - Field: ‘expr’
[13:20:27.306]   - Field: ‘uuid’
[13:20:27.307]   - Field: ‘seed’
[13:20:27.307]   - Field: ‘version’
[13:20:27.307]   - Field: ‘result’
[13:20:27.307]   - Field: ‘asynchronous’
[13:20:27.307]   - Field: ‘calls’
[13:20:27.307]   - Field: ‘globals’
[13:20:27.307]   - Field: ‘stdout’
[13:20:27.308]   - Field: ‘earlySignal’
[13:20:27.308]   - Field: ‘lazy’
[13:20:27.308]   - Field: ‘state’
[13:20:27.308] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.308] - Launch lazy future ...
[13:20:27.309] Packages needed by the future expression (n = 0): <none>
[13:20:27.309] Packages needed by future strategies (n = 0): <none>
[13:20:27.309] {
[13:20:27.309]     {
[13:20:27.309]         {
[13:20:27.309]             ...future.startTime <- base::Sys.time()
[13:20:27.309]             {
[13:20:27.309]                 {
[13:20:27.309]                   {
[13:20:27.309]                     {
[13:20:27.309]                       base::local({
[13:20:27.309]                         has_future <- base::requireNamespace("future", 
[13:20:27.309]                           quietly = TRUE)
[13:20:27.309]                         if (has_future) {
[13:20:27.309]                           ns <- base::getNamespace("future")
[13:20:27.309]                           version <- ns[[".package"]][["version"]]
[13:20:27.309]                           if (is.null(version)) 
[13:20:27.309]                             version <- utils::packageVersion("future")
[13:20:27.309]                         }
[13:20:27.309]                         else {
[13:20:27.309]                           version <- NULL
[13:20:27.309]                         }
[13:20:27.309]                         if (!has_future || version < "1.8.0") {
[13:20:27.309]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.309]                             "", base::R.version$version.string), 
[13:20:27.309]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.309]                               "release", "version")], collapse = " "), 
[13:20:27.309]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.309]                             info)
[13:20:27.309]                           info <- base::paste(info, collapse = "; ")
[13:20:27.309]                           if (!has_future) {
[13:20:27.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.309]                               info)
[13:20:27.309]                           }
[13:20:27.309]                           else {
[13:20:27.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.309]                               info, version)
[13:20:27.309]                           }
[13:20:27.309]                           base::stop(msg)
[13:20:27.309]                         }
[13:20:27.309]                       })
[13:20:27.309]                     }
[13:20:27.309]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.309]                     base::options(mc.cores = 1L)
[13:20:27.309]                   }
[13:20:27.309]                   options(future.plan = NULL)
[13:20:27.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.309]                 }
[13:20:27.309]                 ...future.workdir <- getwd()
[13:20:27.309]             }
[13:20:27.309]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.309]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.309]         }
[13:20:27.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.309]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.309]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.309]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.309]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.309]             base::names(...future.oldOptions))
[13:20:27.309]     }
[13:20:27.309]     if (FALSE) {
[13:20:27.309]     }
[13:20:27.309]     else {
[13:20:27.309]         if (TRUE) {
[13:20:27.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.309]                 open = "w")
[13:20:27.309]         }
[13:20:27.309]         else {
[13:20:27.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.309]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.309]         }
[13:20:27.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.309]             base::sink(type = "output", split = FALSE)
[13:20:27.309]             base::close(...future.stdout)
[13:20:27.309]         }, add = TRUE)
[13:20:27.309]     }
[13:20:27.309]     ...future.frame <- base::sys.nframe()
[13:20:27.309]     ...future.conditions <- base::list()
[13:20:27.309]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.309]     if (FALSE) {
[13:20:27.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.309]     }
[13:20:27.309]     ...future.result <- base::tryCatch({
[13:20:27.309]         base::withCallingHandlers({
[13:20:27.309]             ...future.value <- base::withVisible(base::local({
[13:20:27.309]                 withCallingHandlers({
[13:20:27.309]                   NULL
[13:20:27.309]                 }, immediateCondition = function(cond) {
[13:20:27.309]                   save_rds <- function (object, pathname, ...) 
[13:20:27.309]                   {
[13:20:27.309]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.309]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.309]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.309]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.309]                         fi_tmp[["mtime"]])
[13:20:27.309]                     }
[13:20:27.309]                     tryCatch({
[13:20:27.309]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.309]                     }, error = function(ex) {
[13:20:27.309]                       msg <- conditionMessage(ex)
[13:20:27.309]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.309]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.309]                         fi_tmp[["mtime"]], msg)
[13:20:27.309]                       ex$message <- msg
[13:20:27.309]                       stop(ex)
[13:20:27.309]                     })
[13:20:27.309]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.309]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.309]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.309]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.309]                       fi <- file.info(pathname)
[13:20:27.309]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.309]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.309]                         fi[["size"]], fi[["mtime"]])
[13:20:27.309]                       stop(msg)
[13:20:27.309]                     }
[13:20:27.309]                     invisible(pathname)
[13:20:27.309]                   }
[13:20:27.309]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.309]                     rootPath = tempdir()) 
[13:20:27.309]                   {
[13:20:27.309]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.309]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.309]                       tmpdir = path, fileext = ".rds")
[13:20:27.309]                     save_rds(obj, file)
[13:20:27.309]                   }
[13:20:27.309]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.309]                   {
[13:20:27.309]                     inherits <- base::inherits
[13:20:27.309]                     invokeRestart <- base::invokeRestart
[13:20:27.309]                     is.null <- base::is.null
[13:20:27.309]                     muffled <- FALSE
[13:20:27.309]                     if (inherits(cond, "message")) {
[13:20:27.309]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.309]                       if (muffled) 
[13:20:27.309]                         invokeRestart("muffleMessage")
[13:20:27.309]                     }
[13:20:27.309]                     else if (inherits(cond, "warning")) {
[13:20:27.309]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.309]                       if (muffled) 
[13:20:27.309]                         invokeRestart("muffleWarning")
[13:20:27.309]                     }
[13:20:27.309]                     else if (inherits(cond, "condition")) {
[13:20:27.309]                       if (!is.null(pattern)) {
[13:20:27.309]                         computeRestarts <- base::computeRestarts
[13:20:27.309]                         grepl <- base::grepl
[13:20:27.309]                         restarts <- computeRestarts(cond)
[13:20:27.309]                         for (restart in restarts) {
[13:20:27.309]                           name <- restart$name
[13:20:27.309]                           if (is.null(name)) 
[13:20:27.309]                             next
[13:20:27.309]                           if (!grepl(pattern, name)) 
[13:20:27.309]                             next
[13:20:27.309]                           invokeRestart(restart)
[13:20:27.309]                           muffled <- TRUE
[13:20:27.309]                           break
[13:20:27.309]                         }
[13:20:27.309]                       }
[13:20:27.309]                     }
[13:20:27.309]                     invisible(muffled)
[13:20:27.309]                   }
[13:20:27.309]                   muffleCondition(cond)
[13:20:27.309]                 })
[13:20:27.309]             }))
[13:20:27.309]             future::FutureResult(value = ...future.value$value, 
[13:20:27.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.309]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.309]                     ...future.globalenv.names))
[13:20:27.309]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.309]         }, condition = base::local({
[13:20:27.309]             c <- base::c
[13:20:27.309]             inherits <- base::inherits
[13:20:27.309]             invokeRestart <- base::invokeRestart
[13:20:27.309]             length <- base::length
[13:20:27.309]             list <- base::list
[13:20:27.309]             seq.int <- base::seq.int
[13:20:27.309]             signalCondition <- base::signalCondition
[13:20:27.309]             sys.calls <- base::sys.calls
[13:20:27.309]             `[[` <- base::`[[`
[13:20:27.309]             `+` <- base::`+`
[13:20:27.309]             `<<-` <- base::`<<-`
[13:20:27.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.309]                   3L)]
[13:20:27.309]             }
[13:20:27.309]             function(cond) {
[13:20:27.309]                 is_error <- inherits(cond, "error")
[13:20:27.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.309]                   NULL)
[13:20:27.309]                 if (is_error) {
[13:20:27.309]                   sessionInformation <- function() {
[13:20:27.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.309]                       search = base::search(), system = base::Sys.info())
[13:20:27.309]                   }
[13:20:27.309]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.309]                     cond$call), session = sessionInformation(), 
[13:20:27.309]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.309]                   signalCondition(cond)
[13:20:27.309]                 }
[13:20:27.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.309]                 "immediateCondition"))) {
[13:20:27.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.309]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.309]                   if (TRUE && !signal) {
[13:20:27.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.309]                     {
[13:20:27.309]                       inherits <- base::inherits
[13:20:27.309]                       invokeRestart <- base::invokeRestart
[13:20:27.309]                       is.null <- base::is.null
[13:20:27.309]                       muffled <- FALSE
[13:20:27.309]                       if (inherits(cond, "message")) {
[13:20:27.309]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.309]                         if (muffled) 
[13:20:27.309]                           invokeRestart("muffleMessage")
[13:20:27.309]                       }
[13:20:27.309]                       else if (inherits(cond, "warning")) {
[13:20:27.309]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.309]                         if (muffled) 
[13:20:27.309]                           invokeRestart("muffleWarning")
[13:20:27.309]                       }
[13:20:27.309]                       else if (inherits(cond, "condition")) {
[13:20:27.309]                         if (!is.null(pattern)) {
[13:20:27.309]                           computeRestarts <- base::computeRestarts
[13:20:27.309]                           grepl <- base::grepl
[13:20:27.309]                           restarts <- computeRestarts(cond)
[13:20:27.309]                           for (restart in restarts) {
[13:20:27.309]                             name <- restart$name
[13:20:27.309]                             if (is.null(name)) 
[13:20:27.309]                               next
[13:20:27.309]                             if (!grepl(pattern, name)) 
[13:20:27.309]                               next
[13:20:27.309]                             invokeRestart(restart)
[13:20:27.309]                             muffled <- TRUE
[13:20:27.309]                             break
[13:20:27.309]                           }
[13:20:27.309]                         }
[13:20:27.309]                       }
[13:20:27.309]                       invisible(muffled)
[13:20:27.309]                     }
[13:20:27.309]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.309]                   }
[13:20:27.309]                 }
[13:20:27.309]                 else {
[13:20:27.309]                   if (TRUE) {
[13:20:27.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.309]                     {
[13:20:27.309]                       inherits <- base::inherits
[13:20:27.309]                       invokeRestart <- base::invokeRestart
[13:20:27.309]                       is.null <- base::is.null
[13:20:27.309]                       muffled <- FALSE
[13:20:27.309]                       if (inherits(cond, "message")) {
[13:20:27.309]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.309]                         if (muffled) 
[13:20:27.309]                           invokeRestart("muffleMessage")
[13:20:27.309]                       }
[13:20:27.309]                       else if (inherits(cond, "warning")) {
[13:20:27.309]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.309]                         if (muffled) 
[13:20:27.309]                           invokeRestart("muffleWarning")
[13:20:27.309]                       }
[13:20:27.309]                       else if (inherits(cond, "condition")) {
[13:20:27.309]                         if (!is.null(pattern)) {
[13:20:27.309]                           computeRestarts <- base::computeRestarts
[13:20:27.309]                           grepl <- base::grepl
[13:20:27.309]                           restarts <- computeRestarts(cond)
[13:20:27.309]                           for (restart in restarts) {
[13:20:27.309]                             name <- restart$name
[13:20:27.309]                             if (is.null(name)) 
[13:20:27.309]                               next
[13:20:27.309]                             if (!grepl(pattern, name)) 
[13:20:27.309]                               next
[13:20:27.309]                             invokeRestart(restart)
[13:20:27.309]                             muffled <- TRUE
[13:20:27.309]                             break
[13:20:27.309]                           }
[13:20:27.309]                         }
[13:20:27.309]                       }
[13:20:27.309]                       invisible(muffled)
[13:20:27.309]                     }
[13:20:27.309]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.309]                   }
[13:20:27.309]                 }
[13:20:27.309]             }
[13:20:27.309]         }))
[13:20:27.309]     }, error = function(ex) {
[13:20:27.309]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.309]                 ...future.rng), started = ...future.startTime, 
[13:20:27.309]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.309]             version = "1.8"), class = "FutureResult")
[13:20:27.309]     }, finally = {
[13:20:27.309]         if (!identical(...future.workdir, getwd())) 
[13:20:27.309]             setwd(...future.workdir)
[13:20:27.309]         {
[13:20:27.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.309]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.309]             }
[13:20:27.309]             base::options(...future.oldOptions)
[13:20:27.309]             if (.Platform$OS.type == "windows") {
[13:20:27.309]                 old_names <- names(...future.oldEnvVars)
[13:20:27.309]                 envs <- base::Sys.getenv()
[13:20:27.309]                 names <- names(envs)
[13:20:27.309]                 common <- intersect(names, old_names)
[13:20:27.309]                 added <- setdiff(names, old_names)
[13:20:27.309]                 removed <- setdiff(old_names, names)
[13:20:27.309]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.309]                   envs[common]]
[13:20:27.309]                 NAMES <- toupper(changed)
[13:20:27.309]                 args <- list()
[13:20:27.309]                 for (kk in seq_along(NAMES)) {
[13:20:27.309]                   name <- changed[[kk]]
[13:20:27.309]                   NAME <- NAMES[[kk]]
[13:20:27.309]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.309]                     next
[13:20:27.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.309]                 }
[13:20:27.309]                 NAMES <- toupper(added)
[13:20:27.309]                 for (kk in seq_along(NAMES)) {
[13:20:27.309]                   name <- added[[kk]]
[13:20:27.309]                   NAME <- NAMES[[kk]]
[13:20:27.309]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.309]                     next
[13:20:27.309]                   args[[name]] <- ""
[13:20:27.309]                 }
[13:20:27.309]                 NAMES <- toupper(removed)
[13:20:27.309]                 for (kk in seq_along(NAMES)) {
[13:20:27.309]                   name <- removed[[kk]]
[13:20:27.309]                   NAME <- NAMES[[kk]]
[13:20:27.309]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.309]                     next
[13:20:27.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.309]                 }
[13:20:27.309]                 if (length(args) > 0) 
[13:20:27.309]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.309]             }
[13:20:27.309]             else {
[13:20:27.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.309]             }
[13:20:27.309]             {
[13:20:27.309]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.309]                   0L) {
[13:20:27.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.309]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.309]                   base::options(opts)
[13:20:27.309]                 }
[13:20:27.309]                 {
[13:20:27.309]                   {
[13:20:27.309]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.309]                     NULL
[13:20:27.309]                   }
[13:20:27.309]                   options(future.plan = NULL)
[13:20:27.309]                   if (is.na(NA_character_)) 
[13:20:27.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.309]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.309]                     envir = parent.frame()) 
[13:20:27.309]                   {
[13:20:27.309]                     default_workers <- missing(workers)
[13:20:27.309]                     if (is.function(workers)) 
[13:20:27.309]                       workers <- workers()
[13:20:27.309]                     workers <- structure(as.integer(workers), 
[13:20:27.309]                       class = class(workers))
[13:20:27.309]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.309]                       1L)
[13:20:27.309]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.309]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.309]                       if (default_workers) 
[13:20:27.309]                         supportsMulticore(warn = TRUE)
[13:20:27.309]                       return(sequential(..., envir = envir))
[13:20:27.309]                     }
[13:20:27.309]                     oopts <- options(mc.cores = workers)
[13:20:27.309]                     on.exit(options(oopts))
[13:20:27.309]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.309]                       envir = envir)
[13:20:27.309]                     if (!future$lazy) 
[13:20:27.309]                       future <- run(future)
[13:20:27.309]                     invisible(future)
[13:20:27.309]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.309]                 }
[13:20:27.309]             }
[13:20:27.309]         }
[13:20:27.309]     })
[13:20:27.309]     if (TRUE) {
[13:20:27.309]         base::sink(type = "output", split = FALSE)
[13:20:27.309]         if (TRUE) {
[13:20:27.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.309]         }
[13:20:27.309]         else {
[13:20:27.309]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.309]         }
[13:20:27.309]         base::close(...future.stdout)
[13:20:27.309]         ...future.stdout <- NULL
[13:20:27.309]     }
[13:20:27.309]     ...future.result$conditions <- ...future.conditions
[13:20:27.309]     ...future.result$finished <- base::Sys.time()
[13:20:27.309]     ...future.result
[13:20:27.309] }
[13:20:27.313] requestCore(): workers = 2
[13:20:27.315] MulticoreFuture started
[13:20:27.316] - Launch lazy future ... done
[13:20:27.316] run() for ‘MulticoreFuture’ ... done
[13:20:27.316] plan(): Setting new future strategy stack:
[13:20:27.317] getGlobalsAndPackages() ...
[13:20:27.317] Searching for globals...
[13:20:27.317] List of future strategies:
[13:20:27.317] 1. sequential:
[13:20:27.317]    - args: function (..., envir = parent.frame())
[13:20:27.317]    - tweaked: FALSE
[13:20:27.317]    - call: NULL
[13:20:27.318] plan(): nbrOfWorkers() = 1
[13:20:27.318] - globals found: [1] ‘{’
[13:20:27.318] Searching for globals ... DONE
[13:20:27.318] Resolving globals: FALSE
[13:20:27.319] 
[13:20:27.319] 
[13:20:27.319] getGlobalsAndPackages() ... DONE
[13:20:27.319] plan(): Setting new future strategy stack:
[13:20:27.320] run() for ‘Future’ ...
[13:20:27.320] - state: ‘created’
[13:20:27.320] List of future strategies:
[13:20:27.320] 1. multicore:
[13:20:27.320]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.320]    - tweaked: FALSE
[13:20:27.320]    - call: plan(strategy)
[13:20:27.320] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.325] plan(): nbrOfWorkers() = 2
[13:20:27.326] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.326] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.326]   - Field: ‘label’
[13:20:27.326]   - Field: ‘local’
[13:20:27.326]   - Field: ‘owner’
[13:20:27.326]   - Field: ‘envir’
[13:20:27.327]   - Field: ‘workers’
[13:20:27.327]   - Field: ‘packages’
[13:20:27.327]   - Field: ‘gc’
[13:20:27.327]   - Field: ‘job’
[13:20:27.327]   - Field: ‘conditions’
[13:20:27.327]   - Field: ‘expr’
[13:20:27.327]   - Field: ‘uuid’
[13:20:27.328]   - Field: ‘seed’
[13:20:27.328]   - Field: ‘version’
[13:20:27.328]   - Field: ‘result’
[13:20:27.328]   - Field: ‘asynchronous’
[13:20:27.328]   - Field: ‘calls’
[13:20:27.328]   - Field: ‘globals’
[13:20:27.328]   - Field: ‘stdout’
[13:20:27.328]   - Field: ‘earlySignal’
[13:20:27.329]   - Field: ‘lazy’
[13:20:27.329]   - Field: ‘state’
[13:20:27.329] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.329] - Launch lazy future ...
[13:20:27.330] Packages needed by the future expression (n = 0): <none>
[13:20:27.330] Packages needed by future strategies (n = 0): <none>
[13:20:27.330] {
[13:20:27.330]     {
[13:20:27.330]         {
[13:20:27.330]             ...future.startTime <- base::Sys.time()
[13:20:27.330]             {
[13:20:27.330]                 {
[13:20:27.330]                   {
[13:20:27.330]                     {
[13:20:27.330]                       base::local({
[13:20:27.330]                         has_future <- base::requireNamespace("future", 
[13:20:27.330]                           quietly = TRUE)
[13:20:27.330]                         if (has_future) {
[13:20:27.330]                           ns <- base::getNamespace("future")
[13:20:27.330]                           version <- ns[[".package"]][["version"]]
[13:20:27.330]                           if (is.null(version)) 
[13:20:27.330]                             version <- utils::packageVersion("future")
[13:20:27.330]                         }
[13:20:27.330]                         else {
[13:20:27.330]                           version <- NULL
[13:20:27.330]                         }
[13:20:27.330]                         if (!has_future || version < "1.8.0") {
[13:20:27.330]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.330]                             "", base::R.version$version.string), 
[13:20:27.330]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.330]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.330]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.330]                               "release", "version")], collapse = " "), 
[13:20:27.330]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.330]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.330]                             info)
[13:20:27.330]                           info <- base::paste(info, collapse = "; ")
[13:20:27.330]                           if (!has_future) {
[13:20:27.330]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.330]                               info)
[13:20:27.330]                           }
[13:20:27.330]                           else {
[13:20:27.330]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.330]                               info, version)
[13:20:27.330]                           }
[13:20:27.330]                           base::stop(msg)
[13:20:27.330]                         }
[13:20:27.330]                       })
[13:20:27.330]                     }
[13:20:27.330]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.330]                     base::options(mc.cores = 1L)
[13:20:27.330]                   }
[13:20:27.330]                   options(future.plan = NULL)
[13:20:27.330]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.330]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.330]                 }
[13:20:27.330]                 ...future.workdir <- getwd()
[13:20:27.330]             }
[13:20:27.330]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.330]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.330]         }
[13:20:27.330]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.330]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.330]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.330]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.330]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.330]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.330]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.330]             base::names(...future.oldOptions))
[13:20:27.330]     }
[13:20:27.330]     if (FALSE) {
[13:20:27.330]     }
[13:20:27.330]     else {
[13:20:27.330]         if (TRUE) {
[13:20:27.330]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.330]                 open = "w")
[13:20:27.330]         }
[13:20:27.330]         else {
[13:20:27.330]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.330]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.330]         }
[13:20:27.330]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.330]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.330]             base::sink(type = "output", split = FALSE)
[13:20:27.330]             base::close(...future.stdout)
[13:20:27.330]         }, add = TRUE)
[13:20:27.330]     }
[13:20:27.330]     ...future.frame <- base::sys.nframe()
[13:20:27.330]     ...future.conditions <- base::list()
[13:20:27.330]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.330]     if (FALSE) {
[13:20:27.330]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.330]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.330]     }
[13:20:27.330]     ...future.result <- base::tryCatch({
[13:20:27.330]         base::withCallingHandlers({
[13:20:27.330]             ...future.value <- base::withVisible(base::local({
[13:20:27.330]                 withCallingHandlers({
[13:20:27.330]                   {
[13:20:27.330]                     4
[13:20:27.330]                   }
[13:20:27.330]                 }, immediateCondition = function(cond) {
[13:20:27.330]                   save_rds <- function (object, pathname, ...) 
[13:20:27.330]                   {
[13:20:27.330]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.330]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.330]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.330]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.330]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.330]                         fi_tmp[["mtime"]])
[13:20:27.330]                     }
[13:20:27.330]                     tryCatch({
[13:20:27.330]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.330]                     }, error = function(ex) {
[13:20:27.330]                       msg <- conditionMessage(ex)
[13:20:27.330]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.330]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.330]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.330]                         fi_tmp[["mtime"]], msg)
[13:20:27.330]                       ex$message <- msg
[13:20:27.330]                       stop(ex)
[13:20:27.330]                     })
[13:20:27.330]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.330]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.330]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.330]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.330]                       fi <- file.info(pathname)
[13:20:27.330]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.330]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.330]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.330]                         fi[["size"]], fi[["mtime"]])
[13:20:27.330]                       stop(msg)
[13:20:27.330]                     }
[13:20:27.330]                     invisible(pathname)
[13:20:27.330]                   }
[13:20:27.330]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.330]                     rootPath = tempdir()) 
[13:20:27.330]                   {
[13:20:27.330]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.330]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.330]                       tmpdir = path, fileext = ".rds")
[13:20:27.330]                     save_rds(obj, file)
[13:20:27.330]                   }
[13:20:27.330]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.330]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.330]                   {
[13:20:27.330]                     inherits <- base::inherits
[13:20:27.330]                     invokeRestart <- base::invokeRestart
[13:20:27.330]                     is.null <- base::is.null
[13:20:27.330]                     muffled <- FALSE
[13:20:27.330]                     if (inherits(cond, "message")) {
[13:20:27.330]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.330]                       if (muffled) 
[13:20:27.330]                         invokeRestart("muffleMessage")
[13:20:27.330]                     }
[13:20:27.330]                     else if (inherits(cond, "warning")) {
[13:20:27.330]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.330]                       if (muffled) 
[13:20:27.330]                         invokeRestart("muffleWarning")
[13:20:27.330]                     }
[13:20:27.330]                     else if (inherits(cond, "condition")) {
[13:20:27.330]                       if (!is.null(pattern)) {
[13:20:27.330]                         computeRestarts <- base::computeRestarts
[13:20:27.330]                         grepl <- base::grepl
[13:20:27.330]                         restarts <- computeRestarts(cond)
[13:20:27.330]                         for (restart in restarts) {
[13:20:27.330]                           name <- restart$name
[13:20:27.330]                           if (is.null(name)) 
[13:20:27.330]                             next
[13:20:27.330]                           if (!grepl(pattern, name)) 
[13:20:27.330]                             next
[13:20:27.330]                           invokeRestart(restart)
[13:20:27.330]                           muffled <- TRUE
[13:20:27.330]                           break
[13:20:27.330]                         }
[13:20:27.330]                       }
[13:20:27.330]                     }
[13:20:27.330]                     invisible(muffled)
[13:20:27.330]                   }
[13:20:27.330]                   muffleCondition(cond)
[13:20:27.330]                 })
[13:20:27.330]             }))
[13:20:27.330]             future::FutureResult(value = ...future.value$value, 
[13:20:27.330]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.330]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.330]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.330]                     ...future.globalenv.names))
[13:20:27.330]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.330]         }, condition = base::local({
[13:20:27.330]             c <- base::c
[13:20:27.330]             inherits <- base::inherits
[13:20:27.330]             invokeRestart <- base::invokeRestart
[13:20:27.330]             length <- base::length
[13:20:27.330]             list <- base::list
[13:20:27.330]             seq.int <- base::seq.int
[13:20:27.330]             signalCondition <- base::signalCondition
[13:20:27.330]             sys.calls <- base::sys.calls
[13:20:27.330]             `[[` <- base::`[[`
[13:20:27.330]             `+` <- base::`+`
[13:20:27.330]             `<<-` <- base::`<<-`
[13:20:27.330]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.330]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.330]                   3L)]
[13:20:27.330]             }
[13:20:27.330]             function(cond) {
[13:20:27.330]                 is_error <- inherits(cond, "error")
[13:20:27.330]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.330]                   NULL)
[13:20:27.330]                 if (is_error) {
[13:20:27.330]                   sessionInformation <- function() {
[13:20:27.330]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.330]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.330]                       search = base::search(), system = base::Sys.info())
[13:20:27.330]                   }
[13:20:27.330]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.330]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.330]                     cond$call), session = sessionInformation(), 
[13:20:27.330]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.330]                   signalCondition(cond)
[13:20:27.330]                 }
[13:20:27.330]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.330]                 "immediateCondition"))) {
[13:20:27.330]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.330]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.330]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.330]                   if (TRUE && !signal) {
[13:20:27.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.330]                     {
[13:20:27.330]                       inherits <- base::inherits
[13:20:27.330]                       invokeRestart <- base::invokeRestart
[13:20:27.330]                       is.null <- base::is.null
[13:20:27.330]                       muffled <- FALSE
[13:20:27.330]                       if (inherits(cond, "message")) {
[13:20:27.330]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.330]                         if (muffled) 
[13:20:27.330]                           invokeRestart("muffleMessage")
[13:20:27.330]                       }
[13:20:27.330]                       else if (inherits(cond, "warning")) {
[13:20:27.330]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.330]                         if (muffled) 
[13:20:27.330]                           invokeRestart("muffleWarning")
[13:20:27.330]                       }
[13:20:27.330]                       else if (inherits(cond, "condition")) {
[13:20:27.330]                         if (!is.null(pattern)) {
[13:20:27.330]                           computeRestarts <- base::computeRestarts
[13:20:27.330]                           grepl <- base::grepl
[13:20:27.330]                           restarts <- computeRestarts(cond)
[13:20:27.330]                           for (restart in restarts) {
[13:20:27.330]                             name <- restart$name
[13:20:27.330]                             if (is.null(name)) 
[13:20:27.330]                               next
[13:20:27.330]                             if (!grepl(pattern, name)) 
[13:20:27.330]                               next
[13:20:27.330]                             invokeRestart(restart)
[13:20:27.330]                             muffled <- TRUE
[13:20:27.330]                             break
[13:20:27.330]                           }
[13:20:27.330]                         }
[13:20:27.330]                       }
[13:20:27.330]                       invisible(muffled)
[13:20:27.330]                     }
[13:20:27.330]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.330]                   }
[13:20:27.330]                 }
[13:20:27.330]                 else {
[13:20:27.330]                   if (TRUE) {
[13:20:27.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.330]                     {
[13:20:27.330]                       inherits <- base::inherits
[13:20:27.330]                       invokeRestart <- base::invokeRestart
[13:20:27.330]                       is.null <- base::is.null
[13:20:27.330]                       muffled <- FALSE
[13:20:27.330]                       if (inherits(cond, "message")) {
[13:20:27.330]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.330]                         if (muffled) 
[13:20:27.330]                           invokeRestart("muffleMessage")
[13:20:27.330]                       }
[13:20:27.330]                       else if (inherits(cond, "warning")) {
[13:20:27.330]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.330]                         if (muffled) 
[13:20:27.330]                           invokeRestart("muffleWarning")
[13:20:27.330]                       }
[13:20:27.330]                       else if (inherits(cond, "condition")) {
[13:20:27.330]                         if (!is.null(pattern)) {
[13:20:27.330]                           computeRestarts <- base::computeRestarts
[13:20:27.330]                           grepl <- base::grepl
[13:20:27.330]                           restarts <- computeRestarts(cond)
[13:20:27.330]                           for (restart in restarts) {
[13:20:27.330]                             name <- restart$name
[13:20:27.330]                             if (is.null(name)) 
[13:20:27.330]                               next
[13:20:27.330]                             if (!grepl(pattern, name)) 
[13:20:27.330]                               next
[13:20:27.330]                             invokeRestart(restart)
[13:20:27.330]                             muffled <- TRUE
[13:20:27.330]                             break
[13:20:27.330]                           }
[13:20:27.330]                         }
[13:20:27.330]                       }
[13:20:27.330]                       invisible(muffled)
[13:20:27.330]                     }
[13:20:27.330]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.330]                   }
[13:20:27.330]                 }
[13:20:27.330]             }
[13:20:27.330]         }))
[13:20:27.330]     }, error = function(ex) {
[13:20:27.330]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.330]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.330]                 ...future.rng), started = ...future.startTime, 
[13:20:27.330]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.330]             version = "1.8"), class = "FutureResult")
[13:20:27.330]     }, finally = {
[13:20:27.330]         if (!identical(...future.workdir, getwd())) 
[13:20:27.330]             setwd(...future.workdir)
[13:20:27.330]         {
[13:20:27.330]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.330]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.330]             }
[13:20:27.330]             base::options(...future.oldOptions)
[13:20:27.330]             if (.Platform$OS.type == "windows") {
[13:20:27.330]                 old_names <- names(...future.oldEnvVars)
[13:20:27.330]                 envs <- base::Sys.getenv()
[13:20:27.330]                 names <- names(envs)
[13:20:27.330]                 common <- intersect(names, old_names)
[13:20:27.330]                 added <- setdiff(names, old_names)
[13:20:27.330]                 removed <- setdiff(old_names, names)
[13:20:27.330]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.330]                   envs[common]]
[13:20:27.330]                 NAMES <- toupper(changed)
[13:20:27.330]                 args <- list()
[13:20:27.330]                 for (kk in seq_along(NAMES)) {
[13:20:27.330]                   name <- changed[[kk]]
[13:20:27.330]                   NAME <- NAMES[[kk]]
[13:20:27.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.330]                     next
[13:20:27.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.330]                 }
[13:20:27.330]                 NAMES <- toupper(added)
[13:20:27.330]                 for (kk in seq_along(NAMES)) {
[13:20:27.330]                   name <- added[[kk]]
[13:20:27.330]                   NAME <- NAMES[[kk]]
[13:20:27.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.330]                     next
[13:20:27.330]                   args[[name]] <- ""
[13:20:27.330]                 }
[13:20:27.330]                 NAMES <- toupper(removed)
[13:20:27.330]                 for (kk in seq_along(NAMES)) {
[13:20:27.330]                   name <- removed[[kk]]
[13:20:27.330]                   NAME <- NAMES[[kk]]
[13:20:27.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.330]                     next
[13:20:27.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.330]                 }
[13:20:27.330]                 if (length(args) > 0) 
[13:20:27.330]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.330]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.330]             }
[13:20:27.330]             else {
[13:20:27.330]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.330]             }
[13:20:27.330]             {
[13:20:27.330]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.330]                   0L) {
[13:20:27.330]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.330]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.330]                   base::options(opts)
[13:20:27.330]                 }
[13:20:27.330]                 {
[13:20:27.330]                   {
[13:20:27.330]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.330]                     NULL
[13:20:27.330]                   }
[13:20:27.330]                   options(future.plan = NULL)
[13:20:27.330]                   if (is.na(NA_character_)) 
[13:20:27.330]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.330]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.330]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.330]                     envir = parent.frame()) 
[13:20:27.330]                   {
[13:20:27.330]                     default_workers <- missing(workers)
[13:20:27.330]                     if (is.function(workers)) 
[13:20:27.330]                       workers <- workers()
[13:20:27.330]                     workers <- structure(as.integer(workers), 
[13:20:27.330]                       class = class(workers))
[13:20:27.330]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.330]                       1L)
[13:20:27.330]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.330]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.330]                       if (default_workers) 
[13:20:27.330]                         supportsMulticore(warn = TRUE)
[13:20:27.330]                       return(sequential(..., envir = envir))
[13:20:27.330]                     }
[13:20:27.330]                     oopts <- options(mc.cores = workers)
[13:20:27.330]                     on.exit(options(oopts))
[13:20:27.330]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.330]                       envir = envir)
[13:20:27.330]                     if (!future$lazy) 
[13:20:27.330]                       future <- run(future)
[13:20:27.330]                     invisible(future)
[13:20:27.330]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.330]                 }
[13:20:27.330]             }
[13:20:27.330]         }
[13:20:27.330]     })
[13:20:27.330]     if (TRUE) {
[13:20:27.330]         base::sink(type = "output", split = FALSE)
[13:20:27.330]         if (TRUE) {
[13:20:27.330]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.330]         }
[13:20:27.330]         else {
[13:20:27.330]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.330]         }
[13:20:27.330]         base::close(...future.stdout)
[13:20:27.330]         ...future.stdout <- NULL
[13:20:27.330]     }
[13:20:27.330]     ...future.result$conditions <- ...future.conditions
[13:20:27.330]     ...future.result$finished <- base::Sys.time()
[13:20:27.330]     ...future.result
[13:20:27.330] }
[13:20:27.333] requestCore(): workers = 2
[13:20:27.334] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:27.354] MulticoreFuture started
[13:20:27.354] - Launch lazy future ... done
[13:20:27.355] run() for ‘MulticoreFuture’ ... done
[13:20:27.355] plan(): Setting new future strategy stack:
<environment: 0x55659d3aead0> 
[13:20:27.356] List of future strategies:
[13:20:27.356] 1. sequential:
[13:20:27.356]    - args: function (..., envir = parent.frame())
[13:20:27.356]    - tweaked: FALSE
[13:20:27.356]    - call: NULL
[13:20:27.357] plan(): nbrOfWorkers() = 1
<environment: 0x55659c3d05c8> 
[13:20:27.359] plan(): Setting new future strategy stack:
[13:20:27.359] List of future strategies:
[13:20:27.359] 1. multicore:
[13:20:27.359]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.359]    - tweaked: FALSE
[13:20:27.359]    - call: plan(strategy)
[13:20:27.364] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:27.367] resolve() on environment ...
[13:20:27.367]  recursive: 0
[13:20:27.368]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:27.368] signalConditionsASAP(numeric, pos=1) ...
[13:20:27.368] - nx: 4
[13:20:27.368] - relay: TRUE
[13:20:27.368] - stdout: TRUE
[13:20:27.368] - signal: TRUE
[13:20:27.368] - resignal: FALSE
[13:20:27.369] - force: TRUE
[13:20:27.369] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.369] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.369]  - until=2
[13:20:27.369]  - relaying element #2
[13:20:27.369] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:27.369] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.370] signalConditionsASAP(NULL, pos=1) ... done
[13:20:27.370]  length: 3 (resolved future 1)
[13:20:27.370] Future #2
[13:20:27.370] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:27.370] - nx: 4
[13:20:27.370] - relay: TRUE
[13:20:27.371] - stdout: TRUE
[13:20:27.371] - signal: TRUE
[13:20:27.371] - resignal: FALSE
[13:20:27.371] - force: TRUE
[13:20:27.371] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:27.371] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.371]  - until=2
[13:20:27.371]  - relaying element #2
[13:20:27.372] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:27.372] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:27.372] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:27.372]  length: 2 (resolved future 2)
[13:20:27.373] Future #3
[13:20:27.374] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:27.374] - nx: 4
[13:20:27.374] - relay: TRUE
[13:20:27.374] - stdout: TRUE
[13:20:27.374] - signal: TRUE
[13:20:27.374] - resignal: FALSE
[13:20:27.375] - force: TRUE
[13:20:27.375] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:27.375] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:27.375]  - until=3
[13:20:27.375]  - relaying element #3
[13:20:27.376] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:27.376] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:27.376] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:27.376]  length: 1 (resolved future 3)
[13:20:27.377] Future #4
[13:20:27.378] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:20:27.378] - nx: 4
[13:20:27.378] - relay: TRUE
[13:20:27.378] - stdout: TRUE
[13:20:27.378] - signal: TRUE
[13:20:27.378] - resignal: FALSE
[13:20:27.379] - force: TRUE
[13:20:27.379] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:27.379] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:27.379]  - until=4
[13:20:27.379]  - relaying element #4
[13:20:27.379] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.379] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:27.380] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:20:27.380]  length: 0 (resolved future 4)
[13:20:27.380] Relaying remaining futures
[13:20:27.380] signalConditionsASAP(NULL, pos=0) ...
[13:20:27.380] - nx: 4
[13:20:27.380] - relay: TRUE
[13:20:27.380] - stdout: TRUE
[13:20:27.380] - signal: TRUE
[13:20:27.380] - resignal: FALSE
[13:20:27.380] - force: TRUE
[13:20:27.381] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.381] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:27.381] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.381] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:27.381] signalConditionsASAP(NULL, pos=0) ... done
[13:20:27.381] resolve() on environment ... DONE
<environment: 0x55659c215210> 
Dimensions: c(1, 6)
[13:20:27.382] getGlobalsAndPackages() ...
[13:20:27.382] Searching for globals...
[13:20:27.382] 
[13:20:27.383] Searching for globals ... DONE
[13:20:27.383] - globals: [0] <none>
[13:20:27.383] getGlobalsAndPackages() ... DONE
[13:20:27.383] run() for ‘Future’ ...
[13:20:27.383] - state: ‘created’
[13:20:27.383] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.387] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.388] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.388]   - Field: ‘label’
[13:20:27.388]   - Field: ‘local’
[13:20:27.388]   - Field: ‘owner’
[13:20:27.388]   - Field: ‘envir’
[13:20:27.388]   - Field: ‘workers’
[13:20:27.388]   - Field: ‘packages’
[13:20:27.388]   - Field: ‘gc’
[13:20:27.389]   - Field: ‘job’
[13:20:27.389]   - Field: ‘conditions’
[13:20:27.389]   - Field: ‘expr’
[13:20:27.389]   - Field: ‘uuid’
[13:20:27.389]   - Field: ‘seed’
[13:20:27.389]   - Field: ‘version’
[13:20:27.389]   - Field: ‘result’
[13:20:27.389]   - Field: ‘asynchronous’
[13:20:27.390]   - Field: ‘calls’
[13:20:27.390]   - Field: ‘globals’
[13:20:27.390]   - Field: ‘stdout’
[13:20:27.390]   - Field: ‘earlySignal’
[13:20:27.390]   - Field: ‘lazy’
[13:20:27.390]   - Field: ‘state’
[13:20:27.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.390] - Launch lazy future ...
[13:20:27.391] Packages needed by the future expression (n = 0): <none>
[13:20:27.391] Packages needed by future strategies (n = 0): <none>
[13:20:27.391] {
[13:20:27.391]     {
[13:20:27.391]         {
[13:20:27.391]             ...future.startTime <- base::Sys.time()
[13:20:27.391]             {
[13:20:27.391]                 {
[13:20:27.391]                   {
[13:20:27.391]                     {
[13:20:27.391]                       base::local({
[13:20:27.391]                         has_future <- base::requireNamespace("future", 
[13:20:27.391]                           quietly = TRUE)
[13:20:27.391]                         if (has_future) {
[13:20:27.391]                           ns <- base::getNamespace("future")
[13:20:27.391]                           version <- ns[[".package"]][["version"]]
[13:20:27.391]                           if (is.null(version)) 
[13:20:27.391]                             version <- utils::packageVersion("future")
[13:20:27.391]                         }
[13:20:27.391]                         else {
[13:20:27.391]                           version <- NULL
[13:20:27.391]                         }
[13:20:27.391]                         if (!has_future || version < "1.8.0") {
[13:20:27.391]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.391]                             "", base::R.version$version.string), 
[13:20:27.391]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.391]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.391]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.391]                               "release", "version")], collapse = " "), 
[13:20:27.391]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.391]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.391]                             info)
[13:20:27.391]                           info <- base::paste(info, collapse = "; ")
[13:20:27.391]                           if (!has_future) {
[13:20:27.391]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.391]                               info)
[13:20:27.391]                           }
[13:20:27.391]                           else {
[13:20:27.391]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.391]                               info, version)
[13:20:27.391]                           }
[13:20:27.391]                           base::stop(msg)
[13:20:27.391]                         }
[13:20:27.391]                       })
[13:20:27.391]                     }
[13:20:27.391]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.391]                     base::options(mc.cores = 1L)
[13:20:27.391]                   }
[13:20:27.391]                   options(future.plan = NULL)
[13:20:27.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.391]                 }
[13:20:27.391]                 ...future.workdir <- getwd()
[13:20:27.391]             }
[13:20:27.391]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.391]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.391]         }
[13:20:27.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.391]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.391]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.391]             base::names(...future.oldOptions))
[13:20:27.391]     }
[13:20:27.391]     if (FALSE) {
[13:20:27.391]     }
[13:20:27.391]     else {
[13:20:27.391]         if (TRUE) {
[13:20:27.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.391]                 open = "w")
[13:20:27.391]         }
[13:20:27.391]         else {
[13:20:27.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.391]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.391]         }
[13:20:27.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.391]             base::sink(type = "output", split = FALSE)
[13:20:27.391]             base::close(...future.stdout)
[13:20:27.391]         }, add = TRUE)
[13:20:27.391]     }
[13:20:27.391]     ...future.frame <- base::sys.nframe()
[13:20:27.391]     ...future.conditions <- base::list()
[13:20:27.391]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.391]     if (FALSE) {
[13:20:27.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.391]     }
[13:20:27.391]     ...future.result <- base::tryCatch({
[13:20:27.391]         base::withCallingHandlers({
[13:20:27.391]             ...future.value <- base::withVisible(base::local({
[13:20:27.391]                 withCallingHandlers({
[13:20:27.391]                   2
[13:20:27.391]                 }, immediateCondition = function(cond) {
[13:20:27.391]                   save_rds <- function (object, pathname, ...) 
[13:20:27.391]                   {
[13:20:27.391]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.391]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.391]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.391]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.391]                         fi_tmp[["mtime"]])
[13:20:27.391]                     }
[13:20:27.391]                     tryCatch({
[13:20:27.391]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.391]                     }, error = function(ex) {
[13:20:27.391]                       msg <- conditionMessage(ex)
[13:20:27.391]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.391]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.391]                         fi_tmp[["mtime"]], msg)
[13:20:27.391]                       ex$message <- msg
[13:20:27.391]                       stop(ex)
[13:20:27.391]                     })
[13:20:27.391]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.391]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.391]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.391]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.391]                       fi <- file.info(pathname)
[13:20:27.391]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.391]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.391]                         fi[["size"]], fi[["mtime"]])
[13:20:27.391]                       stop(msg)
[13:20:27.391]                     }
[13:20:27.391]                     invisible(pathname)
[13:20:27.391]                   }
[13:20:27.391]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.391]                     rootPath = tempdir()) 
[13:20:27.391]                   {
[13:20:27.391]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.391]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.391]                       tmpdir = path, fileext = ".rds")
[13:20:27.391]                     save_rds(obj, file)
[13:20:27.391]                   }
[13:20:27.391]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.391]                   {
[13:20:27.391]                     inherits <- base::inherits
[13:20:27.391]                     invokeRestart <- base::invokeRestart
[13:20:27.391]                     is.null <- base::is.null
[13:20:27.391]                     muffled <- FALSE
[13:20:27.391]                     if (inherits(cond, "message")) {
[13:20:27.391]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.391]                       if (muffled) 
[13:20:27.391]                         invokeRestart("muffleMessage")
[13:20:27.391]                     }
[13:20:27.391]                     else if (inherits(cond, "warning")) {
[13:20:27.391]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.391]                       if (muffled) 
[13:20:27.391]                         invokeRestart("muffleWarning")
[13:20:27.391]                     }
[13:20:27.391]                     else if (inherits(cond, "condition")) {
[13:20:27.391]                       if (!is.null(pattern)) {
[13:20:27.391]                         computeRestarts <- base::computeRestarts
[13:20:27.391]                         grepl <- base::grepl
[13:20:27.391]                         restarts <- computeRestarts(cond)
[13:20:27.391]                         for (restart in restarts) {
[13:20:27.391]                           name <- restart$name
[13:20:27.391]                           if (is.null(name)) 
[13:20:27.391]                             next
[13:20:27.391]                           if (!grepl(pattern, name)) 
[13:20:27.391]                             next
[13:20:27.391]                           invokeRestart(restart)
[13:20:27.391]                           muffled <- TRUE
[13:20:27.391]                           break
[13:20:27.391]                         }
[13:20:27.391]                       }
[13:20:27.391]                     }
[13:20:27.391]                     invisible(muffled)
[13:20:27.391]                   }
[13:20:27.391]                   muffleCondition(cond)
[13:20:27.391]                 })
[13:20:27.391]             }))
[13:20:27.391]             future::FutureResult(value = ...future.value$value, 
[13:20:27.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.391]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.391]                     ...future.globalenv.names))
[13:20:27.391]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.391]         }, condition = base::local({
[13:20:27.391]             c <- base::c
[13:20:27.391]             inherits <- base::inherits
[13:20:27.391]             invokeRestart <- base::invokeRestart
[13:20:27.391]             length <- base::length
[13:20:27.391]             list <- base::list
[13:20:27.391]             seq.int <- base::seq.int
[13:20:27.391]             signalCondition <- base::signalCondition
[13:20:27.391]             sys.calls <- base::sys.calls
[13:20:27.391]             `[[` <- base::`[[`
[13:20:27.391]             `+` <- base::`+`
[13:20:27.391]             `<<-` <- base::`<<-`
[13:20:27.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.391]                   3L)]
[13:20:27.391]             }
[13:20:27.391]             function(cond) {
[13:20:27.391]                 is_error <- inherits(cond, "error")
[13:20:27.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.391]                   NULL)
[13:20:27.391]                 if (is_error) {
[13:20:27.391]                   sessionInformation <- function() {
[13:20:27.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.391]                       search = base::search(), system = base::Sys.info())
[13:20:27.391]                   }
[13:20:27.391]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.391]                     cond$call), session = sessionInformation(), 
[13:20:27.391]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.391]                   signalCondition(cond)
[13:20:27.391]                 }
[13:20:27.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.391]                 "immediateCondition"))) {
[13:20:27.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.391]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.391]                   if (TRUE && !signal) {
[13:20:27.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.391]                     {
[13:20:27.391]                       inherits <- base::inherits
[13:20:27.391]                       invokeRestart <- base::invokeRestart
[13:20:27.391]                       is.null <- base::is.null
[13:20:27.391]                       muffled <- FALSE
[13:20:27.391]                       if (inherits(cond, "message")) {
[13:20:27.391]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.391]                         if (muffled) 
[13:20:27.391]                           invokeRestart("muffleMessage")
[13:20:27.391]                       }
[13:20:27.391]                       else if (inherits(cond, "warning")) {
[13:20:27.391]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.391]                         if (muffled) 
[13:20:27.391]                           invokeRestart("muffleWarning")
[13:20:27.391]                       }
[13:20:27.391]                       else if (inherits(cond, "condition")) {
[13:20:27.391]                         if (!is.null(pattern)) {
[13:20:27.391]                           computeRestarts <- base::computeRestarts
[13:20:27.391]                           grepl <- base::grepl
[13:20:27.391]                           restarts <- computeRestarts(cond)
[13:20:27.391]                           for (restart in restarts) {
[13:20:27.391]                             name <- restart$name
[13:20:27.391]                             if (is.null(name)) 
[13:20:27.391]                               next
[13:20:27.391]                             if (!grepl(pattern, name)) 
[13:20:27.391]                               next
[13:20:27.391]                             invokeRestart(restart)
[13:20:27.391]                             muffled <- TRUE
[13:20:27.391]                             break
[13:20:27.391]                           }
[13:20:27.391]                         }
[13:20:27.391]                       }
[13:20:27.391]                       invisible(muffled)
[13:20:27.391]                     }
[13:20:27.391]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.391]                   }
[13:20:27.391]                 }
[13:20:27.391]                 else {
[13:20:27.391]                   if (TRUE) {
[13:20:27.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.391]                     {
[13:20:27.391]                       inherits <- base::inherits
[13:20:27.391]                       invokeRestart <- base::invokeRestart
[13:20:27.391]                       is.null <- base::is.null
[13:20:27.391]                       muffled <- FALSE
[13:20:27.391]                       if (inherits(cond, "message")) {
[13:20:27.391]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.391]                         if (muffled) 
[13:20:27.391]                           invokeRestart("muffleMessage")
[13:20:27.391]                       }
[13:20:27.391]                       else if (inherits(cond, "warning")) {
[13:20:27.391]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.391]                         if (muffled) 
[13:20:27.391]                           invokeRestart("muffleWarning")
[13:20:27.391]                       }
[13:20:27.391]                       else if (inherits(cond, "condition")) {
[13:20:27.391]                         if (!is.null(pattern)) {
[13:20:27.391]                           computeRestarts <- base::computeRestarts
[13:20:27.391]                           grepl <- base::grepl
[13:20:27.391]                           restarts <- computeRestarts(cond)
[13:20:27.391]                           for (restart in restarts) {
[13:20:27.391]                             name <- restart$name
[13:20:27.391]                             if (is.null(name)) 
[13:20:27.391]                               next
[13:20:27.391]                             if (!grepl(pattern, name)) 
[13:20:27.391]                               next
[13:20:27.391]                             invokeRestart(restart)
[13:20:27.391]                             muffled <- TRUE
[13:20:27.391]                             break
[13:20:27.391]                           }
[13:20:27.391]                         }
[13:20:27.391]                       }
[13:20:27.391]                       invisible(muffled)
[13:20:27.391]                     }
[13:20:27.391]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.391]                   }
[13:20:27.391]                 }
[13:20:27.391]             }
[13:20:27.391]         }))
[13:20:27.391]     }, error = function(ex) {
[13:20:27.391]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.391]                 ...future.rng), started = ...future.startTime, 
[13:20:27.391]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.391]             version = "1.8"), class = "FutureResult")
[13:20:27.391]     }, finally = {
[13:20:27.391]         if (!identical(...future.workdir, getwd())) 
[13:20:27.391]             setwd(...future.workdir)
[13:20:27.391]         {
[13:20:27.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.391]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.391]             }
[13:20:27.391]             base::options(...future.oldOptions)
[13:20:27.391]             if (.Platform$OS.type == "windows") {
[13:20:27.391]                 old_names <- names(...future.oldEnvVars)
[13:20:27.391]                 envs <- base::Sys.getenv()
[13:20:27.391]                 names <- names(envs)
[13:20:27.391]                 common <- intersect(names, old_names)
[13:20:27.391]                 added <- setdiff(names, old_names)
[13:20:27.391]                 removed <- setdiff(old_names, names)
[13:20:27.391]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.391]                   envs[common]]
[13:20:27.391]                 NAMES <- toupper(changed)
[13:20:27.391]                 args <- list()
[13:20:27.391]                 for (kk in seq_along(NAMES)) {
[13:20:27.391]                   name <- changed[[kk]]
[13:20:27.391]                   NAME <- NAMES[[kk]]
[13:20:27.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.391]                     next
[13:20:27.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.391]                 }
[13:20:27.391]                 NAMES <- toupper(added)
[13:20:27.391]                 for (kk in seq_along(NAMES)) {
[13:20:27.391]                   name <- added[[kk]]
[13:20:27.391]                   NAME <- NAMES[[kk]]
[13:20:27.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.391]                     next
[13:20:27.391]                   args[[name]] <- ""
[13:20:27.391]                 }
[13:20:27.391]                 NAMES <- toupper(removed)
[13:20:27.391]                 for (kk in seq_along(NAMES)) {
[13:20:27.391]                   name <- removed[[kk]]
[13:20:27.391]                   NAME <- NAMES[[kk]]
[13:20:27.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.391]                     next
[13:20:27.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.391]                 }
[13:20:27.391]                 if (length(args) > 0) 
[13:20:27.391]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.391]             }
[13:20:27.391]             else {
[13:20:27.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.391]             }
[13:20:27.391]             {
[13:20:27.391]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.391]                   0L) {
[13:20:27.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.391]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.391]                   base::options(opts)
[13:20:27.391]                 }
[13:20:27.391]                 {
[13:20:27.391]                   {
[13:20:27.391]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.391]                     NULL
[13:20:27.391]                   }
[13:20:27.391]                   options(future.plan = NULL)
[13:20:27.391]                   if (is.na(NA_character_)) 
[13:20:27.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.391]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.391]                     envir = parent.frame()) 
[13:20:27.391]                   {
[13:20:27.391]                     default_workers <- missing(workers)
[13:20:27.391]                     if (is.function(workers)) 
[13:20:27.391]                       workers <- workers()
[13:20:27.391]                     workers <- structure(as.integer(workers), 
[13:20:27.391]                       class = class(workers))
[13:20:27.391]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.391]                       1L)
[13:20:27.391]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.391]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.391]                       if (default_workers) 
[13:20:27.391]                         supportsMulticore(warn = TRUE)
[13:20:27.391]                       return(sequential(..., envir = envir))
[13:20:27.391]                     }
[13:20:27.391]                     oopts <- options(mc.cores = workers)
[13:20:27.391]                     on.exit(options(oopts))
[13:20:27.391]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.391]                       envir = envir)
[13:20:27.391]                     if (!future$lazy) 
[13:20:27.391]                       future <- run(future)
[13:20:27.391]                     invisible(future)
[13:20:27.391]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.391]                 }
[13:20:27.391]             }
[13:20:27.391]         }
[13:20:27.391]     })
[13:20:27.391]     if (TRUE) {
[13:20:27.391]         base::sink(type = "output", split = FALSE)
[13:20:27.391]         if (TRUE) {
[13:20:27.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.391]         }
[13:20:27.391]         else {
[13:20:27.391]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.391]         }
[13:20:27.391]         base::close(...future.stdout)
[13:20:27.391]         ...future.stdout <- NULL
[13:20:27.391]     }
[13:20:27.391]     ...future.result$conditions <- ...future.conditions
[13:20:27.391]     ...future.result$finished <- base::Sys.time()
[13:20:27.391]     ...future.result
[13:20:27.391] }
[13:20:27.394] requestCore(): workers = 2
[13:20:27.396] MulticoreFuture started
[13:20:27.397] - Launch lazy future ... done
[13:20:27.397] run() for ‘MulticoreFuture’ ... done
[13:20:27.397] getGlobalsAndPackages() ...
[13:20:27.397] Searching for globals...
[13:20:27.397] plan(): Setting new future strategy stack:
[13:20:27.398] 
[13:20:27.398] List of future strategies:
[13:20:27.398] 1. sequential:
[13:20:27.398]    - args: function (..., envir = parent.frame())
[13:20:27.398]    - tweaked: FALSE
[13:20:27.398]    - call: NULL
[13:20:27.398] Searching for globals ... DONE
[13:20:27.399] plan(): nbrOfWorkers() = 1
[13:20:27.399] - globals: [0] <none>
[13:20:27.399] getGlobalsAndPackages() ... DONE
[13:20:27.400] run() for ‘Future’ ...
[13:20:27.400] - state: ‘created’
[13:20:27.400] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.401] plan(): Setting new future strategy stack:
[13:20:27.401] List of future strategies:
[13:20:27.401] 1. multicore:
[13:20:27.401]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.401]    - tweaked: FALSE
[13:20:27.401]    - call: plan(strategy)
[13:20:27.406] plan(): nbrOfWorkers() = 2
[13:20:27.407] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.407]   - Field: ‘label’
[13:20:27.407]   - Field: ‘local’
[13:20:27.407]   - Field: ‘owner’
[13:20:27.408]   - Field: ‘envir’
[13:20:27.408]   - Field: ‘workers’
[13:20:27.408]   - Field: ‘packages’
[13:20:27.408]   - Field: ‘gc’
[13:20:27.408]   - Field: ‘job’
[13:20:27.409]   - Field: ‘conditions’
[13:20:27.409]   - Field: ‘expr’
[13:20:27.409]   - Field: ‘uuid’
[13:20:27.409]   - Field: ‘seed’
[13:20:27.409]   - Field: ‘version’
[13:20:27.409]   - Field: ‘result’
[13:20:27.410]   - Field: ‘asynchronous’
[13:20:27.410]   - Field: ‘calls’
[13:20:27.410]   - Field: ‘globals’
[13:20:27.410]   - Field: ‘stdout’
[13:20:27.410]   - Field: ‘earlySignal’
[13:20:27.410]   - Field: ‘lazy’
[13:20:27.411]   - Field: ‘state’
[13:20:27.411] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.411] - Launch lazy future ...
[13:20:27.411] Packages needed by the future expression (n = 0): <none>
[13:20:27.412] Packages needed by future strategies (n = 0): <none>
[13:20:27.412] {
[13:20:27.412]     {
[13:20:27.412]         {
[13:20:27.412]             ...future.startTime <- base::Sys.time()
[13:20:27.412]             {
[13:20:27.412]                 {
[13:20:27.412]                   {
[13:20:27.412]                     {
[13:20:27.412]                       base::local({
[13:20:27.412]                         has_future <- base::requireNamespace("future", 
[13:20:27.412]                           quietly = TRUE)
[13:20:27.412]                         if (has_future) {
[13:20:27.412]                           ns <- base::getNamespace("future")
[13:20:27.412]                           version <- ns[[".package"]][["version"]]
[13:20:27.412]                           if (is.null(version)) 
[13:20:27.412]                             version <- utils::packageVersion("future")
[13:20:27.412]                         }
[13:20:27.412]                         else {
[13:20:27.412]                           version <- NULL
[13:20:27.412]                         }
[13:20:27.412]                         if (!has_future || version < "1.8.0") {
[13:20:27.412]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.412]                             "", base::R.version$version.string), 
[13:20:27.412]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.412]                               "release", "version")], collapse = " "), 
[13:20:27.412]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.412]                             info)
[13:20:27.412]                           info <- base::paste(info, collapse = "; ")
[13:20:27.412]                           if (!has_future) {
[13:20:27.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.412]                               info)
[13:20:27.412]                           }
[13:20:27.412]                           else {
[13:20:27.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.412]                               info, version)
[13:20:27.412]                           }
[13:20:27.412]                           base::stop(msg)
[13:20:27.412]                         }
[13:20:27.412]                       })
[13:20:27.412]                     }
[13:20:27.412]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.412]                     base::options(mc.cores = 1L)
[13:20:27.412]                   }
[13:20:27.412]                   options(future.plan = NULL)
[13:20:27.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.412]                 }
[13:20:27.412]                 ...future.workdir <- getwd()
[13:20:27.412]             }
[13:20:27.412]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.412]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.412]         }
[13:20:27.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.412]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.412]             base::names(...future.oldOptions))
[13:20:27.412]     }
[13:20:27.412]     if (FALSE) {
[13:20:27.412]     }
[13:20:27.412]     else {
[13:20:27.412]         if (TRUE) {
[13:20:27.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.412]                 open = "w")
[13:20:27.412]         }
[13:20:27.412]         else {
[13:20:27.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.412]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.412]         }
[13:20:27.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.412]             base::sink(type = "output", split = FALSE)
[13:20:27.412]             base::close(...future.stdout)
[13:20:27.412]         }, add = TRUE)
[13:20:27.412]     }
[13:20:27.412]     ...future.frame <- base::sys.nframe()
[13:20:27.412]     ...future.conditions <- base::list()
[13:20:27.412]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.412]     if (FALSE) {
[13:20:27.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.412]     }
[13:20:27.412]     ...future.result <- base::tryCatch({
[13:20:27.412]         base::withCallingHandlers({
[13:20:27.412]             ...future.value <- base::withVisible(base::local({
[13:20:27.412]                 withCallingHandlers({
[13:20:27.412]                   NULL
[13:20:27.412]                 }, immediateCondition = function(cond) {
[13:20:27.412]                   save_rds <- function (object, pathname, ...) 
[13:20:27.412]                   {
[13:20:27.412]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.412]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.412]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.412]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.412]                         fi_tmp[["mtime"]])
[13:20:27.412]                     }
[13:20:27.412]                     tryCatch({
[13:20:27.412]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.412]                     }, error = function(ex) {
[13:20:27.412]                       msg <- conditionMessage(ex)
[13:20:27.412]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.412]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.412]                         fi_tmp[["mtime"]], msg)
[13:20:27.412]                       ex$message <- msg
[13:20:27.412]                       stop(ex)
[13:20:27.412]                     })
[13:20:27.412]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.412]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.412]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.412]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.412]                       fi <- file.info(pathname)
[13:20:27.412]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.412]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.412]                         fi[["size"]], fi[["mtime"]])
[13:20:27.412]                       stop(msg)
[13:20:27.412]                     }
[13:20:27.412]                     invisible(pathname)
[13:20:27.412]                   }
[13:20:27.412]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.412]                     rootPath = tempdir()) 
[13:20:27.412]                   {
[13:20:27.412]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.412]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.412]                       tmpdir = path, fileext = ".rds")
[13:20:27.412]                     save_rds(obj, file)
[13:20:27.412]                   }
[13:20:27.412]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.412]                   {
[13:20:27.412]                     inherits <- base::inherits
[13:20:27.412]                     invokeRestart <- base::invokeRestart
[13:20:27.412]                     is.null <- base::is.null
[13:20:27.412]                     muffled <- FALSE
[13:20:27.412]                     if (inherits(cond, "message")) {
[13:20:27.412]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.412]                       if (muffled) 
[13:20:27.412]                         invokeRestart("muffleMessage")
[13:20:27.412]                     }
[13:20:27.412]                     else if (inherits(cond, "warning")) {
[13:20:27.412]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.412]                       if (muffled) 
[13:20:27.412]                         invokeRestart("muffleWarning")
[13:20:27.412]                     }
[13:20:27.412]                     else if (inherits(cond, "condition")) {
[13:20:27.412]                       if (!is.null(pattern)) {
[13:20:27.412]                         computeRestarts <- base::computeRestarts
[13:20:27.412]                         grepl <- base::grepl
[13:20:27.412]                         restarts <- computeRestarts(cond)
[13:20:27.412]                         for (restart in restarts) {
[13:20:27.412]                           name <- restart$name
[13:20:27.412]                           if (is.null(name)) 
[13:20:27.412]                             next
[13:20:27.412]                           if (!grepl(pattern, name)) 
[13:20:27.412]                             next
[13:20:27.412]                           invokeRestart(restart)
[13:20:27.412]                           muffled <- TRUE
[13:20:27.412]                           break
[13:20:27.412]                         }
[13:20:27.412]                       }
[13:20:27.412]                     }
[13:20:27.412]                     invisible(muffled)
[13:20:27.412]                   }
[13:20:27.412]                   muffleCondition(cond)
[13:20:27.412]                 })
[13:20:27.412]             }))
[13:20:27.412]             future::FutureResult(value = ...future.value$value, 
[13:20:27.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.412]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.412]                     ...future.globalenv.names))
[13:20:27.412]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.412]         }, condition = base::local({
[13:20:27.412]             c <- base::c
[13:20:27.412]             inherits <- base::inherits
[13:20:27.412]             invokeRestart <- base::invokeRestart
[13:20:27.412]             length <- base::length
[13:20:27.412]             list <- base::list
[13:20:27.412]             seq.int <- base::seq.int
[13:20:27.412]             signalCondition <- base::signalCondition
[13:20:27.412]             sys.calls <- base::sys.calls
[13:20:27.412]             `[[` <- base::`[[`
[13:20:27.412]             `+` <- base::`+`
[13:20:27.412]             `<<-` <- base::`<<-`
[13:20:27.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.412]                   3L)]
[13:20:27.412]             }
[13:20:27.412]             function(cond) {
[13:20:27.412]                 is_error <- inherits(cond, "error")
[13:20:27.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.412]                   NULL)
[13:20:27.412]                 if (is_error) {
[13:20:27.412]                   sessionInformation <- function() {
[13:20:27.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.412]                       search = base::search(), system = base::Sys.info())
[13:20:27.412]                   }
[13:20:27.412]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.412]                     cond$call), session = sessionInformation(), 
[13:20:27.412]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.412]                   signalCondition(cond)
[13:20:27.412]                 }
[13:20:27.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.412]                 "immediateCondition"))) {
[13:20:27.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.412]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.412]                   if (TRUE && !signal) {
[13:20:27.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.412]                     {
[13:20:27.412]                       inherits <- base::inherits
[13:20:27.412]                       invokeRestart <- base::invokeRestart
[13:20:27.412]                       is.null <- base::is.null
[13:20:27.412]                       muffled <- FALSE
[13:20:27.412]                       if (inherits(cond, "message")) {
[13:20:27.412]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.412]                         if (muffled) 
[13:20:27.412]                           invokeRestart("muffleMessage")
[13:20:27.412]                       }
[13:20:27.412]                       else if (inherits(cond, "warning")) {
[13:20:27.412]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.412]                         if (muffled) 
[13:20:27.412]                           invokeRestart("muffleWarning")
[13:20:27.412]                       }
[13:20:27.412]                       else if (inherits(cond, "condition")) {
[13:20:27.412]                         if (!is.null(pattern)) {
[13:20:27.412]                           computeRestarts <- base::computeRestarts
[13:20:27.412]                           grepl <- base::grepl
[13:20:27.412]                           restarts <- computeRestarts(cond)
[13:20:27.412]                           for (restart in restarts) {
[13:20:27.412]                             name <- restart$name
[13:20:27.412]                             if (is.null(name)) 
[13:20:27.412]                               next
[13:20:27.412]                             if (!grepl(pattern, name)) 
[13:20:27.412]                               next
[13:20:27.412]                             invokeRestart(restart)
[13:20:27.412]                             muffled <- TRUE
[13:20:27.412]                             break
[13:20:27.412]                           }
[13:20:27.412]                         }
[13:20:27.412]                       }
[13:20:27.412]                       invisible(muffled)
[13:20:27.412]                     }
[13:20:27.412]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.412]                   }
[13:20:27.412]                 }
[13:20:27.412]                 else {
[13:20:27.412]                   if (TRUE) {
[13:20:27.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.412]                     {
[13:20:27.412]                       inherits <- base::inherits
[13:20:27.412]                       invokeRestart <- base::invokeRestart
[13:20:27.412]                       is.null <- base::is.null
[13:20:27.412]                       muffled <- FALSE
[13:20:27.412]                       if (inherits(cond, "message")) {
[13:20:27.412]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.412]                         if (muffled) 
[13:20:27.412]                           invokeRestart("muffleMessage")
[13:20:27.412]                       }
[13:20:27.412]                       else if (inherits(cond, "warning")) {
[13:20:27.412]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.412]                         if (muffled) 
[13:20:27.412]                           invokeRestart("muffleWarning")
[13:20:27.412]                       }
[13:20:27.412]                       else if (inherits(cond, "condition")) {
[13:20:27.412]                         if (!is.null(pattern)) {
[13:20:27.412]                           computeRestarts <- base::computeRestarts
[13:20:27.412]                           grepl <- base::grepl
[13:20:27.412]                           restarts <- computeRestarts(cond)
[13:20:27.412]                           for (restart in restarts) {
[13:20:27.412]                             name <- restart$name
[13:20:27.412]                             if (is.null(name)) 
[13:20:27.412]                               next
[13:20:27.412]                             if (!grepl(pattern, name)) 
[13:20:27.412]                               next
[13:20:27.412]                             invokeRestart(restart)
[13:20:27.412]                             muffled <- TRUE
[13:20:27.412]                             break
[13:20:27.412]                           }
[13:20:27.412]                         }
[13:20:27.412]                       }
[13:20:27.412]                       invisible(muffled)
[13:20:27.412]                     }
[13:20:27.412]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.412]                   }
[13:20:27.412]                 }
[13:20:27.412]             }
[13:20:27.412]         }))
[13:20:27.412]     }, error = function(ex) {
[13:20:27.412]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.412]                 ...future.rng), started = ...future.startTime, 
[13:20:27.412]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.412]             version = "1.8"), class = "FutureResult")
[13:20:27.412]     }, finally = {
[13:20:27.412]         if (!identical(...future.workdir, getwd())) 
[13:20:27.412]             setwd(...future.workdir)
[13:20:27.412]         {
[13:20:27.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.412]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.412]             }
[13:20:27.412]             base::options(...future.oldOptions)
[13:20:27.412]             if (.Platform$OS.type == "windows") {
[13:20:27.412]                 old_names <- names(...future.oldEnvVars)
[13:20:27.412]                 envs <- base::Sys.getenv()
[13:20:27.412]                 names <- names(envs)
[13:20:27.412]                 common <- intersect(names, old_names)
[13:20:27.412]                 added <- setdiff(names, old_names)
[13:20:27.412]                 removed <- setdiff(old_names, names)
[13:20:27.412]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.412]                   envs[common]]
[13:20:27.412]                 NAMES <- toupper(changed)
[13:20:27.412]                 args <- list()
[13:20:27.412]                 for (kk in seq_along(NAMES)) {
[13:20:27.412]                   name <- changed[[kk]]
[13:20:27.412]                   NAME <- NAMES[[kk]]
[13:20:27.412]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.412]                     next
[13:20:27.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.412]                 }
[13:20:27.412]                 NAMES <- toupper(added)
[13:20:27.412]                 for (kk in seq_along(NAMES)) {
[13:20:27.412]                   name <- added[[kk]]
[13:20:27.412]                   NAME <- NAMES[[kk]]
[13:20:27.412]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.412]                     next
[13:20:27.412]                   args[[name]] <- ""
[13:20:27.412]                 }
[13:20:27.412]                 NAMES <- toupper(removed)
[13:20:27.412]                 for (kk in seq_along(NAMES)) {
[13:20:27.412]                   name <- removed[[kk]]
[13:20:27.412]                   NAME <- NAMES[[kk]]
[13:20:27.412]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.412]                     next
[13:20:27.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.412]                 }
[13:20:27.412]                 if (length(args) > 0) 
[13:20:27.412]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.412]             }
[13:20:27.412]             else {
[13:20:27.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.412]             }
[13:20:27.412]             {
[13:20:27.412]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.412]                   0L) {
[13:20:27.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.412]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.412]                   base::options(opts)
[13:20:27.412]                 }
[13:20:27.412]                 {
[13:20:27.412]                   {
[13:20:27.412]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.412]                     NULL
[13:20:27.412]                   }
[13:20:27.412]                   options(future.plan = NULL)
[13:20:27.412]                   if (is.na(NA_character_)) 
[13:20:27.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.412]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.412]                     envir = parent.frame()) 
[13:20:27.412]                   {
[13:20:27.412]                     default_workers <- missing(workers)
[13:20:27.412]                     if (is.function(workers)) 
[13:20:27.412]                       workers <- workers()
[13:20:27.412]                     workers <- structure(as.integer(workers), 
[13:20:27.412]                       class = class(workers))
[13:20:27.412]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.412]                       1L)
[13:20:27.412]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.412]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.412]                       if (default_workers) 
[13:20:27.412]                         supportsMulticore(warn = TRUE)
[13:20:27.412]                       return(sequential(..., envir = envir))
[13:20:27.412]                     }
[13:20:27.412]                     oopts <- options(mc.cores = workers)
[13:20:27.412]                     on.exit(options(oopts))
[13:20:27.412]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.412]                       envir = envir)
[13:20:27.412]                     if (!future$lazy) 
[13:20:27.412]                       future <- run(future)
[13:20:27.412]                     invisible(future)
[13:20:27.412]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.412]                 }
[13:20:27.412]             }
[13:20:27.412]         }
[13:20:27.412]     })
[13:20:27.412]     if (TRUE) {
[13:20:27.412]         base::sink(type = "output", split = FALSE)
[13:20:27.412]         if (TRUE) {
[13:20:27.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.412]         }
[13:20:27.412]         else {
[13:20:27.412]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.412]         }
[13:20:27.412]         base::close(...future.stdout)
[13:20:27.412]         ...future.stdout <- NULL
[13:20:27.412]     }
[13:20:27.412]     ...future.result$conditions <- ...future.conditions
[13:20:27.412]     ...future.result$finished <- base::Sys.time()
[13:20:27.412]     ...future.result
[13:20:27.412] }
[13:20:27.416] requestCore(): workers = 2
[13:20:27.419] MulticoreFuture started
[13:20:27.420] - Launch lazy future ... done
[13:20:27.420] run() for ‘MulticoreFuture’ ... done
[13:20:27.420] plan(): Setting new future strategy stack:
[13:20:27.421] getGlobalsAndPackages() ...
[13:20:27.421] Searching for globals...
[13:20:27.421] List of future strategies:
[13:20:27.421] 1. sequential:
[13:20:27.421]    - args: function (..., envir = parent.frame())
[13:20:27.421]    - tweaked: FALSE
[13:20:27.421]    - call: NULL
[13:20:27.422] plan(): nbrOfWorkers() = 1
[13:20:27.422] - globals found: [1] ‘{’
[13:20:27.423] Searching for globals ... DONE
[13:20:27.423] Resolving globals: FALSE
[13:20:27.423] 
[13:20:27.423] 
[13:20:27.424] getGlobalsAndPackages() ... DONE
[13:20:27.424] plan(): Setting new future strategy stack:
[13:20:27.424] run() for ‘Future’ ...
[13:20:27.424] - state: ‘created’
[13:20:27.424] List of future strategies:
[13:20:27.424] 1. multicore:
[13:20:27.424]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.424]    - tweaked: FALSE
[13:20:27.424]    - call: plan(strategy)
[13:20:27.424] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.430] plan(): nbrOfWorkers() = 2
[13:20:27.430] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.430]   - Field: ‘label’
[13:20:27.430]   - Field: ‘local’
[13:20:27.430]   - Field: ‘owner’
[13:20:27.431]   - Field: ‘envir’
[13:20:27.431]   - Field: ‘workers’
[13:20:27.431]   - Field: ‘packages’
[13:20:27.431]   - Field: ‘gc’
[13:20:27.431]   - Field: ‘job’
[13:20:27.431]   - Field: ‘conditions’
[13:20:27.432]   - Field: ‘expr’
[13:20:27.432]   - Field: ‘uuid’
[13:20:27.432]   - Field: ‘seed’
[13:20:27.432]   - Field: ‘version’
[13:20:27.432]   - Field: ‘result’
[13:20:27.432]   - Field: ‘asynchronous’
[13:20:27.432]   - Field: ‘calls’
[13:20:27.433]   - Field: ‘globals’
[13:20:27.433]   - Field: ‘stdout’
[13:20:27.433]   - Field: ‘earlySignal’
[13:20:27.433]   - Field: ‘lazy’
[13:20:27.433]   - Field: ‘state’
[13:20:27.433] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.433] - Launch lazy future ...
[13:20:27.434] Packages needed by the future expression (n = 0): <none>
[13:20:27.434] Packages needed by future strategies (n = 0): <none>
[13:20:27.435] {
[13:20:27.435]     {
[13:20:27.435]         {
[13:20:27.435]             ...future.startTime <- base::Sys.time()
[13:20:27.435]             {
[13:20:27.435]                 {
[13:20:27.435]                   {
[13:20:27.435]                     {
[13:20:27.435]                       base::local({
[13:20:27.435]                         has_future <- base::requireNamespace("future", 
[13:20:27.435]                           quietly = TRUE)
[13:20:27.435]                         if (has_future) {
[13:20:27.435]                           ns <- base::getNamespace("future")
[13:20:27.435]                           version <- ns[[".package"]][["version"]]
[13:20:27.435]                           if (is.null(version)) 
[13:20:27.435]                             version <- utils::packageVersion("future")
[13:20:27.435]                         }
[13:20:27.435]                         else {
[13:20:27.435]                           version <- NULL
[13:20:27.435]                         }
[13:20:27.435]                         if (!has_future || version < "1.8.0") {
[13:20:27.435]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.435]                             "", base::R.version$version.string), 
[13:20:27.435]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.435]                               "release", "version")], collapse = " "), 
[13:20:27.435]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.435]                             info)
[13:20:27.435]                           info <- base::paste(info, collapse = "; ")
[13:20:27.435]                           if (!has_future) {
[13:20:27.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.435]                               info)
[13:20:27.435]                           }
[13:20:27.435]                           else {
[13:20:27.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.435]                               info, version)
[13:20:27.435]                           }
[13:20:27.435]                           base::stop(msg)
[13:20:27.435]                         }
[13:20:27.435]                       })
[13:20:27.435]                     }
[13:20:27.435]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.435]                     base::options(mc.cores = 1L)
[13:20:27.435]                   }
[13:20:27.435]                   options(future.plan = NULL)
[13:20:27.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.435]                 }
[13:20:27.435]                 ...future.workdir <- getwd()
[13:20:27.435]             }
[13:20:27.435]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.435]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.435]         }
[13:20:27.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.435]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.435]             base::names(...future.oldOptions))
[13:20:27.435]     }
[13:20:27.435]     if (FALSE) {
[13:20:27.435]     }
[13:20:27.435]     else {
[13:20:27.435]         if (TRUE) {
[13:20:27.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.435]                 open = "w")
[13:20:27.435]         }
[13:20:27.435]         else {
[13:20:27.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.435]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.435]         }
[13:20:27.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.435]             base::sink(type = "output", split = FALSE)
[13:20:27.435]             base::close(...future.stdout)
[13:20:27.435]         }, add = TRUE)
[13:20:27.435]     }
[13:20:27.435]     ...future.frame <- base::sys.nframe()
[13:20:27.435]     ...future.conditions <- base::list()
[13:20:27.435]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.435]     if (FALSE) {
[13:20:27.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.435]     }
[13:20:27.435]     ...future.result <- base::tryCatch({
[13:20:27.435]         base::withCallingHandlers({
[13:20:27.435]             ...future.value <- base::withVisible(base::local({
[13:20:27.435]                 withCallingHandlers({
[13:20:27.435]                   {
[13:20:27.435]                     4
[13:20:27.435]                   }
[13:20:27.435]                 }, immediateCondition = function(cond) {
[13:20:27.435]                   save_rds <- function (object, pathname, ...) 
[13:20:27.435]                   {
[13:20:27.435]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.435]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.435]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.435]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.435]                         fi_tmp[["mtime"]])
[13:20:27.435]                     }
[13:20:27.435]                     tryCatch({
[13:20:27.435]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.435]                     }, error = function(ex) {
[13:20:27.435]                       msg <- conditionMessage(ex)
[13:20:27.435]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.435]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.435]                         fi_tmp[["mtime"]], msg)
[13:20:27.435]                       ex$message <- msg
[13:20:27.435]                       stop(ex)
[13:20:27.435]                     })
[13:20:27.435]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.435]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.435]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.435]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.435]                       fi <- file.info(pathname)
[13:20:27.435]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.435]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.435]                         fi[["size"]], fi[["mtime"]])
[13:20:27.435]                       stop(msg)
[13:20:27.435]                     }
[13:20:27.435]                     invisible(pathname)
[13:20:27.435]                   }
[13:20:27.435]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.435]                     rootPath = tempdir()) 
[13:20:27.435]                   {
[13:20:27.435]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.435]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.435]                       tmpdir = path, fileext = ".rds")
[13:20:27.435]                     save_rds(obj, file)
[13:20:27.435]                   }
[13:20:27.435]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.435]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.435]                   {
[13:20:27.435]                     inherits <- base::inherits
[13:20:27.435]                     invokeRestart <- base::invokeRestart
[13:20:27.435]                     is.null <- base::is.null
[13:20:27.435]                     muffled <- FALSE
[13:20:27.435]                     if (inherits(cond, "message")) {
[13:20:27.435]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.435]                       if (muffled) 
[13:20:27.435]                         invokeRestart("muffleMessage")
[13:20:27.435]                     }
[13:20:27.435]                     else if (inherits(cond, "warning")) {
[13:20:27.435]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.435]                       if (muffled) 
[13:20:27.435]                         invokeRestart("muffleWarning")
[13:20:27.435]                     }
[13:20:27.435]                     else if (inherits(cond, "condition")) {
[13:20:27.435]                       if (!is.null(pattern)) {
[13:20:27.435]                         computeRestarts <- base::computeRestarts
[13:20:27.435]                         grepl <- base::grepl
[13:20:27.435]                         restarts <- computeRestarts(cond)
[13:20:27.435]                         for (restart in restarts) {
[13:20:27.435]                           name <- restart$name
[13:20:27.435]                           if (is.null(name)) 
[13:20:27.435]                             next
[13:20:27.435]                           if (!grepl(pattern, name)) 
[13:20:27.435]                             next
[13:20:27.435]                           invokeRestart(restart)
[13:20:27.435]                           muffled <- TRUE
[13:20:27.435]                           break
[13:20:27.435]                         }
[13:20:27.435]                       }
[13:20:27.435]                     }
[13:20:27.435]                     invisible(muffled)
[13:20:27.435]                   }
[13:20:27.435]                   muffleCondition(cond)
[13:20:27.435]                 })
[13:20:27.435]             }))
[13:20:27.435]             future::FutureResult(value = ...future.value$value, 
[13:20:27.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.435]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.435]                     ...future.globalenv.names))
[13:20:27.435]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.435]         }, condition = base::local({
[13:20:27.435]             c <- base::c
[13:20:27.435]             inherits <- base::inherits
[13:20:27.435]             invokeRestart <- base::invokeRestart
[13:20:27.435]             length <- base::length
[13:20:27.435]             list <- base::list
[13:20:27.435]             seq.int <- base::seq.int
[13:20:27.435]             signalCondition <- base::signalCondition
[13:20:27.435]             sys.calls <- base::sys.calls
[13:20:27.435]             `[[` <- base::`[[`
[13:20:27.435]             `+` <- base::`+`
[13:20:27.435]             `<<-` <- base::`<<-`
[13:20:27.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.435]                   3L)]
[13:20:27.435]             }
[13:20:27.435]             function(cond) {
[13:20:27.435]                 is_error <- inherits(cond, "error")
[13:20:27.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.435]                   NULL)
[13:20:27.435]                 if (is_error) {
[13:20:27.435]                   sessionInformation <- function() {
[13:20:27.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.435]                       search = base::search(), system = base::Sys.info())
[13:20:27.435]                   }
[13:20:27.435]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.435]                     cond$call), session = sessionInformation(), 
[13:20:27.435]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.435]                   signalCondition(cond)
[13:20:27.435]                 }
[13:20:27.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.435]                 "immediateCondition"))) {
[13:20:27.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.435]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.435]                   if (TRUE && !signal) {
[13:20:27.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.435]                     {
[13:20:27.435]                       inherits <- base::inherits
[13:20:27.435]                       invokeRestart <- base::invokeRestart
[13:20:27.435]                       is.null <- base::is.null
[13:20:27.435]                       muffled <- FALSE
[13:20:27.435]                       if (inherits(cond, "message")) {
[13:20:27.435]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.435]                         if (muffled) 
[13:20:27.435]                           invokeRestart("muffleMessage")
[13:20:27.435]                       }
[13:20:27.435]                       else if (inherits(cond, "warning")) {
[13:20:27.435]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.435]                         if (muffled) 
[13:20:27.435]                           invokeRestart("muffleWarning")
[13:20:27.435]                       }
[13:20:27.435]                       else if (inherits(cond, "condition")) {
[13:20:27.435]                         if (!is.null(pattern)) {
[13:20:27.435]                           computeRestarts <- base::computeRestarts
[13:20:27.435]                           grepl <- base::grepl
[13:20:27.435]                           restarts <- computeRestarts(cond)
[13:20:27.435]                           for (restart in restarts) {
[13:20:27.435]                             name <- restart$name
[13:20:27.435]                             if (is.null(name)) 
[13:20:27.435]                               next
[13:20:27.435]                             if (!grepl(pattern, name)) 
[13:20:27.435]                               next
[13:20:27.435]                             invokeRestart(restart)
[13:20:27.435]                             muffled <- TRUE
[13:20:27.435]                             break
[13:20:27.435]                           }
[13:20:27.435]                         }
[13:20:27.435]                       }
[13:20:27.435]                       invisible(muffled)
[13:20:27.435]                     }
[13:20:27.435]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.435]                   }
[13:20:27.435]                 }
[13:20:27.435]                 else {
[13:20:27.435]                   if (TRUE) {
[13:20:27.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.435]                     {
[13:20:27.435]                       inherits <- base::inherits
[13:20:27.435]                       invokeRestart <- base::invokeRestart
[13:20:27.435]                       is.null <- base::is.null
[13:20:27.435]                       muffled <- FALSE
[13:20:27.435]                       if (inherits(cond, "message")) {
[13:20:27.435]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.435]                         if (muffled) 
[13:20:27.435]                           invokeRestart("muffleMessage")
[13:20:27.435]                       }
[13:20:27.435]                       else if (inherits(cond, "warning")) {
[13:20:27.435]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.435]                         if (muffled) 
[13:20:27.435]                           invokeRestart("muffleWarning")
[13:20:27.435]                       }
[13:20:27.435]                       else if (inherits(cond, "condition")) {
[13:20:27.435]                         if (!is.null(pattern)) {
[13:20:27.435]                           computeRestarts <- base::computeRestarts
[13:20:27.435]                           grepl <- base::grepl
[13:20:27.435]                           restarts <- computeRestarts(cond)
[13:20:27.435]                           for (restart in restarts) {
[13:20:27.435]                             name <- restart$name
[13:20:27.435]                             if (is.null(name)) 
[13:20:27.435]                               next
[13:20:27.435]                             if (!grepl(pattern, name)) 
[13:20:27.435]                               next
[13:20:27.435]                             invokeRestart(restart)
[13:20:27.435]                             muffled <- TRUE
[13:20:27.435]                             break
[13:20:27.435]                           }
[13:20:27.435]                         }
[13:20:27.435]                       }
[13:20:27.435]                       invisible(muffled)
[13:20:27.435]                     }
[13:20:27.435]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.435]                   }
[13:20:27.435]                 }
[13:20:27.435]             }
[13:20:27.435]         }))
[13:20:27.435]     }, error = function(ex) {
[13:20:27.435]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.435]                 ...future.rng), started = ...future.startTime, 
[13:20:27.435]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.435]             version = "1.8"), class = "FutureResult")
[13:20:27.435]     }, finally = {
[13:20:27.435]         if (!identical(...future.workdir, getwd())) 
[13:20:27.435]             setwd(...future.workdir)
[13:20:27.435]         {
[13:20:27.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.435]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.435]             }
[13:20:27.435]             base::options(...future.oldOptions)
[13:20:27.435]             if (.Platform$OS.type == "windows") {
[13:20:27.435]                 old_names <- names(...future.oldEnvVars)
[13:20:27.435]                 envs <- base::Sys.getenv()
[13:20:27.435]                 names <- names(envs)
[13:20:27.435]                 common <- intersect(names, old_names)
[13:20:27.435]                 added <- setdiff(names, old_names)
[13:20:27.435]                 removed <- setdiff(old_names, names)
[13:20:27.435]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.435]                   envs[common]]
[13:20:27.435]                 NAMES <- toupper(changed)
[13:20:27.435]                 args <- list()
[13:20:27.435]                 for (kk in seq_along(NAMES)) {
[13:20:27.435]                   name <- changed[[kk]]
[13:20:27.435]                   NAME <- NAMES[[kk]]
[13:20:27.435]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.435]                     next
[13:20:27.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.435]                 }
[13:20:27.435]                 NAMES <- toupper(added)
[13:20:27.435]                 for (kk in seq_along(NAMES)) {
[13:20:27.435]                   name <- added[[kk]]
[13:20:27.435]                   NAME <- NAMES[[kk]]
[13:20:27.435]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.435]                     next
[13:20:27.435]                   args[[name]] <- ""
[13:20:27.435]                 }
[13:20:27.435]                 NAMES <- toupper(removed)
[13:20:27.435]                 for (kk in seq_along(NAMES)) {
[13:20:27.435]                   name <- removed[[kk]]
[13:20:27.435]                   NAME <- NAMES[[kk]]
[13:20:27.435]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.435]                     next
[13:20:27.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.435]                 }
[13:20:27.435]                 if (length(args) > 0) 
[13:20:27.435]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.435]             }
[13:20:27.435]             else {
[13:20:27.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.435]             }
[13:20:27.435]             {
[13:20:27.435]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.435]                   0L) {
[13:20:27.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.435]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.435]                   base::options(opts)
[13:20:27.435]                 }
[13:20:27.435]                 {
[13:20:27.435]                   {
[13:20:27.435]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.435]                     NULL
[13:20:27.435]                   }
[13:20:27.435]                   options(future.plan = NULL)
[13:20:27.435]                   if (is.na(NA_character_)) 
[13:20:27.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.435]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.435]                     envir = parent.frame()) 
[13:20:27.435]                   {
[13:20:27.435]                     default_workers <- missing(workers)
[13:20:27.435]                     if (is.function(workers)) 
[13:20:27.435]                       workers <- workers()
[13:20:27.435]                     workers <- structure(as.integer(workers), 
[13:20:27.435]                       class = class(workers))
[13:20:27.435]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.435]                       1L)
[13:20:27.435]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.435]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.435]                       if (default_workers) 
[13:20:27.435]                         supportsMulticore(warn = TRUE)
[13:20:27.435]                       return(sequential(..., envir = envir))
[13:20:27.435]                     }
[13:20:27.435]                     oopts <- options(mc.cores = workers)
[13:20:27.435]                     on.exit(options(oopts))
[13:20:27.435]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.435]                       envir = envir)
[13:20:27.435]                     if (!future$lazy) 
[13:20:27.435]                       future <- run(future)
[13:20:27.435]                     invisible(future)
[13:20:27.435]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.435]                 }
[13:20:27.435]             }
[13:20:27.435]         }
[13:20:27.435]     })
[13:20:27.435]     if (TRUE) {
[13:20:27.435]         base::sink(type = "output", split = FALSE)
[13:20:27.435]         if (TRUE) {
[13:20:27.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.435]         }
[13:20:27.435]         else {
[13:20:27.435]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.435]         }
[13:20:27.435]         base::close(...future.stdout)
[13:20:27.435]         ...future.stdout <- NULL
[13:20:27.435]     }
[13:20:27.435]     ...future.result$conditions <- ...future.conditions
[13:20:27.435]     ...future.result$finished <- base::Sys.time()
[13:20:27.435]     ...future.result
[13:20:27.435] }
[13:20:27.439] requestCore(): workers = 2
[13:20:27.439] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:27.468] MulticoreFuture started
[13:20:27.468] - Launch lazy future ... done
[13:20:27.468] run() for ‘MulticoreFuture’ ... done
[13:20:27.469] plan(): Setting new future strategy stack:
<environment: 0x55659b9be580> 
[13:20:27.469] List of future strategies:
[13:20:27.469] 1. sequential:
[13:20:27.469]    - args: function (..., envir = parent.frame())
[13:20:27.469]    - tweaked: FALSE
[13:20:27.469]    - call: NULL
[13:20:27.470] plan(): nbrOfWorkers() = 1
<environment: 0x55659d1e5390> 
[13:20:27.472] plan(): Setting new future strategy stack:
[13:20:27.472] List of future strategies:
[13:20:27.472] 1. multicore:
[13:20:27.472]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.472]    - tweaked: FALSE
[13:20:27.472]    - call: plan(strategy)
[13:20:27.477] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:27.479] resolve() on environment ...
[13:20:27.480]  recursive: 0
[13:20:27.480]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:27.481] signalConditionsASAP(numeric, pos=1) ...
[13:20:27.481] - nx: 4
[13:20:27.481] - relay: TRUE
[13:20:27.481] - stdout: TRUE
[13:20:27.481] - signal: TRUE
[13:20:27.481] - resignal: FALSE
[13:20:27.481] - force: TRUE
[13:20:27.481] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.482] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.482]  - until=2
[13:20:27.482]  - relaying element #2
[13:20:27.482] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:27.482] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.482] signalConditionsASAP(NULL, pos=1) ... done
[13:20:27.482]  length: 3 (resolved future 1)
[13:20:27.483] Future #2
[13:20:27.483] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:27.483] - nx: 4
[13:20:27.483] - relay: TRUE
[13:20:27.483] - stdout: TRUE
[13:20:27.483] - signal: TRUE
[13:20:27.483] - resignal: FALSE
[13:20:27.484] - force: TRUE
[13:20:27.484] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:27.484] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.484]  - until=2
[13:20:27.484]  - relaying element #2
[13:20:27.484] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:27.484] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:27.485] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:27.485]  length: 2 (resolved future 2)
[13:20:27.485] Future #3
[13:20:27.486] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:27.486] - nx: 4
[13:20:27.486] - relay: TRUE
[13:20:27.486] - stdout: TRUE
[13:20:27.487] - signal: TRUE
[13:20:27.487] - resignal: FALSE
[13:20:27.487] - force: TRUE
[13:20:27.487] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:27.487] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:27.487]  - until=3
[13:20:27.487]  - relaying element #3
[13:20:27.487] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:27.488] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:27.488] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:27.488]  length: 1 (resolved future 3)
[13:20:27.488] Future #4
[13:20:27.489] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:20:27.489] - nx: 4
[13:20:27.489] - relay: TRUE
[13:20:27.490] - stdout: TRUE
[13:20:27.490] - signal: TRUE
[13:20:27.490] - resignal: FALSE
[13:20:27.490] - force: TRUE
[13:20:27.490] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:27.490] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:27.491]  - until=4
[13:20:27.491]  - relaying element #4
[13:20:27.491] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.491] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:27.491] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:20:27.492]  length: 0 (resolved future 4)
[13:20:27.492] Relaying remaining futures
[13:20:27.492] signalConditionsASAP(NULL, pos=0) ...
[13:20:27.492] - nx: 4
[13:20:27.492] - relay: TRUE
[13:20:27.492] - stdout: TRUE
[13:20:27.492] - signal: TRUE
[13:20:27.493] - resignal: FALSE
[13:20:27.493] - force: TRUE
[13:20:27.493] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.493] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:27.493] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.493] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:27.493] signalConditionsASAP(NULL, pos=0) ... done
[13:20:27.493] resolve() on environment ... DONE
<environment: 0x55659d2b9270> 
Dimensions: c(2, 3)
[13:20:27.494] getGlobalsAndPackages() ...
[13:20:27.494] Searching for globals...
[13:20:27.495] 
[13:20:27.495] Searching for globals ... DONE
[13:20:27.495] - globals: [0] <none>
[13:20:27.495] getGlobalsAndPackages() ... DONE
[13:20:27.495] run() for ‘Future’ ...
[13:20:27.495] - state: ‘created’
[13:20:27.496] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.500] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.500] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.500]   - Field: ‘label’
[13:20:27.500]   - Field: ‘local’
[13:20:27.500]   - Field: ‘owner’
[13:20:27.501]   - Field: ‘envir’
[13:20:27.501]   - Field: ‘workers’
[13:20:27.501]   - Field: ‘packages’
[13:20:27.501]   - Field: ‘gc’
[13:20:27.501]   - Field: ‘job’
[13:20:27.501]   - Field: ‘conditions’
[13:20:27.501]   - Field: ‘expr’
[13:20:27.501]   - Field: ‘uuid’
[13:20:27.501]   - Field: ‘seed’
[13:20:27.502]   - Field: ‘version’
[13:20:27.502]   - Field: ‘result’
[13:20:27.502]   - Field: ‘asynchronous’
[13:20:27.502]   - Field: ‘calls’
[13:20:27.502]   - Field: ‘globals’
[13:20:27.502]   - Field: ‘stdout’
[13:20:27.502]   - Field: ‘earlySignal’
[13:20:27.502]   - Field: ‘lazy’
[13:20:27.502]   - Field: ‘state’
[13:20:27.503] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.503] - Launch lazy future ...
[13:20:27.503] Packages needed by the future expression (n = 0): <none>
[13:20:27.503] Packages needed by future strategies (n = 0): <none>
[13:20:27.504] {
[13:20:27.504]     {
[13:20:27.504]         {
[13:20:27.504]             ...future.startTime <- base::Sys.time()
[13:20:27.504]             {
[13:20:27.504]                 {
[13:20:27.504]                   {
[13:20:27.504]                     {
[13:20:27.504]                       base::local({
[13:20:27.504]                         has_future <- base::requireNamespace("future", 
[13:20:27.504]                           quietly = TRUE)
[13:20:27.504]                         if (has_future) {
[13:20:27.504]                           ns <- base::getNamespace("future")
[13:20:27.504]                           version <- ns[[".package"]][["version"]]
[13:20:27.504]                           if (is.null(version)) 
[13:20:27.504]                             version <- utils::packageVersion("future")
[13:20:27.504]                         }
[13:20:27.504]                         else {
[13:20:27.504]                           version <- NULL
[13:20:27.504]                         }
[13:20:27.504]                         if (!has_future || version < "1.8.0") {
[13:20:27.504]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.504]                             "", base::R.version$version.string), 
[13:20:27.504]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.504]                               "release", "version")], collapse = " "), 
[13:20:27.504]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.504]                             info)
[13:20:27.504]                           info <- base::paste(info, collapse = "; ")
[13:20:27.504]                           if (!has_future) {
[13:20:27.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.504]                               info)
[13:20:27.504]                           }
[13:20:27.504]                           else {
[13:20:27.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.504]                               info, version)
[13:20:27.504]                           }
[13:20:27.504]                           base::stop(msg)
[13:20:27.504]                         }
[13:20:27.504]                       })
[13:20:27.504]                     }
[13:20:27.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.504]                     base::options(mc.cores = 1L)
[13:20:27.504]                   }
[13:20:27.504]                   options(future.plan = NULL)
[13:20:27.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.504]                 }
[13:20:27.504]                 ...future.workdir <- getwd()
[13:20:27.504]             }
[13:20:27.504]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.504]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.504]         }
[13:20:27.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.504]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.504]             base::names(...future.oldOptions))
[13:20:27.504]     }
[13:20:27.504]     if (FALSE) {
[13:20:27.504]     }
[13:20:27.504]     else {
[13:20:27.504]         if (TRUE) {
[13:20:27.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.504]                 open = "w")
[13:20:27.504]         }
[13:20:27.504]         else {
[13:20:27.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.504]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.504]         }
[13:20:27.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.504]             base::sink(type = "output", split = FALSE)
[13:20:27.504]             base::close(...future.stdout)
[13:20:27.504]         }, add = TRUE)
[13:20:27.504]     }
[13:20:27.504]     ...future.frame <- base::sys.nframe()
[13:20:27.504]     ...future.conditions <- base::list()
[13:20:27.504]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.504]     if (FALSE) {
[13:20:27.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.504]     }
[13:20:27.504]     ...future.result <- base::tryCatch({
[13:20:27.504]         base::withCallingHandlers({
[13:20:27.504]             ...future.value <- base::withVisible(base::local({
[13:20:27.504]                 withCallingHandlers({
[13:20:27.504]                   2
[13:20:27.504]                 }, immediateCondition = function(cond) {
[13:20:27.504]                   save_rds <- function (object, pathname, ...) 
[13:20:27.504]                   {
[13:20:27.504]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.504]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.504]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.504]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.504]                         fi_tmp[["mtime"]])
[13:20:27.504]                     }
[13:20:27.504]                     tryCatch({
[13:20:27.504]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.504]                     }, error = function(ex) {
[13:20:27.504]                       msg <- conditionMessage(ex)
[13:20:27.504]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.504]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.504]                         fi_tmp[["mtime"]], msg)
[13:20:27.504]                       ex$message <- msg
[13:20:27.504]                       stop(ex)
[13:20:27.504]                     })
[13:20:27.504]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.504]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.504]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.504]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.504]                       fi <- file.info(pathname)
[13:20:27.504]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.504]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.504]                         fi[["size"]], fi[["mtime"]])
[13:20:27.504]                       stop(msg)
[13:20:27.504]                     }
[13:20:27.504]                     invisible(pathname)
[13:20:27.504]                   }
[13:20:27.504]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.504]                     rootPath = tempdir()) 
[13:20:27.504]                   {
[13:20:27.504]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.504]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.504]                       tmpdir = path, fileext = ".rds")
[13:20:27.504]                     save_rds(obj, file)
[13:20:27.504]                   }
[13:20:27.504]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.504]                   {
[13:20:27.504]                     inherits <- base::inherits
[13:20:27.504]                     invokeRestart <- base::invokeRestart
[13:20:27.504]                     is.null <- base::is.null
[13:20:27.504]                     muffled <- FALSE
[13:20:27.504]                     if (inherits(cond, "message")) {
[13:20:27.504]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.504]                       if (muffled) 
[13:20:27.504]                         invokeRestart("muffleMessage")
[13:20:27.504]                     }
[13:20:27.504]                     else if (inherits(cond, "warning")) {
[13:20:27.504]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.504]                       if (muffled) 
[13:20:27.504]                         invokeRestart("muffleWarning")
[13:20:27.504]                     }
[13:20:27.504]                     else if (inherits(cond, "condition")) {
[13:20:27.504]                       if (!is.null(pattern)) {
[13:20:27.504]                         computeRestarts <- base::computeRestarts
[13:20:27.504]                         grepl <- base::grepl
[13:20:27.504]                         restarts <- computeRestarts(cond)
[13:20:27.504]                         for (restart in restarts) {
[13:20:27.504]                           name <- restart$name
[13:20:27.504]                           if (is.null(name)) 
[13:20:27.504]                             next
[13:20:27.504]                           if (!grepl(pattern, name)) 
[13:20:27.504]                             next
[13:20:27.504]                           invokeRestart(restart)
[13:20:27.504]                           muffled <- TRUE
[13:20:27.504]                           break
[13:20:27.504]                         }
[13:20:27.504]                       }
[13:20:27.504]                     }
[13:20:27.504]                     invisible(muffled)
[13:20:27.504]                   }
[13:20:27.504]                   muffleCondition(cond)
[13:20:27.504]                 })
[13:20:27.504]             }))
[13:20:27.504]             future::FutureResult(value = ...future.value$value, 
[13:20:27.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.504]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.504]                     ...future.globalenv.names))
[13:20:27.504]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.504]         }, condition = base::local({
[13:20:27.504]             c <- base::c
[13:20:27.504]             inherits <- base::inherits
[13:20:27.504]             invokeRestart <- base::invokeRestart
[13:20:27.504]             length <- base::length
[13:20:27.504]             list <- base::list
[13:20:27.504]             seq.int <- base::seq.int
[13:20:27.504]             signalCondition <- base::signalCondition
[13:20:27.504]             sys.calls <- base::sys.calls
[13:20:27.504]             `[[` <- base::`[[`
[13:20:27.504]             `+` <- base::`+`
[13:20:27.504]             `<<-` <- base::`<<-`
[13:20:27.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.504]                   3L)]
[13:20:27.504]             }
[13:20:27.504]             function(cond) {
[13:20:27.504]                 is_error <- inherits(cond, "error")
[13:20:27.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.504]                   NULL)
[13:20:27.504]                 if (is_error) {
[13:20:27.504]                   sessionInformation <- function() {
[13:20:27.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.504]                       search = base::search(), system = base::Sys.info())
[13:20:27.504]                   }
[13:20:27.504]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.504]                     cond$call), session = sessionInformation(), 
[13:20:27.504]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.504]                   signalCondition(cond)
[13:20:27.504]                 }
[13:20:27.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.504]                 "immediateCondition"))) {
[13:20:27.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.504]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.504]                   if (TRUE && !signal) {
[13:20:27.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.504]                     {
[13:20:27.504]                       inherits <- base::inherits
[13:20:27.504]                       invokeRestart <- base::invokeRestart
[13:20:27.504]                       is.null <- base::is.null
[13:20:27.504]                       muffled <- FALSE
[13:20:27.504]                       if (inherits(cond, "message")) {
[13:20:27.504]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.504]                         if (muffled) 
[13:20:27.504]                           invokeRestart("muffleMessage")
[13:20:27.504]                       }
[13:20:27.504]                       else if (inherits(cond, "warning")) {
[13:20:27.504]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.504]                         if (muffled) 
[13:20:27.504]                           invokeRestart("muffleWarning")
[13:20:27.504]                       }
[13:20:27.504]                       else if (inherits(cond, "condition")) {
[13:20:27.504]                         if (!is.null(pattern)) {
[13:20:27.504]                           computeRestarts <- base::computeRestarts
[13:20:27.504]                           grepl <- base::grepl
[13:20:27.504]                           restarts <- computeRestarts(cond)
[13:20:27.504]                           for (restart in restarts) {
[13:20:27.504]                             name <- restart$name
[13:20:27.504]                             if (is.null(name)) 
[13:20:27.504]                               next
[13:20:27.504]                             if (!grepl(pattern, name)) 
[13:20:27.504]                               next
[13:20:27.504]                             invokeRestart(restart)
[13:20:27.504]                             muffled <- TRUE
[13:20:27.504]                             break
[13:20:27.504]                           }
[13:20:27.504]                         }
[13:20:27.504]                       }
[13:20:27.504]                       invisible(muffled)
[13:20:27.504]                     }
[13:20:27.504]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.504]                   }
[13:20:27.504]                 }
[13:20:27.504]                 else {
[13:20:27.504]                   if (TRUE) {
[13:20:27.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.504]                     {
[13:20:27.504]                       inherits <- base::inherits
[13:20:27.504]                       invokeRestart <- base::invokeRestart
[13:20:27.504]                       is.null <- base::is.null
[13:20:27.504]                       muffled <- FALSE
[13:20:27.504]                       if (inherits(cond, "message")) {
[13:20:27.504]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.504]                         if (muffled) 
[13:20:27.504]                           invokeRestart("muffleMessage")
[13:20:27.504]                       }
[13:20:27.504]                       else if (inherits(cond, "warning")) {
[13:20:27.504]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.504]                         if (muffled) 
[13:20:27.504]                           invokeRestart("muffleWarning")
[13:20:27.504]                       }
[13:20:27.504]                       else if (inherits(cond, "condition")) {
[13:20:27.504]                         if (!is.null(pattern)) {
[13:20:27.504]                           computeRestarts <- base::computeRestarts
[13:20:27.504]                           grepl <- base::grepl
[13:20:27.504]                           restarts <- computeRestarts(cond)
[13:20:27.504]                           for (restart in restarts) {
[13:20:27.504]                             name <- restart$name
[13:20:27.504]                             if (is.null(name)) 
[13:20:27.504]                               next
[13:20:27.504]                             if (!grepl(pattern, name)) 
[13:20:27.504]                               next
[13:20:27.504]                             invokeRestart(restart)
[13:20:27.504]                             muffled <- TRUE
[13:20:27.504]                             break
[13:20:27.504]                           }
[13:20:27.504]                         }
[13:20:27.504]                       }
[13:20:27.504]                       invisible(muffled)
[13:20:27.504]                     }
[13:20:27.504]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.504]                   }
[13:20:27.504]                 }
[13:20:27.504]             }
[13:20:27.504]         }))
[13:20:27.504]     }, error = function(ex) {
[13:20:27.504]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.504]                 ...future.rng), started = ...future.startTime, 
[13:20:27.504]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.504]             version = "1.8"), class = "FutureResult")
[13:20:27.504]     }, finally = {
[13:20:27.504]         if (!identical(...future.workdir, getwd())) 
[13:20:27.504]             setwd(...future.workdir)
[13:20:27.504]         {
[13:20:27.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.504]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.504]             }
[13:20:27.504]             base::options(...future.oldOptions)
[13:20:27.504]             if (.Platform$OS.type == "windows") {
[13:20:27.504]                 old_names <- names(...future.oldEnvVars)
[13:20:27.504]                 envs <- base::Sys.getenv()
[13:20:27.504]                 names <- names(envs)
[13:20:27.504]                 common <- intersect(names, old_names)
[13:20:27.504]                 added <- setdiff(names, old_names)
[13:20:27.504]                 removed <- setdiff(old_names, names)
[13:20:27.504]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.504]                   envs[common]]
[13:20:27.504]                 NAMES <- toupper(changed)
[13:20:27.504]                 args <- list()
[13:20:27.504]                 for (kk in seq_along(NAMES)) {
[13:20:27.504]                   name <- changed[[kk]]
[13:20:27.504]                   NAME <- NAMES[[kk]]
[13:20:27.504]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.504]                     next
[13:20:27.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.504]                 }
[13:20:27.504]                 NAMES <- toupper(added)
[13:20:27.504]                 for (kk in seq_along(NAMES)) {
[13:20:27.504]                   name <- added[[kk]]
[13:20:27.504]                   NAME <- NAMES[[kk]]
[13:20:27.504]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.504]                     next
[13:20:27.504]                   args[[name]] <- ""
[13:20:27.504]                 }
[13:20:27.504]                 NAMES <- toupper(removed)
[13:20:27.504]                 for (kk in seq_along(NAMES)) {
[13:20:27.504]                   name <- removed[[kk]]
[13:20:27.504]                   NAME <- NAMES[[kk]]
[13:20:27.504]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.504]                     next
[13:20:27.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.504]                 }
[13:20:27.504]                 if (length(args) > 0) 
[13:20:27.504]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.504]             }
[13:20:27.504]             else {
[13:20:27.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.504]             }
[13:20:27.504]             {
[13:20:27.504]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.504]                   0L) {
[13:20:27.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.504]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.504]                   base::options(opts)
[13:20:27.504]                 }
[13:20:27.504]                 {
[13:20:27.504]                   {
[13:20:27.504]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.504]                     NULL
[13:20:27.504]                   }
[13:20:27.504]                   options(future.plan = NULL)
[13:20:27.504]                   if (is.na(NA_character_)) 
[13:20:27.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.504]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.504]                     envir = parent.frame()) 
[13:20:27.504]                   {
[13:20:27.504]                     default_workers <- missing(workers)
[13:20:27.504]                     if (is.function(workers)) 
[13:20:27.504]                       workers <- workers()
[13:20:27.504]                     workers <- structure(as.integer(workers), 
[13:20:27.504]                       class = class(workers))
[13:20:27.504]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.504]                       1L)
[13:20:27.504]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.504]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.504]                       if (default_workers) 
[13:20:27.504]                         supportsMulticore(warn = TRUE)
[13:20:27.504]                       return(sequential(..., envir = envir))
[13:20:27.504]                     }
[13:20:27.504]                     oopts <- options(mc.cores = workers)
[13:20:27.504]                     on.exit(options(oopts))
[13:20:27.504]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.504]                       envir = envir)
[13:20:27.504]                     if (!future$lazy) 
[13:20:27.504]                       future <- run(future)
[13:20:27.504]                     invisible(future)
[13:20:27.504]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.504]                 }
[13:20:27.504]             }
[13:20:27.504]         }
[13:20:27.504]     })
[13:20:27.504]     if (TRUE) {
[13:20:27.504]         base::sink(type = "output", split = FALSE)
[13:20:27.504]         if (TRUE) {
[13:20:27.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.504]         }
[13:20:27.504]         else {
[13:20:27.504]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.504]         }
[13:20:27.504]         base::close(...future.stdout)
[13:20:27.504]         ...future.stdout <- NULL
[13:20:27.504]     }
[13:20:27.504]     ...future.result$conditions <- ...future.conditions
[13:20:27.504]     ...future.result$finished <- base::Sys.time()
[13:20:27.504]     ...future.result
[13:20:27.504] }
[13:20:27.506] requestCore(): workers = 2
[13:20:27.508] MulticoreFuture started
[13:20:27.509] - Launch lazy future ... done
[13:20:27.509] run() for ‘MulticoreFuture’ ... done
[13:20:27.509] getGlobalsAndPackages() ...
[13:20:27.510] Searching for globals...
[13:20:27.510] plan(): Setting new future strategy stack:
[13:20:27.510] 
[13:20:27.510] List of future strategies:
[13:20:27.510] 1. sequential:
[13:20:27.510]    - args: function (..., envir = parent.frame())
[13:20:27.510]    - tweaked: FALSE
[13:20:27.510]    - call: NULL
[13:20:27.510] Searching for globals ... DONE
[13:20:27.511] - globals: [0] <none>
[13:20:27.511] plan(): nbrOfWorkers() = 1
[13:20:27.511] getGlobalsAndPackages() ... DONE
[13:20:27.511] run() for ‘Future’ ...
[13:20:27.511] - state: ‘created’
[13:20:27.512] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.512] plan(): Setting new future strategy stack:
[13:20:27.513] List of future strategies:
[13:20:27.513] 1. multicore:
[13:20:27.513]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.513]    - tweaked: FALSE
[13:20:27.513]    - call: plan(strategy)
[13:20:27.517] plan(): nbrOfWorkers() = 2
[13:20:27.517] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.518]   - Field: ‘label’
[13:20:27.518]   - Field: ‘local’
[13:20:27.518]   - Field: ‘owner’
[13:20:27.518]   - Field: ‘envir’
[13:20:27.518]   - Field: ‘workers’
[13:20:27.518]   - Field: ‘packages’
[13:20:27.519]   - Field: ‘gc’
[13:20:27.519]   - Field: ‘job’
[13:20:27.519]   - Field: ‘conditions’
[13:20:27.519]   - Field: ‘expr’
[13:20:27.519]   - Field: ‘uuid’
[13:20:27.519]   - Field: ‘seed’
[13:20:27.519]   - Field: ‘version’
[13:20:27.520]   - Field: ‘result’
[13:20:27.520]   - Field: ‘asynchronous’
[13:20:27.520]   - Field: ‘calls’
[13:20:27.520]   - Field: ‘globals’
[13:20:27.520]   - Field: ‘stdout’
[13:20:27.520]   - Field: ‘earlySignal’
[13:20:27.520]   - Field: ‘lazy’
[13:20:27.521]   - Field: ‘state’
[13:20:27.521] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.521] - Launch lazy future ...
[13:20:27.521] Packages needed by the future expression (n = 0): <none>
[13:20:27.522] Packages needed by future strategies (n = 0): <none>
[13:20:27.528] {
[13:20:27.528]     {
[13:20:27.528]         {
[13:20:27.528]             ...future.startTime <- base::Sys.time()
[13:20:27.528]             {
[13:20:27.528]                 {
[13:20:27.528]                   {
[13:20:27.528]                     {
[13:20:27.528]                       base::local({
[13:20:27.528]                         has_future <- base::requireNamespace("future", 
[13:20:27.528]                           quietly = TRUE)
[13:20:27.528]                         if (has_future) {
[13:20:27.528]                           ns <- base::getNamespace("future")
[13:20:27.528]                           version <- ns[[".package"]][["version"]]
[13:20:27.528]                           if (is.null(version)) 
[13:20:27.528]                             version <- utils::packageVersion("future")
[13:20:27.528]                         }
[13:20:27.528]                         else {
[13:20:27.528]                           version <- NULL
[13:20:27.528]                         }
[13:20:27.528]                         if (!has_future || version < "1.8.0") {
[13:20:27.528]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.528]                             "", base::R.version$version.string), 
[13:20:27.528]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.528]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.528]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.528]                               "release", "version")], collapse = " "), 
[13:20:27.528]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.528]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.528]                             info)
[13:20:27.528]                           info <- base::paste(info, collapse = "; ")
[13:20:27.528]                           if (!has_future) {
[13:20:27.528]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.528]                               info)
[13:20:27.528]                           }
[13:20:27.528]                           else {
[13:20:27.528]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.528]                               info, version)
[13:20:27.528]                           }
[13:20:27.528]                           base::stop(msg)
[13:20:27.528]                         }
[13:20:27.528]                       })
[13:20:27.528]                     }
[13:20:27.528]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.528]                     base::options(mc.cores = 1L)
[13:20:27.528]                   }
[13:20:27.528]                   options(future.plan = NULL)
[13:20:27.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.528]                 }
[13:20:27.528]                 ...future.workdir <- getwd()
[13:20:27.528]             }
[13:20:27.528]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.528]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.528]         }
[13:20:27.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.528]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.528]             base::names(...future.oldOptions))
[13:20:27.528]     }
[13:20:27.528]     if (FALSE) {
[13:20:27.528]     }
[13:20:27.528]     else {
[13:20:27.528]         if (TRUE) {
[13:20:27.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.528]                 open = "w")
[13:20:27.528]         }
[13:20:27.528]         else {
[13:20:27.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.528]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.528]         }
[13:20:27.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.528]             base::sink(type = "output", split = FALSE)
[13:20:27.528]             base::close(...future.stdout)
[13:20:27.528]         }, add = TRUE)
[13:20:27.528]     }
[13:20:27.528]     ...future.frame <- base::sys.nframe()
[13:20:27.528]     ...future.conditions <- base::list()
[13:20:27.528]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.528]     if (FALSE) {
[13:20:27.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.528]     }
[13:20:27.528]     ...future.result <- base::tryCatch({
[13:20:27.528]         base::withCallingHandlers({
[13:20:27.528]             ...future.value <- base::withVisible(base::local({
[13:20:27.528]                 withCallingHandlers({
[13:20:27.528]                   NULL
[13:20:27.528]                 }, immediateCondition = function(cond) {
[13:20:27.528]                   save_rds <- function (object, pathname, ...) 
[13:20:27.528]                   {
[13:20:27.528]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.528]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.528]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.528]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.528]                         fi_tmp[["mtime"]])
[13:20:27.528]                     }
[13:20:27.528]                     tryCatch({
[13:20:27.528]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.528]                     }, error = function(ex) {
[13:20:27.528]                       msg <- conditionMessage(ex)
[13:20:27.528]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.528]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.528]                         fi_tmp[["mtime"]], msg)
[13:20:27.528]                       ex$message <- msg
[13:20:27.528]                       stop(ex)
[13:20:27.528]                     })
[13:20:27.528]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.528]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.528]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.528]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.528]                       fi <- file.info(pathname)
[13:20:27.528]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.528]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.528]                         fi[["size"]], fi[["mtime"]])
[13:20:27.528]                       stop(msg)
[13:20:27.528]                     }
[13:20:27.528]                     invisible(pathname)
[13:20:27.528]                   }
[13:20:27.528]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.528]                     rootPath = tempdir()) 
[13:20:27.528]                   {
[13:20:27.528]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.528]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.528]                       tmpdir = path, fileext = ".rds")
[13:20:27.528]                     save_rds(obj, file)
[13:20:27.528]                   }
[13:20:27.528]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.528]                   {
[13:20:27.528]                     inherits <- base::inherits
[13:20:27.528]                     invokeRestart <- base::invokeRestart
[13:20:27.528]                     is.null <- base::is.null
[13:20:27.528]                     muffled <- FALSE
[13:20:27.528]                     if (inherits(cond, "message")) {
[13:20:27.528]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.528]                       if (muffled) 
[13:20:27.528]                         invokeRestart("muffleMessage")
[13:20:27.528]                     }
[13:20:27.528]                     else if (inherits(cond, "warning")) {
[13:20:27.528]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.528]                       if (muffled) 
[13:20:27.528]                         invokeRestart("muffleWarning")
[13:20:27.528]                     }
[13:20:27.528]                     else if (inherits(cond, "condition")) {
[13:20:27.528]                       if (!is.null(pattern)) {
[13:20:27.528]                         computeRestarts <- base::computeRestarts
[13:20:27.528]                         grepl <- base::grepl
[13:20:27.528]                         restarts <- computeRestarts(cond)
[13:20:27.528]                         for (restart in restarts) {
[13:20:27.528]                           name <- restart$name
[13:20:27.528]                           if (is.null(name)) 
[13:20:27.528]                             next
[13:20:27.528]                           if (!grepl(pattern, name)) 
[13:20:27.528]                             next
[13:20:27.528]                           invokeRestart(restart)
[13:20:27.528]                           muffled <- TRUE
[13:20:27.528]                           break
[13:20:27.528]                         }
[13:20:27.528]                       }
[13:20:27.528]                     }
[13:20:27.528]                     invisible(muffled)
[13:20:27.528]                   }
[13:20:27.528]                   muffleCondition(cond)
[13:20:27.528]                 })
[13:20:27.528]             }))
[13:20:27.528]             future::FutureResult(value = ...future.value$value, 
[13:20:27.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.528]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.528]                     ...future.globalenv.names))
[13:20:27.528]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.528]         }, condition = base::local({
[13:20:27.528]             c <- base::c
[13:20:27.528]             inherits <- base::inherits
[13:20:27.528]             invokeRestart <- base::invokeRestart
[13:20:27.528]             length <- base::length
[13:20:27.528]             list <- base::list
[13:20:27.528]             seq.int <- base::seq.int
[13:20:27.528]             signalCondition <- base::signalCondition
[13:20:27.528]             sys.calls <- base::sys.calls
[13:20:27.528]             `[[` <- base::`[[`
[13:20:27.528]             `+` <- base::`+`
[13:20:27.528]             `<<-` <- base::`<<-`
[13:20:27.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.528]                   3L)]
[13:20:27.528]             }
[13:20:27.528]             function(cond) {
[13:20:27.528]                 is_error <- inherits(cond, "error")
[13:20:27.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.528]                   NULL)
[13:20:27.528]                 if (is_error) {
[13:20:27.528]                   sessionInformation <- function() {
[13:20:27.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.528]                       search = base::search(), system = base::Sys.info())
[13:20:27.528]                   }
[13:20:27.528]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.528]                     cond$call), session = sessionInformation(), 
[13:20:27.528]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.528]                   signalCondition(cond)
[13:20:27.528]                 }
[13:20:27.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.528]                 "immediateCondition"))) {
[13:20:27.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.528]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.528]                   if (TRUE && !signal) {
[13:20:27.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.528]                     {
[13:20:27.528]                       inherits <- base::inherits
[13:20:27.528]                       invokeRestart <- base::invokeRestart
[13:20:27.528]                       is.null <- base::is.null
[13:20:27.528]                       muffled <- FALSE
[13:20:27.528]                       if (inherits(cond, "message")) {
[13:20:27.528]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.528]                         if (muffled) 
[13:20:27.528]                           invokeRestart("muffleMessage")
[13:20:27.528]                       }
[13:20:27.528]                       else if (inherits(cond, "warning")) {
[13:20:27.528]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.528]                         if (muffled) 
[13:20:27.528]                           invokeRestart("muffleWarning")
[13:20:27.528]                       }
[13:20:27.528]                       else if (inherits(cond, "condition")) {
[13:20:27.528]                         if (!is.null(pattern)) {
[13:20:27.528]                           computeRestarts <- base::computeRestarts
[13:20:27.528]                           grepl <- base::grepl
[13:20:27.528]                           restarts <- computeRestarts(cond)
[13:20:27.528]                           for (restart in restarts) {
[13:20:27.528]                             name <- restart$name
[13:20:27.528]                             if (is.null(name)) 
[13:20:27.528]                               next
[13:20:27.528]                             if (!grepl(pattern, name)) 
[13:20:27.528]                               next
[13:20:27.528]                             invokeRestart(restart)
[13:20:27.528]                             muffled <- TRUE
[13:20:27.528]                             break
[13:20:27.528]                           }
[13:20:27.528]                         }
[13:20:27.528]                       }
[13:20:27.528]                       invisible(muffled)
[13:20:27.528]                     }
[13:20:27.528]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.528]                   }
[13:20:27.528]                 }
[13:20:27.528]                 else {
[13:20:27.528]                   if (TRUE) {
[13:20:27.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.528]                     {
[13:20:27.528]                       inherits <- base::inherits
[13:20:27.528]                       invokeRestart <- base::invokeRestart
[13:20:27.528]                       is.null <- base::is.null
[13:20:27.528]                       muffled <- FALSE
[13:20:27.528]                       if (inherits(cond, "message")) {
[13:20:27.528]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.528]                         if (muffled) 
[13:20:27.528]                           invokeRestart("muffleMessage")
[13:20:27.528]                       }
[13:20:27.528]                       else if (inherits(cond, "warning")) {
[13:20:27.528]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.528]                         if (muffled) 
[13:20:27.528]                           invokeRestart("muffleWarning")
[13:20:27.528]                       }
[13:20:27.528]                       else if (inherits(cond, "condition")) {
[13:20:27.528]                         if (!is.null(pattern)) {
[13:20:27.528]                           computeRestarts <- base::computeRestarts
[13:20:27.528]                           grepl <- base::grepl
[13:20:27.528]                           restarts <- computeRestarts(cond)
[13:20:27.528]                           for (restart in restarts) {
[13:20:27.528]                             name <- restart$name
[13:20:27.528]                             if (is.null(name)) 
[13:20:27.528]                               next
[13:20:27.528]                             if (!grepl(pattern, name)) 
[13:20:27.528]                               next
[13:20:27.528]                             invokeRestart(restart)
[13:20:27.528]                             muffled <- TRUE
[13:20:27.528]                             break
[13:20:27.528]                           }
[13:20:27.528]                         }
[13:20:27.528]                       }
[13:20:27.528]                       invisible(muffled)
[13:20:27.528]                     }
[13:20:27.528]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.528]                   }
[13:20:27.528]                 }
[13:20:27.528]             }
[13:20:27.528]         }))
[13:20:27.528]     }, error = function(ex) {
[13:20:27.528]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.528]                 ...future.rng), started = ...future.startTime, 
[13:20:27.528]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.528]             version = "1.8"), class = "FutureResult")
[13:20:27.528]     }, finally = {
[13:20:27.528]         if (!identical(...future.workdir, getwd())) 
[13:20:27.528]             setwd(...future.workdir)
[13:20:27.528]         {
[13:20:27.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.528]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.528]             }
[13:20:27.528]             base::options(...future.oldOptions)
[13:20:27.528]             if (.Platform$OS.type == "windows") {
[13:20:27.528]                 old_names <- names(...future.oldEnvVars)
[13:20:27.528]                 envs <- base::Sys.getenv()
[13:20:27.528]                 names <- names(envs)
[13:20:27.528]                 common <- intersect(names, old_names)
[13:20:27.528]                 added <- setdiff(names, old_names)
[13:20:27.528]                 removed <- setdiff(old_names, names)
[13:20:27.528]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.528]                   envs[common]]
[13:20:27.528]                 NAMES <- toupper(changed)
[13:20:27.528]                 args <- list()
[13:20:27.528]                 for (kk in seq_along(NAMES)) {
[13:20:27.528]                   name <- changed[[kk]]
[13:20:27.528]                   NAME <- NAMES[[kk]]
[13:20:27.528]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.528]                     next
[13:20:27.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.528]                 }
[13:20:27.528]                 NAMES <- toupper(added)
[13:20:27.528]                 for (kk in seq_along(NAMES)) {
[13:20:27.528]                   name <- added[[kk]]
[13:20:27.528]                   NAME <- NAMES[[kk]]
[13:20:27.528]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.528]                     next
[13:20:27.528]                   args[[name]] <- ""
[13:20:27.528]                 }
[13:20:27.528]                 NAMES <- toupper(removed)
[13:20:27.528]                 for (kk in seq_along(NAMES)) {
[13:20:27.528]                   name <- removed[[kk]]
[13:20:27.528]                   NAME <- NAMES[[kk]]
[13:20:27.528]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.528]                     next
[13:20:27.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.528]                 }
[13:20:27.528]                 if (length(args) > 0) 
[13:20:27.528]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.528]             }
[13:20:27.528]             else {
[13:20:27.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.528]             }
[13:20:27.528]             {
[13:20:27.528]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.528]                   0L) {
[13:20:27.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.528]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.528]                   base::options(opts)
[13:20:27.528]                 }
[13:20:27.528]                 {
[13:20:27.528]                   {
[13:20:27.528]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.528]                     NULL
[13:20:27.528]                   }
[13:20:27.528]                   options(future.plan = NULL)
[13:20:27.528]                   if (is.na(NA_character_)) 
[13:20:27.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.528]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.528]                     envir = parent.frame()) 
[13:20:27.528]                   {
[13:20:27.528]                     default_workers <- missing(workers)
[13:20:27.528]                     if (is.function(workers)) 
[13:20:27.528]                       workers <- workers()
[13:20:27.528]                     workers <- structure(as.integer(workers), 
[13:20:27.528]                       class = class(workers))
[13:20:27.528]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.528]                       1L)
[13:20:27.528]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.528]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.528]                       if (default_workers) 
[13:20:27.528]                         supportsMulticore(warn = TRUE)
[13:20:27.528]                       return(sequential(..., envir = envir))
[13:20:27.528]                     }
[13:20:27.528]                     oopts <- options(mc.cores = workers)
[13:20:27.528]                     on.exit(options(oopts))
[13:20:27.528]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.528]                       envir = envir)
[13:20:27.528]                     if (!future$lazy) 
[13:20:27.528]                       future <- run(future)
[13:20:27.528]                     invisible(future)
[13:20:27.528]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.528]                 }
[13:20:27.528]             }
[13:20:27.528]         }
[13:20:27.528]     })
[13:20:27.528]     if (TRUE) {
[13:20:27.528]         base::sink(type = "output", split = FALSE)
[13:20:27.528]         if (TRUE) {
[13:20:27.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.528]         }
[13:20:27.528]         else {
[13:20:27.528]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.528]         }
[13:20:27.528]         base::close(...future.stdout)
[13:20:27.528]         ...future.stdout <- NULL
[13:20:27.528]     }
[13:20:27.528]     ...future.result$conditions <- ...future.conditions
[13:20:27.528]     ...future.result$finished <- base::Sys.time()
[13:20:27.528]     ...future.result
[13:20:27.528] }
[13:20:27.531] requestCore(): workers = 2
[13:20:27.534] MulticoreFuture started
[13:20:27.534] - Launch lazy future ... done
[13:20:27.535] run() for ‘MulticoreFuture’ ... done
[13:20:27.535] plan(): Setting new future strategy stack:
[13:20:27.535] getGlobalsAndPackages() ...
[13:20:27.536] Searching for globals...
[13:20:27.535] List of future strategies:
[13:20:27.535] 1. sequential:
[13:20:27.535]    - args: function (..., envir = parent.frame())
[13:20:27.535]    - tweaked: FALSE
[13:20:27.535]    - call: NULL
[13:20:27.536] plan(): nbrOfWorkers() = 1
[13:20:27.537] - globals found: [1] ‘{’
[13:20:27.537] Searching for globals ... DONE
[13:20:27.538] Resolving globals: FALSE
[13:20:27.538] 
[13:20:27.538] 
[13:20:27.538] getGlobalsAndPackages() ... DONE
[13:20:27.539] plan(): Setting new future strategy stack:
[13:20:27.539] run() for ‘Future’ ...
[13:20:27.539] - state: ‘created’
[13:20:27.539] List of future strategies:
[13:20:27.539] 1. multicore:
[13:20:27.539]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.539]    - tweaked: FALSE
[13:20:27.539]    - call: plan(strategy)
[13:20:27.539] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.544] plan(): nbrOfWorkers() = 2
[13:20:27.545] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.546]   - Field: ‘label’
[13:20:27.546]   - Field: ‘local’
[13:20:27.546]   - Field: ‘owner’
[13:20:27.546]   - Field: ‘envir’
[13:20:27.546]   - Field: ‘workers’
[13:20:27.546]   - Field: ‘packages’
[13:20:27.546]   - Field: ‘gc’
[13:20:27.547]   - Field: ‘job’
[13:20:27.547]   - Field: ‘conditions’
[13:20:27.547]   - Field: ‘expr’
[13:20:27.547]   - Field: ‘uuid’
[13:20:27.547]   - Field: ‘seed’
[13:20:27.547]   - Field: ‘version’
[13:20:27.547]   - Field: ‘result’
[13:20:27.548]   - Field: ‘asynchronous’
[13:20:27.548]   - Field: ‘calls’
[13:20:27.548]   - Field: ‘globals’
[13:20:27.548]   - Field: ‘stdout’
[13:20:27.548]   - Field: ‘earlySignal’
[13:20:27.548]   - Field: ‘lazy’
[13:20:27.548]   - Field: ‘state’
[13:20:27.549] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.549] - Launch lazy future ...
[13:20:27.549] Packages needed by the future expression (n = 0): <none>
[13:20:27.550] Packages needed by future strategies (n = 0): <none>
[13:20:27.550] {
[13:20:27.550]     {
[13:20:27.550]         {
[13:20:27.550]             ...future.startTime <- base::Sys.time()
[13:20:27.550]             {
[13:20:27.550]                 {
[13:20:27.550]                   {
[13:20:27.550]                     {
[13:20:27.550]                       base::local({
[13:20:27.550]                         has_future <- base::requireNamespace("future", 
[13:20:27.550]                           quietly = TRUE)
[13:20:27.550]                         if (has_future) {
[13:20:27.550]                           ns <- base::getNamespace("future")
[13:20:27.550]                           version <- ns[[".package"]][["version"]]
[13:20:27.550]                           if (is.null(version)) 
[13:20:27.550]                             version <- utils::packageVersion("future")
[13:20:27.550]                         }
[13:20:27.550]                         else {
[13:20:27.550]                           version <- NULL
[13:20:27.550]                         }
[13:20:27.550]                         if (!has_future || version < "1.8.0") {
[13:20:27.550]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.550]                             "", base::R.version$version.string), 
[13:20:27.550]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.550]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.550]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.550]                               "release", "version")], collapse = " "), 
[13:20:27.550]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.550]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.550]                             info)
[13:20:27.550]                           info <- base::paste(info, collapse = "; ")
[13:20:27.550]                           if (!has_future) {
[13:20:27.550]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.550]                               info)
[13:20:27.550]                           }
[13:20:27.550]                           else {
[13:20:27.550]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.550]                               info, version)
[13:20:27.550]                           }
[13:20:27.550]                           base::stop(msg)
[13:20:27.550]                         }
[13:20:27.550]                       })
[13:20:27.550]                     }
[13:20:27.550]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.550]                     base::options(mc.cores = 1L)
[13:20:27.550]                   }
[13:20:27.550]                   options(future.plan = NULL)
[13:20:27.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.550]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.550]                 }
[13:20:27.550]                 ...future.workdir <- getwd()
[13:20:27.550]             }
[13:20:27.550]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.550]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.550]         }
[13:20:27.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.550]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.550]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.550]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.550]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.550]             base::names(...future.oldOptions))
[13:20:27.550]     }
[13:20:27.550]     if (FALSE) {
[13:20:27.550]     }
[13:20:27.550]     else {
[13:20:27.550]         if (TRUE) {
[13:20:27.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.550]                 open = "w")
[13:20:27.550]         }
[13:20:27.550]         else {
[13:20:27.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.550]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.550]         }
[13:20:27.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.550]             base::sink(type = "output", split = FALSE)
[13:20:27.550]             base::close(...future.stdout)
[13:20:27.550]         }, add = TRUE)
[13:20:27.550]     }
[13:20:27.550]     ...future.frame <- base::sys.nframe()
[13:20:27.550]     ...future.conditions <- base::list()
[13:20:27.550]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.550]     if (FALSE) {
[13:20:27.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.550]     }
[13:20:27.550]     ...future.result <- base::tryCatch({
[13:20:27.550]         base::withCallingHandlers({
[13:20:27.550]             ...future.value <- base::withVisible(base::local({
[13:20:27.550]                 withCallingHandlers({
[13:20:27.550]                   {
[13:20:27.550]                     4
[13:20:27.550]                   }
[13:20:27.550]                 }, immediateCondition = function(cond) {
[13:20:27.550]                   save_rds <- function (object, pathname, ...) 
[13:20:27.550]                   {
[13:20:27.550]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.550]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.550]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.550]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.550]                         fi_tmp[["mtime"]])
[13:20:27.550]                     }
[13:20:27.550]                     tryCatch({
[13:20:27.550]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.550]                     }, error = function(ex) {
[13:20:27.550]                       msg <- conditionMessage(ex)
[13:20:27.550]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.550]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.550]                         fi_tmp[["mtime"]], msg)
[13:20:27.550]                       ex$message <- msg
[13:20:27.550]                       stop(ex)
[13:20:27.550]                     })
[13:20:27.550]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.550]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.550]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.550]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.550]                       fi <- file.info(pathname)
[13:20:27.550]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.550]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.550]                         fi[["size"]], fi[["mtime"]])
[13:20:27.550]                       stop(msg)
[13:20:27.550]                     }
[13:20:27.550]                     invisible(pathname)
[13:20:27.550]                   }
[13:20:27.550]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.550]                     rootPath = tempdir()) 
[13:20:27.550]                   {
[13:20:27.550]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.550]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.550]                       tmpdir = path, fileext = ".rds")
[13:20:27.550]                     save_rds(obj, file)
[13:20:27.550]                   }
[13:20:27.550]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.550]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.550]                   {
[13:20:27.550]                     inherits <- base::inherits
[13:20:27.550]                     invokeRestart <- base::invokeRestart
[13:20:27.550]                     is.null <- base::is.null
[13:20:27.550]                     muffled <- FALSE
[13:20:27.550]                     if (inherits(cond, "message")) {
[13:20:27.550]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.550]                       if (muffled) 
[13:20:27.550]                         invokeRestart("muffleMessage")
[13:20:27.550]                     }
[13:20:27.550]                     else if (inherits(cond, "warning")) {
[13:20:27.550]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.550]                       if (muffled) 
[13:20:27.550]                         invokeRestart("muffleWarning")
[13:20:27.550]                     }
[13:20:27.550]                     else if (inherits(cond, "condition")) {
[13:20:27.550]                       if (!is.null(pattern)) {
[13:20:27.550]                         computeRestarts <- base::computeRestarts
[13:20:27.550]                         grepl <- base::grepl
[13:20:27.550]                         restarts <- computeRestarts(cond)
[13:20:27.550]                         for (restart in restarts) {
[13:20:27.550]                           name <- restart$name
[13:20:27.550]                           if (is.null(name)) 
[13:20:27.550]                             next
[13:20:27.550]                           if (!grepl(pattern, name)) 
[13:20:27.550]                             next
[13:20:27.550]                           invokeRestart(restart)
[13:20:27.550]                           muffled <- TRUE
[13:20:27.550]                           break
[13:20:27.550]                         }
[13:20:27.550]                       }
[13:20:27.550]                     }
[13:20:27.550]                     invisible(muffled)
[13:20:27.550]                   }
[13:20:27.550]                   muffleCondition(cond)
[13:20:27.550]                 })
[13:20:27.550]             }))
[13:20:27.550]             future::FutureResult(value = ...future.value$value, 
[13:20:27.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.550]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.550]                     ...future.globalenv.names))
[13:20:27.550]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.550]         }, condition = base::local({
[13:20:27.550]             c <- base::c
[13:20:27.550]             inherits <- base::inherits
[13:20:27.550]             invokeRestart <- base::invokeRestart
[13:20:27.550]             length <- base::length
[13:20:27.550]             list <- base::list
[13:20:27.550]             seq.int <- base::seq.int
[13:20:27.550]             signalCondition <- base::signalCondition
[13:20:27.550]             sys.calls <- base::sys.calls
[13:20:27.550]             `[[` <- base::`[[`
[13:20:27.550]             `+` <- base::`+`
[13:20:27.550]             `<<-` <- base::`<<-`
[13:20:27.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.550]                   3L)]
[13:20:27.550]             }
[13:20:27.550]             function(cond) {
[13:20:27.550]                 is_error <- inherits(cond, "error")
[13:20:27.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.550]                   NULL)
[13:20:27.550]                 if (is_error) {
[13:20:27.550]                   sessionInformation <- function() {
[13:20:27.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.550]                       search = base::search(), system = base::Sys.info())
[13:20:27.550]                   }
[13:20:27.550]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.550]                     cond$call), session = sessionInformation(), 
[13:20:27.550]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.550]                   signalCondition(cond)
[13:20:27.550]                 }
[13:20:27.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.550]                 "immediateCondition"))) {
[13:20:27.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.550]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.550]                   if (TRUE && !signal) {
[13:20:27.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.550]                     {
[13:20:27.550]                       inherits <- base::inherits
[13:20:27.550]                       invokeRestart <- base::invokeRestart
[13:20:27.550]                       is.null <- base::is.null
[13:20:27.550]                       muffled <- FALSE
[13:20:27.550]                       if (inherits(cond, "message")) {
[13:20:27.550]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.550]                         if (muffled) 
[13:20:27.550]                           invokeRestart("muffleMessage")
[13:20:27.550]                       }
[13:20:27.550]                       else if (inherits(cond, "warning")) {
[13:20:27.550]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.550]                         if (muffled) 
[13:20:27.550]                           invokeRestart("muffleWarning")
[13:20:27.550]                       }
[13:20:27.550]                       else if (inherits(cond, "condition")) {
[13:20:27.550]                         if (!is.null(pattern)) {
[13:20:27.550]                           computeRestarts <- base::computeRestarts
[13:20:27.550]                           grepl <- base::grepl
[13:20:27.550]                           restarts <- computeRestarts(cond)
[13:20:27.550]                           for (restart in restarts) {
[13:20:27.550]                             name <- restart$name
[13:20:27.550]                             if (is.null(name)) 
[13:20:27.550]                               next
[13:20:27.550]                             if (!grepl(pattern, name)) 
[13:20:27.550]                               next
[13:20:27.550]                             invokeRestart(restart)
[13:20:27.550]                             muffled <- TRUE
[13:20:27.550]                             break
[13:20:27.550]                           }
[13:20:27.550]                         }
[13:20:27.550]                       }
[13:20:27.550]                       invisible(muffled)
[13:20:27.550]                     }
[13:20:27.550]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.550]                   }
[13:20:27.550]                 }
[13:20:27.550]                 else {
[13:20:27.550]                   if (TRUE) {
[13:20:27.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.550]                     {
[13:20:27.550]                       inherits <- base::inherits
[13:20:27.550]                       invokeRestart <- base::invokeRestart
[13:20:27.550]                       is.null <- base::is.null
[13:20:27.550]                       muffled <- FALSE
[13:20:27.550]                       if (inherits(cond, "message")) {
[13:20:27.550]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.550]                         if (muffled) 
[13:20:27.550]                           invokeRestart("muffleMessage")
[13:20:27.550]                       }
[13:20:27.550]                       else if (inherits(cond, "warning")) {
[13:20:27.550]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.550]                         if (muffled) 
[13:20:27.550]                           invokeRestart("muffleWarning")
[13:20:27.550]                       }
[13:20:27.550]                       else if (inherits(cond, "condition")) {
[13:20:27.550]                         if (!is.null(pattern)) {
[13:20:27.550]                           computeRestarts <- base::computeRestarts
[13:20:27.550]                           grepl <- base::grepl
[13:20:27.550]                           restarts <- computeRestarts(cond)
[13:20:27.550]                           for (restart in restarts) {
[13:20:27.550]                             name <- restart$name
[13:20:27.550]                             if (is.null(name)) 
[13:20:27.550]                               next
[13:20:27.550]                             if (!grepl(pattern, name)) 
[13:20:27.550]                               next
[13:20:27.550]                             invokeRestart(restart)
[13:20:27.550]                             muffled <- TRUE
[13:20:27.550]                             break
[13:20:27.550]                           }
[13:20:27.550]                         }
[13:20:27.550]                       }
[13:20:27.550]                       invisible(muffled)
[13:20:27.550]                     }
[13:20:27.550]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.550]                   }
[13:20:27.550]                 }
[13:20:27.550]             }
[13:20:27.550]         }))
[13:20:27.550]     }, error = function(ex) {
[13:20:27.550]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.550]                 ...future.rng), started = ...future.startTime, 
[13:20:27.550]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.550]             version = "1.8"), class = "FutureResult")
[13:20:27.550]     }, finally = {
[13:20:27.550]         if (!identical(...future.workdir, getwd())) 
[13:20:27.550]             setwd(...future.workdir)
[13:20:27.550]         {
[13:20:27.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.550]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.550]             }
[13:20:27.550]             base::options(...future.oldOptions)
[13:20:27.550]             if (.Platform$OS.type == "windows") {
[13:20:27.550]                 old_names <- names(...future.oldEnvVars)
[13:20:27.550]                 envs <- base::Sys.getenv()
[13:20:27.550]                 names <- names(envs)
[13:20:27.550]                 common <- intersect(names, old_names)
[13:20:27.550]                 added <- setdiff(names, old_names)
[13:20:27.550]                 removed <- setdiff(old_names, names)
[13:20:27.550]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.550]                   envs[common]]
[13:20:27.550]                 NAMES <- toupper(changed)
[13:20:27.550]                 args <- list()
[13:20:27.550]                 for (kk in seq_along(NAMES)) {
[13:20:27.550]                   name <- changed[[kk]]
[13:20:27.550]                   NAME <- NAMES[[kk]]
[13:20:27.550]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.550]                     next
[13:20:27.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.550]                 }
[13:20:27.550]                 NAMES <- toupper(added)
[13:20:27.550]                 for (kk in seq_along(NAMES)) {
[13:20:27.550]                   name <- added[[kk]]
[13:20:27.550]                   NAME <- NAMES[[kk]]
[13:20:27.550]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.550]                     next
[13:20:27.550]                   args[[name]] <- ""
[13:20:27.550]                 }
[13:20:27.550]                 NAMES <- toupper(removed)
[13:20:27.550]                 for (kk in seq_along(NAMES)) {
[13:20:27.550]                   name <- removed[[kk]]
[13:20:27.550]                   NAME <- NAMES[[kk]]
[13:20:27.550]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.550]                     next
[13:20:27.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.550]                 }
[13:20:27.550]                 if (length(args) > 0) 
[13:20:27.550]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.550]             }
[13:20:27.550]             else {
[13:20:27.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.550]             }
[13:20:27.550]             {
[13:20:27.550]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.550]                   0L) {
[13:20:27.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.550]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.550]                   base::options(opts)
[13:20:27.550]                 }
[13:20:27.550]                 {
[13:20:27.550]                   {
[13:20:27.550]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.550]                     NULL
[13:20:27.550]                   }
[13:20:27.550]                   options(future.plan = NULL)
[13:20:27.550]                   if (is.na(NA_character_)) 
[13:20:27.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.550]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.550]                     envir = parent.frame()) 
[13:20:27.550]                   {
[13:20:27.550]                     default_workers <- missing(workers)
[13:20:27.550]                     if (is.function(workers)) 
[13:20:27.550]                       workers <- workers()
[13:20:27.550]                     workers <- structure(as.integer(workers), 
[13:20:27.550]                       class = class(workers))
[13:20:27.550]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.550]                       1L)
[13:20:27.550]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.550]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.550]                       if (default_workers) 
[13:20:27.550]                         supportsMulticore(warn = TRUE)
[13:20:27.550]                       return(sequential(..., envir = envir))
[13:20:27.550]                     }
[13:20:27.550]                     oopts <- options(mc.cores = workers)
[13:20:27.550]                     on.exit(options(oopts))
[13:20:27.550]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.550]                       envir = envir)
[13:20:27.550]                     if (!future$lazy) 
[13:20:27.550]                       future <- run(future)
[13:20:27.550]                     invisible(future)
[13:20:27.550]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.550]                 }
[13:20:27.550]             }
[13:20:27.550]         }
[13:20:27.550]     })
[13:20:27.550]     if (TRUE) {
[13:20:27.550]         base::sink(type = "output", split = FALSE)
[13:20:27.550]         if (TRUE) {
[13:20:27.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.550]         }
[13:20:27.550]         else {
[13:20:27.550]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.550]         }
[13:20:27.550]         base::close(...future.stdout)
[13:20:27.550]         ...future.stdout <- NULL
[13:20:27.550]     }
[13:20:27.550]     ...future.result$conditions <- ...future.conditions
[13:20:27.550]     ...future.result$finished <- base::Sys.time()
[13:20:27.550]     ...future.result
[13:20:27.550] }
[13:20:27.554] requestCore(): workers = 2
[13:20:27.554] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:27.569] MulticoreFuture started
[13:20:27.569] - Launch lazy future ... done
[13:20:27.569] run() for ‘MulticoreFuture’ ... done
[13:20:27.570] plan(): Setting new future strategy stack:
<environment: 0x55659d7fb320> 
[13:20:27.570] List of future strategies:
[13:20:27.570] 1. sequential:
[13:20:27.570]    - args: function (..., envir = parent.frame())
[13:20:27.570]    - tweaked: FALSE
[13:20:27.570]    - call: NULL
[13:20:27.572] plan(): nbrOfWorkers() = 1
<environment: 0x55659bbedd90> 
[13:20:27.574] plan(): Setting new future strategy stack:
[13:20:27.574] List of future strategies:
[13:20:27.574] 1. multicore:
[13:20:27.574]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.574]    - tweaked: FALSE
[13:20:27.574]    - call: plan(strategy)
[13:20:27.580] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:27.582] resolve() on environment ...
[13:20:27.582]  recursive: 0
[13:20:27.583]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:27.583] signalConditionsASAP(numeric, pos=1) ...
[13:20:27.583] - nx: 4
[13:20:27.583] - relay: TRUE
[13:20:27.583] - stdout: TRUE
[13:20:27.584] - signal: TRUE
[13:20:27.584] - resignal: FALSE
[13:20:27.584] - force: TRUE
[13:20:27.584] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.584] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.584]  - until=2
[13:20:27.584]  - relaying element #2
[13:20:27.585] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:27.585] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.585] signalConditionsASAP(NULL, pos=1) ... done
[13:20:27.585]  length: 3 (resolved future 1)
[13:20:27.585] Future #2
[13:20:27.586] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:27.586] - nx: 4
[13:20:27.586] - relay: TRUE
[13:20:27.586] - stdout: TRUE
[13:20:27.586] - signal: TRUE
[13:20:27.586] - resignal: FALSE
[13:20:27.586] - force: TRUE
[13:20:27.586] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:27.587] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.587]  - until=2
[13:20:27.587]  - relaying element #2
[13:20:27.587] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:27.587] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:27.587] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:27.588]  length: 2 (resolved future 2)
[13:20:27.588] Future #3
[13:20:27.589] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:27.589] - nx: 4
[13:20:27.589] - relay: TRUE
[13:20:27.590] - stdout: TRUE
[13:20:27.590] - signal: TRUE
[13:20:27.590] - resignal: FALSE
[13:20:27.590] - force: TRUE
[13:20:27.590] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:27.590] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:27.591]  - until=3
[13:20:27.591]  - relaying element #3
[13:20:27.591] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:27.591] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:27.592] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:27.592]  length: 1 (resolved future 3)
[13:20:27.592] Future #4
[13:20:27.593] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:20:27.593] - nx: 4
[13:20:27.594] - relay: TRUE
[13:20:27.594] - stdout: TRUE
[13:20:27.594] - signal: TRUE
[13:20:27.594] - resignal: FALSE
[13:20:27.594] - force: TRUE
[13:20:27.594] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:27.595] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:27.595]  - until=4
[13:20:27.595]  - relaying element #4
[13:20:27.595] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.595] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:27.596] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:20:27.596]  length: 0 (resolved future 4)
[13:20:27.596] Relaying remaining futures
[13:20:27.596] signalConditionsASAP(NULL, pos=0) ...
[13:20:27.596] - nx: 4
[13:20:27.597] - relay: TRUE
[13:20:27.597] - stdout: TRUE
[13:20:27.597] - signal: TRUE
[13:20:27.597] - resignal: FALSE
[13:20:27.597] - force: TRUE
[13:20:27.597] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.597] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:27.598] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.598] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:27.598] signalConditionsASAP(NULL, pos=0) ... done
[13:20:27.598] resolve() on environment ... DONE
<environment: 0x55659ba9eb68> 
Dimensions: c(2, 3, 1)
[13:20:27.599] getGlobalsAndPackages() ...
[13:20:27.599] Searching for globals...
[13:20:27.599] 
[13:20:27.599] Searching for globals ... DONE
[13:20:27.599] - globals: [0] <none>
[13:20:27.600] getGlobalsAndPackages() ... DONE
[13:20:27.600] run() for ‘Future’ ...
[13:20:27.600] - state: ‘created’
[13:20:27.600] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.604] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.604] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.605]   - Field: ‘label’
[13:20:27.605]   - Field: ‘local’
[13:20:27.605]   - Field: ‘owner’
[13:20:27.605]   - Field: ‘envir’
[13:20:27.605]   - Field: ‘workers’
[13:20:27.605]   - Field: ‘packages’
[13:20:27.605]   - Field: ‘gc’
[13:20:27.605]   - Field: ‘job’
[13:20:27.606]   - Field: ‘conditions’
[13:20:27.606]   - Field: ‘expr’
[13:20:27.606]   - Field: ‘uuid’
[13:20:27.606]   - Field: ‘seed’
[13:20:27.606]   - Field: ‘version’
[13:20:27.606]   - Field: ‘result’
[13:20:27.606]   - Field: ‘asynchronous’
[13:20:27.606]   - Field: ‘calls’
[13:20:27.606]   - Field: ‘globals’
[13:20:27.607]   - Field: ‘stdout’
[13:20:27.607]   - Field: ‘earlySignal’
[13:20:27.607]   - Field: ‘lazy’
[13:20:27.607]   - Field: ‘state’
[13:20:27.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.607] - Launch lazy future ...
[13:20:27.607] Packages needed by the future expression (n = 0): <none>
[13:20:27.608] Packages needed by future strategies (n = 0): <none>
[13:20:27.608] {
[13:20:27.608]     {
[13:20:27.608]         {
[13:20:27.608]             ...future.startTime <- base::Sys.time()
[13:20:27.608]             {
[13:20:27.608]                 {
[13:20:27.608]                   {
[13:20:27.608]                     {
[13:20:27.608]                       base::local({
[13:20:27.608]                         has_future <- base::requireNamespace("future", 
[13:20:27.608]                           quietly = TRUE)
[13:20:27.608]                         if (has_future) {
[13:20:27.608]                           ns <- base::getNamespace("future")
[13:20:27.608]                           version <- ns[[".package"]][["version"]]
[13:20:27.608]                           if (is.null(version)) 
[13:20:27.608]                             version <- utils::packageVersion("future")
[13:20:27.608]                         }
[13:20:27.608]                         else {
[13:20:27.608]                           version <- NULL
[13:20:27.608]                         }
[13:20:27.608]                         if (!has_future || version < "1.8.0") {
[13:20:27.608]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.608]                             "", base::R.version$version.string), 
[13:20:27.608]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.608]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.608]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.608]                               "release", "version")], collapse = " "), 
[13:20:27.608]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.608]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.608]                             info)
[13:20:27.608]                           info <- base::paste(info, collapse = "; ")
[13:20:27.608]                           if (!has_future) {
[13:20:27.608]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.608]                               info)
[13:20:27.608]                           }
[13:20:27.608]                           else {
[13:20:27.608]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.608]                               info, version)
[13:20:27.608]                           }
[13:20:27.608]                           base::stop(msg)
[13:20:27.608]                         }
[13:20:27.608]                       })
[13:20:27.608]                     }
[13:20:27.608]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.608]                     base::options(mc.cores = 1L)
[13:20:27.608]                   }
[13:20:27.608]                   options(future.plan = NULL)
[13:20:27.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.608]                 }
[13:20:27.608]                 ...future.workdir <- getwd()
[13:20:27.608]             }
[13:20:27.608]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.608]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.608]         }
[13:20:27.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.608]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.608]             base::names(...future.oldOptions))
[13:20:27.608]     }
[13:20:27.608]     if (FALSE) {
[13:20:27.608]     }
[13:20:27.608]     else {
[13:20:27.608]         if (TRUE) {
[13:20:27.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.608]                 open = "w")
[13:20:27.608]         }
[13:20:27.608]         else {
[13:20:27.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.608]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.608]         }
[13:20:27.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.608]             base::sink(type = "output", split = FALSE)
[13:20:27.608]             base::close(...future.stdout)
[13:20:27.608]         }, add = TRUE)
[13:20:27.608]     }
[13:20:27.608]     ...future.frame <- base::sys.nframe()
[13:20:27.608]     ...future.conditions <- base::list()
[13:20:27.608]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.608]     if (FALSE) {
[13:20:27.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.608]     }
[13:20:27.608]     ...future.result <- base::tryCatch({
[13:20:27.608]         base::withCallingHandlers({
[13:20:27.608]             ...future.value <- base::withVisible(base::local({
[13:20:27.608]                 withCallingHandlers({
[13:20:27.608]                   2
[13:20:27.608]                 }, immediateCondition = function(cond) {
[13:20:27.608]                   save_rds <- function (object, pathname, ...) 
[13:20:27.608]                   {
[13:20:27.608]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.608]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.608]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.608]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.608]                         fi_tmp[["mtime"]])
[13:20:27.608]                     }
[13:20:27.608]                     tryCatch({
[13:20:27.608]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.608]                     }, error = function(ex) {
[13:20:27.608]                       msg <- conditionMessage(ex)
[13:20:27.608]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.608]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.608]                         fi_tmp[["mtime"]], msg)
[13:20:27.608]                       ex$message <- msg
[13:20:27.608]                       stop(ex)
[13:20:27.608]                     })
[13:20:27.608]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.608]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.608]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.608]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.608]                       fi <- file.info(pathname)
[13:20:27.608]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.608]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.608]                         fi[["size"]], fi[["mtime"]])
[13:20:27.608]                       stop(msg)
[13:20:27.608]                     }
[13:20:27.608]                     invisible(pathname)
[13:20:27.608]                   }
[13:20:27.608]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.608]                     rootPath = tempdir()) 
[13:20:27.608]                   {
[13:20:27.608]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.608]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.608]                       tmpdir = path, fileext = ".rds")
[13:20:27.608]                     save_rds(obj, file)
[13:20:27.608]                   }
[13:20:27.608]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.608]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.608]                   {
[13:20:27.608]                     inherits <- base::inherits
[13:20:27.608]                     invokeRestart <- base::invokeRestart
[13:20:27.608]                     is.null <- base::is.null
[13:20:27.608]                     muffled <- FALSE
[13:20:27.608]                     if (inherits(cond, "message")) {
[13:20:27.608]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.608]                       if (muffled) 
[13:20:27.608]                         invokeRestart("muffleMessage")
[13:20:27.608]                     }
[13:20:27.608]                     else if (inherits(cond, "warning")) {
[13:20:27.608]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.608]                       if (muffled) 
[13:20:27.608]                         invokeRestart("muffleWarning")
[13:20:27.608]                     }
[13:20:27.608]                     else if (inherits(cond, "condition")) {
[13:20:27.608]                       if (!is.null(pattern)) {
[13:20:27.608]                         computeRestarts <- base::computeRestarts
[13:20:27.608]                         grepl <- base::grepl
[13:20:27.608]                         restarts <- computeRestarts(cond)
[13:20:27.608]                         for (restart in restarts) {
[13:20:27.608]                           name <- restart$name
[13:20:27.608]                           if (is.null(name)) 
[13:20:27.608]                             next
[13:20:27.608]                           if (!grepl(pattern, name)) 
[13:20:27.608]                             next
[13:20:27.608]                           invokeRestart(restart)
[13:20:27.608]                           muffled <- TRUE
[13:20:27.608]                           break
[13:20:27.608]                         }
[13:20:27.608]                       }
[13:20:27.608]                     }
[13:20:27.608]                     invisible(muffled)
[13:20:27.608]                   }
[13:20:27.608]                   muffleCondition(cond)
[13:20:27.608]                 })
[13:20:27.608]             }))
[13:20:27.608]             future::FutureResult(value = ...future.value$value, 
[13:20:27.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.608]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.608]                     ...future.globalenv.names))
[13:20:27.608]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.608]         }, condition = base::local({
[13:20:27.608]             c <- base::c
[13:20:27.608]             inherits <- base::inherits
[13:20:27.608]             invokeRestart <- base::invokeRestart
[13:20:27.608]             length <- base::length
[13:20:27.608]             list <- base::list
[13:20:27.608]             seq.int <- base::seq.int
[13:20:27.608]             signalCondition <- base::signalCondition
[13:20:27.608]             sys.calls <- base::sys.calls
[13:20:27.608]             `[[` <- base::`[[`
[13:20:27.608]             `+` <- base::`+`
[13:20:27.608]             `<<-` <- base::`<<-`
[13:20:27.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.608]                   3L)]
[13:20:27.608]             }
[13:20:27.608]             function(cond) {
[13:20:27.608]                 is_error <- inherits(cond, "error")
[13:20:27.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.608]                   NULL)
[13:20:27.608]                 if (is_error) {
[13:20:27.608]                   sessionInformation <- function() {
[13:20:27.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.608]                       search = base::search(), system = base::Sys.info())
[13:20:27.608]                   }
[13:20:27.608]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.608]                     cond$call), session = sessionInformation(), 
[13:20:27.608]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.608]                   signalCondition(cond)
[13:20:27.608]                 }
[13:20:27.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.608]                 "immediateCondition"))) {
[13:20:27.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.608]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.608]                   if (TRUE && !signal) {
[13:20:27.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.608]                     {
[13:20:27.608]                       inherits <- base::inherits
[13:20:27.608]                       invokeRestart <- base::invokeRestart
[13:20:27.608]                       is.null <- base::is.null
[13:20:27.608]                       muffled <- FALSE
[13:20:27.608]                       if (inherits(cond, "message")) {
[13:20:27.608]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.608]                         if (muffled) 
[13:20:27.608]                           invokeRestart("muffleMessage")
[13:20:27.608]                       }
[13:20:27.608]                       else if (inherits(cond, "warning")) {
[13:20:27.608]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.608]                         if (muffled) 
[13:20:27.608]                           invokeRestart("muffleWarning")
[13:20:27.608]                       }
[13:20:27.608]                       else if (inherits(cond, "condition")) {
[13:20:27.608]                         if (!is.null(pattern)) {
[13:20:27.608]                           computeRestarts <- base::computeRestarts
[13:20:27.608]                           grepl <- base::grepl
[13:20:27.608]                           restarts <- computeRestarts(cond)
[13:20:27.608]                           for (restart in restarts) {
[13:20:27.608]                             name <- restart$name
[13:20:27.608]                             if (is.null(name)) 
[13:20:27.608]                               next
[13:20:27.608]                             if (!grepl(pattern, name)) 
[13:20:27.608]                               next
[13:20:27.608]                             invokeRestart(restart)
[13:20:27.608]                             muffled <- TRUE
[13:20:27.608]                             break
[13:20:27.608]                           }
[13:20:27.608]                         }
[13:20:27.608]                       }
[13:20:27.608]                       invisible(muffled)
[13:20:27.608]                     }
[13:20:27.608]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.608]                   }
[13:20:27.608]                 }
[13:20:27.608]                 else {
[13:20:27.608]                   if (TRUE) {
[13:20:27.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.608]                     {
[13:20:27.608]                       inherits <- base::inherits
[13:20:27.608]                       invokeRestart <- base::invokeRestart
[13:20:27.608]                       is.null <- base::is.null
[13:20:27.608]                       muffled <- FALSE
[13:20:27.608]                       if (inherits(cond, "message")) {
[13:20:27.608]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.608]                         if (muffled) 
[13:20:27.608]                           invokeRestart("muffleMessage")
[13:20:27.608]                       }
[13:20:27.608]                       else if (inherits(cond, "warning")) {
[13:20:27.608]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.608]                         if (muffled) 
[13:20:27.608]                           invokeRestart("muffleWarning")
[13:20:27.608]                       }
[13:20:27.608]                       else if (inherits(cond, "condition")) {
[13:20:27.608]                         if (!is.null(pattern)) {
[13:20:27.608]                           computeRestarts <- base::computeRestarts
[13:20:27.608]                           grepl <- base::grepl
[13:20:27.608]                           restarts <- computeRestarts(cond)
[13:20:27.608]                           for (restart in restarts) {
[13:20:27.608]                             name <- restart$name
[13:20:27.608]                             if (is.null(name)) 
[13:20:27.608]                               next
[13:20:27.608]                             if (!grepl(pattern, name)) 
[13:20:27.608]                               next
[13:20:27.608]                             invokeRestart(restart)
[13:20:27.608]                             muffled <- TRUE
[13:20:27.608]                             break
[13:20:27.608]                           }
[13:20:27.608]                         }
[13:20:27.608]                       }
[13:20:27.608]                       invisible(muffled)
[13:20:27.608]                     }
[13:20:27.608]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.608]                   }
[13:20:27.608]                 }
[13:20:27.608]             }
[13:20:27.608]         }))
[13:20:27.608]     }, error = function(ex) {
[13:20:27.608]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.608]                 ...future.rng), started = ...future.startTime, 
[13:20:27.608]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.608]             version = "1.8"), class = "FutureResult")
[13:20:27.608]     }, finally = {
[13:20:27.608]         if (!identical(...future.workdir, getwd())) 
[13:20:27.608]             setwd(...future.workdir)
[13:20:27.608]         {
[13:20:27.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.608]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.608]             }
[13:20:27.608]             base::options(...future.oldOptions)
[13:20:27.608]             if (.Platform$OS.type == "windows") {
[13:20:27.608]                 old_names <- names(...future.oldEnvVars)
[13:20:27.608]                 envs <- base::Sys.getenv()
[13:20:27.608]                 names <- names(envs)
[13:20:27.608]                 common <- intersect(names, old_names)
[13:20:27.608]                 added <- setdiff(names, old_names)
[13:20:27.608]                 removed <- setdiff(old_names, names)
[13:20:27.608]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.608]                   envs[common]]
[13:20:27.608]                 NAMES <- toupper(changed)
[13:20:27.608]                 args <- list()
[13:20:27.608]                 for (kk in seq_along(NAMES)) {
[13:20:27.608]                   name <- changed[[kk]]
[13:20:27.608]                   NAME <- NAMES[[kk]]
[13:20:27.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.608]                     next
[13:20:27.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.608]                 }
[13:20:27.608]                 NAMES <- toupper(added)
[13:20:27.608]                 for (kk in seq_along(NAMES)) {
[13:20:27.608]                   name <- added[[kk]]
[13:20:27.608]                   NAME <- NAMES[[kk]]
[13:20:27.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.608]                     next
[13:20:27.608]                   args[[name]] <- ""
[13:20:27.608]                 }
[13:20:27.608]                 NAMES <- toupper(removed)
[13:20:27.608]                 for (kk in seq_along(NAMES)) {
[13:20:27.608]                   name <- removed[[kk]]
[13:20:27.608]                   NAME <- NAMES[[kk]]
[13:20:27.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.608]                     next
[13:20:27.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.608]                 }
[13:20:27.608]                 if (length(args) > 0) 
[13:20:27.608]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.608]             }
[13:20:27.608]             else {
[13:20:27.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.608]             }
[13:20:27.608]             {
[13:20:27.608]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.608]                   0L) {
[13:20:27.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.608]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.608]                   base::options(opts)
[13:20:27.608]                 }
[13:20:27.608]                 {
[13:20:27.608]                   {
[13:20:27.608]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.608]                     NULL
[13:20:27.608]                   }
[13:20:27.608]                   options(future.plan = NULL)
[13:20:27.608]                   if (is.na(NA_character_)) 
[13:20:27.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.608]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.608]                     envir = parent.frame()) 
[13:20:27.608]                   {
[13:20:27.608]                     default_workers <- missing(workers)
[13:20:27.608]                     if (is.function(workers)) 
[13:20:27.608]                       workers <- workers()
[13:20:27.608]                     workers <- structure(as.integer(workers), 
[13:20:27.608]                       class = class(workers))
[13:20:27.608]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.608]                       1L)
[13:20:27.608]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.608]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.608]                       if (default_workers) 
[13:20:27.608]                         supportsMulticore(warn = TRUE)
[13:20:27.608]                       return(sequential(..., envir = envir))
[13:20:27.608]                     }
[13:20:27.608]                     oopts <- options(mc.cores = workers)
[13:20:27.608]                     on.exit(options(oopts))
[13:20:27.608]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.608]                       envir = envir)
[13:20:27.608]                     if (!future$lazy) 
[13:20:27.608]                       future <- run(future)
[13:20:27.608]                     invisible(future)
[13:20:27.608]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.608]                 }
[13:20:27.608]             }
[13:20:27.608]         }
[13:20:27.608]     })
[13:20:27.608]     if (TRUE) {
[13:20:27.608]         base::sink(type = "output", split = FALSE)
[13:20:27.608]         if (TRUE) {
[13:20:27.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.608]         }
[13:20:27.608]         else {
[13:20:27.608]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.608]         }
[13:20:27.608]         base::close(...future.stdout)
[13:20:27.608]         ...future.stdout <- NULL
[13:20:27.608]     }
[13:20:27.608]     ...future.result$conditions <- ...future.conditions
[13:20:27.608]     ...future.result$finished <- base::Sys.time()
[13:20:27.608]     ...future.result
[13:20:27.608] }
[13:20:27.611] requestCore(): workers = 2
[13:20:27.613] MulticoreFuture started
[13:20:27.614] - Launch lazy future ... done
[13:20:27.614] run() for ‘MulticoreFuture’ ... done
[13:20:27.614] getGlobalsAndPackages() ...
[13:20:27.614] Searching for globals...
[13:20:27.615] plan(): Setting new future strategy stack:
[13:20:27.615] 
[13:20:27.615] List of future strategies:
[13:20:27.615] 1. sequential:
[13:20:27.615]    - args: function (..., envir = parent.frame())
[13:20:27.615]    - tweaked: FALSE
[13:20:27.615]    - call: NULL
[13:20:27.615] Searching for globals ... DONE
[13:20:27.616] - globals: [0] <none>
[13:20:27.616] getGlobalsAndPackages() ... DONE
[13:20:27.616] plan(): nbrOfWorkers() = 1
[13:20:27.616] run() for ‘Future’ ...
[13:20:27.616] - state: ‘created’
[13:20:27.617] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.618] plan(): Setting new future strategy stack:
[13:20:27.618] List of future strategies:
[13:20:27.618] 1. multicore:
[13:20:27.618]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.618]    - tweaked: FALSE
[13:20:27.618]    - call: plan(strategy)
[13:20:27.622] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.622] plan(): nbrOfWorkers() = 2
[13:20:27.622] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.623]   - Field: ‘label’
[13:20:27.623]   - Field: ‘local’
[13:20:27.623]   - Field: ‘owner’
[13:20:27.623]   - Field: ‘envir’
[13:20:27.623]   - Field: ‘workers’
[13:20:27.623]   - Field: ‘packages’
[13:20:27.624]   - Field: ‘gc’
[13:20:27.624]   - Field: ‘job’
[13:20:27.624]   - Field: ‘conditions’
[13:20:27.624]   - Field: ‘expr’
[13:20:27.624]   - Field: ‘uuid’
[13:20:27.624]   - Field: ‘seed’
[13:20:27.624]   - Field: ‘version’
[13:20:27.625]   - Field: ‘result’
[13:20:27.625]   - Field: ‘asynchronous’
[13:20:27.625]   - Field: ‘calls’
[13:20:27.625]   - Field: ‘globals’
[13:20:27.625]   - Field: ‘stdout’
[13:20:27.625]   - Field: ‘earlySignal’
[13:20:27.626]   - Field: ‘lazy’
[13:20:27.626]   - Field: ‘state’
[13:20:27.626] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.626] - Launch lazy future ...
[13:20:27.627] Packages needed by the future expression (n = 0): <none>
[13:20:27.627] Packages needed by future strategies (n = 0): <none>
[13:20:27.627] {
[13:20:27.627]     {
[13:20:27.627]         {
[13:20:27.627]             ...future.startTime <- base::Sys.time()
[13:20:27.627]             {
[13:20:27.627]                 {
[13:20:27.627]                   {
[13:20:27.627]                     {
[13:20:27.627]                       base::local({
[13:20:27.627]                         has_future <- base::requireNamespace("future", 
[13:20:27.627]                           quietly = TRUE)
[13:20:27.627]                         if (has_future) {
[13:20:27.627]                           ns <- base::getNamespace("future")
[13:20:27.627]                           version <- ns[[".package"]][["version"]]
[13:20:27.627]                           if (is.null(version)) 
[13:20:27.627]                             version <- utils::packageVersion("future")
[13:20:27.627]                         }
[13:20:27.627]                         else {
[13:20:27.627]                           version <- NULL
[13:20:27.627]                         }
[13:20:27.627]                         if (!has_future || version < "1.8.0") {
[13:20:27.627]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.627]                             "", base::R.version$version.string), 
[13:20:27.627]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.627]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.627]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.627]                               "release", "version")], collapse = " "), 
[13:20:27.627]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.627]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.627]                             info)
[13:20:27.627]                           info <- base::paste(info, collapse = "; ")
[13:20:27.627]                           if (!has_future) {
[13:20:27.627]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.627]                               info)
[13:20:27.627]                           }
[13:20:27.627]                           else {
[13:20:27.627]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.627]                               info, version)
[13:20:27.627]                           }
[13:20:27.627]                           base::stop(msg)
[13:20:27.627]                         }
[13:20:27.627]                       })
[13:20:27.627]                     }
[13:20:27.627]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.627]                     base::options(mc.cores = 1L)
[13:20:27.627]                   }
[13:20:27.627]                   options(future.plan = NULL)
[13:20:27.627]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.627]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.627]                 }
[13:20:27.627]                 ...future.workdir <- getwd()
[13:20:27.627]             }
[13:20:27.627]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.627]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.627]         }
[13:20:27.627]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.627]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.627]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.627]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.627]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.627]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.627]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.627]             base::names(...future.oldOptions))
[13:20:27.627]     }
[13:20:27.627]     if (FALSE) {
[13:20:27.627]     }
[13:20:27.627]     else {
[13:20:27.627]         if (TRUE) {
[13:20:27.627]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.627]                 open = "w")
[13:20:27.627]         }
[13:20:27.627]         else {
[13:20:27.627]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.627]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.627]         }
[13:20:27.627]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.627]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.627]             base::sink(type = "output", split = FALSE)
[13:20:27.627]             base::close(...future.stdout)
[13:20:27.627]         }, add = TRUE)
[13:20:27.627]     }
[13:20:27.627]     ...future.frame <- base::sys.nframe()
[13:20:27.627]     ...future.conditions <- base::list()
[13:20:27.627]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.627]     if (FALSE) {
[13:20:27.627]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.627]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.627]     }
[13:20:27.627]     ...future.result <- base::tryCatch({
[13:20:27.627]         base::withCallingHandlers({
[13:20:27.627]             ...future.value <- base::withVisible(base::local({
[13:20:27.627]                 withCallingHandlers({
[13:20:27.627]                   NULL
[13:20:27.627]                 }, immediateCondition = function(cond) {
[13:20:27.627]                   save_rds <- function (object, pathname, ...) 
[13:20:27.627]                   {
[13:20:27.627]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.627]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.627]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.627]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.627]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.627]                         fi_tmp[["mtime"]])
[13:20:27.627]                     }
[13:20:27.627]                     tryCatch({
[13:20:27.627]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.627]                     }, error = function(ex) {
[13:20:27.627]                       msg <- conditionMessage(ex)
[13:20:27.627]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.627]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.627]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.627]                         fi_tmp[["mtime"]], msg)
[13:20:27.627]                       ex$message <- msg
[13:20:27.627]                       stop(ex)
[13:20:27.627]                     })
[13:20:27.627]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.627]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.627]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.627]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.627]                       fi <- file.info(pathname)
[13:20:27.627]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.627]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.627]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.627]                         fi[["size"]], fi[["mtime"]])
[13:20:27.627]                       stop(msg)
[13:20:27.627]                     }
[13:20:27.627]                     invisible(pathname)
[13:20:27.627]                   }
[13:20:27.627]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.627]                     rootPath = tempdir()) 
[13:20:27.627]                   {
[13:20:27.627]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.627]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.627]                       tmpdir = path, fileext = ".rds")
[13:20:27.627]                     save_rds(obj, file)
[13:20:27.627]                   }
[13:20:27.627]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.627]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.627]                   {
[13:20:27.627]                     inherits <- base::inherits
[13:20:27.627]                     invokeRestart <- base::invokeRestart
[13:20:27.627]                     is.null <- base::is.null
[13:20:27.627]                     muffled <- FALSE
[13:20:27.627]                     if (inherits(cond, "message")) {
[13:20:27.627]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.627]                       if (muffled) 
[13:20:27.627]                         invokeRestart("muffleMessage")
[13:20:27.627]                     }
[13:20:27.627]                     else if (inherits(cond, "warning")) {
[13:20:27.627]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.627]                       if (muffled) 
[13:20:27.627]                         invokeRestart("muffleWarning")
[13:20:27.627]                     }
[13:20:27.627]                     else if (inherits(cond, "condition")) {
[13:20:27.627]                       if (!is.null(pattern)) {
[13:20:27.627]                         computeRestarts <- base::computeRestarts
[13:20:27.627]                         grepl <- base::grepl
[13:20:27.627]                         restarts <- computeRestarts(cond)
[13:20:27.627]                         for (restart in restarts) {
[13:20:27.627]                           name <- restart$name
[13:20:27.627]                           if (is.null(name)) 
[13:20:27.627]                             next
[13:20:27.627]                           if (!grepl(pattern, name)) 
[13:20:27.627]                             next
[13:20:27.627]                           invokeRestart(restart)
[13:20:27.627]                           muffled <- TRUE
[13:20:27.627]                           break
[13:20:27.627]                         }
[13:20:27.627]                       }
[13:20:27.627]                     }
[13:20:27.627]                     invisible(muffled)
[13:20:27.627]                   }
[13:20:27.627]                   muffleCondition(cond)
[13:20:27.627]                 })
[13:20:27.627]             }))
[13:20:27.627]             future::FutureResult(value = ...future.value$value, 
[13:20:27.627]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.627]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.627]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.627]                     ...future.globalenv.names))
[13:20:27.627]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.627]         }, condition = base::local({
[13:20:27.627]             c <- base::c
[13:20:27.627]             inherits <- base::inherits
[13:20:27.627]             invokeRestart <- base::invokeRestart
[13:20:27.627]             length <- base::length
[13:20:27.627]             list <- base::list
[13:20:27.627]             seq.int <- base::seq.int
[13:20:27.627]             signalCondition <- base::signalCondition
[13:20:27.627]             sys.calls <- base::sys.calls
[13:20:27.627]             `[[` <- base::`[[`
[13:20:27.627]             `+` <- base::`+`
[13:20:27.627]             `<<-` <- base::`<<-`
[13:20:27.627]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.627]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.627]                   3L)]
[13:20:27.627]             }
[13:20:27.627]             function(cond) {
[13:20:27.627]                 is_error <- inherits(cond, "error")
[13:20:27.627]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.627]                   NULL)
[13:20:27.627]                 if (is_error) {
[13:20:27.627]                   sessionInformation <- function() {
[13:20:27.627]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.627]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.627]                       search = base::search(), system = base::Sys.info())
[13:20:27.627]                   }
[13:20:27.627]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.627]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.627]                     cond$call), session = sessionInformation(), 
[13:20:27.627]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.627]                   signalCondition(cond)
[13:20:27.627]                 }
[13:20:27.627]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.627]                 "immediateCondition"))) {
[13:20:27.627]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.627]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.627]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.627]                   if (TRUE && !signal) {
[13:20:27.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.627]                     {
[13:20:27.627]                       inherits <- base::inherits
[13:20:27.627]                       invokeRestart <- base::invokeRestart
[13:20:27.627]                       is.null <- base::is.null
[13:20:27.627]                       muffled <- FALSE
[13:20:27.627]                       if (inherits(cond, "message")) {
[13:20:27.627]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.627]                         if (muffled) 
[13:20:27.627]                           invokeRestart("muffleMessage")
[13:20:27.627]                       }
[13:20:27.627]                       else if (inherits(cond, "warning")) {
[13:20:27.627]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.627]                         if (muffled) 
[13:20:27.627]                           invokeRestart("muffleWarning")
[13:20:27.627]                       }
[13:20:27.627]                       else if (inherits(cond, "condition")) {
[13:20:27.627]                         if (!is.null(pattern)) {
[13:20:27.627]                           computeRestarts <- base::computeRestarts
[13:20:27.627]                           grepl <- base::grepl
[13:20:27.627]                           restarts <- computeRestarts(cond)
[13:20:27.627]                           for (restart in restarts) {
[13:20:27.627]                             name <- restart$name
[13:20:27.627]                             if (is.null(name)) 
[13:20:27.627]                               next
[13:20:27.627]                             if (!grepl(pattern, name)) 
[13:20:27.627]                               next
[13:20:27.627]                             invokeRestart(restart)
[13:20:27.627]                             muffled <- TRUE
[13:20:27.627]                             break
[13:20:27.627]                           }
[13:20:27.627]                         }
[13:20:27.627]                       }
[13:20:27.627]                       invisible(muffled)
[13:20:27.627]                     }
[13:20:27.627]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.627]                   }
[13:20:27.627]                 }
[13:20:27.627]                 else {
[13:20:27.627]                   if (TRUE) {
[13:20:27.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.627]                     {
[13:20:27.627]                       inherits <- base::inherits
[13:20:27.627]                       invokeRestart <- base::invokeRestart
[13:20:27.627]                       is.null <- base::is.null
[13:20:27.627]                       muffled <- FALSE
[13:20:27.627]                       if (inherits(cond, "message")) {
[13:20:27.627]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.627]                         if (muffled) 
[13:20:27.627]                           invokeRestart("muffleMessage")
[13:20:27.627]                       }
[13:20:27.627]                       else if (inherits(cond, "warning")) {
[13:20:27.627]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.627]                         if (muffled) 
[13:20:27.627]                           invokeRestart("muffleWarning")
[13:20:27.627]                       }
[13:20:27.627]                       else if (inherits(cond, "condition")) {
[13:20:27.627]                         if (!is.null(pattern)) {
[13:20:27.627]                           computeRestarts <- base::computeRestarts
[13:20:27.627]                           grepl <- base::grepl
[13:20:27.627]                           restarts <- computeRestarts(cond)
[13:20:27.627]                           for (restart in restarts) {
[13:20:27.627]                             name <- restart$name
[13:20:27.627]                             if (is.null(name)) 
[13:20:27.627]                               next
[13:20:27.627]                             if (!grepl(pattern, name)) 
[13:20:27.627]                               next
[13:20:27.627]                             invokeRestart(restart)
[13:20:27.627]                             muffled <- TRUE
[13:20:27.627]                             break
[13:20:27.627]                           }
[13:20:27.627]                         }
[13:20:27.627]                       }
[13:20:27.627]                       invisible(muffled)
[13:20:27.627]                     }
[13:20:27.627]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.627]                   }
[13:20:27.627]                 }
[13:20:27.627]             }
[13:20:27.627]         }))
[13:20:27.627]     }, error = function(ex) {
[13:20:27.627]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.627]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.627]                 ...future.rng), started = ...future.startTime, 
[13:20:27.627]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.627]             version = "1.8"), class = "FutureResult")
[13:20:27.627]     }, finally = {
[13:20:27.627]         if (!identical(...future.workdir, getwd())) 
[13:20:27.627]             setwd(...future.workdir)
[13:20:27.627]         {
[13:20:27.627]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.627]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.627]             }
[13:20:27.627]             base::options(...future.oldOptions)
[13:20:27.627]             if (.Platform$OS.type == "windows") {
[13:20:27.627]                 old_names <- names(...future.oldEnvVars)
[13:20:27.627]                 envs <- base::Sys.getenv()
[13:20:27.627]                 names <- names(envs)
[13:20:27.627]                 common <- intersect(names, old_names)
[13:20:27.627]                 added <- setdiff(names, old_names)
[13:20:27.627]                 removed <- setdiff(old_names, names)
[13:20:27.627]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.627]                   envs[common]]
[13:20:27.627]                 NAMES <- toupper(changed)
[13:20:27.627]                 args <- list()
[13:20:27.627]                 for (kk in seq_along(NAMES)) {
[13:20:27.627]                   name <- changed[[kk]]
[13:20:27.627]                   NAME <- NAMES[[kk]]
[13:20:27.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.627]                     next
[13:20:27.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.627]                 }
[13:20:27.627]                 NAMES <- toupper(added)
[13:20:27.627]                 for (kk in seq_along(NAMES)) {
[13:20:27.627]                   name <- added[[kk]]
[13:20:27.627]                   NAME <- NAMES[[kk]]
[13:20:27.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.627]                     next
[13:20:27.627]                   args[[name]] <- ""
[13:20:27.627]                 }
[13:20:27.627]                 NAMES <- toupper(removed)
[13:20:27.627]                 for (kk in seq_along(NAMES)) {
[13:20:27.627]                   name <- removed[[kk]]
[13:20:27.627]                   NAME <- NAMES[[kk]]
[13:20:27.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.627]                     next
[13:20:27.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.627]                 }
[13:20:27.627]                 if (length(args) > 0) 
[13:20:27.627]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.627]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.627]             }
[13:20:27.627]             else {
[13:20:27.627]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.627]             }
[13:20:27.627]             {
[13:20:27.627]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.627]                   0L) {
[13:20:27.627]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.627]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.627]                   base::options(opts)
[13:20:27.627]                 }
[13:20:27.627]                 {
[13:20:27.627]                   {
[13:20:27.627]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.627]                     NULL
[13:20:27.627]                   }
[13:20:27.627]                   options(future.plan = NULL)
[13:20:27.627]                   if (is.na(NA_character_)) 
[13:20:27.627]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.627]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.627]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.627]                     envir = parent.frame()) 
[13:20:27.627]                   {
[13:20:27.627]                     default_workers <- missing(workers)
[13:20:27.627]                     if (is.function(workers)) 
[13:20:27.627]                       workers <- workers()
[13:20:27.627]                     workers <- structure(as.integer(workers), 
[13:20:27.627]                       class = class(workers))
[13:20:27.627]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.627]                       1L)
[13:20:27.627]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.627]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.627]                       if (default_workers) 
[13:20:27.627]                         supportsMulticore(warn = TRUE)
[13:20:27.627]                       return(sequential(..., envir = envir))
[13:20:27.627]                     }
[13:20:27.627]                     oopts <- options(mc.cores = workers)
[13:20:27.627]                     on.exit(options(oopts))
[13:20:27.627]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.627]                       envir = envir)
[13:20:27.627]                     if (!future$lazy) 
[13:20:27.627]                       future <- run(future)
[13:20:27.627]                     invisible(future)
[13:20:27.627]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.627]                 }
[13:20:27.627]             }
[13:20:27.627]         }
[13:20:27.627]     })
[13:20:27.627]     if (TRUE) {
[13:20:27.627]         base::sink(type = "output", split = FALSE)
[13:20:27.627]         if (TRUE) {
[13:20:27.627]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.627]         }
[13:20:27.627]         else {
[13:20:27.627]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.627]         }
[13:20:27.627]         base::close(...future.stdout)
[13:20:27.627]         ...future.stdout <- NULL
[13:20:27.627]     }
[13:20:27.627]     ...future.result$conditions <- ...future.conditions
[13:20:27.627]     ...future.result$finished <- base::Sys.time()
[13:20:27.627]     ...future.result
[13:20:27.627] }
[13:20:27.631] requestCore(): workers = 2
[13:20:27.634] MulticoreFuture started
[13:20:27.634] - Launch lazy future ... done
[13:20:27.634] run() for ‘MulticoreFuture’ ... done
[13:20:27.635] plan(): Setting new future strategy stack:
[13:20:27.635] getGlobalsAndPackages() ...
[13:20:27.635] Searching for globals...
[13:20:27.635] List of future strategies:
[13:20:27.635] 1. sequential:
[13:20:27.635]    - args: function (..., envir = parent.frame())
[13:20:27.635]    - tweaked: FALSE
[13:20:27.635]    - call: NULL
[13:20:27.636] plan(): nbrOfWorkers() = 1
[13:20:27.637] - globals found: [1] ‘{’
[13:20:27.637] Searching for globals ... DONE
[13:20:27.637] Resolving globals: FALSE
[13:20:27.638] 
[13:20:27.638] 
[13:20:27.638] getGlobalsAndPackages() ... DONE
[13:20:27.638] plan(): Setting new future strategy stack:
[13:20:27.638] run() for ‘Future’ ...
[13:20:27.639] - state: ‘created’
[13:20:27.638] List of future strategies:
[13:20:27.638] 1. multicore:
[13:20:27.638]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.638]    - tweaked: FALSE
[13:20:27.638]    - call: plan(strategy)
[13:20:27.639] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.644] plan(): nbrOfWorkers() = 2
[13:20:27.644] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.644] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.644]   - Field: ‘label’
[13:20:27.644]   - Field: ‘local’
[13:20:27.644]   - Field: ‘owner’
[13:20:27.645]   - Field: ‘envir’
[13:20:27.645]   - Field: ‘workers’
[13:20:27.645]   - Field: ‘packages’
[13:20:27.645]   - Field: ‘gc’
[13:20:27.645]   - Field: ‘job’
[13:20:27.645]   - Field: ‘conditions’
[13:20:27.645]   - Field: ‘expr’
[13:20:27.646]   - Field: ‘uuid’
[13:20:27.646]   - Field: ‘seed’
[13:20:27.646]   - Field: ‘version’
[13:20:27.646]   - Field: ‘result’
[13:20:27.646]   - Field: ‘asynchronous’
[13:20:27.646]   - Field: ‘calls’
[13:20:27.646]   - Field: ‘globals’
[13:20:27.647]   - Field: ‘stdout’
[13:20:27.647]   - Field: ‘earlySignal’
[13:20:27.647]   - Field: ‘lazy’
[13:20:27.647]   - Field: ‘state’
[13:20:27.647] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.647] - Launch lazy future ...
[13:20:27.648] Packages needed by the future expression (n = 0): <none>
[13:20:27.648] Packages needed by future strategies (n = 0): <none>
[13:20:27.649] {
[13:20:27.649]     {
[13:20:27.649]         {
[13:20:27.649]             ...future.startTime <- base::Sys.time()
[13:20:27.649]             {
[13:20:27.649]                 {
[13:20:27.649]                   {
[13:20:27.649]                     {
[13:20:27.649]                       base::local({
[13:20:27.649]                         has_future <- base::requireNamespace("future", 
[13:20:27.649]                           quietly = TRUE)
[13:20:27.649]                         if (has_future) {
[13:20:27.649]                           ns <- base::getNamespace("future")
[13:20:27.649]                           version <- ns[[".package"]][["version"]]
[13:20:27.649]                           if (is.null(version)) 
[13:20:27.649]                             version <- utils::packageVersion("future")
[13:20:27.649]                         }
[13:20:27.649]                         else {
[13:20:27.649]                           version <- NULL
[13:20:27.649]                         }
[13:20:27.649]                         if (!has_future || version < "1.8.0") {
[13:20:27.649]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.649]                             "", base::R.version$version.string), 
[13:20:27.649]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.649]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.649]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.649]                               "release", "version")], collapse = " "), 
[13:20:27.649]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.649]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.649]                             info)
[13:20:27.649]                           info <- base::paste(info, collapse = "; ")
[13:20:27.649]                           if (!has_future) {
[13:20:27.649]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.649]                               info)
[13:20:27.649]                           }
[13:20:27.649]                           else {
[13:20:27.649]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.649]                               info, version)
[13:20:27.649]                           }
[13:20:27.649]                           base::stop(msg)
[13:20:27.649]                         }
[13:20:27.649]                       })
[13:20:27.649]                     }
[13:20:27.649]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.649]                     base::options(mc.cores = 1L)
[13:20:27.649]                   }
[13:20:27.649]                   options(future.plan = NULL)
[13:20:27.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.649]                 }
[13:20:27.649]                 ...future.workdir <- getwd()
[13:20:27.649]             }
[13:20:27.649]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.649]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.649]         }
[13:20:27.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.649]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.649]             base::names(...future.oldOptions))
[13:20:27.649]     }
[13:20:27.649]     if (FALSE) {
[13:20:27.649]     }
[13:20:27.649]     else {
[13:20:27.649]         if (TRUE) {
[13:20:27.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.649]                 open = "w")
[13:20:27.649]         }
[13:20:27.649]         else {
[13:20:27.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.649]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.649]         }
[13:20:27.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.649]             base::sink(type = "output", split = FALSE)
[13:20:27.649]             base::close(...future.stdout)
[13:20:27.649]         }, add = TRUE)
[13:20:27.649]     }
[13:20:27.649]     ...future.frame <- base::sys.nframe()
[13:20:27.649]     ...future.conditions <- base::list()
[13:20:27.649]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.649]     if (FALSE) {
[13:20:27.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.649]     }
[13:20:27.649]     ...future.result <- base::tryCatch({
[13:20:27.649]         base::withCallingHandlers({
[13:20:27.649]             ...future.value <- base::withVisible(base::local({
[13:20:27.649]                 withCallingHandlers({
[13:20:27.649]                   {
[13:20:27.649]                     4
[13:20:27.649]                   }
[13:20:27.649]                 }, immediateCondition = function(cond) {
[13:20:27.649]                   save_rds <- function (object, pathname, ...) 
[13:20:27.649]                   {
[13:20:27.649]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.649]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.649]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.649]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.649]                         fi_tmp[["mtime"]])
[13:20:27.649]                     }
[13:20:27.649]                     tryCatch({
[13:20:27.649]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.649]                     }, error = function(ex) {
[13:20:27.649]                       msg <- conditionMessage(ex)
[13:20:27.649]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.649]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.649]                         fi_tmp[["mtime"]], msg)
[13:20:27.649]                       ex$message <- msg
[13:20:27.649]                       stop(ex)
[13:20:27.649]                     })
[13:20:27.649]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.649]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.649]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.649]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.649]                       fi <- file.info(pathname)
[13:20:27.649]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.649]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.649]                         fi[["size"]], fi[["mtime"]])
[13:20:27.649]                       stop(msg)
[13:20:27.649]                     }
[13:20:27.649]                     invisible(pathname)
[13:20:27.649]                   }
[13:20:27.649]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.649]                     rootPath = tempdir()) 
[13:20:27.649]                   {
[13:20:27.649]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.649]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.649]                       tmpdir = path, fileext = ".rds")
[13:20:27.649]                     save_rds(obj, file)
[13:20:27.649]                   }
[13:20:27.649]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.649]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.649]                   {
[13:20:27.649]                     inherits <- base::inherits
[13:20:27.649]                     invokeRestart <- base::invokeRestart
[13:20:27.649]                     is.null <- base::is.null
[13:20:27.649]                     muffled <- FALSE
[13:20:27.649]                     if (inherits(cond, "message")) {
[13:20:27.649]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.649]                       if (muffled) 
[13:20:27.649]                         invokeRestart("muffleMessage")
[13:20:27.649]                     }
[13:20:27.649]                     else if (inherits(cond, "warning")) {
[13:20:27.649]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.649]                       if (muffled) 
[13:20:27.649]                         invokeRestart("muffleWarning")
[13:20:27.649]                     }
[13:20:27.649]                     else if (inherits(cond, "condition")) {
[13:20:27.649]                       if (!is.null(pattern)) {
[13:20:27.649]                         computeRestarts <- base::computeRestarts
[13:20:27.649]                         grepl <- base::grepl
[13:20:27.649]                         restarts <- computeRestarts(cond)
[13:20:27.649]                         for (restart in restarts) {
[13:20:27.649]                           name <- restart$name
[13:20:27.649]                           if (is.null(name)) 
[13:20:27.649]                             next
[13:20:27.649]                           if (!grepl(pattern, name)) 
[13:20:27.649]                             next
[13:20:27.649]                           invokeRestart(restart)
[13:20:27.649]                           muffled <- TRUE
[13:20:27.649]                           break
[13:20:27.649]                         }
[13:20:27.649]                       }
[13:20:27.649]                     }
[13:20:27.649]                     invisible(muffled)
[13:20:27.649]                   }
[13:20:27.649]                   muffleCondition(cond)
[13:20:27.649]                 })
[13:20:27.649]             }))
[13:20:27.649]             future::FutureResult(value = ...future.value$value, 
[13:20:27.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.649]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.649]                     ...future.globalenv.names))
[13:20:27.649]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.649]         }, condition = base::local({
[13:20:27.649]             c <- base::c
[13:20:27.649]             inherits <- base::inherits
[13:20:27.649]             invokeRestart <- base::invokeRestart
[13:20:27.649]             length <- base::length
[13:20:27.649]             list <- base::list
[13:20:27.649]             seq.int <- base::seq.int
[13:20:27.649]             signalCondition <- base::signalCondition
[13:20:27.649]             sys.calls <- base::sys.calls
[13:20:27.649]             `[[` <- base::`[[`
[13:20:27.649]             `+` <- base::`+`
[13:20:27.649]             `<<-` <- base::`<<-`
[13:20:27.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.649]                   3L)]
[13:20:27.649]             }
[13:20:27.649]             function(cond) {
[13:20:27.649]                 is_error <- inherits(cond, "error")
[13:20:27.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.649]                   NULL)
[13:20:27.649]                 if (is_error) {
[13:20:27.649]                   sessionInformation <- function() {
[13:20:27.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.649]                       search = base::search(), system = base::Sys.info())
[13:20:27.649]                   }
[13:20:27.649]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.649]                     cond$call), session = sessionInformation(), 
[13:20:27.649]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.649]                   signalCondition(cond)
[13:20:27.649]                 }
[13:20:27.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.649]                 "immediateCondition"))) {
[13:20:27.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.649]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.649]                   if (TRUE && !signal) {
[13:20:27.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.649]                     {
[13:20:27.649]                       inherits <- base::inherits
[13:20:27.649]                       invokeRestart <- base::invokeRestart
[13:20:27.649]                       is.null <- base::is.null
[13:20:27.649]                       muffled <- FALSE
[13:20:27.649]                       if (inherits(cond, "message")) {
[13:20:27.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.649]                         if (muffled) 
[13:20:27.649]                           invokeRestart("muffleMessage")
[13:20:27.649]                       }
[13:20:27.649]                       else if (inherits(cond, "warning")) {
[13:20:27.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.649]                         if (muffled) 
[13:20:27.649]                           invokeRestart("muffleWarning")
[13:20:27.649]                       }
[13:20:27.649]                       else if (inherits(cond, "condition")) {
[13:20:27.649]                         if (!is.null(pattern)) {
[13:20:27.649]                           computeRestarts <- base::computeRestarts
[13:20:27.649]                           grepl <- base::grepl
[13:20:27.649]                           restarts <- computeRestarts(cond)
[13:20:27.649]                           for (restart in restarts) {
[13:20:27.649]                             name <- restart$name
[13:20:27.649]                             if (is.null(name)) 
[13:20:27.649]                               next
[13:20:27.649]                             if (!grepl(pattern, name)) 
[13:20:27.649]                               next
[13:20:27.649]                             invokeRestart(restart)
[13:20:27.649]                             muffled <- TRUE
[13:20:27.649]                             break
[13:20:27.649]                           }
[13:20:27.649]                         }
[13:20:27.649]                       }
[13:20:27.649]                       invisible(muffled)
[13:20:27.649]                     }
[13:20:27.649]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.649]                   }
[13:20:27.649]                 }
[13:20:27.649]                 else {
[13:20:27.649]                   if (TRUE) {
[13:20:27.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.649]                     {
[13:20:27.649]                       inherits <- base::inherits
[13:20:27.649]                       invokeRestart <- base::invokeRestart
[13:20:27.649]                       is.null <- base::is.null
[13:20:27.649]                       muffled <- FALSE
[13:20:27.649]                       if (inherits(cond, "message")) {
[13:20:27.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.649]                         if (muffled) 
[13:20:27.649]                           invokeRestart("muffleMessage")
[13:20:27.649]                       }
[13:20:27.649]                       else if (inherits(cond, "warning")) {
[13:20:27.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.649]                         if (muffled) 
[13:20:27.649]                           invokeRestart("muffleWarning")
[13:20:27.649]                       }
[13:20:27.649]                       else if (inherits(cond, "condition")) {
[13:20:27.649]                         if (!is.null(pattern)) {
[13:20:27.649]                           computeRestarts <- base::computeRestarts
[13:20:27.649]                           grepl <- base::grepl
[13:20:27.649]                           restarts <- computeRestarts(cond)
[13:20:27.649]                           for (restart in restarts) {
[13:20:27.649]                             name <- restart$name
[13:20:27.649]                             if (is.null(name)) 
[13:20:27.649]                               next
[13:20:27.649]                             if (!grepl(pattern, name)) 
[13:20:27.649]                               next
[13:20:27.649]                             invokeRestart(restart)
[13:20:27.649]                             muffled <- TRUE
[13:20:27.649]                             break
[13:20:27.649]                           }
[13:20:27.649]                         }
[13:20:27.649]                       }
[13:20:27.649]                       invisible(muffled)
[13:20:27.649]                     }
[13:20:27.649]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.649]                   }
[13:20:27.649]                 }
[13:20:27.649]             }
[13:20:27.649]         }))
[13:20:27.649]     }, error = function(ex) {
[13:20:27.649]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.649]                 ...future.rng), started = ...future.startTime, 
[13:20:27.649]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.649]             version = "1.8"), class = "FutureResult")
[13:20:27.649]     }, finally = {
[13:20:27.649]         if (!identical(...future.workdir, getwd())) 
[13:20:27.649]             setwd(...future.workdir)
[13:20:27.649]         {
[13:20:27.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.649]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.649]             }
[13:20:27.649]             base::options(...future.oldOptions)
[13:20:27.649]             if (.Platform$OS.type == "windows") {
[13:20:27.649]                 old_names <- names(...future.oldEnvVars)
[13:20:27.649]                 envs <- base::Sys.getenv()
[13:20:27.649]                 names <- names(envs)
[13:20:27.649]                 common <- intersect(names, old_names)
[13:20:27.649]                 added <- setdiff(names, old_names)
[13:20:27.649]                 removed <- setdiff(old_names, names)
[13:20:27.649]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.649]                   envs[common]]
[13:20:27.649]                 NAMES <- toupper(changed)
[13:20:27.649]                 args <- list()
[13:20:27.649]                 for (kk in seq_along(NAMES)) {
[13:20:27.649]                   name <- changed[[kk]]
[13:20:27.649]                   NAME <- NAMES[[kk]]
[13:20:27.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.649]                     next
[13:20:27.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.649]                 }
[13:20:27.649]                 NAMES <- toupper(added)
[13:20:27.649]                 for (kk in seq_along(NAMES)) {
[13:20:27.649]                   name <- added[[kk]]
[13:20:27.649]                   NAME <- NAMES[[kk]]
[13:20:27.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.649]                     next
[13:20:27.649]                   args[[name]] <- ""
[13:20:27.649]                 }
[13:20:27.649]                 NAMES <- toupper(removed)
[13:20:27.649]                 for (kk in seq_along(NAMES)) {
[13:20:27.649]                   name <- removed[[kk]]
[13:20:27.649]                   NAME <- NAMES[[kk]]
[13:20:27.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.649]                     next
[13:20:27.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.649]                 }
[13:20:27.649]                 if (length(args) > 0) 
[13:20:27.649]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.649]             }
[13:20:27.649]             else {
[13:20:27.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.649]             }
[13:20:27.649]             {
[13:20:27.649]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.649]                   0L) {
[13:20:27.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.649]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.649]                   base::options(opts)
[13:20:27.649]                 }
[13:20:27.649]                 {
[13:20:27.649]                   {
[13:20:27.649]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.649]                     NULL
[13:20:27.649]                   }
[13:20:27.649]                   options(future.plan = NULL)
[13:20:27.649]                   if (is.na(NA_character_)) 
[13:20:27.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.649]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.649]                     envir = parent.frame()) 
[13:20:27.649]                   {
[13:20:27.649]                     default_workers <- missing(workers)
[13:20:27.649]                     if (is.function(workers)) 
[13:20:27.649]                       workers <- workers()
[13:20:27.649]                     workers <- structure(as.integer(workers), 
[13:20:27.649]                       class = class(workers))
[13:20:27.649]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.649]                       1L)
[13:20:27.649]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.649]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.649]                       if (default_workers) 
[13:20:27.649]                         supportsMulticore(warn = TRUE)
[13:20:27.649]                       return(sequential(..., envir = envir))
[13:20:27.649]                     }
[13:20:27.649]                     oopts <- options(mc.cores = workers)
[13:20:27.649]                     on.exit(options(oopts))
[13:20:27.649]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.649]                       envir = envir)
[13:20:27.649]                     if (!future$lazy) 
[13:20:27.649]                       future <- run(future)
[13:20:27.649]                     invisible(future)
[13:20:27.649]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.649]                 }
[13:20:27.649]             }
[13:20:27.649]         }
[13:20:27.649]     })
[13:20:27.649]     if (TRUE) {
[13:20:27.649]         base::sink(type = "output", split = FALSE)
[13:20:27.649]         if (TRUE) {
[13:20:27.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.649]         }
[13:20:27.649]         else {
[13:20:27.649]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.649]         }
[13:20:27.649]         base::close(...future.stdout)
[13:20:27.649]         ...future.stdout <- NULL
[13:20:27.649]     }
[13:20:27.649]     ...future.result$conditions <- ...future.conditions
[13:20:27.649]     ...future.result$finished <- base::Sys.time()
[13:20:27.649]     ...future.result
[13:20:27.649] }
[13:20:27.652] requestCore(): workers = 2
[13:20:27.652] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:27.666] MulticoreFuture started
[13:20:27.667] - Launch lazy future ... done
[13:20:27.667] run() for ‘MulticoreFuture’ ... done
[13:20:27.668] plan(): Setting new future strategy stack:
<environment: 0x55659a843f20> 
[13:20:27.668] List of future strategies:
[13:20:27.668] 1. sequential:
[13:20:27.668]    - args: function (..., envir = parent.frame())
[13:20:27.668]    - tweaked: FALSE
[13:20:27.668]    - call: NULL
[13:20:27.669] plan(): nbrOfWorkers() = 1
<environment: 0x55659d0f8e78> 
[13:20:27.672] plan(): Setting new future strategy stack:
[13:20:27.672] List of future strategies:
[13:20:27.672] 1. multicore:
[13:20:27.672]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.672]    - tweaked: FALSE
[13:20:27.672]    - call: plan(strategy)
[13:20:27.677] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:27.679] resolve() on environment ...
[13:20:27.679]  recursive: 0
[13:20:27.680]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:27.680] signalConditionsASAP(numeric, pos=1) ...
[13:20:27.680] - nx: 4
[13:20:27.680] - relay: TRUE
[13:20:27.681] - stdout: TRUE
[13:20:27.681] - signal: TRUE
[13:20:27.681] - resignal: FALSE
[13:20:27.681] - force: TRUE
[13:20:27.681] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.681] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.681]  - until=2
[13:20:27.682]  - relaying element #2
[13:20:27.682] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:27.682] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.682] signalConditionsASAP(NULL, pos=1) ... done
[13:20:27.682]  length: 3 (resolved future 1)
[13:20:27.682] Future #2
[13:20:27.683] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:27.683] - nx: 4
[13:20:27.683] - relay: TRUE
[13:20:27.683] - stdout: TRUE
[13:20:27.683] - signal: TRUE
[13:20:27.683] - resignal: FALSE
[13:20:27.683] - force: TRUE
[13:20:27.683] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:27.683] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.684]  - until=2
[13:20:27.684]  - relaying element #2
[13:20:27.684] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:27.684] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:27.684] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:27.684]  length: 2 (resolved future 2)
[13:20:27.685] Future #3
[13:20:27.686] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:27.686] - nx: 4
[13:20:27.686] - relay: TRUE
[13:20:27.686] - stdout: TRUE
[13:20:27.686] - signal: TRUE
[13:20:27.686] - resignal: FALSE
[13:20:27.686] - force: TRUE
[13:20:27.687] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:27.687] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:27.687]  - until=3
[13:20:27.687]  - relaying element #3
[13:20:27.687] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:27.687] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:27.687] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:27.688]  length: 1 (resolved future 3)
[13:20:27.688] Future #4
[13:20:27.689] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:20:27.689] - nx: 4
[13:20:27.689] - relay: TRUE
[13:20:27.689] - stdout: TRUE
[13:20:27.689] - signal: TRUE
[13:20:27.690] - resignal: FALSE
[13:20:27.690] - force: TRUE
[13:20:27.690] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:27.690] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:27.690]  - until=4
[13:20:27.690]  - relaying element #4
[13:20:27.691] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.691] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:27.691] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:20:27.691]  length: 0 (resolved future 4)
[13:20:27.691] Relaying remaining futures
[13:20:27.692] signalConditionsASAP(NULL, pos=0) ...
[13:20:27.692] - nx: 4
[13:20:27.692] - relay: TRUE
[13:20:27.692] - stdout: TRUE
[13:20:27.692] - signal: TRUE
[13:20:27.692] - resignal: FALSE
[13:20:27.692] - force: TRUE
[13:20:27.692] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.692] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:27.693] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.693] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:27.693] signalConditionsASAP(NULL, pos=0) ... done
[13:20:27.693] resolve() on environment ... DONE
<environment: 0x55659d1b38f8> 
Dimensions: c(2, 1, 3, 1)
[13:20:27.694] getGlobalsAndPackages() ...
[13:20:27.694] Searching for globals...
[13:20:27.694] 
[13:20:27.694] Searching for globals ... DONE
[13:20:27.694] - globals: [0] <none>
[13:20:27.694] getGlobalsAndPackages() ... DONE
[13:20:27.695] run() for ‘Future’ ...
[13:20:27.695] - state: ‘created’
[13:20:27.695] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.699] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.699] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.699]   - Field: ‘label’
[13:20:27.700]   - Field: ‘local’
[13:20:27.700]   - Field: ‘owner’
[13:20:27.700]   - Field: ‘envir’
[13:20:27.700]   - Field: ‘workers’
[13:20:27.700]   - Field: ‘packages’
[13:20:27.700]   - Field: ‘gc’
[13:20:27.700]   - Field: ‘job’
[13:20:27.700]   - Field: ‘conditions’
[13:20:27.700]   - Field: ‘expr’
[13:20:27.701]   - Field: ‘uuid’
[13:20:27.701]   - Field: ‘seed’
[13:20:27.701]   - Field: ‘version’
[13:20:27.701]   - Field: ‘result’
[13:20:27.701]   - Field: ‘asynchronous’
[13:20:27.701]   - Field: ‘calls’
[13:20:27.701]   - Field: ‘globals’
[13:20:27.701]   - Field: ‘stdout’
[13:20:27.701]   - Field: ‘earlySignal’
[13:20:27.702]   - Field: ‘lazy’
[13:20:27.702]   - Field: ‘state’
[13:20:27.702] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.702] - Launch lazy future ...
[13:20:27.702] Packages needed by the future expression (n = 0): <none>
[13:20:27.702] Packages needed by future strategies (n = 0): <none>
[13:20:27.703] {
[13:20:27.703]     {
[13:20:27.703]         {
[13:20:27.703]             ...future.startTime <- base::Sys.time()
[13:20:27.703]             {
[13:20:27.703]                 {
[13:20:27.703]                   {
[13:20:27.703]                     {
[13:20:27.703]                       base::local({
[13:20:27.703]                         has_future <- base::requireNamespace("future", 
[13:20:27.703]                           quietly = TRUE)
[13:20:27.703]                         if (has_future) {
[13:20:27.703]                           ns <- base::getNamespace("future")
[13:20:27.703]                           version <- ns[[".package"]][["version"]]
[13:20:27.703]                           if (is.null(version)) 
[13:20:27.703]                             version <- utils::packageVersion("future")
[13:20:27.703]                         }
[13:20:27.703]                         else {
[13:20:27.703]                           version <- NULL
[13:20:27.703]                         }
[13:20:27.703]                         if (!has_future || version < "1.8.0") {
[13:20:27.703]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.703]                             "", base::R.version$version.string), 
[13:20:27.703]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.703]                               "release", "version")], collapse = " "), 
[13:20:27.703]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.703]                             info)
[13:20:27.703]                           info <- base::paste(info, collapse = "; ")
[13:20:27.703]                           if (!has_future) {
[13:20:27.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.703]                               info)
[13:20:27.703]                           }
[13:20:27.703]                           else {
[13:20:27.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.703]                               info, version)
[13:20:27.703]                           }
[13:20:27.703]                           base::stop(msg)
[13:20:27.703]                         }
[13:20:27.703]                       })
[13:20:27.703]                     }
[13:20:27.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.703]                     base::options(mc.cores = 1L)
[13:20:27.703]                   }
[13:20:27.703]                   options(future.plan = NULL)
[13:20:27.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.703]                 }
[13:20:27.703]                 ...future.workdir <- getwd()
[13:20:27.703]             }
[13:20:27.703]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.703]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.703]         }
[13:20:27.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.703]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.703]             base::names(...future.oldOptions))
[13:20:27.703]     }
[13:20:27.703]     if (FALSE) {
[13:20:27.703]     }
[13:20:27.703]     else {
[13:20:27.703]         if (TRUE) {
[13:20:27.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.703]                 open = "w")
[13:20:27.703]         }
[13:20:27.703]         else {
[13:20:27.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.703]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.703]         }
[13:20:27.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.703]             base::sink(type = "output", split = FALSE)
[13:20:27.703]             base::close(...future.stdout)
[13:20:27.703]         }, add = TRUE)
[13:20:27.703]     }
[13:20:27.703]     ...future.frame <- base::sys.nframe()
[13:20:27.703]     ...future.conditions <- base::list()
[13:20:27.703]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.703]     if (FALSE) {
[13:20:27.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.703]     }
[13:20:27.703]     ...future.result <- base::tryCatch({
[13:20:27.703]         base::withCallingHandlers({
[13:20:27.703]             ...future.value <- base::withVisible(base::local({
[13:20:27.703]                 withCallingHandlers({
[13:20:27.703]                   2
[13:20:27.703]                 }, immediateCondition = function(cond) {
[13:20:27.703]                   save_rds <- function (object, pathname, ...) 
[13:20:27.703]                   {
[13:20:27.703]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.703]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.703]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.703]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.703]                         fi_tmp[["mtime"]])
[13:20:27.703]                     }
[13:20:27.703]                     tryCatch({
[13:20:27.703]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.703]                     }, error = function(ex) {
[13:20:27.703]                       msg <- conditionMessage(ex)
[13:20:27.703]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.703]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.703]                         fi_tmp[["mtime"]], msg)
[13:20:27.703]                       ex$message <- msg
[13:20:27.703]                       stop(ex)
[13:20:27.703]                     })
[13:20:27.703]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.703]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.703]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.703]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.703]                       fi <- file.info(pathname)
[13:20:27.703]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.703]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.703]                         fi[["size"]], fi[["mtime"]])
[13:20:27.703]                       stop(msg)
[13:20:27.703]                     }
[13:20:27.703]                     invisible(pathname)
[13:20:27.703]                   }
[13:20:27.703]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.703]                     rootPath = tempdir()) 
[13:20:27.703]                   {
[13:20:27.703]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.703]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.703]                       tmpdir = path, fileext = ".rds")
[13:20:27.703]                     save_rds(obj, file)
[13:20:27.703]                   }
[13:20:27.703]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.703]                   {
[13:20:27.703]                     inherits <- base::inherits
[13:20:27.703]                     invokeRestart <- base::invokeRestart
[13:20:27.703]                     is.null <- base::is.null
[13:20:27.703]                     muffled <- FALSE
[13:20:27.703]                     if (inherits(cond, "message")) {
[13:20:27.703]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.703]                       if (muffled) 
[13:20:27.703]                         invokeRestart("muffleMessage")
[13:20:27.703]                     }
[13:20:27.703]                     else if (inherits(cond, "warning")) {
[13:20:27.703]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.703]                       if (muffled) 
[13:20:27.703]                         invokeRestart("muffleWarning")
[13:20:27.703]                     }
[13:20:27.703]                     else if (inherits(cond, "condition")) {
[13:20:27.703]                       if (!is.null(pattern)) {
[13:20:27.703]                         computeRestarts <- base::computeRestarts
[13:20:27.703]                         grepl <- base::grepl
[13:20:27.703]                         restarts <- computeRestarts(cond)
[13:20:27.703]                         for (restart in restarts) {
[13:20:27.703]                           name <- restart$name
[13:20:27.703]                           if (is.null(name)) 
[13:20:27.703]                             next
[13:20:27.703]                           if (!grepl(pattern, name)) 
[13:20:27.703]                             next
[13:20:27.703]                           invokeRestart(restart)
[13:20:27.703]                           muffled <- TRUE
[13:20:27.703]                           break
[13:20:27.703]                         }
[13:20:27.703]                       }
[13:20:27.703]                     }
[13:20:27.703]                     invisible(muffled)
[13:20:27.703]                   }
[13:20:27.703]                   muffleCondition(cond)
[13:20:27.703]                 })
[13:20:27.703]             }))
[13:20:27.703]             future::FutureResult(value = ...future.value$value, 
[13:20:27.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.703]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.703]                     ...future.globalenv.names))
[13:20:27.703]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.703]         }, condition = base::local({
[13:20:27.703]             c <- base::c
[13:20:27.703]             inherits <- base::inherits
[13:20:27.703]             invokeRestart <- base::invokeRestart
[13:20:27.703]             length <- base::length
[13:20:27.703]             list <- base::list
[13:20:27.703]             seq.int <- base::seq.int
[13:20:27.703]             signalCondition <- base::signalCondition
[13:20:27.703]             sys.calls <- base::sys.calls
[13:20:27.703]             `[[` <- base::`[[`
[13:20:27.703]             `+` <- base::`+`
[13:20:27.703]             `<<-` <- base::`<<-`
[13:20:27.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.703]                   3L)]
[13:20:27.703]             }
[13:20:27.703]             function(cond) {
[13:20:27.703]                 is_error <- inherits(cond, "error")
[13:20:27.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.703]                   NULL)
[13:20:27.703]                 if (is_error) {
[13:20:27.703]                   sessionInformation <- function() {
[13:20:27.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.703]                       search = base::search(), system = base::Sys.info())
[13:20:27.703]                   }
[13:20:27.703]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.703]                     cond$call), session = sessionInformation(), 
[13:20:27.703]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.703]                   signalCondition(cond)
[13:20:27.703]                 }
[13:20:27.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.703]                 "immediateCondition"))) {
[13:20:27.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.703]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.703]                   if (TRUE && !signal) {
[13:20:27.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.703]                     {
[13:20:27.703]                       inherits <- base::inherits
[13:20:27.703]                       invokeRestart <- base::invokeRestart
[13:20:27.703]                       is.null <- base::is.null
[13:20:27.703]                       muffled <- FALSE
[13:20:27.703]                       if (inherits(cond, "message")) {
[13:20:27.703]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.703]                         if (muffled) 
[13:20:27.703]                           invokeRestart("muffleMessage")
[13:20:27.703]                       }
[13:20:27.703]                       else if (inherits(cond, "warning")) {
[13:20:27.703]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.703]                         if (muffled) 
[13:20:27.703]                           invokeRestart("muffleWarning")
[13:20:27.703]                       }
[13:20:27.703]                       else if (inherits(cond, "condition")) {
[13:20:27.703]                         if (!is.null(pattern)) {
[13:20:27.703]                           computeRestarts <- base::computeRestarts
[13:20:27.703]                           grepl <- base::grepl
[13:20:27.703]                           restarts <- computeRestarts(cond)
[13:20:27.703]                           for (restart in restarts) {
[13:20:27.703]                             name <- restart$name
[13:20:27.703]                             if (is.null(name)) 
[13:20:27.703]                               next
[13:20:27.703]                             if (!grepl(pattern, name)) 
[13:20:27.703]                               next
[13:20:27.703]                             invokeRestart(restart)
[13:20:27.703]                             muffled <- TRUE
[13:20:27.703]                             break
[13:20:27.703]                           }
[13:20:27.703]                         }
[13:20:27.703]                       }
[13:20:27.703]                       invisible(muffled)
[13:20:27.703]                     }
[13:20:27.703]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.703]                   }
[13:20:27.703]                 }
[13:20:27.703]                 else {
[13:20:27.703]                   if (TRUE) {
[13:20:27.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.703]                     {
[13:20:27.703]                       inherits <- base::inherits
[13:20:27.703]                       invokeRestart <- base::invokeRestart
[13:20:27.703]                       is.null <- base::is.null
[13:20:27.703]                       muffled <- FALSE
[13:20:27.703]                       if (inherits(cond, "message")) {
[13:20:27.703]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.703]                         if (muffled) 
[13:20:27.703]                           invokeRestart("muffleMessage")
[13:20:27.703]                       }
[13:20:27.703]                       else if (inherits(cond, "warning")) {
[13:20:27.703]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.703]                         if (muffled) 
[13:20:27.703]                           invokeRestart("muffleWarning")
[13:20:27.703]                       }
[13:20:27.703]                       else if (inherits(cond, "condition")) {
[13:20:27.703]                         if (!is.null(pattern)) {
[13:20:27.703]                           computeRestarts <- base::computeRestarts
[13:20:27.703]                           grepl <- base::grepl
[13:20:27.703]                           restarts <- computeRestarts(cond)
[13:20:27.703]                           for (restart in restarts) {
[13:20:27.703]                             name <- restart$name
[13:20:27.703]                             if (is.null(name)) 
[13:20:27.703]                               next
[13:20:27.703]                             if (!grepl(pattern, name)) 
[13:20:27.703]                               next
[13:20:27.703]                             invokeRestart(restart)
[13:20:27.703]                             muffled <- TRUE
[13:20:27.703]                             break
[13:20:27.703]                           }
[13:20:27.703]                         }
[13:20:27.703]                       }
[13:20:27.703]                       invisible(muffled)
[13:20:27.703]                     }
[13:20:27.703]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.703]                   }
[13:20:27.703]                 }
[13:20:27.703]             }
[13:20:27.703]         }))
[13:20:27.703]     }, error = function(ex) {
[13:20:27.703]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.703]                 ...future.rng), started = ...future.startTime, 
[13:20:27.703]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.703]             version = "1.8"), class = "FutureResult")
[13:20:27.703]     }, finally = {
[13:20:27.703]         if (!identical(...future.workdir, getwd())) 
[13:20:27.703]             setwd(...future.workdir)
[13:20:27.703]         {
[13:20:27.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.703]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.703]             }
[13:20:27.703]             base::options(...future.oldOptions)
[13:20:27.703]             if (.Platform$OS.type == "windows") {
[13:20:27.703]                 old_names <- names(...future.oldEnvVars)
[13:20:27.703]                 envs <- base::Sys.getenv()
[13:20:27.703]                 names <- names(envs)
[13:20:27.703]                 common <- intersect(names, old_names)
[13:20:27.703]                 added <- setdiff(names, old_names)
[13:20:27.703]                 removed <- setdiff(old_names, names)
[13:20:27.703]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.703]                   envs[common]]
[13:20:27.703]                 NAMES <- toupper(changed)
[13:20:27.703]                 args <- list()
[13:20:27.703]                 for (kk in seq_along(NAMES)) {
[13:20:27.703]                   name <- changed[[kk]]
[13:20:27.703]                   NAME <- NAMES[[kk]]
[13:20:27.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.703]                     next
[13:20:27.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.703]                 }
[13:20:27.703]                 NAMES <- toupper(added)
[13:20:27.703]                 for (kk in seq_along(NAMES)) {
[13:20:27.703]                   name <- added[[kk]]
[13:20:27.703]                   NAME <- NAMES[[kk]]
[13:20:27.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.703]                     next
[13:20:27.703]                   args[[name]] <- ""
[13:20:27.703]                 }
[13:20:27.703]                 NAMES <- toupper(removed)
[13:20:27.703]                 for (kk in seq_along(NAMES)) {
[13:20:27.703]                   name <- removed[[kk]]
[13:20:27.703]                   NAME <- NAMES[[kk]]
[13:20:27.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.703]                     next
[13:20:27.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.703]                 }
[13:20:27.703]                 if (length(args) > 0) 
[13:20:27.703]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.703]             }
[13:20:27.703]             else {
[13:20:27.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.703]             }
[13:20:27.703]             {
[13:20:27.703]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.703]                   0L) {
[13:20:27.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.703]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.703]                   base::options(opts)
[13:20:27.703]                 }
[13:20:27.703]                 {
[13:20:27.703]                   {
[13:20:27.703]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.703]                     NULL
[13:20:27.703]                   }
[13:20:27.703]                   options(future.plan = NULL)
[13:20:27.703]                   if (is.na(NA_character_)) 
[13:20:27.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.703]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.703]                     envir = parent.frame()) 
[13:20:27.703]                   {
[13:20:27.703]                     default_workers <- missing(workers)
[13:20:27.703]                     if (is.function(workers)) 
[13:20:27.703]                       workers <- workers()
[13:20:27.703]                     workers <- structure(as.integer(workers), 
[13:20:27.703]                       class = class(workers))
[13:20:27.703]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.703]                       1L)
[13:20:27.703]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.703]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.703]                       if (default_workers) 
[13:20:27.703]                         supportsMulticore(warn = TRUE)
[13:20:27.703]                       return(sequential(..., envir = envir))
[13:20:27.703]                     }
[13:20:27.703]                     oopts <- options(mc.cores = workers)
[13:20:27.703]                     on.exit(options(oopts))
[13:20:27.703]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.703]                       envir = envir)
[13:20:27.703]                     if (!future$lazy) 
[13:20:27.703]                       future <- run(future)
[13:20:27.703]                     invisible(future)
[13:20:27.703]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.703]                 }
[13:20:27.703]             }
[13:20:27.703]         }
[13:20:27.703]     })
[13:20:27.703]     if (TRUE) {
[13:20:27.703]         base::sink(type = "output", split = FALSE)
[13:20:27.703]         if (TRUE) {
[13:20:27.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.703]         }
[13:20:27.703]         else {
[13:20:27.703]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.703]         }
[13:20:27.703]         base::close(...future.stdout)
[13:20:27.703]         ...future.stdout <- NULL
[13:20:27.703]     }
[13:20:27.703]     ...future.result$conditions <- ...future.conditions
[13:20:27.703]     ...future.result$finished <- base::Sys.time()
[13:20:27.703]     ...future.result
[13:20:27.703] }
[13:20:27.706] requestCore(): workers = 2
[13:20:27.708] MulticoreFuture started
[13:20:27.708] - Launch lazy future ... done
[13:20:27.708] run() for ‘MulticoreFuture’ ... done
[13:20:27.709] getGlobalsAndPackages() ...
[13:20:27.709] Searching for globals...
[13:20:27.709] plan(): Setting new future strategy stack:
[13:20:27.710] 
[13:20:27.709] List of future strategies:
[13:20:27.709] 1. sequential:
[13:20:27.709]    - args: function (..., envir = parent.frame())
[13:20:27.709]    - tweaked: FALSE
[13:20:27.709]    - call: NULL
[13:20:27.710] Searching for globals ... DONE
[13:20:27.710] - globals: [0] <none>
[13:20:27.710] getGlobalsAndPackages() ... DONE
[13:20:27.710] plan(): nbrOfWorkers() = 1
[13:20:27.711] run() for ‘Future’ ...
[13:20:27.711] - state: ‘created’
[13:20:27.711] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.712] plan(): Setting new future strategy stack:
[13:20:27.712] List of future strategies:
[13:20:27.712] 1. multicore:
[13:20:27.712]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.712]    - tweaked: FALSE
[13:20:27.712]    - call: plan(strategy)
[13:20:27.716] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.716] plan(): nbrOfWorkers() = 2
[13:20:27.716] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.716]   - Field: ‘label’
[13:20:27.717]   - Field: ‘local’
[13:20:27.717]   - Field: ‘owner’
[13:20:27.717]   - Field: ‘envir’
[13:20:27.717]   - Field: ‘workers’
[13:20:27.717]   - Field: ‘packages’
[13:20:27.717]   - Field: ‘gc’
[13:20:27.717]   - Field: ‘job’
[13:20:27.718]   - Field: ‘conditions’
[13:20:27.718]   - Field: ‘expr’
[13:20:27.718]   - Field: ‘uuid’
[13:20:27.718]   - Field: ‘seed’
[13:20:27.718]   - Field: ‘version’
[13:20:27.718]   - Field: ‘result’
[13:20:27.718]   - Field: ‘asynchronous’
[13:20:27.718]   - Field: ‘calls’
[13:20:27.719]   - Field: ‘globals’
[13:20:27.719]   - Field: ‘stdout’
[13:20:27.719]   - Field: ‘earlySignal’
[13:20:27.719]   - Field: ‘lazy’
[13:20:27.719]   - Field: ‘state’
[13:20:27.719] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.719] - Launch lazy future ...
[13:20:27.720] Packages needed by the future expression (n = 0): <none>
[13:20:27.720] Packages needed by future strategies (n = 0): <none>
[13:20:27.721] {
[13:20:27.721]     {
[13:20:27.721]         {
[13:20:27.721]             ...future.startTime <- base::Sys.time()
[13:20:27.721]             {
[13:20:27.721]                 {
[13:20:27.721]                   {
[13:20:27.721]                     {
[13:20:27.721]                       base::local({
[13:20:27.721]                         has_future <- base::requireNamespace("future", 
[13:20:27.721]                           quietly = TRUE)
[13:20:27.721]                         if (has_future) {
[13:20:27.721]                           ns <- base::getNamespace("future")
[13:20:27.721]                           version <- ns[[".package"]][["version"]]
[13:20:27.721]                           if (is.null(version)) 
[13:20:27.721]                             version <- utils::packageVersion("future")
[13:20:27.721]                         }
[13:20:27.721]                         else {
[13:20:27.721]                           version <- NULL
[13:20:27.721]                         }
[13:20:27.721]                         if (!has_future || version < "1.8.0") {
[13:20:27.721]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.721]                             "", base::R.version$version.string), 
[13:20:27.721]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.721]                               "release", "version")], collapse = " "), 
[13:20:27.721]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.721]                             info)
[13:20:27.721]                           info <- base::paste(info, collapse = "; ")
[13:20:27.721]                           if (!has_future) {
[13:20:27.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.721]                               info)
[13:20:27.721]                           }
[13:20:27.721]                           else {
[13:20:27.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.721]                               info, version)
[13:20:27.721]                           }
[13:20:27.721]                           base::stop(msg)
[13:20:27.721]                         }
[13:20:27.721]                       })
[13:20:27.721]                     }
[13:20:27.721]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.721]                     base::options(mc.cores = 1L)
[13:20:27.721]                   }
[13:20:27.721]                   options(future.plan = NULL)
[13:20:27.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.721]                 }
[13:20:27.721]                 ...future.workdir <- getwd()
[13:20:27.721]             }
[13:20:27.721]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.721]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.721]         }
[13:20:27.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.721]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.721]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.721]             base::names(...future.oldOptions))
[13:20:27.721]     }
[13:20:27.721]     if (FALSE) {
[13:20:27.721]     }
[13:20:27.721]     else {
[13:20:27.721]         if (TRUE) {
[13:20:27.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.721]                 open = "w")
[13:20:27.721]         }
[13:20:27.721]         else {
[13:20:27.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.721]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.721]         }
[13:20:27.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.721]             base::sink(type = "output", split = FALSE)
[13:20:27.721]             base::close(...future.stdout)
[13:20:27.721]         }, add = TRUE)
[13:20:27.721]     }
[13:20:27.721]     ...future.frame <- base::sys.nframe()
[13:20:27.721]     ...future.conditions <- base::list()
[13:20:27.721]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.721]     if (FALSE) {
[13:20:27.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.721]     }
[13:20:27.721]     ...future.result <- base::tryCatch({
[13:20:27.721]         base::withCallingHandlers({
[13:20:27.721]             ...future.value <- base::withVisible(base::local({
[13:20:27.721]                 withCallingHandlers({
[13:20:27.721]                   NULL
[13:20:27.721]                 }, immediateCondition = function(cond) {
[13:20:27.721]                   save_rds <- function (object, pathname, ...) 
[13:20:27.721]                   {
[13:20:27.721]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.721]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.721]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.721]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.721]                         fi_tmp[["mtime"]])
[13:20:27.721]                     }
[13:20:27.721]                     tryCatch({
[13:20:27.721]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.721]                     }, error = function(ex) {
[13:20:27.721]                       msg <- conditionMessage(ex)
[13:20:27.721]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.721]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.721]                         fi_tmp[["mtime"]], msg)
[13:20:27.721]                       ex$message <- msg
[13:20:27.721]                       stop(ex)
[13:20:27.721]                     })
[13:20:27.721]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.721]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.721]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.721]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.721]                       fi <- file.info(pathname)
[13:20:27.721]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.721]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.721]                         fi[["size"]], fi[["mtime"]])
[13:20:27.721]                       stop(msg)
[13:20:27.721]                     }
[13:20:27.721]                     invisible(pathname)
[13:20:27.721]                   }
[13:20:27.721]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.721]                     rootPath = tempdir()) 
[13:20:27.721]                   {
[13:20:27.721]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.721]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.721]                       tmpdir = path, fileext = ".rds")
[13:20:27.721]                     save_rds(obj, file)
[13:20:27.721]                   }
[13:20:27.721]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.721]                   {
[13:20:27.721]                     inherits <- base::inherits
[13:20:27.721]                     invokeRestart <- base::invokeRestart
[13:20:27.721]                     is.null <- base::is.null
[13:20:27.721]                     muffled <- FALSE
[13:20:27.721]                     if (inherits(cond, "message")) {
[13:20:27.721]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.721]                       if (muffled) 
[13:20:27.721]                         invokeRestart("muffleMessage")
[13:20:27.721]                     }
[13:20:27.721]                     else if (inherits(cond, "warning")) {
[13:20:27.721]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.721]                       if (muffled) 
[13:20:27.721]                         invokeRestart("muffleWarning")
[13:20:27.721]                     }
[13:20:27.721]                     else if (inherits(cond, "condition")) {
[13:20:27.721]                       if (!is.null(pattern)) {
[13:20:27.721]                         computeRestarts <- base::computeRestarts
[13:20:27.721]                         grepl <- base::grepl
[13:20:27.721]                         restarts <- computeRestarts(cond)
[13:20:27.721]                         for (restart in restarts) {
[13:20:27.721]                           name <- restart$name
[13:20:27.721]                           if (is.null(name)) 
[13:20:27.721]                             next
[13:20:27.721]                           if (!grepl(pattern, name)) 
[13:20:27.721]                             next
[13:20:27.721]                           invokeRestart(restart)
[13:20:27.721]                           muffled <- TRUE
[13:20:27.721]                           break
[13:20:27.721]                         }
[13:20:27.721]                       }
[13:20:27.721]                     }
[13:20:27.721]                     invisible(muffled)
[13:20:27.721]                   }
[13:20:27.721]                   muffleCondition(cond)
[13:20:27.721]                 })
[13:20:27.721]             }))
[13:20:27.721]             future::FutureResult(value = ...future.value$value, 
[13:20:27.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.721]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.721]                     ...future.globalenv.names))
[13:20:27.721]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.721]         }, condition = base::local({
[13:20:27.721]             c <- base::c
[13:20:27.721]             inherits <- base::inherits
[13:20:27.721]             invokeRestart <- base::invokeRestart
[13:20:27.721]             length <- base::length
[13:20:27.721]             list <- base::list
[13:20:27.721]             seq.int <- base::seq.int
[13:20:27.721]             signalCondition <- base::signalCondition
[13:20:27.721]             sys.calls <- base::sys.calls
[13:20:27.721]             `[[` <- base::`[[`
[13:20:27.721]             `+` <- base::`+`
[13:20:27.721]             `<<-` <- base::`<<-`
[13:20:27.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.721]                   3L)]
[13:20:27.721]             }
[13:20:27.721]             function(cond) {
[13:20:27.721]                 is_error <- inherits(cond, "error")
[13:20:27.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.721]                   NULL)
[13:20:27.721]                 if (is_error) {
[13:20:27.721]                   sessionInformation <- function() {
[13:20:27.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.721]                       search = base::search(), system = base::Sys.info())
[13:20:27.721]                   }
[13:20:27.721]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.721]                     cond$call), session = sessionInformation(), 
[13:20:27.721]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.721]                   signalCondition(cond)
[13:20:27.721]                 }
[13:20:27.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.721]                 "immediateCondition"))) {
[13:20:27.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.721]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.721]                   if (TRUE && !signal) {
[13:20:27.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.721]                     {
[13:20:27.721]                       inherits <- base::inherits
[13:20:27.721]                       invokeRestart <- base::invokeRestart
[13:20:27.721]                       is.null <- base::is.null
[13:20:27.721]                       muffled <- FALSE
[13:20:27.721]                       if (inherits(cond, "message")) {
[13:20:27.721]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.721]                         if (muffled) 
[13:20:27.721]                           invokeRestart("muffleMessage")
[13:20:27.721]                       }
[13:20:27.721]                       else if (inherits(cond, "warning")) {
[13:20:27.721]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.721]                         if (muffled) 
[13:20:27.721]                           invokeRestart("muffleWarning")
[13:20:27.721]                       }
[13:20:27.721]                       else if (inherits(cond, "condition")) {
[13:20:27.721]                         if (!is.null(pattern)) {
[13:20:27.721]                           computeRestarts <- base::computeRestarts
[13:20:27.721]                           grepl <- base::grepl
[13:20:27.721]                           restarts <- computeRestarts(cond)
[13:20:27.721]                           for (restart in restarts) {
[13:20:27.721]                             name <- restart$name
[13:20:27.721]                             if (is.null(name)) 
[13:20:27.721]                               next
[13:20:27.721]                             if (!grepl(pattern, name)) 
[13:20:27.721]                               next
[13:20:27.721]                             invokeRestart(restart)
[13:20:27.721]                             muffled <- TRUE
[13:20:27.721]                             break
[13:20:27.721]                           }
[13:20:27.721]                         }
[13:20:27.721]                       }
[13:20:27.721]                       invisible(muffled)
[13:20:27.721]                     }
[13:20:27.721]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.721]                   }
[13:20:27.721]                 }
[13:20:27.721]                 else {
[13:20:27.721]                   if (TRUE) {
[13:20:27.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.721]                     {
[13:20:27.721]                       inherits <- base::inherits
[13:20:27.721]                       invokeRestart <- base::invokeRestart
[13:20:27.721]                       is.null <- base::is.null
[13:20:27.721]                       muffled <- FALSE
[13:20:27.721]                       if (inherits(cond, "message")) {
[13:20:27.721]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.721]                         if (muffled) 
[13:20:27.721]                           invokeRestart("muffleMessage")
[13:20:27.721]                       }
[13:20:27.721]                       else if (inherits(cond, "warning")) {
[13:20:27.721]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.721]                         if (muffled) 
[13:20:27.721]                           invokeRestart("muffleWarning")
[13:20:27.721]                       }
[13:20:27.721]                       else if (inherits(cond, "condition")) {
[13:20:27.721]                         if (!is.null(pattern)) {
[13:20:27.721]                           computeRestarts <- base::computeRestarts
[13:20:27.721]                           grepl <- base::grepl
[13:20:27.721]                           restarts <- computeRestarts(cond)
[13:20:27.721]                           for (restart in restarts) {
[13:20:27.721]                             name <- restart$name
[13:20:27.721]                             if (is.null(name)) 
[13:20:27.721]                               next
[13:20:27.721]                             if (!grepl(pattern, name)) 
[13:20:27.721]                               next
[13:20:27.721]                             invokeRestart(restart)
[13:20:27.721]                             muffled <- TRUE
[13:20:27.721]                             break
[13:20:27.721]                           }
[13:20:27.721]                         }
[13:20:27.721]                       }
[13:20:27.721]                       invisible(muffled)
[13:20:27.721]                     }
[13:20:27.721]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.721]                   }
[13:20:27.721]                 }
[13:20:27.721]             }
[13:20:27.721]         }))
[13:20:27.721]     }, error = function(ex) {
[13:20:27.721]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.721]                 ...future.rng), started = ...future.startTime, 
[13:20:27.721]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.721]             version = "1.8"), class = "FutureResult")
[13:20:27.721]     }, finally = {
[13:20:27.721]         if (!identical(...future.workdir, getwd())) 
[13:20:27.721]             setwd(...future.workdir)
[13:20:27.721]         {
[13:20:27.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.721]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.721]             }
[13:20:27.721]             base::options(...future.oldOptions)
[13:20:27.721]             if (.Platform$OS.type == "windows") {
[13:20:27.721]                 old_names <- names(...future.oldEnvVars)
[13:20:27.721]                 envs <- base::Sys.getenv()
[13:20:27.721]                 names <- names(envs)
[13:20:27.721]                 common <- intersect(names, old_names)
[13:20:27.721]                 added <- setdiff(names, old_names)
[13:20:27.721]                 removed <- setdiff(old_names, names)
[13:20:27.721]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.721]                   envs[common]]
[13:20:27.721]                 NAMES <- toupper(changed)
[13:20:27.721]                 args <- list()
[13:20:27.721]                 for (kk in seq_along(NAMES)) {
[13:20:27.721]                   name <- changed[[kk]]
[13:20:27.721]                   NAME <- NAMES[[kk]]
[13:20:27.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.721]                     next
[13:20:27.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.721]                 }
[13:20:27.721]                 NAMES <- toupper(added)
[13:20:27.721]                 for (kk in seq_along(NAMES)) {
[13:20:27.721]                   name <- added[[kk]]
[13:20:27.721]                   NAME <- NAMES[[kk]]
[13:20:27.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.721]                     next
[13:20:27.721]                   args[[name]] <- ""
[13:20:27.721]                 }
[13:20:27.721]                 NAMES <- toupper(removed)
[13:20:27.721]                 for (kk in seq_along(NAMES)) {
[13:20:27.721]                   name <- removed[[kk]]
[13:20:27.721]                   NAME <- NAMES[[kk]]
[13:20:27.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.721]                     next
[13:20:27.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.721]                 }
[13:20:27.721]                 if (length(args) > 0) 
[13:20:27.721]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.721]             }
[13:20:27.721]             else {
[13:20:27.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.721]             }
[13:20:27.721]             {
[13:20:27.721]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.721]                   0L) {
[13:20:27.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.721]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.721]                   base::options(opts)
[13:20:27.721]                 }
[13:20:27.721]                 {
[13:20:27.721]                   {
[13:20:27.721]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.721]                     NULL
[13:20:27.721]                   }
[13:20:27.721]                   options(future.plan = NULL)
[13:20:27.721]                   if (is.na(NA_character_)) 
[13:20:27.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.721]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.721]                     envir = parent.frame()) 
[13:20:27.721]                   {
[13:20:27.721]                     default_workers <- missing(workers)
[13:20:27.721]                     if (is.function(workers)) 
[13:20:27.721]                       workers <- workers()
[13:20:27.721]                     workers <- structure(as.integer(workers), 
[13:20:27.721]                       class = class(workers))
[13:20:27.721]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.721]                       1L)
[13:20:27.721]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.721]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.721]                       if (default_workers) 
[13:20:27.721]                         supportsMulticore(warn = TRUE)
[13:20:27.721]                       return(sequential(..., envir = envir))
[13:20:27.721]                     }
[13:20:27.721]                     oopts <- options(mc.cores = workers)
[13:20:27.721]                     on.exit(options(oopts))
[13:20:27.721]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.721]                       envir = envir)
[13:20:27.721]                     if (!future$lazy) 
[13:20:27.721]                       future <- run(future)
[13:20:27.721]                     invisible(future)
[13:20:27.721]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.721]                 }
[13:20:27.721]             }
[13:20:27.721]         }
[13:20:27.721]     })
[13:20:27.721]     if (TRUE) {
[13:20:27.721]         base::sink(type = "output", split = FALSE)
[13:20:27.721]         if (TRUE) {
[13:20:27.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.721]         }
[13:20:27.721]         else {
[13:20:27.721]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.721]         }
[13:20:27.721]         base::close(...future.stdout)
[13:20:27.721]         ...future.stdout <- NULL
[13:20:27.721]     }
[13:20:27.721]     ...future.result$conditions <- ...future.conditions
[13:20:27.721]     ...future.result$finished <- base::Sys.time()
[13:20:27.721]     ...future.result
[13:20:27.721] }
[13:20:27.724] requestCore(): workers = 2
[13:20:27.726] MulticoreFuture started
[13:20:27.727] - Launch lazy future ... done
[13:20:27.741] plan(): Setting new future strategy stack:
[13:20:27.741] run() for ‘MulticoreFuture’ ... done
[13:20:27.741] List of future strategies:
[13:20:27.741] 1. sequential:
[13:20:27.741]    - args: function (..., envir = parent.frame())
[13:20:27.741]    - tweaked: FALSE
[13:20:27.741]    - call: NULL
[13:20:27.742] getGlobalsAndPackages() ...
[13:20:27.742] Searching for globals...
[13:20:27.742] plan(): nbrOfWorkers() = 1
[13:20:27.743] - globals found: [1] ‘{’
[13:20:27.743] Searching for globals ... DONE
[13:20:27.744] Resolving globals: FALSE
[13:20:27.744] plan(): Setting new future strategy stack:
[13:20:27.744] List of future strategies:
[13:20:27.744] 1. multicore:
[13:20:27.744]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.744]    - tweaked: FALSE
[13:20:27.744]    - call: plan(strategy)
[13:20:27.744] 
[13:20:27.744] 
[13:20:27.744] getGlobalsAndPackages() ... DONE
[13:20:27.745] run() for ‘Future’ ...
[13:20:27.745] - state: ‘created’
[13:20:27.745] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:27.749] plan(): nbrOfWorkers() = 2
[13:20:27.750] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:27.750] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:27.750]   - Field: ‘label’
[13:20:27.751]   - Field: ‘local’
[13:20:27.751]   - Field: ‘owner’
[13:20:27.751]   - Field: ‘envir’
[13:20:27.751]   - Field: ‘workers’
[13:20:27.751]   - Field: ‘packages’
[13:20:27.751]   - Field: ‘gc’
[13:20:27.751]   - Field: ‘job’
[13:20:27.751]   - Field: ‘conditions’
[13:20:27.752]   - Field: ‘expr’
[13:20:27.752]   - Field: ‘uuid’
[13:20:27.752]   - Field: ‘seed’
[13:20:27.752]   - Field: ‘version’
[13:20:27.752]   - Field: ‘result’
[13:20:27.752]   - Field: ‘asynchronous’
[13:20:27.752]   - Field: ‘calls’
[13:20:27.752]   - Field: ‘globals’
[13:20:27.753]   - Field: ‘stdout’
[13:20:27.753]   - Field: ‘earlySignal’
[13:20:27.753]   - Field: ‘lazy’
[13:20:27.753]   - Field: ‘state’
[13:20:27.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:27.753] - Launch lazy future ...
[13:20:27.754] Packages needed by the future expression (n = 0): <none>
[13:20:27.754] Packages needed by future strategies (n = 0): <none>
[13:20:27.754] {
[13:20:27.754]     {
[13:20:27.754]         {
[13:20:27.754]             ...future.startTime <- base::Sys.time()
[13:20:27.754]             {
[13:20:27.754]                 {
[13:20:27.754]                   {
[13:20:27.754]                     {
[13:20:27.754]                       base::local({
[13:20:27.754]                         has_future <- base::requireNamespace("future", 
[13:20:27.754]                           quietly = TRUE)
[13:20:27.754]                         if (has_future) {
[13:20:27.754]                           ns <- base::getNamespace("future")
[13:20:27.754]                           version <- ns[[".package"]][["version"]]
[13:20:27.754]                           if (is.null(version)) 
[13:20:27.754]                             version <- utils::packageVersion("future")
[13:20:27.754]                         }
[13:20:27.754]                         else {
[13:20:27.754]                           version <- NULL
[13:20:27.754]                         }
[13:20:27.754]                         if (!has_future || version < "1.8.0") {
[13:20:27.754]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:27.754]                             "", base::R.version$version.string), 
[13:20:27.754]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:27.754]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:27.754]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:27.754]                               "release", "version")], collapse = " "), 
[13:20:27.754]                             hostname = base::Sys.info()[["nodename"]])
[13:20:27.754]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:27.754]                             info)
[13:20:27.754]                           info <- base::paste(info, collapse = "; ")
[13:20:27.754]                           if (!has_future) {
[13:20:27.754]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:27.754]                               info)
[13:20:27.754]                           }
[13:20:27.754]                           else {
[13:20:27.754]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:27.754]                               info, version)
[13:20:27.754]                           }
[13:20:27.754]                           base::stop(msg)
[13:20:27.754]                         }
[13:20:27.754]                       })
[13:20:27.754]                     }
[13:20:27.754]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:27.754]                     base::options(mc.cores = 1L)
[13:20:27.754]                   }
[13:20:27.754]                   options(future.plan = NULL)
[13:20:27.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:27.754]                 }
[13:20:27.754]                 ...future.workdir <- getwd()
[13:20:27.754]             }
[13:20:27.754]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:27.754]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:27.754]         }
[13:20:27.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:27.754]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:27.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:27.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:27.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:27.754]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:27.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:27.754]             base::names(...future.oldOptions))
[13:20:27.754]     }
[13:20:27.754]     if (FALSE) {
[13:20:27.754]     }
[13:20:27.754]     else {
[13:20:27.754]         if (TRUE) {
[13:20:27.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:27.754]                 open = "w")
[13:20:27.754]         }
[13:20:27.754]         else {
[13:20:27.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:27.754]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:27.754]         }
[13:20:27.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:27.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:27.754]             base::sink(type = "output", split = FALSE)
[13:20:27.754]             base::close(...future.stdout)
[13:20:27.754]         }, add = TRUE)
[13:20:27.754]     }
[13:20:27.754]     ...future.frame <- base::sys.nframe()
[13:20:27.754]     ...future.conditions <- base::list()
[13:20:27.754]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:27.754]     if (FALSE) {
[13:20:27.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:27.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:27.754]     }
[13:20:27.754]     ...future.result <- base::tryCatch({
[13:20:27.754]         base::withCallingHandlers({
[13:20:27.754]             ...future.value <- base::withVisible(base::local({
[13:20:27.754]                 withCallingHandlers({
[13:20:27.754]                   {
[13:20:27.754]                     4
[13:20:27.754]                   }
[13:20:27.754]                 }, immediateCondition = function(cond) {
[13:20:27.754]                   save_rds <- function (object, pathname, ...) 
[13:20:27.754]                   {
[13:20:27.754]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:27.754]                     if (file_test("-f", pathname_tmp)) {
[13:20:27.754]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.754]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:27.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.754]                         fi_tmp[["mtime"]])
[13:20:27.754]                     }
[13:20:27.754]                     tryCatch({
[13:20:27.754]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:27.754]                     }, error = function(ex) {
[13:20:27.754]                       msg <- conditionMessage(ex)
[13:20:27.754]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.754]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:27.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.754]                         fi_tmp[["mtime"]], msg)
[13:20:27.754]                       ex$message <- msg
[13:20:27.754]                       stop(ex)
[13:20:27.754]                     })
[13:20:27.754]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:27.754]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:27.754]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:27.754]                       fi_tmp <- file.info(pathname_tmp)
[13:20:27.754]                       fi <- file.info(pathname)
[13:20:27.754]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:27.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:27.754]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:27.754]                         fi[["size"]], fi[["mtime"]])
[13:20:27.754]                       stop(msg)
[13:20:27.754]                     }
[13:20:27.754]                     invisible(pathname)
[13:20:27.754]                   }
[13:20:27.754]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:27.754]                     rootPath = tempdir()) 
[13:20:27.754]                   {
[13:20:27.754]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:27.754]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:27.754]                       tmpdir = path, fileext = ".rds")
[13:20:27.754]                     save_rds(obj, file)
[13:20:27.754]                   }
[13:20:27.754]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:27.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.754]                   {
[13:20:27.754]                     inherits <- base::inherits
[13:20:27.754]                     invokeRestart <- base::invokeRestart
[13:20:27.754]                     is.null <- base::is.null
[13:20:27.754]                     muffled <- FALSE
[13:20:27.754]                     if (inherits(cond, "message")) {
[13:20:27.754]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:27.754]                       if (muffled) 
[13:20:27.754]                         invokeRestart("muffleMessage")
[13:20:27.754]                     }
[13:20:27.754]                     else if (inherits(cond, "warning")) {
[13:20:27.754]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:27.754]                       if (muffled) 
[13:20:27.754]                         invokeRestart("muffleWarning")
[13:20:27.754]                     }
[13:20:27.754]                     else if (inherits(cond, "condition")) {
[13:20:27.754]                       if (!is.null(pattern)) {
[13:20:27.754]                         computeRestarts <- base::computeRestarts
[13:20:27.754]                         grepl <- base::grepl
[13:20:27.754]                         restarts <- computeRestarts(cond)
[13:20:27.754]                         for (restart in restarts) {
[13:20:27.754]                           name <- restart$name
[13:20:27.754]                           if (is.null(name)) 
[13:20:27.754]                             next
[13:20:27.754]                           if (!grepl(pattern, name)) 
[13:20:27.754]                             next
[13:20:27.754]                           invokeRestart(restart)
[13:20:27.754]                           muffled <- TRUE
[13:20:27.754]                           break
[13:20:27.754]                         }
[13:20:27.754]                       }
[13:20:27.754]                     }
[13:20:27.754]                     invisible(muffled)
[13:20:27.754]                   }
[13:20:27.754]                   muffleCondition(cond)
[13:20:27.754]                 })
[13:20:27.754]             }))
[13:20:27.754]             future::FutureResult(value = ...future.value$value, 
[13:20:27.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.754]                   ...future.rng), globalenv = if (FALSE) 
[13:20:27.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:27.754]                     ...future.globalenv.names))
[13:20:27.754]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:27.754]         }, condition = base::local({
[13:20:27.754]             c <- base::c
[13:20:27.754]             inherits <- base::inherits
[13:20:27.754]             invokeRestart <- base::invokeRestart
[13:20:27.754]             length <- base::length
[13:20:27.754]             list <- base::list
[13:20:27.754]             seq.int <- base::seq.int
[13:20:27.754]             signalCondition <- base::signalCondition
[13:20:27.754]             sys.calls <- base::sys.calls
[13:20:27.754]             `[[` <- base::`[[`
[13:20:27.754]             `+` <- base::`+`
[13:20:27.754]             `<<-` <- base::`<<-`
[13:20:27.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:27.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:27.754]                   3L)]
[13:20:27.754]             }
[13:20:27.754]             function(cond) {
[13:20:27.754]                 is_error <- inherits(cond, "error")
[13:20:27.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:27.754]                   NULL)
[13:20:27.754]                 if (is_error) {
[13:20:27.754]                   sessionInformation <- function() {
[13:20:27.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:27.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:27.754]                       search = base::search(), system = base::Sys.info())
[13:20:27.754]                   }
[13:20:27.754]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:27.754]                     cond$call), session = sessionInformation(), 
[13:20:27.754]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:27.754]                   signalCondition(cond)
[13:20:27.754]                 }
[13:20:27.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:27.754]                 "immediateCondition"))) {
[13:20:27.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:27.754]                   ...future.conditions[[length(...future.conditions) + 
[13:20:27.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:27.754]                   if (TRUE && !signal) {
[13:20:27.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.754]                     {
[13:20:27.754]                       inherits <- base::inherits
[13:20:27.754]                       invokeRestart <- base::invokeRestart
[13:20:27.754]                       is.null <- base::is.null
[13:20:27.754]                       muffled <- FALSE
[13:20:27.754]                       if (inherits(cond, "message")) {
[13:20:27.754]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.754]                         if (muffled) 
[13:20:27.754]                           invokeRestart("muffleMessage")
[13:20:27.754]                       }
[13:20:27.754]                       else if (inherits(cond, "warning")) {
[13:20:27.754]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.754]                         if (muffled) 
[13:20:27.754]                           invokeRestart("muffleWarning")
[13:20:27.754]                       }
[13:20:27.754]                       else if (inherits(cond, "condition")) {
[13:20:27.754]                         if (!is.null(pattern)) {
[13:20:27.754]                           computeRestarts <- base::computeRestarts
[13:20:27.754]                           grepl <- base::grepl
[13:20:27.754]                           restarts <- computeRestarts(cond)
[13:20:27.754]                           for (restart in restarts) {
[13:20:27.754]                             name <- restart$name
[13:20:27.754]                             if (is.null(name)) 
[13:20:27.754]                               next
[13:20:27.754]                             if (!grepl(pattern, name)) 
[13:20:27.754]                               next
[13:20:27.754]                             invokeRestart(restart)
[13:20:27.754]                             muffled <- TRUE
[13:20:27.754]                             break
[13:20:27.754]                           }
[13:20:27.754]                         }
[13:20:27.754]                       }
[13:20:27.754]                       invisible(muffled)
[13:20:27.754]                     }
[13:20:27.754]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.754]                   }
[13:20:27.754]                 }
[13:20:27.754]                 else {
[13:20:27.754]                   if (TRUE) {
[13:20:27.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:27.754]                     {
[13:20:27.754]                       inherits <- base::inherits
[13:20:27.754]                       invokeRestart <- base::invokeRestart
[13:20:27.754]                       is.null <- base::is.null
[13:20:27.754]                       muffled <- FALSE
[13:20:27.754]                       if (inherits(cond, "message")) {
[13:20:27.754]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:27.754]                         if (muffled) 
[13:20:27.754]                           invokeRestart("muffleMessage")
[13:20:27.754]                       }
[13:20:27.754]                       else if (inherits(cond, "warning")) {
[13:20:27.754]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:27.754]                         if (muffled) 
[13:20:27.754]                           invokeRestart("muffleWarning")
[13:20:27.754]                       }
[13:20:27.754]                       else if (inherits(cond, "condition")) {
[13:20:27.754]                         if (!is.null(pattern)) {
[13:20:27.754]                           computeRestarts <- base::computeRestarts
[13:20:27.754]                           grepl <- base::grepl
[13:20:27.754]                           restarts <- computeRestarts(cond)
[13:20:27.754]                           for (restart in restarts) {
[13:20:27.754]                             name <- restart$name
[13:20:27.754]                             if (is.null(name)) 
[13:20:27.754]                               next
[13:20:27.754]                             if (!grepl(pattern, name)) 
[13:20:27.754]                               next
[13:20:27.754]                             invokeRestart(restart)
[13:20:27.754]                             muffled <- TRUE
[13:20:27.754]                             break
[13:20:27.754]                           }
[13:20:27.754]                         }
[13:20:27.754]                       }
[13:20:27.754]                       invisible(muffled)
[13:20:27.754]                     }
[13:20:27.754]                     muffleCondition(cond, pattern = "^muffle")
[13:20:27.754]                   }
[13:20:27.754]                 }
[13:20:27.754]             }
[13:20:27.754]         }))
[13:20:27.754]     }, error = function(ex) {
[13:20:27.754]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:27.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:27.754]                 ...future.rng), started = ...future.startTime, 
[13:20:27.754]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:27.754]             version = "1.8"), class = "FutureResult")
[13:20:27.754]     }, finally = {
[13:20:27.754]         if (!identical(...future.workdir, getwd())) 
[13:20:27.754]             setwd(...future.workdir)
[13:20:27.754]         {
[13:20:27.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:27.754]                 ...future.oldOptions$nwarnings <- NULL
[13:20:27.754]             }
[13:20:27.754]             base::options(...future.oldOptions)
[13:20:27.754]             if (.Platform$OS.type == "windows") {
[13:20:27.754]                 old_names <- names(...future.oldEnvVars)
[13:20:27.754]                 envs <- base::Sys.getenv()
[13:20:27.754]                 names <- names(envs)
[13:20:27.754]                 common <- intersect(names, old_names)
[13:20:27.754]                 added <- setdiff(names, old_names)
[13:20:27.754]                 removed <- setdiff(old_names, names)
[13:20:27.754]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:27.754]                   envs[common]]
[13:20:27.754]                 NAMES <- toupper(changed)
[13:20:27.754]                 args <- list()
[13:20:27.754]                 for (kk in seq_along(NAMES)) {
[13:20:27.754]                   name <- changed[[kk]]
[13:20:27.754]                   NAME <- NAMES[[kk]]
[13:20:27.754]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.754]                     next
[13:20:27.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.754]                 }
[13:20:27.754]                 NAMES <- toupper(added)
[13:20:27.754]                 for (kk in seq_along(NAMES)) {
[13:20:27.754]                   name <- added[[kk]]
[13:20:27.754]                   NAME <- NAMES[[kk]]
[13:20:27.754]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.754]                     next
[13:20:27.754]                   args[[name]] <- ""
[13:20:27.754]                 }
[13:20:27.754]                 NAMES <- toupper(removed)
[13:20:27.754]                 for (kk in seq_along(NAMES)) {
[13:20:27.754]                   name <- removed[[kk]]
[13:20:27.754]                   NAME <- NAMES[[kk]]
[13:20:27.754]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:27.754]                     next
[13:20:27.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:27.754]                 }
[13:20:27.754]                 if (length(args) > 0) 
[13:20:27.754]                   base::do.call(base::Sys.setenv, args = args)
[13:20:27.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:27.754]             }
[13:20:27.754]             else {
[13:20:27.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:27.754]             }
[13:20:27.754]             {
[13:20:27.754]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:27.754]                   0L) {
[13:20:27.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:27.754]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:27.754]                   base::options(opts)
[13:20:27.754]                 }
[13:20:27.754]                 {
[13:20:27.754]                   {
[13:20:27.754]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:27.754]                     NULL
[13:20:27.754]                   }
[13:20:27.754]                   options(future.plan = NULL)
[13:20:27.754]                   if (is.na(NA_character_)) 
[13:20:27.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:27.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:27.754]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:27.754]                     envir = parent.frame()) 
[13:20:27.754]                   {
[13:20:27.754]                     default_workers <- missing(workers)
[13:20:27.754]                     if (is.function(workers)) 
[13:20:27.754]                       workers <- workers()
[13:20:27.754]                     workers <- structure(as.integer(workers), 
[13:20:27.754]                       class = class(workers))
[13:20:27.754]                     stop_if_not(is.finite(workers), workers >= 
[13:20:27.754]                       1L)
[13:20:27.754]                     if ((workers == 1L && !inherits(workers, 
[13:20:27.754]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:27.754]                       if (default_workers) 
[13:20:27.754]                         supportsMulticore(warn = TRUE)
[13:20:27.754]                       return(sequential(..., envir = envir))
[13:20:27.754]                     }
[13:20:27.754]                     oopts <- options(mc.cores = workers)
[13:20:27.754]                     on.exit(options(oopts))
[13:20:27.754]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:27.754]                       envir = envir)
[13:20:27.754]                     if (!future$lazy) 
[13:20:27.754]                       future <- run(future)
[13:20:27.754]                     invisible(future)
[13:20:27.754]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:27.754]                 }
[13:20:27.754]             }
[13:20:27.754]         }
[13:20:27.754]     })
[13:20:27.754]     if (TRUE) {
[13:20:27.754]         base::sink(type = "output", split = FALSE)
[13:20:27.754]         if (TRUE) {
[13:20:27.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:27.754]         }
[13:20:27.754]         else {
[13:20:27.754]             ...future.result["stdout"] <- base::list(NULL)
[13:20:27.754]         }
[13:20:27.754]         base::close(...future.stdout)
[13:20:27.754]         ...future.stdout <- NULL
[13:20:27.754]     }
[13:20:27.754]     ...future.result$conditions <- ...future.conditions
[13:20:27.754]     ...future.result$finished <- base::Sys.time()
[13:20:27.754]     ...future.result
[13:20:27.754] }
[13:20:27.757] requestCore(): workers = 2
[13:20:27.757] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:27.772] MulticoreFuture started
[13:20:27.772] - Launch lazy future ... done
[13:20:27.773] run() for ‘MulticoreFuture’ ... done
[13:20:27.773] plan(): Setting new future strategy stack:
<environment: 0x55659d729e58> 
[13:20:27.774] List of future strategies:
[13:20:27.774] 1. sequential:
[13:20:27.774]    - args: function (..., envir = parent.frame())
[13:20:27.774]    - tweaked: FALSE
[13:20:27.774]    - call: NULL
[13:20:27.775] plan(): nbrOfWorkers() = 1
<environment: 0x55659bd6e2f0> 
[13:20:27.778] plan(): Setting new future strategy stack:
[13:20:27.778] List of future strategies:
[13:20:27.778] 1. multicore:
[13:20:27.778]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:27.778]    - tweaked: FALSE
[13:20:27.778]    - call: plan(strategy)
[13:20:27.784] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:27.786] resolve() on environment ...
[13:20:27.786]  recursive: 0
[13:20:27.787]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:27.787] signalConditionsASAP(numeric, pos=1) ...
[13:20:27.787] - nx: 4
[13:20:27.787] - relay: TRUE
[13:20:27.788] - stdout: TRUE
[13:20:27.788] - signal: TRUE
[13:20:27.788] - resignal: FALSE
[13:20:27.788] - force: TRUE
[13:20:27.788] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.788] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.788]  - until=2
[13:20:27.789]  - relaying element #2
[13:20:27.789] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:27.789] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.789] signalConditionsASAP(NULL, pos=1) ... done
[13:20:27.789]  length: 3 (resolved future 1)
[13:20:27.789] Future #2
[13:20:27.790] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:27.790] - nx: 4
[13:20:27.790] - relay: TRUE
[13:20:27.790] - stdout: TRUE
[13:20:27.790] - signal: TRUE
[13:20:27.790] - resignal: FALSE
[13:20:27.790] - force: TRUE
[13:20:27.790] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:27.791] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:27.791]  - until=2
[13:20:27.791]  - relaying element #2
[13:20:27.791] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:27.791] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:27.791] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:27.792]  length: 2 (resolved future 2)
[13:20:27.792] Future #3
[13:20:27.793] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:27.793] - nx: 4
[13:20:27.793] - relay: TRUE
[13:20:27.793] - stdout: TRUE
[13:20:27.794] - signal: TRUE
[13:20:27.794] - resignal: FALSE
[13:20:27.794] - force: TRUE
[13:20:27.794] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:27.794] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:27.794]  - until=3
[13:20:27.794]  - relaying element #3
[13:20:27.795] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:27.795] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:27.795] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:27.795]  length: 1 (resolved future 3)
[13:20:27.795] Future #4
[13:20:27.796] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:20:27.796] - nx: 4
[13:20:27.797] - relay: TRUE
[13:20:27.797] - stdout: TRUE
[13:20:27.797] - signal: TRUE
[13:20:27.797] - resignal: FALSE
[13:20:27.797] - force: TRUE
[13:20:27.798] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:27.798] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:27.798]  - until=4
[13:20:27.798]  - relaying element #4
[13:20:27.798] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.799] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:27.799] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:20:27.799]  length: 0 (resolved future 4)
[13:20:27.799] Relaying remaining futures
[13:20:27.799] signalConditionsASAP(NULL, pos=0) ...
[13:20:27.799] - nx: 4
[13:20:27.799] - relay: TRUE
[13:20:27.800] - stdout: TRUE
[13:20:27.800] - signal: TRUE
[13:20:27.800] - resignal: FALSE
[13:20:27.800] - force: TRUE
[13:20:27.800] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.800] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:27.800] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:27.800] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:27.801] signalConditionsASAP(NULL, pos=0) ... done
[13:20:27.801] resolve() on environment ... DONE
<environment: 0x55659bbdcc90> 
Type of future: multisession
[13:20:27.802] plan(): Setting new future strategy stack:
[13:20:27.802] List of future strategies:
[13:20:27.802] 1. multisession:
[13:20:27.802]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:27.802]    - tweaked: FALSE
[13:20:27.802]    - call: plan(strategy)
[13:20:27.802] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:20:27.803] multisession:
[13:20:27.803] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:27.803] - tweaked: FALSE
[13:20:27.803] - call: plan(strategy)
[13:20:27.807] getGlobalsAndPackages() ...
[13:20:27.807] Not searching for globals
[13:20:27.808] - globals: [0] <none>
[13:20:27.808] getGlobalsAndPackages() ... DONE
[13:20:27.808] [local output] makeClusterPSOCK() ...
[13:20:27.809] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:20:27.809] [local output] Base port: 11985
[13:20:27.809] [local output] Getting setup options for 2 cluster nodes ...
[13:20:27.810] [local output]  - Node 1 of 2 ...
[13:20:27.810] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:27.811] [local output] Rscript port: 11985

[13:20:27.811] [local output]  - Node 2 of 2 ...
[13:20:27.812] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:27.812] [local output] Rscript port: 11985

[13:20:27.813] [local output] Getting setup options for 2 cluster nodes ... done
[13:20:27.813] [local output]  - Parallel setup requested for some PSOCK nodes
[13:20:27.813] [local output] Setting up PSOCK nodes in parallel
[13:20:27.813] List of 36
[13:20:27.813]  $ worker          : chr "localhost"
[13:20:27.813]   ..- attr(*, "localhost")= logi TRUE
[13:20:27.813]  $ master          : chr "localhost"
[13:20:27.813]  $ port            : int 11985
[13:20:27.813]  $ connectTimeout  : num 120
[13:20:27.813]  $ timeout         : num 2592000
[13:20:27.813]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:20:27.813]  $ homogeneous     : logi TRUE
[13:20:27.813]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:20:27.813]  $ rscript_envs    : NULL
[13:20:27.813]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:27.813]  $ rscript_startup : NULL
[13:20:27.813]  $ rscript_sh      : chr "sh"
[13:20:27.813]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:27.813]  $ methods         : logi TRUE
[13:20:27.813]  $ socketOptions   : chr "no-delay"
[13:20:27.813]  $ useXDR          : logi FALSE
[13:20:27.813]  $ outfile         : chr "/dev/null"
[13:20:27.813]  $ renice          : int NA
[13:20:27.813]  $ rshcmd          : NULL
[13:20:27.813]  $ user            : chr(0) 
[13:20:27.813]  $ revtunnel       : logi FALSE
[13:20:27.813]  $ rshlogfile      : NULL
[13:20:27.813]  $ rshopts         : chr(0) 
[13:20:27.813]  $ rank            : int 1
[13:20:27.813]  $ manual          : logi FALSE
[13:20:27.813]  $ dryrun          : logi FALSE
[13:20:27.813]  $ quiet           : logi FALSE
[13:20:27.813]  $ setup_strategy  : chr "parallel"
[13:20:27.813]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:27.813]  $ pidfile         : chr "/tmp/RtmpXOy31R/worker.rank=1.parallelly.parent=84392.149a81920ca0a.pid"
[13:20:27.813]  $ rshcmd_label    : NULL
[13:20:27.813]  $ rsh_call        : NULL
[13:20:27.813]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:27.813]  $ localMachine    : logi TRUE
[13:20:27.813]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:20:27.813]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:20:27.813]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:20:27.813]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:20:27.813]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:20:27.813]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:20:27.813]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:20:27.813]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:20:27.813]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:20:27.813]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:20:27.813]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:20:27.813]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:20:27.813]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:20:27.813]  $ arguments       :List of 28
[13:20:27.813]   ..$ worker          : chr "localhost"
[13:20:27.813]   ..$ master          : NULL
[13:20:27.813]   ..$ port            : int 11985
[13:20:27.813]   ..$ connectTimeout  : num 120
[13:20:27.813]   ..$ timeout         : num 2592000
[13:20:27.813]   ..$ rscript         : NULL
[13:20:27.813]   ..$ homogeneous     : NULL
[13:20:27.813]   ..$ rscript_args    : NULL
[13:20:27.813]   ..$ rscript_envs    : NULL
[13:20:27.813]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:27.813]   ..$ rscript_startup : NULL
[13:20:27.813]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:20:27.813]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:27.813]   ..$ methods         : logi TRUE
[13:20:27.813]   ..$ socketOptions   : chr "no-delay"
[13:20:27.813]   ..$ useXDR          : logi FALSE
[13:20:27.813]   ..$ outfile         : chr "/dev/null"
[13:20:27.813]   ..$ renice          : int NA
[13:20:27.813]   ..$ rshcmd          : NULL
[13:20:27.813]   ..$ user            : NULL
[13:20:27.813]   ..$ revtunnel       : logi NA
[13:20:27.813]   ..$ rshlogfile      : NULL
[13:20:27.813]   ..$ rshopts         : NULL
[13:20:27.813]   ..$ rank            : int 1
[13:20:27.813]   ..$ manual          : logi FALSE
[13:20:27.813]   ..$ dryrun          : logi FALSE
[13:20:27.813]   ..$ quiet           : logi FALSE
[13:20:27.813]   ..$ setup_strategy  : chr "parallel"
[13:20:27.813]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:20:27.833] [local output] System call to launch all workers:
[13:20:27.833] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpXOy31R/worker.rank=1.parallelly.parent=84392.149a81920ca0a.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11985 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:20:27.833] [local output] Starting PSOCK main server
[13:20:27.835] [local output] Workers launched
[13:20:27.835] [local output] Waiting for workers to connect back
[13:20:27.835]  - [local output] 0 workers out of 2 ready
[13:20:28.089]  - [local output] 0 workers out of 2 ready
[13:20:28.089]  - [local output] 1 workers out of 2 ready
[13:20:28.096]  - [local output] 1 workers out of 2 ready
[13:20:28.097]  - [local output] 2 workers out of 2 ready
[13:20:28.097] [local output] Launching of workers completed
[13:20:28.097] [local output] Collecting session information from workers
[13:20:28.098] [local output]  - Worker #1 of 2
[13:20:28.098] [local output]  - Worker #2 of 2
[13:20:28.098] [local output] makeClusterPSOCK() ... done
[13:20:28.110] Packages needed by the future expression (n = 0): <none>
[13:20:28.110] Packages needed by future strategies (n = 0): <none>
[13:20:28.111] {
[13:20:28.111]     {
[13:20:28.111]         {
[13:20:28.111]             ...future.startTime <- base::Sys.time()
[13:20:28.111]             {
[13:20:28.111]                 {
[13:20:28.111]                   {
[13:20:28.111]                     {
[13:20:28.111]                       base::local({
[13:20:28.111]                         has_future <- base::requireNamespace("future", 
[13:20:28.111]                           quietly = TRUE)
[13:20:28.111]                         if (has_future) {
[13:20:28.111]                           ns <- base::getNamespace("future")
[13:20:28.111]                           version <- ns[[".package"]][["version"]]
[13:20:28.111]                           if (is.null(version)) 
[13:20:28.111]                             version <- utils::packageVersion("future")
[13:20:28.111]                         }
[13:20:28.111]                         else {
[13:20:28.111]                           version <- NULL
[13:20:28.111]                         }
[13:20:28.111]                         if (!has_future || version < "1.8.0") {
[13:20:28.111]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.111]                             "", base::R.version$version.string), 
[13:20:28.111]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.111]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.111]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.111]                               "release", "version")], collapse = " "), 
[13:20:28.111]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.111]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.111]                             info)
[13:20:28.111]                           info <- base::paste(info, collapse = "; ")
[13:20:28.111]                           if (!has_future) {
[13:20:28.111]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.111]                               info)
[13:20:28.111]                           }
[13:20:28.111]                           else {
[13:20:28.111]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.111]                               info, version)
[13:20:28.111]                           }
[13:20:28.111]                           base::stop(msg)
[13:20:28.111]                         }
[13:20:28.111]                       })
[13:20:28.111]                     }
[13:20:28.111]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.111]                     base::options(mc.cores = 1L)
[13:20:28.111]                   }
[13:20:28.111]                   options(future.plan = NULL)
[13:20:28.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.111]                 }
[13:20:28.111]                 ...future.workdir <- getwd()
[13:20:28.111]             }
[13:20:28.111]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.111]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.111]         }
[13:20:28.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.111]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.111]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.111]             base::names(...future.oldOptions))
[13:20:28.111]     }
[13:20:28.111]     if (FALSE) {
[13:20:28.111]     }
[13:20:28.111]     else {
[13:20:28.111]         if (TRUE) {
[13:20:28.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.111]                 open = "w")
[13:20:28.111]         }
[13:20:28.111]         else {
[13:20:28.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.111]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.111]         }
[13:20:28.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.111]             base::sink(type = "output", split = FALSE)
[13:20:28.111]             base::close(...future.stdout)
[13:20:28.111]         }, add = TRUE)
[13:20:28.111]     }
[13:20:28.111]     ...future.frame <- base::sys.nframe()
[13:20:28.111]     ...future.conditions <- base::list()
[13:20:28.111]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.111]     if (FALSE) {
[13:20:28.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.111]     }
[13:20:28.111]     ...future.result <- base::tryCatch({
[13:20:28.111]         base::withCallingHandlers({
[13:20:28.111]             ...future.value <- base::withVisible(base::local({
[13:20:28.111]                 ...future.makeSendCondition <- local({
[13:20:28.111]                   sendCondition <- NULL
[13:20:28.111]                   function(frame = 1L) {
[13:20:28.111]                     if (is.function(sendCondition)) 
[13:20:28.111]                       return(sendCondition)
[13:20:28.111]                     ns <- getNamespace("parallel")
[13:20:28.111]                     if (exists("sendData", mode = "function", 
[13:20:28.111]                       envir = ns)) {
[13:20:28.111]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.111]                         envir = ns)
[13:20:28.111]                       envir <- sys.frame(frame)
[13:20:28.111]                       master <- NULL
[13:20:28.111]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.111]                         !identical(envir, emptyenv())) {
[13:20:28.111]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.111]                           inherits = FALSE)) {
[13:20:28.111]                           master <- get("master", mode = "list", 
[13:20:28.111]                             envir = envir, inherits = FALSE)
[13:20:28.111]                           if (inherits(master, c("SOCKnode", 
[13:20:28.111]                             "SOCK0node"))) {
[13:20:28.111]                             sendCondition <<- function(cond) {
[13:20:28.111]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.111]                                 success = TRUE)
[13:20:28.111]                               parallel_sendData(master, data)
[13:20:28.111]                             }
[13:20:28.111]                             return(sendCondition)
[13:20:28.111]                           }
[13:20:28.111]                         }
[13:20:28.111]                         frame <- frame + 1L
[13:20:28.111]                         envir <- sys.frame(frame)
[13:20:28.111]                       }
[13:20:28.111]                     }
[13:20:28.111]                     sendCondition <<- function(cond) NULL
[13:20:28.111]                   }
[13:20:28.111]                 })
[13:20:28.111]                 withCallingHandlers({
[13:20:28.111]                   NA
[13:20:28.111]                 }, immediateCondition = function(cond) {
[13:20:28.111]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.111]                   sendCondition(cond)
[13:20:28.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.111]                   {
[13:20:28.111]                     inherits <- base::inherits
[13:20:28.111]                     invokeRestart <- base::invokeRestart
[13:20:28.111]                     is.null <- base::is.null
[13:20:28.111]                     muffled <- FALSE
[13:20:28.111]                     if (inherits(cond, "message")) {
[13:20:28.111]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.111]                       if (muffled) 
[13:20:28.111]                         invokeRestart("muffleMessage")
[13:20:28.111]                     }
[13:20:28.111]                     else if (inherits(cond, "warning")) {
[13:20:28.111]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.111]                       if (muffled) 
[13:20:28.111]                         invokeRestart("muffleWarning")
[13:20:28.111]                     }
[13:20:28.111]                     else if (inherits(cond, "condition")) {
[13:20:28.111]                       if (!is.null(pattern)) {
[13:20:28.111]                         computeRestarts <- base::computeRestarts
[13:20:28.111]                         grepl <- base::grepl
[13:20:28.111]                         restarts <- computeRestarts(cond)
[13:20:28.111]                         for (restart in restarts) {
[13:20:28.111]                           name <- restart$name
[13:20:28.111]                           if (is.null(name)) 
[13:20:28.111]                             next
[13:20:28.111]                           if (!grepl(pattern, name)) 
[13:20:28.111]                             next
[13:20:28.111]                           invokeRestart(restart)
[13:20:28.111]                           muffled <- TRUE
[13:20:28.111]                           break
[13:20:28.111]                         }
[13:20:28.111]                       }
[13:20:28.111]                     }
[13:20:28.111]                     invisible(muffled)
[13:20:28.111]                   }
[13:20:28.111]                   muffleCondition(cond)
[13:20:28.111]                 })
[13:20:28.111]             }))
[13:20:28.111]             future::FutureResult(value = ...future.value$value, 
[13:20:28.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.111]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.111]                     ...future.globalenv.names))
[13:20:28.111]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.111]         }, condition = base::local({
[13:20:28.111]             c <- base::c
[13:20:28.111]             inherits <- base::inherits
[13:20:28.111]             invokeRestart <- base::invokeRestart
[13:20:28.111]             length <- base::length
[13:20:28.111]             list <- base::list
[13:20:28.111]             seq.int <- base::seq.int
[13:20:28.111]             signalCondition <- base::signalCondition
[13:20:28.111]             sys.calls <- base::sys.calls
[13:20:28.111]             `[[` <- base::`[[`
[13:20:28.111]             `+` <- base::`+`
[13:20:28.111]             `<<-` <- base::`<<-`
[13:20:28.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.111]                   3L)]
[13:20:28.111]             }
[13:20:28.111]             function(cond) {
[13:20:28.111]                 is_error <- inherits(cond, "error")
[13:20:28.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.111]                   NULL)
[13:20:28.111]                 if (is_error) {
[13:20:28.111]                   sessionInformation <- function() {
[13:20:28.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.111]                       search = base::search(), system = base::Sys.info())
[13:20:28.111]                   }
[13:20:28.111]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.111]                     cond$call), session = sessionInformation(), 
[13:20:28.111]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.111]                   signalCondition(cond)
[13:20:28.111]                 }
[13:20:28.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.111]                 "immediateCondition"))) {
[13:20:28.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.111]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.111]                   if (TRUE && !signal) {
[13:20:28.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.111]                     {
[13:20:28.111]                       inherits <- base::inherits
[13:20:28.111]                       invokeRestart <- base::invokeRestart
[13:20:28.111]                       is.null <- base::is.null
[13:20:28.111]                       muffled <- FALSE
[13:20:28.111]                       if (inherits(cond, "message")) {
[13:20:28.111]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.111]                         if (muffled) 
[13:20:28.111]                           invokeRestart("muffleMessage")
[13:20:28.111]                       }
[13:20:28.111]                       else if (inherits(cond, "warning")) {
[13:20:28.111]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.111]                         if (muffled) 
[13:20:28.111]                           invokeRestart("muffleWarning")
[13:20:28.111]                       }
[13:20:28.111]                       else if (inherits(cond, "condition")) {
[13:20:28.111]                         if (!is.null(pattern)) {
[13:20:28.111]                           computeRestarts <- base::computeRestarts
[13:20:28.111]                           grepl <- base::grepl
[13:20:28.111]                           restarts <- computeRestarts(cond)
[13:20:28.111]                           for (restart in restarts) {
[13:20:28.111]                             name <- restart$name
[13:20:28.111]                             if (is.null(name)) 
[13:20:28.111]                               next
[13:20:28.111]                             if (!grepl(pattern, name)) 
[13:20:28.111]                               next
[13:20:28.111]                             invokeRestart(restart)
[13:20:28.111]                             muffled <- TRUE
[13:20:28.111]                             break
[13:20:28.111]                           }
[13:20:28.111]                         }
[13:20:28.111]                       }
[13:20:28.111]                       invisible(muffled)
[13:20:28.111]                     }
[13:20:28.111]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.111]                   }
[13:20:28.111]                 }
[13:20:28.111]                 else {
[13:20:28.111]                   if (TRUE) {
[13:20:28.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.111]                     {
[13:20:28.111]                       inherits <- base::inherits
[13:20:28.111]                       invokeRestart <- base::invokeRestart
[13:20:28.111]                       is.null <- base::is.null
[13:20:28.111]                       muffled <- FALSE
[13:20:28.111]                       if (inherits(cond, "message")) {
[13:20:28.111]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.111]                         if (muffled) 
[13:20:28.111]                           invokeRestart("muffleMessage")
[13:20:28.111]                       }
[13:20:28.111]                       else if (inherits(cond, "warning")) {
[13:20:28.111]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.111]                         if (muffled) 
[13:20:28.111]                           invokeRestart("muffleWarning")
[13:20:28.111]                       }
[13:20:28.111]                       else if (inherits(cond, "condition")) {
[13:20:28.111]                         if (!is.null(pattern)) {
[13:20:28.111]                           computeRestarts <- base::computeRestarts
[13:20:28.111]                           grepl <- base::grepl
[13:20:28.111]                           restarts <- computeRestarts(cond)
[13:20:28.111]                           for (restart in restarts) {
[13:20:28.111]                             name <- restart$name
[13:20:28.111]                             if (is.null(name)) 
[13:20:28.111]                               next
[13:20:28.111]                             if (!grepl(pattern, name)) 
[13:20:28.111]                               next
[13:20:28.111]                             invokeRestart(restart)
[13:20:28.111]                             muffled <- TRUE
[13:20:28.111]                             break
[13:20:28.111]                           }
[13:20:28.111]                         }
[13:20:28.111]                       }
[13:20:28.111]                       invisible(muffled)
[13:20:28.111]                     }
[13:20:28.111]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.111]                   }
[13:20:28.111]                 }
[13:20:28.111]             }
[13:20:28.111]         }))
[13:20:28.111]     }, error = function(ex) {
[13:20:28.111]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.111]                 ...future.rng), started = ...future.startTime, 
[13:20:28.111]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.111]             version = "1.8"), class = "FutureResult")
[13:20:28.111]     }, finally = {
[13:20:28.111]         if (!identical(...future.workdir, getwd())) 
[13:20:28.111]             setwd(...future.workdir)
[13:20:28.111]         {
[13:20:28.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.111]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.111]             }
[13:20:28.111]             base::options(...future.oldOptions)
[13:20:28.111]             if (.Platform$OS.type == "windows") {
[13:20:28.111]                 old_names <- names(...future.oldEnvVars)
[13:20:28.111]                 envs <- base::Sys.getenv()
[13:20:28.111]                 names <- names(envs)
[13:20:28.111]                 common <- intersect(names, old_names)
[13:20:28.111]                 added <- setdiff(names, old_names)
[13:20:28.111]                 removed <- setdiff(old_names, names)
[13:20:28.111]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.111]                   envs[common]]
[13:20:28.111]                 NAMES <- toupper(changed)
[13:20:28.111]                 args <- list()
[13:20:28.111]                 for (kk in seq_along(NAMES)) {
[13:20:28.111]                   name <- changed[[kk]]
[13:20:28.111]                   NAME <- NAMES[[kk]]
[13:20:28.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.111]                     next
[13:20:28.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.111]                 }
[13:20:28.111]                 NAMES <- toupper(added)
[13:20:28.111]                 for (kk in seq_along(NAMES)) {
[13:20:28.111]                   name <- added[[kk]]
[13:20:28.111]                   NAME <- NAMES[[kk]]
[13:20:28.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.111]                     next
[13:20:28.111]                   args[[name]] <- ""
[13:20:28.111]                 }
[13:20:28.111]                 NAMES <- toupper(removed)
[13:20:28.111]                 for (kk in seq_along(NAMES)) {
[13:20:28.111]                   name <- removed[[kk]]
[13:20:28.111]                   NAME <- NAMES[[kk]]
[13:20:28.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.111]                     next
[13:20:28.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.111]                 }
[13:20:28.111]                 if (length(args) > 0) 
[13:20:28.111]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.111]             }
[13:20:28.111]             else {
[13:20:28.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.111]             }
[13:20:28.111]             {
[13:20:28.111]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.111]                   0L) {
[13:20:28.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.111]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.111]                   base::options(opts)
[13:20:28.111]                 }
[13:20:28.111]                 {
[13:20:28.111]                   {
[13:20:28.111]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.111]                     NULL
[13:20:28.111]                   }
[13:20:28.111]                   options(future.plan = NULL)
[13:20:28.111]                   if (is.na(NA_character_)) 
[13:20:28.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.111]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.111]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.111]                     envir = parent.frame()) 
[13:20:28.111]                   {
[13:20:28.111]                     if (is.function(workers)) 
[13:20:28.111]                       workers <- workers()
[13:20:28.111]                     workers <- structure(as.integer(workers), 
[13:20:28.111]                       class = class(workers))
[13:20:28.111]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.111]                       workers >= 1)
[13:20:28.111]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.111]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.111]                     }
[13:20:28.111]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.111]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.111]                       envir = envir)
[13:20:28.111]                     if (!future$lazy) 
[13:20:28.111]                       future <- run(future)
[13:20:28.111]                     invisible(future)
[13:20:28.111]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.111]                 }
[13:20:28.111]             }
[13:20:28.111]         }
[13:20:28.111]     })
[13:20:28.111]     if (TRUE) {
[13:20:28.111]         base::sink(type = "output", split = FALSE)
[13:20:28.111]         if (TRUE) {
[13:20:28.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.111]         }
[13:20:28.111]         else {
[13:20:28.111]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.111]         }
[13:20:28.111]         base::close(...future.stdout)
[13:20:28.111]         ...future.stdout <- NULL
[13:20:28.111]     }
[13:20:28.111]     ...future.result$conditions <- ...future.conditions
[13:20:28.111]     ...future.result$finished <- base::Sys.time()
[13:20:28.111]     ...future.result
[13:20:28.111] }
[13:20:28.183] MultisessionFuture started
[13:20:28.183] result() for ClusterFuture ...
[13:20:28.183] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.184] - Validating connection of MultisessionFuture
[13:20:28.215] - received message: FutureResult
[13:20:28.216] - Received FutureResult
[13:20:28.216] - Erased future from FutureRegistry
[13:20:28.216] result() for ClusterFuture ...
[13:20:28.216] - result already collected: FutureResult
[13:20:28.216] result() for ClusterFuture ... done
[13:20:28.216] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:28.216] result() for ClusterFuture ... done
[13:20:28.217] result() for ClusterFuture ...
[13:20:28.217] - result already collected: FutureResult
[13:20:28.217] result() for ClusterFuture ... done
[13:20:28.217] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:20:28.220] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:20:28.221] getGlobalsAndPackages() ...
[13:20:28.221] Searching for globals...
[13:20:28.221] 
[13:20:28.221] Searching for globals ... DONE
[13:20:28.222] - globals: [0] <none>
[13:20:28.222] getGlobalsAndPackages() ... DONE
[13:20:28.222] run() for ‘Future’ ...
[13:20:28.222] - state: ‘created’
[13:20:28.222] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.237] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.237]   - Field: ‘node’
[13:20:28.237]   - Field: ‘label’
[13:20:28.237]   - Field: ‘local’
[13:20:28.237]   - Field: ‘owner’
[13:20:28.237]   - Field: ‘envir’
[13:20:28.238]   - Field: ‘workers’
[13:20:28.238]   - Field: ‘packages’
[13:20:28.238]   - Field: ‘gc’
[13:20:28.238]   - Field: ‘conditions’
[13:20:28.238]   - Field: ‘persistent’
[13:20:28.238]   - Field: ‘expr’
[13:20:28.238]   - Field: ‘uuid’
[13:20:28.238]   - Field: ‘seed’
[13:20:28.238]   - Field: ‘version’
[13:20:28.239]   - Field: ‘result’
[13:20:28.239]   - Field: ‘asynchronous’
[13:20:28.239]   - Field: ‘calls’
[13:20:28.239]   - Field: ‘globals’
[13:20:28.239]   - Field: ‘stdout’
[13:20:28.239]   - Field: ‘earlySignal’
[13:20:28.239]   - Field: ‘lazy’
[13:20:28.239]   - Field: ‘state’
[13:20:28.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.240] - Launch lazy future ...
[13:20:28.240] Packages needed by the future expression (n = 0): <none>
[13:20:28.240] Packages needed by future strategies (n = 0): <none>
[13:20:28.240] {
[13:20:28.240]     {
[13:20:28.240]         {
[13:20:28.240]             ...future.startTime <- base::Sys.time()
[13:20:28.240]             {
[13:20:28.240]                 {
[13:20:28.240]                   {
[13:20:28.240]                     {
[13:20:28.240]                       base::local({
[13:20:28.240]                         has_future <- base::requireNamespace("future", 
[13:20:28.240]                           quietly = TRUE)
[13:20:28.240]                         if (has_future) {
[13:20:28.240]                           ns <- base::getNamespace("future")
[13:20:28.240]                           version <- ns[[".package"]][["version"]]
[13:20:28.240]                           if (is.null(version)) 
[13:20:28.240]                             version <- utils::packageVersion("future")
[13:20:28.240]                         }
[13:20:28.240]                         else {
[13:20:28.240]                           version <- NULL
[13:20:28.240]                         }
[13:20:28.240]                         if (!has_future || version < "1.8.0") {
[13:20:28.240]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.240]                             "", base::R.version$version.string), 
[13:20:28.240]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.240]                               "release", "version")], collapse = " "), 
[13:20:28.240]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.240]                             info)
[13:20:28.240]                           info <- base::paste(info, collapse = "; ")
[13:20:28.240]                           if (!has_future) {
[13:20:28.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.240]                               info)
[13:20:28.240]                           }
[13:20:28.240]                           else {
[13:20:28.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.240]                               info, version)
[13:20:28.240]                           }
[13:20:28.240]                           base::stop(msg)
[13:20:28.240]                         }
[13:20:28.240]                       })
[13:20:28.240]                     }
[13:20:28.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.240]                     base::options(mc.cores = 1L)
[13:20:28.240]                   }
[13:20:28.240]                   options(future.plan = NULL)
[13:20:28.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.240]                 }
[13:20:28.240]                 ...future.workdir <- getwd()
[13:20:28.240]             }
[13:20:28.240]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.240]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.240]         }
[13:20:28.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.240]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.240]             base::names(...future.oldOptions))
[13:20:28.240]     }
[13:20:28.240]     if (FALSE) {
[13:20:28.240]     }
[13:20:28.240]     else {
[13:20:28.240]         if (TRUE) {
[13:20:28.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.240]                 open = "w")
[13:20:28.240]         }
[13:20:28.240]         else {
[13:20:28.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.240]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.240]         }
[13:20:28.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.240]             base::sink(type = "output", split = FALSE)
[13:20:28.240]             base::close(...future.stdout)
[13:20:28.240]         }, add = TRUE)
[13:20:28.240]     }
[13:20:28.240]     ...future.frame <- base::sys.nframe()
[13:20:28.240]     ...future.conditions <- base::list()
[13:20:28.240]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.240]     if (FALSE) {
[13:20:28.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.240]     }
[13:20:28.240]     ...future.result <- base::tryCatch({
[13:20:28.240]         base::withCallingHandlers({
[13:20:28.240]             ...future.value <- base::withVisible(base::local({
[13:20:28.240]                 ...future.makeSendCondition <- local({
[13:20:28.240]                   sendCondition <- NULL
[13:20:28.240]                   function(frame = 1L) {
[13:20:28.240]                     if (is.function(sendCondition)) 
[13:20:28.240]                       return(sendCondition)
[13:20:28.240]                     ns <- getNamespace("parallel")
[13:20:28.240]                     if (exists("sendData", mode = "function", 
[13:20:28.240]                       envir = ns)) {
[13:20:28.240]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.240]                         envir = ns)
[13:20:28.240]                       envir <- sys.frame(frame)
[13:20:28.240]                       master <- NULL
[13:20:28.240]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.240]                         !identical(envir, emptyenv())) {
[13:20:28.240]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.240]                           inherits = FALSE)) {
[13:20:28.240]                           master <- get("master", mode = "list", 
[13:20:28.240]                             envir = envir, inherits = FALSE)
[13:20:28.240]                           if (inherits(master, c("SOCKnode", 
[13:20:28.240]                             "SOCK0node"))) {
[13:20:28.240]                             sendCondition <<- function(cond) {
[13:20:28.240]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.240]                                 success = TRUE)
[13:20:28.240]                               parallel_sendData(master, data)
[13:20:28.240]                             }
[13:20:28.240]                             return(sendCondition)
[13:20:28.240]                           }
[13:20:28.240]                         }
[13:20:28.240]                         frame <- frame + 1L
[13:20:28.240]                         envir <- sys.frame(frame)
[13:20:28.240]                       }
[13:20:28.240]                     }
[13:20:28.240]                     sendCondition <<- function(cond) NULL
[13:20:28.240]                   }
[13:20:28.240]                 })
[13:20:28.240]                 withCallingHandlers({
[13:20:28.240]                   2
[13:20:28.240]                 }, immediateCondition = function(cond) {
[13:20:28.240]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.240]                   sendCondition(cond)
[13:20:28.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.240]                   {
[13:20:28.240]                     inherits <- base::inherits
[13:20:28.240]                     invokeRestart <- base::invokeRestart
[13:20:28.240]                     is.null <- base::is.null
[13:20:28.240]                     muffled <- FALSE
[13:20:28.240]                     if (inherits(cond, "message")) {
[13:20:28.240]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.240]                       if (muffled) 
[13:20:28.240]                         invokeRestart("muffleMessage")
[13:20:28.240]                     }
[13:20:28.240]                     else if (inherits(cond, "warning")) {
[13:20:28.240]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.240]                       if (muffled) 
[13:20:28.240]                         invokeRestart("muffleWarning")
[13:20:28.240]                     }
[13:20:28.240]                     else if (inherits(cond, "condition")) {
[13:20:28.240]                       if (!is.null(pattern)) {
[13:20:28.240]                         computeRestarts <- base::computeRestarts
[13:20:28.240]                         grepl <- base::grepl
[13:20:28.240]                         restarts <- computeRestarts(cond)
[13:20:28.240]                         for (restart in restarts) {
[13:20:28.240]                           name <- restart$name
[13:20:28.240]                           if (is.null(name)) 
[13:20:28.240]                             next
[13:20:28.240]                           if (!grepl(pattern, name)) 
[13:20:28.240]                             next
[13:20:28.240]                           invokeRestart(restart)
[13:20:28.240]                           muffled <- TRUE
[13:20:28.240]                           break
[13:20:28.240]                         }
[13:20:28.240]                       }
[13:20:28.240]                     }
[13:20:28.240]                     invisible(muffled)
[13:20:28.240]                   }
[13:20:28.240]                   muffleCondition(cond)
[13:20:28.240]                 })
[13:20:28.240]             }))
[13:20:28.240]             future::FutureResult(value = ...future.value$value, 
[13:20:28.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.240]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.240]                     ...future.globalenv.names))
[13:20:28.240]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.240]         }, condition = base::local({
[13:20:28.240]             c <- base::c
[13:20:28.240]             inherits <- base::inherits
[13:20:28.240]             invokeRestart <- base::invokeRestart
[13:20:28.240]             length <- base::length
[13:20:28.240]             list <- base::list
[13:20:28.240]             seq.int <- base::seq.int
[13:20:28.240]             signalCondition <- base::signalCondition
[13:20:28.240]             sys.calls <- base::sys.calls
[13:20:28.240]             `[[` <- base::`[[`
[13:20:28.240]             `+` <- base::`+`
[13:20:28.240]             `<<-` <- base::`<<-`
[13:20:28.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.240]                   3L)]
[13:20:28.240]             }
[13:20:28.240]             function(cond) {
[13:20:28.240]                 is_error <- inherits(cond, "error")
[13:20:28.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.240]                   NULL)
[13:20:28.240]                 if (is_error) {
[13:20:28.240]                   sessionInformation <- function() {
[13:20:28.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.240]                       search = base::search(), system = base::Sys.info())
[13:20:28.240]                   }
[13:20:28.240]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.240]                     cond$call), session = sessionInformation(), 
[13:20:28.240]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.240]                   signalCondition(cond)
[13:20:28.240]                 }
[13:20:28.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.240]                 "immediateCondition"))) {
[13:20:28.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.240]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.240]                   if (TRUE && !signal) {
[13:20:28.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.240]                     {
[13:20:28.240]                       inherits <- base::inherits
[13:20:28.240]                       invokeRestart <- base::invokeRestart
[13:20:28.240]                       is.null <- base::is.null
[13:20:28.240]                       muffled <- FALSE
[13:20:28.240]                       if (inherits(cond, "message")) {
[13:20:28.240]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.240]                         if (muffled) 
[13:20:28.240]                           invokeRestart("muffleMessage")
[13:20:28.240]                       }
[13:20:28.240]                       else if (inherits(cond, "warning")) {
[13:20:28.240]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.240]                         if (muffled) 
[13:20:28.240]                           invokeRestart("muffleWarning")
[13:20:28.240]                       }
[13:20:28.240]                       else if (inherits(cond, "condition")) {
[13:20:28.240]                         if (!is.null(pattern)) {
[13:20:28.240]                           computeRestarts <- base::computeRestarts
[13:20:28.240]                           grepl <- base::grepl
[13:20:28.240]                           restarts <- computeRestarts(cond)
[13:20:28.240]                           for (restart in restarts) {
[13:20:28.240]                             name <- restart$name
[13:20:28.240]                             if (is.null(name)) 
[13:20:28.240]                               next
[13:20:28.240]                             if (!grepl(pattern, name)) 
[13:20:28.240]                               next
[13:20:28.240]                             invokeRestart(restart)
[13:20:28.240]                             muffled <- TRUE
[13:20:28.240]                             break
[13:20:28.240]                           }
[13:20:28.240]                         }
[13:20:28.240]                       }
[13:20:28.240]                       invisible(muffled)
[13:20:28.240]                     }
[13:20:28.240]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.240]                   }
[13:20:28.240]                 }
[13:20:28.240]                 else {
[13:20:28.240]                   if (TRUE) {
[13:20:28.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.240]                     {
[13:20:28.240]                       inherits <- base::inherits
[13:20:28.240]                       invokeRestart <- base::invokeRestart
[13:20:28.240]                       is.null <- base::is.null
[13:20:28.240]                       muffled <- FALSE
[13:20:28.240]                       if (inherits(cond, "message")) {
[13:20:28.240]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.240]                         if (muffled) 
[13:20:28.240]                           invokeRestart("muffleMessage")
[13:20:28.240]                       }
[13:20:28.240]                       else if (inherits(cond, "warning")) {
[13:20:28.240]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.240]                         if (muffled) 
[13:20:28.240]                           invokeRestart("muffleWarning")
[13:20:28.240]                       }
[13:20:28.240]                       else if (inherits(cond, "condition")) {
[13:20:28.240]                         if (!is.null(pattern)) {
[13:20:28.240]                           computeRestarts <- base::computeRestarts
[13:20:28.240]                           grepl <- base::grepl
[13:20:28.240]                           restarts <- computeRestarts(cond)
[13:20:28.240]                           for (restart in restarts) {
[13:20:28.240]                             name <- restart$name
[13:20:28.240]                             if (is.null(name)) 
[13:20:28.240]                               next
[13:20:28.240]                             if (!grepl(pattern, name)) 
[13:20:28.240]                               next
[13:20:28.240]                             invokeRestart(restart)
[13:20:28.240]                             muffled <- TRUE
[13:20:28.240]                             break
[13:20:28.240]                           }
[13:20:28.240]                         }
[13:20:28.240]                       }
[13:20:28.240]                       invisible(muffled)
[13:20:28.240]                     }
[13:20:28.240]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.240]                   }
[13:20:28.240]                 }
[13:20:28.240]             }
[13:20:28.240]         }))
[13:20:28.240]     }, error = function(ex) {
[13:20:28.240]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.240]                 ...future.rng), started = ...future.startTime, 
[13:20:28.240]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.240]             version = "1.8"), class = "FutureResult")
[13:20:28.240]     }, finally = {
[13:20:28.240]         if (!identical(...future.workdir, getwd())) 
[13:20:28.240]             setwd(...future.workdir)
[13:20:28.240]         {
[13:20:28.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.240]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.240]             }
[13:20:28.240]             base::options(...future.oldOptions)
[13:20:28.240]             if (.Platform$OS.type == "windows") {
[13:20:28.240]                 old_names <- names(...future.oldEnvVars)
[13:20:28.240]                 envs <- base::Sys.getenv()
[13:20:28.240]                 names <- names(envs)
[13:20:28.240]                 common <- intersect(names, old_names)
[13:20:28.240]                 added <- setdiff(names, old_names)
[13:20:28.240]                 removed <- setdiff(old_names, names)
[13:20:28.240]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.240]                   envs[common]]
[13:20:28.240]                 NAMES <- toupper(changed)
[13:20:28.240]                 args <- list()
[13:20:28.240]                 for (kk in seq_along(NAMES)) {
[13:20:28.240]                   name <- changed[[kk]]
[13:20:28.240]                   NAME <- NAMES[[kk]]
[13:20:28.240]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.240]                     next
[13:20:28.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.240]                 }
[13:20:28.240]                 NAMES <- toupper(added)
[13:20:28.240]                 for (kk in seq_along(NAMES)) {
[13:20:28.240]                   name <- added[[kk]]
[13:20:28.240]                   NAME <- NAMES[[kk]]
[13:20:28.240]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.240]                     next
[13:20:28.240]                   args[[name]] <- ""
[13:20:28.240]                 }
[13:20:28.240]                 NAMES <- toupper(removed)
[13:20:28.240]                 for (kk in seq_along(NAMES)) {
[13:20:28.240]                   name <- removed[[kk]]
[13:20:28.240]                   NAME <- NAMES[[kk]]
[13:20:28.240]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.240]                     next
[13:20:28.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.240]                 }
[13:20:28.240]                 if (length(args) > 0) 
[13:20:28.240]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.240]             }
[13:20:28.240]             else {
[13:20:28.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.240]             }
[13:20:28.240]             {
[13:20:28.240]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.240]                   0L) {
[13:20:28.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.240]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.240]                   base::options(opts)
[13:20:28.240]                 }
[13:20:28.240]                 {
[13:20:28.240]                   {
[13:20:28.240]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.240]                     NULL
[13:20:28.240]                   }
[13:20:28.240]                   options(future.plan = NULL)
[13:20:28.240]                   if (is.na(NA_character_)) 
[13:20:28.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.240]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.240]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.240]                     envir = parent.frame()) 
[13:20:28.240]                   {
[13:20:28.240]                     if (is.function(workers)) 
[13:20:28.240]                       workers <- workers()
[13:20:28.240]                     workers <- structure(as.integer(workers), 
[13:20:28.240]                       class = class(workers))
[13:20:28.240]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.240]                       workers >= 1)
[13:20:28.240]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.240]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.240]                     }
[13:20:28.240]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.240]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.240]                       envir = envir)
[13:20:28.240]                     if (!future$lazy) 
[13:20:28.240]                       future <- run(future)
[13:20:28.240]                     invisible(future)
[13:20:28.240]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.240]                 }
[13:20:28.240]             }
[13:20:28.240]         }
[13:20:28.240]     })
[13:20:28.240]     if (TRUE) {
[13:20:28.240]         base::sink(type = "output", split = FALSE)
[13:20:28.240]         if (TRUE) {
[13:20:28.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.240]         }
[13:20:28.240]         else {
[13:20:28.240]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.240]         }
[13:20:28.240]         base::close(...future.stdout)
[13:20:28.240]         ...future.stdout <- NULL
[13:20:28.240]     }
[13:20:28.240]     ...future.result$conditions <- ...future.conditions
[13:20:28.240]     ...future.result$finished <- base::Sys.time()
[13:20:28.240]     ...future.result
[13:20:28.240] }
[13:20:28.244] MultisessionFuture started
[13:20:28.244] - Launch lazy future ... done
[13:20:28.244] run() for ‘MultisessionFuture’ ... done
[13:20:28.244] getGlobalsAndPackages() ...
[13:20:28.244] Searching for globals...
[13:20:28.245] 
[13:20:28.245] Searching for globals ... DONE
[13:20:28.245] - globals: [0] <none>
[13:20:28.245] getGlobalsAndPackages() ... DONE
[13:20:28.245] run() for ‘Future’ ...
[13:20:28.245] - state: ‘created’
[13:20:28.245] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.260] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.260] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.260]   - Field: ‘node’
[13:20:28.260]   - Field: ‘label’
[13:20:28.260]   - Field: ‘local’
[13:20:28.260]   - Field: ‘owner’
[13:20:28.261]   - Field: ‘envir’
[13:20:28.261]   - Field: ‘workers’
[13:20:28.261]   - Field: ‘packages’
[13:20:28.261]   - Field: ‘gc’
[13:20:28.261]   - Field: ‘conditions’
[13:20:28.261]   - Field: ‘persistent’
[13:20:28.261]   - Field: ‘expr’
[13:20:28.261]   - Field: ‘uuid’
[13:20:28.261]   - Field: ‘seed’
[13:20:28.262]   - Field: ‘version’
[13:20:28.262]   - Field: ‘result’
[13:20:28.262]   - Field: ‘asynchronous’
[13:20:28.262]   - Field: ‘calls’
[13:20:28.262]   - Field: ‘globals’
[13:20:28.262]   - Field: ‘stdout’
[13:20:28.262]   - Field: ‘earlySignal’
[13:20:28.262]   - Field: ‘lazy’
[13:20:28.262]   - Field: ‘state’
[13:20:28.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.263] - Launch lazy future ...
[13:20:28.263] Packages needed by the future expression (n = 0): <none>
[13:20:28.263] Packages needed by future strategies (n = 0): <none>
[13:20:28.266] {
[13:20:28.266]     {
[13:20:28.266]         {
[13:20:28.266]             ...future.startTime <- base::Sys.time()
[13:20:28.266]             {
[13:20:28.266]                 {
[13:20:28.266]                   {
[13:20:28.266]                     {
[13:20:28.266]                       base::local({
[13:20:28.266]                         has_future <- base::requireNamespace("future", 
[13:20:28.266]                           quietly = TRUE)
[13:20:28.266]                         if (has_future) {
[13:20:28.266]                           ns <- base::getNamespace("future")
[13:20:28.266]                           version <- ns[[".package"]][["version"]]
[13:20:28.266]                           if (is.null(version)) 
[13:20:28.266]                             version <- utils::packageVersion("future")
[13:20:28.266]                         }
[13:20:28.266]                         else {
[13:20:28.266]                           version <- NULL
[13:20:28.266]                         }
[13:20:28.266]                         if (!has_future || version < "1.8.0") {
[13:20:28.266]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.266]                             "", base::R.version$version.string), 
[13:20:28.266]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.266]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.266]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.266]                               "release", "version")], collapse = " "), 
[13:20:28.266]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.266]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.266]                             info)
[13:20:28.266]                           info <- base::paste(info, collapse = "; ")
[13:20:28.266]                           if (!has_future) {
[13:20:28.266]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.266]                               info)
[13:20:28.266]                           }
[13:20:28.266]                           else {
[13:20:28.266]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.266]                               info, version)
[13:20:28.266]                           }
[13:20:28.266]                           base::stop(msg)
[13:20:28.266]                         }
[13:20:28.266]                       })
[13:20:28.266]                     }
[13:20:28.266]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.266]                     base::options(mc.cores = 1L)
[13:20:28.266]                   }
[13:20:28.266]                   options(future.plan = NULL)
[13:20:28.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.266]                 }
[13:20:28.266]                 ...future.workdir <- getwd()
[13:20:28.266]             }
[13:20:28.266]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.266]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.266]         }
[13:20:28.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.266]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.266]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.266]             base::names(...future.oldOptions))
[13:20:28.266]     }
[13:20:28.266]     if (FALSE) {
[13:20:28.266]     }
[13:20:28.266]     else {
[13:20:28.266]         if (TRUE) {
[13:20:28.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.266]                 open = "w")
[13:20:28.266]         }
[13:20:28.266]         else {
[13:20:28.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.266]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.266]         }
[13:20:28.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.266]             base::sink(type = "output", split = FALSE)
[13:20:28.266]             base::close(...future.stdout)
[13:20:28.266]         }, add = TRUE)
[13:20:28.266]     }
[13:20:28.266]     ...future.frame <- base::sys.nframe()
[13:20:28.266]     ...future.conditions <- base::list()
[13:20:28.266]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.266]     if (FALSE) {
[13:20:28.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.266]     }
[13:20:28.266]     ...future.result <- base::tryCatch({
[13:20:28.266]         base::withCallingHandlers({
[13:20:28.266]             ...future.value <- base::withVisible(base::local({
[13:20:28.266]                 ...future.makeSendCondition <- local({
[13:20:28.266]                   sendCondition <- NULL
[13:20:28.266]                   function(frame = 1L) {
[13:20:28.266]                     if (is.function(sendCondition)) 
[13:20:28.266]                       return(sendCondition)
[13:20:28.266]                     ns <- getNamespace("parallel")
[13:20:28.266]                     if (exists("sendData", mode = "function", 
[13:20:28.266]                       envir = ns)) {
[13:20:28.266]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.266]                         envir = ns)
[13:20:28.266]                       envir <- sys.frame(frame)
[13:20:28.266]                       master <- NULL
[13:20:28.266]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.266]                         !identical(envir, emptyenv())) {
[13:20:28.266]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.266]                           inherits = FALSE)) {
[13:20:28.266]                           master <- get("master", mode = "list", 
[13:20:28.266]                             envir = envir, inherits = FALSE)
[13:20:28.266]                           if (inherits(master, c("SOCKnode", 
[13:20:28.266]                             "SOCK0node"))) {
[13:20:28.266]                             sendCondition <<- function(cond) {
[13:20:28.266]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.266]                                 success = TRUE)
[13:20:28.266]                               parallel_sendData(master, data)
[13:20:28.266]                             }
[13:20:28.266]                             return(sendCondition)
[13:20:28.266]                           }
[13:20:28.266]                         }
[13:20:28.266]                         frame <- frame + 1L
[13:20:28.266]                         envir <- sys.frame(frame)
[13:20:28.266]                       }
[13:20:28.266]                     }
[13:20:28.266]                     sendCondition <<- function(cond) NULL
[13:20:28.266]                   }
[13:20:28.266]                 })
[13:20:28.266]                 withCallingHandlers({
[13:20:28.266]                   NULL
[13:20:28.266]                 }, immediateCondition = function(cond) {
[13:20:28.266]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.266]                   sendCondition(cond)
[13:20:28.266]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.266]                   {
[13:20:28.266]                     inherits <- base::inherits
[13:20:28.266]                     invokeRestart <- base::invokeRestart
[13:20:28.266]                     is.null <- base::is.null
[13:20:28.266]                     muffled <- FALSE
[13:20:28.266]                     if (inherits(cond, "message")) {
[13:20:28.266]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.266]                       if (muffled) 
[13:20:28.266]                         invokeRestart("muffleMessage")
[13:20:28.266]                     }
[13:20:28.266]                     else if (inherits(cond, "warning")) {
[13:20:28.266]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.266]                       if (muffled) 
[13:20:28.266]                         invokeRestart("muffleWarning")
[13:20:28.266]                     }
[13:20:28.266]                     else if (inherits(cond, "condition")) {
[13:20:28.266]                       if (!is.null(pattern)) {
[13:20:28.266]                         computeRestarts <- base::computeRestarts
[13:20:28.266]                         grepl <- base::grepl
[13:20:28.266]                         restarts <- computeRestarts(cond)
[13:20:28.266]                         for (restart in restarts) {
[13:20:28.266]                           name <- restart$name
[13:20:28.266]                           if (is.null(name)) 
[13:20:28.266]                             next
[13:20:28.266]                           if (!grepl(pattern, name)) 
[13:20:28.266]                             next
[13:20:28.266]                           invokeRestart(restart)
[13:20:28.266]                           muffled <- TRUE
[13:20:28.266]                           break
[13:20:28.266]                         }
[13:20:28.266]                       }
[13:20:28.266]                     }
[13:20:28.266]                     invisible(muffled)
[13:20:28.266]                   }
[13:20:28.266]                   muffleCondition(cond)
[13:20:28.266]                 })
[13:20:28.266]             }))
[13:20:28.266]             future::FutureResult(value = ...future.value$value, 
[13:20:28.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.266]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.266]                     ...future.globalenv.names))
[13:20:28.266]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.266]         }, condition = base::local({
[13:20:28.266]             c <- base::c
[13:20:28.266]             inherits <- base::inherits
[13:20:28.266]             invokeRestart <- base::invokeRestart
[13:20:28.266]             length <- base::length
[13:20:28.266]             list <- base::list
[13:20:28.266]             seq.int <- base::seq.int
[13:20:28.266]             signalCondition <- base::signalCondition
[13:20:28.266]             sys.calls <- base::sys.calls
[13:20:28.266]             `[[` <- base::`[[`
[13:20:28.266]             `+` <- base::`+`
[13:20:28.266]             `<<-` <- base::`<<-`
[13:20:28.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.266]                   3L)]
[13:20:28.266]             }
[13:20:28.266]             function(cond) {
[13:20:28.266]                 is_error <- inherits(cond, "error")
[13:20:28.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.266]                   NULL)
[13:20:28.266]                 if (is_error) {
[13:20:28.266]                   sessionInformation <- function() {
[13:20:28.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.266]                       search = base::search(), system = base::Sys.info())
[13:20:28.266]                   }
[13:20:28.266]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.266]                     cond$call), session = sessionInformation(), 
[13:20:28.266]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.266]                   signalCondition(cond)
[13:20:28.266]                 }
[13:20:28.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.266]                 "immediateCondition"))) {
[13:20:28.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.266]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.266]                   if (TRUE && !signal) {
[13:20:28.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.266]                     {
[13:20:28.266]                       inherits <- base::inherits
[13:20:28.266]                       invokeRestart <- base::invokeRestart
[13:20:28.266]                       is.null <- base::is.null
[13:20:28.266]                       muffled <- FALSE
[13:20:28.266]                       if (inherits(cond, "message")) {
[13:20:28.266]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.266]                         if (muffled) 
[13:20:28.266]                           invokeRestart("muffleMessage")
[13:20:28.266]                       }
[13:20:28.266]                       else if (inherits(cond, "warning")) {
[13:20:28.266]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.266]                         if (muffled) 
[13:20:28.266]                           invokeRestart("muffleWarning")
[13:20:28.266]                       }
[13:20:28.266]                       else if (inherits(cond, "condition")) {
[13:20:28.266]                         if (!is.null(pattern)) {
[13:20:28.266]                           computeRestarts <- base::computeRestarts
[13:20:28.266]                           grepl <- base::grepl
[13:20:28.266]                           restarts <- computeRestarts(cond)
[13:20:28.266]                           for (restart in restarts) {
[13:20:28.266]                             name <- restart$name
[13:20:28.266]                             if (is.null(name)) 
[13:20:28.266]                               next
[13:20:28.266]                             if (!grepl(pattern, name)) 
[13:20:28.266]                               next
[13:20:28.266]                             invokeRestart(restart)
[13:20:28.266]                             muffled <- TRUE
[13:20:28.266]                             break
[13:20:28.266]                           }
[13:20:28.266]                         }
[13:20:28.266]                       }
[13:20:28.266]                       invisible(muffled)
[13:20:28.266]                     }
[13:20:28.266]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.266]                   }
[13:20:28.266]                 }
[13:20:28.266]                 else {
[13:20:28.266]                   if (TRUE) {
[13:20:28.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.266]                     {
[13:20:28.266]                       inherits <- base::inherits
[13:20:28.266]                       invokeRestart <- base::invokeRestart
[13:20:28.266]                       is.null <- base::is.null
[13:20:28.266]                       muffled <- FALSE
[13:20:28.266]                       if (inherits(cond, "message")) {
[13:20:28.266]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.266]                         if (muffled) 
[13:20:28.266]                           invokeRestart("muffleMessage")
[13:20:28.266]                       }
[13:20:28.266]                       else if (inherits(cond, "warning")) {
[13:20:28.266]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.266]                         if (muffled) 
[13:20:28.266]                           invokeRestart("muffleWarning")
[13:20:28.266]                       }
[13:20:28.266]                       else if (inherits(cond, "condition")) {
[13:20:28.266]                         if (!is.null(pattern)) {
[13:20:28.266]                           computeRestarts <- base::computeRestarts
[13:20:28.266]                           grepl <- base::grepl
[13:20:28.266]                           restarts <- computeRestarts(cond)
[13:20:28.266]                           for (restart in restarts) {
[13:20:28.266]                             name <- restart$name
[13:20:28.266]                             if (is.null(name)) 
[13:20:28.266]                               next
[13:20:28.266]                             if (!grepl(pattern, name)) 
[13:20:28.266]                               next
[13:20:28.266]                             invokeRestart(restart)
[13:20:28.266]                             muffled <- TRUE
[13:20:28.266]                             break
[13:20:28.266]                           }
[13:20:28.266]                         }
[13:20:28.266]                       }
[13:20:28.266]                       invisible(muffled)
[13:20:28.266]                     }
[13:20:28.266]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.266]                   }
[13:20:28.266]                 }
[13:20:28.266]             }
[13:20:28.266]         }))
[13:20:28.266]     }, error = function(ex) {
[13:20:28.266]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.266]                 ...future.rng), started = ...future.startTime, 
[13:20:28.266]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.266]             version = "1.8"), class = "FutureResult")
[13:20:28.266]     }, finally = {
[13:20:28.266]         if (!identical(...future.workdir, getwd())) 
[13:20:28.266]             setwd(...future.workdir)
[13:20:28.266]         {
[13:20:28.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.266]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.266]             }
[13:20:28.266]             base::options(...future.oldOptions)
[13:20:28.266]             if (.Platform$OS.type == "windows") {
[13:20:28.266]                 old_names <- names(...future.oldEnvVars)
[13:20:28.266]                 envs <- base::Sys.getenv()
[13:20:28.266]                 names <- names(envs)
[13:20:28.266]                 common <- intersect(names, old_names)
[13:20:28.266]                 added <- setdiff(names, old_names)
[13:20:28.266]                 removed <- setdiff(old_names, names)
[13:20:28.266]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.266]                   envs[common]]
[13:20:28.266]                 NAMES <- toupper(changed)
[13:20:28.266]                 args <- list()
[13:20:28.266]                 for (kk in seq_along(NAMES)) {
[13:20:28.266]                   name <- changed[[kk]]
[13:20:28.266]                   NAME <- NAMES[[kk]]
[13:20:28.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.266]                     next
[13:20:28.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.266]                 }
[13:20:28.266]                 NAMES <- toupper(added)
[13:20:28.266]                 for (kk in seq_along(NAMES)) {
[13:20:28.266]                   name <- added[[kk]]
[13:20:28.266]                   NAME <- NAMES[[kk]]
[13:20:28.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.266]                     next
[13:20:28.266]                   args[[name]] <- ""
[13:20:28.266]                 }
[13:20:28.266]                 NAMES <- toupper(removed)
[13:20:28.266]                 for (kk in seq_along(NAMES)) {
[13:20:28.266]                   name <- removed[[kk]]
[13:20:28.266]                   NAME <- NAMES[[kk]]
[13:20:28.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.266]                     next
[13:20:28.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.266]                 }
[13:20:28.266]                 if (length(args) > 0) 
[13:20:28.266]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.266]             }
[13:20:28.266]             else {
[13:20:28.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.266]             }
[13:20:28.266]             {
[13:20:28.266]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.266]                   0L) {
[13:20:28.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.266]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.266]                   base::options(opts)
[13:20:28.266]                 }
[13:20:28.266]                 {
[13:20:28.266]                   {
[13:20:28.266]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.266]                     NULL
[13:20:28.266]                   }
[13:20:28.266]                   options(future.plan = NULL)
[13:20:28.266]                   if (is.na(NA_character_)) 
[13:20:28.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.266]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.266]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.266]                     envir = parent.frame()) 
[13:20:28.266]                   {
[13:20:28.266]                     if (is.function(workers)) 
[13:20:28.266]                       workers <- workers()
[13:20:28.266]                     workers <- structure(as.integer(workers), 
[13:20:28.266]                       class = class(workers))
[13:20:28.266]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.266]                       workers >= 1)
[13:20:28.266]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.266]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.266]                     }
[13:20:28.266]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.266]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.266]                       envir = envir)
[13:20:28.266]                     if (!future$lazy) 
[13:20:28.266]                       future <- run(future)
[13:20:28.266]                     invisible(future)
[13:20:28.266]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.266]                 }
[13:20:28.266]             }
[13:20:28.266]         }
[13:20:28.266]     })
[13:20:28.266]     if (TRUE) {
[13:20:28.266]         base::sink(type = "output", split = FALSE)
[13:20:28.266]         if (TRUE) {
[13:20:28.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.266]         }
[13:20:28.266]         else {
[13:20:28.266]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.266]         }
[13:20:28.266]         base::close(...future.stdout)
[13:20:28.266]         ...future.stdout <- NULL
[13:20:28.266]     }
[13:20:28.266]     ...future.result$conditions <- ...future.conditions
[13:20:28.266]     ...future.result$finished <- base::Sys.time()
[13:20:28.266]     ...future.result
[13:20:28.266] }
[13:20:28.341] MultisessionFuture started
[13:20:28.341] - Launch lazy future ... done
[13:20:28.341] run() for ‘MultisessionFuture’ ... done
[13:20:28.342] getGlobalsAndPackages() ...
[13:20:28.342] Searching for globals...
[13:20:28.343] - globals found: [1] ‘{’
[13:20:28.344] Searching for globals ... DONE
[13:20:28.344] Resolving globals: FALSE
[13:20:28.344] 
[13:20:28.344] 
[13:20:28.345] getGlobalsAndPackages() ... DONE
[13:20:28.345] run() for ‘Future’ ...
[13:20:28.345] - state: ‘created’
[13:20:28.346] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.362] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.362]   - Field: ‘node’
[13:20:28.362]   - Field: ‘label’
[13:20:28.362]   - Field: ‘local’
[13:20:28.362]   - Field: ‘owner’
[13:20:28.363]   - Field: ‘envir’
[13:20:28.363]   - Field: ‘workers’
[13:20:28.363]   - Field: ‘packages’
[13:20:28.363]   - Field: ‘gc’
[13:20:28.363]   - Field: ‘conditions’
[13:20:28.363]   - Field: ‘persistent’
[13:20:28.363]   - Field: ‘expr’
[13:20:28.363]   - Field: ‘uuid’
[13:20:28.363]   - Field: ‘seed’
[13:20:28.364]   - Field: ‘version’
[13:20:28.364]   - Field: ‘result’
[13:20:28.364]   - Field: ‘asynchronous’
[13:20:28.364]   - Field: ‘calls’
[13:20:28.364]   - Field: ‘globals’
[13:20:28.364]   - Field: ‘stdout’
[13:20:28.364]   - Field: ‘earlySignal’
[13:20:28.364]   - Field: ‘lazy’
[13:20:28.364]   - Field: ‘state’
[13:20:28.364] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.364] - Launch lazy future ...
[13:20:28.365] Packages needed by the future expression (n = 0): <none>
[13:20:28.365] Packages needed by future strategies (n = 0): <none>
[13:20:28.365] {
[13:20:28.365]     {
[13:20:28.365]         {
[13:20:28.365]             ...future.startTime <- base::Sys.time()
[13:20:28.365]             {
[13:20:28.365]                 {
[13:20:28.365]                   {
[13:20:28.365]                     {
[13:20:28.365]                       base::local({
[13:20:28.365]                         has_future <- base::requireNamespace("future", 
[13:20:28.365]                           quietly = TRUE)
[13:20:28.365]                         if (has_future) {
[13:20:28.365]                           ns <- base::getNamespace("future")
[13:20:28.365]                           version <- ns[[".package"]][["version"]]
[13:20:28.365]                           if (is.null(version)) 
[13:20:28.365]                             version <- utils::packageVersion("future")
[13:20:28.365]                         }
[13:20:28.365]                         else {
[13:20:28.365]                           version <- NULL
[13:20:28.365]                         }
[13:20:28.365]                         if (!has_future || version < "1.8.0") {
[13:20:28.365]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.365]                             "", base::R.version$version.string), 
[13:20:28.365]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.365]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.365]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.365]                               "release", "version")], collapse = " "), 
[13:20:28.365]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.365]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.365]                             info)
[13:20:28.365]                           info <- base::paste(info, collapse = "; ")
[13:20:28.365]                           if (!has_future) {
[13:20:28.365]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.365]                               info)
[13:20:28.365]                           }
[13:20:28.365]                           else {
[13:20:28.365]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.365]                               info, version)
[13:20:28.365]                           }
[13:20:28.365]                           base::stop(msg)
[13:20:28.365]                         }
[13:20:28.365]                       })
[13:20:28.365]                     }
[13:20:28.365]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.365]                     base::options(mc.cores = 1L)
[13:20:28.365]                   }
[13:20:28.365]                   options(future.plan = NULL)
[13:20:28.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.365]                 }
[13:20:28.365]                 ...future.workdir <- getwd()
[13:20:28.365]             }
[13:20:28.365]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.365]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.365]         }
[13:20:28.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.365]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.365]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.365]             base::names(...future.oldOptions))
[13:20:28.365]     }
[13:20:28.365]     if (FALSE) {
[13:20:28.365]     }
[13:20:28.365]     else {
[13:20:28.365]         if (TRUE) {
[13:20:28.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.365]                 open = "w")
[13:20:28.365]         }
[13:20:28.365]         else {
[13:20:28.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.365]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.365]         }
[13:20:28.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.365]             base::sink(type = "output", split = FALSE)
[13:20:28.365]             base::close(...future.stdout)
[13:20:28.365]         }, add = TRUE)
[13:20:28.365]     }
[13:20:28.365]     ...future.frame <- base::sys.nframe()
[13:20:28.365]     ...future.conditions <- base::list()
[13:20:28.365]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.365]     if (FALSE) {
[13:20:28.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.365]     }
[13:20:28.365]     ...future.result <- base::tryCatch({
[13:20:28.365]         base::withCallingHandlers({
[13:20:28.365]             ...future.value <- base::withVisible(base::local({
[13:20:28.365]                 ...future.makeSendCondition <- local({
[13:20:28.365]                   sendCondition <- NULL
[13:20:28.365]                   function(frame = 1L) {
[13:20:28.365]                     if (is.function(sendCondition)) 
[13:20:28.365]                       return(sendCondition)
[13:20:28.365]                     ns <- getNamespace("parallel")
[13:20:28.365]                     if (exists("sendData", mode = "function", 
[13:20:28.365]                       envir = ns)) {
[13:20:28.365]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.365]                         envir = ns)
[13:20:28.365]                       envir <- sys.frame(frame)
[13:20:28.365]                       master <- NULL
[13:20:28.365]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.365]                         !identical(envir, emptyenv())) {
[13:20:28.365]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.365]                           inherits = FALSE)) {
[13:20:28.365]                           master <- get("master", mode = "list", 
[13:20:28.365]                             envir = envir, inherits = FALSE)
[13:20:28.365]                           if (inherits(master, c("SOCKnode", 
[13:20:28.365]                             "SOCK0node"))) {
[13:20:28.365]                             sendCondition <<- function(cond) {
[13:20:28.365]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.365]                                 success = TRUE)
[13:20:28.365]                               parallel_sendData(master, data)
[13:20:28.365]                             }
[13:20:28.365]                             return(sendCondition)
[13:20:28.365]                           }
[13:20:28.365]                         }
[13:20:28.365]                         frame <- frame + 1L
[13:20:28.365]                         envir <- sys.frame(frame)
[13:20:28.365]                       }
[13:20:28.365]                     }
[13:20:28.365]                     sendCondition <<- function(cond) NULL
[13:20:28.365]                   }
[13:20:28.365]                 })
[13:20:28.365]                 withCallingHandlers({
[13:20:28.365]                   {
[13:20:28.365]                     4
[13:20:28.365]                   }
[13:20:28.365]                 }, immediateCondition = function(cond) {
[13:20:28.365]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.365]                   sendCondition(cond)
[13:20:28.365]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.365]                   {
[13:20:28.365]                     inherits <- base::inherits
[13:20:28.365]                     invokeRestart <- base::invokeRestart
[13:20:28.365]                     is.null <- base::is.null
[13:20:28.365]                     muffled <- FALSE
[13:20:28.365]                     if (inherits(cond, "message")) {
[13:20:28.365]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.365]                       if (muffled) 
[13:20:28.365]                         invokeRestart("muffleMessage")
[13:20:28.365]                     }
[13:20:28.365]                     else if (inherits(cond, "warning")) {
[13:20:28.365]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.365]                       if (muffled) 
[13:20:28.365]                         invokeRestart("muffleWarning")
[13:20:28.365]                     }
[13:20:28.365]                     else if (inherits(cond, "condition")) {
[13:20:28.365]                       if (!is.null(pattern)) {
[13:20:28.365]                         computeRestarts <- base::computeRestarts
[13:20:28.365]                         grepl <- base::grepl
[13:20:28.365]                         restarts <- computeRestarts(cond)
[13:20:28.365]                         for (restart in restarts) {
[13:20:28.365]                           name <- restart$name
[13:20:28.365]                           if (is.null(name)) 
[13:20:28.365]                             next
[13:20:28.365]                           if (!grepl(pattern, name)) 
[13:20:28.365]                             next
[13:20:28.365]                           invokeRestart(restart)
[13:20:28.365]                           muffled <- TRUE
[13:20:28.365]                           break
[13:20:28.365]                         }
[13:20:28.365]                       }
[13:20:28.365]                     }
[13:20:28.365]                     invisible(muffled)
[13:20:28.365]                   }
[13:20:28.365]                   muffleCondition(cond)
[13:20:28.365]                 })
[13:20:28.365]             }))
[13:20:28.365]             future::FutureResult(value = ...future.value$value, 
[13:20:28.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.365]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.365]                     ...future.globalenv.names))
[13:20:28.365]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.365]         }, condition = base::local({
[13:20:28.365]             c <- base::c
[13:20:28.365]             inherits <- base::inherits
[13:20:28.365]             invokeRestart <- base::invokeRestart
[13:20:28.365]             length <- base::length
[13:20:28.365]             list <- base::list
[13:20:28.365]             seq.int <- base::seq.int
[13:20:28.365]             signalCondition <- base::signalCondition
[13:20:28.365]             sys.calls <- base::sys.calls
[13:20:28.365]             `[[` <- base::`[[`
[13:20:28.365]             `+` <- base::`+`
[13:20:28.365]             `<<-` <- base::`<<-`
[13:20:28.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.365]                   3L)]
[13:20:28.365]             }
[13:20:28.365]             function(cond) {
[13:20:28.365]                 is_error <- inherits(cond, "error")
[13:20:28.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.365]                   NULL)
[13:20:28.365]                 if (is_error) {
[13:20:28.365]                   sessionInformation <- function() {
[13:20:28.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.365]                       search = base::search(), system = base::Sys.info())
[13:20:28.365]                   }
[13:20:28.365]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.365]                     cond$call), session = sessionInformation(), 
[13:20:28.365]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.365]                   signalCondition(cond)
[13:20:28.365]                 }
[13:20:28.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.365]                 "immediateCondition"))) {
[13:20:28.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.365]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.365]                   if (TRUE && !signal) {
[13:20:28.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.365]                     {
[13:20:28.365]                       inherits <- base::inherits
[13:20:28.365]                       invokeRestart <- base::invokeRestart
[13:20:28.365]                       is.null <- base::is.null
[13:20:28.365]                       muffled <- FALSE
[13:20:28.365]                       if (inherits(cond, "message")) {
[13:20:28.365]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.365]                         if (muffled) 
[13:20:28.365]                           invokeRestart("muffleMessage")
[13:20:28.365]                       }
[13:20:28.365]                       else if (inherits(cond, "warning")) {
[13:20:28.365]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.365]                         if (muffled) 
[13:20:28.365]                           invokeRestart("muffleWarning")
[13:20:28.365]                       }
[13:20:28.365]                       else if (inherits(cond, "condition")) {
[13:20:28.365]                         if (!is.null(pattern)) {
[13:20:28.365]                           computeRestarts <- base::computeRestarts
[13:20:28.365]                           grepl <- base::grepl
[13:20:28.365]                           restarts <- computeRestarts(cond)
[13:20:28.365]                           for (restart in restarts) {
[13:20:28.365]                             name <- restart$name
[13:20:28.365]                             if (is.null(name)) 
[13:20:28.365]                               next
[13:20:28.365]                             if (!grepl(pattern, name)) 
[13:20:28.365]                               next
[13:20:28.365]                             invokeRestart(restart)
[13:20:28.365]                             muffled <- TRUE
[13:20:28.365]                             break
[13:20:28.365]                           }
[13:20:28.365]                         }
[13:20:28.365]                       }
[13:20:28.365]                       invisible(muffled)
[13:20:28.365]                     }
[13:20:28.365]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.365]                   }
[13:20:28.365]                 }
[13:20:28.365]                 else {
[13:20:28.365]                   if (TRUE) {
[13:20:28.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.365]                     {
[13:20:28.365]                       inherits <- base::inherits
[13:20:28.365]                       invokeRestart <- base::invokeRestart
[13:20:28.365]                       is.null <- base::is.null
[13:20:28.365]                       muffled <- FALSE
[13:20:28.365]                       if (inherits(cond, "message")) {
[13:20:28.365]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.365]                         if (muffled) 
[13:20:28.365]                           invokeRestart("muffleMessage")
[13:20:28.365]                       }
[13:20:28.365]                       else if (inherits(cond, "warning")) {
[13:20:28.365]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.365]                         if (muffled) 
[13:20:28.365]                           invokeRestart("muffleWarning")
[13:20:28.365]                       }
[13:20:28.365]                       else if (inherits(cond, "condition")) {
[13:20:28.365]                         if (!is.null(pattern)) {
[13:20:28.365]                           computeRestarts <- base::computeRestarts
[13:20:28.365]                           grepl <- base::grepl
[13:20:28.365]                           restarts <- computeRestarts(cond)
[13:20:28.365]                           for (restart in restarts) {
[13:20:28.365]                             name <- restart$name
[13:20:28.365]                             if (is.null(name)) 
[13:20:28.365]                               next
[13:20:28.365]                             if (!grepl(pattern, name)) 
[13:20:28.365]                               next
[13:20:28.365]                             invokeRestart(restart)
[13:20:28.365]                             muffled <- TRUE
[13:20:28.365]                             break
[13:20:28.365]                           }
[13:20:28.365]                         }
[13:20:28.365]                       }
[13:20:28.365]                       invisible(muffled)
[13:20:28.365]                     }
[13:20:28.365]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.365]                   }
[13:20:28.365]                 }
[13:20:28.365]             }
[13:20:28.365]         }))
[13:20:28.365]     }, error = function(ex) {
[13:20:28.365]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.365]                 ...future.rng), started = ...future.startTime, 
[13:20:28.365]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.365]             version = "1.8"), class = "FutureResult")
[13:20:28.365]     }, finally = {
[13:20:28.365]         if (!identical(...future.workdir, getwd())) 
[13:20:28.365]             setwd(...future.workdir)
[13:20:28.365]         {
[13:20:28.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.365]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.365]             }
[13:20:28.365]             base::options(...future.oldOptions)
[13:20:28.365]             if (.Platform$OS.type == "windows") {
[13:20:28.365]                 old_names <- names(...future.oldEnvVars)
[13:20:28.365]                 envs <- base::Sys.getenv()
[13:20:28.365]                 names <- names(envs)
[13:20:28.365]                 common <- intersect(names, old_names)
[13:20:28.365]                 added <- setdiff(names, old_names)
[13:20:28.365]                 removed <- setdiff(old_names, names)
[13:20:28.365]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.365]                   envs[common]]
[13:20:28.365]                 NAMES <- toupper(changed)
[13:20:28.365]                 args <- list()
[13:20:28.365]                 for (kk in seq_along(NAMES)) {
[13:20:28.365]                   name <- changed[[kk]]
[13:20:28.365]                   NAME <- NAMES[[kk]]
[13:20:28.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.365]                     next
[13:20:28.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.365]                 }
[13:20:28.365]                 NAMES <- toupper(added)
[13:20:28.365]                 for (kk in seq_along(NAMES)) {
[13:20:28.365]                   name <- added[[kk]]
[13:20:28.365]                   NAME <- NAMES[[kk]]
[13:20:28.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.365]                     next
[13:20:28.365]                   args[[name]] <- ""
[13:20:28.365]                 }
[13:20:28.365]                 NAMES <- toupper(removed)
[13:20:28.365]                 for (kk in seq_along(NAMES)) {
[13:20:28.365]                   name <- removed[[kk]]
[13:20:28.365]                   NAME <- NAMES[[kk]]
[13:20:28.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.365]                     next
[13:20:28.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.365]                 }
[13:20:28.365]                 if (length(args) > 0) 
[13:20:28.365]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.365]             }
[13:20:28.365]             else {
[13:20:28.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.365]             }
[13:20:28.365]             {
[13:20:28.365]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.365]                   0L) {
[13:20:28.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.365]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.365]                   base::options(opts)
[13:20:28.365]                 }
[13:20:28.365]                 {
[13:20:28.365]                   {
[13:20:28.365]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.365]                     NULL
[13:20:28.365]                   }
[13:20:28.365]                   options(future.plan = NULL)
[13:20:28.365]                   if (is.na(NA_character_)) 
[13:20:28.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.365]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.365]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.365]                     envir = parent.frame()) 
[13:20:28.365]                   {
[13:20:28.365]                     if (is.function(workers)) 
[13:20:28.365]                       workers <- workers()
[13:20:28.365]                     workers <- structure(as.integer(workers), 
[13:20:28.365]                       class = class(workers))
[13:20:28.365]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.365]                       workers >= 1)
[13:20:28.365]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.365]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.365]                     }
[13:20:28.365]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.365]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.365]                       envir = envir)
[13:20:28.365]                     if (!future$lazy) 
[13:20:28.365]                       future <- run(future)
[13:20:28.365]                     invisible(future)
[13:20:28.365]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.365]                 }
[13:20:28.365]             }
[13:20:28.365]         }
[13:20:28.365]     })
[13:20:28.365]     if (TRUE) {
[13:20:28.365]         base::sink(type = "output", split = FALSE)
[13:20:28.365]         if (TRUE) {
[13:20:28.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.365]         }
[13:20:28.365]         else {
[13:20:28.365]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.365]         }
[13:20:28.365]         base::close(...future.stdout)
[13:20:28.365]         ...future.stdout <- NULL
[13:20:28.365]     }
[13:20:28.365]     ...future.result$conditions <- ...future.conditions
[13:20:28.365]     ...future.result$finished <- base::Sys.time()
[13:20:28.365]     ...future.result
[13:20:28.365] }
[13:20:28.368] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:28.379] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.379] - Validating connection of MultisessionFuture
[13:20:28.379] - received message: FutureResult
[13:20:28.379] - Received FutureResult
[13:20:28.379] - Erased future from FutureRegistry
[13:20:28.379] result() for ClusterFuture ...
[13:20:28.379] - result already collected: FutureResult
[13:20:28.380] result() for ClusterFuture ... done
[13:20:28.380] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:28.380] result() for ClusterFuture ...
[13:20:28.380] - result already collected: FutureResult
[13:20:28.380] result() for ClusterFuture ... done
[13:20:28.380] result() for ClusterFuture ...
[13:20:28.380] - result already collected: FutureResult
[13:20:28.380] result() for ClusterFuture ... done
[13:20:28.381] MultisessionFuture started
[13:20:28.382] - Launch lazy future ... done
[13:20:28.382] run() for ‘MultisessionFuture’ ... done
<environment: 0x55659d6a5ed0> 
<environment: 0x55659ba47118> 
[13:20:28.384] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.384] - Validating connection of MultisessionFuture
[13:20:28.384] - received message: FutureResult
[13:20:28.384] - Received FutureResult
[13:20:28.384] - Erased future from FutureRegistry
[13:20:28.384] result() for ClusterFuture ...
[13:20:28.384] - result already collected: FutureResult
[13:20:28.384] result() for ClusterFuture ... done
[13:20:28.384] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:28.396] resolve() on environment ...
[13:20:28.396]  recursive: 0
[13:20:28.397]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:28.397] signalConditionsASAP(numeric, pos=1) ...
[13:20:28.397] - nx: 4
[13:20:28.397] - relay: TRUE
[13:20:28.397] - stdout: TRUE
[13:20:28.397] - signal: TRUE
[13:20:28.397] - resignal: FALSE
[13:20:28.398] - force: TRUE
[13:20:28.398] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.398] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.398]  - until=2
[13:20:28.398]  - relaying element #2
[13:20:28.398] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:28.398] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.398] signalConditionsASAP(NULL, pos=1) ... done
[13:20:28.398]  length: 3 (resolved future 1)
[13:20:28.398] Future #2
[13:20:28.398] result() for ClusterFuture ...
[13:20:28.399] - result already collected: FutureResult
[13:20:28.399] result() for ClusterFuture ... done
[13:20:28.399] result() for ClusterFuture ...
[13:20:28.399] - result already collected: FutureResult
[13:20:28.399] result() for ClusterFuture ... done
[13:20:28.399] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:28.399] - nx: 4
[13:20:28.399] - relay: TRUE
[13:20:28.399] - stdout: TRUE
[13:20:28.399] - signal: TRUE
[13:20:28.399] - resignal: FALSE
[13:20:28.400] - force: TRUE
[13:20:28.400] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:28.400] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.400]  - until=2
[13:20:28.400]  - relaying element #2
[13:20:28.400] result() for ClusterFuture ...
[13:20:28.400] - result already collected: FutureResult
[13:20:28.400] result() for ClusterFuture ... done
[13:20:28.400] result() for ClusterFuture ...
[13:20:28.400] - result already collected: FutureResult
[13:20:28.400] result() for ClusterFuture ... done
[13:20:28.401] result() for ClusterFuture ...
[13:20:28.401] - result already collected: FutureResult
[13:20:28.401] result() for ClusterFuture ... done
[13:20:28.401] result() for ClusterFuture ...
[13:20:28.401] - result already collected: FutureResult
[13:20:28.401] result() for ClusterFuture ... done
[13:20:28.401] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:28.401] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:28.401] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:28.401]  length: 2 (resolved future 2)
[13:20:28.402] Future #3
[13:20:28.402] result() for ClusterFuture ...
[13:20:28.402] - result already collected: FutureResult
[13:20:28.402] result() for ClusterFuture ... done
[13:20:28.402] result() for ClusterFuture ...
[13:20:28.402] - result already collected: FutureResult
[13:20:28.402] result() for ClusterFuture ... done
[13:20:28.402] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:28.402] - nx: 4
[13:20:28.402] - relay: TRUE
[13:20:28.402] - stdout: TRUE
[13:20:28.402] - signal: TRUE
[13:20:28.403] - resignal: FALSE
[13:20:28.403] - force: TRUE
[13:20:28.403] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:28.403] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:28.403]  - until=3
[13:20:28.403]  - relaying element #3
[13:20:28.403] result() for ClusterFuture ...
[13:20:28.403] - result already collected: FutureResult
[13:20:28.403] result() for ClusterFuture ... done
[13:20:28.403] result() for ClusterFuture ...
[13:20:28.403] - result already collected: FutureResult
[13:20:28.404] result() for ClusterFuture ... done
[13:20:28.404] result() for ClusterFuture ...
[13:20:28.404] - result already collected: FutureResult
[13:20:28.404] result() for ClusterFuture ... done
[13:20:28.404] result() for ClusterFuture ...
[13:20:28.404] - result already collected: FutureResult
[13:20:28.404] result() for ClusterFuture ... done
[13:20:28.404] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:28.404] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:28.404] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:28.404]  length: 1 (resolved future 3)
[13:20:28.430] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.430] - Validating connection of MultisessionFuture
[13:20:28.431] - received message: FutureResult
[13:20:28.431] - Received FutureResult
[13:20:28.431] - Erased future from FutureRegistry
[13:20:28.431] result() for ClusterFuture ...
[13:20:28.431] - result already collected: FutureResult
[13:20:28.431] result() for ClusterFuture ... done
[13:20:28.431] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:28.431] Future #4
[13:20:28.432] result() for ClusterFuture ...
[13:20:28.432] - result already collected: FutureResult
[13:20:28.432] result() for ClusterFuture ... done
[13:20:28.432] result() for ClusterFuture ...
[13:20:28.432] - result already collected: FutureResult
[13:20:28.432] result() for ClusterFuture ... done
[13:20:28.432] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:20:28.432] - nx: 4
[13:20:28.432] - relay: TRUE
[13:20:28.433] - stdout: TRUE
[13:20:28.433] - signal: TRUE
[13:20:28.433] - resignal: FALSE
[13:20:28.433] - force: TRUE
[13:20:28.433] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:28.433] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:28.433]  - until=4
[13:20:28.433]  - relaying element #4
[13:20:28.433] result() for ClusterFuture ...
[13:20:28.433] - result already collected: FutureResult
[13:20:28.433] result() for ClusterFuture ... done
[13:20:28.434] result() for ClusterFuture ...
[13:20:28.434] - result already collected: FutureResult
[13:20:28.434] result() for ClusterFuture ... done
[13:20:28.434] result() for ClusterFuture ...
[13:20:28.434] - result already collected: FutureResult
[13:20:28.434] result() for ClusterFuture ... done
[13:20:28.434] result() for ClusterFuture ...
[13:20:28.434] - result already collected: FutureResult
[13:20:28.434] result() for ClusterFuture ... done
[13:20:28.434] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.434] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:28.435] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:20:28.435]  length: 0 (resolved future 4)
[13:20:28.435] Relaying remaining futures
[13:20:28.435] signalConditionsASAP(NULL, pos=0) ...
[13:20:28.435] - nx: 4
[13:20:28.435] - relay: TRUE
[13:20:28.435] - stdout: TRUE
[13:20:28.435] - signal: TRUE
[13:20:28.435] - resignal: FALSE
[13:20:28.435] - force: TRUE
[13:20:28.435] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.436] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:28.436] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.436] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:28.436] signalConditionsASAP(NULL, pos=0) ... done
[13:20:28.436] resolve() on environment ... DONE
[13:20:28.436] result() for ClusterFuture ...
[13:20:28.436] - result already collected: FutureResult
[13:20:28.436] result() for ClusterFuture ... done
[13:20:28.436] result() for ClusterFuture ...
[13:20:28.436] - result already collected: FutureResult
[13:20:28.437] result() for ClusterFuture ... done
[13:20:28.437] result() for ClusterFuture ...
[13:20:28.437] - result already collected: FutureResult
[13:20:28.437] result() for ClusterFuture ... done
[13:20:28.437] result() for ClusterFuture ...
[13:20:28.437] - result already collected: FutureResult
[13:20:28.437] result() for ClusterFuture ... done
[13:20:28.437] result() for ClusterFuture ...
[13:20:28.437] - result already collected: FutureResult
[13:20:28.437] result() for ClusterFuture ... done
[13:20:28.438] result() for ClusterFuture ...
[13:20:28.438] - result already collected: FutureResult
[13:20:28.438] result() for ClusterFuture ... done
<environment: 0x55659b652d90> 
Dimensions: c(1, 6)
[13:20:28.438] getGlobalsAndPackages() ...
[13:20:28.438] Searching for globals...
[13:20:28.439] 
[13:20:28.439] Searching for globals ... DONE
[13:20:28.439] - globals: [0] <none>
[13:20:28.439] getGlobalsAndPackages() ... DONE
[13:20:28.439] run() for ‘Future’ ...
[13:20:28.439] - state: ‘created’
[13:20:28.439] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.454] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.454]   - Field: ‘node’
[13:20:28.454]   - Field: ‘label’
[13:20:28.454]   - Field: ‘local’
[13:20:28.454]   - Field: ‘owner’
[13:20:28.455]   - Field: ‘envir’
[13:20:28.455]   - Field: ‘workers’
[13:20:28.455]   - Field: ‘packages’
[13:20:28.455]   - Field: ‘gc’
[13:20:28.455]   - Field: ‘conditions’
[13:20:28.455]   - Field: ‘persistent’
[13:20:28.455]   - Field: ‘expr’
[13:20:28.455]   - Field: ‘uuid’
[13:20:28.455]   - Field: ‘seed’
[13:20:28.455]   - Field: ‘version’
[13:20:28.455]   - Field: ‘result’
[13:20:28.456]   - Field: ‘asynchronous’
[13:20:28.456]   - Field: ‘calls’
[13:20:28.456]   - Field: ‘globals’
[13:20:28.456]   - Field: ‘stdout’
[13:20:28.456]   - Field: ‘earlySignal’
[13:20:28.456]   - Field: ‘lazy’
[13:20:28.456]   - Field: ‘state’
[13:20:28.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.456] - Launch lazy future ...
[13:20:28.457] Packages needed by the future expression (n = 0): <none>
[13:20:28.457] Packages needed by future strategies (n = 0): <none>
[13:20:28.457] {
[13:20:28.457]     {
[13:20:28.457]         {
[13:20:28.457]             ...future.startTime <- base::Sys.time()
[13:20:28.457]             {
[13:20:28.457]                 {
[13:20:28.457]                   {
[13:20:28.457]                     {
[13:20:28.457]                       base::local({
[13:20:28.457]                         has_future <- base::requireNamespace("future", 
[13:20:28.457]                           quietly = TRUE)
[13:20:28.457]                         if (has_future) {
[13:20:28.457]                           ns <- base::getNamespace("future")
[13:20:28.457]                           version <- ns[[".package"]][["version"]]
[13:20:28.457]                           if (is.null(version)) 
[13:20:28.457]                             version <- utils::packageVersion("future")
[13:20:28.457]                         }
[13:20:28.457]                         else {
[13:20:28.457]                           version <- NULL
[13:20:28.457]                         }
[13:20:28.457]                         if (!has_future || version < "1.8.0") {
[13:20:28.457]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.457]                             "", base::R.version$version.string), 
[13:20:28.457]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.457]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.457]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.457]                               "release", "version")], collapse = " "), 
[13:20:28.457]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.457]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.457]                             info)
[13:20:28.457]                           info <- base::paste(info, collapse = "; ")
[13:20:28.457]                           if (!has_future) {
[13:20:28.457]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.457]                               info)
[13:20:28.457]                           }
[13:20:28.457]                           else {
[13:20:28.457]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.457]                               info, version)
[13:20:28.457]                           }
[13:20:28.457]                           base::stop(msg)
[13:20:28.457]                         }
[13:20:28.457]                       })
[13:20:28.457]                     }
[13:20:28.457]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.457]                     base::options(mc.cores = 1L)
[13:20:28.457]                   }
[13:20:28.457]                   options(future.plan = NULL)
[13:20:28.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.457]                 }
[13:20:28.457]                 ...future.workdir <- getwd()
[13:20:28.457]             }
[13:20:28.457]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.457]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.457]         }
[13:20:28.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.457]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.457]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.457]             base::names(...future.oldOptions))
[13:20:28.457]     }
[13:20:28.457]     if (FALSE) {
[13:20:28.457]     }
[13:20:28.457]     else {
[13:20:28.457]         if (TRUE) {
[13:20:28.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.457]                 open = "w")
[13:20:28.457]         }
[13:20:28.457]         else {
[13:20:28.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.457]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.457]         }
[13:20:28.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.457]             base::sink(type = "output", split = FALSE)
[13:20:28.457]             base::close(...future.stdout)
[13:20:28.457]         }, add = TRUE)
[13:20:28.457]     }
[13:20:28.457]     ...future.frame <- base::sys.nframe()
[13:20:28.457]     ...future.conditions <- base::list()
[13:20:28.457]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.457]     if (FALSE) {
[13:20:28.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.457]     }
[13:20:28.457]     ...future.result <- base::tryCatch({
[13:20:28.457]         base::withCallingHandlers({
[13:20:28.457]             ...future.value <- base::withVisible(base::local({
[13:20:28.457]                 ...future.makeSendCondition <- local({
[13:20:28.457]                   sendCondition <- NULL
[13:20:28.457]                   function(frame = 1L) {
[13:20:28.457]                     if (is.function(sendCondition)) 
[13:20:28.457]                       return(sendCondition)
[13:20:28.457]                     ns <- getNamespace("parallel")
[13:20:28.457]                     if (exists("sendData", mode = "function", 
[13:20:28.457]                       envir = ns)) {
[13:20:28.457]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.457]                         envir = ns)
[13:20:28.457]                       envir <- sys.frame(frame)
[13:20:28.457]                       master <- NULL
[13:20:28.457]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.457]                         !identical(envir, emptyenv())) {
[13:20:28.457]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.457]                           inherits = FALSE)) {
[13:20:28.457]                           master <- get("master", mode = "list", 
[13:20:28.457]                             envir = envir, inherits = FALSE)
[13:20:28.457]                           if (inherits(master, c("SOCKnode", 
[13:20:28.457]                             "SOCK0node"))) {
[13:20:28.457]                             sendCondition <<- function(cond) {
[13:20:28.457]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.457]                                 success = TRUE)
[13:20:28.457]                               parallel_sendData(master, data)
[13:20:28.457]                             }
[13:20:28.457]                             return(sendCondition)
[13:20:28.457]                           }
[13:20:28.457]                         }
[13:20:28.457]                         frame <- frame + 1L
[13:20:28.457]                         envir <- sys.frame(frame)
[13:20:28.457]                       }
[13:20:28.457]                     }
[13:20:28.457]                     sendCondition <<- function(cond) NULL
[13:20:28.457]                   }
[13:20:28.457]                 })
[13:20:28.457]                 withCallingHandlers({
[13:20:28.457]                   2
[13:20:28.457]                 }, immediateCondition = function(cond) {
[13:20:28.457]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.457]                   sendCondition(cond)
[13:20:28.457]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.457]                   {
[13:20:28.457]                     inherits <- base::inherits
[13:20:28.457]                     invokeRestart <- base::invokeRestart
[13:20:28.457]                     is.null <- base::is.null
[13:20:28.457]                     muffled <- FALSE
[13:20:28.457]                     if (inherits(cond, "message")) {
[13:20:28.457]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.457]                       if (muffled) 
[13:20:28.457]                         invokeRestart("muffleMessage")
[13:20:28.457]                     }
[13:20:28.457]                     else if (inherits(cond, "warning")) {
[13:20:28.457]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.457]                       if (muffled) 
[13:20:28.457]                         invokeRestart("muffleWarning")
[13:20:28.457]                     }
[13:20:28.457]                     else if (inherits(cond, "condition")) {
[13:20:28.457]                       if (!is.null(pattern)) {
[13:20:28.457]                         computeRestarts <- base::computeRestarts
[13:20:28.457]                         grepl <- base::grepl
[13:20:28.457]                         restarts <- computeRestarts(cond)
[13:20:28.457]                         for (restart in restarts) {
[13:20:28.457]                           name <- restart$name
[13:20:28.457]                           if (is.null(name)) 
[13:20:28.457]                             next
[13:20:28.457]                           if (!grepl(pattern, name)) 
[13:20:28.457]                             next
[13:20:28.457]                           invokeRestart(restart)
[13:20:28.457]                           muffled <- TRUE
[13:20:28.457]                           break
[13:20:28.457]                         }
[13:20:28.457]                       }
[13:20:28.457]                     }
[13:20:28.457]                     invisible(muffled)
[13:20:28.457]                   }
[13:20:28.457]                   muffleCondition(cond)
[13:20:28.457]                 })
[13:20:28.457]             }))
[13:20:28.457]             future::FutureResult(value = ...future.value$value, 
[13:20:28.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.457]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.457]                     ...future.globalenv.names))
[13:20:28.457]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.457]         }, condition = base::local({
[13:20:28.457]             c <- base::c
[13:20:28.457]             inherits <- base::inherits
[13:20:28.457]             invokeRestart <- base::invokeRestart
[13:20:28.457]             length <- base::length
[13:20:28.457]             list <- base::list
[13:20:28.457]             seq.int <- base::seq.int
[13:20:28.457]             signalCondition <- base::signalCondition
[13:20:28.457]             sys.calls <- base::sys.calls
[13:20:28.457]             `[[` <- base::`[[`
[13:20:28.457]             `+` <- base::`+`
[13:20:28.457]             `<<-` <- base::`<<-`
[13:20:28.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.457]                   3L)]
[13:20:28.457]             }
[13:20:28.457]             function(cond) {
[13:20:28.457]                 is_error <- inherits(cond, "error")
[13:20:28.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.457]                   NULL)
[13:20:28.457]                 if (is_error) {
[13:20:28.457]                   sessionInformation <- function() {
[13:20:28.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.457]                       search = base::search(), system = base::Sys.info())
[13:20:28.457]                   }
[13:20:28.457]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.457]                     cond$call), session = sessionInformation(), 
[13:20:28.457]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.457]                   signalCondition(cond)
[13:20:28.457]                 }
[13:20:28.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.457]                 "immediateCondition"))) {
[13:20:28.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.457]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.457]                   if (TRUE && !signal) {
[13:20:28.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.457]                     {
[13:20:28.457]                       inherits <- base::inherits
[13:20:28.457]                       invokeRestart <- base::invokeRestart
[13:20:28.457]                       is.null <- base::is.null
[13:20:28.457]                       muffled <- FALSE
[13:20:28.457]                       if (inherits(cond, "message")) {
[13:20:28.457]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.457]                         if (muffled) 
[13:20:28.457]                           invokeRestart("muffleMessage")
[13:20:28.457]                       }
[13:20:28.457]                       else if (inherits(cond, "warning")) {
[13:20:28.457]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.457]                         if (muffled) 
[13:20:28.457]                           invokeRestart("muffleWarning")
[13:20:28.457]                       }
[13:20:28.457]                       else if (inherits(cond, "condition")) {
[13:20:28.457]                         if (!is.null(pattern)) {
[13:20:28.457]                           computeRestarts <- base::computeRestarts
[13:20:28.457]                           grepl <- base::grepl
[13:20:28.457]                           restarts <- computeRestarts(cond)
[13:20:28.457]                           for (restart in restarts) {
[13:20:28.457]                             name <- restart$name
[13:20:28.457]                             if (is.null(name)) 
[13:20:28.457]                               next
[13:20:28.457]                             if (!grepl(pattern, name)) 
[13:20:28.457]                               next
[13:20:28.457]                             invokeRestart(restart)
[13:20:28.457]                             muffled <- TRUE
[13:20:28.457]                             break
[13:20:28.457]                           }
[13:20:28.457]                         }
[13:20:28.457]                       }
[13:20:28.457]                       invisible(muffled)
[13:20:28.457]                     }
[13:20:28.457]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.457]                   }
[13:20:28.457]                 }
[13:20:28.457]                 else {
[13:20:28.457]                   if (TRUE) {
[13:20:28.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.457]                     {
[13:20:28.457]                       inherits <- base::inherits
[13:20:28.457]                       invokeRestart <- base::invokeRestart
[13:20:28.457]                       is.null <- base::is.null
[13:20:28.457]                       muffled <- FALSE
[13:20:28.457]                       if (inherits(cond, "message")) {
[13:20:28.457]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.457]                         if (muffled) 
[13:20:28.457]                           invokeRestart("muffleMessage")
[13:20:28.457]                       }
[13:20:28.457]                       else if (inherits(cond, "warning")) {
[13:20:28.457]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.457]                         if (muffled) 
[13:20:28.457]                           invokeRestart("muffleWarning")
[13:20:28.457]                       }
[13:20:28.457]                       else if (inherits(cond, "condition")) {
[13:20:28.457]                         if (!is.null(pattern)) {
[13:20:28.457]                           computeRestarts <- base::computeRestarts
[13:20:28.457]                           grepl <- base::grepl
[13:20:28.457]                           restarts <- computeRestarts(cond)
[13:20:28.457]                           for (restart in restarts) {
[13:20:28.457]                             name <- restart$name
[13:20:28.457]                             if (is.null(name)) 
[13:20:28.457]                               next
[13:20:28.457]                             if (!grepl(pattern, name)) 
[13:20:28.457]                               next
[13:20:28.457]                             invokeRestart(restart)
[13:20:28.457]                             muffled <- TRUE
[13:20:28.457]                             break
[13:20:28.457]                           }
[13:20:28.457]                         }
[13:20:28.457]                       }
[13:20:28.457]                       invisible(muffled)
[13:20:28.457]                     }
[13:20:28.457]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.457]                   }
[13:20:28.457]                 }
[13:20:28.457]             }
[13:20:28.457]         }))
[13:20:28.457]     }, error = function(ex) {
[13:20:28.457]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.457]                 ...future.rng), started = ...future.startTime, 
[13:20:28.457]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.457]             version = "1.8"), class = "FutureResult")
[13:20:28.457]     }, finally = {
[13:20:28.457]         if (!identical(...future.workdir, getwd())) 
[13:20:28.457]             setwd(...future.workdir)
[13:20:28.457]         {
[13:20:28.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.457]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.457]             }
[13:20:28.457]             base::options(...future.oldOptions)
[13:20:28.457]             if (.Platform$OS.type == "windows") {
[13:20:28.457]                 old_names <- names(...future.oldEnvVars)
[13:20:28.457]                 envs <- base::Sys.getenv()
[13:20:28.457]                 names <- names(envs)
[13:20:28.457]                 common <- intersect(names, old_names)
[13:20:28.457]                 added <- setdiff(names, old_names)
[13:20:28.457]                 removed <- setdiff(old_names, names)
[13:20:28.457]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.457]                   envs[common]]
[13:20:28.457]                 NAMES <- toupper(changed)
[13:20:28.457]                 args <- list()
[13:20:28.457]                 for (kk in seq_along(NAMES)) {
[13:20:28.457]                   name <- changed[[kk]]
[13:20:28.457]                   NAME <- NAMES[[kk]]
[13:20:28.457]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.457]                     next
[13:20:28.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.457]                 }
[13:20:28.457]                 NAMES <- toupper(added)
[13:20:28.457]                 for (kk in seq_along(NAMES)) {
[13:20:28.457]                   name <- added[[kk]]
[13:20:28.457]                   NAME <- NAMES[[kk]]
[13:20:28.457]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.457]                     next
[13:20:28.457]                   args[[name]] <- ""
[13:20:28.457]                 }
[13:20:28.457]                 NAMES <- toupper(removed)
[13:20:28.457]                 for (kk in seq_along(NAMES)) {
[13:20:28.457]                   name <- removed[[kk]]
[13:20:28.457]                   NAME <- NAMES[[kk]]
[13:20:28.457]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.457]                     next
[13:20:28.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.457]                 }
[13:20:28.457]                 if (length(args) > 0) 
[13:20:28.457]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.457]             }
[13:20:28.457]             else {
[13:20:28.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.457]             }
[13:20:28.457]             {
[13:20:28.457]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.457]                   0L) {
[13:20:28.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.457]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.457]                   base::options(opts)
[13:20:28.457]                 }
[13:20:28.457]                 {
[13:20:28.457]                   {
[13:20:28.457]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.457]                     NULL
[13:20:28.457]                   }
[13:20:28.457]                   options(future.plan = NULL)
[13:20:28.457]                   if (is.na(NA_character_)) 
[13:20:28.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.457]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.457]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.457]                     envir = parent.frame()) 
[13:20:28.457]                   {
[13:20:28.457]                     if (is.function(workers)) 
[13:20:28.457]                       workers <- workers()
[13:20:28.457]                     workers <- structure(as.integer(workers), 
[13:20:28.457]                       class = class(workers))
[13:20:28.457]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.457]                       workers >= 1)
[13:20:28.457]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.457]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.457]                     }
[13:20:28.457]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.457]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.457]                       envir = envir)
[13:20:28.457]                     if (!future$lazy) 
[13:20:28.457]                       future <- run(future)
[13:20:28.457]                     invisible(future)
[13:20:28.457]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.457]                 }
[13:20:28.457]             }
[13:20:28.457]         }
[13:20:28.457]     })
[13:20:28.457]     if (TRUE) {
[13:20:28.457]         base::sink(type = "output", split = FALSE)
[13:20:28.457]         if (TRUE) {
[13:20:28.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.457]         }
[13:20:28.457]         else {
[13:20:28.457]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.457]         }
[13:20:28.457]         base::close(...future.stdout)
[13:20:28.457]         ...future.stdout <- NULL
[13:20:28.457]     }
[13:20:28.457]     ...future.result$conditions <- ...future.conditions
[13:20:28.457]     ...future.result$finished <- base::Sys.time()
[13:20:28.457]     ...future.result
[13:20:28.457] }
[13:20:28.460] MultisessionFuture started
[13:20:28.460] - Launch lazy future ... done
[13:20:28.460] run() for ‘MultisessionFuture’ ... done
[13:20:28.461] getGlobalsAndPackages() ...
[13:20:28.461] Searching for globals...
[13:20:28.461] 
[13:20:28.461] Searching for globals ... DONE
[13:20:28.461] - globals: [0] <none>
[13:20:28.461] getGlobalsAndPackages() ... DONE
[13:20:28.462] run() for ‘Future’ ...
[13:20:28.462] - state: ‘created’
[13:20:28.462] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.476] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.476]   - Field: ‘node’
[13:20:28.476]   - Field: ‘label’
[13:20:28.476]   - Field: ‘local’
[13:20:28.476]   - Field: ‘owner’
[13:20:28.476]   - Field: ‘envir’
[13:20:28.477]   - Field: ‘workers’
[13:20:28.477]   - Field: ‘packages’
[13:20:28.477]   - Field: ‘gc’
[13:20:28.477]   - Field: ‘conditions’
[13:20:28.477]   - Field: ‘persistent’
[13:20:28.477]   - Field: ‘expr’
[13:20:28.477]   - Field: ‘uuid’
[13:20:28.477]   - Field: ‘seed’
[13:20:28.477]   - Field: ‘version’
[13:20:28.477]   - Field: ‘result’
[13:20:28.477]   - Field: ‘asynchronous’
[13:20:28.478]   - Field: ‘calls’
[13:20:28.478]   - Field: ‘globals’
[13:20:28.478]   - Field: ‘stdout’
[13:20:28.478]   - Field: ‘earlySignal’
[13:20:28.478]   - Field: ‘lazy’
[13:20:28.478]   - Field: ‘state’
[13:20:28.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.478] - Launch lazy future ...
[13:20:28.479] Packages needed by the future expression (n = 0): <none>
[13:20:28.479] Packages needed by future strategies (n = 0): <none>
[13:20:28.479] {
[13:20:28.479]     {
[13:20:28.479]         {
[13:20:28.479]             ...future.startTime <- base::Sys.time()
[13:20:28.479]             {
[13:20:28.479]                 {
[13:20:28.479]                   {
[13:20:28.479]                     {
[13:20:28.479]                       base::local({
[13:20:28.479]                         has_future <- base::requireNamespace("future", 
[13:20:28.479]                           quietly = TRUE)
[13:20:28.479]                         if (has_future) {
[13:20:28.479]                           ns <- base::getNamespace("future")
[13:20:28.479]                           version <- ns[[".package"]][["version"]]
[13:20:28.479]                           if (is.null(version)) 
[13:20:28.479]                             version <- utils::packageVersion("future")
[13:20:28.479]                         }
[13:20:28.479]                         else {
[13:20:28.479]                           version <- NULL
[13:20:28.479]                         }
[13:20:28.479]                         if (!has_future || version < "1.8.0") {
[13:20:28.479]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.479]                             "", base::R.version$version.string), 
[13:20:28.479]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.479]                               "release", "version")], collapse = " "), 
[13:20:28.479]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.479]                             info)
[13:20:28.479]                           info <- base::paste(info, collapse = "; ")
[13:20:28.479]                           if (!has_future) {
[13:20:28.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.479]                               info)
[13:20:28.479]                           }
[13:20:28.479]                           else {
[13:20:28.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.479]                               info, version)
[13:20:28.479]                           }
[13:20:28.479]                           base::stop(msg)
[13:20:28.479]                         }
[13:20:28.479]                       })
[13:20:28.479]                     }
[13:20:28.479]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.479]                     base::options(mc.cores = 1L)
[13:20:28.479]                   }
[13:20:28.479]                   options(future.plan = NULL)
[13:20:28.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.479]                 }
[13:20:28.479]                 ...future.workdir <- getwd()
[13:20:28.479]             }
[13:20:28.479]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.479]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.479]         }
[13:20:28.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.479]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.479]             base::names(...future.oldOptions))
[13:20:28.479]     }
[13:20:28.479]     if (FALSE) {
[13:20:28.479]     }
[13:20:28.479]     else {
[13:20:28.479]         if (TRUE) {
[13:20:28.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.479]                 open = "w")
[13:20:28.479]         }
[13:20:28.479]         else {
[13:20:28.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.479]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.479]         }
[13:20:28.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.479]             base::sink(type = "output", split = FALSE)
[13:20:28.479]             base::close(...future.stdout)
[13:20:28.479]         }, add = TRUE)
[13:20:28.479]     }
[13:20:28.479]     ...future.frame <- base::sys.nframe()
[13:20:28.479]     ...future.conditions <- base::list()
[13:20:28.479]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.479]     if (FALSE) {
[13:20:28.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.479]     }
[13:20:28.479]     ...future.result <- base::tryCatch({
[13:20:28.479]         base::withCallingHandlers({
[13:20:28.479]             ...future.value <- base::withVisible(base::local({
[13:20:28.479]                 ...future.makeSendCondition <- local({
[13:20:28.479]                   sendCondition <- NULL
[13:20:28.479]                   function(frame = 1L) {
[13:20:28.479]                     if (is.function(sendCondition)) 
[13:20:28.479]                       return(sendCondition)
[13:20:28.479]                     ns <- getNamespace("parallel")
[13:20:28.479]                     if (exists("sendData", mode = "function", 
[13:20:28.479]                       envir = ns)) {
[13:20:28.479]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.479]                         envir = ns)
[13:20:28.479]                       envir <- sys.frame(frame)
[13:20:28.479]                       master <- NULL
[13:20:28.479]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.479]                         !identical(envir, emptyenv())) {
[13:20:28.479]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.479]                           inherits = FALSE)) {
[13:20:28.479]                           master <- get("master", mode = "list", 
[13:20:28.479]                             envir = envir, inherits = FALSE)
[13:20:28.479]                           if (inherits(master, c("SOCKnode", 
[13:20:28.479]                             "SOCK0node"))) {
[13:20:28.479]                             sendCondition <<- function(cond) {
[13:20:28.479]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.479]                                 success = TRUE)
[13:20:28.479]                               parallel_sendData(master, data)
[13:20:28.479]                             }
[13:20:28.479]                             return(sendCondition)
[13:20:28.479]                           }
[13:20:28.479]                         }
[13:20:28.479]                         frame <- frame + 1L
[13:20:28.479]                         envir <- sys.frame(frame)
[13:20:28.479]                       }
[13:20:28.479]                     }
[13:20:28.479]                     sendCondition <<- function(cond) NULL
[13:20:28.479]                   }
[13:20:28.479]                 })
[13:20:28.479]                 withCallingHandlers({
[13:20:28.479]                   NULL
[13:20:28.479]                 }, immediateCondition = function(cond) {
[13:20:28.479]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.479]                   sendCondition(cond)
[13:20:28.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.479]                   {
[13:20:28.479]                     inherits <- base::inherits
[13:20:28.479]                     invokeRestart <- base::invokeRestart
[13:20:28.479]                     is.null <- base::is.null
[13:20:28.479]                     muffled <- FALSE
[13:20:28.479]                     if (inherits(cond, "message")) {
[13:20:28.479]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.479]                       if (muffled) 
[13:20:28.479]                         invokeRestart("muffleMessage")
[13:20:28.479]                     }
[13:20:28.479]                     else if (inherits(cond, "warning")) {
[13:20:28.479]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.479]                       if (muffled) 
[13:20:28.479]                         invokeRestart("muffleWarning")
[13:20:28.479]                     }
[13:20:28.479]                     else if (inherits(cond, "condition")) {
[13:20:28.479]                       if (!is.null(pattern)) {
[13:20:28.479]                         computeRestarts <- base::computeRestarts
[13:20:28.479]                         grepl <- base::grepl
[13:20:28.479]                         restarts <- computeRestarts(cond)
[13:20:28.479]                         for (restart in restarts) {
[13:20:28.479]                           name <- restart$name
[13:20:28.479]                           if (is.null(name)) 
[13:20:28.479]                             next
[13:20:28.479]                           if (!grepl(pattern, name)) 
[13:20:28.479]                             next
[13:20:28.479]                           invokeRestart(restart)
[13:20:28.479]                           muffled <- TRUE
[13:20:28.479]                           break
[13:20:28.479]                         }
[13:20:28.479]                       }
[13:20:28.479]                     }
[13:20:28.479]                     invisible(muffled)
[13:20:28.479]                   }
[13:20:28.479]                   muffleCondition(cond)
[13:20:28.479]                 })
[13:20:28.479]             }))
[13:20:28.479]             future::FutureResult(value = ...future.value$value, 
[13:20:28.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.479]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.479]                     ...future.globalenv.names))
[13:20:28.479]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.479]         }, condition = base::local({
[13:20:28.479]             c <- base::c
[13:20:28.479]             inherits <- base::inherits
[13:20:28.479]             invokeRestart <- base::invokeRestart
[13:20:28.479]             length <- base::length
[13:20:28.479]             list <- base::list
[13:20:28.479]             seq.int <- base::seq.int
[13:20:28.479]             signalCondition <- base::signalCondition
[13:20:28.479]             sys.calls <- base::sys.calls
[13:20:28.479]             `[[` <- base::`[[`
[13:20:28.479]             `+` <- base::`+`
[13:20:28.479]             `<<-` <- base::`<<-`
[13:20:28.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.479]                   3L)]
[13:20:28.479]             }
[13:20:28.479]             function(cond) {
[13:20:28.479]                 is_error <- inherits(cond, "error")
[13:20:28.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.479]                   NULL)
[13:20:28.479]                 if (is_error) {
[13:20:28.479]                   sessionInformation <- function() {
[13:20:28.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.479]                       search = base::search(), system = base::Sys.info())
[13:20:28.479]                   }
[13:20:28.479]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.479]                     cond$call), session = sessionInformation(), 
[13:20:28.479]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.479]                   signalCondition(cond)
[13:20:28.479]                 }
[13:20:28.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.479]                 "immediateCondition"))) {
[13:20:28.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.479]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.479]                   if (TRUE && !signal) {
[13:20:28.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.479]                     {
[13:20:28.479]                       inherits <- base::inherits
[13:20:28.479]                       invokeRestart <- base::invokeRestart
[13:20:28.479]                       is.null <- base::is.null
[13:20:28.479]                       muffled <- FALSE
[13:20:28.479]                       if (inherits(cond, "message")) {
[13:20:28.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.479]                         if (muffled) 
[13:20:28.479]                           invokeRestart("muffleMessage")
[13:20:28.479]                       }
[13:20:28.479]                       else if (inherits(cond, "warning")) {
[13:20:28.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.479]                         if (muffled) 
[13:20:28.479]                           invokeRestart("muffleWarning")
[13:20:28.479]                       }
[13:20:28.479]                       else if (inherits(cond, "condition")) {
[13:20:28.479]                         if (!is.null(pattern)) {
[13:20:28.479]                           computeRestarts <- base::computeRestarts
[13:20:28.479]                           grepl <- base::grepl
[13:20:28.479]                           restarts <- computeRestarts(cond)
[13:20:28.479]                           for (restart in restarts) {
[13:20:28.479]                             name <- restart$name
[13:20:28.479]                             if (is.null(name)) 
[13:20:28.479]                               next
[13:20:28.479]                             if (!grepl(pattern, name)) 
[13:20:28.479]                               next
[13:20:28.479]                             invokeRestart(restart)
[13:20:28.479]                             muffled <- TRUE
[13:20:28.479]                             break
[13:20:28.479]                           }
[13:20:28.479]                         }
[13:20:28.479]                       }
[13:20:28.479]                       invisible(muffled)
[13:20:28.479]                     }
[13:20:28.479]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.479]                   }
[13:20:28.479]                 }
[13:20:28.479]                 else {
[13:20:28.479]                   if (TRUE) {
[13:20:28.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.479]                     {
[13:20:28.479]                       inherits <- base::inherits
[13:20:28.479]                       invokeRestart <- base::invokeRestart
[13:20:28.479]                       is.null <- base::is.null
[13:20:28.479]                       muffled <- FALSE
[13:20:28.479]                       if (inherits(cond, "message")) {
[13:20:28.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.479]                         if (muffled) 
[13:20:28.479]                           invokeRestart("muffleMessage")
[13:20:28.479]                       }
[13:20:28.479]                       else if (inherits(cond, "warning")) {
[13:20:28.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.479]                         if (muffled) 
[13:20:28.479]                           invokeRestart("muffleWarning")
[13:20:28.479]                       }
[13:20:28.479]                       else if (inherits(cond, "condition")) {
[13:20:28.479]                         if (!is.null(pattern)) {
[13:20:28.479]                           computeRestarts <- base::computeRestarts
[13:20:28.479]                           grepl <- base::grepl
[13:20:28.479]                           restarts <- computeRestarts(cond)
[13:20:28.479]                           for (restart in restarts) {
[13:20:28.479]                             name <- restart$name
[13:20:28.479]                             if (is.null(name)) 
[13:20:28.479]                               next
[13:20:28.479]                             if (!grepl(pattern, name)) 
[13:20:28.479]                               next
[13:20:28.479]                             invokeRestart(restart)
[13:20:28.479]                             muffled <- TRUE
[13:20:28.479]                             break
[13:20:28.479]                           }
[13:20:28.479]                         }
[13:20:28.479]                       }
[13:20:28.479]                       invisible(muffled)
[13:20:28.479]                     }
[13:20:28.479]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.479]                   }
[13:20:28.479]                 }
[13:20:28.479]             }
[13:20:28.479]         }))
[13:20:28.479]     }, error = function(ex) {
[13:20:28.479]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.479]                 ...future.rng), started = ...future.startTime, 
[13:20:28.479]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.479]             version = "1.8"), class = "FutureResult")
[13:20:28.479]     }, finally = {
[13:20:28.479]         if (!identical(...future.workdir, getwd())) 
[13:20:28.479]             setwd(...future.workdir)
[13:20:28.479]         {
[13:20:28.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.479]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.479]             }
[13:20:28.479]             base::options(...future.oldOptions)
[13:20:28.479]             if (.Platform$OS.type == "windows") {
[13:20:28.479]                 old_names <- names(...future.oldEnvVars)
[13:20:28.479]                 envs <- base::Sys.getenv()
[13:20:28.479]                 names <- names(envs)
[13:20:28.479]                 common <- intersect(names, old_names)
[13:20:28.479]                 added <- setdiff(names, old_names)
[13:20:28.479]                 removed <- setdiff(old_names, names)
[13:20:28.479]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.479]                   envs[common]]
[13:20:28.479]                 NAMES <- toupper(changed)
[13:20:28.479]                 args <- list()
[13:20:28.479]                 for (kk in seq_along(NAMES)) {
[13:20:28.479]                   name <- changed[[kk]]
[13:20:28.479]                   NAME <- NAMES[[kk]]
[13:20:28.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.479]                     next
[13:20:28.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.479]                 }
[13:20:28.479]                 NAMES <- toupper(added)
[13:20:28.479]                 for (kk in seq_along(NAMES)) {
[13:20:28.479]                   name <- added[[kk]]
[13:20:28.479]                   NAME <- NAMES[[kk]]
[13:20:28.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.479]                     next
[13:20:28.479]                   args[[name]] <- ""
[13:20:28.479]                 }
[13:20:28.479]                 NAMES <- toupper(removed)
[13:20:28.479]                 for (kk in seq_along(NAMES)) {
[13:20:28.479]                   name <- removed[[kk]]
[13:20:28.479]                   NAME <- NAMES[[kk]]
[13:20:28.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.479]                     next
[13:20:28.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.479]                 }
[13:20:28.479]                 if (length(args) > 0) 
[13:20:28.479]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.479]             }
[13:20:28.479]             else {
[13:20:28.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.479]             }
[13:20:28.479]             {
[13:20:28.479]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.479]                   0L) {
[13:20:28.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.479]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.479]                   base::options(opts)
[13:20:28.479]                 }
[13:20:28.479]                 {
[13:20:28.479]                   {
[13:20:28.479]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.479]                     NULL
[13:20:28.479]                   }
[13:20:28.479]                   options(future.plan = NULL)
[13:20:28.479]                   if (is.na(NA_character_)) 
[13:20:28.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.479]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.479]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.479]                     envir = parent.frame()) 
[13:20:28.479]                   {
[13:20:28.479]                     if (is.function(workers)) 
[13:20:28.479]                       workers <- workers()
[13:20:28.479]                     workers <- structure(as.integer(workers), 
[13:20:28.479]                       class = class(workers))
[13:20:28.479]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.479]                       workers >= 1)
[13:20:28.479]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.479]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.479]                     }
[13:20:28.479]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.479]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.479]                       envir = envir)
[13:20:28.479]                     if (!future$lazy) 
[13:20:28.479]                       future <- run(future)
[13:20:28.479]                     invisible(future)
[13:20:28.479]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.479]                 }
[13:20:28.479]             }
[13:20:28.479]         }
[13:20:28.479]     })
[13:20:28.479]     if (TRUE) {
[13:20:28.479]         base::sink(type = "output", split = FALSE)
[13:20:28.479]         if (TRUE) {
[13:20:28.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.479]         }
[13:20:28.479]         else {
[13:20:28.479]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.479]         }
[13:20:28.479]         base::close(...future.stdout)
[13:20:28.479]         ...future.stdout <- NULL
[13:20:28.479]     }
[13:20:28.479]     ...future.result$conditions <- ...future.conditions
[13:20:28.479]     ...future.result$finished <- base::Sys.time()
[13:20:28.479]     ...future.result
[13:20:28.479] }
[13:20:28.482] MultisessionFuture started
[13:20:28.482] - Launch lazy future ... done
[13:20:28.483] run() for ‘MultisessionFuture’ ... done
[13:20:28.483] getGlobalsAndPackages() ...
[13:20:28.483] Searching for globals...
[13:20:28.484] - globals found: [1] ‘{’
[13:20:28.484] Searching for globals ... DONE
[13:20:28.484] Resolving globals: FALSE
[13:20:28.484] 
[13:20:28.484] 
[13:20:28.484] getGlobalsAndPackages() ... DONE
[13:20:28.485] run() for ‘Future’ ...
[13:20:28.485] - state: ‘created’
[13:20:28.485] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.499] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.499]   - Field: ‘node’
[13:20:28.499]   - Field: ‘label’
[13:20:28.500]   - Field: ‘local’
[13:20:28.500]   - Field: ‘owner’
[13:20:28.500]   - Field: ‘envir’
[13:20:28.500]   - Field: ‘workers’
[13:20:28.500]   - Field: ‘packages’
[13:20:28.500]   - Field: ‘gc’
[13:20:28.500]   - Field: ‘conditions’
[13:20:28.500]   - Field: ‘persistent’
[13:20:28.500]   - Field: ‘expr’
[13:20:28.500]   - Field: ‘uuid’
[13:20:28.500]   - Field: ‘seed’
[13:20:28.501]   - Field: ‘version’
[13:20:28.501]   - Field: ‘result’
[13:20:28.501]   - Field: ‘asynchronous’
[13:20:28.501]   - Field: ‘calls’
[13:20:28.501]   - Field: ‘globals’
[13:20:28.501]   - Field: ‘stdout’
[13:20:28.501]   - Field: ‘earlySignal’
[13:20:28.501]   - Field: ‘lazy’
[13:20:28.501]   - Field: ‘state’
[13:20:28.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.502] - Launch lazy future ...
[13:20:28.502] Packages needed by the future expression (n = 0): <none>
[13:20:28.502] Packages needed by future strategies (n = 0): <none>
[13:20:28.502] {
[13:20:28.502]     {
[13:20:28.502]         {
[13:20:28.502]             ...future.startTime <- base::Sys.time()
[13:20:28.502]             {
[13:20:28.502]                 {
[13:20:28.502]                   {
[13:20:28.502]                     {
[13:20:28.502]                       base::local({
[13:20:28.502]                         has_future <- base::requireNamespace("future", 
[13:20:28.502]                           quietly = TRUE)
[13:20:28.502]                         if (has_future) {
[13:20:28.502]                           ns <- base::getNamespace("future")
[13:20:28.502]                           version <- ns[[".package"]][["version"]]
[13:20:28.502]                           if (is.null(version)) 
[13:20:28.502]                             version <- utils::packageVersion("future")
[13:20:28.502]                         }
[13:20:28.502]                         else {
[13:20:28.502]                           version <- NULL
[13:20:28.502]                         }
[13:20:28.502]                         if (!has_future || version < "1.8.0") {
[13:20:28.502]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.502]                             "", base::R.version$version.string), 
[13:20:28.502]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.502]                               "release", "version")], collapse = " "), 
[13:20:28.502]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.502]                             info)
[13:20:28.502]                           info <- base::paste(info, collapse = "; ")
[13:20:28.502]                           if (!has_future) {
[13:20:28.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.502]                               info)
[13:20:28.502]                           }
[13:20:28.502]                           else {
[13:20:28.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.502]                               info, version)
[13:20:28.502]                           }
[13:20:28.502]                           base::stop(msg)
[13:20:28.502]                         }
[13:20:28.502]                       })
[13:20:28.502]                     }
[13:20:28.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.502]                     base::options(mc.cores = 1L)
[13:20:28.502]                   }
[13:20:28.502]                   options(future.plan = NULL)
[13:20:28.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.502]                 }
[13:20:28.502]                 ...future.workdir <- getwd()
[13:20:28.502]             }
[13:20:28.502]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.502]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.502]         }
[13:20:28.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.502]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.502]             base::names(...future.oldOptions))
[13:20:28.502]     }
[13:20:28.502]     if (FALSE) {
[13:20:28.502]     }
[13:20:28.502]     else {
[13:20:28.502]         if (TRUE) {
[13:20:28.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.502]                 open = "w")
[13:20:28.502]         }
[13:20:28.502]         else {
[13:20:28.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.502]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.502]         }
[13:20:28.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.502]             base::sink(type = "output", split = FALSE)
[13:20:28.502]             base::close(...future.stdout)
[13:20:28.502]         }, add = TRUE)
[13:20:28.502]     }
[13:20:28.502]     ...future.frame <- base::sys.nframe()
[13:20:28.502]     ...future.conditions <- base::list()
[13:20:28.502]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.502]     if (FALSE) {
[13:20:28.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.502]     }
[13:20:28.502]     ...future.result <- base::tryCatch({
[13:20:28.502]         base::withCallingHandlers({
[13:20:28.502]             ...future.value <- base::withVisible(base::local({
[13:20:28.502]                 ...future.makeSendCondition <- local({
[13:20:28.502]                   sendCondition <- NULL
[13:20:28.502]                   function(frame = 1L) {
[13:20:28.502]                     if (is.function(sendCondition)) 
[13:20:28.502]                       return(sendCondition)
[13:20:28.502]                     ns <- getNamespace("parallel")
[13:20:28.502]                     if (exists("sendData", mode = "function", 
[13:20:28.502]                       envir = ns)) {
[13:20:28.502]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.502]                         envir = ns)
[13:20:28.502]                       envir <- sys.frame(frame)
[13:20:28.502]                       master <- NULL
[13:20:28.502]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.502]                         !identical(envir, emptyenv())) {
[13:20:28.502]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.502]                           inherits = FALSE)) {
[13:20:28.502]                           master <- get("master", mode = "list", 
[13:20:28.502]                             envir = envir, inherits = FALSE)
[13:20:28.502]                           if (inherits(master, c("SOCKnode", 
[13:20:28.502]                             "SOCK0node"))) {
[13:20:28.502]                             sendCondition <<- function(cond) {
[13:20:28.502]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.502]                                 success = TRUE)
[13:20:28.502]                               parallel_sendData(master, data)
[13:20:28.502]                             }
[13:20:28.502]                             return(sendCondition)
[13:20:28.502]                           }
[13:20:28.502]                         }
[13:20:28.502]                         frame <- frame + 1L
[13:20:28.502]                         envir <- sys.frame(frame)
[13:20:28.502]                       }
[13:20:28.502]                     }
[13:20:28.502]                     sendCondition <<- function(cond) NULL
[13:20:28.502]                   }
[13:20:28.502]                 })
[13:20:28.502]                 withCallingHandlers({
[13:20:28.502]                   {
[13:20:28.502]                     4
[13:20:28.502]                   }
[13:20:28.502]                 }, immediateCondition = function(cond) {
[13:20:28.502]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.502]                   sendCondition(cond)
[13:20:28.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.502]                   {
[13:20:28.502]                     inherits <- base::inherits
[13:20:28.502]                     invokeRestart <- base::invokeRestart
[13:20:28.502]                     is.null <- base::is.null
[13:20:28.502]                     muffled <- FALSE
[13:20:28.502]                     if (inherits(cond, "message")) {
[13:20:28.502]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.502]                       if (muffled) 
[13:20:28.502]                         invokeRestart("muffleMessage")
[13:20:28.502]                     }
[13:20:28.502]                     else if (inherits(cond, "warning")) {
[13:20:28.502]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.502]                       if (muffled) 
[13:20:28.502]                         invokeRestart("muffleWarning")
[13:20:28.502]                     }
[13:20:28.502]                     else if (inherits(cond, "condition")) {
[13:20:28.502]                       if (!is.null(pattern)) {
[13:20:28.502]                         computeRestarts <- base::computeRestarts
[13:20:28.502]                         grepl <- base::grepl
[13:20:28.502]                         restarts <- computeRestarts(cond)
[13:20:28.502]                         for (restart in restarts) {
[13:20:28.502]                           name <- restart$name
[13:20:28.502]                           if (is.null(name)) 
[13:20:28.502]                             next
[13:20:28.502]                           if (!grepl(pattern, name)) 
[13:20:28.502]                             next
[13:20:28.502]                           invokeRestart(restart)
[13:20:28.502]                           muffled <- TRUE
[13:20:28.502]                           break
[13:20:28.502]                         }
[13:20:28.502]                       }
[13:20:28.502]                     }
[13:20:28.502]                     invisible(muffled)
[13:20:28.502]                   }
[13:20:28.502]                   muffleCondition(cond)
[13:20:28.502]                 })
[13:20:28.502]             }))
[13:20:28.502]             future::FutureResult(value = ...future.value$value, 
[13:20:28.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.502]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.502]                     ...future.globalenv.names))
[13:20:28.502]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.502]         }, condition = base::local({
[13:20:28.502]             c <- base::c
[13:20:28.502]             inherits <- base::inherits
[13:20:28.502]             invokeRestart <- base::invokeRestart
[13:20:28.502]             length <- base::length
[13:20:28.502]             list <- base::list
[13:20:28.502]             seq.int <- base::seq.int
[13:20:28.502]             signalCondition <- base::signalCondition
[13:20:28.502]             sys.calls <- base::sys.calls
[13:20:28.502]             `[[` <- base::`[[`
[13:20:28.502]             `+` <- base::`+`
[13:20:28.502]             `<<-` <- base::`<<-`
[13:20:28.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.502]                   3L)]
[13:20:28.502]             }
[13:20:28.502]             function(cond) {
[13:20:28.502]                 is_error <- inherits(cond, "error")
[13:20:28.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.502]                   NULL)
[13:20:28.502]                 if (is_error) {
[13:20:28.502]                   sessionInformation <- function() {
[13:20:28.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.502]                       search = base::search(), system = base::Sys.info())
[13:20:28.502]                   }
[13:20:28.502]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.502]                     cond$call), session = sessionInformation(), 
[13:20:28.502]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.502]                   signalCondition(cond)
[13:20:28.502]                 }
[13:20:28.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.502]                 "immediateCondition"))) {
[13:20:28.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.502]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.502]                   if (TRUE && !signal) {
[13:20:28.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.502]                     {
[13:20:28.502]                       inherits <- base::inherits
[13:20:28.502]                       invokeRestart <- base::invokeRestart
[13:20:28.502]                       is.null <- base::is.null
[13:20:28.502]                       muffled <- FALSE
[13:20:28.502]                       if (inherits(cond, "message")) {
[13:20:28.502]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.502]                         if (muffled) 
[13:20:28.502]                           invokeRestart("muffleMessage")
[13:20:28.502]                       }
[13:20:28.502]                       else if (inherits(cond, "warning")) {
[13:20:28.502]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.502]                         if (muffled) 
[13:20:28.502]                           invokeRestart("muffleWarning")
[13:20:28.502]                       }
[13:20:28.502]                       else if (inherits(cond, "condition")) {
[13:20:28.502]                         if (!is.null(pattern)) {
[13:20:28.502]                           computeRestarts <- base::computeRestarts
[13:20:28.502]                           grepl <- base::grepl
[13:20:28.502]                           restarts <- computeRestarts(cond)
[13:20:28.502]                           for (restart in restarts) {
[13:20:28.502]                             name <- restart$name
[13:20:28.502]                             if (is.null(name)) 
[13:20:28.502]                               next
[13:20:28.502]                             if (!grepl(pattern, name)) 
[13:20:28.502]                               next
[13:20:28.502]                             invokeRestart(restart)
[13:20:28.502]                             muffled <- TRUE
[13:20:28.502]                             break
[13:20:28.502]                           }
[13:20:28.502]                         }
[13:20:28.502]                       }
[13:20:28.502]                       invisible(muffled)
[13:20:28.502]                     }
[13:20:28.502]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.502]                   }
[13:20:28.502]                 }
[13:20:28.502]                 else {
[13:20:28.502]                   if (TRUE) {
[13:20:28.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.502]                     {
[13:20:28.502]                       inherits <- base::inherits
[13:20:28.502]                       invokeRestart <- base::invokeRestart
[13:20:28.502]                       is.null <- base::is.null
[13:20:28.502]                       muffled <- FALSE
[13:20:28.502]                       if (inherits(cond, "message")) {
[13:20:28.502]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.502]                         if (muffled) 
[13:20:28.502]                           invokeRestart("muffleMessage")
[13:20:28.502]                       }
[13:20:28.502]                       else if (inherits(cond, "warning")) {
[13:20:28.502]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.502]                         if (muffled) 
[13:20:28.502]                           invokeRestart("muffleWarning")
[13:20:28.502]                       }
[13:20:28.502]                       else if (inherits(cond, "condition")) {
[13:20:28.502]                         if (!is.null(pattern)) {
[13:20:28.502]                           computeRestarts <- base::computeRestarts
[13:20:28.502]                           grepl <- base::grepl
[13:20:28.502]                           restarts <- computeRestarts(cond)
[13:20:28.502]                           for (restart in restarts) {
[13:20:28.502]                             name <- restart$name
[13:20:28.502]                             if (is.null(name)) 
[13:20:28.502]                               next
[13:20:28.502]                             if (!grepl(pattern, name)) 
[13:20:28.502]                               next
[13:20:28.502]                             invokeRestart(restart)
[13:20:28.502]                             muffled <- TRUE
[13:20:28.502]                             break
[13:20:28.502]                           }
[13:20:28.502]                         }
[13:20:28.502]                       }
[13:20:28.502]                       invisible(muffled)
[13:20:28.502]                     }
[13:20:28.502]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.502]                   }
[13:20:28.502]                 }
[13:20:28.502]             }
[13:20:28.502]         }))
[13:20:28.502]     }, error = function(ex) {
[13:20:28.502]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.502]                 ...future.rng), started = ...future.startTime, 
[13:20:28.502]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.502]             version = "1.8"), class = "FutureResult")
[13:20:28.502]     }, finally = {
[13:20:28.502]         if (!identical(...future.workdir, getwd())) 
[13:20:28.502]             setwd(...future.workdir)
[13:20:28.502]         {
[13:20:28.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.502]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.502]             }
[13:20:28.502]             base::options(...future.oldOptions)
[13:20:28.502]             if (.Platform$OS.type == "windows") {
[13:20:28.502]                 old_names <- names(...future.oldEnvVars)
[13:20:28.502]                 envs <- base::Sys.getenv()
[13:20:28.502]                 names <- names(envs)
[13:20:28.502]                 common <- intersect(names, old_names)
[13:20:28.502]                 added <- setdiff(names, old_names)
[13:20:28.502]                 removed <- setdiff(old_names, names)
[13:20:28.502]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.502]                   envs[common]]
[13:20:28.502]                 NAMES <- toupper(changed)
[13:20:28.502]                 args <- list()
[13:20:28.502]                 for (kk in seq_along(NAMES)) {
[13:20:28.502]                   name <- changed[[kk]]
[13:20:28.502]                   NAME <- NAMES[[kk]]
[13:20:28.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.502]                     next
[13:20:28.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.502]                 }
[13:20:28.502]                 NAMES <- toupper(added)
[13:20:28.502]                 for (kk in seq_along(NAMES)) {
[13:20:28.502]                   name <- added[[kk]]
[13:20:28.502]                   NAME <- NAMES[[kk]]
[13:20:28.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.502]                     next
[13:20:28.502]                   args[[name]] <- ""
[13:20:28.502]                 }
[13:20:28.502]                 NAMES <- toupper(removed)
[13:20:28.502]                 for (kk in seq_along(NAMES)) {
[13:20:28.502]                   name <- removed[[kk]]
[13:20:28.502]                   NAME <- NAMES[[kk]]
[13:20:28.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.502]                     next
[13:20:28.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.502]                 }
[13:20:28.502]                 if (length(args) > 0) 
[13:20:28.502]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.502]             }
[13:20:28.502]             else {
[13:20:28.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.502]             }
[13:20:28.502]             {
[13:20:28.502]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.502]                   0L) {
[13:20:28.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.502]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.502]                   base::options(opts)
[13:20:28.502]                 }
[13:20:28.502]                 {
[13:20:28.502]                   {
[13:20:28.502]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.502]                     NULL
[13:20:28.502]                   }
[13:20:28.502]                   options(future.plan = NULL)
[13:20:28.502]                   if (is.na(NA_character_)) 
[13:20:28.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.502]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.502]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.502]                     envir = parent.frame()) 
[13:20:28.502]                   {
[13:20:28.502]                     if (is.function(workers)) 
[13:20:28.502]                       workers <- workers()
[13:20:28.502]                     workers <- structure(as.integer(workers), 
[13:20:28.502]                       class = class(workers))
[13:20:28.502]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.502]                       workers >= 1)
[13:20:28.502]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.502]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.502]                     }
[13:20:28.502]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.502]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.502]                       envir = envir)
[13:20:28.502]                     if (!future$lazy) 
[13:20:28.502]                       future <- run(future)
[13:20:28.502]                     invisible(future)
[13:20:28.502]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.502]                 }
[13:20:28.502]             }
[13:20:28.502]         }
[13:20:28.502]     })
[13:20:28.502]     if (TRUE) {
[13:20:28.502]         base::sink(type = "output", split = FALSE)
[13:20:28.502]         if (TRUE) {
[13:20:28.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.502]         }
[13:20:28.502]         else {
[13:20:28.502]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.502]         }
[13:20:28.502]         base::close(...future.stdout)
[13:20:28.502]         ...future.stdout <- NULL
[13:20:28.502]     }
[13:20:28.502]     ...future.result$conditions <- ...future.conditions
[13:20:28.502]     ...future.result$finished <- base::Sys.time()
[13:20:28.502]     ...future.result
[13:20:28.502] }
[13:20:28.505] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:28.516] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.516] - Validating connection of MultisessionFuture
[13:20:28.516] - received message: FutureResult
[13:20:28.516] - Received FutureResult
[13:20:28.516] - Erased future from FutureRegistry
[13:20:28.516] result() for ClusterFuture ...
[13:20:28.516] - result already collected: FutureResult
[13:20:28.516] result() for ClusterFuture ... done
[13:20:28.516] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:28.517] result() for ClusterFuture ...
[13:20:28.517] - result already collected: FutureResult
[13:20:28.517] result() for ClusterFuture ... done
[13:20:28.517] result() for ClusterFuture ...
[13:20:28.517] - result already collected: FutureResult
[13:20:28.517] result() for ClusterFuture ... done
[13:20:28.518] MultisessionFuture started
[13:20:28.518] - Launch lazy future ... done
[13:20:28.518] run() for ‘MultisessionFuture’ ... done
<environment: 0x55659cb692e8> 
<environment: 0x55659d955fb0> 
[13:20:28.529] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.530] - Validating connection of MultisessionFuture
[13:20:28.530] - received message: FutureResult
[13:20:28.530] - Received FutureResult
[13:20:28.530] - Erased future from FutureRegistry
[13:20:28.530] result() for ClusterFuture ...
[13:20:28.531] - result already collected: FutureResult
[13:20:28.531] result() for ClusterFuture ... done
[13:20:28.531] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:28.543] resolve() on environment ...
[13:20:28.543]  recursive: 0
[13:20:28.543]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:28.544] signalConditionsASAP(numeric, pos=1) ...
[13:20:28.544] - nx: 4
[13:20:28.544] - relay: TRUE
[13:20:28.544] - stdout: TRUE
[13:20:28.544] - signal: TRUE
[13:20:28.544] - resignal: FALSE
[13:20:28.544] - force: TRUE
[13:20:28.544] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.544] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.544]  - until=2
[13:20:28.544]  - relaying element #2
[13:20:28.545] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:28.545] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.545] signalConditionsASAP(NULL, pos=1) ... done
[13:20:28.545]  length: 3 (resolved future 1)
[13:20:28.545] Future #2
[13:20:28.545] result() for ClusterFuture ...
[13:20:28.545] - result already collected: FutureResult
[13:20:28.545] result() for ClusterFuture ... done
[13:20:28.545] result() for ClusterFuture ...
[13:20:28.546] - result already collected: FutureResult
[13:20:28.546] result() for ClusterFuture ... done
[13:20:28.546] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:28.546] - nx: 4
[13:20:28.546] - relay: TRUE
[13:20:28.546] - stdout: TRUE
[13:20:28.546] - signal: TRUE
[13:20:28.546] - resignal: FALSE
[13:20:28.546] - force: TRUE
[13:20:28.546] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:28.546] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.549]  - until=2
[13:20:28.549]  - relaying element #2
[13:20:28.550] result() for ClusterFuture ...
[13:20:28.550] - result already collected: FutureResult
[13:20:28.550] result() for ClusterFuture ... done
[13:20:28.550] result() for ClusterFuture ...
[13:20:28.550] - result already collected: FutureResult
[13:20:28.550] result() for ClusterFuture ... done
[13:20:28.550] result() for ClusterFuture ...
[13:20:28.550] - result already collected: FutureResult
[13:20:28.550] result() for ClusterFuture ... done
[13:20:28.550] result() for ClusterFuture ...
[13:20:28.551] - result already collected: FutureResult
[13:20:28.551] result() for ClusterFuture ... done
[13:20:28.551] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:28.551] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:28.551] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:28.551]  length: 2 (resolved future 2)
[13:20:28.551] Future #3
[13:20:28.551] result() for ClusterFuture ...
[13:20:28.551] - result already collected: FutureResult
[13:20:28.551] result() for ClusterFuture ... done
[13:20:28.552] result() for ClusterFuture ...
[13:20:28.552] - result already collected: FutureResult
[13:20:28.552] result() for ClusterFuture ... done
[13:20:28.552] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:28.552] - nx: 4
[13:20:28.552] - relay: TRUE
[13:20:28.552] - stdout: TRUE
[13:20:28.552] - signal: TRUE
[13:20:28.552] - resignal: FALSE
[13:20:28.552] - force: TRUE
[13:20:28.552] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:28.552] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:28.553]  - until=3
[13:20:28.553]  - relaying element #3
[13:20:28.553] result() for ClusterFuture ...
[13:20:28.553] - result already collected: FutureResult
[13:20:28.553] result() for ClusterFuture ... done
[13:20:28.553] result() for ClusterFuture ...
[13:20:28.553] - result already collected: FutureResult
[13:20:28.553] result() for ClusterFuture ... done
[13:20:28.553] result() for ClusterFuture ...
[13:20:28.553] - result already collected: FutureResult
[13:20:28.554] result() for ClusterFuture ... done
[13:20:28.554] result() for ClusterFuture ...
[13:20:28.554] - result already collected: FutureResult
[13:20:28.554] result() for ClusterFuture ... done
[13:20:28.554] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:28.554] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:28.554] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:28.554]  length: 1 (resolved future 3)
[13:20:28.575] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.576] - Validating connection of MultisessionFuture
[13:20:28.576] - received message: FutureResult
[13:20:28.576] - Received FutureResult
[13:20:28.576] - Erased future from FutureRegistry
[13:20:28.576] result() for ClusterFuture ...
[13:20:28.576] - result already collected: FutureResult
[13:20:28.576] result() for ClusterFuture ... done
[13:20:28.576] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:28.576] Future #4
[13:20:28.577] result() for ClusterFuture ...
[13:20:28.577] - result already collected: FutureResult
[13:20:28.577] result() for ClusterFuture ... done
[13:20:28.577] result() for ClusterFuture ...
[13:20:28.577] - result already collected: FutureResult
[13:20:28.577] result() for ClusterFuture ... done
[13:20:28.577] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:20:28.577] - nx: 4
[13:20:28.577] - relay: TRUE
[13:20:28.577] - stdout: TRUE
[13:20:28.577] - signal: TRUE
[13:20:28.578] - resignal: FALSE
[13:20:28.578] - force: TRUE
[13:20:28.578] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:28.578] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:28.578]  - until=4
[13:20:28.578]  - relaying element #4
[13:20:28.578] result() for ClusterFuture ...
[13:20:28.578] - result already collected: FutureResult
[13:20:28.578] result() for ClusterFuture ... done
[13:20:28.578] result() for ClusterFuture ...
[13:20:28.578] - result already collected: FutureResult
[13:20:28.579] result() for ClusterFuture ... done
[13:20:28.579] result() for ClusterFuture ...
[13:20:28.579] - result already collected: FutureResult
[13:20:28.579] result() for ClusterFuture ... done
[13:20:28.579] result() for ClusterFuture ...
[13:20:28.579] - result already collected: FutureResult
[13:20:28.579] result() for ClusterFuture ... done
[13:20:28.579] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.579] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:28.579] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:20:28.579]  length: 0 (resolved future 4)
[13:20:28.580] Relaying remaining futures
[13:20:28.580] signalConditionsASAP(NULL, pos=0) ...
[13:20:28.580] - nx: 4
[13:20:28.580] - relay: TRUE
[13:20:28.580] - stdout: TRUE
[13:20:28.580] - signal: TRUE
[13:20:28.580] - resignal: FALSE
[13:20:28.580] - force: TRUE
[13:20:28.580] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.580] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:28.580] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.581] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:28.581] signalConditionsASAP(NULL, pos=0) ... done
[13:20:28.581] resolve() on environment ... DONE
[13:20:28.581] result() for ClusterFuture ...
[13:20:28.581] - result already collected: FutureResult
[13:20:28.581] result() for ClusterFuture ... done
[13:20:28.581] result() for ClusterFuture ...
[13:20:28.581] - result already collected: FutureResult
[13:20:28.581] result() for ClusterFuture ... done
[13:20:28.581] result() for ClusterFuture ...
[13:20:28.581] - result already collected: FutureResult
[13:20:28.582] result() for ClusterFuture ... done
[13:20:28.582] result() for ClusterFuture ...
[13:20:28.582] - result already collected: FutureResult
[13:20:28.582] result() for ClusterFuture ... done
[13:20:28.582] result() for ClusterFuture ...
[13:20:28.582] - result already collected: FutureResult
[13:20:28.582] result() for ClusterFuture ... done
[13:20:28.582] result() for ClusterFuture ...
[13:20:28.582] - result already collected: FutureResult
[13:20:28.582] result() for ClusterFuture ... done
<environment: 0x55659daa08e8> 
Dimensions: c(2, 3)
[13:20:28.583] getGlobalsAndPackages() ...
[13:20:28.583] Searching for globals...
[13:20:28.583] 
[13:20:28.583] Searching for globals ... DONE
[13:20:28.583] - globals: [0] <none>
[13:20:28.583] getGlobalsAndPackages() ... DONE
[13:20:28.584] run() for ‘Future’ ...
[13:20:28.584] - state: ‘created’
[13:20:28.584] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.599] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.599] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.599]   - Field: ‘node’
[13:20:28.599]   - Field: ‘label’
[13:20:28.599]   - Field: ‘local’
[13:20:28.599]   - Field: ‘owner’
[13:20:28.599]   - Field: ‘envir’
[13:20:28.599]   - Field: ‘workers’
[13:20:28.600]   - Field: ‘packages’
[13:20:28.600]   - Field: ‘gc’
[13:20:28.600]   - Field: ‘conditions’
[13:20:28.600]   - Field: ‘persistent’
[13:20:28.600]   - Field: ‘expr’
[13:20:28.600]   - Field: ‘uuid’
[13:20:28.600]   - Field: ‘seed’
[13:20:28.600]   - Field: ‘version’
[13:20:28.600]   - Field: ‘result’
[13:20:28.600]   - Field: ‘asynchronous’
[13:20:28.601]   - Field: ‘calls’
[13:20:28.601]   - Field: ‘globals’
[13:20:28.601]   - Field: ‘stdout’
[13:20:28.601]   - Field: ‘earlySignal’
[13:20:28.601]   - Field: ‘lazy’
[13:20:28.601]   - Field: ‘state’
[13:20:28.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.601] - Launch lazy future ...
[13:20:28.601] Packages needed by the future expression (n = 0): <none>
[13:20:28.602] Packages needed by future strategies (n = 0): <none>
[13:20:28.602] {
[13:20:28.602]     {
[13:20:28.602]         {
[13:20:28.602]             ...future.startTime <- base::Sys.time()
[13:20:28.602]             {
[13:20:28.602]                 {
[13:20:28.602]                   {
[13:20:28.602]                     {
[13:20:28.602]                       base::local({
[13:20:28.602]                         has_future <- base::requireNamespace("future", 
[13:20:28.602]                           quietly = TRUE)
[13:20:28.602]                         if (has_future) {
[13:20:28.602]                           ns <- base::getNamespace("future")
[13:20:28.602]                           version <- ns[[".package"]][["version"]]
[13:20:28.602]                           if (is.null(version)) 
[13:20:28.602]                             version <- utils::packageVersion("future")
[13:20:28.602]                         }
[13:20:28.602]                         else {
[13:20:28.602]                           version <- NULL
[13:20:28.602]                         }
[13:20:28.602]                         if (!has_future || version < "1.8.0") {
[13:20:28.602]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.602]                             "", base::R.version$version.string), 
[13:20:28.602]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.602]                               "release", "version")], collapse = " "), 
[13:20:28.602]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.602]                             info)
[13:20:28.602]                           info <- base::paste(info, collapse = "; ")
[13:20:28.602]                           if (!has_future) {
[13:20:28.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.602]                               info)
[13:20:28.602]                           }
[13:20:28.602]                           else {
[13:20:28.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.602]                               info, version)
[13:20:28.602]                           }
[13:20:28.602]                           base::stop(msg)
[13:20:28.602]                         }
[13:20:28.602]                       })
[13:20:28.602]                     }
[13:20:28.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.602]                     base::options(mc.cores = 1L)
[13:20:28.602]                   }
[13:20:28.602]                   options(future.plan = NULL)
[13:20:28.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.602]                 }
[13:20:28.602]                 ...future.workdir <- getwd()
[13:20:28.602]             }
[13:20:28.602]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.602]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.602]         }
[13:20:28.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.602]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.602]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.602]             base::names(...future.oldOptions))
[13:20:28.602]     }
[13:20:28.602]     if (FALSE) {
[13:20:28.602]     }
[13:20:28.602]     else {
[13:20:28.602]         if (TRUE) {
[13:20:28.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.602]                 open = "w")
[13:20:28.602]         }
[13:20:28.602]         else {
[13:20:28.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.602]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.602]         }
[13:20:28.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.602]             base::sink(type = "output", split = FALSE)
[13:20:28.602]             base::close(...future.stdout)
[13:20:28.602]         }, add = TRUE)
[13:20:28.602]     }
[13:20:28.602]     ...future.frame <- base::sys.nframe()
[13:20:28.602]     ...future.conditions <- base::list()
[13:20:28.602]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.602]     if (FALSE) {
[13:20:28.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.602]     }
[13:20:28.602]     ...future.result <- base::tryCatch({
[13:20:28.602]         base::withCallingHandlers({
[13:20:28.602]             ...future.value <- base::withVisible(base::local({
[13:20:28.602]                 ...future.makeSendCondition <- local({
[13:20:28.602]                   sendCondition <- NULL
[13:20:28.602]                   function(frame = 1L) {
[13:20:28.602]                     if (is.function(sendCondition)) 
[13:20:28.602]                       return(sendCondition)
[13:20:28.602]                     ns <- getNamespace("parallel")
[13:20:28.602]                     if (exists("sendData", mode = "function", 
[13:20:28.602]                       envir = ns)) {
[13:20:28.602]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.602]                         envir = ns)
[13:20:28.602]                       envir <- sys.frame(frame)
[13:20:28.602]                       master <- NULL
[13:20:28.602]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.602]                         !identical(envir, emptyenv())) {
[13:20:28.602]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.602]                           inherits = FALSE)) {
[13:20:28.602]                           master <- get("master", mode = "list", 
[13:20:28.602]                             envir = envir, inherits = FALSE)
[13:20:28.602]                           if (inherits(master, c("SOCKnode", 
[13:20:28.602]                             "SOCK0node"))) {
[13:20:28.602]                             sendCondition <<- function(cond) {
[13:20:28.602]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.602]                                 success = TRUE)
[13:20:28.602]                               parallel_sendData(master, data)
[13:20:28.602]                             }
[13:20:28.602]                             return(sendCondition)
[13:20:28.602]                           }
[13:20:28.602]                         }
[13:20:28.602]                         frame <- frame + 1L
[13:20:28.602]                         envir <- sys.frame(frame)
[13:20:28.602]                       }
[13:20:28.602]                     }
[13:20:28.602]                     sendCondition <<- function(cond) NULL
[13:20:28.602]                   }
[13:20:28.602]                 })
[13:20:28.602]                 withCallingHandlers({
[13:20:28.602]                   2
[13:20:28.602]                 }, immediateCondition = function(cond) {
[13:20:28.602]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.602]                   sendCondition(cond)
[13:20:28.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.602]                   {
[13:20:28.602]                     inherits <- base::inherits
[13:20:28.602]                     invokeRestart <- base::invokeRestart
[13:20:28.602]                     is.null <- base::is.null
[13:20:28.602]                     muffled <- FALSE
[13:20:28.602]                     if (inherits(cond, "message")) {
[13:20:28.602]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.602]                       if (muffled) 
[13:20:28.602]                         invokeRestart("muffleMessage")
[13:20:28.602]                     }
[13:20:28.602]                     else if (inherits(cond, "warning")) {
[13:20:28.602]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.602]                       if (muffled) 
[13:20:28.602]                         invokeRestart("muffleWarning")
[13:20:28.602]                     }
[13:20:28.602]                     else if (inherits(cond, "condition")) {
[13:20:28.602]                       if (!is.null(pattern)) {
[13:20:28.602]                         computeRestarts <- base::computeRestarts
[13:20:28.602]                         grepl <- base::grepl
[13:20:28.602]                         restarts <- computeRestarts(cond)
[13:20:28.602]                         for (restart in restarts) {
[13:20:28.602]                           name <- restart$name
[13:20:28.602]                           if (is.null(name)) 
[13:20:28.602]                             next
[13:20:28.602]                           if (!grepl(pattern, name)) 
[13:20:28.602]                             next
[13:20:28.602]                           invokeRestart(restart)
[13:20:28.602]                           muffled <- TRUE
[13:20:28.602]                           break
[13:20:28.602]                         }
[13:20:28.602]                       }
[13:20:28.602]                     }
[13:20:28.602]                     invisible(muffled)
[13:20:28.602]                   }
[13:20:28.602]                   muffleCondition(cond)
[13:20:28.602]                 })
[13:20:28.602]             }))
[13:20:28.602]             future::FutureResult(value = ...future.value$value, 
[13:20:28.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.602]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.602]                     ...future.globalenv.names))
[13:20:28.602]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.602]         }, condition = base::local({
[13:20:28.602]             c <- base::c
[13:20:28.602]             inherits <- base::inherits
[13:20:28.602]             invokeRestart <- base::invokeRestart
[13:20:28.602]             length <- base::length
[13:20:28.602]             list <- base::list
[13:20:28.602]             seq.int <- base::seq.int
[13:20:28.602]             signalCondition <- base::signalCondition
[13:20:28.602]             sys.calls <- base::sys.calls
[13:20:28.602]             `[[` <- base::`[[`
[13:20:28.602]             `+` <- base::`+`
[13:20:28.602]             `<<-` <- base::`<<-`
[13:20:28.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.602]                   3L)]
[13:20:28.602]             }
[13:20:28.602]             function(cond) {
[13:20:28.602]                 is_error <- inherits(cond, "error")
[13:20:28.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.602]                   NULL)
[13:20:28.602]                 if (is_error) {
[13:20:28.602]                   sessionInformation <- function() {
[13:20:28.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.602]                       search = base::search(), system = base::Sys.info())
[13:20:28.602]                   }
[13:20:28.602]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.602]                     cond$call), session = sessionInformation(), 
[13:20:28.602]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.602]                   signalCondition(cond)
[13:20:28.602]                 }
[13:20:28.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.602]                 "immediateCondition"))) {
[13:20:28.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.602]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.602]                   if (TRUE && !signal) {
[13:20:28.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.602]                     {
[13:20:28.602]                       inherits <- base::inherits
[13:20:28.602]                       invokeRestart <- base::invokeRestart
[13:20:28.602]                       is.null <- base::is.null
[13:20:28.602]                       muffled <- FALSE
[13:20:28.602]                       if (inherits(cond, "message")) {
[13:20:28.602]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.602]                         if (muffled) 
[13:20:28.602]                           invokeRestart("muffleMessage")
[13:20:28.602]                       }
[13:20:28.602]                       else if (inherits(cond, "warning")) {
[13:20:28.602]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.602]                         if (muffled) 
[13:20:28.602]                           invokeRestart("muffleWarning")
[13:20:28.602]                       }
[13:20:28.602]                       else if (inherits(cond, "condition")) {
[13:20:28.602]                         if (!is.null(pattern)) {
[13:20:28.602]                           computeRestarts <- base::computeRestarts
[13:20:28.602]                           grepl <- base::grepl
[13:20:28.602]                           restarts <- computeRestarts(cond)
[13:20:28.602]                           for (restart in restarts) {
[13:20:28.602]                             name <- restart$name
[13:20:28.602]                             if (is.null(name)) 
[13:20:28.602]                               next
[13:20:28.602]                             if (!grepl(pattern, name)) 
[13:20:28.602]                               next
[13:20:28.602]                             invokeRestart(restart)
[13:20:28.602]                             muffled <- TRUE
[13:20:28.602]                             break
[13:20:28.602]                           }
[13:20:28.602]                         }
[13:20:28.602]                       }
[13:20:28.602]                       invisible(muffled)
[13:20:28.602]                     }
[13:20:28.602]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.602]                   }
[13:20:28.602]                 }
[13:20:28.602]                 else {
[13:20:28.602]                   if (TRUE) {
[13:20:28.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.602]                     {
[13:20:28.602]                       inherits <- base::inherits
[13:20:28.602]                       invokeRestart <- base::invokeRestart
[13:20:28.602]                       is.null <- base::is.null
[13:20:28.602]                       muffled <- FALSE
[13:20:28.602]                       if (inherits(cond, "message")) {
[13:20:28.602]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.602]                         if (muffled) 
[13:20:28.602]                           invokeRestart("muffleMessage")
[13:20:28.602]                       }
[13:20:28.602]                       else if (inherits(cond, "warning")) {
[13:20:28.602]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.602]                         if (muffled) 
[13:20:28.602]                           invokeRestart("muffleWarning")
[13:20:28.602]                       }
[13:20:28.602]                       else if (inherits(cond, "condition")) {
[13:20:28.602]                         if (!is.null(pattern)) {
[13:20:28.602]                           computeRestarts <- base::computeRestarts
[13:20:28.602]                           grepl <- base::grepl
[13:20:28.602]                           restarts <- computeRestarts(cond)
[13:20:28.602]                           for (restart in restarts) {
[13:20:28.602]                             name <- restart$name
[13:20:28.602]                             if (is.null(name)) 
[13:20:28.602]                               next
[13:20:28.602]                             if (!grepl(pattern, name)) 
[13:20:28.602]                               next
[13:20:28.602]                             invokeRestart(restart)
[13:20:28.602]                             muffled <- TRUE
[13:20:28.602]                             break
[13:20:28.602]                           }
[13:20:28.602]                         }
[13:20:28.602]                       }
[13:20:28.602]                       invisible(muffled)
[13:20:28.602]                     }
[13:20:28.602]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.602]                   }
[13:20:28.602]                 }
[13:20:28.602]             }
[13:20:28.602]         }))
[13:20:28.602]     }, error = function(ex) {
[13:20:28.602]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.602]                 ...future.rng), started = ...future.startTime, 
[13:20:28.602]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.602]             version = "1.8"), class = "FutureResult")
[13:20:28.602]     }, finally = {
[13:20:28.602]         if (!identical(...future.workdir, getwd())) 
[13:20:28.602]             setwd(...future.workdir)
[13:20:28.602]         {
[13:20:28.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.602]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.602]             }
[13:20:28.602]             base::options(...future.oldOptions)
[13:20:28.602]             if (.Platform$OS.type == "windows") {
[13:20:28.602]                 old_names <- names(...future.oldEnvVars)
[13:20:28.602]                 envs <- base::Sys.getenv()
[13:20:28.602]                 names <- names(envs)
[13:20:28.602]                 common <- intersect(names, old_names)
[13:20:28.602]                 added <- setdiff(names, old_names)
[13:20:28.602]                 removed <- setdiff(old_names, names)
[13:20:28.602]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.602]                   envs[common]]
[13:20:28.602]                 NAMES <- toupper(changed)
[13:20:28.602]                 args <- list()
[13:20:28.602]                 for (kk in seq_along(NAMES)) {
[13:20:28.602]                   name <- changed[[kk]]
[13:20:28.602]                   NAME <- NAMES[[kk]]
[13:20:28.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.602]                     next
[13:20:28.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.602]                 }
[13:20:28.602]                 NAMES <- toupper(added)
[13:20:28.602]                 for (kk in seq_along(NAMES)) {
[13:20:28.602]                   name <- added[[kk]]
[13:20:28.602]                   NAME <- NAMES[[kk]]
[13:20:28.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.602]                     next
[13:20:28.602]                   args[[name]] <- ""
[13:20:28.602]                 }
[13:20:28.602]                 NAMES <- toupper(removed)
[13:20:28.602]                 for (kk in seq_along(NAMES)) {
[13:20:28.602]                   name <- removed[[kk]]
[13:20:28.602]                   NAME <- NAMES[[kk]]
[13:20:28.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.602]                     next
[13:20:28.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.602]                 }
[13:20:28.602]                 if (length(args) > 0) 
[13:20:28.602]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.602]             }
[13:20:28.602]             else {
[13:20:28.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.602]             }
[13:20:28.602]             {
[13:20:28.602]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.602]                   0L) {
[13:20:28.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.602]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.602]                   base::options(opts)
[13:20:28.602]                 }
[13:20:28.602]                 {
[13:20:28.602]                   {
[13:20:28.602]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.602]                     NULL
[13:20:28.602]                   }
[13:20:28.602]                   options(future.plan = NULL)
[13:20:28.602]                   if (is.na(NA_character_)) 
[13:20:28.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.602]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.602]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.602]                     envir = parent.frame()) 
[13:20:28.602]                   {
[13:20:28.602]                     if (is.function(workers)) 
[13:20:28.602]                       workers <- workers()
[13:20:28.602]                     workers <- structure(as.integer(workers), 
[13:20:28.602]                       class = class(workers))
[13:20:28.602]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.602]                       workers >= 1)
[13:20:28.602]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.602]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.602]                     }
[13:20:28.602]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.602]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.602]                       envir = envir)
[13:20:28.602]                     if (!future$lazy) 
[13:20:28.602]                       future <- run(future)
[13:20:28.602]                     invisible(future)
[13:20:28.602]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.602]                 }
[13:20:28.602]             }
[13:20:28.602]         }
[13:20:28.602]     })
[13:20:28.602]     if (TRUE) {
[13:20:28.602]         base::sink(type = "output", split = FALSE)
[13:20:28.602]         if (TRUE) {
[13:20:28.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.602]         }
[13:20:28.602]         else {
[13:20:28.602]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.602]         }
[13:20:28.602]         base::close(...future.stdout)
[13:20:28.602]         ...future.stdout <- NULL
[13:20:28.602]     }
[13:20:28.602]     ...future.result$conditions <- ...future.conditions
[13:20:28.602]     ...future.result$finished <- base::Sys.time()
[13:20:28.602]     ...future.result
[13:20:28.602] }
[13:20:28.605] MultisessionFuture started
[13:20:28.605] - Launch lazy future ... done
[13:20:28.606] run() for ‘MultisessionFuture’ ... done
[13:20:28.606] getGlobalsAndPackages() ...
[13:20:28.606] Searching for globals...
[13:20:28.606] 
[13:20:28.606] Searching for globals ... DONE
[13:20:28.606] - globals: [0] <none>
[13:20:28.606] getGlobalsAndPackages() ... DONE
[13:20:28.607] run() for ‘Future’ ...
[13:20:28.607] - state: ‘created’
[13:20:28.607] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.622] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.622]   - Field: ‘node’
[13:20:28.622]   - Field: ‘label’
[13:20:28.623]   - Field: ‘local’
[13:20:28.623]   - Field: ‘owner’
[13:20:28.623]   - Field: ‘envir’
[13:20:28.623]   - Field: ‘workers’
[13:20:28.623]   - Field: ‘packages’
[13:20:28.623]   - Field: ‘gc’
[13:20:28.623]   - Field: ‘conditions’
[13:20:28.623]   - Field: ‘persistent’
[13:20:28.623]   - Field: ‘expr’
[13:20:28.623]   - Field: ‘uuid’
[13:20:28.623]   - Field: ‘seed’
[13:20:28.624]   - Field: ‘version’
[13:20:28.624]   - Field: ‘result’
[13:20:28.624]   - Field: ‘asynchronous’
[13:20:28.624]   - Field: ‘calls’
[13:20:28.624]   - Field: ‘globals’
[13:20:28.624]   - Field: ‘stdout’
[13:20:28.624]   - Field: ‘earlySignal’
[13:20:28.624]   - Field: ‘lazy’
[13:20:28.624]   - Field: ‘state’
[13:20:28.624] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.625] - Launch lazy future ...
[13:20:28.625] Packages needed by the future expression (n = 0): <none>
[13:20:28.625] Packages needed by future strategies (n = 0): <none>
[13:20:28.625] {
[13:20:28.625]     {
[13:20:28.625]         {
[13:20:28.625]             ...future.startTime <- base::Sys.time()
[13:20:28.625]             {
[13:20:28.625]                 {
[13:20:28.625]                   {
[13:20:28.625]                     {
[13:20:28.625]                       base::local({
[13:20:28.625]                         has_future <- base::requireNamespace("future", 
[13:20:28.625]                           quietly = TRUE)
[13:20:28.625]                         if (has_future) {
[13:20:28.625]                           ns <- base::getNamespace("future")
[13:20:28.625]                           version <- ns[[".package"]][["version"]]
[13:20:28.625]                           if (is.null(version)) 
[13:20:28.625]                             version <- utils::packageVersion("future")
[13:20:28.625]                         }
[13:20:28.625]                         else {
[13:20:28.625]                           version <- NULL
[13:20:28.625]                         }
[13:20:28.625]                         if (!has_future || version < "1.8.0") {
[13:20:28.625]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.625]                             "", base::R.version$version.string), 
[13:20:28.625]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.625]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.625]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.625]                               "release", "version")], collapse = " "), 
[13:20:28.625]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.625]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.625]                             info)
[13:20:28.625]                           info <- base::paste(info, collapse = "; ")
[13:20:28.625]                           if (!has_future) {
[13:20:28.625]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.625]                               info)
[13:20:28.625]                           }
[13:20:28.625]                           else {
[13:20:28.625]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.625]                               info, version)
[13:20:28.625]                           }
[13:20:28.625]                           base::stop(msg)
[13:20:28.625]                         }
[13:20:28.625]                       })
[13:20:28.625]                     }
[13:20:28.625]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.625]                     base::options(mc.cores = 1L)
[13:20:28.625]                   }
[13:20:28.625]                   options(future.plan = NULL)
[13:20:28.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.625]                 }
[13:20:28.625]                 ...future.workdir <- getwd()
[13:20:28.625]             }
[13:20:28.625]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.625]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.625]         }
[13:20:28.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.625]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.625]             base::names(...future.oldOptions))
[13:20:28.625]     }
[13:20:28.625]     if (FALSE) {
[13:20:28.625]     }
[13:20:28.625]     else {
[13:20:28.625]         if (TRUE) {
[13:20:28.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.625]                 open = "w")
[13:20:28.625]         }
[13:20:28.625]         else {
[13:20:28.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.625]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.625]         }
[13:20:28.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.625]             base::sink(type = "output", split = FALSE)
[13:20:28.625]             base::close(...future.stdout)
[13:20:28.625]         }, add = TRUE)
[13:20:28.625]     }
[13:20:28.625]     ...future.frame <- base::sys.nframe()
[13:20:28.625]     ...future.conditions <- base::list()
[13:20:28.625]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.625]     if (FALSE) {
[13:20:28.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.625]     }
[13:20:28.625]     ...future.result <- base::tryCatch({
[13:20:28.625]         base::withCallingHandlers({
[13:20:28.625]             ...future.value <- base::withVisible(base::local({
[13:20:28.625]                 ...future.makeSendCondition <- local({
[13:20:28.625]                   sendCondition <- NULL
[13:20:28.625]                   function(frame = 1L) {
[13:20:28.625]                     if (is.function(sendCondition)) 
[13:20:28.625]                       return(sendCondition)
[13:20:28.625]                     ns <- getNamespace("parallel")
[13:20:28.625]                     if (exists("sendData", mode = "function", 
[13:20:28.625]                       envir = ns)) {
[13:20:28.625]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.625]                         envir = ns)
[13:20:28.625]                       envir <- sys.frame(frame)
[13:20:28.625]                       master <- NULL
[13:20:28.625]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.625]                         !identical(envir, emptyenv())) {
[13:20:28.625]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.625]                           inherits = FALSE)) {
[13:20:28.625]                           master <- get("master", mode = "list", 
[13:20:28.625]                             envir = envir, inherits = FALSE)
[13:20:28.625]                           if (inherits(master, c("SOCKnode", 
[13:20:28.625]                             "SOCK0node"))) {
[13:20:28.625]                             sendCondition <<- function(cond) {
[13:20:28.625]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.625]                                 success = TRUE)
[13:20:28.625]                               parallel_sendData(master, data)
[13:20:28.625]                             }
[13:20:28.625]                             return(sendCondition)
[13:20:28.625]                           }
[13:20:28.625]                         }
[13:20:28.625]                         frame <- frame + 1L
[13:20:28.625]                         envir <- sys.frame(frame)
[13:20:28.625]                       }
[13:20:28.625]                     }
[13:20:28.625]                     sendCondition <<- function(cond) NULL
[13:20:28.625]                   }
[13:20:28.625]                 })
[13:20:28.625]                 withCallingHandlers({
[13:20:28.625]                   NULL
[13:20:28.625]                 }, immediateCondition = function(cond) {
[13:20:28.625]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.625]                   sendCondition(cond)
[13:20:28.625]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.625]                   {
[13:20:28.625]                     inherits <- base::inherits
[13:20:28.625]                     invokeRestart <- base::invokeRestart
[13:20:28.625]                     is.null <- base::is.null
[13:20:28.625]                     muffled <- FALSE
[13:20:28.625]                     if (inherits(cond, "message")) {
[13:20:28.625]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.625]                       if (muffled) 
[13:20:28.625]                         invokeRestart("muffleMessage")
[13:20:28.625]                     }
[13:20:28.625]                     else if (inherits(cond, "warning")) {
[13:20:28.625]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.625]                       if (muffled) 
[13:20:28.625]                         invokeRestart("muffleWarning")
[13:20:28.625]                     }
[13:20:28.625]                     else if (inherits(cond, "condition")) {
[13:20:28.625]                       if (!is.null(pattern)) {
[13:20:28.625]                         computeRestarts <- base::computeRestarts
[13:20:28.625]                         grepl <- base::grepl
[13:20:28.625]                         restarts <- computeRestarts(cond)
[13:20:28.625]                         for (restart in restarts) {
[13:20:28.625]                           name <- restart$name
[13:20:28.625]                           if (is.null(name)) 
[13:20:28.625]                             next
[13:20:28.625]                           if (!grepl(pattern, name)) 
[13:20:28.625]                             next
[13:20:28.625]                           invokeRestart(restart)
[13:20:28.625]                           muffled <- TRUE
[13:20:28.625]                           break
[13:20:28.625]                         }
[13:20:28.625]                       }
[13:20:28.625]                     }
[13:20:28.625]                     invisible(muffled)
[13:20:28.625]                   }
[13:20:28.625]                   muffleCondition(cond)
[13:20:28.625]                 })
[13:20:28.625]             }))
[13:20:28.625]             future::FutureResult(value = ...future.value$value, 
[13:20:28.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.625]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.625]                     ...future.globalenv.names))
[13:20:28.625]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.625]         }, condition = base::local({
[13:20:28.625]             c <- base::c
[13:20:28.625]             inherits <- base::inherits
[13:20:28.625]             invokeRestart <- base::invokeRestart
[13:20:28.625]             length <- base::length
[13:20:28.625]             list <- base::list
[13:20:28.625]             seq.int <- base::seq.int
[13:20:28.625]             signalCondition <- base::signalCondition
[13:20:28.625]             sys.calls <- base::sys.calls
[13:20:28.625]             `[[` <- base::`[[`
[13:20:28.625]             `+` <- base::`+`
[13:20:28.625]             `<<-` <- base::`<<-`
[13:20:28.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.625]                   3L)]
[13:20:28.625]             }
[13:20:28.625]             function(cond) {
[13:20:28.625]                 is_error <- inherits(cond, "error")
[13:20:28.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.625]                   NULL)
[13:20:28.625]                 if (is_error) {
[13:20:28.625]                   sessionInformation <- function() {
[13:20:28.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.625]                       search = base::search(), system = base::Sys.info())
[13:20:28.625]                   }
[13:20:28.625]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.625]                     cond$call), session = sessionInformation(), 
[13:20:28.625]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.625]                   signalCondition(cond)
[13:20:28.625]                 }
[13:20:28.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.625]                 "immediateCondition"))) {
[13:20:28.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.625]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.625]                   if (TRUE && !signal) {
[13:20:28.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.625]                     {
[13:20:28.625]                       inherits <- base::inherits
[13:20:28.625]                       invokeRestart <- base::invokeRestart
[13:20:28.625]                       is.null <- base::is.null
[13:20:28.625]                       muffled <- FALSE
[13:20:28.625]                       if (inherits(cond, "message")) {
[13:20:28.625]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.625]                         if (muffled) 
[13:20:28.625]                           invokeRestart("muffleMessage")
[13:20:28.625]                       }
[13:20:28.625]                       else if (inherits(cond, "warning")) {
[13:20:28.625]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.625]                         if (muffled) 
[13:20:28.625]                           invokeRestart("muffleWarning")
[13:20:28.625]                       }
[13:20:28.625]                       else if (inherits(cond, "condition")) {
[13:20:28.625]                         if (!is.null(pattern)) {
[13:20:28.625]                           computeRestarts <- base::computeRestarts
[13:20:28.625]                           grepl <- base::grepl
[13:20:28.625]                           restarts <- computeRestarts(cond)
[13:20:28.625]                           for (restart in restarts) {
[13:20:28.625]                             name <- restart$name
[13:20:28.625]                             if (is.null(name)) 
[13:20:28.625]                               next
[13:20:28.625]                             if (!grepl(pattern, name)) 
[13:20:28.625]                               next
[13:20:28.625]                             invokeRestart(restart)
[13:20:28.625]                             muffled <- TRUE
[13:20:28.625]                             break
[13:20:28.625]                           }
[13:20:28.625]                         }
[13:20:28.625]                       }
[13:20:28.625]                       invisible(muffled)
[13:20:28.625]                     }
[13:20:28.625]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.625]                   }
[13:20:28.625]                 }
[13:20:28.625]                 else {
[13:20:28.625]                   if (TRUE) {
[13:20:28.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.625]                     {
[13:20:28.625]                       inherits <- base::inherits
[13:20:28.625]                       invokeRestart <- base::invokeRestart
[13:20:28.625]                       is.null <- base::is.null
[13:20:28.625]                       muffled <- FALSE
[13:20:28.625]                       if (inherits(cond, "message")) {
[13:20:28.625]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.625]                         if (muffled) 
[13:20:28.625]                           invokeRestart("muffleMessage")
[13:20:28.625]                       }
[13:20:28.625]                       else if (inherits(cond, "warning")) {
[13:20:28.625]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.625]                         if (muffled) 
[13:20:28.625]                           invokeRestart("muffleWarning")
[13:20:28.625]                       }
[13:20:28.625]                       else if (inherits(cond, "condition")) {
[13:20:28.625]                         if (!is.null(pattern)) {
[13:20:28.625]                           computeRestarts <- base::computeRestarts
[13:20:28.625]                           grepl <- base::grepl
[13:20:28.625]                           restarts <- computeRestarts(cond)
[13:20:28.625]                           for (restart in restarts) {
[13:20:28.625]                             name <- restart$name
[13:20:28.625]                             if (is.null(name)) 
[13:20:28.625]                               next
[13:20:28.625]                             if (!grepl(pattern, name)) 
[13:20:28.625]                               next
[13:20:28.625]                             invokeRestart(restart)
[13:20:28.625]                             muffled <- TRUE
[13:20:28.625]                             break
[13:20:28.625]                           }
[13:20:28.625]                         }
[13:20:28.625]                       }
[13:20:28.625]                       invisible(muffled)
[13:20:28.625]                     }
[13:20:28.625]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.625]                   }
[13:20:28.625]                 }
[13:20:28.625]             }
[13:20:28.625]         }))
[13:20:28.625]     }, error = function(ex) {
[13:20:28.625]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.625]                 ...future.rng), started = ...future.startTime, 
[13:20:28.625]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.625]             version = "1.8"), class = "FutureResult")
[13:20:28.625]     }, finally = {
[13:20:28.625]         if (!identical(...future.workdir, getwd())) 
[13:20:28.625]             setwd(...future.workdir)
[13:20:28.625]         {
[13:20:28.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.625]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.625]             }
[13:20:28.625]             base::options(...future.oldOptions)
[13:20:28.625]             if (.Platform$OS.type == "windows") {
[13:20:28.625]                 old_names <- names(...future.oldEnvVars)
[13:20:28.625]                 envs <- base::Sys.getenv()
[13:20:28.625]                 names <- names(envs)
[13:20:28.625]                 common <- intersect(names, old_names)
[13:20:28.625]                 added <- setdiff(names, old_names)
[13:20:28.625]                 removed <- setdiff(old_names, names)
[13:20:28.625]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.625]                   envs[common]]
[13:20:28.625]                 NAMES <- toupper(changed)
[13:20:28.625]                 args <- list()
[13:20:28.625]                 for (kk in seq_along(NAMES)) {
[13:20:28.625]                   name <- changed[[kk]]
[13:20:28.625]                   NAME <- NAMES[[kk]]
[13:20:28.625]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.625]                     next
[13:20:28.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.625]                 }
[13:20:28.625]                 NAMES <- toupper(added)
[13:20:28.625]                 for (kk in seq_along(NAMES)) {
[13:20:28.625]                   name <- added[[kk]]
[13:20:28.625]                   NAME <- NAMES[[kk]]
[13:20:28.625]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.625]                     next
[13:20:28.625]                   args[[name]] <- ""
[13:20:28.625]                 }
[13:20:28.625]                 NAMES <- toupper(removed)
[13:20:28.625]                 for (kk in seq_along(NAMES)) {
[13:20:28.625]                   name <- removed[[kk]]
[13:20:28.625]                   NAME <- NAMES[[kk]]
[13:20:28.625]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.625]                     next
[13:20:28.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.625]                 }
[13:20:28.625]                 if (length(args) > 0) 
[13:20:28.625]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.625]             }
[13:20:28.625]             else {
[13:20:28.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.625]             }
[13:20:28.625]             {
[13:20:28.625]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.625]                   0L) {
[13:20:28.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.625]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.625]                   base::options(opts)
[13:20:28.625]                 }
[13:20:28.625]                 {
[13:20:28.625]                   {
[13:20:28.625]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.625]                     NULL
[13:20:28.625]                   }
[13:20:28.625]                   options(future.plan = NULL)
[13:20:28.625]                   if (is.na(NA_character_)) 
[13:20:28.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.625]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.625]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.625]                     envir = parent.frame()) 
[13:20:28.625]                   {
[13:20:28.625]                     if (is.function(workers)) 
[13:20:28.625]                       workers <- workers()
[13:20:28.625]                     workers <- structure(as.integer(workers), 
[13:20:28.625]                       class = class(workers))
[13:20:28.625]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.625]                       workers >= 1)
[13:20:28.625]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.625]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.625]                     }
[13:20:28.625]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.625]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.625]                       envir = envir)
[13:20:28.625]                     if (!future$lazy) 
[13:20:28.625]                       future <- run(future)
[13:20:28.625]                     invisible(future)
[13:20:28.625]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.625]                 }
[13:20:28.625]             }
[13:20:28.625]         }
[13:20:28.625]     })
[13:20:28.625]     if (TRUE) {
[13:20:28.625]         base::sink(type = "output", split = FALSE)
[13:20:28.625]         if (TRUE) {
[13:20:28.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.625]         }
[13:20:28.625]         else {
[13:20:28.625]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.625]         }
[13:20:28.625]         base::close(...future.stdout)
[13:20:28.625]         ...future.stdout <- NULL
[13:20:28.625]     }
[13:20:28.625]     ...future.result$conditions <- ...future.conditions
[13:20:28.625]     ...future.result$finished <- base::Sys.time()
[13:20:28.625]     ...future.result
[13:20:28.625] }
[13:20:28.628] MultisessionFuture started
[13:20:28.629] - Launch lazy future ... done
[13:20:28.629] run() for ‘MultisessionFuture’ ... done
[13:20:28.629] getGlobalsAndPackages() ...
[13:20:28.629] Searching for globals...
[13:20:28.630] - globals found: [1] ‘{’
[13:20:28.630] Searching for globals ... DONE
[13:20:28.630] Resolving globals: FALSE
[13:20:28.630] 
[13:20:28.630] 
[13:20:28.630] getGlobalsAndPackages() ... DONE
[13:20:28.631] run() for ‘Future’ ...
[13:20:28.631] - state: ‘created’
[13:20:28.631] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.645] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.645]   - Field: ‘node’
[13:20:28.645]   - Field: ‘label’
[13:20:28.645]   - Field: ‘local’
[13:20:28.646]   - Field: ‘owner’
[13:20:28.646]   - Field: ‘envir’
[13:20:28.646]   - Field: ‘workers’
[13:20:28.646]   - Field: ‘packages’
[13:20:28.646]   - Field: ‘gc’
[13:20:28.646]   - Field: ‘conditions’
[13:20:28.646]   - Field: ‘persistent’
[13:20:28.646]   - Field: ‘expr’
[13:20:28.646]   - Field: ‘uuid’
[13:20:28.646]   - Field: ‘seed’
[13:20:28.646]   - Field: ‘version’
[13:20:28.647]   - Field: ‘result’
[13:20:28.647]   - Field: ‘asynchronous’
[13:20:28.647]   - Field: ‘calls’
[13:20:28.647]   - Field: ‘globals’
[13:20:28.647]   - Field: ‘stdout’
[13:20:28.647]   - Field: ‘earlySignal’
[13:20:28.647]   - Field: ‘lazy’
[13:20:28.647]   - Field: ‘state’
[13:20:28.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.647] - Launch lazy future ...
[13:20:28.648] Packages needed by the future expression (n = 0): <none>
[13:20:28.648] Packages needed by future strategies (n = 0): <none>
[13:20:28.648] {
[13:20:28.648]     {
[13:20:28.648]         {
[13:20:28.648]             ...future.startTime <- base::Sys.time()
[13:20:28.648]             {
[13:20:28.648]                 {
[13:20:28.648]                   {
[13:20:28.648]                     {
[13:20:28.648]                       base::local({
[13:20:28.648]                         has_future <- base::requireNamespace("future", 
[13:20:28.648]                           quietly = TRUE)
[13:20:28.648]                         if (has_future) {
[13:20:28.648]                           ns <- base::getNamespace("future")
[13:20:28.648]                           version <- ns[[".package"]][["version"]]
[13:20:28.648]                           if (is.null(version)) 
[13:20:28.648]                             version <- utils::packageVersion("future")
[13:20:28.648]                         }
[13:20:28.648]                         else {
[13:20:28.648]                           version <- NULL
[13:20:28.648]                         }
[13:20:28.648]                         if (!has_future || version < "1.8.0") {
[13:20:28.648]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.648]                             "", base::R.version$version.string), 
[13:20:28.648]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.648]                               "release", "version")], collapse = " "), 
[13:20:28.648]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.648]                             info)
[13:20:28.648]                           info <- base::paste(info, collapse = "; ")
[13:20:28.648]                           if (!has_future) {
[13:20:28.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.648]                               info)
[13:20:28.648]                           }
[13:20:28.648]                           else {
[13:20:28.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.648]                               info, version)
[13:20:28.648]                           }
[13:20:28.648]                           base::stop(msg)
[13:20:28.648]                         }
[13:20:28.648]                       })
[13:20:28.648]                     }
[13:20:28.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.648]                     base::options(mc.cores = 1L)
[13:20:28.648]                   }
[13:20:28.648]                   options(future.plan = NULL)
[13:20:28.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.648]                 }
[13:20:28.648]                 ...future.workdir <- getwd()
[13:20:28.648]             }
[13:20:28.648]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.648]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.648]         }
[13:20:28.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.648]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.648]             base::names(...future.oldOptions))
[13:20:28.648]     }
[13:20:28.648]     if (FALSE) {
[13:20:28.648]     }
[13:20:28.648]     else {
[13:20:28.648]         if (TRUE) {
[13:20:28.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.648]                 open = "w")
[13:20:28.648]         }
[13:20:28.648]         else {
[13:20:28.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.648]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.648]         }
[13:20:28.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.648]             base::sink(type = "output", split = FALSE)
[13:20:28.648]             base::close(...future.stdout)
[13:20:28.648]         }, add = TRUE)
[13:20:28.648]     }
[13:20:28.648]     ...future.frame <- base::sys.nframe()
[13:20:28.648]     ...future.conditions <- base::list()
[13:20:28.648]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.648]     if (FALSE) {
[13:20:28.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.648]     }
[13:20:28.648]     ...future.result <- base::tryCatch({
[13:20:28.648]         base::withCallingHandlers({
[13:20:28.648]             ...future.value <- base::withVisible(base::local({
[13:20:28.648]                 ...future.makeSendCondition <- local({
[13:20:28.648]                   sendCondition <- NULL
[13:20:28.648]                   function(frame = 1L) {
[13:20:28.648]                     if (is.function(sendCondition)) 
[13:20:28.648]                       return(sendCondition)
[13:20:28.648]                     ns <- getNamespace("parallel")
[13:20:28.648]                     if (exists("sendData", mode = "function", 
[13:20:28.648]                       envir = ns)) {
[13:20:28.648]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.648]                         envir = ns)
[13:20:28.648]                       envir <- sys.frame(frame)
[13:20:28.648]                       master <- NULL
[13:20:28.648]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.648]                         !identical(envir, emptyenv())) {
[13:20:28.648]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.648]                           inherits = FALSE)) {
[13:20:28.648]                           master <- get("master", mode = "list", 
[13:20:28.648]                             envir = envir, inherits = FALSE)
[13:20:28.648]                           if (inherits(master, c("SOCKnode", 
[13:20:28.648]                             "SOCK0node"))) {
[13:20:28.648]                             sendCondition <<- function(cond) {
[13:20:28.648]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.648]                                 success = TRUE)
[13:20:28.648]                               parallel_sendData(master, data)
[13:20:28.648]                             }
[13:20:28.648]                             return(sendCondition)
[13:20:28.648]                           }
[13:20:28.648]                         }
[13:20:28.648]                         frame <- frame + 1L
[13:20:28.648]                         envir <- sys.frame(frame)
[13:20:28.648]                       }
[13:20:28.648]                     }
[13:20:28.648]                     sendCondition <<- function(cond) NULL
[13:20:28.648]                   }
[13:20:28.648]                 })
[13:20:28.648]                 withCallingHandlers({
[13:20:28.648]                   {
[13:20:28.648]                     4
[13:20:28.648]                   }
[13:20:28.648]                 }, immediateCondition = function(cond) {
[13:20:28.648]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.648]                   sendCondition(cond)
[13:20:28.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.648]                   {
[13:20:28.648]                     inherits <- base::inherits
[13:20:28.648]                     invokeRestart <- base::invokeRestart
[13:20:28.648]                     is.null <- base::is.null
[13:20:28.648]                     muffled <- FALSE
[13:20:28.648]                     if (inherits(cond, "message")) {
[13:20:28.648]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.648]                       if (muffled) 
[13:20:28.648]                         invokeRestart("muffleMessage")
[13:20:28.648]                     }
[13:20:28.648]                     else if (inherits(cond, "warning")) {
[13:20:28.648]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.648]                       if (muffled) 
[13:20:28.648]                         invokeRestart("muffleWarning")
[13:20:28.648]                     }
[13:20:28.648]                     else if (inherits(cond, "condition")) {
[13:20:28.648]                       if (!is.null(pattern)) {
[13:20:28.648]                         computeRestarts <- base::computeRestarts
[13:20:28.648]                         grepl <- base::grepl
[13:20:28.648]                         restarts <- computeRestarts(cond)
[13:20:28.648]                         for (restart in restarts) {
[13:20:28.648]                           name <- restart$name
[13:20:28.648]                           if (is.null(name)) 
[13:20:28.648]                             next
[13:20:28.648]                           if (!grepl(pattern, name)) 
[13:20:28.648]                             next
[13:20:28.648]                           invokeRestart(restart)
[13:20:28.648]                           muffled <- TRUE
[13:20:28.648]                           break
[13:20:28.648]                         }
[13:20:28.648]                       }
[13:20:28.648]                     }
[13:20:28.648]                     invisible(muffled)
[13:20:28.648]                   }
[13:20:28.648]                   muffleCondition(cond)
[13:20:28.648]                 })
[13:20:28.648]             }))
[13:20:28.648]             future::FutureResult(value = ...future.value$value, 
[13:20:28.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.648]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.648]                     ...future.globalenv.names))
[13:20:28.648]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.648]         }, condition = base::local({
[13:20:28.648]             c <- base::c
[13:20:28.648]             inherits <- base::inherits
[13:20:28.648]             invokeRestart <- base::invokeRestart
[13:20:28.648]             length <- base::length
[13:20:28.648]             list <- base::list
[13:20:28.648]             seq.int <- base::seq.int
[13:20:28.648]             signalCondition <- base::signalCondition
[13:20:28.648]             sys.calls <- base::sys.calls
[13:20:28.648]             `[[` <- base::`[[`
[13:20:28.648]             `+` <- base::`+`
[13:20:28.648]             `<<-` <- base::`<<-`
[13:20:28.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.648]                   3L)]
[13:20:28.648]             }
[13:20:28.648]             function(cond) {
[13:20:28.648]                 is_error <- inherits(cond, "error")
[13:20:28.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.648]                   NULL)
[13:20:28.648]                 if (is_error) {
[13:20:28.648]                   sessionInformation <- function() {
[13:20:28.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.648]                       search = base::search(), system = base::Sys.info())
[13:20:28.648]                   }
[13:20:28.648]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.648]                     cond$call), session = sessionInformation(), 
[13:20:28.648]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.648]                   signalCondition(cond)
[13:20:28.648]                 }
[13:20:28.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.648]                 "immediateCondition"))) {
[13:20:28.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.648]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.648]                   if (TRUE && !signal) {
[13:20:28.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.648]                     {
[13:20:28.648]                       inherits <- base::inherits
[13:20:28.648]                       invokeRestart <- base::invokeRestart
[13:20:28.648]                       is.null <- base::is.null
[13:20:28.648]                       muffled <- FALSE
[13:20:28.648]                       if (inherits(cond, "message")) {
[13:20:28.648]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.648]                         if (muffled) 
[13:20:28.648]                           invokeRestart("muffleMessage")
[13:20:28.648]                       }
[13:20:28.648]                       else if (inherits(cond, "warning")) {
[13:20:28.648]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.648]                         if (muffled) 
[13:20:28.648]                           invokeRestart("muffleWarning")
[13:20:28.648]                       }
[13:20:28.648]                       else if (inherits(cond, "condition")) {
[13:20:28.648]                         if (!is.null(pattern)) {
[13:20:28.648]                           computeRestarts <- base::computeRestarts
[13:20:28.648]                           grepl <- base::grepl
[13:20:28.648]                           restarts <- computeRestarts(cond)
[13:20:28.648]                           for (restart in restarts) {
[13:20:28.648]                             name <- restart$name
[13:20:28.648]                             if (is.null(name)) 
[13:20:28.648]                               next
[13:20:28.648]                             if (!grepl(pattern, name)) 
[13:20:28.648]                               next
[13:20:28.648]                             invokeRestart(restart)
[13:20:28.648]                             muffled <- TRUE
[13:20:28.648]                             break
[13:20:28.648]                           }
[13:20:28.648]                         }
[13:20:28.648]                       }
[13:20:28.648]                       invisible(muffled)
[13:20:28.648]                     }
[13:20:28.648]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.648]                   }
[13:20:28.648]                 }
[13:20:28.648]                 else {
[13:20:28.648]                   if (TRUE) {
[13:20:28.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.648]                     {
[13:20:28.648]                       inherits <- base::inherits
[13:20:28.648]                       invokeRestart <- base::invokeRestart
[13:20:28.648]                       is.null <- base::is.null
[13:20:28.648]                       muffled <- FALSE
[13:20:28.648]                       if (inherits(cond, "message")) {
[13:20:28.648]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.648]                         if (muffled) 
[13:20:28.648]                           invokeRestart("muffleMessage")
[13:20:28.648]                       }
[13:20:28.648]                       else if (inherits(cond, "warning")) {
[13:20:28.648]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.648]                         if (muffled) 
[13:20:28.648]                           invokeRestart("muffleWarning")
[13:20:28.648]                       }
[13:20:28.648]                       else if (inherits(cond, "condition")) {
[13:20:28.648]                         if (!is.null(pattern)) {
[13:20:28.648]                           computeRestarts <- base::computeRestarts
[13:20:28.648]                           grepl <- base::grepl
[13:20:28.648]                           restarts <- computeRestarts(cond)
[13:20:28.648]                           for (restart in restarts) {
[13:20:28.648]                             name <- restart$name
[13:20:28.648]                             if (is.null(name)) 
[13:20:28.648]                               next
[13:20:28.648]                             if (!grepl(pattern, name)) 
[13:20:28.648]                               next
[13:20:28.648]                             invokeRestart(restart)
[13:20:28.648]                             muffled <- TRUE
[13:20:28.648]                             break
[13:20:28.648]                           }
[13:20:28.648]                         }
[13:20:28.648]                       }
[13:20:28.648]                       invisible(muffled)
[13:20:28.648]                     }
[13:20:28.648]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.648]                   }
[13:20:28.648]                 }
[13:20:28.648]             }
[13:20:28.648]         }))
[13:20:28.648]     }, error = function(ex) {
[13:20:28.648]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.648]                 ...future.rng), started = ...future.startTime, 
[13:20:28.648]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.648]             version = "1.8"), class = "FutureResult")
[13:20:28.648]     }, finally = {
[13:20:28.648]         if (!identical(...future.workdir, getwd())) 
[13:20:28.648]             setwd(...future.workdir)
[13:20:28.648]         {
[13:20:28.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.648]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.648]             }
[13:20:28.648]             base::options(...future.oldOptions)
[13:20:28.648]             if (.Platform$OS.type == "windows") {
[13:20:28.648]                 old_names <- names(...future.oldEnvVars)
[13:20:28.648]                 envs <- base::Sys.getenv()
[13:20:28.648]                 names <- names(envs)
[13:20:28.648]                 common <- intersect(names, old_names)
[13:20:28.648]                 added <- setdiff(names, old_names)
[13:20:28.648]                 removed <- setdiff(old_names, names)
[13:20:28.648]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.648]                   envs[common]]
[13:20:28.648]                 NAMES <- toupper(changed)
[13:20:28.648]                 args <- list()
[13:20:28.648]                 for (kk in seq_along(NAMES)) {
[13:20:28.648]                   name <- changed[[kk]]
[13:20:28.648]                   NAME <- NAMES[[kk]]
[13:20:28.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.648]                     next
[13:20:28.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.648]                 }
[13:20:28.648]                 NAMES <- toupper(added)
[13:20:28.648]                 for (kk in seq_along(NAMES)) {
[13:20:28.648]                   name <- added[[kk]]
[13:20:28.648]                   NAME <- NAMES[[kk]]
[13:20:28.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.648]                     next
[13:20:28.648]                   args[[name]] <- ""
[13:20:28.648]                 }
[13:20:28.648]                 NAMES <- toupper(removed)
[13:20:28.648]                 for (kk in seq_along(NAMES)) {
[13:20:28.648]                   name <- removed[[kk]]
[13:20:28.648]                   NAME <- NAMES[[kk]]
[13:20:28.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.648]                     next
[13:20:28.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.648]                 }
[13:20:28.648]                 if (length(args) > 0) 
[13:20:28.648]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.648]             }
[13:20:28.648]             else {
[13:20:28.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.648]             }
[13:20:28.648]             {
[13:20:28.648]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.648]                   0L) {
[13:20:28.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.648]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.648]                   base::options(opts)
[13:20:28.648]                 }
[13:20:28.648]                 {
[13:20:28.648]                   {
[13:20:28.648]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.648]                     NULL
[13:20:28.648]                   }
[13:20:28.648]                   options(future.plan = NULL)
[13:20:28.648]                   if (is.na(NA_character_)) 
[13:20:28.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.648]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.648]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.648]                     envir = parent.frame()) 
[13:20:28.648]                   {
[13:20:28.648]                     if (is.function(workers)) 
[13:20:28.648]                       workers <- workers()
[13:20:28.648]                     workers <- structure(as.integer(workers), 
[13:20:28.648]                       class = class(workers))
[13:20:28.648]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.648]                       workers >= 1)
[13:20:28.648]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.648]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.648]                     }
[13:20:28.648]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.648]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.648]                       envir = envir)
[13:20:28.648]                     if (!future$lazy) 
[13:20:28.648]                       future <- run(future)
[13:20:28.648]                     invisible(future)
[13:20:28.648]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.648]                 }
[13:20:28.648]             }
[13:20:28.648]         }
[13:20:28.648]     })
[13:20:28.648]     if (TRUE) {
[13:20:28.648]         base::sink(type = "output", split = FALSE)
[13:20:28.648]         if (TRUE) {
[13:20:28.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.648]         }
[13:20:28.648]         else {
[13:20:28.648]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.648]         }
[13:20:28.648]         base::close(...future.stdout)
[13:20:28.648]         ...future.stdout <- NULL
[13:20:28.648]     }
[13:20:28.648]     ...future.result$conditions <- ...future.conditions
[13:20:28.648]     ...future.result$finished <- base::Sys.time()
[13:20:28.648]     ...future.result
[13:20:28.648] }
[13:20:28.650] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:28.661] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.661] - Validating connection of MultisessionFuture
[13:20:28.662] - received message: FutureResult
[13:20:28.662] - Received FutureResult
[13:20:28.662] - Erased future from FutureRegistry
[13:20:28.662] result() for ClusterFuture ...
[13:20:28.662] - result already collected: FutureResult
[13:20:28.662] result() for ClusterFuture ... done
[13:20:28.662] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:28.662] result() for ClusterFuture ...
[13:20:28.662] - result already collected: FutureResult
[13:20:28.663] result() for ClusterFuture ... done
[13:20:28.663] result() for ClusterFuture ...
[13:20:28.663] - result already collected: FutureResult
[13:20:28.663] result() for ClusterFuture ... done
[13:20:28.664] MultisessionFuture started
[13:20:28.664] - Launch lazy future ... done
[13:20:28.664] run() for ‘MultisessionFuture’ ... done
<environment: 0x55659b9a18d0> 
<environment: 0x55659cf1e738> 
[13:20:28.674] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.674] - Validating connection of MultisessionFuture
[13:20:28.674] - received message: FutureResult
[13:20:28.674] - Received FutureResult
[13:20:28.674] - Erased future from FutureRegistry
[13:20:28.674] result() for ClusterFuture ...
[13:20:28.675] - result already collected: FutureResult
[13:20:28.675] result() for ClusterFuture ... done
[13:20:28.675] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:28.687] resolve() on environment ...
[13:20:28.687]  recursive: 0
[13:20:28.687]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:28.688] signalConditionsASAP(numeric, pos=1) ...
[13:20:28.688] - nx: 4
[13:20:28.688] - relay: TRUE
[13:20:28.688] - stdout: TRUE
[13:20:28.688] - signal: TRUE
[13:20:28.688] - resignal: FALSE
[13:20:28.688] - force: TRUE
[13:20:28.688] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.688] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.688]  - until=2
[13:20:28.688]  - relaying element #2
[13:20:28.689] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:28.689] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.689] signalConditionsASAP(NULL, pos=1) ... done
[13:20:28.689]  length: 3 (resolved future 1)
[13:20:28.689] Future #2
[13:20:28.689] result() for ClusterFuture ...
[13:20:28.689] - result already collected: FutureResult
[13:20:28.689] result() for ClusterFuture ... done
[13:20:28.689] result() for ClusterFuture ...
[13:20:28.689] - result already collected: FutureResult
[13:20:28.689] result() for ClusterFuture ... done
[13:20:28.690] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:28.690] - nx: 4
[13:20:28.690] - relay: TRUE
[13:20:28.690] - stdout: TRUE
[13:20:28.690] - signal: TRUE
[13:20:28.690] - resignal: FALSE
[13:20:28.690] - force: TRUE
[13:20:28.690] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:28.690] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.690]  - until=2
[13:20:28.690]  - relaying element #2
[13:20:28.691] result() for ClusterFuture ...
[13:20:28.691] - result already collected: FutureResult
[13:20:28.691] result() for ClusterFuture ... done
[13:20:28.691] result() for ClusterFuture ...
[13:20:28.691] - result already collected: FutureResult
[13:20:28.691] result() for ClusterFuture ... done
[13:20:28.691] result() for ClusterFuture ...
[13:20:28.691] - result already collected: FutureResult
[13:20:28.691] result() for ClusterFuture ... done
[13:20:28.691] result() for ClusterFuture ...
[13:20:28.692] - result already collected: FutureResult
[13:20:28.692] result() for ClusterFuture ... done
[13:20:28.692] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:28.692] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:28.692] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:28.692]  length: 2 (resolved future 2)
[13:20:28.692] Future #3
[13:20:28.692] result() for ClusterFuture ...
[13:20:28.692] - result already collected: FutureResult
[13:20:28.692] result() for ClusterFuture ... done
[13:20:28.692] result() for ClusterFuture ...
[13:20:28.693] - result already collected: FutureResult
[13:20:28.693] result() for ClusterFuture ... done
[13:20:28.693] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:28.693] - nx: 4
[13:20:28.693] - relay: TRUE
[13:20:28.693] - stdout: TRUE
[13:20:28.693] - signal: TRUE
[13:20:28.693] - resignal: FALSE
[13:20:28.693] - force: TRUE
[13:20:28.693] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:28.693] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:28.694]  - until=3
[13:20:28.694]  - relaying element #3
[13:20:28.694] result() for ClusterFuture ...
[13:20:28.694] - result already collected: FutureResult
[13:20:28.694] result() for ClusterFuture ... done
[13:20:28.694] result() for ClusterFuture ...
[13:20:28.694] - result already collected: FutureResult
[13:20:28.694] result() for ClusterFuture ... done
[13:20:28.694] result() for ClusterFuture ...
[13:20:28.694] - result already collected: FutureResult
[13:20:28.694] result() for ClusterFuture ... done
[13:20:28.695] result() for ClusterFuture ...
[13:20:28.695] - result already collected: FutureResult
[13:20:28.695] result() for ClusterFuture ... done
[13:20:28.695] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:28.695] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:28.695] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:28.695]  length: 1 (resolved future 3)
[13:20:28.716] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.716] - Validating connection of MultisessionFuture
[13:20:28.717] - received message: FutureResult
[13:20:28.717] - Received FutureResult
[13:20:28.717] - Erased future from FutureRegistry
[13:20:28.717] result() for ClusterFuture ...
[13:20:28.717] - result already collected: FutureResult
[13:20:28.717] result() for ClusterFuture ... done
[13:20:28.717] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:28.717] Future #4
[13:20:28.718] result() for ClusterFuture ...
[13:20:28.718] - result already collected: FutureResult
[13:20:28.718] result() for ClusterFuture ... done
[13:20:28.718] result() for ClusterFuture ...
[13:20:28.718] - result already collected: FutureResult
[13:20:28.718] result() for ClusterFuture ... done
[13:20:28.718] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:20:28.718] - nx: 4
[13:20:28.718] - relay: TRUE
[13:20:28.718] - stdout: TRUE
[13:20:28.718] - signal: TRUE
[13:20:28.719] - resignal: FALSE
[13:20:28.719] - force: TRUE
[13:20:28.719] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:28.719] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:28.719]  - until=4
[13:20:28.719]  - relaying element #4
[13:20:28.719] result() for ClusterFuture ...
[13:20:28.719] - result already collected: FutureResult
[13:20:28.719] result() for ClusterFuture ... done
[13:20:28.719] result() for ClusterFuture ...
[13:20:28.719] - result already collected: FutureResult
[13:20:28.719] result() for ClusterFuture ... done
[13:20:28.720] result() for ClusterFuture ...
[13:20:28.720] - result already collected: FutureResult
[13:20:28.720] result() for ClusterFuture ... done
[13:20:28.720] result() for ClusterFuture ...
[13:20:28.720] - result already collected: FutureResult
[13:20:28.720] result() for ClusterFuture ... done
[13:20:28.720] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.720] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:28.720] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:20:28.720]  length: 0 (resolved future 4)
[13:20:28.720] Relaying remaining futures
[13:20:28.721] signalConditionsASAP(NULL, pos=0) ...
[13:20:28.721] - nx: 4
[13:20:28.721] - relay: TRUE
[13:20:28.721] - stdout: TRUE
[13:20:28.721] - signal: TRUE
[13:20:28.721] - resignal: FALSE
[13:20:28.721] - force: TRUE
[13:20:28.721] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.721] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:28.721] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.722] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:28.722] signalConditionsASAP(NULL, pos=0) ... done
[13:20:28.722] resolve() on environment ... DONE
[13:20:28.722] result() for ClusterFuture ...
[13:20:28.722] - result already collected: FutureResult
[13:20:28.722] result() for ClusterFuture ... done
[13:20:28.722] result() for ClusterFuture ...
[13:20:28.722] - result already collected: FutureResult
[13:20:28.722] result() for ClusterFuture ... done
[13:20:28.722] result() for ClusterFuture ...
[13:20:28.722] - result already collected: FutureResult
[13:20:28.723] result() for ClusterFuture ... done
[13:20:28.723] result() for ClusterFuture ...
[13:20:28.723] - result already collected: FutureResult
[13:20:28.723] result() for ClusterFuture ... done
[13:20:28.723] result() for ClusterFuture ...
[13:20:28.723] - result already collected: FutureResult
[13:20:28.723] result() for ClusterFuture ... done
[13:20:28.723] result() for ClusterFuture ...
[13:20:28.723] - result already collected: FutureResult
[13:20:28.723] result() for ClusterFuture ... done
<environment: 0x55659d115480> 
Dimensions: c(2, 3, 1)
[13:20:28.724] getGlobalsAndPackages() ...
[13:20:28.724] Searching for globals...
[13:20:28.724] 
[13:20:28.724] Searching for globals ... DONE
[13:20:28.724] - globals: [0] <none>
[13:20:28.725] getGlobalsAndPackages() ... DONE
[13:20:28.725] run() for ‘Future’ ...
[13:20:28.725] - state: ‘created’
[13:20:28.725] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.740] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.740]   - Field: ‘node’
[13:20:28.740]   - Field: ‘label’
[13:20:28.740]   - Field: ‘local’
[13:20:28.740]   - Field: ‘owner’
[13:20:28.740]   - Field: ‘envir’
[13:20:28.740]   - Field: ‘workers’
[13:20:28.740]   - Field: ‘packages’
[13:20:28.740]   - Field: ‘gc’
[13:20:28.741]   - Field: ‘conditions’
[13:20:28.741]   - Field: ‘persistent’
[13:20:28.741]   - Field: ‘expr’
[13:20:28.741]   - Field: ‘uuid’
[13:20:28.741]   - Field: ‘seed’
[13:20:28.741]   - Field: ‘version’
[13:20:28.741]   - Field: ‘result’
[13:20:28.741]   - Field: ‘asynchronous’
[13:20:28.741]   - Field: ‘calls’
[13:20:28.741]   - Field: ‘globals’
[13:20:28.742]   - Field: ‘stdout’
[13:20:28.742]   - Field: ‘earlySignal’
[13:20:28.742]   - Field: ‘lazy’
[13:20:28.744]   - Field: ‘state’
[13:20:28.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.745] - Launch lazy future ...
[13:20:28.745] Packages needed by the future expression (n = 0): <none>
[13:20:28.745] Packages needed by future strategies (n = 0): <none>
[13:20:28.746] {
[13:20:28.746]     {
[13:20:28.746]         {
[13:20:28.746]             ...future.startTime <- base::Sys.time()
[13:20:28.746]             {
[13:20:28.746]                 {
[13:20:28.746]                   {
[13:20:28.746]                     {
[13:20:28.746]                       base::local({
[13:20:28.746]                         has_future <- base::requireNamespace("future", 
[13:20:28.746]                           quietly = TRUE)
[13:20:28.746]                         if (has_future) {
[13:20:28.746]                           ns <- base::getNamespace("future")
[13:20:28.746]                           version <- ns[[".package"]][["version"]]
[13:20:28.746]                           if (is.null(version)) 
[13:20:28.746]                             version <- utils::packageVersion("future")
[13:20:28.746]                         }
[13:20:28.746]                         else {
[13:20:28.746]                           version <- NULL
[13:20:28.746]                         }
[13:20:28.746]                         if (!has_future || version < "1.8.0") {
[13:20:28.746]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.746]                             "", base::R.version$version.string), 
[13:20:28.746]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.746]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.746]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.746]                               "release", "version")], collapse = " "), 
[13:20:28.746]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.746]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.746]                             info)
[13:20:28.746]                           info <- base::paste(info, collapse = "; ")
[13:20:28.746]                           if (!has_future) {
[13:20:28.746]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.746]                               info)
[13:20:28.746]                           }
[13:20:28.746]                           else {
[13:20:28.746]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.746]                               info, version)
[13:20:28.746]                           }
[13:20:28.746]                           base::stop(msg)
[13:20:28.746]                         }
[13:20:28.746]                       })
[13:20:28.746]                     }
[13:20:28.746]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.746]                     base::options(mc.cores = 1L)
[13:20:28.746]                   }
[13:20:28.746]                   options(future.plan = NULL)
[13:20:28.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.746]                 }
[13:20:28.746]                 ...future.workdir <- getwd()
[13:20:28.746]             }
[13:20:28.746]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.746]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.746]         }
[13:20:28.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.746]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.746]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.746]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.746]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.746]             base::names(...future.oldOptions))
[13:20:28.746]     }
[13:20:28.746]     if (FALSE) {
[13:20:28.746]     }
[13:20:28.746]     else {
[13:20:28.746]         if (TRUE) {
[13:20:28.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.746]                 open = "w")
[13:20:28.746]         }
[13:20:28.746]         else {
[13:20:28.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.746]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.746]         }
[13:20:28.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.746]             base::sink(type = "output", split = FALSE)
[13:20:28.746]             base::close(...future.stdout)
[13:20:28.746]         }, add = TRUE)
[13:20:28.746]     }
[13:20:28.746]     ...future.frame <- base::sys.nframe()
[13:20:28.746]     ...future.conditions <- base::list()
[13:20:28.746]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.746]     if (FALSE) {
[13:20:28.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.746]     }
[13:20:28.746]     ...future.result <- base::tryCatch({
[13:20:28.746]         base::withCallingHandlers({
[13:20:28.746]             ...future.value <- base::withVisible(base::local({
[13:20:28.746]                 ...future.makeSendCondition <- local({
[13:20:28.746]                   sendCondition <- NULL
[13:20:28.746]                   function(frame = 1L) {
[13:20:28.746]                     if (is.function(sendCondition)) 
[13:20:28.746]                       return(sendCondition)
[13:20:28.746]                     ns <- getNamespace("parallel")
[13:20:28.746]                     if (exists("sendData", mode = "function", 
[13:20:28.746]                       envir = ns)) {
[13:20:28.746]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.746]                         envir = ns)
[13:20:28.746]                       envir <- sys.frame(frame)
[13:20:28.746]                       master <- NULL
[13:20:28.746]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.746]                         !identical(envir, emptyenv())) {
[13:20:28.746]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.746]                           inherits = FALSE)) {
[13:20:28.746]                           master <- get("master", mode = "list", 
[13:20:28.746]                             envir = envir, inherits = FALSE)
[13:20:28.746]                           if (inherits(master, c("SOCKnode", 
[13:20:28.746]                             "SOCK0node"))) {
[13:20:28.746]                             sendCondition <<- function(cond) {
[13:20:28.746]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.746]                                 success = TRUE)
[13:20:28.746]                               parallel_sendData(master, data)
[13:20:28.746]                             }
[13:20:28.746]                             return(sendCondition)
[13:20:28.746]                           }
[13:20:28.746]                         }
[13:20:28.746]                         frame <- frame + 1L
[13:20:28.746]                         envir <- sys.frame(frame)
[13:20:28.746]                       }
[13:20:28.746]                     }
[13:20:28.746]                     sendCondition <<- function(cond) NULL
[13:20:28.746]                   }
[13:20:28.746]                 })
[13:20:28.746]                 withCallingHandlers({
[13:20:28.746]                   2
[13:20:28.746]                 }, immediateCondition = function(cond) {
[13:20:28.746]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.746]                   sendCondition(cond)
[13:20:28.746]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.746]                   {
[13:20:28.746]                     inherits <- base::inherits
[13:20:28.746]                     invokeRestart <- base::invokeRestart
[13:20:28.746]                     is.null <- base::is.null
[13:20:28.746]                     muffled <- FALSE
[13:20:28.746]                     if (inherits(cond, "message")) {
[13:20:28.746]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.746]                       if (muffled) 
[13:20:28.746]                         invokeRestart("muffleMessage")
[13:20:28.746]                     }
[13:20:28.746]                     else if (inherits(cond, "warning")) {
[13:20:28.746]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.746]                       if (muffled) 
[13:20:28.746]                         invokeRestart("muffleWarning")
[13:20:28.746]                     }
[13:20:28.746]                     else if (inherits(cond, "condition")) {
[13:20:28.746]                       if (!is.null(pattern)) {
[13:20:28.746]                         computeRestarts <- base::computeRestarts
[13:20:28.746]                         grepl <- base::grepl
[13:20:28.746]                         restarts <- computeRestarts(cond)
[13:20:28.746]                         for (restart in restarts) {
[13:20:28.746]                           name <- restart$name
[13:20:28.746]                           if (is.null(name)) 
[13:20:28.746]                             next
[13:20:28.746]                           if (!grepl(pattern, name)) 
[13:20:28.746]                             next
[13:20:28.746]                           invokeRestart(restart)
[13:20:28.746]                           muffled <- TRUE
[13:20:28.746]                           break
[13:20:28.746]                         }
[13:20:28.746]                       }
[13:20:28.746]                     }
[13:20:28.746]                     invisible(muffled)
[13:20:28.746]                   }
[13:20:28.746]                   muffleCondition(cond)
[13:20:28.746]                 })
[13:20:28.746]             }))
[13:20:28.746]             future::FutureResult(value = ...future.value$value, 
[13:20:28.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.746]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.746]                     ...future.globalenv.names))
[13:20:28.746]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.746]         }, condition = base::local({
[13:20:28.746]             c <- base::c
[13:20:28.746]             inherits <- base::inherits
[13:20:28.746]             invokeRestart <- base::invokeRestart
[13:20:28.746]             length <- base::length
[13:20:28.746]             list <- base::list
[13:20:28.746]             seq.int <- base::seq.int
[13:20:28.746]             signalCondition <- base::signalCondition
[13:20:28.746]             sys.calls <- base::sys.calls
[13:20:28.746]             `[[` <- base::`[[`
[13:20:28.746]             `+` <- base::`+`
[13:20:28.746]             `<<-` <- base::`<<-`
[13:20:28.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.746]                   3L)]
[13:20:28.746]             }
[13:20:28.746]             function(cond) {
[13:20:28.746]                 is_error <- inherits(cond, "error")
[13:20:28.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.746]                   NULL)
[13:20:28.746]                 if (is_error) {
[13:20:28.746]                   sessionInformation <- function() {
[13:20:28.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.746]                       search = base::search(), system = base::Sys.info())
[13:20:28.746]                   }
[13:20:28.746]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.746]                     cond$call), session = sessionInformation(), 
[13:20:28.746]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.746]                   signalCondition(cond)
[13:20:28.746]                 }
[13:20:28.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.746]                 "immediateCondition"))) {
[13:20:28.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.746]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.746]                   if (TRUE && !signal) {
[13:20:28.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.746]                     {
[13:20:28.746]                       inherits <- base::inherits
[13:20:28.746]                       invokeRestart <- base::invokeRestart
[13:20:28.746]                       is.null <- base::is.null
[13:20:28.746]                       muffled <- FALSE
[13:20:28.746]                       if (inherits(cond, "message")) {
[13:20:28.746]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.746]                         if (muffled) 
[13:20:28.746]                           invokeRestart("muffleMessage")
[13:20:28.746]                       }
[13:20:28.746]                       else if (inherits(cond, "warning")) {
[13:20:28.746]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.746]                         if (muffled) 
[13:20:28.746]                           invokeRestart("muffleWarning")
[13:20:28.746]                       }
[13:20:28.746]                       else if (inherits(cond, "condition")) {
[13:20:28.746]                         if (!is.null(pattern)) {
[13:20:28.746]                           computeRestarts <- base::computeRestarts
[13:20:28.746]                           grepl <- base::grepl
[13:20:28.746]                           restarts <- computeRestarts(cond)
[13:20:28.746]                           for (restart in restarts) {
[13:20:28.746]                             name <- restart$name
[13:20:28.746]                             if (is.null(name)) 
[13:20:28.746]                               next
[13:20:28.746]                             if (!grepl(pattern, name)) 
[13:20:28.746]                               next
[13:20:28.746]                             invokeRestart(restart)
[13:20:28.746]                             muffled <- TRUE
[13:20:28.746]                             break
[13:20:28.746]                           }
[13:20:28.746]                         }
[13:20:28.746]                       }
[13:20:28.746]                       invisible(muffled)
[13:20:28.746]                     }
[13:20:28.746]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.746]                   }
[13:20:28.746]                 }
[13:20:28.746]                 else {
[13:20:28.746]                   if (TRUE) {
[13:20:28.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.746]                     {
[13:20:28.746]                       inherits <- base::inherits
[13:20:28.746]                       invokeRestart <- base::invokeRestart
[13:20:28.746]                       is.null <- base::is.null
[13:20:28.746]                       muffled <- FALSE
[13:20:28.746]                       if (inherits(cond, "message")) {
[13:20:28.746]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.746]                         if (muffled) 
[13:20:28.746]                           invokeRestart("muffleMessage")
[13:20:28.746]                       }
[13:20:28.746]                       else if (inherits(cond, "warning")) {
[13:20:28.746]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.746]                         if (muffled) 
[13:20:28.746]                           invokeRestart("muffleWarning")
[13:20:28.746]                       }
[13:20:28.746]                       else if (inherits(cond, "condition")) {
[13:20:28.746]                         if (!is.null(pattern)) {
[13:20:28.746]                           computeRestarts <- base::computeRestarts
[13:20:28.746]                           grepl <- base::grepl
[13:20:28.746]                           restarts <- computeRestarts(cond)
[13:20:28.746]                           for (restart in restarts) {
[13:20:28.746]                             name <- restart$name
[13:20:28.746]                             if (is.null(name)) 
[13:20:28.746]                               next
[13:20:28.746]                             if (!grepl(pattern, name)) 
[13:20:28.746]                               next
[13:20:28.746]                             invokeRestart(restart)
[13:20:28.746]                             muffled <- TRUE
[13:20:28.746]                             break
[13:20:28.746]                           }
[13:20:28.746]                         }
[13:20:28.746]                       }
[13:20:28.746]                       invisible(muffled)
[13:20:28.746]                     }
[13:20:28.746]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.746]                   }
[13:20:28.746]                 }
[13:20:28.746]             }
[13:20:28.746]         }))
[13:20:28.746]     }, error = function(ex) {
[13:20:28.746]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.746]                 ...future.rng), started = ...future.startTime, 
[13:20:28.746]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.746]             version = "1.8"), class = "FutureResult")
[13:20:28.746]     }, finally = {
[13:20:28.746]         if (!identical(...future.workdir, getwd())) 
[13:20:28.746]             setwd(...future.workdir)
[13:20:28.746]         {
[13:20:28.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.746]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.746]             }
[13:20:28.746]             base::options(...future.oldOptions)
[13:20:28.746]             if (.Platform$OS.type == "windows") {
[13:20:28.746]                 old_names <- names(...future.oldEnvVars)
[13:20:28.746]                 envs <- base::Sys.getenv()
[13:20:28.746]                 names <- names(envs)
[13:20:28.746]                 common <- intersect(names, old_names)
[13:20:28.746]                 added <- setdiff(names, old_names)
[13:20:28.746]                 removed <- setdiff(old_names, names)
[13:20:28.746]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.746]                   envs[common]]
[13:20:28.746]                 NAMES <- toupper(changed)
[13:20:28.746]                 args <- list()
[13:20:28.746]                 for (kk in seq_along(NAMES)) {
[13:20:28.746]                   name <- changed[[kk]]
[13:20:28.746]                   NAME <- NAMES[[kk]]
[13:20:28.746]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.746]                     next
[13:20:28.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.746]                 }
[13:20:28.746]                 NAMES <- toupper(added)
[13:20:28.746]                 for (kk in seq_along(NAMES)) {
[13:20:28.746]                   name <- added[[kk]]
[13:20:28.746]                   NAME <- NAMES[[kk]]
[13:20:28.746]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.746]                     next
[13:20:28.746]                   args[[name]] <- ""
[13:20:28.746]                 }
[13:20:28.746]                 NAMES <- toupper(removed)
[13:20:28.746]                 for (kk in seq_along(NAMES)) {
[13:20:28.746]                   name <- removed[[kk]]
[13:20:28.746]                   NAME <- NAMES[[kk]]
[13:20:28.746]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.746]                     next
[13:20:28.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.746]                 }
[13:20:28.746]                 if (length(args) > 0) 
[13:20:28.746]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.746]             }
[13:20:28.746]             else {
[13:20:28.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.746]             }
[13:20:28.746]             {
[13:20:28.746]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.746]                   0L) {
[13:20:28.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.746]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.746]                   base::options(opts)
[13:20:28.746]                 }
[13:20:28.746]                 {
[13:20:28.746]                   {
[13:20:28.746]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.746]                     NULL
[13:20:28.746]                   }
[13:20:28.746]                   options(future.plan = NULL)
[13:20:28.746]                   if (is.na(NA_character_)) 
[13:20:28.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.746]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.746]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.746]                     envir = parent.frame()) 
[13:20:28.746]                   {
[13:20:28.746]                     if (is.function(workers)) 
[13:20:28.746]                       workers <- workers()
[13:20:28.746]                     workers <- structure(as.integer(workers), 
[13:20:28.746]                       class = class(workers))
[13:20:28.746]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.746]                       workers >= 1)
[13:20:28.746]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.746]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.746]                     }
[13:20:28.746]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.746]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.746]                       envir = envir)
[13:20:28.746]                     if (!future$lazy) 
[13:20:28.746]                       future <- run(future)
[13:20:28.746]                     invisible(future)
[13:20:28.746]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.746]                 }
[13:20:28.746]             }
[13:20:28.746]         }
[13:20:28.746]     })
[13:20:28.746]     if (TRUE) {
[13:20:28.746]         base::sink(type = "output", split = FALSE)
[13:20:28.746]         if (TRUE) {
[13:20:28.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.746]         }
[13:20:28.746]         else {
[13:20:28.746]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.746]         }
[13:20:28.746]         base::close(...future.stdout)
[13:20:28.746]         ...future.stdout <- NULL
[13:20:28.746]     }
[13:20:28.746]     ...future.result$conditions <- ...future.conditions
[13:20:28.746]     ...future.result$finished <- base::Sys.time()
[13:20:28.746]     ...future.result
[13:20:28.746] }
[13:20:28.749] MultisessionFuture started
[13:20:28.749] - Launch lazy future ... done
[13:20:28.749] run() for ‘MultisessionFuture’ ... done
[13:20:28.749] getGlobalsAndPackages() ...
[13:20:28.749] Searching for globals...
[13:20:28.750] 
[13:20:28.750] Searching for globals ... DONE
[13:20:28.750] - globals: [0] <none>
[13:20:28.750] getGlobalsAndPackages() ... DONE
[13:20:28.750] run() for ‘Future’ ...
[13:20:28.750] - state: ‘created’
[13:20:28.750] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.765] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.765] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.765]   - Field: ‘node’
[13:20:28.765]   - Field: ‘label’
[13:20:28.765]   - Field: ‘local’
[13:20:28.765]   - Field: ‘owner’
[13:20:28.765]   - Field: ‘envir’
[13:20:28.766]   - Field: ‘workers’
[13:20:28.766]   - Field: ‘packages’
[13:20:28.766]   - Field: ‘gc’
[13:20:28.766]   - Field: ‘conditions’
[13:20:28.766]   - Field: ‘persistent’
[13:20:28.766]   - Field: ‘expr’
[13:20:28.766]   - Field: ‘uuid’
[13:20:28.766]   - Field: ‘seed’
[13:20:28.766]   - Field: ‘version’
[13:20:28.766]   - Field: ‘result’
[13:20:28.767]   - Field: ‘asynchronous’
[13:20:28.767]   - Field: ‘calls’
[13:20:28.767]   - Field: ‘globals’
[13:20:28.767]   - Field: ‘stdout’
[13:20:28.767]   - Field: ‘earlySignal’
[13:20:28.767]   - Field: ‘lazy’
[13:20:28.767]   - Field: ‘state’
[13:20:28.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.767] - Launch lazy future ...
[13:20:28.768] Packages needed by the future expression (n = 0): <none>
[13:20:28.768] Packages needed by future strategies (n = 0): <none>
[13:20:28.768] {
[13:20:28.768]     {
[13:20:28.768]         {
[13:20:28.768]             ...future.startTime <- base::Sys.time()
[13:20:28.768]             {
[13:20:28.768]                 {
[13:20:28.768]                   {
[13:20:28.768]                     {
[13:20:28.768]                       base::local({
[13:20:28.768]                         has_future <- base::requireNamespace("future", 
[13:20:28.768]                           quietly = TRUE)
[13:20:28.768]                         if (has_future) {
[13:20:28.768]                           ns <- base::getNamespace("future")
[13:20:28.768]                           version <- ns[[".package"]][["version"]]
[13:20:28.768]                           if (is.null(version)) 
[13:20:28.768]                             version <- utils::packageVersion("future")
[13:20:28.768]                         }
[13:20:28.768]                         else {
[13:20:28.768]                           version <- NULL
[13:20:28.768]                         }
[13:20:28.768]                         if (!has_future || version < "1.8.0") {
[13:20:28.768]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.768]                             "", base::R.version$version.string), 
[13:20:28.768]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.768]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.768]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.768]                               "release", "version")], collapse = " "), 
[13:20:28.768]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.768]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.768]                             info)
[13:20:28.768]                           info <- base::paste(info, collapse = "; ")
[13:20:28.768]                           if (!has_future) {
[13:20:28.768]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.768]                               info)
[13:20:28.768]                           }
[13:20:28.768]                           else {
[13:20:28.768]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.768]                               info, version)
[13:20:28.768]                           }
[13:20:28.768]                           base::stop(msg)
[13:20:28.768]                         }
[13:20:28.768]                       })
[13:20:28.768]                     }
[13:20:28.768]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.768]                     base::options(mc.cores = 1L)
[13:20:28.768]                   }
[13:20:28.768]                   options(future.plan = NULL)
[13:20:28.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.768]                 }
[13:20:28.768]                 ...future.workdir <- getwd()
[13:20:28.768]             }
[13:20:28.768]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.768]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.768]         }
[13:20:28.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.768]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.768]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.768]             base::names(...future.oldOptions))
[13:20:28.768]     }
[13:20:28.768]     if (FALSE) {
[13:20:28.768]     }
[13:20:28.768]     else {
[13:20:28.768]         if (TRUE) {
[13:20:28.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.768]                 open = "w")
[13:20:28.768]         }
[13:20:28.768]         else {
[13:20:28.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.768]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.768]         }
[13:20:28.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.768]             base::sink(type = "output", split = FALSE)
[13:20:28.768]             base::close(...future.stdout)
[13:20:28.768]         }, add = TRUE)
[13:20:28.768]     }
[13:20:28.768]     ...future.frame <- base::sys.nframe()
[13:20:28.768]     ...future.conditions <- base::list()
[13:20:28.768]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.768]     if (FALSE) {
[13:20:28.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.768]     }
[13:20:28.768]     ...future.result <- base::tryCatch({
[13:20:28.768]         base::withCallingHandlers({
[13:20:28.768]             ...future.value <- base::withVisible(base::local({
[13:20:28.768]                 ...future.makeSendCondition <- local({
[13:20:28.768]                   sendCondition <- NULL
[13:20:28.768]                   function(frame = 1L) {
[13:20:28.768]                     if (is.function(sendCondition)) 
[13:20:28.768]                       return(sendCondition)
[13:20:28.768]                     ns <- getNamespace("parallel")
[13:20:28.768]                     if (exists("sendData", mode = "function", 
[13:20:28.768]                       envir = ns)) {
[13:20:28.768]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.768]                         envir = ns)
[13:20:28.768]                       envir <- sys.frame(frame)
[13:20:28.768]                       master <- NULL
[13:20:28.768]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.768]                         !identical(envir, emptyenv())) {
[13:20:28.768]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.768]                           inherits = FALSE)) {
[13:20:28.768]                           master <- get("master", mode = "list", 
[13:20:28.768]                             envir = envir, inherits = FALSE)
[13:20:28.768]                           if (inherits(master, c("SOCKnode", 
[13:20:28.768]                             "SOCK0node"))) {
[13:20:28.768]                             sendCondition <<- function(cond) {
[13:20:28.768]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.768]                                 success = TRUE)
[13:20:28.768]                               parallel_sendData(master, data)
[13:20:28.768]                             }
[13:20:28.768]                             return(sendCondition)
[13:20:28.768]                           }
[13:20:28.768]                         }
[13:20:28.768]                         frame <- frame + 1L
[13:20:28.768]                         envir <- sys.frame(frame)
[13:20:28.768]                       }
[13:20:28.768]                     }
[13:20:28.768]                     sendCondition <<- function(cond) NULL
[13:20:28.768]                   }
[13:20:28.768]                 })
[13:20:28.768]                 withCallingHandlers({
[13:20:28.768]                   NULL
[13:20:28.768]                 }, immediateCondition = function(cond) {
[13:20:28.768]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.768]                   sendCondition(cond)
[13:20:28.768]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.768]                   {
[13:20:28.768]                     inherits <- base::inherits
[13:20:28.768]                     invokeRestart <- base::invokeRestart
[13:20:28.768]                     is.null <- base::is.null
[13:20:28.768]                     muffled <- FALSE
[13:20:28.768]                     if (inherits(cond, "message")) {
[13:20:28.768]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.768]                       if (muffled) 
[13:20:28.768]                         invokeRestart("muffleMessage")
[13:20:28.768]                     }
[13:20:28.768]                     else if (inherits(cond, "warning")) {
[13:20:28.768]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.768]                       if (muffled) 
[13:20:28.768]                         invokeRestart("muffleWarning")
[13:20:28.768]                     }
[13:20:28.768]                     else if (inherits(cond, "condition")) {
[13:20:28.768]                       if (!is.null(pattern)) {
[13:20:28.768]                         computeRestarts <- base::computeRestarts
[13:20:28.768]                         grepl <- base::grepl
[13:20:28.768]                         restarts <- computeRestarts(cond)
[13:20:28.768]                         for (restart in restarts) {
[13:20:28.768]                           name <- restart$name
[13:20:28.768]                           if (is.null(name)) 
[13:20:28.768]                             next
[13:20:28.768]                           if (!grepl(pattern, name)) 
[13:20:28.768]                             next
[13:20:28.768]                           invokeRestart(restart)
[13:20:28.768]                           muffled <- TRUE
[13:20:28.768]                           break
[13:20:28.768]                         }
[13:20:28.768]                       }
[13:20:28.768]                     }
[13:20:28.768]                     invisible(muffled)
[13:20:28.768]                   }
[13:20:28.768]                   muffleCondition(cond)
[13:20:28.768]                 })
[13:20:28.768]             }))
[13:20:28.768]             future::FutureResult(value = ...future.value$value, 
[13:20:28.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.768]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.768]                     ...future.globalenv.names))
[13:20:28.768]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.768]         }, condition = base::local({
[13:20:28.768]             c <- base::c
[13:20:28.768]             inherits <- base::inherits
[13:20:28.768]             invokeRestart <- base::invokeRestart
[13:20:28.768]             length <- base::length
[13:20:28.768]             list <- base::list
[13:20:28.768]             seq.int <- base::seq.int
[13:20:28.768]             signalCondition <- base::signalCondition
[13:20:28.768]             sys.calls <- base::sys.calls
[13:20:28.768]             `[[` <- base::`[[`
[13:20:28.768]             `+` <- base::`+`
[13:20:28.768]             `<<-` <- base::`<<-`
[13:20:28.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.768]                   3L)]
[13:20:28.768]             }
[13:20:28.768]             function(cond) {
[13:20:28.768]                 is_error <- inherits(cond, "error")
[13:20:28.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.768]                   NULL)
[13:20:28.768]                 if (is_error) {
[13:20:28.768]                   sessionInformation <- function() {
[13:20:28.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.768]                       search = base::search(), system = base::Sys.info())
[13:20:28.768]                   }
[13:20:28.768]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.768]                     cond$call), session = sessionInformation(), 
[13:20:28.768]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.768]                   signalCondition(cond)
[13:20:28.768]                 }
[13:20:28.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.768]                 "immediateCondition"))) {
[13:20:28.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.768]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.768]                   if (TRUE && !signal) {
[13:20:28.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.768]                     {
[13:20:28.768]                       inherits <- base::inherits
[13:20:28.768]                       invokeRestart <- base::invokeRestart
[13:20:28.768]                       is.null <- base::is.null
[13:20:28.768]                       muffled <- FALSE
[13:20:28.768]                       if (inherits(cond, "message")) {
[13:20:28.768]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.768]                         if (muffled) 
[13:20:28.768]                           invokeRestart("muffleMessage")
[13:20:28.768]                       }
[13:20:28.768]                       else if (inherits(cond, "warning")) {
[13:20:28.768]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.768]                         if (muffled) 
[13:20:28.768]                           invokeRestart("muffleWarning")
[13:20:28.768]                       }
[13:20:28.768]                       else if (inherits(cond, "condition")) {
[13:20:28.768]                         if (!is.null(pattern)) {
[13:20:28.768]                           computeRestarts <- base::computeRestarts
[13:20:28.768]                           grepl <- base::grepl
[13:20:28.768]                           restarts <- computeRestarts(cond)
[13:20:28.768]                           for (restart in restarts) {
[13:20:28.768]                             name <- restart$name
[13:20:28.768]                             if (is.null(name)) 
[13:20:28.768]                               next
[13:20:28.768]                             if (!grepl(pattern, name)) 
[13:20:28.768]                               next
[13:20:28.768]                             invokeRestart(restart)
[13:20:28.768]                             muffled <- TRUE
[13:20:28.768]                             break
[13:20:28.768]                           }
[13:20:28.768]                         }
[13:20:28.768]                       }
[13:20:28.768]                       invisible(muffled)
[13:20:28.768]                     }
[13:20:28.768]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.768]                   }
[13:20:28.768]                 }
[13:20:28.768]                 else {
[13:20:28.768]                   if (TRUE) {
[13:20:28.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.768]                     {
[13:20:28.768]                       inherits <- base::inherits
[13:20:28.768]                       invokeRestart <- base::invokeRestart
[13:20:28.768]                       is.null <- base::is.null
[13:20:28.768]                       muffled <- FALSE
[13:20:28.768]                       if (inherits(cond, "message")) {
[13:20:28.768]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.768]                         if (muffled) 
[13:20:28.768]                           invokeRestart("muffleMessage")
[13:20:28.768]                       }
[13:20:28.768]                       else if (inherits(cond, "warning")) {
[13:20:28.768]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.768]                         if (muffled) 
[13:20:28.768]                           invokeRestart("muffleWarning")
[13:20:28.768]                       }
[13:20:28.768]                       else if (inherits(cond, "condition")) {
[13:20:28.768]                         if (!is.null(pattern)) {
[13:20:28.768]                           computeRestarts <- base::computeRestarts
[13:20:28.768]                           grepl <- base::grepl
[13:20:28.768]                           restarts <- computeRestarts(cond)
[13:20:28.768]                           for (restart in restarts) {
[13:20:28.768]                             name <- restart$name
[13:20:28.768]                             if (is.null(name)) 
[13:20:28.768]                               next
[13:20:28.768]                             if (!grepl(pattern, name)) 
[13:20:28.768]                               next
[13:20:28.768]                             invokeRestart(restart)
[13:20:28.768]                             muffled <- TRUE
[13:20:28.768]                             break
[13:20:28.768]                           }
[13:20:28.768]                         }
[13:20:28.768]                       }
[13:20:28.768]                       invisible(muffled)
[13:20:28.768]                     }
[13:20:28.768]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.768]                   }
[13:20:28.768]                 }
[13:20:28.768]             }
[13:20:28.768]         }))
[13:20:28.768]     }, error = function(ex) {
[13:20:28.768]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.768]                 ...future.rng), started = ...future.startTime, 
[13:20:28.768]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.768]             version = "1.8"), class = "FutureResult")
[13:20:28.768]     }, finally = {
[13:20:28.768]         if (!identical(...future.workdir, getwd())) 
[13:20:28.768]             setwd(...future.workdir)
[13:20:28.768]         {
[13:20:28.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.768]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.768]             }
[13:20:28.768]             base::options(...future.oldOptions)
[13:20:28.768]             if (.Platform$OS.type == "windows") {
[13:20:28.768]                 old_names <- names(...future.oldEnvVars)
[13:20:28.768]                 envs <- base::Sys.getenv()
[13:20:28.768]                 names <- names(envs)
[13:20:28.768]                 common <- intersect(names, old_names)
[13:20:28.768]                 added <- setdiff(names, old_names)
[13:20:28.768]                 removed <- setdiff(old_names, names)
[13:20:28.768]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.768]                   envs[common]]
[13:20:28.768]                 NAMES <- toupper(changed)
[13:20:28.768]                 args <- list()
[13:20:28.768]                 for (kk in seq_along(NAMES)) {
[13:20:28.768]                   name <- changed[[kk]]
[13:20:28.768]                   NAME <- NAMES[[kk]]
[13:20:28.768]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.768]                     next
[13:20:28.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.768]                 }
[13:20:28.768]                 NAMES <- toupper(added)
[13:20:28.768]                 for (kk in seq_along(NAMES)) {
[13:20:28.768]                   name <- added[[kk]]
[13:20:28.768]                   NAME <- NAMES[[kk]]
[13:20:28.768]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.768]                     next
[13:20:28.768]                   args[[name]] <- ""
[13:20:28.768]                 }
[13:20:28.768]                 NAMES <- toupper(removed)
[13:20:28.768]                 for (kk in seq_along(NAMES)) {
[13:20:28.768]                   name <- removed[[kk]]
[13:20:28.768]                   NAME <- NAMES[[kk]]
[13:20:28.768]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.768]                     next
[13:20:28.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.768]                 }
[13:20:28.768]                 if (length(args) > 0) 
[13:20:28.768]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.768]             }
[13:20:28.768]             else {
[13:20:28.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.768]             }
[13:20:28.768]             {
[13:20:28.768]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.768]                   0L) {
[13:20:28.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.768]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.768]                   base::options(opts)
[13:20:28.768]                 }
[13:20:28.768]                 {
[13:20:28.768]                   {
[13:20:28.768]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.768]                     NULL
[13:20:28.768]                   }
[13:20:28.768]                   options(future.plan = NULL)
[13:20:28.768]                   if (is.na(NA_character_)) 
[13:20:28.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.768]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.768]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.768]                     envir = parent.frame()) 
[13:20:28.768]                   {
[13:20:28.768]                     if (is.function(workers)) 
[13:20:28.768]                       workers <- workers()
[13:20:28.768]                     workers <- structure(as.integer(workers), 
[13:20:28.768]                       class = class(workers))
[13:20:28.768]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.768]                       workers >= 1)
[13:20:28.768]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.768]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.768]                     }
[13:20:28.768]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.768]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.768]                       envir = envir)
[13:20:28.768]                     if (!future$lazy) 
[13:20:28.768]                       future <- run(future)
[13:20:28.768]                     invisible(future)
[13:20:28.768]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.768]                 }
[13:20:28.768]             }
[13:20:28.768]         }
[13:20:28.768]     })
[13:20:28.768]     if (TRUE) {
[13:20:28.768]         base::sink(type = "output", split = FALSE)
[13:20:28.768]         if (TRUE) {
[13:20:28.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.768]         }
[13:20:28.768]         else {
[13:20:28.768]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.768]         }
[13:20:28.768]         base::close(...future.stdout)
[13:20:28.768]         ...future.stdout <- NULL
[13:20:28.768]     }
[13:20:28.768]     ...future.result$conditions <- ...future.conditions
[13:20:28.768]     ...future.result$finished <- base::Sys.time()
[13:20:28.768]     ...future.result
[13:20:28.768] }
[13:20:28.771] MultisessionFuture started
[13:20:28.771] - Launch lazy future ... done
[13:20:28.772] run() for ‘MultisessionFuture’ ... done
[13:20:28.772] getGlobalsAndPackages() ...
[13:20:28.772] Searching for globals...
[13:20:28.773] - globals found: [1] ‘{’
[13:20:28.773] Searching for globals ... DONE
[13:20:28.773] Resolving globals: FALSE
[13:20:28.773] 
[13:20:28.773] 
[13:20:28.773] getGlobalsAndPackages() ... DONE
[13:20:28.774] run() for ‘Future’ ...
[13:20:28.774] - state: ‘created’
[13:20:28.774] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.789] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.789]   - Field: ‘node’
[13:20:28.789]   - Field: ‘label’
[13:20:28.790]   - Field: ‘local’
[13:20:28.790]   - Field: ‘owner’
[13:20:28.790]   - Field: ‘envir’
[13:20:28.790]   - Field: ‘workers’
[13:20:28.790]   - Field: ‘packages’
[13:20:28.790]   - Field: ‘gc’
[13:20:28.790]   - Field: ‘conditions’
[13:20:28.790]   - Field: ‘persistent’
[13:20:28.790]   - Field: ‘expr’
[13:20:28.790]   - Field: ‘uuid’
[13:20:28.790]   - Field: ‘seed’
[13:20:28.791]   - Field: ‘version’
[13:20:28.791]   - Field: ‘result’
[13:20:28.791]   - Field: ‘asynchronous’
[13:20:28.791]   - Field: ‘calls’
[13:20:28.791]   - Field: ‘globals’
[13:20:28.791]   - Field: ‘stdout’
[13:20:28.791]   - Field: ‘earlySignal’
[13:20:28.791]   - Field: ‘lazy’
[13:20:28.791]   - Field: ‘state’
[13:20:28.791] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.792] - Launch lazy future ...
[13:20:28.792] Packages needed by the future expression (n = 0): <none>
[13:20:28.792] Packages needed by future strategies (n = 0): <none>
[13:20:28.792] {
[13:20:28.792]     {
[13:20:28.792]         {
[13:20:28.792]             ...future.startTime <- base::Sys.time()
[13:20:28.792]             {
[13:20:28.792]                 {
[13:20:28.792]                   {
[13:20:28.792]                     {
[13:20:28.792]                       base::local({
[13:20:28.792]                         has_future <- base::requireNamespace("future", 
[13:20:28.792]                           quietly = TRUE)
[13:20:28.792]                         if (has_future) {
[13:20:28.792]                           ns <- base::getNamespace("future")
[13:20:28.792]                           version <- ns[[".package"]][["version"]]
[13:20:28.792]                           if (is.null(version)) 
[13:20:28.792]                             version <- utils::packageVersion("future")
[13:20:28.792]                         }
[13:20:28.792]                         else {
[13:20:28.792]                           version <- NULL
[13:20:28.792]                         }
[13:20:28.792]                         if (!has_future || version < "1.8.0") {
[13:20:28.792]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.792]                             "", base::R.version$version.string), 
[13:20:28.792]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.792]                               "release", "version")], collapse = " "), 
[13:20:28.792]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.792]                             info)
[13:20:28.792]                           info <- base::paste(info, collapse = "; ")
[13:20:28.792]                           if (!has_future) {
[13:20:28.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.792]                               info)
[13:20:28.792]                           }
[13:20:28.792]                           else {
[13:20:28.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.792]                               info, version)
[13:20:28.792]                           }
[13:20:28.792]                           base::stop(msg)
[13:20:28.792]                         }
[13:20:28.792]                       })
[13:20:28.792]                     }
[13:20:28.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.792]                     base::options(mc.cores = 1L)
[13:20:28.792]                   }
[13:20:28.792]                   options(future.plan = NULL)
[13:20:28.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.792]                 }
[13:20:28.792]                 ...future.workdir <- getwd()
[13:20:28.792]             }
[13:20:28.792]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.792]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.792]         }
[13:20:28.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.792]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.792]             base::names(...future.oldOptions))
[13:20:28.792]     }
[13:20:28.792]     if (FALSE) {
[13:20:28.792]     }
[13:20:28.792]     else {
[13:20:28.792]         if (TRUE) {
[13:20:28.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.792]                 open = "w")
[13:20:28.792]         }
[13:20:28.792]         else {
[13:20:28.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.792]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.792]         }
[13:20:28.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.792]             base::sink(type = "output", split = FALSE)
[13:20:28.792]             base::close(...future.stdout)
[13:20:28.792]         }, add = TRUE)
[13:20:28.792]     }
[13:20:28.792]     ...future.frame <- base::sys.nframe()
[13:20:28.792]     ...future.conditions <- base::list()
[13:20:28.792]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.792]     if (FALSE) {
[13:20:28.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.792]     }
[13:20:28.792]     ...future.result <- base::tryCatch({
[13:20:28.792]         base::withCallingHandlers({
[13:20:28.792]             ...future.value <- base::withVisible(base::local({
[13:20:28.792]                 ...future.makeSendCondition <- local({
[13:20:28.792]                   sendCondition <- NULL
[13:20:28.792]                   function(frame = 1L) {
[13:20:28.792]                     if (is.function(sendCondition)) 
[13:20:28.792]                       return(sendCondition)
[13:20:28.792]                     ns <- getNamespace("parallel")
[13:20:28.792]                     if (exists("sendData", mode = "function", 
[13:20:28.792]                       envir = ns)) {
[13:20:28.792]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.792]                         envir = ns)
[13:20:28.792]                       envir <- sys.frame(frame)
[13:20:28.792]                       master <- NULL
[13:20:28.792]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.792]                         !identical(envir, emptyenv())) {
[13:20:28.792]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.792]                           inherits = FALSE)) {
[13:20:28.792]                           master <- get("master", mode = "list", 
[13:20:28.792]                             envir = envir, inherits = FALSE)
[13:20:28.792]                           if (inherits(master, c("SOCKnode", 
[13:20:28.792]                             "SOCK0node"))) {
[13:20:28.792]                             sendCondition <<- function(cond) {
[13:20:28.792]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.792]                                 success = TRUE)
[13:20:28.792]                               parallel_sendData(master, data)
[13:20:28.792]                             }
[13:20:28.792]                             return(sendCondition)
[13:20:28.792]                           }
[13:20:28.792]                         }
[13:20:28.792]                         frame <- frame + 1L
[13:20:28.792]                         envir <- sys.frame(frame)
[13:20:28.792]                       }
[13:20:28.792]                     }
[13:20:28.792]                     sendCondition <<- function(cond) NULL
[13:20:28.792]                   }
[13:20:28.792]                 })
[13:20:28.792]                 withCallingHandlers({
[13:20:28.792]                   {
[13:20:28.792]                     4
[13:20:28.792]                   }
[13:20:28.792]                 }, immediateCondition = function(cond) {
[13:20:28.792]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.792]                   sendCondition(cond)
[13:20:28.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.792]                   {
[13:20:28.792]                     inherits <- base::inherits
[13:20:28.792]                     invokeRestart <- base::invokeRestart
[13:20:28.792]                     is.null <- base::is.null
[13:20:28.792]                     muffled <- FALSE
[13:20:28.792]                     if (inherits(cond, "message")) {
[13:20:28.792]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.792]                       if (muffled) 
[13:20:28.792]                         invokeRestart("muffleMessage")
[13:20:28.792]                     }
[13:20:28.792]                     else if (inherits(cond, "warning")) {
[13:20:28.792]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.792]                       if (muffled) 
[13:20:28.792]                         invokeRestart("muffleWarning")
[13:20:28.792]                     }
[13:20:28.792]                     else if (inherits(cond, "condition")) {
[13:20:28.792]                       if (!is.null(pattern)) {
[13:20:28.792]                         computeRestarts <- base::computeRestarts
[13:20:28.792]                         grepl <- base::grepl
[13:20:28.792]                         restarts <- computeRestarts(cond)
[13:20:28.792]                         for (restart in restarts) {
[13:20:28.792]                           name <- restart$name
[13:20:28.792]                           if (is.null(name)) 
[13:20:28.792]                             next
[13:20:28.792]                           if (!grepl(pattern, name)) 
[13:20:28.792]                             next
[13:20:28.792]                           invokeRestart(restart)
[13:20:28.792]                           muffled <- TRUE
[13:20:28.792]                           break
[13:20:28.792]                         }
[13:20:28.792]                       }
[13:20:28.792]                     }
[13:20:28.792]                     invisible(muffled)
[13:20:28.792]                   }
[13:20:28.792]                   muffleCondition(cond)
[13:20:28.792]                 })
[13:20:28.792]             }))
[13:20:28.792]             future::FutureResult(value = ...future.value$value, 
[13:20:28.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.792]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.792]                     ...future.globalenv.names))
[13:20:28.792]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.792]         }, condition = base::local({
[13:20:28.792]             c <- base::c
[13:20:28.792]             inherits <- base::inherits
[13:20:28.792]             invokeRestart <- base::invokeRestart
[13:20:28.792]             length <- base::length
[13:20:28.792]             list <- base::list
[13:20:28.792]             seq.int <- base::seq.int
[13:20:28.792]             signalCondition <- base::signalCondition
[13:20:28.792]             sys.calls <- base::sys.calls
[13:20:28.792]             `[[` <- base::`[[`
[13:20:28.792]             `+` <- base::`+`
[13:20:28.792]             `<<-` <- base::`<<-`
[13:20:28.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.792]                   3L)]
[13:20:28.792]             }
[13:20:28.792]             function(cond) {
[13:20:28.792]                 is_error <- inherits(cond, "error")
[13:20:28.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.792]                   NULL)
[13:20:28.792]                 if (is_error) {
[13:20:28.792]                   sessionInformation <- function() {
[13:20:28.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.792]                       search = base::search(), system = base::Sys.info())
[13:20:28.792]                   }
[13:20:28.792]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.792]                     cond$call), session = sessionInformation(), 
[13:20:28.792]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.792]                   signalCondition(cond)
[13:20:28.792]                 }
[13:20:28.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.792]                 "immediateCondition"))) {
[13:20:28.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.792]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.792]                   if (TRUE && !signal) {
[13:20:28.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.792]                     {
[13:20:28.792]                       inherits <- base::inherits
[13:20:28.792]                       invokeRestart <- base::invokeRestart
[13:20:28.792]                       is.null <- base::is.null
[13:20:28.792]                       muffled <- FALSE
[13:20:28.792]                       if (inherits(cond, "message")) {
[13:20:28.792]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.792]                         if (muffled) 
[13:20:28.792]                           invokeRestart("muffleMessage")
[13:20:28.792]                       }
[13:20:28.792]                       else if (inherits(cond, "warning")) {
[13:20:28.792]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.792]                         if (muffled) 
[13:20:28.792]                           invokeRestart("muffleWarning")
[13:20:28.792]                       }
[13:20:28.792]                       else if (inherits(cond, "condition")) {
[13:20:28.792]                         if (!is.null(pattern)) {
[13:20:28.792]                           computeRestarts <- base::computeRestarts
[13:20:28.792]                           grepl <- base::grepl
[13:20:28.792]                           restarts <- computeRestarts(cond)
[13:20:28.792]                           for (restart in restarts) {
[13:20:28.792]                             name <- restart$name
[13:20:28.792]                             if (is.null(name)) 
[13:20:28.792]                               next
[13:20:28.792]                             if (!grepl(pattern, name)) 
[13:20:28.792]                               next
[13:20:28.792]                             invokeRestart(restart)
[13:20:28.792]                             muffled <- TRUE
[13:20:28.792]                             break
[13:20:28.792]                           }
[13:20:28.792]                         }
[13:20:28.792]                       }
[13:20:28.792]                       invisible(muffled)
[13:20:28.792]                     }
[13:20:28.792]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.792]                   }
[13:20:28.792]                 }
[13:20:28.792]                 else {
[13:20:28.792]                   if (TRUE) {
[13:20:28.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.792]                     {
[13:20:28.792]                       inherits <- base::inherits
[13:20:28.792]                       invokeRestart <- base::invokeRestart
[13:20:28.792]                       is.null <- base::is.null
[13:20:28.792]                       muffled <- FALSE
[13:20:28.792]                       if (inherits(cond, "message")) {
[13:20:28.792]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.792]                         if (muffled) 
[13:20:28.792]                           invokeRestart("muffleMessage")
[13:20:28.792]                       }
[13:20:28.792]                       else if (inherits(cond, "warning")) {
[13:20:28.792]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.792]                         if (muffled) 
[13:20:28.792]                           invokeRestart("muffleWarning")
[13:20:28.792]                       }
[13:20:28.792]                       else if (inherits(cond, "condition")) {
[13:20:28.792]                         if (!is.null(pattern)) {
[13:20:28.792]                           computeRestarts <- base::computeRestarts
[13:20:28.792]                           grepl <- base::grepl
[13:20:28.792]                           restarts <- computeRestarts(cond)
[13:20:28.792]                           for (restart in restarts) {
[13:20:28.792]                             name <- restart$name
[13:20:28.792]                             if (is.null(name)) 
[13:20:28.792]                               next
[13:20:28.792]                             if (!grepl(pattern, name)) 
[13:20:28.792]                               next
[13:20:28.792]                             invokeRestart(restart)
[13:20:28.792]                             muffled <- TRUE
[13:20:28.792]                             break
[13:20:28.792]                           }
[13:20:28.792]                         }
[13:20:28.792]                       }
[13:20:28.792]                       invisible(muffled)
[13:20:28.792]                     }
[13:20:28.792]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.792]                   }
[13:20:28.792]                 }
[13:20:28.792]             }
[13:20:28.792]         }))
[13:20:28.792]     }, error = function(ex) {
[13:20:28.792]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.792]                 ...future.rng), started = ...future.startTime, 
[13:20:28.792]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.792]             version = "1.8"), class = "FutureResult")
[13:20:28.792]     }, finally = {
[13:20:28.792]         if (!identical(...future.workdir, getwd())) 
[13:20:28.792]             setwd(...future.workdir)
[13:20:28.792]         {
[13:20:28.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.792]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.792]             }
[13:20:28.792]             base::options(...future.oldOptions)
[13:20:28.792]             if (.Platform$OS.type == "windows") {
[13:20:28.792]                 old_names <- names(...future.oldEnvVars)
[13:20:28.792]                 envs <- base::Sys.getenv()
[13:20:28.792]                 names <- names(envs)
[13:20:28.792]                 common <- intersect(names, old_names)
[13:20:28.792]                 added <- setdiff(names, old_names)
[13:20:28.792]                 removed <- setdiff(old_names, names)
[13:20:28.792]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.792]                   envs[common]]
[13:20:28.792]                 NAMES <- toupper(changed)
[13:20:28.792]                 args <- list()
[13:20:28.792]                 for (kk in seq_along(NAMES)) {
[13:20:28.792]                   name <- changed[[kk]]
[13:20:28.792]                   NAME <- NAMES[[kk]]
[13:20:28.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.792]                     next
[13:20:28.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.792]                 }
[13:20:28.792]                 NAMES <- toupper(added)
[13:20:28.792]                 for (kk in seq_along(NAMES)) {
[13:20:28.792]                   name <- added[[kk]]
[13:20:28.792]                   NAME <- NAMES[[kk]]
[13:20:28.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.792]                     next
[13:20:28.792]                   args[[name]] <- ""
[13:20:28.792]                 }
[13:20:28.792]                 NAMES <- toupper(removed)
[13:20:28.792]                 for (kk in seq_along(NAMES)) {
[13:20:28.792]                   name <- removed[[kk]]
[13:20:28.792]                   NAME <- NAMES[[kk]]
[13:20:28.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.792]                     next
[13:20:28.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.792]                 }
[13:20:28.792]                 if (length(args) > 0) 
[13:20:28.792]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.792]             }
[13:20:28.792]             else {
[13:20:28.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.792]             }
[13:20:28.792]             {
[13:20:28.792]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.792]                   0L) {
[13:20:28.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.792]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.792]                   base::options(opts)
[13:20:28.792]                 }
[13:20:28.792]                 {
[13:20:28.792]                   {
[13:20:28.792]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.792]                     NULL
[13:20:28.792]                   }
[13:20:28.792]                   options(future.plan = NULL)
[13:20:28.792]                   if (is.na(NA_character_)) 
[13:20:28.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.792]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.792]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.792]                     envir = parent.frame()) 
[13:20:28.792]                   {
[13:20:28.792]                     if (is.function(workers)) 
[13:20:28.792]                       workers <- workers()
[13:20:28.792]                     workers <- structure(as.integer(workers), 
[13:20:28.792]                       class = class(workers))
[13:20:28.792]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.792]                       workers >= 1)
[13:20:28.792]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.792]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.792]                     }
[13:20:28.792]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.792]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.792]                       envir = envir)
[13:20:28.792]                     if (!future$lazy) 
[13:20:28.792]                       future <- run(future)
[13:20:28.792]                     invisible(future)
[13:20:28.792]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.792]                 }
[13:20:28.792]             }
[13:20:28.792]         }
[13:20:28.792]     })
[13:20:28.792]     if (TRUE) {
[13:20:28.792]         base::sink(type = "output", split = FALSE)
[13:20:28.792]         if (TRUE) {
[13:20:28.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.792]         }
[13:20:28.792]         else {
[13:20:28.792]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.792]         }
[13:20:28.792]         base::close(...future.stdout)
[13:20:28.792]         ...future.stdout <- NULL
[13:20:28.792]     }
[13:20:28.792]     ...future.result$conditions <- ...future.conditions
[13:20:28.792]     ...future.result$finished <- base::Sys.time()
[13:20:28.792]     ...future.result
[13:20:28.792] }
[13:20:28.795] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:28.805] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.806] - Validating connection of MultisessionFuture
[13:20:28.806] - received message: FutureResult
[13:20:28.806] - Received FutureResult
[13:20:28.806] - Erased future from FutureRegistry
[13:20:28.806] result() for ClusterFuture ...
[13:20:28.806] - result already collected: FutureResult
[13:20:28.806] result() for ClusterFuture ... done
[13:20:28.806] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:28.807] result() for ClusterFuture ...
[13:20:28.807] - result already collected: FutureResult
[13:20:28.807] result() for ClusterFuture ... done
[13:20:28.807] result() for ClusterFuture ...
[13:20:28.807] - result already collected: FutureResult
[13:20:28.807] result() for ClusterFuture ... done
[13:20:28.808] MultisessionFuture started
[13:20:28.808] - Launch lazy future ... done
[13:20:28.809] run() for ‘MultisessionFuture’ ... done
<environment: 0x55659d9af690> 
<environment: 0x55659b011dd0> 
[13:20:28.818] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.818] - Validating connection of MultisessionFuture
[13:20:28.818] - received message: FutureResult
[13:20:28.818] - Received FutureResult
[13:20:28.818] - Erased future from FutureRegistry
[13:20:28.819] result() for ClusterFuture ...
[13:20:28.819] - result already collected: FutureResult
[13:20:28.819] result() for ClusterFuture ... done
[13:20:28.819] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:28.831] resolve() on environment ...
[13:20:28.831]  recursive: 0
[13:20:28.831]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:28.832] signalConditionsASAP(numeric, pos=1) ...
[13:20:28.832] - nx: 4
[13:20:28.832] - relay: TRUE
[13:20:28.832] - stdout: TRUE
[13:20:28.832] - signal: TRUE
[13:20:28.832] - resignal: FALSE
[13:20:28.832] - force: TRUE
[13:20:28.832] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.832] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.832]  - until=2
[13:20:28.832]  - relaying element #2
[13:20:28.833] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:28.833] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.833] signalConditionsASAP(NULL, pos=1) ... done
[13:20:28.833]  length: 3 (resolved future 1)
[13:20:28.833] Future #2
[13:20:28.833] result() for ClusterFuture ...
[13:20:28.833] - result already collected: FutureResult
[13:20:28.833] result() for ClusterFuture ... done
[13:20:28.834] result() for ClusterFuture ...
[13:20:28.834] - result already collected: FutureResult
[13:20:28.834] result() for ClusterFuture ... done
[13:20:28.834] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:28.834] - nx: 4
[13:20:28.834] - relay: TRUE
[13:20:28.834] - stdout: TRUE
[13:20:28.834] - signal: TRUE
[13:20:28.834] - resignal: FALSE
[13:20:28.834] - force: TRUE
[13:20:28.834] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:28.835] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.835]  - until=2
[13:20:28.835]  - relaying element #2
[13:20:28.835] result() for ClusterFuture ...
[13:20:28.835] - result already collected: FutureResult
[13:20:28.835] result() for ClusterFuture ... done
[13:20:28.835] result() for ClusterFuture ...
[13:20:28.835] - result already collected: FutureResult
[13:20:28.835] result() for ClusterFuture ... done
[13:20:28.835] result() for ClusterFuture ...
[13:20:28.836] - result already collected: FutureResult
[13:20:28.836] result() for ClusterFuture ... done
[13:20:28.836] result() for ClusterFuture ...
[13:20:28.836] - result already collected: FutureResult
[13:20:28.836] result() for ClusterFuture ... done
[13:20:28.836] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:28.836] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:28.836] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:28.836]  length: 2 (resolved future 2)
[13:20:28.836] Future #3
[13:20:28.837] result() for ClusterFuture ...
[13:20:28.837] - result already collected: FutureResult
[13:20:28.837] result() for ClusterFuture ... done
[13:20:28.837] result() for ClusterFuture ...
[13:20:28.837] - result already collected: FutureResult
[13:20:28.837] result() for ClusterFuture ... done
[13:20:28.837] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:28.837] - nx: 4
[13:20:28.837] - relay: TRUE
[13:20:28.837] - stdout: TRUE
[13:20:28.838] - signal: TRUE
[13:20:28.838] - resignal: FALSE
[13:20:28.838] - force: TRUE
[13:20:28.838] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:28.838] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:28.838]  - until=3
[13:20:28.838]  - relaying element #3
[13:20:28.838] result() for ClusterFuture ...
[13:20:28.838] - result already collected: FutureResult
[13:20:28.838] result() for ClusterFuture ... done
[13:20:28.838] result() for ClusterFuture ...
[13:20:28.838] - result already collected: FutureResult
[13:20:28.839] result() for ClusterFuture ... done
[13:20:28.839] result() for ClusterFuture ...
[13:20:28.839] - result already collected: FutureResult
[13:20:28.839] result() for ClusterFuture ... done
[13:20:28.839] result() for ClusterFuture ...
[13:20:28.839] - result already collected: FutureResult
[13:20:28.839] result() for ClusterFuture ... done
[13:20:28.839] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:28.839] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:28.839] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:28.839]  length: 1 (resolved future 3)
[13:20:28.861] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.861] - Validating connection of MultisessionFuture
[13:20:28.861] - received message: FutureResult
[13:20:28.861] - Received FutureResult
[13:20:28.861] - Erased future from FutureRegistry
[13:20:28.862] result() for ClusterFuture ...
[13:20:28.862] - result already collected: FutureResult
[13:20:28.862] result() for ClusterFuture ... done
[13:20:28.862] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:28.862] Future #4
[13:20:28.862] result() for ClusterFuture ...
[13:20:28.862] - result already collected: FutureResult
[13:20:28.862] result() for ClusterFuture ... done
[13:20:28.862] result() for ClusterFuture ...
[13:20:28.862] - result already collected: FutureResult
[13:20:28.863] result() for ClusterFuture ... done
[13:20:28.863] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:20:28.863] - nx: 4
[13:20:28.863] - relay: TRUE
[13:20:28.863] - stdout: TRUE
[13:20:28.863] - signal: TRUE
[13:20:28.863] - resignal: FALSE
[13:20:28.863] - force: TRUE
[13:20:28.863] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:28.863] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:28.863]  - until=4
[13:20:28.863]  - relaying element #4
[13:20:28.864] result() for ClusterFuture ...
[13:20:28.864] - result already collected: FutureResult
[13:20:28.864] result() for ClusterFuture ... done
[13:20:28.864] result() for ClusterFuture ...
[13:20:28.864] - result already collected: FutureResult
[13:20:28.864] result() for ClusterFuture ... done
[13:20:28.864] result() for ClusterFuture ...
[13:20:28.864] - result already collected: FutureResult
[13:20:28.864] result() for ClusterFuture ... done
[13:20:28.864] result() for ClusterFuture ...
[13:20:28.865] - result already collected: FutureResult
[13:20:28.865] result() for ClusterFuture ... done
[13:20:28.865] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.865] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:28.865] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:20:28.865]  length: 0 (resolved future 4)
[13:20:28.865] Relaying remaining futures
[13:20:28.865] signalConditionsASAP(NULL, pos=0) ...
[13:20:28.865] - nx: 4
[13:20:28.865] - relay: TRUE
[13:20:28.866] - stdout: TRUE
[13:20:28.866] - signal: TRUE
[13:20:28.866] - resignal: FALSE
[13:20:28.866] - force: TRUE
[13:20:28.866] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.866] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:28.866] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:28.866] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:28.866] signalConditionsASAP(NULL, pos=0) ... done
[13:20:28.867] resolve() on environment ... DONE
[13:20:28.867] result() for ClusterFuture ...
[13:20:28.867] - result already collected: FutureResult
[13:20:28.867] result() for ClusterFuture ... done
[13:20:28.867] result() for ClusterFuture ...
[13:20:28.867] - result already collected: FutureResult
[13:20:28.867] result() for ClusterFuture ... done
[13:20:28.867] result() for ClusterFuture ...
[13:20:28.867] - result already collected: FutureResult
[13:20:28.867] result() for ClusterFuture ... done
[13:20:28.868] result() for ClusterFuture ...
[13:20:28.868] - result already collected: FutureResult
[13:20:28.868] result() for ClusterFuture ... done
[13:20:28.868] result() for ClusterFuture ...
[13:20:28.868] - result already collected: FutureResult
[13:20:28.868] result() for ClusterFuture ... done
[13:20:28.868] result() for ClusterFuture ...
[13:20:28.868] - result already collected: FutureResult
[13:20:28.868] result() for ClusterFuture ... done
<environment: 0x556599d10b48> 
Dimensions: c(2, 1, 3, 1)
[13:20:28.869] getGlobalsAndPackages() ...
[13:20:28.869] Searching for globals...
[13:20:28.869] 
[13:20:28.869] Searching for globals ... DONE
[13:20:28.870] - globals: [0] <none>
[13:20:28.870] getGlobalsAndPackages() ... DONE
[13:20:28.870] run() for ‘Future’ ...
[13:20:28.870] - state: ‘created’
[13:20:28.870] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.885] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.885]   - Field: ‘node’
[13:20:28.885]   - Field: ‘label’
[13:20:28.885]   - Field: ‘local’
[13:20:28.885]   - Field: ‘owner’
[13:20:28.885]   - Field: ‘envir’
[13:20:28.885]   - Field: ‘workers’
[13:20:28.886]   - Field: ‘packages’
[13:20:28.886]   - Field: ‘gc’
[13:20:28.886]   - Field: ‘conditions’
[13:20:28.886]   - Field: ‘persistent’
[13:20:28.886]   - Field: ‘expr’
[13:20:28.886]   - Field: ‘uuid’
[13:20:28.886]   - Field: ‘seed’
[13:20:28.886]   - Field: ‘version’
[13:20:28.886]   - Field: ‘result’
[13:20:28.886]   - Field: ‘asynchronous’
[13:20:28.886]   - Field: ‘calls’
[13:20:28.887]   - Field: ‘globals’
[13:20:28.887]   - Field: ‘stdout’
[13:20:28.887]   - Field: ‘earlySignal’
[13:20:28.887]   - Field: ‘lazy’
[13:20:28.887]   - Field: ‘state’
[13:20:28.887] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.887] - Launch lazy future ...
[13:20:28.887] Packages needed by the future expression (n = 0): <none>
[13:20:28.888] Packages needed by future strategies (n = 0): <none>
[13:20:28.888] {
[13:20:28.888]     {
[13:20:28.888]         {
[13:20:28.888]             ...future.startTime <- base::Sys.time()
[13:20:28.888]             {
[13:20:28.888]                 {
[13:20:28.888]                   {
[13:20:28.888]                     {
[13:20:28.888]                       base::local({
[13:20:28.888]                         has_future <- base::requireNamespace("future", 
[13:20:28.888]                           quietly = TRUE)
[13:20:28.888]                         if (has_future) {
[13:20:28.888]                           ns <- base::getNamespace("future")
[13:20:28.888]                           version <- ns[[".package"]][["version"]]
[13:20:28.888]                           if (is.null(version)) 
[13:20:28.888]                             version <- utils::packageVersion("future")
[13:20:28.888]                         }
[13:20:28.888]                         else {
[13:20:28.888]                           version <- NULL
[13:20:28.888]                         }
[13:20:28.888]                         if (!has_future || version < "1.8.0") {
[13:20:28.888]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.888]                             "", base::R.version$version.string), 
[13:20:28.888]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.888]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.888]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.888]                               "release", "version")], collapse = " "), 
[13:20:28.888]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.888]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.888]                             info)
[13:20:28.888]                           info <- base::paste(info, collapse = "; ")
[13:20:28.888]                           if (!has_future) {
[13:20:28.888]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.888]                               info)
[13:20:28.888]                           }
[13:20:28.888]                           else {
[13:20:28.888]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.888]                               info, version)
[13:20:28.888]                           }
[13:20:28.888]                           base::stop(msg)
[13:20:28.888]                         }
[13:20:28.888]                       })
[13:20:28.888]                     }
[13:20:28.888]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.888]                     base::options(mc.cores = 1L)
[13:20:28.888]                   }
[13:20:28.888]                   options(future.plan = NULL)
[13:20:28.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.888]                 }
[13:20:28.888]                 ...future.workdir <- getwd()
[13:20:28.888]             }
[13:20:28.888]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.888]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.888]         }
[13:20:28.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.888]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.888]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.888]             base::names(...future.oldOptions))
[13:20:28.888]     }
[13:20:28.888]     if (FALSE) {
[13:20:28.888]     }
[13:20:28.888]     else {
[13:20:28.888]         if (TRUE) {
[13:20:28.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.888]                 open = "w")
[13:20:28.888]         }
[13:20:28.888]         else {
[13:20:28.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.888]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.888]         }
[13:20:28.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.888]             base::sink(type = "output", split = FALSE)
[13:20:28.888]             base::close(...future.stdout)
[13:20:28.888]         }, add = TRUE)
[13:20:28.888]     }
[13:20:28.888]     ...future.frame <- base::sys.nframe()
[13:20:28.888]     ...future.conditions <- base::list()
[13:20:28.888]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.888]     if (FALSE) {
[13:20:28.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.888]     }
[13:20:28.888]     ...future.result <- base::tryCatch({
[13:20:28.888]         base::withCallingHandlers({
[13:20:28.888]             ...future.value <- base::withVisible(base::local({
[13:20:28.888]                 ...future.makeSendCondition <- local({
[13:20:28.888]                   sendCondition <- NULL
[13:20:28.888]                   function(frame = 1L) {
[13:20:28.888]                     if (is.function(sendCondition)) 
[13:20:28.888]                       return(sendCondition)
[13:20:28.888]                     ns <- getNamespace("parallel")
[13:20:28.888]                     if (exists("sendData", mode = "function", 
[13:20:28.888]                       envir = ns)) {
[13:20:28.888]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.888]                         envir = ns)
[13:20:28.888]                       envir <- sys.frame(frame)
[13:20:28.888]                       master <- NULL
[13:20:28.888]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.888]                         !identical(envir, emptyenv())) {
[13:20:28.888]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.888]                           inherits = FALSE)) {
[13:20:28.888]                           master <- get("master", mode = "list", 
[13:20:28.888]                             envir = envir, inherits = FALSE)
[13:20:28.888]                           if (inherits(master, c("SOCKnode", 
[13:20:28.888]                             "SOCK0node"))) {
[13:20:28.888]                             sendCondition <<- function(cond) {
[13:20:28.888]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.888]                                 success = TRUE)
[13:20:28.888]                               parallel_sendData(master, data)
[13:20:28.888]                             }
[13:20:28.888]                             return(sendCondition)
[13:20:28.888]                           }
[13:20:28.888]                         }
[13:20:28.888]                         frame <- frame + 1L
[13:20:28.888]                         envir <- sys.frame(frame)
[13:20:28.888]                       }
[13:20:28.888]                     }
[13:20:28.888]                     sendCondition <<- function(cond) NULL
[13:20:28.888]                   }
[13:20:28.888]                 })
[13:20:28.888]                 withCallingHandlers({
[13:20:28.888]                   2
[13:20:28.888]                 }, immediateCondition = function(cond) {
[13:20:28.888]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.888]                   sendCondition(cond)
[13:20:28.888]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.888]                   {
[13:20:28.888]                     inherits <- base::inherits
[13:20:28.888]                     invokeRestart <- base::invokeRestart
[13:20:28.888]                     is.null <- base::is.null
[13:20:28.888]                     muffled <- FALSE
[13:20:28.888]                     if (inherits(cond, "message")) {
[13:20:28.888]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.888]                       if (muffled) 
[13:20:28.888]                         invokeRestart("muffleMessage")
[13:20:28.888]                     }
[13:20:28.888]                     else if (inherits(cond, "warning")) {
[13:20:28.888]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.888]                       if (muffled) 
[13:20:28.888]                         invokeRestart("muffleWarning")
[13:20:28.888]                     }
[13:20:28.888]                     else if (inherits(cond, "condition")) {
[13:20:28.888]                       if (!is.null(pattern)) {
[13:20:28.888]                         computeRestarts <- base::computeRestarts
[13:20:28.888]                         grepl <- base::grepl
[13:20:28.888]                         restarts <- computeRestarts(cond)
[13:20:28.888]                         for (restart in restarts) {
[13:20:28.888]                           name <- restart$name
[13:20:28.888]                           if (is.null(name)) 
[13:20:28.888]                             next
[13:20:28.888]                           if (!grepl(pattern, name)) 
[13:20:28.888]                             next
[13:20:28.888]                           invokeRestart(restart)
[13:20:28.888]                           muffled <- TRUE
[13:20:28.888]                           break
[13:20:28.888]                         }
[13:20:28.888]                       }
[13:20:28.888]                     }
[13:20:28.888]                     invisible(muffled)
[13:20:28.888]                   }
[13:20:28.888]                   muffleCondition(cond)
[13:20:28.888]                 })
[13:20:28.888]             }))
[13:20:28.888]             future::FutureResult(value = ...future.value$value, 
[13:20:28.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.888]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.888]                     ...future.globalenv.names))
[13:20:28.888]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.888]         }, condition = base::local({
[13:20:28.888]             c <- base::c
[13:20:28.888]             inherits <- base::inherits
[13:20:28.888]             invokeRestart <- base::invokeRestart
[13:20:28.888]             length <- base::length
[13:20:28.888]             list <- base::list
[13:20:28.888]             seq.int <- base::seq.int
[13:20:28.888]             signalCondition <- base::signalCondition
[13:20:28.888]             sys.calls <- base::sys.calls
[13:20:28.888]             `[[` <- base::`[[`
[13:20:28.888]             `+` <- base::`+`
[13:20:28.888]             `<<-` <- base::`<<-`
[13:20:28.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.888]                   3L)]
[13:20:28.888]             }
[13:20:28.888]             function(cond) {
[13:20:28.888]                 is_error <- inherits(cond, "error")
[13:20:28.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.888]                   NULL)
[13:20:28.888]                 if (is_error) {
[13:20:28.888]                   sessionInformation <- function() {
[13:20:28.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.888]                       search = base::search(), system = base::Sys.info())
[13:20:28.888]                   }
[13:20:28.888]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.888]                     cond$call), session = sessionInformation(), 
[13:20:28.888]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.888]                   signalCondition(cond)
[13:20:28.888]                 }
[13:20:28.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.888]                 "immediateCondition"))) {
[13:20:28.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.888]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.888]                   if (TRUE && !signal) {
[13:20:28.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.888]                     {
[13:20:28.888]                       inherits <- base::inherits
[13:20:28.888]                       invokeRestart <- base::invokeRestart
[13:20:28.888]                       is.null <- base::is.null
[13:20:28.888]                       muffled <- FALSE
[13:20:28.888]                       if (inherits(cond, "message")) {
[13:20:28.888]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.888]                         if (muffled) 
[13:20:28.888]                           invokeRestart("muffleMessage")
[13:20:28.888]                       }
[13:20:28.888]                       else if (inherits(cond, "warning")) {
[13:20:28.888]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.888]                         if (muffled) 
[13:20:28.888]                           invokeRestart("muffleWarning")
[13:20:28.888]                       }
[13:20:28.888]                       else if (inherits(cond, "condition")) {
[13:20:28.888]                         if (!is.null(pattern)) {
[13:20:28.888]                           computeRestarts <- base::computeRestarts
[13:20:28.888]                           grepl <- base::grepl
[13:20:28.888]                           restarts <- computeRestarts(cond)
[13:20:28.888]                           for (restart in restarts) {
[13:20:28.888]                             name <- restart$name
[13:20:28.888]                             if (is.null(name)) 
[13:20:28.888]                               next
[13:20:28.888]                             if (!grepl(pattern, name)) 
[13:20:28.888]                               next
[13:20:28.888]                             invokeRestart(restart)
[13:20:28.888]                             muffled <- TRUE
[13:20:28.888]                             break
[13:20:28.888]                           }
[13:20:28.888]                         }
[13:20:28.888]                       }
[13:20:28.888]                       invisible(muffled)
[13:20:28.888]                     }
[13:20:28.888]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.888]                   }
[13:20:28.888]                 }
[13:20:28.888]                 else {
[13:20:28.888]                   if (TRUE) {
[13:20:28.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.888]                     {
[13:20:28.888]                       inherits <- base::inherits
[13:20:28.888]                       invokeRestart <- base::invokeRestart
[13:20:28.888]                       is.null <- base::is.null
[13:20:28.888]                       muffled <- FALSE
[13:20:28.888]                       if (inherits(cond, "message")) {
[13:20:28.888]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.888]                         if (muffled) 
[13:20:28.888]                           invokeRestart("muffleMessage")
[13:20:28.888]                       }
[13:20:28.888]                       else if (inherits(cond, "warning")) {
[13:20:28.888]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.888]                         if (muffled) 
[13:20:28.888]                           invokeRestart("muffleWarning")
[13:20:28.888]                       }
[13:20:28.888]                       else if (inherits(cond, "condition")) {
[13:20:28.888]                         if (!is.null(pattern)) {
[13:20:28.888]                           computeRestarts <- base::computeRestarts
[13:20:28.888]                           grepl <- base::grepl
[13:20:28.888]                           restarts <- computeRestarts(cond)
[13:20:28.888]                           for (restart in restarts) {
[13:20:28.888]                             name <- restart$name
[13:20:28.888]                             if (is.null(name)) 
[13:20:28.888]                               next
[13:20:28.888]                             if (!grepl(pattern, name)) 
[13:20:28.888]                               next
[13:20:28.888]                             invokeRestart(restart)
[13:20:28.888]                             muffled <- TRUE
[13:20:28.888]                             break
[13:20:28.888]                           }
[13:20:28.888]                         }
[13:20:28.888]                       }
[13:20:28.888]                       invisible(muffled)
[13:20:28.888]                     }
[13:20:28.888]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.888]                   }
[13:20:28.888]                 }
[13:20:28.888]             }
[13:20:28.888]         }))
[13:20:28.888]     }, error = function(ex) {
[13:20:28.888]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.888]                 ...future.rng), started = ...future.startTime, 
[13:20:28.888]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.888]             version = "1.8"), class = "FutureResult")
[13:20:28.888]     }, finally = {
[13:20:28.888]         if (!identical(...future.workdir, getwd())) 
[13:20:28.888]             setwd(...future.workdir)
[13:20:28.888]         {
[13:20:28.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.888]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.888]             }
[13:20:28.888]             base::options(...future.oldOptions)
[13:20:28.888]             if (.Platform$OS.type == "windows") {
[13:20:28.888]                 old_names <- names(...future.oldEnvVars)
[13:20:28.888]                 envs <- base::Sys.getenv()
[13:20:28.888]                 names <- names(envs)
[13:20:28.888]                 common <- intersect(names, old_names)
[13:20:28.888]                 added <- setdiff(names, old_names)
[13:20:28.888]                 removed <- setdiff(old_names, names)
[13:20:28.888]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.888]                   envs[common]]
[13:20:28.888]                 NAMES <- toupper(changed)
[13:20:28.888]                 args <- list()
[13:20:28.888]                 for (kk in seq_along(NAMES)) {
[13:20:28.888]                   name <- changed[[kk]]
[13:20:28.888]                   NAME <- NAMES[[kk]]
[13:20:28.888]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.888]                     next
[13:20:28.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.888]                 }
[13:20:28.888]                 NAMES <- toupper(added)
[13:20:28.888]                 for (kk in seq_along(NAMES)) {
[13:20:28.888]                   name <- added[[kk]]
[13:20:28.888]                   NAME <- NAMES[[kk]]
[13:20:28.888]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.888]                     next
[13:20:28.888]                   args[[name]] <- ""
[13:20:28.888]                 }
[13:20:28.888]                 NAMES <- toupper(removed)
[13:20:28.888]                 for (kk in seq_along(NAMES)) {
[13:20:28.888]                   name <- removed[[kk]]
[13:20:28.888]                   NAME <- NAMES[[kk]]
[13:20:28.888]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.888]                     next
[13:20:28.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.888]                 }
[13:20:28.888]                 if (length(args) > 0) 
[13:20:28.888]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.888]             }
[13:20:28.888]             else {
[13:20:28.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.888]             }
[13:20:28.888]             {
[13:20:28.888]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.888]                   0L) {
[13:20:28.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.888]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.888]                   base::options(opts)
[13:20:28.888]                 }
[13:20:28.888]                 {
[13:20:28.888]                   {
[13:20:28.888]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.888]                     NULL
[13:20:28.888]                   }
[13:20:28.888]                   options(future.plan = NULL)
[13:20:28.888]                   if (is.na(NA_character_)) 
[13:20:28.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.888]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.888]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.888]                     envir = parent.frame()) 
[13:20:28.888]                   {
[13:20:28.888]                     if (is.function(workers)) 
[13:20:28.888]                       workers <- workers()
[13:20:28.888]                     workers <- structure(as.integer(workers), 
[13:20:28.888]                       class = class(workers))
[13:20:28.888]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.888]                       workers >= 1)
[13:20:28.888]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.888]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.888]                     }
[13:20:28.888]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.888]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.888]                       envir = envir)
[13:20:28.888]                     if (!future$lazy) 
[13:20:28.888]                       future <- run(future)
[13:20:28.888]                     invisible(future)
[13:20:28.888]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.888]                 }
[13:20:28.888]             }
[13:20:28.888]         }
[13:20:28.888]     })
[13:20:28.888]     if (TRUE) {
[13:20:28.888]         base::sink(type = "output", split = FALSE)
[13:20:28.888]         if (TRUE) {
[13:20:28.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.888]         }
[13:20:28.888]         else {
[13:20:28.888]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.888]         }
[13:20:28.888]         base::close(...future.stdout)
[13:20:28.888]         ...future.stdout <- NULL
[13:20:28.888]     }
[13:20:28.888]     ...future.result$conditions <- ...future.conditions
[13:20:28.888]     ...future.result$finished <- base::Sys.time()
[13:20:28.888]     ...future.result
[13:20:28.888] }
[13:20:28.891] MultisessionFuture started
[13:20:28.891] - Launch lazy future ... done
[13:20:28.891] run() for ‘MultisessionFuture’ ... done
[13:20:28.891] getGlobalsAndPackages() ...
[13:20:28.892] Searching for globals...
[13:20:28.892] 
[13:20:28.892] Searching for globals ... DONE
[13:20:28.892] - globals: [0] <none>
[13:20:28.892] getGlobalsAndPackages() ... DONE
[13:20:28.892] run() for ‘Future’ ...
[13:20:28.893] - state: ‘created’
[13:20:28.893] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.908] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.908]   - Field: ‘node’
[13:20:28.908]   - Field: ‘label’
[13:20:28.908]   - Field: ‘local’
[13:20:28.908]   - Field: ‘owner’
[13:20:28.908]   - Field: ‘envir’
[13:20:28.909]   - Field: ‘workers’
[13:20:28.909]   - Field: ‘packages’
[13:20:28.909]   - Field: ‘gc’
[13:20:28.909]   - Field: ‘conditions’
[13:20:28.909]   - Field: ‘persistent’
[13:20:28.909]   - Field: ‘expr’
[13:20:28.909]   - Field: ‘uuid’
[13:20:28.909]   - Field: ‘seed’
[13:20:28.909]   - Field: ‘version’
[13:20:28.909]   - Field: ‘result’
[13:20:28.910]   - Field: ‘asynchronous’
[13:20:28.910]   - Field: ‘calls’
[13:20:28.910]   - Field: ‘globals’
[13:20:28.910]   - Field: ‘stdout’
[13:20:28.910]   - Field: ‘earlySignal’
[13:20:28.910]   - Field: ‘lazy’
[13:20:28.910]   - Field: ‘state’
[13:20:28.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.910] - Launch lazy future ...
[13:20:28.911] Packages needed by the future expression (n = 0): <none>
[13:20:28.911] Packages needed by future strategies (n = 0): <none>
[13:20:28.911] {
[13:20:28.911]     {
[13:20:28.911]         {
[13:20:28.911]             ...future.startTime <- base::Sys.time()
[13:20:28.911]             {
[13:20:28.911]                 {
[13:20:28.911]                   {
[13:20:28.911]                     {
[13:20:28.911]                       base::local({
[13:20:28.911]                         has_future <- base::requireNamespace("future", 
[13:20:28.911]                           quietly = TRUE)
[13:20:28.911]                         if (has_future) {
[13:20:28.911]                           ns <- base::getNamespace("future")
[13:20:28.911]                           version <- ns[[".package"]][["version"]]
[13:20:28.911]                           if (is.null(version)) 
[13:20:28.911]                             version <- utils::packageVersion("future")
[13:20:28.911]                         }
[13:20:28.911]                         else {
[13:20:28.911]                           version <- NULL
[13:20:28.911]                         }
[13:20:28.911]                         if (!has_future || version < "1.8.0") {
[13:20:28.911]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.911]                             "", base::R.version$version.string), 
[13:20:28.911]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.911]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.911]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.911]                               "release", "version")], collapse = " "), 
[13:20:28.911]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.911]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.911]                             info)
[13:20:28.911]                           info <- base::paste(info, collapse = "; ")
[13:20:28.911]                           if (!has_future) {
[13:20:28.911]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.911]                               info)
[13:20:28.911]                           }
[13:20:28.911]                           else {
[13:20:28.911]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.911]                               info, version)
[13:20:28.911]                           }
[13:20:28.911]                           base::stop(msg)
[13:20:28.911]                         }
[13:20:28.911]                       })
[13:20:28.911]                     }
[13:20:28.911]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.911]                     base::options(mc.cores = 1L)
[13:20:28.911]                   }
[13:20:28.911]                   options(future.plan = NULL)
[13:20:28.911]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.911]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.911]                 }
[13:20:28.911]                 ...future.workdir <- getwd()
[13:20:28.911]             }
[13:20:28.911]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.911]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.911]         }
[13:20:28.911]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.911]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.911]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.911]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.911]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.911]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.911]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.911]             base::names(...future.oldOptions))
[13:20:28.911]     }
[13:20:28.911]     if (FALSE) {
[13:20:28.911]     }
[13:20:28.911]     else {
[13:20:28.911]         if (TRUE) {
[13:20:28.911]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.911]                 open = "w")
[13:20:28.911]         }
[13:20:28.911]         else {
[13:20:28.911]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.911]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.911]         }
[13:20:28.911]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.911]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.911]             base::sink(type = "output", split = FALSE)
[13:20:28.911]             base::close(...future.stdout)
[13:20:28.911]         }, add = TRUE)
[13:20:28.911]     }
[13:20:28.911]     ...future.frame <- base::sys.nframe()
[13:20:28.911]     ...future.conditions <- base::list()
[13:20:28.911]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.911]     if (FALSE) {
[13:20:28.911]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.911]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.911]     }
[13:20:28.911]     ...future.result <- base::tryCatch({
[13:20:28.911]         base::withCallingHandlers({
[13:20:28.911]             ...future.value <- base::withVisible(base::local({
[13:20:28.911]                 ...future.makeSendCondition <- local({
[13:20:28.911]                   sendCondition <- NULL
[13:20:28.911]                   function(frame = 1L) {
[13:20:28.911]                     if (is.function(sendCondition)) 
[13:20:28.911]                       return(sendCondition)
[13:20:28.911]                     ns <- getNamespace("parallel")
[13:20:28.911]                     if (exists("sendData", mode = "function", 
[13:20:28.911]                       envir = ns)) {
[13:20:28.911]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.911]                         envir = ns)
[13:20:28.911]                       envir <- sys.frame(frame)
[13:20:28.911]                       master <- NULL
[13:20:28.911]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.911]                         !identical(envir, emptyenv())) {
[13:20:28.911]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.911]                           inherits = FALSE)) {
[13:20:28.911]                           master <- get("master", mode = "list", 
[13:20:28.911]                             envir = envir, inherits = FALSE)
[13:20:28.911]                           if (inherits(master, c("SOCKnode", 
[13:20:28.911]                             "SOCK0node"))) {
[13:20:28.911]                             sendCondition <<- function(cond) {
[13:20:28.911]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.911]                                 success = TRUE)
[13:20:28.911]                               parallel_sendData(master, data)
[13:20:28.911]                             }
[13:20:28.911]                             return(sendCondition)
[13:20:28.911]                           }
[13:20:28.911]                         }
[13:20:28.911]                         frame <- frame + 1L
[13:20:28.911]                         envir <- sys.frame(frame)
[13:20:28.911]                       }
[13:20:28.911]                     }
[13:20:28.911]                     sendCondition <<- function(cond) NULL
[13:20:28.911]                   }
[13:20:28.911]                 })
[13:20:28.911]                 withCallingHandlers({
[13:20:28.911]                   NULL
[13:20:28.911]                 }, immediateCondition = function(cond) {
[13:20:28.911]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.911]                   sendCondition(cond)
[13:20:28.911]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.911]                   {
[13:20:28.911]                     inherits <- base::inherits
[13:20:28.911]                     invokeRestart <- base::invokeRestart
[13:20:28.911]                     is.null <- base::is.null
[13:20:28.911]                     muffled <- FALSE
[13:20:28.911]                     if (inherits(cond, "message")) {
[13:20:28.911]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.911]                       if (muffled) 
[13:20:28.911]                         invokeRestart("muffleMessage")
[13:20:28.911]                     }
[13:20:28.911]                     else if (inherits(cond, "warning")) {
[13:20:28.911]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.911]                       if (muffled) 
[13:20:28.911]                         invokeRestart("muffleWarning")
[13:20:28.911]                     }
[13:20:28.911]                     else if (inherits(cond, "condition")) {
[13:20:28.911]                       if (!is.null(pattern)) {
[13:20:28.911]                         computeRestarts <- base::computeRestarts
[13:20:28.911]                         grepl <- base::grepl
[13:20:28.911]                         restarts <- computeRestarts(cond)
[13:20:28.911]                         for (restart in restarts) {
[13:20:28.911]                           name <- restart$name
[13:20:28.911]                           if (is.null(name)) 
[13:20:28.911]                             next
[13:20:28.911]                           if (!grepl(pattern, name)) 
[13:20:28.911]                             next
[13:20:28.911]                           invokeRestart(restart)
[13:20:28.911]                           muffled <- TRUE
[13:20:28.911]                           break
[13:20:28.911]                         }
[13:20:28.911]                       }
[13:20:28.911]                     }
[13:20:28.911]                     invisible(muffled)
[13:20:28.911]                   }
[13:20:28.911]                   muffleCondition(cond)
[13:20:28.911]                 })
[13:20:28.911]             }))
[13:20:28.911]             future::FutureResult(value = ...future.value$value, 
[13:20:28.911]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.911]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.911]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.911]                     ...future.globalenv.names))
[13:20:28.911]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.911]         }, condition = base::local({
[13:20:28.911]             c <- base::c
[13:20:28.911]             inherits <- base::inherits
[13:20:28.911]             invokeRestart <- base::invokeRestart
[13:20:28.911]             length <- base::length
[13:20:28.911]             list <- base::list
[13:20:28.911]             seq.int <- base::seq.int
[13:20:28.911]             signalCondition <- base::signalCondition
[13:20:28.911]             sys.calls <- base::sys.calls
[13:20:28.911]             `[[` <- base::`[[`
[13:20:28.911]             `+` <- base::`+`
[13:20:28.911]             `<<-` <- base::`<<-`
[13:20:28.911]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.911]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.911]                   3L)]
[13:20:28.911]             }
[13:20:28.911]             function(cond) {
[13:20:28.911]                 is_error <- inherits(cond, "error")
[13:20:28.911]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.911]                   NULL)
[13:20:28.911]                 if (is_error) {
[13:20:28.911]                   sessionInformation <- function() {
[13:20:28.911]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.911]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.911]                       search = base::search(), system = base::Sys.info())
[13:20:28.911]                   }
[13:20:28.911]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.911]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.911]                     cond$call), session = sessionInformation(), 
[13:20:28.911]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.911]                   signalCondition(cond)
[13:20:28.911]                 }
[13:20:28.911]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.911]                 "immediateCondition"))) {
[13:20:28.911]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.911]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.911]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.911]                   if (TRUE && !signal) {
[13:20:28.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.911]                     {
[13:20:28.911]                       inherits <- base::inherits
[13:20:28.911]                       invokeRestart <- base::invokeRestart
[13:20:28.911]                       is.null <- base::is.null
[13:20:28.911]                       muffled <- FALSE
[13:20:28.911]                       if (inherits(cond, "message")) {
[13:20:28.911]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.911]                         if (muffled) 
[13:20:28.911]                           invokeRestart("muffleMessage")
[13:20:28.911]                       }
[13:20:28.911]                       else if (inherits(cond, "warning")) {
[13:20:28.911]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.911]                         if (muffled) 
[13:20:28.911]                           invokeRestart("muffleWarning")
[13:20:28.911]                       }
[13:20:28.911]                       else if (inherits(cond, "condition")) {
[13:20:28.911]                         if (!is.null(pattern)) {
[13:20:28.911]                           computeRestarts <- base::computeRestarts
[13:20:28.911]                           grepl <- base::grepl
[13:20:28.911]                           restarts <- computeRestarts(cond)
[13:20:28.911]                           for (restart in restarts) {
[13:20:28.911]                             name <- restart$name
[13:20:28.911]                             if (is.null(name)) 
[13:20:28.911]                               next
[13:20:28.911]                             if (!grepl(pattern, name)) 
[13:20:28.911]                               next
[13:20:28.911]                             invokeRestart(restart)
[13:20:28.911]                             muffled <- TRUE
[13:20:28.911]                             break
[13:20:28.911]                           }
[13:20:28.911]                         }
[13:20:28.911]                       }
[13:20:28.911]                       invisible(muffled)
[13:20:28.911]                     }
[13:20:28.911]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.911]                   }
[13:20:28.911]                 }
[13:20:28.911]                 else {
[13:20:28.911]                   if (TRUE) {
[13:20:28.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.911]                     {
[13:20:28.911]                       inherits <- base::inherits
[13:20:28.911]                       invokeRestart <- base::invokeRestart
[13:20:28.911]                       is.null <- base::is.null
[13:20:28.911]                       muffled <- FALSE
[13:20:28.911]                       if (inherits(cond, "message")) {
[13:20:28.911]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.911]                         if (muffled) 
[13:20:28.911]                           invokeRestart("muffleMessage")
[13:20:28.911]                       }
[13:20:28.911]                       else if (inherits(cond, "warning")) {
[13:20:28.911]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.911]                         if (muffled) 
[13:20:28.911]                           invokeRestart("muffleWarning")
[13:20:28.911]                       }
[13:20:28.911]                       else if (inherits(cond, "condition")) {
[13:20:28.911]                         if (!is.null(pattern)) {
[13:20:28.911]                           computeRestarts <- base::computeRestarts
[13:20:28.911]                           grepl <- base::grepl
[13:20:28.911]                           restarts <- computeRestarts(cond)
[13:20:28.911]                           for (restart in restarts) {
[13:20:28.911]                             name <- restart$name
[13:20:28.911]                             if (is.null(name)) 
[13:20:28.911]                               next
[13:20:28.911]                             if (!grepl(pattern, name)) 
[13:20:28.911]                               next
[13:20:28.911]                             invokeRestart(restart)
[13:20:28.911]                             muffled <- TRUE
[13:20:28.911]                             break
[13:20:28.911]                           }
[13:20:28.911]                         }
[13:20:28.911]                       }
[13:20:28.911]                       invisible(muffled)
[13:20:28.911]                     }
[13:20:28.911]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.911]                   }
[13:20:28.911]                 }
[13:20:28.911]             }
[13:20:28.911]         }))
[13:20:28.911]     }, error = function(ex) {
[13:20:28.911]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.911]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.911]                 ...future.rng), started = ...future.startTime, 
[13:20:28.911]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.911]             version = "1.8"), class = "FutureResult")
[13:20:28.911]     }, finally = {
[13:20:28.911]         if (!identical(...future.workdir, getwd())) 
[13:20:28.911]             setwd(...future.workdir)
[13:20:28.911]         {
[13:20:28.911]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.911]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.911]             }
[13:20:28.911]             base::options(...future.oldOptions)
[13:20:28.911]             if (.Platform$OS.type == "windows") {
[13:20:28.911]                 old_names <- names(...future.oldEnvVars)
[13:20:28.911]                 envs <- base::Sys.getenv()
[13:20:28.911]                 names <- names(envs)
[13:20:28.911]                 common <- intersect(names, old_names)
[13:20:28.911]                 added <- setdiff(names, old_names)
[13:20:28.911]                 removed <- setdiff(old_names, names)
[13:20:28.911]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.911]                   envs[common]]
[13:20:28.911]                 NAMES <- toupper(changed)
[13:20:28.911]                 args <- list()
[13:20:28.911]                 for (kk in seq_along(NAMES)) {
[13:20:28.911]                   name <- changed[[kk]]
[13:20:28.911]                   NAME <- NAMES[[kk]]
[13:20:28.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.911]                     next
[13:20:28.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.911]                 }
[13:20:28.911]                 NAMES <- toupper(added)
[13:20:28.911]                 for (kk in seq_along(NAMES)) {
[13:20:28.911]                   name <- added[[kk]]
[13:20:28.911]                   NAME <- NAMES[[kk]]
[13:20:28.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.911]                     next
[13:20:28.911]                   args[[name]] <- ""
[13:20:28.911]                 }
[13:20:28.911]                 NAMES <- toupper(removed)
[13:20:28.911]                 for (kk in seq_along(NAMES)) {
[13:20:28.911]                   name <- removed[[kk]]
[13:20:28.911]                   NAME <- NAMES[[kk]]
[13:20:28.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.911]                     next
[13:20:28.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.911]                 }
[13:20:28.911]                 if (length(args) > 0) 
[13:20:28.911]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.911]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.911]             }
[13:20:28.911]             else {
[13:20:28.911]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.911]             }
[13:20:28.911]             {
[13:20:28.911]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.911]                   0L) {
[13:20:28.911]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.911]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.911]                   base::options(opts)
[13:20:28.911]                 }
[13:20:28.911]                 {
[13:20:28.911]                   {
[13:20:28.911]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.911]                     NULL
[13:20:28.911]                   }
[13:20:28.911]                   options(future.plan = NULL)
[13:20:28.911]                   if (is.na(NA_character_)) 
[13:20:28.911]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.911]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.911]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.911]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.911]                     envir = parent.frame()) 
[13:20:28.911]                   {
[13:20:28.911]                     if (is.function(workers)) 
[13:20:28.911]                       workers <- workers()
[13:20:28.911]                     workers <- structure(as.integer(workers), 
[13:20:28.911]                       class = class(workers))
[13:20:28.911]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.911]                       workers >= 1)
[13:20:28.911]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.911]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.911]                     }
[13:20:28.911]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.911]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.911]                       envir = envir)
[13:20:28.911]                     if (!future$lazy) 
[13:20:28.911]                       future <- run(future)
[13:20:28.911]                     invisible(future)
[13:20:28.911]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.911]                 }
[13:20:28.911]             }
[13:20:28.911]         }
[13:20:28.911]     })
[13:20:28.911]     if (TRUE) {
[13:20:28.911]         base::sink(type = "output", split = FALSE)
[13:20:28.911]         if (TRUE) {
[13:20:28.911]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.911]         }
[13:20:28.911]         else {
[13:20:28.911]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.911]         }
[13:20:28.911]         base::close(...future.stdout)
[13:20:28.911]         ...future.stdout <- NULL
[13:20:28.911]     }
[13:20:28.911]     ...future.result$conditions <- ...future.conditions
[13:20:28.911]     ...future.result$finished <- base::Sys.time()
[13:20:28.911]     ...future.result
[13:20:28.911] }
[13:20:28.915] MultisessionFuture started
[13:20:28.915] - Launch lazy future ... done
[13:20:28.915] run() for ‘MultisessionFuture’ ... done
[13:20:28.916] getGlobalsAndPackages() ...
[13:20:28.916] Searching for globals...
[13:20:28.916] - globals found: [1] ‘{’
[13:20:28.916] Searching for globals ... DONE
[13:20:28.917] Resolving globals: FALSE
[13:20:28.917] 
[13:20:28.917] 
[13:20:28.917] getGlobalsAndPackages() ... DONE
[13:20:28.917] run() for ‘Future’ ...
[13:20:28.918] - state: ‘created’
[13:20:28.918] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:28.933] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:28.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:28.933]   - Field: ‘node’
[13:20:28.933]   - Field: ‘label’
[13:20:28.933]   - Field: ‘local’
[13:20:28.933]   - Field: ‘owner’
[13:20:28.934]   - Field: ‘envir’
[13:20:28.934]   - Field: ‘workers’
[13:20:28.934]   - Field: ‘packages’
[13:20:28.934]   - Field: ‘gc’
[13:20:28.934]   - Field: ‘conditions’
[13:20:28.934]   - Field: ‘persistent’
[13:20:28.934]   - Field: ‘expr’
[13:20:28.934]   - Field: ‘uuid’
[13:20:28.934]   - Field: ‘seed’
[13:20:28.934]   - Field: ‘version’
[13:20:28.934]   - Field: ‘result’
[13:20:28.935]   - Field: ‘asynchronous’
[13:20:28.935]   - Field: ‘calls’
[13:20:28.935]   - Field: ‘globals’
[13:20:28.935]   - Field: ‘stdout’
[13:20:28.935]   - Field: ‘earlySignal’
[13:20:28.935]   - Field: ‘lazy’
[13:20:28.935]   - Field: ‘state’
[13:20:28.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:28.935] - Launch lazy future ...
[13:20:28.936] Packages needed by the future expression (n = 0): <none>
[13:20:28.936] Packages needed by future strategies (n = 0): <none>
[13:20:28.936] {
[13:20:28.936]     {
[13:20:28.936]         {
[13:20:28.936]             ...future.startTime <- base::Sys.time()
[13:20:28.936]             {
[13:20:28.936]                 {
[13:20:28.936]                   {
[13:20:28.936]                     {
[13:20:28.936]                       base::local({
[13:20:28.936]                         has_future <- base::requireNamespace("future", 
[13:20:28.936]                           quietly = TRUE)
[13:20:28.936]                         if (has_future) {
[13:20:28.936]                           ns <- base::getNamespace("future")
[13:20:28.936]                           version <- ns[[".package"]][["version"]]
[13:20:28.936]                           if (is.null(version)) 
[13:20:28.936]                             version <- utils::packageVersion("future")
[13:20:28.936]                         }
[13:20:28.936]                         else {
[13:20:28.936]                           version <- NULL
[13:20:28.936]                         }
[13:20:28.936]                         if (!has_future || version < "1.8.0") {
[13:20:28.936]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:28.936]                             "", base::R.version$version.string), 
[13:20:28.936]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:28.936]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:28.936]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:28.936]                               "release", "version")], collapse = " "), 
[13:20:28.936]                             hostname = base::Sys.info()[["nodename"]])
[13:20:28.936]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:28.936]                             info)
[13:20:28.936]                           info <- base::paste(info, collapse = "; ")
[13:20:28.936]                           if (!has_future) {
[13:20:28.936]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:28.936]                               info)
[13:20:28.936]                           }
[13:20:28.936]                           else {
[13:20:28.936]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:28.936]                               info, version)
[13:20:28.936]                           }
[13:20:28.936]                           base::stop(msg)
[13:20:28.936]                         }
[13:20:28.936]                       })
[13:20:28.936]                     }
[13:20:28.936]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:28.936]                     base::options(mc.cores = 1L)
[13:20:28.936]                   }
[13:20:28.936]                   options(future.plan = NULL)
[13:20:28.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:28.936]                 }
[13:20:28.936]                 ...future.workdir <- getwd()
[13:20:28.936]             }
[13:20:28.936]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:28.936]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:28.936]         }
[13:20:28.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:28.936]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:28.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:28.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:28.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:28.936]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:28.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:28.936]             base::names(...future.oldOptions))
[13:20:28.936]     }
[13:20:28.936]     if (FALSE) {
[13:20:28.936]     }
[13:20:28.936]     else {
[13:20:28.936]         if (TRUE) {
[13:20:28.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:28.936]                 open = "w")
[13:20:28.936]         }
[13:20:28.936]         else {
[13:20:28.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:28.936]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:28.936]         }
[13:20:28.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:28.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:28.936]             base::sink(type = "output", split = FALSE)
[13:20:28.936]             base::close(...future.stdout)
[13:20:28.936]         }, add = TRUE)
[13:20:28.936]     }
[13:20:28.936]     ...future.frame <- base::sys.nframe()
[13:20:28.936]     ...future.conditions <- base::list()
[13:20:28.936]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:28.936]     if (FALSE) {
[13:20:28.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:28.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:28.936]     }
[13:20:28.936]     ...future.result <- base::tryCatch({
[13:20:28.936]         base::withCallingHandlers({
[13:20:28.936]             ...future.value <- base::withVisible(base::local({
[13:20:28.936]                 ...future.makeSendCondition <- local({
[13:20:28.936]                   sendCondition <- NULL
[13:20:28.936]                   function(frame = 1L) {
[13:20:28.936]                     if (is.function(sendCondition)) 
[13:20:28.936]                       return(sendCondition)
[13:20:28.936]                     ns <- getNamespace("parallel")
[13:20:28.936]                     if (exists("sendData", mode = "function", 
[13:20:28.936]                       envir = ns)) {
[13:20:28.936]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:28.936]                         envir = ns)
[13:20:28.936]                       envir <- sys.frame(frame)
[13:20:28.936]                       master <- NULL
[13:20:28.936]                       while (!identical(envir, .GlobalEnv) && 
[13:20:28.936]                         !identical(envir, emptyenv())) {
[13:20:28.936]                         if (exists("master", mode = "list", envir = envir, 
[13:20:28.936]                           inherits = FALSE)) {
[13:20:28.936]                           master <- get("master", mode = "list", 
[13:20:28.936]                             envir = envir, inherits = FALSE)
[13:20:28.936]                           if (inherits(master, c("SOCKnode", 
[13:20:28.936]                             "SOCK0node"))) {
[13:20:28.936]                             sendCondition <<- function(cond) {
[13:20:28.936]                               data <- list(type = "VALUE", value = cond, 
[13:20:28.936]                                 success = TRUE)
[13:20:28.936]                               parallel_sendData(master, data)
[13:20:28.936]                             }
[13:20:28.936]                             return(sendCondition)
[13:20:28.936]                           }
[13:20:28.936]                         }
[13:20:28.936]                         frame <- frame + 1L
[13:20:28.936]                         envir <- sys.frame(frame)
[13:20:28.936]                       }
[13:20:28.936]                     }
[13:20:28.936]                     sendCondition <<- function(cond) NULL
[13:20:28.936]                   }
[13:20:28.936]                 })
[13:20:28.936]                 withCallingHandlers({
[13:20:28.936]                   {
[13:20:28.936]                     4
[13:20:28.936]                   }
[13:20:28.936]                 }, immediateCondition = function(cond) {
[13:20:28.936]                   sendCondition <- ...future.makeSendCondition()
[13:20:28.936]                   sendCondition(cond)
[13:20:28.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.936]                   {
[13:20:28.936]                     inherits <- base::inherits
[13:20:28.936]                     invokeRestart <- base::invokeRestart
[13:20:28.936]                     is.null <- base::is.null
[13:20:28.936]                     muffled <- FALSE
[13:20:28.936]                     if (inherits(cond, "message")) {
[13:20:28.936]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:28.936]                       if (muffled) 
[13:20:28.936]                         invokeRestart("muffleMessage")
[13:20:28.936]                     }
[13:20:28.936]                     else if (inherits(cond, "warning")) {
[13:20:28.936]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:28.936]                       if (muffled) 
[13:20:28.936]                         invokeRestart("muffleWarning")
[13:20:28.936]                     }
[13:20:28.936]                     else if (inherits(cond, "condition")) {
[13:20:28.936]                       if (!is.null(pattern)) {
[13:20:28.936]                         computeRestarts <- base::computeRestarts
[13:20:28.936]                         grepl <- base::grepl
[13:20:28.936]                         restarts <- computeRestarts(cond)
[13:20:28.936]                         for (restart in restarts) {
[13:20:28.936]                           name <- restart$name
[13:20:28.936]                           if (is.null(name)) 
[13:20:28.936]                             next
[13:20:28.936]                           if (!grepl(pattern, name)) 
[13:20:28.936]                             next
[13:20:28.936]                           invokeRestart(restart)
[13:20:28.936]                           muffled <- TRUE
[13:20:28.936]                           break
[13:20:28.936]                         }
[13:20:28.936]                       }
[13:20:28.936]                     }
[13:20:28.936]                     invisible(muffled)
[13:20:28.936]                   }
[13:20:28.936]                   muffleCondition(cond)
[13:20:28.936]                 })
[13:20:28.936]             }))
[13:20:28.936]             future::FutureResult(value = ...future.value$value, 
[13:20:28.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.936]                   ...future.rng), globalenv = if (FALSE) 
[13:20:28.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:28.936]                     ...future.globalenv.names))
[13:20:28.936]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:28.936]         }, condition = base::local({
[13:20:28.936]             c <- base::c
[13:20:28.936]             inherits <- base::inherits
[13:20:28.936]             invokeRestart <- base::invokeRestart
[13:20:28.936]             length <- base::length
[13:20:28.936]             list <- base::list
[13:20:28.936]             seq.int <- base::seq.int
[13:20:28.936]             signalCondition <- base::signalCondition
[13:20:28.936]             sys.calls <- base::sys.calls
[13:20:28.936]             `[[` <- base::`[[`
[13:20:28.936]             `+` <- base::`+`
[13:20:28.936]             `<<-` <- base::`<<-`
[13:20:28.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:28.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:28.936]                   3L)]
[13:20:28.936]             }
[13:20:28.936]             function(cond) {
[13:20:28.936]                 is_error <- inherits(cond, "error")
[13:20:28.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:28.936]                   NULL)
[13:20:28.936]                 if (is_error) {
[13:20:28.936]                   sessionInformation <- function() {
[13:20:28.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:28.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:28.936]                       search = base::search(), system = base::Sys.info())
[13:20:28.936]                   }
[13:20:28.936]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:28.936]                     cond$call), session = sessionInformation(), 
[13:20:28.936]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:28.936]                   signalCondition(cond)
[13:20:28.936]                 }
[13:20:28.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:28.936]                 "immediateCondition"))) {
[13:20:28.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:28.936]                   ...future.conditions[[length(...future.conditions) + 
[13:20:28.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:28.936]                   if (TRUE && !signal) {
[13:20:28.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.936]                     {
[13:20:28.936]                       inherits <- base::inherits
[13:20:28.936]                       invokeRestart <- base::invokeRestart
[13:20:28.936]                       is.null <- base::is.null
[13:20:28.936]                       muffled <- FALSE
[13:20:28.936]                       if (inherits(cond, "message")) {
[13:20:28.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.936]                         if (muffled) 
[13:20:28.936]                           invokeRestart("muffleMessage")
[13:20:28.936]                       }
[13:20:28.936]                       else if (inherits(cond, "warning")) {
[13:20:28.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.936]                         if (muffled) 
[13:20:28.936]                           invokeRestart("muffleWarning")
[13:20:28.936]                       }
[13:20:28.936]                       else if (inherits(cond, "condition")) {
[13:20:28.936]                         if (!is.null(pattern)) {
[13:20:28.936]                           computeRestarts <- base::computeRestarts
[13:20:28.936]                           grepl <- base::grepl
[13:20:28.936]                           restarts <- computeRestarts(cond)
[13:20:28.936]                           for (restart in restarts) {
[13:20:28.936]                             name <- restart$name
[13:20:28.936]                             if (is.null(name)) 
[13:20:28.936]                               next
[13:20:28.936]                             if (!grepl(pattern, name)) 
[13:20:28.936]                               next
[13:20:28.936]                             invokeRestart(restart)
[13:20:28.936]                             muffled <- TRUE
[13:20:28.936]                             break
[13:20:28.936]                           }
[13:20:28.936]                         }
[13:20:28.936]                       }
[13:20:28.936]                       invisible(muffled)
[13:20:28.936]                     }
[13:20:28.936]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.936]                   }
[13:20:28.936]                 }
[13:20:28.936]                 else {
[13:20:28.936]                   if (TRUE) {
[13:20:28.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:28.936]                     {
[13:20:28.936]                       inherits <- base::inherits
[13:20:28.936]                       invokeRestart <- base::invokeRestart
[13:20:28.936]                       is.null <- base::is.null
[13:20:28.936]                       muffled <- FALSE
[13:20:28.936]                       if (inherits(cond, "message")) {
[13:20:28.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:28.936]                         if (muffled) 
[13:20:28.936]                           invokeRestart("muffleMessage")
[13:20:28.936]                       }
[13:20:28.936]                       else if (inherits(cond, "warning")) {
[13:20:28.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:28.936]                         if (muffled) 
[13:20:28.936]                           invokeRestart("muffleWarning")
[13:20:28.936]                       }
[13:20:28.936]                       else if (inherits(cond, "condition")) {
[13:20:28.936]                         if (!is.null(pattern)) {
[13:20:28.936]                           computeRestarts <- base::computeRestarts
[13:20:28.936]                           grepl <- base::grepl
[13:20:28.936]                           restarts <- computeRestarts(cond)
[13:20:28.936]                           for (restart in restarts) {
[13:20:28.936]                             name <- restart$name
[13:20:28.936]                             if (is.null(name)) 
[13:20:28.936]                               next
[13:20:28.936]                             if (!grepl(pattern, name)) 
[13:20:28.936]                               next
[13:20:28.936]                             invokeRestart(restart)
[13:20:28.936]                             muffled <- TRUE
[13:20:28.936]                             break
[13:20:28.936]                           }
[13:20:28.936]                         }
[13:20:28.936]                       }
[13:20:28.936]                       invisible(muffled)
[13:20:28.936]                     }
[13:20:28.936]                     muffleCondition(cond, pattern = "^muffle")
[13:20:28.936]                   }
[13:20:28.936]                 }
[13:20:28.936]             }
[13:20:28.936]         }))
[13:20:28.936]     }, error = function(ex) {
[13:20:28.936]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:28.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:28.936]                 ...future.rng), started = ...future.startTime, 
[13:20:28.936]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:28.936]             version = "1.8"), class = "FutureResult")
[13:20:28.936]     }, finally = {
[13:20:28.936]         if (!identical(...future.workdir, getwd())) 
[13:20:28.936]             setwd(...future.workdir)
[13:20:28.936]         {
[13:20:28.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:28.936]                 ...future.oldOptions$nwarnings <- NULL
[13:20:28.936]             }
[13:20:28.936]             base::options(...future.oldOptions)
[13:20:28.936]             if (.Platform$OS.type == "windows") {
[13:20:28.936]                 old_names <- names(...future.oldEnvVars)
[13:20:28.936]                 envs <- base::Sys.getenv()
[13:20:28.936]                 names <- names(envs)
[13:20:28.936]                 common <- intersect(names, old_names)
[13:20:28.936]                 added <- setdiff(names, old_names)
[13:20:28.936]                 removed <- setdiff(old_names, names)
[13:20:28.936]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:28.936]                   envs[common]]
[13:20:28.936]                 NAMES <- toupper(changed)
[13:20:28.936]                 args <- list()
[13:20:28.936]                 for (kk in seq_along(NAMES)) {
[13:20:28.936]                   name <- changed[[kk]]
[13:20:28.936]                   NAME <- NAMES[[kk]]
[13:20:28.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.936]                     next
[13:20:28.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.936]                 }
[13:20:28.936]                 NAMES <- toupper(added)
[13:20:28.936]                 for (kk in seq_along(NAMES)) {
[13:20:28.936]                   name <- added[[kk]]
[13:20:28.936]                   NAME <- NAMES[[kk]]
[13:20:28.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.936]                     next
[13:20:28.936]                   args[[name]] <- ""
[13:20:28.936]                 }
[13:20:28.936]                 NAMES <- toupper(removed)
[13:20:28.936]                 for (kk in seq_along(NAMES)) {
[13:20:28.936]                   name <- removed[[kk]]
[13:20:28.936]                   NAME <- NAMES[[kk]]
[13:20:28.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:28.936]                     next
[13:20:28.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:28.936]                 }
[13:20:28.936]                 if (length(args) > 0) 
[13:20:28.936]                   base::do.call(base::Sys.setenv, args = args)
[13:20:28.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:28.936]             }
[13:20:28.936]             else {
[13:20:28.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:28.936]             }
[13:20:28.936]             {
[13:20:28.936]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:28.936]                   0L) {
[13:20:28.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:28.936]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:28.936]                   base::options(opts)
[13:20:28.936]                 }
[13:20:28.936]                 {
[13:20:28.936]                   {
[13:20:28.936]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:28.936]                     NULL
[13:20:28.936]                   }
[13:20:28.936]                   options(future.plan = NULL)
[13:20:28.936]                   if (is.na(NA_character_)) 
[13:20:28.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:28.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:28.936]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:28.936]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:28.936]                     envir = parent.frame()) 
[13:20:28.936]                   {
[13:20:28.936]                     if (is.function(workers)) 
[13:20:28.936]                       workers <- workers()
[13:20:28.936]                     workers <- structure(as.integer(workers), 
[13:20:28.936]                       class = class(workers))
[13:20:28.936]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:28.936]                       workers >= 1)
[13:20:28.936]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:28.936]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:28.936]                     }
[13:20:28.936]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:28.936]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:28.936]                       envir = envir)
[13:20:28.936]                     if (!future$lazy) 
[13:20:28.936]                       future <- run(future)
[13:20:28.936]                     invisible(future)
[13:20:28.936]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:28.936]                 }
[13:20:28.936]             }
[13:20:28.936]         }
[13:20:28.936]     })
[13:20:28.936]     if (TRUE) {
[13:20:28.936]         base::sink(type = "output", split = FALSE)
[13:20:28.936]         if (TRUE) {
[13:20:28.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:28.936]         }
[13:20:28.936]         else {
[13:20:28.936]             ...future.result["stdout"] <- base::list(NULL)
[13:20:28.936]         }
[13:20:28.936]         base::close(...future.stdout)
[13:20:28.936]         ...future.stdout <- NULL
[13:20:28.936]     }
[13:20:28.936]     ...future.result$conditions <- ...future.conditions
[13:20:28.936]     ...future.result$finished <- base::Sys.time()
[13:20:28.936]     ...future.result
[13:20:28.936] }
[13:20:28.939] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:28.950] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.950] - Validating connection of MultisessionFuture
[13:20:28.953] - received message: FutureResult
[13:20:28.953] - Received FutureResult
[13:20:28.953] - Erased future from FutureRegistry
[13:20:28.953] result() for ClusterFuture ...
[13:20:28.954] - result already collected: FutureResult
[13:20:28.954] result() for ClusterFuture ... done
[13:20:28.954] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:28.954] result() for ClusterFuture ...
[13:20:28.954] - result already collected: FutureResult
[13:20:28.954] result() for ClusterFuture ... done
[13:20:28.954] result() for ClusterFuture ...
[13:20:28.954] - result already collected: FutureResult
[13:20:28.954] result() for ClusterFuture ... done
[13:20:28.955] MultisessionFuture started
[13:20:28.956] - Launch lazy future ... done
[13:20:28.956] run() for ‘MultisessionFuture’ ... done
<environment: 0x55659cabda78> 
<environment: 0x55659c299e18> 
[13:20:28.966] receiveMessageFromWorker() for ClusterFuture ...
[13:20:28.966] - Validating connection of MultisessionFuture
[13:20:28.967] - received message: FutureResult
[13:20:28.967] - Received FutureResult
[13:20:28.967] - Erased future from FutureRegistry
[13:20:28.967] result() for ClusterFuture ...
[13:20:28.967] - result already collected: FutureResult
[13:20:28.967] result() for ClusterFuture ... done
[13:20:28.967] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:20:28.979] resolve() on environment ...
[13:20:28.979]  recursive: 0
[13:20:28.980]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:20:28.980] signalConditionsASAP(numeric, pos=1) ...
[13:20:28.980] - nx: 4
[13:20:28.980] - relay: TRUE
[13:20:28.980] - stdout: TRUE
[13:20:28.980] - signal: TRUE
[13:20:28.980] - resignal: FALSE
[13:20:28.980] - force: TRUE
[13:20:28.981] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.981] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.981]  - until=2
[13:20:28.981]  - relaying element #2
[13:20:28.981] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:28.981] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.981] signalConditionsASAP(NULL, pos=1) ... done
[13:20:28.981]  length: 3 (resolved future 1)
[13:20:28.981] Future #2
[13:20:28.982] result() for ClusterFuture ...
[13:20:28.982] - result already collected: FutureResult
[13:20:28.982] result() for ClusterFuture ... done
[13:20:28.982] result() for ClusterFuture ...
[13:20:28.982] - result already collected: FutureResult
[13:20:28.982] result() for ClusterFuture ... done
[13:20:28.982] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:28.982] - nx: 4
[13:20:28.982] - relay: TRUE
[13:20:28.982] - stdout: TRUE
[13:20:28.982] - signal: TRUE
[13:20:28.982] - resignal: FALSE
[13:20:28.983] - force: TRUE
[13:20:28.983] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:20:28.983] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:20:28.983]  - until=2
[13:20:28.983]  - relaying element #2
[13:20:28.983] result() for ClusterFuture ...
[13:20:28.983] - result already collected: FutureResult
[13:20:28.983] result() for ClusterFuture ... done
[13:20:28.983] result() for ClusterFuture ...
[13:20:28.983] - result already collected: FutureResult
[13:20:28.983] result() for ClusterFuture ... done
[13:20:28.984] result() for ClusterFuture ...
[13:20:28.984] - result already collected: FutureResult
[13:20:28.984] result() for ClusterFuture ... done
[13:20:28.984] result() for ClusterFuture ...
[13:20:28.984] - result already collected: FutureResult
[13:20:28.984] result() for ClusterFuture ... done
[13:20:28.984] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:28.984] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:28.984] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:28.984]  length: 2 (resolved future 2)
[13:20:28.984] Future #3
[13:20:28.985] result() for ClusterFuture ...
[13:20:28.985] - result already collected: FutureResult
[13:20:28.985] result() for ClusterFuture ... done
[13:20:28.985] result() for ClusterFuture ...
[13:20:28.985] - result already collected: FutureResult
[13:20:28.985] result() for ClusterFuture ... done
[13:20:28.985] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:28.985] - nx: 4
[13:20:28.985] - relay: TRUE
[13:20:28.985] - stdout: TRUE
[13:20:28.985] - signal: TRUE
[13:20:28.986] - resignal: FALSE
[13:20:28.986] - force: TRUE
[13:20:28.986] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:20:28.986] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:20:28.986]  - until=3
[13:20:28.986]  - relaying element #3
[13:20:28.986] result() for ClusterFuture ...
[13:20:28.986] - result already collected: FutureResult
[13:20:28.986] result() for ClusterFuture ... done
[13:20:28.986] result() for ClusterFuture ...
[13:20:28.986] - result already collected: FutureResult
[13:20:28.986] result() for ClusterFuture ... done
[13:20:28.987] result() for ClusterFuture ...
[13:20:28.987] - result already collected: FutureResult
[13:20:28.987] result() for ClusterFuture ... done
[13:20:28.987] result() for ClusterFuture ...
[13:20:28.987] - result already collected: FutureResult
[13:20:28.987] result() for ClusterFuture ... done
[13:20:28.987] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:28.987] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:28.987] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:28.988]  length: 1 (resolved future 3)
[13:20:29.009] receiveMessageFromWorker() for ClusterFuture ...
[13:20:29.009] - Validating connection of MultisessionFuture
[13:20:29.010] - received message: FutureResult
[13:20:29.010] - Received FutureResult
[13:20:29.010] - Erased future from FutureRegistry
[13:20:29.010] result() for ClusterFuture ...
[13:20:29.010] - result already collected: FutureResult
[13:20:29.010] result() for ClusterFuture ... done
[13:20:29.010] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:29.010] Future #4
[13:20:29.010] result() for ClusterFuture ...
[13:20:29.011] - result already collected: FutureResult
[13:20:29.011] result() for ClusterFuture ... done
[13:20:29.011] result() for ClusterFuture ...
[13:20:29.011] - result already collected: FutureResult
[13:20:29.011] result() for ClusterFuture ... done
[13:20:29.011] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:20:29.011] - nx: 4
[13:20:29.011] - relay: TRUE
[13:20:29.011] - stdout: TRUE
[13:20:29.011] - signal: TRUE
[13:20:29.011] - resignal: FALSE
[13:20:29.012] - force: TRUE
[13:20:29.012] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:20:29.012] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:20:29.012]  - until=4
[13:20:29.012]  - relaying element #4
[13:20:29.012] result() for ClusterFuture ...
[13:20:29.012] - result already collected: FutureResult
[13:20:29.012] result() for ClusterFuture ... done
[13:20:29.012] result() for ClusterFuture ...
[13:20:29.012] - result already collected: FutureResult
[13:20:29.012] result() for ClusterFuture ... done
[13:20:29.013] result() for ClusterFuture ...
[13:20:29.013] - result already collected: FutureResult
[13:20:29.013] result() for ClusterFuture ... done
[13:20:29.013] result() for ClusterFuture ...
[13:20:29.013] - result already collected: FutureResult
[13:20:29.013] result() for ClusterFuture ... done
[13:20:29.013] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:29.013] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:29.013] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:20:29.013]  length: 0 (resolved future 4)
[13:20:29.014] Relaying remaining futures
[13:20:29.014] signalConditionsASAP(NULL, pos=0) ...
[13:20:29.014] - nx: 4
[13:20:29.014] - relay: TRUE
[13:20:29.014] - stdout: TRUE
[13:20:29.014] - signal: TRUE
[13:20:29.014] - resignal: FALSE
[13:20:29.014] - force: TRUE
[13:20:29.014] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:29.014] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:20:29.014] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:20:29.015] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:20:29.015] signalConditionsASAP(NULL, pos=0) ... done
[13:20:29.015] resolve() on environment ... DONE
[13:20:29.015] result() for ClusterFuture ...
[13:20:29.015] - result already collected: FutureResult
[13:20:29.015] result() for ClusterFuture ... done
[13:20:29.015] result() for ClusterFuture ...
[13:20:29.015] - result already collected: FutureResult
[13:20:29.015] result() for ClusterFuture ... done
[13:20:29.015] result() for ClusterFuture ...
[13:20:29.016] - result already collected: FutureResult
[13:20:29.016] result() for ClusterFuture ... done
[13:20:29.016] result() for ClusterFuture ...
[13:20:29.016] - result already collected: FutureResult
[13:20:29.016] result() for ClusterFuture ... done
[13:20:29.016] result() for ClusterFuture ...
[13:20:29.016] - result already collected: FutureResult
[13:20:29.016] result() for ClusterFuture ... done
[13:20:29.016] result() for ClusterFuture ...
[13:20:29.016] - result already collected: FutureResult
[13:20:29.016] result() for ClusterFuture ... done
<environment: 0x55659bf8c3a0> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[13:20:29.017] plan(): Setting new future strategy stack:
[13:20:29.017] List of future strategies:
[13:20:29.017] 1. multicore:
[13:20:29.017]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.017]    - tweaked: FALSE
[13:20:29.017]    - call: plan(strategy)
[13:20:29.022] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:20:29.023] getGlobalsAndPackages() ...
[13:20:29.023] Searching for globals...
[13:20:29.024] 
[13:20:29.024] Searching for globals ... DONE
[13:20:29.024] - globals: [0] <none>
[13:20:29.024] getGlobalsAndPackages() ... DONE
[13:20:29.025] run() for ‘Future’ ...
[13:20:29.025] - state: ‘created’
[13:20:29.025] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.029] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.029] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.029]   - Field: ‘label’
[13:20:29.030]   - Field: ‘local’
[13:20:29.030]   - Field: ‘owner’
[13:20:29.030]   - Field: ‘envir’
[13:20:29.030]   - Field: ‘workers’
[13:20:29.030]   - Field: ‘packages’
[13:20:29.030]   - Field: ‘gc’
[13:20:29.030]   - Field: ‘job’
[13:20:29.030]   - Field: ‘conditions’
[13:20:29.030]   - Field: ‘expr’
[13:20:29.030]   - Field: ‘uuid’
[13:20:29.030]   - Field: ‘seed’
[13:20:29.031]   - Field: ‘version’
[13:20:29.031]   - Field: ‘result’
[13:20:29.031]   - Field: ‘asynchronous’
[13:20:29.031]   - Field: ‘calls’
[13:20:29.031]   - Field: ‘globals’
[13:20:29.031]   - Field: ‘stdout’
[13:20:29.031]   - Field: ‘earlySignal’
[13:20:29.031]   - Field: ‘lazy’
[13:20:29.031]   - Field: ‘state’
[13:20:29.031] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.032] - Launch lazy future ...
[13:20:29.032] Packages needed by the future expression (n = 0): <none>
[13:20:29.032] Packages needed by future strategies (n = 0): <none>
[13:20:29.032] {
[13:20:29.032]     {
[13:20:29.032]         {
[13:20:29.032]             ...future.startTime <- base::Sys.time()
[13:20:29.032]             {
[13:20:29.032]                 {
[13:20:29.032]                   {
[13:20:29.032]                     {
[13:20:29.032]                       base::local({
[13:20:29.032]                         has_future <- base::requireNamespace("future", 
[13:20:29.032]                           quietly = TRUE)
[13:20:29.032]                         if (has_future) {
[13:20:29.032]                           ns <- base::getNamespace("future")
[13:20:29.032]                           version <- ns[[".package"]][["version"]]
[13:20:29.032]                           if (is.null(version)) 
[13:20:29.032]                             version <- utils::packageVersion("future")
[13:20:29.032]                         }
[13:20:29.032]                         else {
[13:20:29.032]                           version <- NULL
[13:20:29.032]                         }
[13:20:29.032]                         if (!has_future || version < "1.8.0") {
[13:20:29.032]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.032]                             "", base::R.version$version.string), 
[13:20:29.032]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.032]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.032]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.032]                               "release", "version")], collapse = " "), 
[13:20:29.032]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.032]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.032]                             info)
[13:20:29.032]                           info <- base::paste(info, collapse = "; ")
[13:20:29.032]                           if (!has_future) {
[13:20:29.032]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.032]                               info)
[13:20:29.032]                           }
[13:20:29.032]                           else {
[13:20:29.032]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.032]                               info, version)
[13:20:29.032]                           }
[13:20:29.032]                           base::stop(msg)
[13:20:29.032]                         }
[13:20:29.032]                       })
[13:20:29.032]                     }
[13:20:29.032]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.032]                     base::options(mc.cores = 1L)
[13:20:29.032]                   }
[13:20:29.032]                   options(future.plan = NULL)
[13:20:29.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.032]                 }
[13:20:29.032]                 ...future.workdir <- getwd()
[13:20:29.032]             }
[13:20:29.032]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.032]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.032]         }
[13:20:29.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.032]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.032]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.032]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.032]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.032]             base::names(...future.oldOptions))
[13:20:29.032]     }
[13:20:29.032]     if (FALSE) {
[13:20:29.032]     }
[13:20:29.032]     else {
[13:20:29.032]         if (TRUE) {
[13:20:29.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.032]                 open = "w")
[13:20:29.032]         }
[13:20:29.032]         else {
[13:20:29.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.032]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.032]         }
[13:20:29.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.032]             base::sink(type = "output", split = FALSE)
[13:20:29.032]             base::close(...future.stdout)
[13:20:29.032]         }, add = TRUE)
[13:20:29.032]     }
[13:20:29.032]     ...future.frame <- base::sys.nframe()
[13:20:29.032]     ...future.conditions <- base::list()
[13:20:29.032]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.032]     if (FALSE) {
[13:20:29.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.032]     }
[13:20:29.032]     ...future.result <- base::tryCatch({
[13:20:29.032]         base::withCallingHandlers({
[13:20:29.032]             ...future.value <- base::withVisible(base::local({
[13:20:29.032]                 withCallingHandlers({
[13:20:29.032]                   2
[13:20:29.032]                 }, immediateCondition = function(cond) {
[13:20:29.032]                   save_rds <- function (object, pathname, ...) 
[13:20:29.032]                   {
[13:20:29.032]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.032]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.032]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.032]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.032]                         fi_tmp[["mtime"]])
[13:20:29.032]                     }
[13:20:29.032]                     tryCatch({
[13:20:29.032]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.032]                     }, error = function(ex) {
[13:20:29.032]                       msg <- conditionMessage(ex)
[13:20:29.032]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.032]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.032]                         fi_tmp[["mtime"]], msg)
[13:20:29.032]                       ex$message <- msg
[13:20:29.032]                       stop(ex)
[13:20:29.032]                     })
[13:20:29.032]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.032]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.032]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.032]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.032]                       fi <- file.info(pathname)
[13:20:29.032]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.032]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.032]                         fi[["size"]], fi[["mtime"]])
[13:20:29.032]                       stop(msg)
[13:20:29.032]                     }
[13:20:29.032]                     invisible(pathname)
[13:20:29.032]                   }
[13:20:29.032]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.032]                     rootPath = tempdir()) 
[13:20:29.032]                   {
[13:20:29.032]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.032]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.032]                       tmpdir = path, fileext = ".rds")
[13:20:29.032]                     save_rds(obj, file)
[13:20:29.032]                   }
[13:20:29.032]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.032]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.032]                   {
[13:20:29.032]                     inherits <- base::inherits
[13:20:29.032]                     invokeRestart <- base::invokeRestart
[13:20:29.032]                     is.null <- base::is.null
[13:20:29.032]                     muffled <- FALSE
[13:20:29.032]                     if (inherits(cond, "message")) {
[13:20:29.032]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.032]                       if (muffled) 
[13:20:29.032]                         invokeRestart("muffleMessage")
[13:20:29.032]                     }
[13:20:29.032]                     else if (inherits(cond, "warning")) {
[13:20:29.032]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.032]                       if (muffled) 
[13:20:29.032]                         invokeRestart("muffleWarning")
[13:20:29.032]                     }
[13:20:29.032]                     else if (inherits(cond, "condition")) {
[13:20:29.032]                       if (!is.null(pattern)) {
[13:20:29.032]                         computeRestarts <- base::computeRestarts
[13:20:29.032]                         grepl <- base::grepl
[13:20:29.032]                         restarts <- computeRestarts(cond)
[13:20:29.032]                         for (restart in restarts) {
[13:20:29.032]                           name <- restart$name
[13:20:29.032]                           if (is.null(name)) 
[13:20:29.032]                             next
[13:20:29.032]                           if (!grepl(pattern, name)) 
[13:20:29.032]                             next
[13:20:29.032]                           invokeRestart(restart)
[13:20:29.032]                           muffled <- TRUE
[13:20:29.032]                           break
[13:20:29.032]                         }
[13:20:29.032]                       }
[13:20:29.032]                     }
[13:20:29.032]                     invisible(muffled)
[13:20:29.032]                   }
[13:20:29.032]                   muffleCondition(cond)
[13:20:29.032]                 })
[13:20:29.032]             }))
[13:20:29.032]             future::FutureResult(value = ...future.value$value, 
[13:20:29.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.032]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.032]                     ...future.globalenv.names))
[13:20:29.032]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.032]         }, condition = base::local({
[13:20:29.032]             c <- base::c
[13:20:29.032]             inherits <- base::inherits
[13:20:29.032]             invokeRestart <- base::invokeRestart
[13:20:29.032]             length <- base::length
[13:20:29.032]             list <- base::list
[13:20:29.032]             seq.int <- base::seq.int
[13:20:29.032]             signalCondition <- base::signalCondition
[13:20:29.032]             sys.calls <- base::sys.calls
[13:20:29.032]             `[[` <- base::`[[`
[13:20:29.032]             `+` <- base::`+`
[13:20:29.032]             `<<-` <- base::`<<-`
[13:20:29.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.032]                   3L)]
[13:20:29.032]             }
[13:20:29.032]             function(cond) {
[13:20:29.032]                 is_error <- inherits(cond, "error")
[13:20:29.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.032]                   NULL)
[13:20:29.032]                 if (is_error) {
[13:20:29.032]                   sessionInformation <- function() {
[13:20:29.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.032]                       search = base::search(), system = base::Sys.info())
[13:20:29.032]                   }
[13:20:29.032]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.032]                     cond$call), session = sessionInformation(), 
[13:20:29.032]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.032]                   signalCondition(cond)
[13:20:29.032]                 }
[13:20:29.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.032]                 "immediateCondition"))) {
[13:20:29.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.032]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.032]                   if (TRUE && !signal) {
[13:20:29.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.032]                     {
[13:20:29.032]                       inherits <- base::inherits
[13:20:29.032]                       invokeRestart <- base::invokeRestart
[13:20:29.032]                       is.null <- base::is.null
[13:20:29.032]                       muffled <- FALSE
[13:20:29.032]                       if (inherits(cond, "message")) {
[13:20:29.032]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.032]                         if (muffled) 
[13:20:29.032]                           invokeRestart("muffleMessage")
[13:20:29.032]                       }
[13:20:29.032]                       else if (inherits(cond, "warning")) {
[13:20:29.032]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.032]                         if (muffled) 
[13:20:29.032]                           invokeRestart("muffleWarning")
[13:20:29.032]                       }
[13:20:29.032]                       else if (inherits(cond, "condition")) {
[13:20:29.032]                         if (!is.null(pattern)) {
[13:20:29.032]                           computeRestarts <- base::computeRestarts
[13:20:29.032]                           grepl <- base::grepl
[13:20:29.032]                           restarts <- computeRestarts(cond)
[13:20:29.032]                           for (restart in restarts) {
[13:20:29.032]                             name <- restart$name
[13:20:29.032]                             if (is.null(name)) 
[13:20:29.032]                               next
[13:20:29.032]                             if (!grepl(pattern, name)) 
[13:20:29.032]                               next
[13:20:29.032]                             invokeRestart(restart)
[13:20:29.032]                             muffled <- TRUE
[13:20:29.032]                             break
[13:20:29.032]                           }
[13:20:29.032]                         }
[13:20:29.032]                       }
[13:20:29.032]                       invisible(muffled)
[13:20:29.032]                     }
[13:20:29.032]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.032]                   }
[13:20:29.032]                 }
[13:20:29.032]                 else {
[13:20:29.032]                   if (TRUE) {
[13:20:29.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.032]                     {
[13:20:29.032]                       inherits <- base::inherits
[13:20:29.032]                       invokeRestart <- base::invokeRestart
[13:20:29.032]                       is.null <- base::is.null
[13:20:29.032]                       muffled <- FALSE
[13:20:29.032]                       if (inherits(cond, "message")) {
[13:20:29.032]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.032]                         if (muffled) 
[13:20:29.032]                           invokeRestart("muffleMessage")
[13:20:29.032]                       }
[13:20:29.032]                       else if (inherits(cond, "warning")) {
[13:20:29.032]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.032]                         if (muffled) 
[13:20:29.032]                           invokeRestart("muffleWarning")
[13:20:29.032]                       }
[13:20:29.032]                       else if (inherits(cond, "condition")) {
[13:20:29.032]                         if (!is.null(pattern)) {
[13:20:29.032]                           computeRestarts <- base::computeRestarts
[13:20:29.032]                           grepl <- base::grepl
[13:20:29.032]                           restarts <- computeRestarts(cond)
[13:20:29.032]                           for (restart in restarts) {
[13:20:29.032]                             name <- restart$name
[13:20:29.032]                             if (is.null(name)) 
[13:20:29.032]                               next
[13:20:29.032]                             if (!grepl(pattern, name)) 
[13:20:29.032]                               next
[13:20:29.032]                             invokeRestart(restart)
[13:20:29.032]                             muffled <- TRUE
[13:20:29.032]                             break
[13:20:29.032]                           }
[13:20:29.032]                         }
[13:20:29.032]                       }
[13:20:29.032]                       invisible(muffled)
[13:20:29.032]                     }
[13:20:29.032]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.032]                   }
[13:20:29.032]                 }
[13:20:29.032]             }
[13:20:29.032]         }))
[13:20:29.032]     }, error = function(ex) {
[13:20:29.032]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.032]                 ...future.rng), started = ...future.startTime, 
[13:20:29.032]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.032]             version = "1.8"), class = "FutureResult")
[13:20:29.032]     }, finally = {
[13:20:29.032]         if (!identical(...future.workdir, getwd())) 
[13:20:29.032]             setwd(...future.workdir)
[13:20:29.032]         {
[13:20:29.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.032]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.032]             }
[13:20:29.032]             base::options(...future.oldOptions)
[13:20:29.032]             if (.Platform$OS.type == "windows") {
[13:20:29.032]                 old_names <- names(...future.oldEnvVars)
[13:20:29.032]                 envs <- base::Sys.getenv()
[13:20:29.032]                 names <- names(envs)
[13:20:29.032]                 common <- intersect(names, old_names)
[13:20:29.032]                 added <- setdiff(names, old_names)
[13:20:29.032]                 removed <- setdiff(old_names, names)
[13:20:29.032]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.032]                   envs[common]]
[13:20:29.032]                 NAMES <- toupper(changed)
[13:20:29.032]                 args <- list()
[13:20:29.032]                 for (kk in seq_along(NAMES)) {
[13:20:29.032]                   name <- changed[[kk]]
[13:20:29.032]                   NAME <- NAMES[[kk]]
[13:20:29.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.032]                     next
[13:20:29.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.032]                 }
[13:20:29.032]                 NAMES <- toupper(added)
[13:20:29.032]                 for (kk in seq_along(NAMES)) {
[13:20:29.032]                   name <- added[[kk]]
[13:20:29.032]                   NAME <- NAMES[[kk]]
[13:20:29.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.032]                     next
[13:20:29.032]                   args[[name]] <- ""
[13:20:29.032]                 }
[13:20:29.032]                 NAMES <- toupper(removed)
[13:20:29.032]                 for (kk in seq_along(NAMES)) {
[13:20:29.032]                   name <- removed[[kk]]
[13:20:29.032]                   NAME <- NAMES[[kk]]
[13:20:29.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.032]                     next
[13:20:29.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.032]                 }
[13:20:29.032]                 if (length(args) > 0) 
[13:20:29.032]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.032]             }
[13:20:29.032]             else {
[13:20:29.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.032]             }
[13:20:29.032]             {
[13:20:29.032]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.032]                   0L) {
[13:20:29.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.032]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.032]                   base::options(opts)
[13:20:29.032]                 }
[13:20:29.032]                 {
[13:20:29.032]                   {
[13:20:29.032]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.032]                     NULL
[13:20:29.032]                   }
[13:20:29.032]                   options(future.plan = NULL)
[13:20:29.032]                   if (is.na(NA_character_)) 
[13:20:29.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.032]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.032]                     envir = parent.frame()) 
[13:20:29.032]                   {
[13:20:29.032]                     default_workers <- missing(workers)
[13:20:29.032]                     if (is.function(workers)) 
[13:20:29.032]                       workers <- workers()
[13:20:29.032]                     workers <- structure(as.integer(workers), 
[13:20:29.032]                       class = class(workers))
[13:20:29.032]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.032]                       1L)
[13:20:29.032]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.032]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.032]                       if (default_workers) 
[13:20:29.032]                         supportsMulticore(warn = TRUE)
[13:20:29.032]                       return(sequential(..., envir = envir))
[13:20:29.032]                     }
[13:20:29.032]                     oopts <- options(mc.cores = workers)
[13:20:29.032]                     on.exit(options(oopts))
[13:20:29.032]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.032]                       envir = envir)
[13:20:29.032]                     if (!future$lazy) 
[13:20:29.032]                       future <- run(future)
[13:20:29.032]                     invisible(future)
[13:20:29.032]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.032]                 }
[13:20:29.032]             }
[13:20:29.032]         }
[13:20:29.032]     })
[13:20:29.032]     if (TRUE) {
[13:20:29.032]         base::sink(type = "output", split = FALSE)
[13:20:29.032]         if (TRUE) {
[13:20:29.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.032]         }
[13:20:29.032]         else {
[13:20:29.032]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.032]         }
[13:20:29.032]         base::close(...future.stdout)
[13:20:29.032]         ...future.stdout <- NULL
[13:20:29.032]     }
[13:20:29.032]     ...future.result$conditions <- ...future.conditions
[13:20:29.032]     ...future.result$finished <- base::Sys.time()
[13:20:29.032]     ...future.result
[13:20:29.032] }
[13:20:29.035] requestCore(): workers = 2
[13:20:29.037] MulticoreFuture started
[13:20:29.038] - Launch lazy future ... done
[13:20:29.038] run() for ‘MulticoreFuture’ ... done
[13:20:29.038] getGlobalsAndPackages() ...
[13:20:29.038] Searching for globals...
[13:20:29.039] plan(): Setting new future strategy stack:
[13:20:29.039] 
[13:20:29.039] List of future strategies:
[13:20:29.039] 1. sequential:
[13:20:29.039]    - args: function (..., envir = parent.frame())
[13:20:29.039]    - tweaked: FALSE
[13:20:29.039]    - call: NULL
[13:20:29.039] Searching for globals ... DONE
[13:20:29.040] - globals: [0] <none>
[13:20:29.040] getGlobalsAndPackages() ... DONE
[13:20:29.040] plan(): nbrOfWorkers() = 1
[13:20:29.040] run() for ‘Future’ ...
[13:20:29.040] - state: ‘created’
[13:20:29.041] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.042] plan(): Setting new future strategy stack:
[13:20:29.042] List of future strategies:
[13:20:29.042] 1. multicore:
[13:20:29.042]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.042]    - tweaked: FALSE
[13:20:29.042]    - call: plan(strategy)
[13:20:29.046] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.046] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.046]   - Field: ‘label’
[13:20:29.046] plan(): nbrOfWorkers() = 2
[13:20:29.047]   - Field: ‘local’
[13:20:29.047]   - Field: ‘owner’
[13:20:29.047]   - Field: ‘envir’
[13:20:29.047]   - Field: ‘workers’
[13:20:29.047]   - Field: ‘packages’
[13:20:29.047]   - Field: ‘gc’
[13:20:29.047]   - Field: ‘job’
[13:20:29.048]   - Field: ‘conditions’
[13:20:29.048]   - Field: ‘expr’
[13:20:29.048]   - Field: ‘uuid’
[13:20:29.048]   - Field: ‘seed’
[13:20:29.048]   - Field: ‘version’
[13:20:29.048]   - Field: ‘result’
[13:20:29.048]   - Field: ‘asynchronous’
[13:20:29.049]   - Field: ‘calls’
[13:20:29.049]   - Field: ‘globals’
[13:20:29.049]   - Field: ‘stdout’
[13:20:29.049]   - Field: ‘earlySignal’
[13:20:29.049]   - Field: ‘lazy’
[13:20:29.049]   - Field: ‘state’
[13:20:29.049] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.050] - Launch lazy future ...
[13:20:29.050] Packages needed by the future expression (n = 0): <none>
[13:20:29.050] Packages needed by future strategies (n = 0): <none>
[13:20:29.051] {
[13:20:29.051]     {
[13:20:29.051]         {
[13:20:29.051]             ...future.startTime <- base::Sys.time()
[13:20:29.051]             {
[13:20:29.051]                 {
[13:20:29.051]                   {
[13:20:29.051]                     {
[13:20:29.051]                       base::local({
[13:20:29.051]                         has_future <- base::requireNamespace("future", 
[13:20:29.051]                           quietly = TRUE)
[13:20:29.051]                         if (has_future) {
[13:20:29.051]                           ns <- base::getNamespace("future")
[13:20:29.051]                           version <- ns[[".package"]][["version"]]
[13:20:29.051]                           if (is.null(version)) 
[13:20:29.051]                             version <- utils::packageVersion("future")
[13:20:29.051]                         }
[13:20:29.051]                         else {
[13:20:29.051]                           version <- NULL
[13:20:29.051]                         }
[13:20:29.051]                         if (!has_future || version < "1.8.0") {
[13:20:29.051]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.051]                             "", base::R.version$version.string), 
[13:20:29.051]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.051]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.051]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.051]                               "release", "version")], collapse = " "), 
[13:20:29.051]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.051]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.051]                             info)
[13:20:29.051]                           info <- base::paste(info, collapse = "; ")
[13:20:29.051]                           if (!has_future) {
[13:20:29.051]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.051]                               info)
[13:20:29.051]                           }
[13:20:29.051]                           else {
[13:20:29.051]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.051]                               info, version)
[13:20:29.051]                           }
[13:20:29.051]                           base::stop(msg)
[13:20:29.051]                         }
[13:20:29.051]                       })
[13:20:29.051]                     }
[13:20:29.051]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.051]                     base::options(mc.cores = 1L)
[13:20:29.051]                   }
[13:20:29.051]                   options(future.plan = NULL)
[13:20:29.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.051]                 }
[13:20:29.051]                 ...future.workdir <- getwd()
[13:20:29.051]             }
[13:20:29.051]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.051]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.051]         }
[13:20:29.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.051]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.051]             base::names(...future.oldOptions))
[13:20:29.051]     }
[13:20:29.051]     if (FALSE) {
[13:20:29.051]     }
[13:20:29.051]     else {
[13:20:29.051]         if (TRUE) {
[13:20:29.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.051]                 open = "w")
[13:20:29.051]         }
[13:20:29.051]         else {
[13:20:29.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.051]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.051]         }
[13:20:29.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.051]             base::sink(type = "output", split = FALSE)
[13:20:29.051]             base::close(...future.stdout)
[13:20:29.051]         }, add = TRUE)
[13:20:29.051]     }
[13:20:29.051]     ...future.frame <- base::sys.nframe()
[13:20:29.051]     ...future.conditions <- base::list()
[13:20:29.051]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.051]     if (FALSE) {
[13:20:29.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.051]     }
[13:20:29.051]     ...future.result <- base::tryCatch({
[13:20:29.051]         base::withCallingHandlers({
[13:20:29.051]             ...future.value <- base::withVisible(base::local({
[13:20:29.051]                 withCallingHandlers({
[13:20:29.051]                   NULL
[13:20:29.051]                 }, immediateCondition = function(cond) {
[13:20:29.051]                   save_rds <- function (object, pathname, ...) 
[13:20:29.051]                   {
[13:20:29.051]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.051]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.051]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.051]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.051]                         fi_tmp[["mtime"]])
[13:20:29.051]                     }
[13:20:29.051]                     tryCatch({
[13:20:29.051]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.051]                     }, error = function(ex) {
[13:20:29.051]                       msg <- conditionMessage(ex)
[13:20:29.051]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.051]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.051]                         fi_tmp[["mtime"]], msg)
[13:20:29.051]                       ex$message <- msg
[13:20:29.051]                       stop(ex)
[13:20:29.051]                     })
[13:20:29.051]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.051]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.051]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.051]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.051]                       fi <- file.info(pathname)
[13:20:29.051]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.051]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.051]                         fi[["size"]], fi[["mtime"]])
[13:20:29.051]                       stop(msg)
[13:20:29.051]                     }
[13:20:29.051]                     invisible(pathname)
[13:20:29.051]                   }
[13:20:29.051]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.051]                     rootPath = tempdir()) 
[13:20:29.051]                   {
[13:20:29.051]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.051]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.051]                       tmpdir = path, fileext = ".rds")
[13:20:29.051]                     save_rds(obj, file)
[13:20:29.051]                   }
[13:20:29.051]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.051]                   {
[13:20:29.051]                     inherits <- base::inherits
[13:20:29.051]                     invokeRestart <- base::invokeRestart
[13:20:29.051]                     is.null <- base::is.null
[13:20:29.051]                     muffled <- FALSE
[13:20:29.051]                     if (inherits(cond, "message")) {
[13:20:29.051]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.051]                       if (muffled) 
[13:20:29.051]                         invokeRestart("muffleMessage")
[13:20:29.051]                     }
[13:20:29.051]                     else if (inherits(cond, "warning")) {
[13:20:29.051]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.051]                       if (muffled) 
[13:20:29.051]                         invokeRestart("muffleWarning")
[13:20:29.051]                     }
[13:20:29.051]                     else if (inherits(cond, "condition")) {
[13:20:29.051]                       if (!is.null(pattern)) {
[13:20:29.051]                         computeRestarts <- base::computeRestarts
[13:20:29.051]                         grepl <- base::grepl
[13:20:29.051]                         restarts <- computeRestarts(cond)
[13:20:29.051]                         for (restart in restarts) {
[13:20:29.051]                           name <- restart$name
[13:20:29.051]                           if (is.null(name)) 
[13:20:29.051]                             next
[13:20:29.051]                           if (!grepl(pattern, name)) 
[13:20:29.051]                             next
[13:20:29.051]                           invokeRestart(restart)
[13:20:29.051]                           muffled <- TRUE
[13:20:29.051]                           break
[13:20:29.051]                         }
[13:20:29.051]                       }
[13:20:29.051]                     }
[13:20:29.051]                     invisible(muffled)
[13:20:29.051]                   }
[13:20:29.051]                   muffleCondition(cond)
[13:20:29.051]                 })
[13:20:29.051]             }))
[13:20:29.051]             future::FutureResult(value = ...future.value$value, 
[13:20:29.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.051]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.051]                     ...future.globalenv.names))
[13:20:29.051]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.051]         }, condition = base::local({
[13:20:29.051]             c <- base::c
[13:20:29.051]             inherits <- base::inherits
[13:20:29.051]             invokeRestart <- base::invokeRestart
[13:20:29.051]             length <- base::length
[13:20:29.051]             list <- base::list
[13:20:29.051]             seq.int <- base::seq.int
[13:20:29.051]             signalCondition <- base::signalCondition
[13:20:29.051]             sys.calls <- base::sys.calls
[13:20:29.051]             `[[` <- base::`[[`
[13:20:29.051]             `+` <- base::`+`
[13:20:29.051]             `<<-` <- base::`<<-`
[13:20:29.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.051]                   3L)]
[13:20:29.051]             }
[13:20:29.051]             function(cond) {
[13:20:29.051]                 is_error <- inherits(cond, "error")
[13:20:29.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.051]                   NULL)
[13:20:29.051]                 if (is_error) {
[13:20:29.051]                   sessionInformation <- function() {
[13:20:29.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.051]                       search = base::search(), system = base::Sys.info())
[13:20:29.051]                   }
[13:20:29.051]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.051]                     cond$call), session = sessionInformation(), 
[13:20:29.051]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.051]                   signalCondition(cond)
[13:20:29.051]                 }
[13:20:29.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.051]                 "immediateCondition"))) {
[13:20:29.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.051]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.051]                   if (TRUE && !signal) {
[13:20:29.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.051]                     {
[13:20:29.051]                       inherits <- base::inherits
[13:20:29.051]                       invokeRestart <- base::invokeRestart
[13:20:29.051]                       is.null <- base::is.null
[13:20:29.051]                       muffled <- FALSE
[13:20:29.051]                       if (inherits(cond, "message")) {
[13:20:29.051]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.051]                         if (muffled) 
[13:20:29.051]                           invokeRestart("muffleMessage")
[13:20:29.051]                       }
[13:20:29.051]                       else if (inherits(cond, "warning")) {
[13:20:29.051]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.051]                         if (muffled) 
[13:20:29.051]                           invokeRestart("muffleWarning")
[13:20:29.051]                       }
[13:20:29.051]                       else if (inherits(cond, "condition")) {
[13:20:29.051]                         if (!is.null(pattern)) {
[13:20:29.051]                           computeRestarts <- base::computeRestarts
[13:20:29.051]                           grepl <- base::grepl
[13:20:29.051]                           restarts <- computeRestarts(cond)
[13:20:29.051]                           for (restart in restarts) {
[13:20:29.051]                             name <- restart$name
[13:20:29.051]                             if (is.null(name)) 
[13:20:29.051]                               next
[13:20:29.051]                             if (!grepl(pattern, name)) 
[13:20:29.051]                               next
[13:20:29.051]                             invokeRestart(restart)
[13:20:29.051]                             muffled <- TRUE
[13:20:29.051]                             break
[13:20:29.051]                           }
[13:20:29.051]                         }
[13:20:29.051]                       }
[13:20:29.051]                       invisible(muffled)
[13:20:29.051]                     }
[13:20:29.051]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.051]                   }
[13:20:29.051]                 }
[13:20:29.051]                 else {
[13:20:29.051]                   if (TRUE) {
[13:20:29.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.051]                     {
[13:20:29.051]                       inherits <- base::inherits
[13:20:29.051]                       invokeRestart <- base::invokeRestart
[13:20:29.051]                       is.null <- base::is.null
[13:20:29.051]                       muffled <- FALSE
[13:20:29.051]                       if (inherits(cond, "message")) {
[13:20:29.051]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.051]                         if (muffled) 
[13:20:29.051]                           invokeRestart("muffleMessage")
[13:20:29.051]                       }
[13:20:29.051]                       else if (inherits(cond, "warning")) {
[13:20:29.051]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.051]                         if (muffled) 
[13:20:29.051]                           invokeRestart("muffleWarning")
[13:20:29.051]                       }
[13:20:29.051]                       else if (inherits(cond, "condition")) {
[13:20:29.051]                         if (!is.null(pattern)) {
[13:20:29.051]                           computeRestarts <- base::computeRestarts
[13:20:29.051]                           grepl <- base::grepl
[13:20:29.051]                           restarts <- computeRestarts(cond)
[13:20:29.051]                           for (restart in restarts) {
[13:20:29.051]                             name <- restart$name
[13:20:29.051]                             if (is.null(name)) 
[13:20:29.051]                               next
[13:20:29.051]                             if (!grepl(pattern, name)) 
[13:20:29.051]                               next
[13:20:29.051]                             invokeRestart(restart)
[13:20:29.051]                             muffled <- TRUE
[13:20:29.051]                             break
[13:20:29.051]                           }
[13:20:29.051]                         }
[13:20:29.051]                       }
[13:20:29.051]                       invisible(muffled)
[13:20:29.051]                     }
[13:20:29.051]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.051]                   }
[13:20:29.051]                 }
[13:20:29.051]             }
[13:20:29.051]         }))
[13:20:29.051]     }, error = function(ex) {
[13:20:29.051]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.051]                 ...future.rng), started = ...future.startTime, 
[13:20:29.051]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.051]             version = "1.8"), class = "FutureResult")
[13:20:29.051]     }, finally = {
[13:20:29.051]         if (!identical(...future.workdir, getwd())) 
[13:20:29.051]             setwd(...future.workdir)
[13:20:29.051]         {
[13:20:29.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.051]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.051]             }
[13:20:29.051]             base::options(...future.oldOptions)
[13:20:29.051]             if (.Platform$OS.type == "windows") {
[13:20:29.051]                 old_names <- names(...future.oldEnvVars)
[13:20:29.051]                 envs <- base::Sys.getenv()
[13:20:29.051]                 names <- names(envs)
[13:20:29.051]                 common <- intersect(names, old_names)
[13:20:29.051]                 added <- setdiff(names, old_names)
[13:20:29.051]                 removed <- setdiff(old_names, names)
[13:20:29.051]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.051]                   envs[common]]
[13:20:29.051]                 NAMES <- toupper(changed)
[13:20:29.051]                 args <- list()
[13:20:29.051]                 for (kk in seq_along(NAMES)) {
[13:20:29.051]                   name <- changed[[kk]]
[13:20:29.051]                   NAME <- NAMES[[kk]]
[13:20:29.051]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.051]                     next
[13:20:29.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.051]                 }
[13:20:29.051]                 NAMES <- toupper(added)
[13:20:29.051]                 for (kk in seq_along(NAMES)) {
[13:20:29.051]                   name <- added[[kk]]
[13:20:29.051]                   NAME <- NAMES[[kk]]
[13:20:29.051]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.051]                     next
[13:20:29.051]                   args[[name]] <- ""
[13:20:29.051]                 }
[13:20:29.051]                 NAMES <- toupper(removed)
[13:20:29.051]                 for (kk in seq_along(NAMES)) {
[13:20:29.051]                   name <- removed[[kk]]
[13:20:29.051]                   NAME <- NAMES[[kk]]
[13:20:29.051]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.051]                     next
[13:20:29.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.051]                 }
[13:20:29.051]                 if (length(args) > 0) 
[13:20:29.051]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.051]             }
[13:20:29.051]             else {
[13:20:29.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.051]             }
[13:20:29.051]             {
[13:20:29.051]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.051]                   0L) {
[13:20:29.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.051]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.051]                   base::options(opts)
[13:20:29.051]                 }
[13:20:29.051]                 {
[13:20:29.051]                   {
[13:20:29.051]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.051]                     NULL
[13:20:29.051]                   }
[13:20:29.051]                   options(future.plan = NULL)
[13:20:29.051]                   if (is.na(NA_character_)) 
[13:20:29.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.051]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.051]                     envir = parent.frame()) 
[13:20:29.051]                   {
[13:20:29.051]                     default_workers <- missing(workers)
[13:20:29.051]                     if (is.function(workers)) 
[13:20:29.051]                       workers <- workers()
[13:20:29.051]                     workers <- structure(as.integer(workers), 
[13:20:29.051]                       class = class(workers))
[13:20:29.051]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.051]                       1L)
[13:20:29.051]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.051]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.051]                       if (default_workers) 
[13:20:29.051]                         supportsMulticore(warn = TRUE)
[13:20:29.051]                       return(sequential(..., envir = envir))
[13:20:29.051]                     }
[13:20:29.051]                     oopts <- options(mc.cores = workers)
[13:20:29.051]                     on.exit(options(oopts))
[13:20:29.051]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.051]                       envir = envir)
[13:20:29.051]                     if (!future$lazy) 
[13:20:29.051]                       future <- run(future)
[13:20:29.051]                     invisible(future)
[13:20:29.051]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.051]                 }
[13:20:29.051]             }
[13:20:29.051]         }
[13:20:29.051]     })
[13:20:29.051]     if (TRUE) {
[13:20:29.051]         base::sink(type = "output", split = FALSE)
[13:20:29.051]         if (TRUE) {
[13:20:29.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.051]         }
[13:20:29.051]         else {
[13:20:29.051]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.051]         }
[13:20:29.051]         base::close(...future.stdout)
[13:20:29.051]         ...future.stdout <- NULL
[13:20:29.051]     }
[13:20:29.051]     ...future.result$conditions <- ...future.conditions
[13:20:29.051]     ...future.result$finished <- base::Sys.time()
[13:20:29.051]     ...future.result
[13:20:29.051] }
[13:20:29.055] requestCore(): workers = 2
[13:20:29.057] MulticoreFuture started
[13:20:29.058] - Launch lazy future ... done
[13:20:29.058] run() for ‘MulticoreFuture’ ... done
[13:20:29.059] plan(): Setting new future strategy stack:
[13:20:29.059] getGlobalsAndPackages() ...
[13:20:29.059] Searching for globals...
[13:20:29.059] List of future strategies:
[13:20:29.059] 1. sequential:
[13:20:29.059]    - args: function (..., envir = parent.frame())
[13:20:29.059]    - tweaked: FALSE
[13:20:29.059]    - call: NULL
[13:20:29.060] plan(): nbrOfWorkers() = 1
[13:20:29.061] - globals found: [1] ‘{’
[13:20:29.061] Searching for globals ... DONE
[13:20:29.061] Resolving globals: FALSE
[13:20:29.061] 
[13:20:29.062] 
[13:20:29.062] getGlobalsAndPackages() ... DONE
[13:20:29.062] plan(): Setting new future strategy stack:
[13:20:29.062] run() for ‘Future’ ...
[13:20:29.062] - state: ‘created’
[13:20:29.062] List of future strategies:
[13:20:29.062] 1. multicore:
[13:20:29.062]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.062]    - tweaked: FALSE
[13:20:29.062]    - call: plan(strategy)
[13:20:29.063] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.068] plan(): nbrOfWorkers() = 2
[13:20:29.068] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.068]   - Field: ‘label’
[13:20:29.069]   - Field: ‘local’
[13:20:29.069]   - Field: ‘owner’
[13:20:29.069]   - Field: ‘envir’
[13:20:29.069]   - Field: ‘workers’
[13:20:29.069]   - Field: ‘packages’
[13:20:29.069]   - Field: ‘gc’
[13:20:29.069]   - Field: ‘job’
[13:20:29.070]   - Field: ‘conditions’
[13:20:29.070]   - Field: ‘expr’
[13:20:29.070]   - Field: ‘uuid’
[13:20:29.070]   - Field: ‘seed’
[13:20:29.070]   - Field: ‘version’
[13:20:29.070]   - Field: ‘result’
[13:20:29.070]   - Field: ‘asynchronous’
[13:20:29.071]   - Field: ‘calls’
[13:20:29.071]   - Field: ‘globals’
[13:20:29.071]   - Field: ‘stdout’
[13:20:29.071]   - Field: ‘earlySignal’
[13:20:29.071]   - Field: ‘lazy’
[13:20:29.071]   - Field: ‘state’
[13:20:29.071] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.072] - Launch lazy future ...
[13:20:29.072] Packages needed by the future expression (n = 0): <none>
[13:20:29.072] Packages needed by future strategies (n = 0): <none>
[13:20:29.073] {
[13:20:29.073]     {
[13:20:29.073]         {
[13:20:29.073]             ...future.startTime <- base::Sys.time()
[13:20:29.073]             {
[13:20:29.073]                 {
[13:20:29.073]                   {
[13:20:29.073]                     {
[13:20:29.073]                       base::local({
[13:20:29.073]                         has_future <- base::requireNamespace("future", 
[13:20:29.073]                           quietly = TRUE)
[13:20:29.073]                         if (has_future) {
[13:20:29.073]                           ns <- base::getNamespace("future")
[13:20:29.073]                           version <- ns[[".package"]][["version"]]
[13:20:29.073]                           if (is.null(version)) 
[13:20:29.073]                             version <- utils::packageVersion("future")
[13:20:29.073]                         }
[13:20:29.073]                         else {
[13:20:29.073]                           version <- NULL
[13:20:29.073]                         }
[13:20:29.073]                         if (!has_future || version < "1.8.0") {
[13:20:29.073]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.073]                             "", base::R.version$version.string), 
[13:20:29.073]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.073]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.073]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.073]                               "release", "version")], collapse = " "), 
[13:20:29.073]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.073]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.073]                             info)
[13:20:29.073]                           info <- base::paste(info, collapse = "; ")
[13:20:29.073]                           if (!has_future) {
[13:20:29.073]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.073]                               info)
[13:20:29.073]                           }
[13:20:29.073]                           else {
[13:20:29.073]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.073]                               info, version)
[13:20:29.073]                           }
[13:20:29.073]                           base::stop(msg)
[13:20:29.073]                         }
[13:20:29.073]                       })
[13:20:29.073]                     }
[13:20:29.073]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.073]                     base::options(mc.cores = 1L)
[13:20:29.073]                   }
[13:20:29.073]                   options(future.plan = NULL)
[13:20:29.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.073]                 }
[13:20:29.073]                 ...future.workdir <- getwd()
[13:20:29.073]             }
[13:20:29.073]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.073]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.073]         }
[13:20:29.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.073]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.073]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.073]             base::names(...future.oldOptions))
[13:20:29.073]     }
[13:20:29.073]     if (FALSE) {
[13:20:29.073]     }
[13:20:29.073]     else {
[13:20:29.073]         if (TRUE) {
[13:20:29.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.073]                 open = "w")
[13:20:29.073]         }
[13:20:29.073]         else {
[13:20:29.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.073]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.073]         }
[13:20:29.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.073]             base::sink(type = "output", split = FALSE)
[13:20:29.073]             base::close(...future.stdout)
[13:20:29.073]         }, add = TRUE)
[13:20:29.073]     }
[13:20:29.073]     ...future.frame <- base::sys.nframe()
[13:20:29.073]     ...future.conditions <- base::list()
[13:20:29.073]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.073]     if (FALSE) {
[13:20:29.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.073]     }
[13:20:29.073]     ...future.result <- base::tryCatch({
[13:20:29.073]         base::withCallingHandlers({
[13:20:29.073]             ...future.value <- base::withVisible(base::local({
[13:20:29.073]                 withCallingHandlers({
[13:20:29.073]                   {
[13:20:29.073]                     4
[13:20:29.073]                   }
[13:20:29.073]                 }, immediateCondition = function(cond) {
[13:20:29.073]                   save_rds <- function (object, pathname, ...) 
[13:20:29.073]                   {
[13:20:29.073]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.073]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.073]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.073]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.073]                         fi_tmp[["mtime"]])
[13:20:29.073]                     }
[13:20:29.073]                     tryCatch({
[13:20:29.073]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.073]                     }, error = function(ex) {
[13:20:29.073]                       msg <- conditionMessage(ex)
[13:20:29.073]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.073]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.073]                         fi_tmp[["mtime"]], msg)
[13:20:29.073]                       ex$message <- msg
[13:20:29.073]                       stop(ex)
[13:20:29.073]                     })
[13:20:29.073]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.073]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.073]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.073]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.073]                       fi <- file.info(pathname)
[13:20:29.073]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.073]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.073]                         fi[["size"]], fi[["mtime"]])
[13:20:29.073]                       stop(msg)
[13:20:29.073]                     }
[13:20:29.073]                     invisible(pathname)
[13:20:29.073]                   }
[13:20:29.073]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.073]                     rootPath = tempdir()) 
[13:20:29.073]                   {
[13:20:29.073]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.073]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.073]                       tmpdir = path, fileext = ".rds")
[13:20:29.073]                     save_rds(obj, file)
[13:20:29.073]                   }
[13:20:29.073]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.073]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.073]                   {
[13:20:29.073]                     inherits <- base::inherits
[13:20:29.073]                     invokeRestart <- base::invokeRestart
[13:20:29.073]                     is.null <- base::is.null
[13:20:29.073]                     muffled <- FALSE
[13:20:29.073]                     if (inherits(cond, "message")) {
[13:20:29.073]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.073]                       if (muffled) 
[13:20:29.073]                         invokeRestart("muffleMessage")
[13:20:29.073]                     }
[13:20:29.073]                     else if (inherits(cond, "warning")) {
[13:20:29.073]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.073]                       if (muffled) 
[13:20:29.073]                         invokeRestart("muffleWarning")
[13:20:29.073]                     }
[13:20:29.073]                     else if (inherits(cond, "condition")) {
[13:20:29.073]                       if (!is.null(pattern)) {
[13:20:29.073]                         computeRestarts <- base::computeRestarts
[13:20:29.073]                         grepl <- base::grepl
[13:20:29.073]                         restarts <- computeRestarts(cond)
[13:20:29.073]                         for (restart in restarts) {
[13:20:29.073]                           name <- restart$name
[13:20:29.073]                           if (is.null(name)) 
[13:20:29.073]                             next
[13:20:29.073]                           if (!grepl(pattern, name)) 
[13:20:29.073]                             next
[13:20:29.073]                           invokeRestart(restart)
[13:20:29.073]                           muffled <- TRUE
[13:20:29.073]                           break
[13:20:29.073]                         }
[13:20:29.073]                       }
[13:20:29.073]                     }
[13:20:29.073]                     invisible(muffled)
[13:20:29.073]                   }
[13:20:29.073]                   muffleCondition(cond)
[13:20:29.073]                 })
[13:20:29.073]             }))
[13:20:29.073]             future::FutureResult(value = ...future.value$value, 
[13:20:29.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.073]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.073]                     ...future.globalenv.names))
[13:20:29.073]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.073]         }, condition = base::local({
[13:20:29.073]             c <- base::c
[13:20:29.073]             inherits <- base::inherits
[13:20:29.073]             invokeRestart <- base::invokeRestart
[13:20:29.073]             length <- base::length
[13:20:29.073]             list <- base::list
[13:20:29.073]             seq.int <- base::seq.int
[13:20:29.073]             signalCondition <- base::signalCondition
[13:20:29.073]             sys.calls <- base::sys.calls
[13:20:29.073]             `[[` <- base::`[[`
[13:20:29.073]             `+` <- base::`+`
[13:20:29.073]             `<<-` <- base::`<<-`
[13:20:29.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.073]                   3L)]
[13:20:29.073]             }
[13:20:29.073]             function(cond) {
[13:20:29.073]                 is_error <- inherits(cond, "error")
[13:20:29.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.073]                   NULL)
[13:20:29.073]                 if (is_error) {
[13:20:29.073]                   sessionInformation <- function() {
[13:20:29.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.073]                       search = base::search(), system = base::Sys.info())
[13:20:29.073]                   }
[13:20:29.073]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.073]                     cond$call), session = sessionInformation(), 
[13:20:29.073]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.073]                   signalCondition(cond)
[13:20:29.073]                 }
[13:20:29.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.073]                 "immediateCondition"))) {
[13:20:29.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.073]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.073]                   if (TRUE && !signal) {
[13:20:29.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.073]                     {
[13:20:29.073]                       inherits <- base::inherits
[13:20:29.073]                       invokeRestart <- base::invokeRestart
[13:20:29.073]                       is.null <- base::is.null
[13:20:29.073]                       muffled <- FALSE
[13:20:29.073]                       if (inherits(cond, "message")) {
[13:20:29.073]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.073]                         if (muffled) 
[13:20:29.073]                           invokeRestart("muffleMessage")
[13:20:29.073]                       }
[13:20:29.073]                       else if (inherits(cond, "warning")) {
[13:20:29.073]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.073]                         if (muffled) 
[13:20:29.073]                           invokeRestart("muffleWarning")
[13:20:29.073]                       }
[13:20:29.073]                       else if (inherits(cond, "condition")) {
[13:20:29.073]                         if (!is.null(pattern)) {
[13:20:29.073]                           computeRestarts <- base::computeRestarts
[13:20:29.073]                           grepl <- base::grepl
[13:20:29.073]                           restarts <- computeRestarts(cond)
[13:20:29.073]                           for (restart in restarts) {
[13:20:29.073]                             name <- restart$name
[13:20:29.073]                             if (is.null(name)) 
[13:20:29.073]                               next
[13:20:29.073]                             if (!grepl(pattern, name)) 
[13:20:29.073]                               next
[13:20:29.073]                             invokeRestart(restart)
[13:20:29.073]                             muffled <- TRUE
[13:20:29.073]                             break
[13:20:29.073]                           }
[13:20:29.073]                         }
[13:20:29.073]                       }
[13:20:29.073]                       invisible(muffled)
[13:20:29.073]                     }
[13:20:29.073]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.073]                   }
[13:20:29.073]                 }
[13:20:29.073]                 else {
[13:20:29.073]                   if (TRUE) {
[13:20:29.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.073]                     {
[13:20:29.073]                       inherits <- base::inherits
[13:20:29.073]                       invokeRestart <- base::invokeRestart
[13:20:29.073]                       is.null <- base::is.null
[13:20:29.073]                       muffled <- FALSE
[13:20:29.073]                       if (inherits(cond, "message")) {
[13:20:29.073]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.073]                         if (muffled) 
[13:20:29.073]                           invokeRestart("muffleMessage")
[13:20:29.073]                       }
[13:20:29.073]                       else if (inherits(cond, "warning")) {
[13:20:29.073]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.073]                         if (muffled) 
[13:20:29.073]                           invokeRestart("muffleWarning")
[13:20:29.073]                       }
[13:20:29.073]                       else if (inherits(cond, "condition")) {
[13:20:29.073]                         if (!is.null(pattern)) {
[13:20:29.073]                           computeRestarts <- base::computeRestarts
[13:20:29.073]                           grepl <- base::grepl
[13:20:29.073]                           restarts <- computeRestarts(cond)
[13:20:29.073]                           for (restart in restarts) {
[13:20:29.073]                             name <- restart$name
[13:20:29.073]                             if (is.null(name)) 
[13:20:29.073]                               next
[13:20:29.073]                             if (!grepl(pattern, name)) 
[13:20:29.073]                               next
[13:20:29.073]                             invokeRestart(restart)
[13:20:29.073]                             muffled <- TRUE
[13:20:29.073]                             break
[13:20:29.073]                           }
[13:20:29.073]                         }
[13:20:29.073]                       }
[13:20:29.073]                       invisible(muffled)
[13:20:29.073]                     }
[13:20:29.073]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.073]                   }
[13:20:29.073]                 }
[13:20:29.073]             }
[13:20:29.073]         }))
[13:20:29.073]     }, error = function(ex) {
[13:20:29.073]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.073]                 ...future.rng), started = ...future.startTime, 
[13:20:29.073]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.073]             version = "1.8"), class = "FutureResult")
[13:20:29.073]     }, finally = {
[13:20:29.073]         if (!identical(...future.workdir, getwd())) 
[13:20:29.073]             setwd(...future.workdir)
[13:20:29.073]         {
[13:20:29.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.073]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.073]             }
[13:20:29.073]             base::options(...future.oldOptions)
[13:20:29.073]             if (.Platform$OS.type == "windows") {
[13:20:29.073]                 old_names <- names(...future.oldEnvVars)
[13:20:29.073]                 envs <- base::Sys.getenv()
[13:20:29.073]                 names <- names(envs)
[13:20:29.073]                 common <- intersect(names, old_names)
[13:20:29.073]                 added <- setdiff(names, old_names)
[13:20:29.073]                 removed <- setdiff(old_names, names)
[13:20:29.073]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.073]                   envs[common]]
[13:20:29.073]                 NAMES <- toupper(changed)
[13:20:29.073]                 args <- list()
[13:20:29.073]                 for (kk in seq_along(NAMES)) {
[13:20:29.073]                   name <- changed[[kk]]
[13:20:29.073]                   NAME <- NAMES[[kk]]
[13:20:29.073]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.073]                     next
[13:20:29.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.073]                 }
[13:20:29.073]                 NAMES <- toupper(added)
[13:20:29.073]                 for (kk in seq_along(NAMES)) {
[13:20:29.073]                   name <- added[[kk]]
[13:20:29.073]                   NAME <- NAMES[[kk]]
[13:20:29.073]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.073]                     next
[13:20:29.073]                   args[[name]] <- ""
[13:20:29.073]                 }
[13:20:29.073]                 NAMES <- toupper(removed)
[13:20:29.073]                 for (kk in seq_along(NAMES)) {
[13:20:29.073]                   name <- removed[[kk]]
[13:20:29.073]                   NAME <- NAMES[[kk]]
[13:20:29.073]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.073]                     next
[13:20:29.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.073]                 }
[13:20:29.073]                 if (length(args) > 0) 
[13:20:29.073]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.073]             }
[13:20:29.073]             else {
[13:20:29.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.073]             }
[13:20:29.073]             {
[13:20:29.073]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.073]                   0L) {
[13:20:29.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.073]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.073]                   base::options(opts)
[13:20:29.073]                 }
[13:20:29.073]                 {
[13:20:29.073]                   {
[13:20:29.073]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.073]                     NULL
[13:20:29.073]                   }
[13:20:29.073]                   options(future.plan = NULL)
[13:20:29.073]                   if (is.na(NA_character_)) 
[13:20:29.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.073]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.073]                     envir = parent.frame()) 
[13:20:29.073]                   {
[13:20:29.073]                     default_workers <- missing(workers)
[13:20:29.073]                     if (is.function(workers)) 
[13:20:29.073]                       workers <- workers()
[13:20:29.073]                     workers <- structure(as.integer(workers), 
[13:20:29.073]                       class = class(workers))
[13:20:29.073]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.073]                       1L)
[13:20:29.073]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.073]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.073]                       if (default_workers) 
[13:20:29.073]                         supportsMulticore(warn = TRUE)
[13:20:29.073]                       return(sequential(..., envir = envir))
[13:20:29.073]                     }
[13:20:29.073]                     oopts <- options(mc.cores = workers)
[13:20:29.073]                     on.exit(options(oopts))
[13:20:29.073]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.073]                       envir = envir)
[13:20:29.073]                     if (!future$lazy) 
[13:20:29.073]                       future <- run(future)
[13:20:29.073]                     invisible(future)
[13:20:29.073]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.073]                 }
[13:20:29.073]             }
[13:20:29.073]         }
[13:20:29.073]     })
[13:20:29.073]     if (TRUE) {
[13:20:29.073]         base::sink(type = "output", split = FALSE)
[13:20:29.073]         if (TRUE) {
[13:20:29.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.073]         }
[13:20:29.073]         else {
[13:20:29.073]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.073]         }
[13:20:29.073]         base::close(...future.stdout)
[13:20:29.073]         ...future.stdout <- NULL
[13:20:29.073]     }
[13:20:29.073]     ...future.result$conditions <- ...future.conditions
[13:20:29.073]     ...future.result$finished <- base::Sys.time()
[13:20:29.073]     ...future.result
[13:20:29.073] }
[13:20:29.077] requestCore(): workers = 2
[13:20:29.077] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:29.092] MulticoreFuture started
[13:20:29.092] - Launch lazy future ... done
[13:20:29.093] run() for ‘MulticoreFuture’ ... done
[13:20:29.093] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x556599a5c9b8> 
[13:20:29.094] List of future strategies:
[13:20:29.094] 1. sequential:
[13:20:29.094]    - args: function (..., envir = parent.frame())
[13:20:29.094]    - tweaked: FALSE
[13:20:29.094]    - call: NULL
[13:20:29.095] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55659d2bf0b0> 
[13:20:29.098] plan(): Setting new future strategy stack:
[13:20:29.098] List of future strategies:
[13:20:29.098] 1. multicore:
[13:20:29.098]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.098]    - tweaked: FALSE
[13:20:29.098]    - call: plan(strategy)
[13:20:29.104] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:29.107] resolve() on list environment ...
[13:20:29.107]  recursive: 0
[13:20:29.109]  length: 6
[13:20:29.109]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:29.109] signalConditionsASAP(numeric, pos=1) ...
[13:20:29.109] - nx: 6
[13:20:29.109] - relay: TRUE
[13:20:29.109] - stdout: TRUE
[13:20:29.110] - signal: TRUE
[13:20:29.110] - resignal: FALSE
[13:20:29.110] - force: TRUE
[13:20:29.110] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.110] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.110]  - until=2
[13:20:29.110]  - relaying element #2
[13:20:29.110] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.111] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.111] signalConditionsASAP(NULL, pos=1) ... done
[13:20:29.111]  length: 5 (resolved future 1)
[13:20:29.111] Future #2
[13:20:29.111] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:29.112] - nx: 6
[13:20:29.112] - relay: TRUE
[13:20:29.112] - stdout: TRUE
[13:20:29.112] - signal: TRUE
[13:20:29.112] - resignal: FALSE
[13:20:29.112] - force: TRUE
[13:20:29.112] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.112] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.113]  - until=2
[13:20:29.113]  - relaying element #2
[13:20:29.113] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.113] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.113] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:29.113]  length: 4 (resolved future 2)
[13:20:29.114] Future #3
[13:20:29.115] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:29.115] - nx: 6
[13:20:29.115] - relay: TRUE
[13:20:29.115] - stdout: TRUE
[13:20:29.115] - signal: TRUE
[13:20:29.115] - resignal: FALSE
[13:20:29.115] - force: TRUE
[13:20:29.116] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.116] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.116]  - until=3
[13:20:29.116]  - relaying element #3
[13:20:29.116] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.116] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.116] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:29.117]  length: 3 (resolved future 3)
[13:20:29.117] Future #4
[13:20:29.118] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:20:29.118] - nx: 6
[13:20:29.118] - relay: TRUE
[13:20:29.118] - stdout: TRUE
[13:20:29.119] - signal: TRUE
[13:20:29.119] - resignal: FALSE
[13:20:29.119] - force: TRUE
[13:20:29.119] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.119] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.119]  - until=4
[13:20:29.120]  - relaying element #4
[13:20:29.120] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.120] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.120] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:20:29.120]  length: 2 (resolved future 4)
[13:20:29.121] signalConditionsASAP(NULL, pos=5) ...
[13:20:29.121] - nx: 6
[13:20:29.121] - relay: TRUE
[13:20:29.121] - stdout: TRUE
[13:20:29.121] - signal: TRUE
[13:20:29.121] - resignal: FALSE
[13:20:29.121] - force: TRUE
[13:20:29.122] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.122] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.122]  - until=6
[13:20:29.122]  - relaying element #6
[13:20:29.122] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:29.122] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.122] signalConditionsASAP(NULL, pos=5) ... done
[13:20:29.122]  length: 1 (resolved future 5)
[13:20:29.122] signalConditionsASAP(numeric, pos=6) ...
[13:20:29.123] - nx: 6
[13:20:29.123] - relay: TRUE
[13:20:29.123] - stdout: TRUE
[13:20:29.123] - signal: TRUE
[13:20:29.123] - resignal: FALSE
[13:20:29.123] - force: TRUE
[13:20:29.123] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:29.123] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.123]  - until=6
[13:20:29.123] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.124] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.124] signalConditionsASAP(numeric, pos=6) ... done
[13:20:29.124]  length: 0 (resolved future 6)
[13:20:29.124] Relaying remaining futures
[13:20:29.124] signalConditionsASAP(NULL, pos=0) ...
[13:20:29.124] - nx: 6
[13:20:29.124] - relay: TRUE
[13:20:29.124] - stdout: TRUE
[13:20:29.124] - signal: TRUE
[13:20:29.124] - resignal: FALSE
[13:20:29.125] - force: TRUE
[13:20:29.125] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.125] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:29.125] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.125] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.125] signalConditionsASAP(NULL, pos=0) ... done
[13:20:29.125] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55659d51ab70> 
Dimensions: c(1, 6)
[13:20:29.126] getGlobalsAndPackages() ...
[13:20:29.126] Searching for globals...
[13:20:29.127] 
[13:20:29.127] Searching for globals ... DONE
[13:20:29.127] - globals: [0] <none>
[13:20:29.127] getGlobalsAndPackages() ... DONE
[13:20:29.127] run() for ‘Future’ ...
[13:20:29.128] - state: ‘created’
[13:20:29.128] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.136] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.136]   - Field: ‘label’
[13:20:29.137]   - Field: ‘local’
[13:20:29.137]   - Field: ‘owner’
[13:20:29.137]   - Field: ‘envir’
[13:20:29.137]   - Field: ‘workers’
[13:20:29.137]   - Field: ‘packages’
[13:20:29.137]   - Field: ‘gc’
[13:20:29.137]   - Field: ‘job’
[13:20:29.137]   - Field: ‘conditions’
[13:20:29.138]   - Field: ‘expr’
[13:20:29.138]   - Field: ‘uuid’
[13:20:29.138]   - Field: ‘seed’
[13:20:29.138]   - Field: ‘version’
[13:20:29.138]   - Field: ‘result’
[13:20:29.138]   - Field: ‘asynchronous’
[13:20:29.138]   - Field: ‘calls’
[13:20:29.138]   - Field: ‘globals’
[13:20:29.138]   - Field: ‘stdout’
[13:20:29.139]   - Field: ‘earlySignal’
[13:20:29.139]   - Field: ‘lazy’
[13:20:29.139]   - Field: ‘state’
[13:20:29.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.139] - Launch lazy future ...
[13:20:29.139] Packages needed by the future expression (n = 0): <none>
[13:20:29.139] Packages needed by future strategies (n = 0): <none>
[13:20:29.140] {
[13:20:29.140]     {
[13:20:29.140]         {
[13:20:29.140]             ...future.startTime <- base::Sys.time()
[13:20:29.140]             {
[13:20:29.140]                 {
[13:20:29.140]                   {
[13:20:29.140]                     {
[13:20:29.140]                       base::local({
[13:20:29.140]                         has_future <- base::requireNamespace("future", 
[13:20:29.140]                           quietly = TRUE)
[13:20:29.140]                         if (has_future) {
[13:20:29.140]                           ns <- base::getNamespace("future")
[13:20:29.140]                           version <- ns[[".package"]][["version"]]
[13:20:29.140]                           if (is.null(version)) 
[13:20:29.140]                             version <- utils::packageVersion("future")
[13:20:29.140]                         }
[13:20:29.140]                         else {
[13:20:29.140]                           version <- NULL
[13:20:29.140]                         }
[13:20:29.140]                         if (!has_future || version < "1.8.0") {
[13:20:29.140]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.140]                             "", base::R.version$version.string), 
[13:20:29.140]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.140]                               "release", "version")], collapse = " "), 
[13:20:29.140]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.140]                             info)
[13:20:29.140]                           info <- base::paste(info, collapse = "; ")
[13:20:29.140]                           if (!has_future) {
[13:20:29.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.140]                               info)
[13:20:29.140]                           }
[13:20:29.140]                           else {
[13:20:29.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.140]                               info, version)
[13:20:29.140]                           }
[13:20:29.140]                           base::stop(msg)
[13:20:29.140]                         }
[13:20:29.140]                       })
[13:20:29.140]                     }
[13:20:29.140]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.140]                     base::options(mc.cores = 1L)
[13:20:29.140]                   }
[13:20:29.140]                   options(future.plan = NULL)
[13:20:29.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.140]                 }
[13:20:29.140]                 ...future.workdir <- getwd()
[13:20:29.140]             }
[13:20:29.140]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.140]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.140]         }
[13:20:29.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.140]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.140]             base::names(...future.oldOptions))
[13:20:29.140]     }
[13:20:29.140]     if (FALSE) {
[13:20:29.140]     }
[13:20:29.140]     else {
[13:20:29.140]         if (TRUE) {
[13:20:29.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.140]                 open = "w")
[13:20:29.140]         }
[13:20:29.140]         else {
[13:20:29.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.140]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.140]         }
[13:20:29.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.140]             base::sink(type = "output", split = FALSE)
[13:20:29.140]             base::close(...future.stdout)
[13:20:29.140]         }, add = TRUE)
[13:20:29.140]     }
[13:20:29.140]     ...future.frame <- base::sys.nframe()
[13:20:29.140]     ...future.conditions <- base::list()
[13:20:29.140]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.140]     if (FALSE) {
[13:20:29.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.140]     }
[13:20:29.140]     ...future.result <- base::tryCatch({
[13:20:29.140]         base::withCallingHandlers({
[13:20:29.140]             ...future.value <- base::withVisible(base::local({
[13:20:29.140]                 withCallingHandlers({
[13:20:29.140]                   2
[13:20:29.140]                 }, immediateCondition = function(cond) {
[13:20:29.140]                   save_rds <- function (object, pathname, ...) 
[13:20:29.140]                   {
[13:20:29.140]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.140]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.140]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.140]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.140]                         fi_tmp[["mtime"]])
[13:20:29.140]                     }
[13:20:29.140]                     tryCatch({
[13:20:29.140]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.140]                     }, error = function(ex) {
[13:20:29.140]                       msg <- conditionMessage(ex)
[13:20:29.140]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.140]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.140]                         fi_tmp[["mtime"]], msg)
[13:20:29.140]                       ex$message <- msg
[13:20:29.140]                       stop(ex)
[13:20:29.140]                     })
[13:20:29.140]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.140]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.140]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.140]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.140]                       fi <- file.info(pathname)
[13:20:29.140]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.140]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.140]                         fi[["size"]], fi[["mtime"]])
[13:20:29.140]                       stop(msg)
[13:20:29.140]                     }
[13:20:29.140]                     invisible(pathname)
[13:20:29.140]                   }
[13:20:29.140]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.140]                     rootPath = tempdir()) 
[13:20:29.140]                   {
[13:20:29.140]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.140]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.140]                       tmpdir = path, fileext = ".rds")
[13:20:29.140]                     save_rds(obj, file)
[13:20:29.140]                   }
[13:20:29.140]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.140]                   {
[13:20:29.140]                     inherits <- base::inherits
[13:20:29.140]                     invokeRestart <- base::invokeRestart
[13:20:29.140]                     is.null <- base::is.null
[13:20:29.140]                     muffled <- FALSE
[13:20:29.140]                     if (inherits(cond, "message")) {
[13:20:29.140]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.140]                       if (muffled) 
[13:20:29.140]                         invokeRestart("muffleMessage")
[13:20:29.140]                     }
[13:20:29.140]                     else if (inherits(cond, "warning")) {
[13:20:29.140]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.140]                       if (muffled) 
[13:20:29.140]                         invokeRestart("muffleWarning")
[13:20:29.140]                     }
[13:20:29.140]                     else if (inherits(cond, "condition")) {
[13:20:29.140]                       if (!is.null(pattern)) {
[13:20:29.140]                         computeRestarts <- base::computeRestarts
[13:20:29.140]                         grepl <- base::grepl
[13:20:29.140]                         restarts <- computeRestarts(cond)
[13:20:29.140]                         for (restart in restarts) {
[13:20:29.140]                           name <- restart$name
[13:20:29.140]                           if (is.null(name)) 
[13:20:29.140]                             next
[13:20:29.140]                           if (!grepl(pattern, name)) 
[13:20:29.140]                             next
[13:20:29.140]                           invokeRestart(restart)
[13:20:29.140]                           muffled <- TRUE
[13:20:29.140]                           break
[13:20:29.140]                         }
[13:20:29.140]                       }
[13:20:29.140]                     }
[13:20:29.140]                     invisible(muffled)
[13:20:29.140]                   }
[13:20:29.140]                   muffleCondition(cond)
[13:20:29.140]                 })
[13:20:29.140]             }))
[13:20:29.140]             future::FutureResult(value = ...future.value$value, 
[13:20:29.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.140]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.140]                     ...future.globalenv.names))
[13:20:29.140]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.140]         }, condition = base::local({
[13:20:29.140]             c <- base::c
[13:20:29.140]             inherits <- base::inherits
[13:20:29.140]             invokeRestart <- base::invokeRestart
[13:20:29.140]             length <- base::length
[13:20:29.140]             list <- base::list
[13:20:29.140]             seq.int <- base::seq.int
[13:20:29.140]             signalCondition <- base::signalCondition
[13:20:29.140]             sys.calls <- base::sys.calls
[13:20:29.140]             `[[` <- base::`[[`
[13:20:29.140]             `+` <- base::`+`
[13:20:29.140]             `<<-` <- base::`<<-`
[13:20:29.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.140]                   3L)]
[13:20:29.140]             }
[13:20:29.140]             function(cond) {
[13:20:29.140]                 is_error <- inherits(cond, "error")
[13:20:29.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.140]                   NULL)
[13:20:29.140]                 if (is_error) {
[13:20:29.140]                   sessionInformation <- function() {
[13:20:29.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.140]                       search = base::search(), system = base::Sys.info())
[13:20:29.140]                   }
[13:20:29.140]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.140]                     cond$call), session = sessionInformation(), 
[13:20:29.140]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.140]                   signalCondition(cond)
[13:20:29.140]                 }
[13:20:29.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.140]                 "immediateCondition"))) {
[13:20:29.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.140]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.140]                   if (TRUE && !signal) {
[13:20:29.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.140]                     {
[13:20:29.140]                       inherits <- base::inherits
[13:20:29.140]                       invokeRestart <- base::invokeRestart
[13:20:29.140]                       is.null <- base::is.null
[13:20:29.140]                       muffled <- FALSE
[13:20:29.140]                       if (inherits(cond, "message")) {
[13:20:29.140]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.140]                         if (muffled) 
[13:20:29.140]                           invokeRestart("muffleMessage")
[13:20:29.140]                       }
[13:20:29.140]                       else if (inherits(cond, "warning")) {
[13:20:29.140]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.140]                         if (muffled) 
[13:20:29.140]                           invokeRestart("muffleWarning")
[13:20:29.140]                       }
[13:20:29.140]                       else if (inherits(cond, "condition")) {
[13:20:29.140]                         if (!is.null(pattern)) {
[13:20:29.140]                           computeRestarts <- base::computeRestarts
[13:20:29.140]                           grepl <- base::grepl
[13:20:29.140]                           restarts <- computeRestarts(cond)
[13:20:29.140]                           for (restart in restarts) {
[13:20:29.140]                             name <- restart$name
[13:20:29.140]                             if (is.null(name)) 
[13:20:29.140]                               next
[13:20:29.140]                             if (!grepl(pattern, name)) 
[13:20:29.140]                               next
[13:20:29.140]                             invokeRestart(restart)
[13:20:29.140]                             muffled <- TRUE
[13:20:29.140]                             break
[13:20:29.140]                           }
[13:20:29.140]                         }
[13:20:29.140]                       }
[13:20:29.140]                       invisible(muffled)
[13:20:29.140]                     }
[13:20:29.140]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.140]                   }
[13:20:29.140]                 }
[13:20:29.140]                 else {
[13:20:29.140]                   if (TRUE) {
[13:20:29.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.140]                     {
[13:20:29.140]                       inherits <- base::inherits
[13:20:29.140]                       invokeRestart <- base::invokeRestart
[13:20:29.140]                       is.null <- base::is.null
[13:20:29.140]                       muffled <- FALSE
[13:20:29.140]                       if (inherits(cond, "message")) {
[13:20:29.140]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.140]                         if (muffled) 
[13:20:29.140]                           invokeRestart("muffleMessage")
[13:20:29.140]                       }
[13:20:29.140]                       else if (inherits(cond, "warning")) {
[13:20:29.140]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.140]                         if (muffled) 
[13:20:29.140]                           invokeRestart("muffleWarning")
[13:20:29.140]                       }
[13:20:29.140]                       else if (inherits(cond, "condition")) {
[13:20:29.140]                         if (!is.null(pattern)) {
[13:20:29.140]                           computeRestarts <- base::computeRestarts
[13:20:29.140]                           grepl <- base::grepl
[13:20:29.140]                           restarts <- computeRestarts(cond)
[13:20:29.140]                           for (restart in restarts) {
[13:20:29.140]                             name <- restart$name
[13:20:29.140]                             if (is.null(name)) 
[13:20:29.140]                               next
[13:20:29.140]                             if (!grepl(pattern, name)) 
[13:20:29.140]                               next
[13:20:29.140]                             invokeRestart(restart)
[13:20:29.140]                             muffled <- TRUE
[13:20:29.140]                             break
[13:20:29.140]                           }
[13:20:29.140]                         }
[13:20:29.140]                       }
[13:20:29.140]                       invisible(muffled)
[13:20:29.140]                     }
[13:20:29.140]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.140]                   }
[13:20:29.140]                 }
[13:20:29.140]             }
[13:20:29.140]         }))
[13:20:29.140]     }, error = function(ex) {
[13:20:29.140]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.140]                 ...future.rng), started = ...future.startTime, 
[13:20:29.140]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.140]             version = "1.8"), class = "FutureResult")
[13:20:29.140]     }, finally = {
[13:20:29.140]         if (!identical(...future.workdir, getwd())) 
[13:20:29.140]             setwd(...future.workdir)
[13:20:29.140]         {
[13:20:29.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.140]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.140]             }
[13:20:29.140]             base::options(...future.oldOptions)
[13:20:29.140]             if (.Platform$OS.type == "windows") {
[13:20:29.140]                 old_names <- names(...future.oldEnvVars)
[13:20:29.140]                 envs <- base::Sys.getenv()
[13:20:29.140]                 names <- names(envs)
[13:20:29.140]                 common <- intersect(names, old_names)
[13:20:29.140]                 added <- setdiff(names, old_names)
[13:20:29.140]                 removed <- setdiff(old_names, names)
[13:20:29.140]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.140]                   envs[common]]
[13:20:29.140]                 NAMES <- toupper(changed)
[13:20:29.140]                 args <- list()
[13:20:29.140]                 for (kk in seq_along(NAMES)) {
[13:20:29.140]                   name <- changed[[kk]]
[13:20:29.140]                   NAME <- NAMES[[kk]]
[13:20:29.140]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.140]                     next
[13:20:29.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.140]                 }
[13:20:29.140]                 NAMES <- toupper(added)
[13:20:29.140]                 for (kk in seq_along(NAMES)) {
[13:20:29.140]                   name <- added[[kk]]
[13:20:29.140]                   NAME <- NAMES[[kk]]
[13:20:29.140]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.140]                     next
[13:20:29.140]                   args[[name]] <- ""
[13:20:29.140]                 }
[13:20:29.140]                 NAMES <- toupper(removed)
[13:20:29.140]                 for (kk in seq_along(NAMES)) {
[13:20:29.140]                   name <- removed[[kk]]
[13:20:29.140]                   NAME <- NAMES[[kk]]
[13:20:29.140]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.140]                     next
[13:20:29.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.140]                 }
[13:20:29.140]                 if (length(args) > 0) 
[13:20:29.140]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.140]             }
[13:20:29.140]             else {
[13:20:29.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.140]             }
[13:20:29.140]             {
[13:20:29.140]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.140]                   0L) {
[13:20:29.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.140]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.140]                   base::options(opts)
[13:20:29.140]                 }
[13:20:29.140]                 {
[13:20:29.140]                   {
[13:20:29.140]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.140]                     NULL
[13:20:29.140]                   }
[13:20:29.140]                   options(future.plan = NULL)
[13:20:29.140]                   if (is.na(NA_character_)) 
[13:20:29.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.140]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.140]                     envir = parent.frame()) 
[13:20:29.140]                   {
[13:20:29.140]                     default_workers <- missing(workers)
[13:20:29.140]                     if (is.function(workers)) 
[13:20:29.140]                       workers <- workers()
[13:20:29.140]                     workers <- structure(as.integer(workers), 
[13:20:29.140]                       class = class(workers))
[13:20:29.140]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.140]                       1L)
[13:20:29.140]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.140]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.140]                       if (default_workers) 
[13:20:29.140]                         supportsMulticore(warn = TRUE)
[13:20:29.140]                       return(sequential(..., envir = envir))
[13:20:29.140]                     }
[13:20:29.140]                     oopts <- options(mc.cores = workers)
[13:20:29.140]                     on.exit(options(oopts))
[13:20:29.140]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.140]                       envir = envir)
[13:20:29.140]                     if (!future$lazy) 
[13:20:29.140]                       future <- run(future)
[13:20:29.140]                     invisible(future)
[13:20:29.140]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.140]                 }
[13:20:29.140]             }
[13:20:29.140]         }
[13:20:29.140]     })
[13:20:29.140]     if (TRUE) {
[13:20:29.140]         base::sink(type = "output", split = FALSE)
[13:20:29.140]         if (TRUE) {
[13:20:29.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.140]         }
[13:20:29.140]         else {
[13:20:29.140]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.140]         }
[13:20:29.140]         base::close(...future.stdout)
[13:20:29.140]         ...future.stdout <- NULL
[13:20:29.140]     }
[13:20:29.140]     ...future.result$conditions <- ...future.conditions
[13:20:29.140]     ...future.result$finished <- base::Sys.time()
[13:20:29.140]     ...future.result
[13:20:29.140] }
[13:20:29.143] requestCore(): workers = 2
[13:20:29.145] MulticoreFuture started
[13:20:29.145] - Launch lazy future ... done
[13:20:29.146] run() for ‘MulticoreFuture’ ... done
[13:20:29.146] getGlobalsAndPackages() ...
[13:20:29.146] Searching for globals...
[13:20:29.146] plan(): Setting new future strategy stack:
[13:20:29.147] 
[13:20:29.147] Searching for globals ... DONE
[13:20:29.147] List of future strategies:
[13:20:29.147] 1. sequential:
[13:20:29.147]    - args: function (..., envir = parent.frame())
[13:20:29.147]    - tweaked: FALSE
[13:20:29.147]    - call: NULL
[13:20:29.147] - globals: [0] <none>
[13:20:29.147] getGlobalsAndPackages() ... DONE
[13:20:29.147] plan(): nbrOfWorkers() = 1
[13:20:29.148] run() for ‘Future’ ...
[13:20:29.148] - state: ‘created’
[13:20:29.148] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.149] plan(): Setting new future strategy stack:
[13:20:29.150] List of future strategies:
[13:20:29.150] 1. multicore:
[13:20:29.150]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.150]    - tweaked: FALSE
[13:20:29.150]    - call: plan(strategy)
[13:20:29.154] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.154] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.154] plan(): nbrOfWorkers() = 2
[13:20:29.154]   - Field: ‘label’
[13:20:29.154]   - Field: ‘local’
[13:20:29.154]   - Field: ‘owner’
[13:20:29.155]   - Field: ‘envir’
[13:20:29.155]   - Field: ‘workers’
[13:20:29.155]   - Field: ‘packages’
[13:20:29.155]   - Field: ‘gc’
[13:20:29.155]   - Field: ‘job’
[13:20:29.155]   - Field: ‘conditions’
[13:20:29.155]   - Field: ‘expr’
[13:20:29.156]   - Field: ‘uuid’
[13:20:29.156]   - Field: ‘seed’
[13:20:29.156]   - Field: ‘version’
[13:20:29.156]   - Field: ‘result’
[13:20:29.156]   - Field: ‘asynchronous’
[13:20:29.156]   - Field: ‘calls’
[13:20:29.156]   - Field: ‘globals’
[13:20:29.157]   - Field: ‘stdout’
[13:20:29.157]   - Field: ‘earlySignal’
[13:20:29.157]   - Field: ‘lazy’
[13:20:29.157]   - Field: ‘state’
[13:20:29.157] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.158] - Launch lazy future ...
[13:20:29.158] Packages needed by the future expression (n = 0): <none>
[13:20:29.158] Packages needed by future strategies (n = 0): <none>
[13:20:29.159] {
[13:20:29.159]     {
[13:20:29.159]         {
[13:20:29.159]             ...future.startTime <- base::Sys.time()
[13:20:29.159]             {
[13:20:29.159]                 {
[13:20:29.159]                   {
[13:20:29.159]                     {
[13:20:29.159]                       base::local({
[13:20:29.159]                         has_future <- base::requireNamespace("future", 
[13:20:29.159]                           quietly = TRUE)
[13:20:29.159]                         if (has_future) {
[13:20:29.159]                           ns <- base::getNamespace("future")
[13:20:29.159]                           version <- ns[[".package"]][["version"]]
[13:20:29.159]                           if (is.null(version)) 
[13:20:29.159]                             version <- utils::packageVersion("future")
[13:20:29.159]                         }
[13:20:29.159]                         else {
[13:20:29.159]                           version <- NULL
[13:20:29.159]                         }
[13:20:29.159]                         if (!has_future || version < "1.8.0") {
[13:20:29.159]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.159]                             "", base::R.version$version.string), 
[13:20:29.159]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.159]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.159]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.159]                               "release", "version")], collapse = " "), 
[13:20:29.159]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.159]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.159]                             info)
[13:20:29.159]                           info <- base::paste(info, collapse = "; ")
[13:20:29.159]                           if (!has_future) {
[13:20:29.159]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.159]                               info)
[13:20:29.159]                           }
[13:20:29.159]                           else {
[13:20:29.159]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.159]                               info, version)
[13:20:29.159]                           }
[13:20:29.159]                           base::stop(msg)
[13:20:29.159]                         }
[13:20:29.159]                       })
[13:20:29.159]                     }
[13:20:29.159]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.159]                     base::options(mc.cores = 1L)
[13:20:29.159]                   }
[13:20:29.159]                   options(future.plan = NULL)
[13:20:29.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.159]                 }
[13:20:29.159]                 ...future.workdir <- getwd()
[13:20:29.159]             }
[13:20:29.159]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.159]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.159]         }
[13:20:29.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.159]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.159]             base::names(...future.oldOptions))
[13:20:29.159]     }
[13:20:29.159]     if (FALSE) {
[13:20:29.159]     }
[13:20:29.159]     else {
[13:20:29.159]         if (TRUE) {
[13:20:29.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.159]                 open = "w")
[13:20:29.159]         }
[13:20:29.159]         else {
[13:20:29.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.159]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.159]         }
[13:20:29.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.159]             base::sink(type = "output", split = FALSE)
[13:20:29.159]             base::close(...future.stdout)
[13:20:29.159]         }, add = TRUE)
[13:20:29.159]     }
[13:20:29.159]     ...future.frame <- base::sys.nframe()
[13:20:29.159]     ...future.conditions <- base::list()
[13:20:29.159]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.159]     if (FALSE) {
[13:20:29.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.159]     }
[13:20:29.159]     ...future.result <- base::tryCatch({
[13:20:29.159]         base::withCallingHandlers({
[13:20:29.159]             ...future.value <- base::withVisible(base::local({
[13:20:29.159]                 withCallingHandlers({
[13:20:29.159]                   NULL
[13:20:29.159]                 }, immediateCondition = function(cond) {
[13:20:29.159]                   save_rds <- function (object, pathname, ...) 
[13:20:29.159]                   {
[13:20:29.159]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.159]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.159]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.159]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.159]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.159]                         fi_tmp[["mtime"]])
[13:20:29.159]                     }
[13:20:29.159]                     tryCatch({
[13:20:29.159]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.159]                     }, error = function(ex) {
[13:20:29.159]                       msg <- conditionMessage(ex)
[13:20:29.159]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.159]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.159]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.159]                         fi_tmp[["mtime"]], msg)
[13:20:29.159]                       ex$message <- msg
[13:20:29.159]                       stop(ex)
[13:20:29.159]                     })
[13:20:29.159]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.159]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.159]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.159]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.159]                       fi <- file.info(pathname)
[13:20:29.159]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.159]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.159]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.159]                         fi[["size"]], fi[["mtime"]])
[13:20:29.159]                       stop(msg)
[13:20:29.159]                     }
[13:20:29.159]                     invisible(pathname)
[13:20:29.159]                   }
[13:20:29.159]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.159]                     rootPath = tempdir()) 
[13:20:29.159]                   {
[13:20:29.159]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.159]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.159]                       tmpdir = path, fileext = ".rds")
[13:20:29.159]                     save_rds(obj, file)
[13:20:29.159]                   }
[13:20:29.159]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.159]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.159]                   {
[13:20:29.159]                     inherits <- base::inherits
[13:20:29.159]                     invokeRestart <- base::invokeRestart
[13:20:29.159]                     is.null <- base::is.null
[13:20:29.159]                     muffled <- FALSE
[13:20:29.159]                     if (inherits(cond, "message")) {
[13:20:29.159]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.159]                       if (muffled) 
[13:20:29.159]                         invokeRestart("muffleMessage")
[13:20:29.159]                     }
[13:20:29.159]                     else if (inherits(cond, "warning")) {
[13:20:29.159]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.159]                       if (muffled) 
[13:20:29.159]                         invokeRestart("muffleWarning")
[13:20:29.159]                     }
[13:20:29.159]                     else if (inherits(cond, "condition")) {
[13:20:29.159]                       if (!is.null(pattern)) {
[13:20:29.159]                         computeRestarts <- base::computeRestarts
[13:20:29.159]                         grepl <- base::grepl
[13:20:29.159]                         restarts <- computeRestarts(cond)
[13:20:29.159]                         for (restart in restarts) {
[13:20:29.159]                           name <- restart$name
[13:20:29.159]                           if (is.null(name)) 
[13:20:29.159]                             next
[13:20:29.159]                           if (!grepl(pattern, name)) 
[13:20:29.159]                             next
[13:20:29.159]                           invokeRestart(restart)
[13:20:29.159]                           muffled <- TRUE
[13:20:29.159]                           break
[13:20:29.159]                         }
[13:20:29.159]                       }
[13:20:29.159]                     }
[13:20:29.159]                     invisible(muffled)
[13:20:29.159]                   }
[13:20:29.159]                   muffleCondition(cond)
[13:20:29.159]                 })
[13:20:29.159]             }))
[13:20:29.159]             future::FutureResult(value = ...future.value$value, 
[13:20:29.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.159]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.159]                     ...future.globalenv.names))
[13:20:29.159]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.159]         }, condition = base::local({
[13:20:29.159]             c <- base::c
[13:20:29.159]             inherits <- base::inherits
[13:20:29.159]             invokeRestart <- base::invokeRestart
[13:20:29.159]             length <- base::length
[13:20:29.159]             list <- base::list
[13:20:29.159]             seq.int <- base::seq.int
[13:20:29.159]             signalCondition <- base::signalCondition
[13:20:29.159]             sys.calls <- base::sys.calls
[13:20:29.159]             `[[` <- base::`[[`
[13:20:29.159]             `+` <- base::`+`
[13:20:29.159]             `<<-` <- base::`<<-`
[13:20:29.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.159]                   3L)]
[13:20:29.159]             }
[13:20:29.159]             function(cond) {
[13:20:29.159]                 is_error <- inherits(cond, "error")
[13:20:29.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.159]                   NULL)
[13:20:29.159]                 if (is_error) {
[13:20:29.159]                   sessionInformation <- function() {
[13:20:29.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.159]                       search = base::search(), system = base::Sys.info())
[13:20:29.159]                   }
[13:20:29.159]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.159]                     cond$call), session = sessionInformation(), 
[13:20:29.159]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.159]                   signalCondition(cond)
[13:20:29.159]                 }
[13:20:29.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.159]                 "immediateCondition"))) {
[13:20:29.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.159]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.159]                   if (TRUE && !signal) {
[13:20:29.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.159]                     {
[13:20:29.159]                       inherits <- base::inherits
[13:20:29.159]                       invokeRestart <- base::invokeRestart
[13:20:29.159]                       is.null <- base::is.null
[13:20:29.159]                       muffled <- FALSE
[13:20:29.159]                       if (inherits(cond, "message")) {
[13:20:29.159]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.159]                         if (muffled) 
[13:20:29.159]                           invokeRestart("muffleMessage")
[13:20:29.159]                       }
[13:20:29.159]                       else if (inherits(cond, "warning")) {
[13:20:29.159]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.159]                         if (muffled) 
[13:20:29.159]                           invokeRestart("muffleWarning")
[13:20:29.159]                       }
[13:20:29.159]                       else if (inherits(cond, "condition")) {
[13:20:29.159]                         if (!is.null(pattern)) {
[13:20:29.159]                           computeRestarts <- base::computeRestarts
[13:20:29.159]                           grepl <- base::grepl
[13:20:29.159]                           restarts <- computeRestarts(cond)
[13:20:29.159]                           for (restart in restarts) {
[13:20:29.159]                             name <- restart$name
[13:20:29.159]                             if (is.null(name)) 
[13:20:29.159]                               next
[13:20:29.159]                             if (!grepl(pattern, name)) 
[13:20:29.159]                               next
[13:20:29.159]                             invokeRestart(restart)
[13:20:29.159]                             muffled <- TRUE
[13:20:29.159]                             break
[13:20:29.159]                           }
[13:20:29.159]                         }
[13:20:29.159]                       }
[13:20:29.159]                       invisible(muffled)
[13:20:29.159]                     }
[13:20:29.159]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.159]                   }
[13:20:29.159]                 }
[13:20:29.159]                 else {
[13:20:29.159]                   if (TRUE) {
[13:20:29.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.159]                     {
[13:20:29.159]                       inherits <- base::inherits
[13:20:29.159]                       invokeRestart <- base::invokeRestart
[13:20:29.159]                       is.null <- base::is.null
[13:20:29.159]                       muffled <- FALSE
[13:20:29.159]                       if (inherits(cond, "message")) {
[13:20:29.159]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.159]                         if (muffled) 
[13:20:29.159]                           invokeRestart("muffleMessage")
[13:20:29.159]                       }
[13:20:29.159]                       else if (inherits(cond, "warning")) {
[13:20:29.159]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.159]                         if (muffled) 
[13:20:29.159]                           invokeRestart("muffleWarning")
[13:20:29.159]                       }
[13:20:29.159]                       else if (inherits(cond, "condition")) {
[13:20:29.159]                         if (!is.null(pattern)) {
[13:20:29.159]                           computeRestarts <- base::computeRestarts
[13:20:29.159]                           grepl <- base::grepl
[13:20:29.159]                           restarts <- computeRestarts(cond)
[13:20:29.159]                           for (restart in restarts) {
[13:20:29.159]                             name <- restart$name
[13:20:29.159]                             if (is.null(name)) 
[13:20:29.159]                               next
[13:20:29.159]                             if (!grepl(pattern, name)) 
[13:20:29.159]                               next
[13:20:29.159]                             invokeRestart(restart)
[13:20:29.159]                             muffled <- TRUE
[13:20:29.159]                             break
[13:20:29.159]                           }
[13:20:29.159]                         }
[13:20:29.159]                       }
[13:20:29.159]                       invisible(muffled)
[13:20:29.159]                     }
[13:20:29.159]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.159]                   }
[13:20:29.159]                 }
[13:20:29.159]             }
[13:20:29.159]         }))
[13:20:29.159]     }, error = function(ex) {
[13:20:29.159]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.159]                 ...future.rng), started = ...future.startTime, 
[13:20:29.159]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.159]             version = "1.8"), class = "FutureResult")
[13:20:29.159]     }, finally = {
[13:20:29.159]         if (!identical(...future.workdir, getwd())) 
[13:20:29.159]             setwd(...future.workdir)
[13:20:29.159]         {
[13:20:29.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.159]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.159]             }
[13:20:29.159]             base::options(...future.oldOptions)
[13:20:29.159]             if (.Platform$OS.type == "windows") {
[13:20:29.159]                 old_names <- names(...future.oldEnvVars)
[13:20:29.159]                 envs <- base::Sys.getenv()
[13:20:29.159]                 names <- names(envs)
[13:20:29.159]                 common <- intersect(names, old_names)
[13:20:29.159]                 added <- setdiff(names, old_names)
[13:20:29.159]                 removed <- setdiff(old_names, names)
[13:20:29.159]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.159]                   envs[common]]
[13:20:29.159]                 NAMES <- toupper(changed)
[13:20:29.159]                 args <- list()
[13:20:29.159]                 for (kk in seq_along(NAMES)) {
[13:20:29.159]                   name <- changed[[kk]]
[13:20:29.159]                   NAME <- NAMES[[kk]]
[13:20:29.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.159]                     next
[13:20:29.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.159]                 }
[13:20:29.159]                 NAMES <- toupper(added)
[13:20:29.159]                 for (kk in seq_along(NAMES)) {
[13:20:29.159]                   name <- added[[kk]]
[13:20:29.159]                   NAME <- NAMES[[kk]]
[13:20:29.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.159]                     next
[13:20:29.159]                   args[[name]] <- ""
[13:20:29.159]                 }
[13:20:29.159]                 NAMES <- toupper(removed)
[13:20:29.159]                 for (kk in seq_along(NAMES)) {
[13:20:29.159]                   name <- removed[[kk]]
[13:20:29.159]                   NAME <- NAMES[[kk]]
[13:20:29.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.159]                     next
[13:20:29.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.159]                 }
[13:20:29.159]                 if (length(args) > 0) 
[13:20:29.159]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.159]             }
[13:20:29.159]             else {
[13:20:29.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.159]             }
[13:20:29.159]             {
[13:20:29.159]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.159]                   0L) {
[13:20:29.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.159]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.159]                   base::options(opts)
[13:20:29.159]                 }
[13:20:29.159]                 {
[13:20:29.159]                   {
[13:20:29.159]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.159]                     NULL
[13:20:29.159]                   }
[13:20:29.159]                   options(future.plan = NULL)
[13:20:29.159]                   if (is.na(NA_character_)) 
[13:20:29.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.159]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.159]                     envir = parent.frame()) 
[13:20:29.159]                   {
[13:20:29.159]                     default_workers <- missing(workers)
[13:20:29.159]                     if (is.function(workers)) 
[13:20:29.159]                       workers <- workers()
[13:20:29.159]                     workers <- structure(as.integer(workers), 
[13:20:29.159]                       class = class(workers))
[13:20:29.159]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.159]                       1L)
[13:20:29.159]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.159]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.159]                       if (default_workers) 
[13:20:29.159]                         supportsMulticore(warn = TRUE)
[13:20:29.159]                       return(sequential(..., envir = envir))
[13:20:29.159]                     }
[13:20:29.159]                     oopts <- options(mc.cores = workers)
[13:20:29.159]                     on.exit(options(oopts))
[13:20:29.159]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.159]                       envir = envir)
[13:20:29.159]                     if (!future$lazy) 
[13:20:29.159]                       future <- run(future)
[13:20:29.159]                     invisible(future)
[13:20:29.159]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.159]                 }
[13:20:29.159]             }
[13:20:29.159]         }
[13:20:29.159]     })
[13:20:29.159]     if (TRUE) {
[13:20:29.159]         base::sink(type = "output", split = FALSE)
[13:20:29.159]         if (TRUE) {
[13:20:29.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.159]         }
[13:20:29.159]         else {
[13:20:29.159]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.159]         }
[13:20:29.159]         base::close(...future.stdout)
[13:20:29.159]         ...future.stdout <- NULL
[13:20:29.159]     }
[13:20:29.159]     ...future.result$conditions <- ...future.conditions
[13:20:29.159]     ...future.result$finished <- base::Sys.time()
[13:20:29.159]     ...future.result
[13:20:29.159] }
[13:20:29.163] requestCore(): workers = 2
[13:20:29.165] MulticoreFuture started
[13:20:29.166] - Launch lazy future ... done
[13:20:29.166] run() for ‘MulticoreFuture’ ... done
[13:20:29.166] plan(): Setting new future strategy stack:
[13:20:29.167] getGlobalsAndPackages() ...
[13:20:29.167] Searching for globals...
[13:20:29.167] List of future strategies:
[13:20:29.167] 1. sequential:
[13:20:29.167]    - args: function (..., envir = parent.frame())
[13:20:29.167]    - tweaked: FALSE
[13:20:29.167]    - call: NULL
[13:20:29.168] plan(): nbrOfWorkers() = 1
[13:20:29.168] - globals found: [1] ‘{’
[13:20:29.169] Searching for globals ... DONE
[13:20:29.169] Resolving globals: FALSE
[13:20:29.169] 
[13:20:29.170] 
[13:20:29.170] getGlobalsAndPackages() ... DONE
[13:20:29.170] plan(): Setting new future strategy stack:
[13:20:29.170] run() for ‘Future’ ...
[13:20:29.170] - state: ‘created’
[13:20:29.170] List of future strategies:
[13:20:29.170] 1. multicore:
[13:20:29.170]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.170]    - tweaked: FALSE
[13:20:29.170]    - call: plan(strategy)
[13:20:29.171] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.176] plan(): nbrOfWorkers() = 2
[13:20:29.177] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.177] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.177]   - Field: ‘label’
[13:20:29.177]   - Field: ‘local’
[13:20:29.177]   - Field: ‘owner’
[13:20:29.177]   - Field: ‘envir’
[13:20:29.178]   - Field: ‘workers’
[13:20:29.178]   - Field: ‘packages’
[13:20:29.178]   - Field: ‘gc’
[13:20:29.178]   - Field: ‘job’
[13:20:29.178]   - Field: ‘conditions’
[13:20:29.178]   - Field: ‘expr’
[13:20:29.179]   - Field: ‘uuid’
[13:20:29.179]   - Field: ‘seed’
[13:20:29.179]   - Field: ‘version’
[13:20:29.179]   - Field: ‘result’
[13:20:29.179]   - Field: ‘asynchronous’
[13:20:29.179]   - Field: ‘calls’
[13:20:29.179]   - Field: ‘globals’
[13:20:29.180]   - Field: ‘stdout’
[13:20:29.180]   - Field: ‘earlySignal’
[13:20:29.180]   - Field: ‘lazy’
[13:20:29.180]   - Field: ‘state’
[13:20:29.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.180] - Launch lazy future ...
[13:20:29.181] Packages needed by the future expression (n = 0): <none>
[13:20:29.181] Packages needed by future strategies (n = 0): <none>
[13:20:29.182] {
[13:20:29.182]     {
[13:20:29.182]         {
[13:20:29.182]             ...future.startTime <- base::Sys.time()
[13:20:29.182]             {
[13:20:29.182]                 {
[13:20:29.182]                   {
[13:20:29.182]                     {
[13:20:29.182]                       base::local({
[13:20:29.182]                         has_future <- base::requireNamespace("future", 
[13:20:29.182]                           quietly = TRUE)
[13:20:29.182]                         if (has_future) {
[13:20:29.182]                           ns <- base::getNamespace("future")
[13:20:29.182]                           version <- ns[[".package"]][["version"]]
[13:20:29.182]                           if (is.null(version)) 
[13:20:29.182]                             version <- utils::packageVersion("future")
[13:20:29.182]                         }
[13:20:29.182]                         else {
[13:20:29.182]                           version <- NULL
[13:20:29.182]                         }
[13:20:29.182]                         if (!has_future || version < "1.8.0") {
[13:20:29.182]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.182]                             "", base::R.version$version.string), 
[13:20:29.182]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.182]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.182]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.182]                               "release", "version")], collapse = " "), 
[13:20:29.182]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.182]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.182]                             info)
[13:20:29.182]                           info <- base::paste(info, collapse = "; ")
[13:20:29.182]                           if (!has_future) {
[13:20:29.182]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.182]                               info)
[13:20:29.182]                           }
[13:20:29.182]                           else {
[13:20:29.182]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.182]                               info, version)
[13:20:29.182]                           }
[13:20:29.182]                           base::stop(msg)
[13:20:29.182]                         }
[13:20:29.182]                       })
[13:20:29.182]                     }
[13:20:29.182]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.182]                     base::options(mc.cores = 1L)
[13:20:29.182]                   }
[13:20:29.182]                   options(future.plan = NULL)
[13:20:29.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.182]                 }
[13:20:29.182]                 ...future.workdir <- getwd()
[13:20:29.182]             }
[13:20:29.182]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.182]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.182]         }
[13:20:29.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.182]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.182]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.182]             base::names(...future.oldOptions))
[13:20:29.182]     }
[13:20:29.182]     if (FALSE) {
[13:20:29.182]     }
[13:20:29.182]     else {
[13:20:29.182]         if (TRUE) {
[13:20:29.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.182]                 open = "w")
[13:20:29.182]         }
[13:20:29.182]         else {
[13:20:29.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.182]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.182]         }
[13:20:29.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.182]             base::sink(type = "output", split = FALSE)
[13:20:29.182]             base::close(...future.stdout)
[13:20:29.182]         }, add = TRUE)
[13:20:29.182]     }
[13:20:29.182]     ...future.frame <- base::sys.nframe()
[13:20:29.182]     ...future.conditions <- base::list()
[13:20:29.182]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.182]     if (FALSE) {
[13:20:29.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.182]     }
[13:20:29.182]     ...future.result <- base::tryCatch({
[13:20:29.182]         base::withCallingHandlers({
[13:20:29.182]             ...future.value <- base::withVisible(base::local({
[13:20:29.182]                 withCallingHandlers({
[13:20:29.182]                   {
[13:20:29.182]                     4
[13:20:29.182]                   }
[13:20:29.182]                 }, immediateCondition = function(cond) {
[13:20:29.182]                   save_rds <- function (object, pathname, ...) 
[13:20:29.182]                   {
[13:20:29.182]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.182]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.182]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.182]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.182]                         fi_tmp[["mtime"]])
[13:20:29.182]                     }
[13:20:29.182]                     tryCatch({
[13:20:29.182]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.182]                     }, error = function(ex) {
[13:20:29.182]                       msg <- conditionMessage(ex)
[13:20:29.182]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.182]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.182]                         fi_tmp[["mtime"]], msg)
[13:20:29.182]                       ex$message <- msg
[13:20:29.182]                       stop(ex)
[13:20:29.182]                     })
[13:20:29.182]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.182]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.182]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.182]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.182]                       fi <- file.info(pathname)
[13:20:29.182]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.182]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.182]                         fi[["size"]], fi[["mtime"]])
[13:20:29.182]                       stop(msg)
[13:20:29.182]                     }
[13:20:29.182]                     invisible(pathname)
[13:20:29.182]                   }
[13:20:29.182]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.182]                     rootPath = tempdir()) 
[13:20:29.182]                   {
[13:20:29.182]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.182]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.182]                       tmpdir = path, fileext = ".rds")
[13:20:29.182]                     save_rds(obj, file)
[13:20:29.182]                   }
[13:20:29.182]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.182]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.182]                   {
[13:20:29.182]                     inherits <- base::inherits
[13:20:29.182]                     invokeRestart <- base::invokeRestart
[13:20:29.182]                     is.null <- base::is.null
[13:20:29.182]                     muffled <- FALSE
[13:20:29.182]                     if (inherits(cond, "message")) {
[13:20:29.182]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.182]                       if (muffled) 
[13:20:29.182]                         invokeRestart("muffleMessage")
[13:20:29.182]                     }
[13:20:29.182]                     else if (inherits(cond, "warning")) {
[13:20:29.182]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.182]                       if (muffled) 
[13:20:29.182]                         invokeRestart("muffleWarning")
[13:20:29.182]                     }
[13:20:29.182]                     else if (inherits(cond, "condition")) {
[13:20:29.182]                       if (!is.null(pattern)) {
[13:20:29.182]                         computeRestarts <- base::computeRestarts
[13:20:29.182]                         grepl <- base::grepl
[13:20:29.182]                         restarts <- computeRestarts(cond)
[13:20:29.182]                         for (restart in restarts) {
[13:20:29.182]                           name <- restart$name
[13:20:29.182]                           if (is.null(name)) 
[13:20:29.182]                             next
[13:20:29.182]                           if (!grepl(pattern, name)) 
[13:20:29.182]                             next
[13:20:29.182]                           invokeRestart(restart)
[13:20:29.182]                           muffled <- TRUE
[13:20:29.182]                           break
[13:20:29.182]                         }
[13:20:29.182]                       }
[13:20:29.182]                     }
[13:20:29.182]                     invisible(muffled)
[13:20:29.182]                   }
[13:20:29.182]                   muffleCondition(cond)
[13:20:29.182]                 })
[13:20:29.182]             }))
[13:20:29.182]             future::FutureResult(value = ...future.value$value, 
[13:20:29.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.182]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.182]                     ...future.globalenv.names))
[13:20:29.182]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.182]         }, condition = base::local({
[13:20:29.182]             c <- base::c
[13:20:29.182]             inherits <- base::inherits
[13:20:29.182]             invokeRestart <- base::invokeRestart
[13:20:29.182]             length <- base::length
[13:20:29.182]             list <- base::list
[13:20:29.182]             seq.int <- base::seq.int
[13:20:29.182]             signalCondition <- base::signalCondition
[13:20:29.182]             sys.calls <- base::sys.calls
[13:20:29.182]             `[[` <- base::`[[`
[13:20:29.182]             `+` <- base::`+`
[13:20:29.182]             `<<-` <- base::`<<-`
[13:20:29.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.182]                   3L)]
[13:20:29.182]             }
[13:20:29.182]             function(cond) {
[13:20:29.182]                 is_error <- inherits(cond, "error")
[13:20:29.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.182]                   NULL)
[13:20:29.182]                 if (is_error) {
[13:20:29.182]                   sessionInformation <- function() {
[13:20:29.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.182]                       search = base::search(), system = base::Sys.info())
[13:20:29.182]                   }
[13:20:29.182]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.182]                     cond$call), session = sessionInformation(), 
[13:20:29.182]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.182]                   signalCondition(cond)
[13:20:29.182]                 }
[13:20:29.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.182]                 "immediateCondition"))) {
[13:20:29.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.182]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.182]                   if (TRUE && !signal) {
[13:20:29.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.182]                     {
[13:20:29.182]                       inherits <- base::inherits
[13:20:29.182]                       invokeRestart <- base::invokeRestart
[13:20:29.182]                       is.null <- base::is.null
[13:20:29.182]                       muffled <- FALSE
[13:20:29.182]                       if (inherits(cond, "message")) {
[13:20:29.182]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.182]                         if (muffled) 
[13:20:29.182]                           invokeRestart("muffleMessage")
[13:20:29.182]                       }
[13:20:29.182]                       else if (inherits(cond, "warning")) {
[13:20:29.182]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.182]                         if (muffled) 
[13:20:29.182]                           invokeRestart("muffleWarning")
[13:20:29.182]                       }
[13:20:29.182]                       else if (inherits(cond, "condition")) {
[13:20:29.182]                         if (!is.null(pattern)) {
[13:20:29.182]                           computeRestarts <- base::computeRestarts
[13:20:29.182]                           grepl <- base::grepl
[13:20:29.182]                           restarts <- computeRestarts(cond)
[13:20:29.182]                           for (restart in restarts) {
[13:20:29.182]                             name <- restart$name
[13:20:29.182]                             if (is.null(name)) 
[13:20:29.182]                               next
[13:20:29.182]                             if (!grepl(pattern, name)) 
[13:20:29.182]                               next
[13:20:29.182]                             invokeRestart(restart)
[13:20:29.182]                             muffled <- TRUE
[13:20:29.182]                             break
[13:20:29.182]                           }
[13:20:29.182]                         }
[13:20:29.182]                       }
[13:20:29.182]                       invisible(muffled)
[13:20:29.182]                     }
[13:20:29.182]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.182]                   }
[13:20:29.182]                 }
[13:20:29.182]                 else {
[13:20:29.182]                   if (TRUE) {
[13:20:29.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.182]                     {
[13:20:29.182]                       inherits <- base::inherits
[13:20:29.182]                       invokeRestart <- base::invokeRestart
[13:20:29.182]                       is.null <- base::is.null
[13:20:29.182]                       muffled <- FALSE
[13:20:29.182]                       if (inherits(cond, "message")) {
[13:20:29.182]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.182]                         if (muffled) 
[13:20:29.182]                           invokeRestart("muffleMessage")
[13:20:29.182]                       }
[13:20:29.182]                       else if (inherits(cond, "warning")) {
[13:20:29.182]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.182]                         if (muffled) 
[13:20:29.182]                           invokeRestart("muffleWarning")
[13:20:29.182]                       }
[13:20:29.182]                       else if (inherits(cond, "condition")) {
[13:20:29.182]                         if (!is.null(pattern)) {
[13:20:29.182]                           computeRestarts <- base::computeRestarts
[13:20:29.182]                           grepl <- base::grepl
[13:20:29.182]                           restarts <- computeRestarts(cond)
[13:20:29.182]                           for (restart in restarts) {
[13:20:29.182]                             name <- restart$name
[13:20:29.182]                             if (is.null(name)) 
[13:20:29.182]                               next
[13:20:29.182]                             if (!grepl(pattern, name)) 
[13:20:29.182]                               next
[13:20:29.182]                             invokeRestart(restart)
[13:20:29.182]                             muffled <- TRUE
[13:20:29.182]                             break
[13:20:29.182]                           }
[13:20:29.182]                         }
[13:20:29.182]                       }
[13:20:29.182]                       invisible(muffled)
[13:20:29.182]                     }
[13:20:29.182]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.182]                   }
[13:20:29.182]                 }
[13:20:29.182]             }
[13:20:29.182]         }))
[13:20:29.182]     }, error = function(ex) {
[13:20:29.182]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.182]                 ...future.rng), started = ...future.startTime, 
[13:20:29.182]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.182]             version = "1.8"), class = "FutureResult")
[13:20:29.182]     }, finally = {
[13:20:29.182]         if (!identical(...future.workdir, getwd())) 
[13:20:29.182]             setwd(...future.workdir)
[13:20:29.182]         {
[13:20:29.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.182]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.182]             }
[13:20:29.182]             base::options(...future.oldOptions)
[13:20:29.182]             if (.Platform$OS.type == "windows") {
[13:20:29.182]                 old_names <- names(...future.oldEnvVars)
[13:20:29.182]                 envs <- base::Sys.getenv()
[13:20:29.182]                 names <- names(envs)
[13:20:29.182]                 common <- intersect(names, old_names)
[13:20:29.182]                 added <- setdiff(names, old_names)
[13:20:29.182]                 removed <- setdiff(old_names, names)
[13:20:29.182]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.182]                   envs[common]]
[13:20:29.182]                 NAMES <- toupper(changed)
[13:20:29.182]                 args <- list()
[13:20:29.182]                 for (kk in seq_along(NAMES)) {
[13:20:29.182]                   name <- changed[[kk]]
[13:20:29.182]                   NAME <- NAMES[[kk]]
[13:20:29.182]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.182]                     next
[13:20:29.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.182]                 }
[13:20:29.182]                 NAMES <- toupper(added)
[13:20:29.182]                 for (kk in seq_along(NAMES)) {
[13:20:29.182]                   name <- added[[kk]]
[13:20:29.182]                   NAME <- NAMES[[kk]]
[13:20:29.182]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.182]                     next
[13:20:29.182]                   args[[name]] <- ""
[13:20:29.182]                 }
[13:20:29.182]                 NAMES <- toupper(removed)
[13:20:29.182]                 for (kk in seq_along(NAMES)) {
[13:20:29.182]                   name <- removed[[kk]]
[13:20:29.182]                   NAME <- NAMES[[kk]]
[13:20:29.182]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.182]                     next
[13:20:29.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.182]                 }
[13:20:29.182]                 if (length(args) > 0) 
[13:20:29.182]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.182]             }
[13:20:29.182]             else {
[13:20:29.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.182]             }
[13:20:29.182]             {
[13:20:29.182]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.182]                   0L) {
[13:20:29.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.182]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.182]                   base::options(opts)
[13:20:29.182]                 }
[13:20:29.182]                 {
[13:20:29.182]                   {
[13:20:29.182]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.182]                     NULL
[13:20:29.182]                   }
[13:20:29.182]                   options(future.plan = NULL)
[13:20:29.182]                   if (is.na(NA_character_)) 
[13:20:29.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.182]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.182]                     envir = parent.frame()) 
[13:20:29.182]                   {
[13:20:29.182]                     default_workers <- missing(workers)
[13:20:29.182]                     if (is.function(workers)) 
[13:20:29.182]                       workers <- workers()
[13:20:29.182]                     workers <- structure(as.integer(workers), 
[13:20:29.182]                       class = class(workers))
[13:20:29.182]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.182]                       1L)
[13:20:29.182]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.182]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.182]                       if (default_workers) 
[13:20:29.182]                         supportsMulticore(warn = TRUE)
[13:20:29.182]                       return(sequential(..., envir = envir))
[13:20:29.182]                     }
[13:20:29.182]                     oopts <- options(mc.cores = workers)
[13:20:29.182]                     on.exit(options(oopts))
[13:20:29.182]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.182]                       envir = envir)
[13:20:29.182]                     if (!future$lazy) 
[13:20:29.182]                       future <- run(future)
[13:20:29.182]                     invisible(future)
[13:20:29.182]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.182]                 }
[13:20:29.182]             }
[13:20:29.182]         }
[13:20:29.182]     })
[13:20:29.182]     if (TRUE) {
[13:20:29.182]         base::sink(type = "output", split = FALSE)
[13:20:29.182]         if (TRUE) {
[13:20:29.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.182]         }
[13:20:29.182]         else {
[13:20:29.182]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.182]         }
[13:20:29.182]         base::close(...future.stdout)
[13:20:29.182]         ...future.stdout <- NULL
[13:20:29.182]     }
[13:20:29.182]     ...future.result$conditions <- ...future.conditions
[13:20:29.182]     ...future.result$finished <- base::Sys.time()
[13:20:29.182]     ...future.result
[13:20:29.182] }
[13:20:29.185] requestCore(): workers = 2
[13:20:29.186] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:29.201] MulticoreFuture started
[13:20:29.201] - Launch lazy future ... done
[13:20:29.202] run() for ‘MulticoreFuture’ ... done
[13:20:29.202] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55659db3eb38> 
[13:20:29.202] List of future strategies:
[13:20:29.202] 1. sequential:
[13:20:29.202]    - args: function (..., envir = parent.frame())
[13:20:29.202]    - tweaked: FALSE
[13:20:29.202]    - call: NULL
[13:20:29.203] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x556599bd7300> 
 - attr(*, "dim.")=[13:20:29.206] plan(): Setting new future strategy stack:
[13:20:29.206] List of future strategies:
[13:20:29.206] 1. multicore:
[13:20:29.206]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.206]    - tweaked: FALSE
[13:20:29.206]    - call: plan(strategy)
 int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:20:29.212] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:29.216] resolve() on list environment ...
[13:20:29.216]  recursive: 0
[13:20:29.218]  length: 6
[13:20:29.218]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:29.218] signalConditionsASAP(numeric, pos=1) ...
[13:20:29.218] - nx: 6
[13:20:29.218] - relay: TRUE
[13:20:29.218] - stdout: TRUE
[13:20:29.219] - signal: TRUE
[13:20:29.219] - resignal: FALSE
[13:20:29.219] - force: TRUE
[13:20:29.219] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.219] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.219]  - until=2
[13:20:29.219]  - relaying element #2
[13:20:29.219] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.220] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.220] signalConditionsASAP(NULL, pos=1) ... done
[13:20:29.220]  length: 5 (resolved future 1)
[13:20:29.220] Future #2
[13:20:29.220] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:29.221] - nx: 6
[13:20:29.221] - relay: TRUE
[13:20:29.221] - stdout: TRUE
[13:20:29.221] - signal: TRUE
[13:20:29.221] - resignal: FALSE
[13:20:29.221] - force: TRUE
[13:20:29.221] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.221] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.222]  - until=2
[13:20:29.222]  - relaying element #2
[13:20:29.222] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.222] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.222] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:29.222]  length: 4 (resolved future 2)
[13:20:29.223] Future #3
[13:20:29.224] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:29.224] - nx: 6
[13:20:29.224] - relay: TRUE
[13:20:29.224] - stdout: TRUE
[13:20:29.224] - signal: TRUE
[13:20:29.225] - resignal: FALSE
[13:20:29.225] - force: TRUE
[13:20:29.225] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.225] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.225]  - until=3
[13:20:29.226]  - relaying element #3
[13:20:29.226] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.226] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.226] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:29.227]  length: 3 (resolved future 3)
[13:20:29.227] Future #4
[13:20:29.228] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:20:29.228] - nx: 6
[13:20:29.228] - relay: TRUE
[13:20:29.228] - stdout: TRUE
[13:20:29.228] - signal: TRUE
[13:20:29.229] - resignal: FALSE
[13:20:29.229] - force: TRUE
[13:20:29.229] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.229] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.229]  - until=4
[13:20:29.229]  - relaying element #4
[13:20:29.230] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.230] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.230] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:20:29.230]  length: 2 (resolved future 4)
[13:20:29.230] signalConditionsASAP(NULL, pos=5) ...
[13:20:29.230] - nx: 6
[13:20:29.230] - relay: TRUE
[13:20:29.230] - stdout: TRUE
[13:20:29.231] - signal: TRUE
[13:20:29.231] - resignal: FALSE
[13:20:29.231] - force: TRUE
[13:20:29.231] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.231] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.231]  - until=6
[13:20:29.231]  - relaying element #6
[13:20:29.231] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:29.231] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.232] signalConditionsASAP(NULL, pos=5) ... done
[13:20:29.232]  length: 1 (resolved future 5)
[13:20:29.232] signalConditionsASAP(numeric, pos=6) ...
[13:20:29.232] - nx: 6
[13:20:29.232] - relay: TRUE
[13:20:29.232] - stdout: TRUE
[13:20:29.232] - signal: TRUE
[13:20:29.232] - resignal: FALSE
[13:20:29.232] - force: TRUE
[13:20:29.233] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:29.233] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.233]  - until=6
[13:20:29.233] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.233] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.233] signalConditionsASAP(numeric, pos=6) ... done
[13:20:29.233]  length: 0 (resolved future 6)
[13:20:29.233] Relaying remaining futures
[13:20:29.234] signalConditionsASAP(NULL, pos=0) ...
[13:20:29.234] - nx: 6
[13:20:29.234] - relay: TRUE
[13:20:29.234] - stdout: TRUE
[13:20:29.234] - signal: TRUE
[13:20:29.234] - resignal: FALSE
[13:20:29.234] - force: TRUE
[13:20:29.234] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.234] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:29.235] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.235] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.235] signalConditionsASAP(NULL, pos=0) ... done
[13:20:29.235] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55659999cbc0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:20:29.237] getGlobalsAndPackages() ...
[13:20:29.238] Searching for globals...
[13:20:29.238] 
[13:20:29.238] Searching for globals ... DONE
[13:20:29.238] - globals: [0] <none>
[13:20:29.238] getGlobalsAndPackages() ... DONE
[13:20:29.239] run() for ‘Future’ ...
[13:20:29.239] - state: ‘created’
[13:20:29.239] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.244] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.244] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.244]   - Field: ‘label’
[13:20:29.244]   - Field: ‘local’
[13:20:29.245]   - Field: ‘owner’
[13:20:29.245]   - Field: ‘envir’
[13:20:29.245]   - Field: ‘workers’
[13:20:29.245]   - Field: ‘packages’
[13:20:29.245]   - Field: ‘gc’
[13:20:29.245]   - Field: ‘job’
[13:20:29.245]   - Field: ‘conditions’
[13:20:29.245]   - Field: ‘expr’
[13:20:29.246]   - Field: ‘uuid’
[13:20:29.246]   - Field: ‘seed’
[13:20:29.246]   - Field: ‘version’
[13:20:29.246]   - Field: ‘result’
[13:20:29.246]   - Field: ‘asynchronous’
[13:20:29.246]   - Field: ‘calls’
[13:20:29.246]   - Field: ‘globals’
[13:20:29.246]   - Field: ‘stdout’
[13:20:29.246]   - Field: ‘earlySignal’
[13:20:29.247]   - Field: ‘lazy’
[13:20:29.247]   - Field: ‘state’
[13:20:29.247] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.247] - Launch lazy future ...
[13:20:29.247] Packages needed by the future expression (n = 0): <none>
[13:20:29.247] Packages needed by future strategies (n = 0): <none>
[13:20:29.248] {
[13:20:29.248]     {
[13:20:29.248]         {
[13:20:29.248]             ...future.startTime <- base::Sys.time()
[13:20:29.248]             {
[13:20:29.248]                 {
[13:20:29.248]                   {
[13:20:29.248]                     {
[13:20:29.248]                       base::local({
[13:20:29.248]                         has_future <- base::requireNamespace("future", 
[13:20:29.248]                           quietly = TRUE)
[13:20:29.248]                         if (has_future) {
[13:20:29.248]                           ns <- base::getNamespace("future")
[13:20:29.248]                           version <- ns[[".package"]][["version"]]
[13:20:29.248]                           if (is.null(version)) 
[13:20:29.248]                             version <- utils::packageVersion("future")
[13:20:29.248]                         }
[13:20:29.248]                         else {
[13:20:29.248]                           version <- NULL
[13:20:29.248]                         }
[13:20:29.248]                         if (!has_future || version < "1.8.0") {
[13:20:29.248]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.248]                             "", base::R.version$version.string), 
[13:20:29.248]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.248]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.248]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.248]                               "release", "version")], collapse = " "), 
[13:20:29.248]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.248]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.248]                             info)
[13:20:29.248]                           info <- base::paste(info, collapse = "; ")
[13:20:29.248]                           if (!has_future) {
[13:20:29.248]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.248]                               info)
[13:20:29.248]                           }
[13:20:29.248]                           else {
[13:20:29.248]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.248]                               info, version)
[13:20:29.248]                           }
[13:20:29.248]                           base::stop(msg)
[13:20:29.248]                         }
[13:20:29.248]                       })
[13:20:29.248]                     }
[13:20:29.248]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.248]                     base::options(mc.cores = 1L)
[13:20:29.248]                   }
[13:20:29.248]                   options(future.plan = NULL)
[13:20:29.248]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.248]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.248]                 }
[13:20:29.248]                 ...future.workdir <- getwd()
[13:20:29.248]             }
[13:20:29.248]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.248]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.248]         }
[13:20:29.248]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.248]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.248]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.248]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.248]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.248]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.248]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.248]             base::names(...future.oldOptions))
[13:20:29.248]     }
[13:20:29.248]     if (FALSE) {
[13:20:29.248]     }
[13:20:29.248]     else {
[13:20:29.248]         if (TRUE) {
[13:20:29.248]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.248]                 open = "w")
[13:20:29.248]         }
[13:20:29.248]         else {
[13:20:29.248]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.248]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.248]         }
[13:20:29.248]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.248]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.248]             base::sink(type = "output", split = FALSE)
[13:20:29.248]             base::close(...future.stdout)
[13:20:29.248]         }, add = TRUE)
[13:20:29.248]     }
[13:20:29.248]     ...future.frame <- base::sys.nframe()
[13:20:29.248]     ...future.conditions <- base::list()
[13:20:29.248]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.248]     if (FALSE) {
[13:20:29.248]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.248]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.248]     }
[13:20:29.248]     ...future.result <- base::tryCatch({
[13:20:29.248]         base::withCallingHandlers({
[13:20:29.248]             ...future.value <- base::withVisible(base::local({
[13:20:29.248]                 withCallingHandlers({
[13:20:29.248]                   2
[13:20:29.248]                 }, immediateCondition = function(cond) {
[13:20:29.248]                   save_rds <- function (object, pathname, ...) 
[13:20:29.248]                   {
[13:20:29.248]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.248]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.248]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.248]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.248]                         fi_tmp[["mtime"]])
[13:20:29.248]                     }
[13:20:29.248]                     tryCatch({
[13:20:29.248]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.248]                     }, error = function(ex) {
[13:20:29.248]                       msg <- conditionMessage(ex)
[13:20:29.248]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.248]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.248]                         fi_tmp[["mtime"]], msg)
[13:20:29.248]                       ex$message <- msg
[13:20:29.248]                       stop(ex)
[13:20:29.248]                     })
[13:20:29.248]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.248]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.248]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.248]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.248]                       fi <- file.info(pathname)
[13:20:29.248]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.248]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.248]                         fi[["size"]], fi[["mtime"]])
[13:20:29.248]                       stop(msg)
[13:20:29.248]                     }
[13:20:29.248]                     invisible(pathname)
[13:20:29.248]                   }
[13:20:29.248]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.248]                     rootPath = tempdir()) 
[13:20:29.248]                   {
[13:20:29.248]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.248]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.248]                       tmpdir = path, fileext = ".rds")
[13:20:29.248]                     save_rds(obj, file)
[13:20:29.248]                   }
[13:20:29.248]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.248]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.248]                   {
[13:20:29.248]                     inherits <- base::inherits
[13:20:29.248]                     invokeRestart <- base::invokeRestart
[13:20:29.248]                     is.null <- base::is.null
[13:20:29.248]                     muffled <- FALSE
[13:20:29.248]                     if (inherits(cond, "message")) {
[13:20:29.248]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.248]                       if (muffled) 
[13:20:29.248]                         invokeRestart("muffleMessage")
[13:20:29.248]                     }
[13:20:29.248]                     else if (inherits(cond, "warning")) {
[13:20:29.248]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.248]                       if (muffled) 
[13:20:29.248]                         invokeRestart("muffleWarning")
[13:20:29.248]                     }
[13:20:29.248]                     else if (inherits(cond, "condition")) {
[13:20:29.248]                       if (!is.null(pattern)) {
[13:20:29.248]                         computeRestarts <- base::computeRestarts
[13:20:29.248]                         grepl <- base::grepl
[13:20:29.248]                         restarts <- computeRestarts(cond)
[13:20:29.248]                         for (restart in restarts) {
[13:20:29.248]                           name <- restart$name
[13:20:29.248]                           if (is.null(name)) 
[13:20:29.248]                             next
[13:20:29.248]                           if (!grepl(pattern, name)) 
[13:20:29.248]                             next
[13:20:29.248]                           invokeRestart(restart)
[13:20:29.248]                           muffled <- TRUE
[13:20:29.248]                           break
[13:20:29.248]                         }
[13:20:29.248]                       }
[13:20:29.248]                     }
[13:20:29.248]                     invisible(muffled)
[13:20:29.248]                   }
[13:20:29.248]                   muffleCondition(cond)
[13:20:29.248]                 })
[13:20:29.248]             }))
[13:20:29.248]             future::FutureResult(value = ...future.value$value, 
[13:20:29.248]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.248]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.248]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.248]                     ...future.globalenv.names))
[13:20:29.248]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.248]         }, condition = base::local({
[13:20:29.248]             c <- base::c
[13:20:29.248]             inherits <- base::inherits
[13:20:29.248]             invokeRestart <- base::invokeRestart
[13:20:29.248]             length <- base::length
[13:20:29.248]             list <- base::list
[13:20:29.248]             seq.int <- base::seq.int
[13:20:29.248]             signalCondition <- base::signalCondition
[13:20:29.248]             sys.calls <- base::sys.calls
[13:20:29.248]             `[[` <- base::`[[`
[13:20:29.248]             `+` <- base::`+`
[13:20:29.248]             `<<-` <- base::`<<-`
[13:20:29.248]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.248]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.248]                   3L)]
[13:20:29.248]             }
[13:20:29.248]             function(cond) {
[13:20:29.248]                 is_error <- inherits(cond, "error")
[13:20:29.248]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.248]                   NULL)
[13:20:29.248]                 if (is_error) {
[13:20:29.248]                   sessionInformation <- function() {
[13:20:29.248]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.248]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.248]                       search = base::search(), system = base::Sys.info())
[13:20:29.248]                   }
[13:20:29.248]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.248]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.248]                     cond$call), session = sessionInformation(), 
[13:20:29.248]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.248]                   signalCondition(cond)
[13:20:29.248]                 }
[13:20:29.248]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.248]                 "immediateCondition"))) {
[13:20:29.248]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.248]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.248]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.248]                   if (TRUE && !signal) {
[13:20:29.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.248]                     {
[13:20:29.248]                       inherits <- base::inherits
[13:20:29.248]                       invokeRestart <- base::invokeRestart
[13:20:29.248]                       is.null <- base::is.null
[13:20:29.248]                       muffled <- FALSE
[13:20:29.248]                       if (inherits(cond, "message")) {
[13:20:29.248]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.248]                         if (muffled) 
[13:20:29.248]                           invokeRestart("muffleMessage")
[13:20:29.248]                       }
[13:20:29.248]                       else if (inherits(cond, "warning")) {
[13:20:29.248]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.248]                         if (muffled) 
[13:20:29.248]                           invokeRestart("muffleWarning")
[13:20:29.248]                       }
[13:20:29.248]                       else if (inherits(cond, "condition")) {
[13:20:29.248]                         if (!is.null(pattern)) {
[13:20:29.248]                           computeRestarts <- base::computeRestarts
[13:20:29.248]                           grepl <- base::grepl
[13:20:29.248]                           restarts <- computeRestarts(cond)
[13:20:29.248]                           for (restart in restarts) {
[13:20:29.248]                             name <- restart$name
[13:20:29.248]                             if (is.null(name)) 
[13:20:29.248]                               next
[13:20:29.248]                             if (!grepl(pattern, name)) 
[13:20:29.248]                               next
[13:20:29.248]                             invokeRestart(restart)
[13:20:29.248]                             muffled <- TRUE
[13:20:29.248]                             break
[13:20:29.248]                           }
[13:20:29.248]                         }
[13:20:29.248]                       }
[13:20:29.248]                       invisible(muffled)
[13:20:29.248]                     }
[13:20:29.248]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.248]                   }
[13:20:29.248]                 }
[13:20:29.248]                 else {
[13:20:29.248]                   if (TRUE) {
[13:20:29.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.248]                     {
[13:20:29.248]                       inherits <- base::inherits
[13:20:29.248]                       invokeRestart <- base::invokeRestart
[13:20:29.248]                       is.null <- base::is.null
[13:20:29.248]                       muffled <- FALSE
[13:20:29.248]                       if (inherits(cond, "message")) {
[13:20:29.248]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.248]                         if (muffled) 
[13:20:29.248]                           invokeRestart("muffleMessage")
[13:20:29.248]                       }
[13:20:29.248]                       else if (inherits(cond, "warning")) {
[13:20:29.248]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.248]                         if (muffled) 
[13:20:29.248]                           invokeRestart("muffleWarning")
[13:20:29.248]                       }
[13:20:29.248]                       else if (inherits(cond, "condition")) {
[13:20:29.248]                         if (!is.null(pattern)) {
[13:20:29.248]                           computeRestarts <- base::computeRestarts
[13:20:29.248]                           grepl <- base::grepl
[13:20:29.248]                           restarts <- computeRestarts(cond)
[13:20:29.248]                           for (restart in restarts) {
[13:20:29.248]                             name <- restart$name
[13:20:29.248]                             if (is.null(name)) 
[13:20:29.248]                               next
[13:20:29.248]                             if (!grepl(pattern, name)) 
[13:20:29.248]                               next
[13:20:29.248]                             invokeRestart(restart)
[13:20:29.248]                             muffled <- TRUE
[13:20:29.248]                             break
[13:20:29.248]                           }
[13:20:29.248]                         }
[13:20:29.248]                       }
[13:20:29.248]                       invisible(muffled)
[13:20:29.248]                     }
[13:20:29.248]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.248]                   }
[13:20:29.248]                 }
[13:20:29.248]             }
[13:20:29.248]         }))
[13:20:29.248]     }, error = function(ex) {
[13:20:29.248]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.248]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.248]                 ...future.rng), started = ...future.startTime, 
[13:20:29.248]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.248]             version = "1.8"), class = "FutureResult")
[13:20:29.248]     }, finally = {
[13:20:29.248]         if (!identical(...future.workdir, getwd())) 
[13:20:29.248]             setwd(...future.workdir)
[13:20:29.248]         {
[13:20:29.248]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.248]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.248]             }
[13:20:29.248]             base::options(...future.oldOptions)
[13:20:29.248]             if (.Platform$OS.type == "windows") {
[13:20:29.248]                 old_names <- names(...future.oldEnvVars)
[13:20:29.248]                 envs <- base::Sys.getenv()
[13:20:29.248]                 names <- names(envs)
[13:20:29.248]                 common <- intersect(names, old_names)
[13:20:29.248]                 added <- setdiff(names, old_names)
[13:20:29.248]                 removed <- setdiff(old_names, names)
[13:20:29.248]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.248]                   envs[common]]
[13:20:29.248]                 NAMES <- toupper(changed)
[13:20:29.248]                 args <- list()
[13:20:29.248]                 for (kk in seq_along(NAMES)) {
[13:20:29.248]                   name <- changed[[kk]]
[13:20:29.248]                   NAME <- NAMES[[kk]]
[13:20:29.248]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.248]                     next
[13:20:29.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.248]                 }
[13:20:29.248]                 NAMES <- toupper(added)
[13:20:29.248]                 for (kk in seq_along(NAMES)) {
[13:20:29.248]                   name <- added[[kk]]
[13:20:29.248]                   NAME <- NAMES[[kk]]
[13:20:29.248]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.248]                     next
[13:20:29.248]                   args[[name]] <- ""
[13:20:29.248]                 }
[13:20:29.248]                 NAMES <- toupper(removed)
[13:20:29.248]                 for (kk in seq_along(NAMES)) {
[13:20:29.248]                   name <- removed[[kk]]
[13:20:29.248]                   NAME <- NAMES[[kk]]
[13:20:29.248]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.248]                     next
[13:20:29.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.248]                 }
[13:20:29.248]                 if (length(args) > 0) 
[13:20:29.248]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.248]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.248]             }
[13:20:29.248]             else {
[13:20:29.248]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.248]             }
[13:20:29.248]             {
[13:20:29.248]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.248]                   0L) {
[13:20:29.248]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.248]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.248]                   base::options(opts)
[13:20:29.248]                 }
[13:20:29.248]                 {
[13:20:29.248]                   {
[13:20:29.248]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.248]                     NULL
[13:20:29.248]                   }
[13:20:29.248]                   options(future.plan = NULL)
[13:20:29.248]                   if (is.na(NA_character_)) 
[13:20:29.248]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.248]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.248]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.248]                     envir = parent.frame()) 
[13:20:29.248]                   {
[13:20:29.248]                     default_workers <- missing(workers)
[13:20:29.248]                     if (is.function(workers)) 
[13:20:29.248]                       workers <- workers()
[13:20:29.248]                     workers <- structure(as.integer(workers), 
[13:20:29.248]                       class = class(workers))
[13:20:29.248]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.248]                       1L)
[13:20:29.248]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.248]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.248]                       if (default_workers) 
[13:20:29.248]                         supportsMulticore(warn = TRUE)
[13:20:29.248]                       return(sequential(..., envir = envir))
[13:20:29.248]                     }
[13:20:29.248]                     oopts <- options(mc.cores = workers)
[13:20:29.248]                     on.exit(options(oopts))
[13:20:29.248]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.248]                       envir = envir)
[13:20:29.248]                     if (!future$lazy) 
[13:20:29.248]                       future <- run(future)
[13:20:29.248]                     invisible(future)
[13:20:29.248]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.248]                 }
[13:20:29.248]             }
[13:20:29.248]         }
[13:20:29.248]     })
[13:20:29.248]     if (TRUE) {
[13:20:29.248]         base::sink(type = "output", split = FALSE)
[13:20:29.248]         if (TRUE) {
[13:20:29.248]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.248]         }
[13:20:29.248]         else {
[13:20:29.248]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.248]         }
[13:20:29.248]         base::close(...future.stdout)
[13:20:29.248]         ...future.stdout <- NULL
[13:20:29.248]     }
[13:20:29.248]     ...future.result$conditions <- ...future.conditions
[13:20:29.248]     ...future.result$finished <- base::Sys.time()
[13:20:29.248]     ...future.result
[13:20:29.248] }
[13:20:29.251] requestCore(): workers = 2
[13:20:29.254] MulticoreFuture started
[13:20:29.254] - Launch lazy future ... done
[13:20:29.254] run() for ‘MulticoreFuture’ ... done
[13:20:29.255] getGlobalsAndPackages() ...
[13:20:29.255] Searching for globals...
[13:20:29.255] plan(): Setting new future strategy stack:
[13:20:29.256] 
[13:20:29.255] List of future strategies:
[13:20:29.255] 1. sequential:
[13:20:29.255]    - args: function (..., envir = parent.frame())
[13:20:29.255]    - tweaked: FALSE
[13:20:29.255]    - call: NULL
[13:20:29.256] Searching for globals ... DONE
[13:20:29.256] - globals: [0] <none>
[13:20:29.256] plan(): nbrOfWorkers() = 1
[13:20:29.256] getGlobalsAndPackages() ... DONE
[13:20:29.257] run() for ‘Future’ ...
[13:20:29.257] - state: ‘created’
[13:20:29.257] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.258] plan(): Setting new future strategy stack:
[13:20:29.258] List of future strategies:
[13:20:29.258] 1. multicore:
[13:20:29.258]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.258]    - tweaked: FALSE
[13:20:29.258]    - call: plan(strategy)
[13:20:29.263] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.263] plan(): nbrOfWorkers() = 2
[13:20:29.263] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.263]   - Field: ‘label’
[13:20:29.263]   - Field: ‘local’
[13:20:29.263]   - Field: ‘owner’
[13:20:29.263]   - Field: ‘envir’
[13:20:29.264]   - Field: ‘workers’
[13:20:29.264]   - Field: ‘packages’
[13:20:29.264]   - Field: ‘gc’
[13:20:29.264]   - Field: ‘job’
[13:20:29.264]   - Field: ‘conditions’
[13:20:29.264]   - Field: ‘expr’
[13:20:29.264]   - Field: ‘uuid’
[13:20:29.265]   - Field: ‘seed’
[13:20:29.265]   - Field: ‘version’
[13:20:29.265]   - Field: ‘result’
[13:20:29.265]   - Field: ‘asynchronous’
[13:20:29.265]   - Field: ‘calls’
[13:20:29.265]   - Field: ‘globals’
[13:20:29.265]   - Field: ‘stdout’
[13:20:29.266]   - Field: ‘earlySignal’
[13:20:29.266]   - Field: ‘lazy’
[13:20:29.266]   - Field: ‘state’
[13:20:29.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.266] - Launch lazy future ...
[13:20:29.267] Packages needed by the future expression (n = 0): <none>
[13:20:29.267] Packages needed by future strategies (n = 0): <none>
[13:20:29.268] {
[13:20:29.268]     {
[13:20:29.268]         {
[13:20:29.268]             ...future.startTime <- base::Sys.time()
[13:20:29.268]             {
[13:20:29.268]                 {
[13:20:29.268]                   {
[13:20:29.268]                     {
[13:20:29.268]                       base::local({
[13:20:29.268]                         has_future <- base::requireNamespace("future", 
[13:20:29.268]                           quietly = TRUE)
[13:20:29.268]                         if (has_future) {
[13:20:29.268]                           ns <- base::getNamespace("future")
[13:20:29.268]                           version <- ns[[".package"]][["version"]]
[13:20:29.268]                           if (is.null(version)) 
[13:20:29.268]                             version <- utils::packageVersion("future")
[13:20:29.268]                         }
[13:20:29.268]                         else {
[13:20:29.268]                           version <- NULL
[13:20:29.268]                         }
[13:20:29.268]                         if (!has_future || version < "1.8.0") {
[13:20:29.268]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.268]                             "", base::R.version$version.string), 
[13:20:29.268]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.268]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.268]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.268]                               "release", "version")], collapse = " "), 
[13:20:29.268]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.268]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.268]                             info)
[13:20:29.268]                           info <- base::paste(info, collapse = "; ")
[13:20:29.268]                           if (!has_future) {
[13:20:29.268]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.268]                               info)
[13:20:29.268]                           }
[13:20:29.268]                           else {
[13:20:29.268]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.268]                               info, version)
[13:20:29.268]                           }
[13:20:29.268]                           base::stop(msg)
[13:20:29.268]                         }
[13:20:29.268]                       })
[13:20:29.268]                     }
[13:20:29.268]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.268]                     base::options(mc.cores = 1L)
[13:20:29.268]                   }
[13:20:29.268]                   options(future.plan = NULL)
[13:20:29.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.268]                 }
[13:20:29.268]                 ...future.workdir <- getwd()
[13:20:29.268]             }
[13:20:29.268]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.268]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.268]         }
[13:20:29.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.268]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.268]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.268]             base::names(...future.oldOptions))
[13:20:29.268]     }
[13:20:29.268]     if (FALSE) {
[13:20:29.268]     }
[13:20:29.268]     else {
[13:20:29.268]         if (TRUE) {
[13:20:29.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.268]                 open = "w")
[13:20:29.268]         }
[13:20:29.268]         else {
[13:20:29.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.268]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.268]         }
[13:20:29.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.268]             base::sink(type = "output", split = FALSE)
[13:20:29.268]             base::close(...future.stdout)
[13:20:29.268]         }, add = TRUE)
[13:20:29.268]     }
[13:20:29.268]     ...future.frame <- base::sys.nframe()
[13:20:29.268]     ...future.conditions <- base::list()
[13:20:29.268]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.268]     if (FALSE) {
[13:20:29.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.268]     }
[13:20:29.268]     ...future.result <- base::tryCatch({
[13:20:29.268]         base::withCallingHandlers({
[13:20:29.268]             ...future.value <- base::withVisible(base::local({
[13:20:29.268]                 withCallingHandlers({
[13:20:29.268]                   NULL
[13:20:29.268]                 }, immediateCondition = function(cond) {
[13:20:29.268]                   save_rds <- function (object, pathname, ...) 
[13:20:29.268]                   {
[13:20:29.268]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.268]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.268]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.268]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.268]                         fi_tmp[["mtime"]])
[13:20:29.268]                     }
[13:20:29.268]                     tryCatch({
[13:20:29.268]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.268]                     }, error = function(ex) {
[13:20:29.268]                       msg <- conditionMessage(ex)
[13:20:29.268]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.268]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.268]                         fi_tmp[["mtime"]], msg)
[13:20:29.268]                       ex$message <- msg
[13:20:29.268]                       stop(ex)
[13:20:29.268]                     })
[13:20:29.268]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.268]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.268]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.268]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.268]                       fi <- file.info(pathname)
[13:20:29.268]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.268]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.268]                         fi[["size"]], fi[["mtime"]])
[13:20:29.268]                       stop(msg)
[13:20:29.268]                     }
[13:20:29.268]                     invisible(pathname)
[13:20:29.268]                   }
[13:20:29.268]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.268]                     rootPath = tempdir()) 
[13:20:29.268]                   {
[13:20:29.268]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.268]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.268]                       tmpdir = path, fileext = ".rds")
[13:20:29.268]                     save_rds(obj, file)
[13:20:29.268]                   }
[13:20:29.268]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.268]                   {
[13:20:29.268]                     inherits <- base::inherits
[13:20:29.268]                     invokeRestart <- base::invokeRestart
[13:20:29.268]                     is.null <- base::is.null
[13:20:29.268]                     muffled <- FALSE
[13:20:29.268]                     if (inherits(cond, "message")) {
[13:20:29.268]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.268]                       if (muffled) 
[13:20:29.268]                         invokeRestart("muffleMessage")
[13:20:29.268]                     }
[13:20:29.268]                     else if (inherits(cond, "warning")) {
[13:20:29.268]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.268]                       if (muffled) 
[13:20:29.268]                         invokeRestart("muffleWarning")
[13:20:29.268]                     }
[13:20:29.268]                     else if (inherits(cond, "condition")) {
[13:20:29.268]                       if (!is.null(pattern)) {
[13:20:29.268]                         computeRestarts <- base::computeRestarts
[13:20:29.268]                         grepl <- base::grepl
[13:20:29.268]                         restarts <- computeRestarts(cond)
[13:20:29.268]                         for (restart in restarts) {
[13:20:29.268]                           name <- restart$name
[13:20:29.268]                           if (is.null(name)) 
[13:20:29.268]                             next
[13:20:29.268]                           if (!grepl(pattern, name)) 
[13:20:29.268]                             next
[13:20:29.268]                           invokeRestart(restart)
[13:20:29.268]                           muffled <- TRUE
[13:20:29.268]                           break
[13:20:29.268]                         }
[13:20:29.268]                       }
[13:20:29.268]                     }
[13:20:29.268]                     invisible(muffled)
[13:20:29.268]                   }
[13:20:29.268]                   muffleCondition(cond)
[13:20:29.268]                 })
[13:20:29.268]             }))
[13:20:29.268]             future::FutureResult(value = ...future.value$value, 
[13:20:29.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.268]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.268]                     ...future.globalenv.names))
[13:20:29.268]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.268]         }, condition = base::local({
[13:20:29.268]             c <- base::c
[13:20:29.268]             inherits <- base::inherits
[13:20:29.268]             invokeRestart <- base::invokeRestart
[13:20:29.268]             length <- base::length
[13:20:29.268]             list <- base::list
[13:20:29.268]             seq.int <- base::seq.int
[13:20:29.268]             signalCondition <- base::signalCondition
[13:20:29.268]             sys.calls <- base::sys.calls
[13:20:29.268]             `[[` <- base::`[[`
[13:20:29.268]             `+` <- base::`+`
[13:20:29.268]             `<<-` <- base::`<<-`
[13:20:29.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.268]                   3L)]
[13:20:29.268]             }
[13:20:29.268]             function(cond) {
[13:20:29.268]                 is_error <- inherits(cond, "error")
[13:20:29.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.268]                   NULL)
[13:20:29.268]                 if (is_error) {
[13:20:29.268]                   sessionInformation <- function() {
[13:20:29.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.268]                       search = base::search(), system = base::Sys.info())
[13:20:29.268]                   }
[13:20:29.268]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.268]                     cond$call), session = sessionInformation(), 
[13:20:29.268]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.268]                   signalCondition(cond)
[13:20:29.268]                 }
[13:20:29.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.268]                 "immediateCondition"))) {
[13:20:29.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.268]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.268]                   if (TRUE && !signal) {
[13:20:29.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.268]                     {
[13:20:29.268]                       inherits <- base::inherits
[13:20:29.268]                       invokeRestart <- base::invokeRestart
[13:20:29.268]                       is.null <- base::is.null
[13:20:29.268]                       muffled <- FALSE
[13:20:29.268]                       if (inherits(cond, "message")) {
[13:20:29.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.268]                         if (muffled) 
[13:20:29.268]                           invokeRestart("muffleMessage")
[13:20:29.268]                       }
[13:20:29.268]                       else if (inherits(cond, "warning")) {
[13:20:29.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.268]                         if (muffled) 
[13:20:29.268]                           invokeRestart("muffleWarning")
[13:20:29.268]                       }
[13:20:29.268]                       else if (inherits(cond, "condition")) {
[13:20:29.268]                         if (!is.null(pattern)) {
[13:20:29.268]                           computeRestarts <- base::computeRestarts
[13:20:29.268]                           grepl <- base::grepl
[13:20:29.268]                           restarts <- computeRestarts(cond)
[13:20:29.268]                           for (restart in restarts) {
[13:20:29.268]                             name <- restart$name
[13:20:29.268]                             if (is.null(name)) 
[13:20:29.268]                               next
[13:20:29.268]                             if (!grepl(pattern, name)) 
[13:20:29.268]                               next
[13:20:29.268]                             invokeRestart(restart)
[13:20:29.268]                             muffled <- TRUE
[13:20:29.268]                             break
[13:20:29.268]                           }
[13:20:29.268]                         }
[13:20:29.268]                       }
[13:20:29.268]                       invisible(muffled)
[13:20:29.268]                     }
[13:20:29.268]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.268]                   }
[13:20:29.268]                 }
[13:20:29.268]                 else {
[13:20:29.268]                   if (TRUE) {
[13:20:29.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.268]                     {
[13:20:29.268]                       inherits <- base::inherits
[13:20:29.268]                       invokeRestart <- base::invokeRestart
[13:20:29.268]                       is.null <- base::is.null
[13:20:29.268]                       muffled <- FALSE
[13:20:29.268]                       if (inherits(cond, "message")) {
[13:20:29.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.268]                         if (muffled) 
[13:20:29.268]                           invokeRestart("muffleMessage")
[13:20:29.268]                       }
[13:20:29.268]                       else if (inherits(cond, "warning")) {
[13:20:29.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.268]                         if (muffled) 
[13:20:29.268]                           invokeRestart("muffleWarning")
[13:20:29.268]                       }
[13:20:29.268]                       else if (inherits(cond, "condition")) {
[13:20:29.268]                         if (!is.null(pattern)) {
[13:20:29.268]                           computeRestarts <- base::computeRestarts
[13:20:29.268]                           grepl <- base::grepl
[13:20:29.268]                           restarts <- computeRestarts(cond)
[13:20:29.268]                           for (restart in restarts) {
[13:20:29.268]                             name <- restart$name
[13:20:29.268]                             if (is.null(name)) 
[13:20:29.268]                               next
[13:20:29.268]                             if (!grepl(pattern, name)) 
[13:20:29.268]                               next
[13:20:29.268]                             invokeRestart(restart)
[13:20:29.268]                             muffled <- TRUE
[13:20:29.268]                             break
[13:20:29.268]                           }
[13:20:29.268]                         }
[13:20:29.268]                       }
[13:20:29.268]                       invisible(muffled)
[13:20:29.268]                     }
[13:20:29.268]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.268]                   }
[13:20:29.268]                 }
[13:20:29.268]             }
[13:20:29.268]         }))
[13:20:29.268]     }, error = function(ex) {
[13:20:29.268]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.268]                 ...future.rng), started = ...future.startTime, 
[13:20:29.268]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.268]             version = "1.8"), class = "FutureResult")
[13:20:29.268]     }, finally = {
[13:20:29.268]         if (!identical(...future.workdir, getwd())) 
[13:20:29.268]             setwd(...future.workdir)
[13:20:29.268]         {
[13:20:29.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.268]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.268]             }
[13:20:29.268]             base::options(...future.oldOptions)
[13:20:29.268]             if (.Platform$OS.type == "windows") {
[13:20:29.268]                 old_names <- names(...future.oldEnvVars)
[13:20:29.268]                 envs <- base::Sys.getenv()
[13:20:29.268]                 names <- names(envs)
[13:20:29.268]                 common <- intersect(names, old_names)
[13:20:29.268]                 added <- setdiff(names, old_names)
[13:20:29.268]                 removed <- setdiff(old_names, names)
[13:20:29.268]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.268]                   envs[common]]
[13:20:29.268]                 NAMES <- toupper(changed)
[13:20:29.268]                 args <- list()
[13:20:29.268]                 for (kk in seq_along(NAMES)) {
[13:20:29.268]                   name <- changed[[kk]]
[13:20:29.268]                   NAME <- NAMES[[kk]]
[13:20:29.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.268]                     next
[13:20:29.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.268]                 }
[13:20:29.268]                 NAMES <- toupper(added)
[13:20:29.268]                 for (kk in seq_along(NAMES)) {
[13:20:29.268]                   name <- added[[kk]]
[13:20:29.268]                   NAME <- NAMES[[kk]]
[13:20:29.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.268]                     next
[13:20:29.268]                   args[[name]] <- ""
[13:20:29.268]                 }
[13:20:29.268]                 NAMES <- toupper(removed)
[13:20:29.268]                 for (kk in seq_along(NAMES)) {
[13:20:29.268]                   name <- removed[[kk]]
[13:20:29.268]                   NAME <- NAMES[[kk]]
[13:20:29.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.268]                     next
[13:20:29.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.268]                 }
[13:20:29.268]                 if (length(args) > 0) 
[13:20:29.268]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.268]             }
[13:20:29.268]             else {
[13:20:29.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.268]             }
[13:20:29.268]             {
[13:20:29.268]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.268]                   0L) {
[13:20:29.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.268]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.268]                   base::options(opts)
[13:20:29.268]                 }
[13:20:29.268]                 {
[13:20:29.268]                   {
[13:20:29.268]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.268]                     NULL
[13:20:29.268]                   }
[13:20:29.268]                   options(future.plan = NULL)
[13:20:29.268]                   if (is.na(NA_character_)) 
[13:20:29.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.268]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.268]                     envir = parent.frame()) 
[13:20:29.268]                   {
[13:20:29.268]                     default_workers <- missing(workers)
[13:20:29.268]                     if (is.function(workers)) 
[13:20:29.268]                       workers <- workers()
[13:20:29.268]                     workers <- structure(as.integer(workers), 
[13:20:29.268]                       class = class(workers))
[13:20:29.268]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.268]                       1L)
[13:20:29.268]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.268]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.268]                       if (default_workers) 
[13:20:29.268]                         supportsMulticore(warn = TRUE)
[13:20:29.268]                       return(sequential(..., envir = envir))
[13:20:29.268]                     }
[13:20:29.268]                     oopts <- options(mc.cores = workers)
[13:20:29.268]                     on.exit(options(oopts))
[13:20:29.268]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.268]                       envir = envir)
[13:20:29.268]                     if (!future$lazy) 
[13:20:29.268]                       future <- run(future)
[13:20:29.268]                     invisible(future)
[13:20:29.268]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.268]                 }
[13:20:29.268]             }
[13:20:29.268]         }
[13:20:29.268]     })
[13:20:29.268]     if (TRUE) {
[13:20:29.268]         base::sink(type = "output", split = FALSE)
[13:20:29.268]         if (TRUE) {
[13:20:29.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.268]         }
[13:20:29.268]         else {
[13:20:29.268]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.268]         }
[13:20:29.268]         base::close(...future.stdout)
[13:20:29.268]         ...future.stdout <- NULL
[13:20:29.268]     }
[13:20:29.268]     ...future.result$conditions <- ...future.conditions
[13:20:29.268]     ...future.result$finished <- base::Sys.time()
[13:20:29.268]     ...future.result
[13:20:29.268] }
[13:20:29.271] requestCore(): workers = 2
[13:20:29.274] MulticoreFuture started
[13:20:29.275] - Launch lazy future ... done
[13:20:29.275] run() for ‘MulticoreFuture’ ... done
[13:20:29.275] plan(): Setting new future strategy stack:
[13:20:29.276] getGlobalsAndPackages() ...
[13:20:29.276] Searching for globals...
[13:20:29.276] List of future strategies:
[13:20:29.276] 1. sequential:
[13:20:29.276]    - args: function (..., envir = parent.frame())
[13:20:29.276]    - tweaked: FALSE
[13:20:29.276]    - call: NULL
[13:20:29.277] plan(): nbrOfWorkers() = 1
[13:20:29.277] - globals found: [1] ‘{’
[13:20:29.278] Searching for globals ... DONE
[13:20:29.278] Resolving globals: FALSE
[13:20:29.278] 
[13:20:29.279] 
[13:20:29.279] getGlobalsAndPackages() ... DONE
[13:20:29.279] plan(): Setting new future strategy stack:
[13:20:29.279] run() for ‘Future’ ...
[13:20:29.280] - state: ‘created’
[13:20:29.279] List of future strategies:
[13:20:29.279] 1. multicore:
[13:20:29.279]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.279]    - tweaked: FALSE
[13:20:29.279]    - call: plan(strategy)
[13:20:29.280] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.285] plan(): nbrOfWorkers() = 2
[13:20:29.286] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.286] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.286]   - Field: ‘label’
[13:20:29.286]   - Field: ‘local’
[13:20:29.286]   - Field: ‘owner’
[13:20:29.286]   - Field: ‘envir’
[13:20:29.287]   - Field: ‘workers’
[13:20:29.287]   - Field: ‘packages’
[13:20:29.287]   - Field: ‘gc’
[13:20:29.287]   - Field: ‘job’
[13:20:29.287]   - Field: ‘conditions’
[13:20:29.287]   - Field: ‘expr’
[13:20:29.287]   - Field: ‘uuid’
[13:20:29.288]   - Field: ‘seed’
[13:20:29.288]   - Field: ‘version’
[13:20:29.288]   - Field: ‘result’
[13:20:29.288]   - Field: ‘asynchronous’
[13:20:29.288]   - Field: ‘calls’
[13:20:29.288]   - Field: ‘globals’
[13:20:29.288]   - Field: ‘stdout’
[13:20:29.289]   - Field: ‘earlySignal’
[13:20:29.289]   - Field: ‘lazy’
[13:20:29.289]   - Field: ‘state’
[13:20:29.289] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.289] - Launch lazy future ...
[13:20:29.290] Packages needed by the future expression (n = 0): <none>
[13:20:29.290] Packages needed by future strategies (n = 0): <none>
[13:20:29.291] {
[13:20:29.291]     {
[13:20:29.291]         {
[13:20:29.291]             ...future.startTime <- base::Sys.time()
[13:20:29.291]             {
[13:20:29.291]                 {
[13:20:29.291]                   {
[13:20:29.291]                     {
[13:20:29.291]                       base::local({
[13:20:29.291]                         has_future <- base::requireNamespace("future", 
[13:20:29.291]                           quietly = TRUE)
[13:20:29.291]                         if (has_future) {
[13:20:29.291]                           ns <- base::getNamespace("future")
[13:20:29.291]                           version <- ns[[".package"]][["version"]]
[13:20:29.291]                           if (is.null(version)) 
[13:20:29.291]                             version <- utils::packageVersion("future")
[13:20:29.291]                         }
[13:20:29.291]                         else {
[13:20:29.291]                           version <- NULL
[13:20:29.291]                         }
[13:20:29.291]                         if (!has_future || version < "1.8.0") {
[13:20:29.291]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.291]                             "", base::R.version$version.string), 
[13:20:29.291]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.291]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.291]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.291]                               "release", "version")], collapse = " "), 
[13:20:29.291]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.291]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.291]                             info)
[13:20:29.291]                           info <- base::paste(info, collapse = "; ")
[13:20:29.291]                           if (!has_future) {
[13:20:29.291]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.291]                               info)
[13:20:29.291]                           }
[13:20:29.291]                           else {
[13:20:29.291]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.291]                               info, version)
[13:20:29.291]                           }
[13:20:29.291]                           base::stop(msg)
[13:20:29.291]                         }
[13:20:29.291]                       })
[13:20:29.291]                     }
[13:20:29.291]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.291]                     base::options(mc.cores = 1L)
[13:20:29.291]                   }
[13:20:29.291]                   options(future.plan = NULL)
[13:20:29.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.291]                 }
[13:20:29.291]                 ...future.workdir <- getwd()
[13:20:29.291]             }
[13:20:29.291]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.291]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.291]         }
[13:20:29.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.291]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.291]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.291]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.291]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.291]             base::names(...future.oldOptions))
[13:20:29.291]     }
[13:20:29.291]     if (FALSE) {
[13:20:29.291]     }
[13:20:29.291]     else {
[13:20:29.291]         if (TRUE) {
[13:20:29.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.291]                 open = "w")
[13:20:29.291]         }
[13:20:29.291]         else {
[13:20:29.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.291]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.291]         }
[13:20:29.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.291]             base::sink(type = "output", split = FALSE)
[13:20:29.291]             base::close(...future.stdout)
[13:20:29.291]         }, add = TRUE)
[13:20:29.291]     }
[13:20:29.291]     ...future.frame <- base::sys.nframe()
[13:20:29.291]     ...future.conditions <- base::list()
[13:20:29.291]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.291]     if (FALSE) {
[13:20:29.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.291]     }
[13:20:29.291]     ...future.result <- base::tryCatch({
[13:20:29.291]         base::withCallingHandlers({
[13:20:29.291]             ...future.value <- base::withVisible(base::local({
[13:20:29.291]                 withCallingHandlers({
[13:20:29.291]                   {
[13:20:29.291]                     4
[13:20:29.291]                   }
[13:20:29.291]                 }, immediateCondition = function(cond) {
[13:20:29.291]                   save_rds <- function (object, pathname, ...) 
[13:20:29.291]                   {
[13:20:29.291]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.291]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.291]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.291]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.291]                         fi_tmp[["mtime"]])
[13:20:29.291]                     }
[13:20:29.291]                     tryCatch({
[13:20:29.291]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.291]                     }, error = function(ex) {
[13:20:29.291]                       msg <- conditionMessage(ex)
[13:20:29.291]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.291]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.291]                         fi_tmp[["mtime"]], msg)
[13:20:29.291]                       ex$message <- msg
[13:20:29.291]                       stop(ex)
[13:20:29.291]                     })
[13:20:29.291]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.291]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.291]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.291]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.291]                       fi <- file.info(pathname)
[13:20:29.291]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.291]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.291]                         fi[["size"]], fi[["mtime"]])
[13:20:29.291]                       stop(msg)
[13:20:29.291]                     }
[13:20:29.291]                     invisible(pathname)
[13:20:29.291]                   }
[13:20:29.291]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.291]                     rootPath = tempdir()) 
[13:20:29.291]                   {
[13:20:29.291]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.291]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.291]                       tmpdir = path, fileext = ".rds")
[13:20:29.291]                     save_rds(obj, file)
[13:20:29.291]                   }
[13:20:29.291]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.291]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.291]                   {
[13:20:29.291]                     inherits <- base::inherits
[13:20:29.291]                     invokeRestart <- base::invokeRestart
[13:20:29.291]                     is.null <- base::is.null
[13:20:29.291]                     muffled <- FALSE
[13:20:29.291]                     if (inherits(cond, "message")) {
[13:20:29.291]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.291]                       if (muffled) 
[13:20:29.291]                         invokeRestart("muffleMessage")
[13:20:29.291]                     }
[13:20:29.291]                     else if (inherits(cond, "warning")) {
[13:20:29.291]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.291]                       if (muffled) 
[13:20:29.291]                         invokeRestart("muffleWarning")
[13:20:29.291]                     }
[13:20:29.291]                     else if (inherits(cond, "condition")) {
[13:20:29.291]                       if (!is.null(pattern)) {
[13:20:29.291]                         computeRestarts <- base::computeRestarts
[13:20:29.291]                         grepl <- base::grepl
[13:20:29.291]                         restarts <- computeRestarts(cond)
[13:20:29.291]                         for (restart in restarts) {
[13:20:29.291]                           name <- restart$name
[13:20:29.291]                           if (is.null(name)) 
[13:20:29.291]                             next
[13:20:29.291]                           if (!grepl(pattern, name)) 
[13:20:29.291]                             next
[13:20:29.291]                           invokeRestart(restart)
[13:20:29.291]                           muffled <- TRUE
[13:20:29.291]                           break
[13:20:29.291]                         }
[13:20:29.291]                       }
[13:20:29.291]                     }
[13:20:29.291]                     invisible(muffled)
[13:20:29.291]                   }
[13:20:29.291]                   muffleCondition(cond)
[13:20:29.291]                 })
[13:20:29.291]             }))
[13:20:29.291]             future::FutureResult(value = ...future.value$value, 
[13:20:29.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.291]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.291]                     ...future.globalenv.names))
[13:20:29.291]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.291]         }, condition = base::local({
[13:20:29.291]             c <- base::c
[13:20:29.291]             inherits <- base::inherits
[13:20:29.291]             invokeRestart <- base::invokeRestart
[13:20:29.291]             length <- base::length
[13:20:29.291]             list <- base::list
[13:20:29.291]             seq.int <- base::seq.int
[13:20:29.291]             signalCondition <- base::signalCondition
[13:20:29.291]             sys.calls <- base::sys.calls
[13:20:29.291]             `[[` <- base::`[[`
[13:20:29.291]             `+` <- base::`+`
[13:20:29.291]             `<<-` <- base::`<<-`
[13:20:29.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.291]                   3L)]
[13:20:29.291]             }
[13:20:29.291]             function(cond) {
[13:20:29.291]                 is_error <- inherits(cond, "error")
[13:20:29.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.291]                   NULL)
[13:20:29.291]                 if (is_error) {
[13:20:29.291]                   sessionInformation <- function() {
[13:20:29.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.291]                       search = base::search(), system = base::Sys.info())
[13:20:29.291]                   }
[13:20:29.291]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.291]                     cond$call), session = sessionInformation(), 
[13:20:29.291]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.291]                   signalCondition(cond)
[13:20:29.291]                 }
[13:20:29.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.291]                 "immediateCondition"))) {
[13:20:29.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.291]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.291]                   if (TRUE && !signal) {
[13:20:29.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.291]                     {
[13:20:29.291]                       inherits <- base::inherits
[13:20:29.291]                       invokeRestart <- base::invokeRestart
[13:20:29.291]                       is.null <- base::is.null
[13:20:29.291]                       muffled <- FALSE
[13:20:29.291]                       if (inherits(cond, "message")) {
[13:20:29.291]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.291]                         if (muffled) 
[13:20:29.291]                           invokeRestart("muffleMessage")
[13:20:29.291]                       }
[13:20:29.291]                       else if (inherits(cond, "warning")) {
[13:20:29.291]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.291]                         if (muffled) 
[13:20:29.291]                           invokeRestart("muffleWarning")
[13:20:29.291]                       }
[13:20:29.291]                       else if (inherits(cond, "condition")) {
[13:20:29.291]                         if (!is.null(pattern)) {
[13:20:29.291]                           computeRestarts <- base::computeRestarts
[13:20:29.291]                           grepl <- base::grepl
[13:20:29.291]                           restarts <- computeRestarts(cond)
[13:20:29.291]                           for (restart in restarts) {
[13:20:29.291]                             name <- restart$name
[13:20:29.291]                             if (is.null(name)) 
[13:20:29.291]                               next
[13:20:29.291]                             if (!grepl(pattern, name)) 
[13:20:29.291]                               next
[13:20:29.291]                             invokeRestart(restart)
[13:20:29.291]                             muffled <- TRUE
[13:20:29.291]                             break
[13:20:29.291]                           }
[13:20:29.291]                         }
[13:20:29.291]                       }
[13:20:29.291]                       invisible(muffled)
[13:20:29.291]                     }
[13:20:29.291]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.291]                   }
[13:20:29.291]                 }
[13:20:29.291]                 else {
[13:20:29.291]                   if (TRUE) {
[13:20:29.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.291]                     {
[13:20:29.291]                       inherits <- base::inherits
[13:20:29.291]                       invokeRestart <- base::invokeRestart
[13:20:29.291]                       is.null <- base::is.null
[13:20:29.291]                       muffled <- FALSE
[13:20:29.291]                       if (inherits(cond, "message")) {
[13:20:29.291]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.291]                         if (muffled) 
[13:20:29.291]                           invokeRestart("muffleMessage")
[13:20:29.291]                       }
[13:20:29.291]                       else if (inherits(cond, "warning")) {
[13:20:29.291]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.291]                         if (muffled) 
[13:20:29.291]                           invokeRestart("muffleWarning")
[13:20:29.291]                       }
[13:20:29.291]                       else if (inherits(cond, "condition")) {
[13:20:29.291]                         if (!is.null(pattern)) {
[13:20:29.291]                           computeRestarts <- base::computeRestarts
[13:20:29.291]                           grepl <- base::grepl
[13:20:29.291]                           restarts <- computeRestarts(cond)
[13:20:29.291]                           for (restart in restarts) {
[13:20:29.291]                             name <- restart$name
[13:20:29.291]                             if (is.null(name)) 
[13:20:29.291]                               next
[13:20:29.291]                             if (!grepl(pattern, name)) 
[13:20:29.291]                               next
[13:20:29.291]                             invokeRestart(restart)
[13:20:29.291]                             muffled <- TRUE
[13:20:29.291]                             break
[13:20:29.291]                           }
[13:20:29.291]                         }
[13:20:29.291]                       }
[13:20:29.291]                       invisible(muffled)
[13:20:29.291]                     }
[13:20:29.291]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.291]                   }
[13:20:29.291]                 }
[13:20:29.291]             }
[13:20:29.291]         }))
[13:20:29.291]     }, error = function(ex) {
[13:20:29.291]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.291]                 ...future.rng), started = ...future.startTime, 
[13:20:29.291]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.291]             version = "1.8"), class = "FutureResult")
[13:20:29.291]     }, finally = {
[13:20:29.291]         if (!identical(...future.workdir, getwd())) 
[13:20:29.291]             setwd(...future.workdir)
[13:20:29.291]         {
[13:20:29.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.291]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.291]             }
[13:20:29.291]             base::options(...future.oldOptions)
[13:20:29.291]             if (.Platform$OS.type == "windows") {
[13:20:29.291]                 old_names <- names(...future.oldEnvVars)
[13:20:29.291]                 envs <- base::Sys.getenv()
[13:20:29.291]                 names <- names(envs)
[13:20:29.291]                 common <- intersect(names, old_names)
[13:20:29.291]                 added <- setdiff(names, old_names)
[13:20:29.291]                 removed <- setdiff(old_names, names)
[13:20:29.291]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.291]                   envs[common]]
[13:20:29.291]                 NAMES <- toupper(changed)
[13:20:29.291]                 args <- list()
[13:20:29.291]                 for (kk in seq_along(NAMES)) {
[13:20:29.291]                   name <- changed[[kk]]
[13:20:29.291]                   NAME <- NAMES[[kk]]
[13:20:29.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.291]                     next
[13:20:29.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.291]                 }
[13:20:29.291]                 NAMES <- toupper(added)
[13:20:29.291]                 for (kk in seq_along(NAMES)) {
[13:20:29.291]                   name <- added[[kk]]
[13:20:29.291]                   NAME <- NAMES[[kk]]
[13:20:29.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.291]                     next
[13:20:29.291]                   args[[name]] <- ""
[13:20:29.291]                 }
[13:20:29.291]                 NAMES <- toupper(removed)
[13:20:29.291]                 for (kk in seq_along(NAMES)) {
[13:20:29.291]                   name <- removed[[kk]]
[13:20:29.291]                   NAME <- NAMES[[kk]]
[13:20:29.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.291]                     next
[13:20:29.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.291]                 }
[13:20:29.291]                 if (length(args) > 0) 
[13:20:29.291]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.291]             }
[13:20:29.291]             else {
[13:20:29.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.291]             }
[13:20:29.291]             {
[13:20:29.291]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.291]                   0L) {
[13:20:29.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.291]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.291]                   base::options(opts)
[13:20:29.291]                 }
[13:20:29.291]                 {
[13:20:29.291]                   {
[13:20:29.291]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.291]                     NULL
[13:20:29.291]                   }
[13:20:29.291]                   options(future.plan = NULL)
[13:20:29.291]                   if (is.na(NA_character_)) 
[13:20:29.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.291]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.291]                     envir = parent.frame()) 
[13:20:29.291]                   {
[13:20:29.291]                     default_workers <- missing(workers)
[13:20:29.291]                     if (is.function(workers)) 
[13:20:29.291]                       workers <- workers()
[13:20:29.291]                     workers <- structure(as.integer(workers), 
[13:20:29.291]                       class = class(workers))
[13:20:29.291]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.291]                       1L)
[13:20:29.291]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.291]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.291]                       if (default_workers) 
[13:20:29.291]                         supportsMulticore(warn = TRUE)
[13:20:29.291]                       return(sequential(..., envir = envir))
[13:20:29.291]                     }
[13:20:29.291]                     oopts <- options(mc.cores = workers)
[13:20:29.291]                     on.exit(options(oopts))
[13:20:29.291]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.291]                       envir = envir)
[13:20:29.291]                     if (!future$lazy) 
[13:20:29.291]                       future <- run(future)
[13:20:29.291]                     invisible(future)
[13:20:29.291]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.291]                 }
[13:20:29.291]             }
[13:20:29.291]         }
[13:20:29.291]     })
[13:20:29.291]     if (TRUE) {
[13:20:29.291]         base::sink(type = "output", split = FALSE)
[13:20:29.291]         if (TRUE) {
[13:20:29.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.291]         }
[13:20:29.291]         else {
[13:20:29.291]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.291]         }
[13:20:29.291]         base::close(...future.stdout)
[13:20:29.291]         ...future.stdout <- NULL
[13:20:29.291]     }
[13:20:29.291]     ...future.result$conditions <- ...future.conditions
[13:20:29.291]     ...future.result$finished <- base::Sys.time()
[13:20:29.291]     ...future.result
[13:20:29.291] }
[13:20:29.294] requestCore(): workers = 2
[13:20:29.295] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:29.309] MulticoreFuture started
[13:20:29.309] - Launch lazy future ... done
[13:20:29.310] run() for ‘MulticoreFuture’ ... done
[13:20:29.310] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55659cf3ea20> 
[13:20:29.311] List of future strategies:
[13:20:29.311] 1. sequential:
[13:20:29.311]    - args: function (..., envir = parent.frame())
[13:20:29.311]    - tweaked: FALSE
[13:20:29.311]    - call: NULL
[13:20:29.312] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55659dab5d88> 
 - attr(*, "dim.")=[13:20:29.315] plan(): Setting new future strategy stack:
 int [1:2] 2 3
 - attr(*, "dimnames.")=List[13:20:29.315] List of future strategies:
[13:20:29.315] 1. multicore:
[13:20:29.315]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.315]    - tweaked: FALSE
[13:20:29.315]    - call: plan(strategy)
 of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:20:29.321] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:29.334] resolve() on list environment ...
[13:20:29.334]  recursive: 0
[13:20:29.336]  length: 6
[13:20:29.336]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:29.336] signalConditionsASAP(numeric, pos=1) ...
[13:20:29.336] - nx: 6
[13:20:29.337] - relay: TRUE
[13:20:29.337] - stdout: TRUE
[13:20:29.337] - signal: TRUE
[13:20:29.337] - resignal: FALSE
[13:20:29.337] - force: TRUE
[13:20:29.337] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.337] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.337]  - until=2
[13:20:29.338]  - relaying element #2
[13:20:29.338] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.338] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.338] signalConditionsASAP(NULL, pos=1) ... done
[13:20:29.338]  length: 5 (resolved future 1)
[13:20:29.338] Future #2
[13:20:29.338] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:29.339] - nx: 6
[13:20:29.339] - relay: TRUE
[13:20:29.339] - stdout: TRUE
[13:20:29.339] - signal: TRUE
[13:20:29.339] - resignal: FALSE
[13:20:29.339] - force: TRUE
[13:20:29.339] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.339] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.340]  - until=2
[13:20:29.340]  - relaying element #2
[13:20:29.340] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.340] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.340] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:29.340]  length: 4 (resolved future 2)
[13:20:29.341] Future #3
[13:20:29.342] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:29.342] - nx: 6
[13:20:29.342] - relay: TRUE
[13:20:29.342] - stdout: TRUE
[13:20:29.342] - signal: TRUE
[13:20:29.342] - resignal: FALSE
[13:20:29.342] - force: TRUE
[13:20:29.343] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.343] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.343]  - until=3
[13:20:29.343]  - relaying element #3
[13:20:29.343] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.343] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.344] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:29.344]  length: 3 (resolved future 3)
[13:20:29.344] Future #4
[13:20:29.345] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:20:29.345] - nx: 6
[13:20:29.345] - relay: TRUE
[13:20:29.345] - stdout: TRUE
[13:20:29.346] - signal: TRUE
[13:20:29.346] - resignal: FALSE
[13:20:29.346] - force: TRUE
[13:20:29.346] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.346] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.346]  - until=4
[13:20:29.346]  - relaying element #4
[13:20:29.347] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.347] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.347] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:20:29.347]  length: 2 (resolved future 4)
[13:20:29.347] signalConditionsASAP(NULL, pos=5) ...
[13:20:29.348] - nx: 6
[13:20:29.348] - relay: TRUE
[13:20:29.348] - stdout: TRUE
[13:20:29.348] - signal: TRUE
[13:20:29.348] - resignal: FALSE
[13:20:29.348] - force: TRUE
[13:20:29.348] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.349] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.349]  - until=6
[13:20:29.349]  - relaying element #6
[13:20:29.349] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:29.349] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.349] signalConditionsASAP(NULL, pos=5) ... done
[13:20:29.350]  length: 1 (resolved future 5)
[13:20:29.350] signalConditionsASAP(numeric, pos=6) ...
[13:20:29.350] - nx: 6
[13:20:29.350] - relay: TRUE
[13:20:29.350] - stdout: TRUE
[13:20:29.350] - signal: TRUE
[13:20:29.350] - resignal: FALSE
[13:20:29.350] - force: TRUE
[13:20:29.350] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:29.351] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.351]  - until=6
[13:20:29.351] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.351] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.351] signalConditionsASAP(numeric, pos=6) ... done
[13:20:29.351]  length: 0 (resolved future 6)
[13:20:29.351] Relaying remaining futures
[13:20:29.351] signalConditionsASAP(NULL, pos=0) ...
[13:20:29.351] - nx: 6
[13:20:29.352] - relay: TRUE
[13:20:29.352] - stdout: TRUE
[13:20:29.352] - signal: TRUE
[13:20:29.352] - resignal: FALSE
[13:20:29.352] - force: TRUE
[13:20:29.352] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.352] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:29.352] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.352] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.352] signalConditionsASAP(NULL, pos=0) ... done
[13:20:29.353] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55659c30db58> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:20:29.355] getGlobalsAndPackages() ...
[13:20:29.355] Searching for globals...
[13:20:29.355] 
[13:20:29.356] Searching for globals ... DONE
[13:20:29.356] - globals: [0] <none>
[13:20:29.356] getGlobalsAndPackages() ... DONE
[13:20:29.356] run() for ‘Future’ ...
[13:20:29.356] - state: ‘created’
[13:20:29.356] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.361] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.361] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.361]   - Field: ‘label’
[13:20:29.361]   - Field: ‘local’
[13:20:29.361]   - Field: ‘owner’
[13:20:29.362]   - Field: ‘envir’
[13:20:29.362]   - Field: ‘workers’
[13:20:29.362]   - Field: ‘packages’
[13:20:29.362]   - Field: ‘gc’
[13:20:29.362]   - Field: ‘job’
[13:20:29.362]   - Field: ‘conditions’
[13:20:29.362]   - Field: ‘expr’
[13:20:29.363]   - Field: ‘uuid’
[13:20:29.363]   - Field: ‘seed’
[13:20:29.363]   - Field: ‘version’
[13:20:29.363]   - Field: ‘result’
[13:20:29.363]   - Field: ‘asynchronous’
[13:20:29.363]   - Field: ‘calls’
[13:20:29.363]   - Field: ‘globals’
[13:20:29.363]   - Field: ‘stdout’
[13:20:29.364]   - Field: ‘earlySignal’
[13:20:29.364]   - Field: ‘lazy’
[13:20:29.364]   - Field: ‘state’
[13:20:29.364] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.364] - Launch lazy future ...
[13:20:29.364] Packages needed by the future expression (n = 0): <none>
[13:20:29.365] Packages needed by future strategies (n = 0): <none>
[13:20:29.365] {
[13:20:29.365]     {
[13:20:29.365]         {
[13:20:29.365]             ...future.startTime <- base::Sys.time()
[13:20:29.365]             {
[13:20:29.365]                 {
[13:20:29.365]                   {
[13:20:29.365]                     {
[13:20:29.365]                       base::local({
[13:20:29.365]                         has_future <- base::requireNamespace("future", 
[13:20:29.365]                           quietly = TRUE)
[13:20:29.365]                         if (has_future) {
[13:20:29.365]                           ns <- base::getNamespace("future")
[13:20:29.365]                           version <- ns[[".package"]][["version"]]
[13:20:29.365]                           if (is.null(version)) 
[13:20:29.365]                             version <- utils::packageVersion("future")
[13:20:29.365]                         }
[13:20:29.365]                         else {
[13:20:29.365]                           version <- NULL
[13:20:29.365]                         }
[13:20:29.365]                         if (!has_future || version < "1.8.0") {
[13:20:29.365]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.365]                             "", base::R.version$version.string), 
[13:20:29.365]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.365]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.365]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.365]                               "release", "version")], collapse = " "), 
[13:20:29.365]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.365]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.365]                             info)
[13:20:29.365]                           info <- base::paste(info, collapse = "; ")
[13:20:29.365]                           if (!has_future) {
[13:20:29.365]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.365]                               info)
[13:20:29.365]                           }
[13:20:29.365]                           else {
[13:20:29.365]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.365]                               info, version)
[13:20:29.365]                           }
[13:20:29.365]                           base::stop(msg)
[13:20:29.365]                         }
[13:20:29.365]                       })
[13:20:29.365]                     }
[13:20:29.365]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.365]                     base::options(mc.cores = 1L)
[13:20:29.365]                   }
[13:20:29.365]                   options(future.plan = NULL)
[13:20:29.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.365]                 }
[13:20:29.365]                 ...future.workdir <- getwd()
[13:20:29.365]             }
[13:20:29.365]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.365]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.365]         }
[13:20:29.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.365]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.365]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.365]             base::names(...future.oldOptions))
[13:20:29.365]     }
[13:20:29.365]     if (FALSE) {
[13:20:29.365]     }
[13:20:29.365]     else {
[13:20:29.365]         if (TRUE) {
[13:20:29.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.365]                 open = "w")
[13:20:29.365]         }
[13:20:29.365]         else {
[13:20:29.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.365]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.365]         }
[13:20:29.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.365]             base::sink(type = "output", split = FALSE)
[13:20:29.365]             base::close(...future.stdout)
[13:20:29.365]         }, add = TRUE)
[13:20:29.365]     }
[13:20:29.365]     ...future.frame <- base::sys.nframe()
[13:20:29.365]     ...future.conditions <- base::list()
[13:20:29.365]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.365]     if (FALSE) {
[13:20:29.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.365]     }
[13:20:29.365]     ...future.result <- base::tryCatch({
[13:20:29.365]         base::withCallingHandlers({
[13:20:29.365]             ...future.value <- base::withVisible(base::local({
[13:20:29.365]                 withCallingHandlers({
[13:20:29.365]                   2
[13:20:29.365]                 }, immediateCondition = function(cond) {
[13:20:29.365]                   save_rds <- function (object, pathname, ...) 
[13:20:29.365]                   {
[13:20:29.365]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.365]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.365]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.365]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.365]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.365]                         fi_tmp[["mtime"]])
[13:20:29.365]                     }
[13:20:29.365]                     tryCatch({
[13:20:29.365]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.365]                     }, error = function(ex) {
[13:20:29.365]                       msg <- conditionMessage(ex)
[13:20:29.365]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.365]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.365]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.365]                         fi_tmp[["mtime"]], msg)
[13:20:29.365]                       ex$message <- msg
[13:20:29.365]                       stop(ex)
[13:20:29.365]                     })
[13:20:29.365]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.365]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.365]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.365]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.365]                       fi <- file.info(pathname)
[13:20:29.365]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.365]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.365]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.365]                         fi[["size"]], fi[["mtime"]])
[13:20:29.365]                       stop(msg)
[13:20:29.365]                     }
[13:20:29.365]                     invisible(pathname)
[13:20:29.365]                   }
[13:20:29.365]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.365]                     rootPath = tempdir()) 
[13:20:29.365]                   {
[13:20:29.365]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.365]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.365]                       tmpdir = path, fileext = ".rds")
[13:20:29.365]                     save_rds(obj, file)
[13:20:29.365]                   }
[13:20:29.365]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.365]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.365]                   {
[13:20:29.365]                     inherits <- base::inherits
[13:20:29.365]                     invokeRestart <- base::invokeRestart
[13:20:29.365]                     is.null <- base::is.null
[13:20:29.365]                     muffled <- FALSE
[13:20:29.365]                     if (inherits(cond, "message")) {
[13:20:29.365]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.365]                       if (muffled) 
[13:20:29.365]                         invokeRestart("muffleMessage")
[13:20:29.365]                     }
[13:20:29.365]                     else if (inherits(cond, "warning")) {
[13:20:29.365]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.365]                       if (muffled) 
[13:20:29.365]                         invokeRestart("muffleWarning")
[13:20:29.365]                     }
[13:20:29.365]                     else if (inherits(cond, "condition")) {
[13:20:29.365]                       if (!is.null(pattern)) {
[13:20:29.365]                         computeRestarts <- base::computeRestarts
[13:20:29.365]                         grepl <- base::grepl
[13:20:29.365]                         restarts <- computeRestarts(cond)
[13:20:29.365]                         for (restart in restarts) {
[13:20:29.365]                           name <- restart$name
[13:20:29.365]                           if (is.null(name)) 
[13:20:29.365]                             next
[13:20:29.365]                           if (!grepl(pattern, name)) 
[13:20:29.365]                             next
[13:20:29.365]                           invokeRestart(restart)
[13:20:29.365]                           muffled <- TRUE
[13:20:29.365]                           break
[13:20:29.365]                         }
[13:20:29.365]                       }
[13:20:29.365]                     }
[13:20:29.365]                     invisible(muffled)
[13:20:29.365]                   }
[13:20:29.365]                   muffleCondition(cond)
[13:20:29.365]                 })
[13:20:29.365]             }))
[13:20:29.365]             future::FutureResult(value = ...future.value$value, 
[13:20:29.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.365]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.365]                     ...future.globalenv.names))
[13:20:29.365]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.365]         }, condition = base::local({
[13:20:29.365]             c <- base::c
[13:20:29.365]             inherits <- base::inherits
[13:20:29.365]             invokeRestart <- base::invokeRestart
[13:20:29.365]             length <- base::length
[13:20:29.365]             list <- base::list
[13:20:29.365]             seq.int <- base::seq.int
[13:20:29.365]             signalCondition <- base::signalCondition
[13:20:29.365]             sys.calls <- base::sys.calls
[13:20:29.365]             `[[` <- base::`[[`
[13:20:29.365]             `+` <- base::`+`
[13:20:29.365]             `<<-` <- base::`<<-`
[13:20:29.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.365]                   3L)]
[13:20:29.365]             }
[13:20:29.365]             function(cond) {
[13:20:29.365]                 is_error <- inherits(cond, "error")
[13:20:29.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.365]                   NULL)
[13:20:29.365]                 if (is_error) {
[13:20:29.365]                   sessionInformation <- function() {
[13:20:29.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.365]                       search = base::search(), system = base::Sys.info())
[13:20:29.365]                   }
[13:20:29.365]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.365]                     cond$call), session = sessionInformation(), 
[13:20:29.365]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.365]                   signalCondition(cond)
[13:20:29.365]                 }
[13:20:29.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.365]                 "immediateCondition"))) {
[13:20:29.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.365]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.365]                   if (TRUE && !signal) {
[13:20:29.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.365]                     {
[13:20:29.365]                       inherits <- base::inherits
[13:20:29.365]                       invokeRestart <- base::invokeRestart
[13:20:29.365]                       is.null <- base::is.null
[13:20:29.365]                       muffled <- FALSE
[13:20:29.365]                       if (inherits(cond, "message")) {
[13:20:29.365]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.365]                         if (muffled) 
[13:20:29.365]                           invokeRestart("muffleMessage")
[13:20:29.365]                       }
[13:20:29.365]                       else if (inherits(cond, "warning")) {
[13:20:29.365]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.365]                         if (muffled) 
[13:20:29.365]                           invokeRestart("muffleWarning")
[13:20:29.365]                       }
[13:20:29.365]                       else if (inherits(cond, "condition")) {
[13:20:29.365]                         if (!is.null(pattern)) {
[13:20:29.365]                           computeRestarts <- base::computeRestarts
[13:20:29.365]                           grepl <- base::grepl
[13:20:29.365]                           restarts <- computeRestarts(cond)
[13:20:29.365]                           for (restart in restarts) {
[13:20:29.365]                             name <- restart$name
[13:20:29.365]                             if (is.null(name)) 
[13:20:29.365]                               next
[13:20:29.365]                             if (!grepl(pattern, name)) 
[13:20:29.365]                               next
[13:20:29.365]                             invokeRestart(restart)
[13:20:29.365]                             muffled <- TRUE
[13:20:29.365]                             break
[13:20:29.365]                           }
[13:20:29.365]                         }
[13:20:29.365]                       }
[13:20:29.365]                       invisible(muffled)
[13:20:29.365]                     }
[13:20:29.365]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.365]                   }
[13:20:29.365]                 }
[13:20:29.365]                 else {
[13:20:29.365]                   if (TRUE) {
[13:20:29.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.365]                     {
[13:20:29.365]                       inherits <- base::inherits
[13:20:29.365]                       invokeRestart <- base::invokeRestart
[13:20:29.365]                       is.null <- base::is.null
[13:20:29.365]                       muffled <- FALSE
[13:20:29.365]                       if (inherits(cond, "message")) {
[13:20:29.365]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.365]                         if (muffled) 
[13:20:29.365]                           invokeRestart("muffleMessage")
[13:20:29.365]                       }
[13:20:29.365]                       else if (inherits(cond, "warning")) {
[13:20:29.365]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.365]                         if (muffled) 
[13:20:29.365]                           invokeRestart("muffleWarning")
[13:20:29.365]                       }
[13:20:29.365]                       else if (inherits(cond, "condition")) {
[13:20:29.365]                         if (!is.null(pattern)) {
[13:20:29.365]                           computeRestarts <- base::computeRestarts
[13:20:29.365]                           grepl <- base::grepl
[13:20:29.365]                           restarts <- computeRestarts(cond)
[13:20:29.365]                           for (restart in restarts) {
[13:20:29.365]                             name <- restart$name
[13:20:29.365]                             if (is.null(name)) 
[13:20:29.365]                               next
[13:20:29.365]                             if (!grepl(pattern, name)) 
[13:20:29.365]                               next
[13:20:29.365]                             invokeRestart(restart)
[13:20:29.365]                             muffled <- TRUE
[13:20:29.365]                             break
[13:20:29.365]                           }
[13:20:29.365]                         }
[13:20:29.365]                       }
[13:20:29.365]                       invisible(muffled)
[13:20:29.365]                     }
[13:20:29.365]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.365]                   }
[13:20:29.365]                 }
[13:20:29.365]             }
[13:20:29.365]         }))
[13:20:29.365]     }, error = function(ex) {
[13:20:29.365]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.365]                 ...future.rng), started = ...future.startTime, 
[13:20:29.365]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.365]             version = "1.8"), class = "FutureResult")
[13:20:29.365]     }, finally = {
[13:20:29.365]         if (!identical(...future.workdir, getwd())) 
[13:20:29.365]             setwd(...future.workdir)
[13:20:29.365]         {
[13:20:29.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.365]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.365]             }
[13:20:29.365]             base::options(...future.oldOptions)
[13:20:29.365]             if (.Platform$OS.type == "windows") {
[13:20:29.365]                 old_names <- names(...future.oldEnvVars)
[13:20:29.365]                 envs <- base::Sys.getenv()
[13:20:29.365]                 names <- names(envs)
[13:20:29.365]                 common <- intersect(names, old_names)
[13:20:29.365]                 added <- setdiff(names, old_names)
[13:20:29.365]                 removed <- setdiff(old_names, names)
[13:20:29.365]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.365]                   envs[common]]
[13:20:29.365]                 NAMES <- toupper(changed)
[13:20:29.365]                 args <- list()
[13:20:29.365]                 for (kk in seq_along(NAMES)) {
[13:20:29.365]                   name <- changed[[kk]]
[13:20:29.365]                   NAME <- NAMES[[kk]]
[13:20:29.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.365]                     next
[13:20:29.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.365]                 }
[13:20:29.365]                 NAMES <- toupper(added)
[13:20:29.365]                 for (kk in seq_along(NAMES)) {
[13:20:29.365]                   name <- added[[kk]]
[13:20:29.365]                   NAME <- NAMES[[kk]]
[13:20:29.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.365]                     next
[13:20:29.365]                   args[[name]] <- ""
[13:20:29.365]                 }
[13:20:29.365]                 NAMES <- toupper(removed)
[13:20:29.365]                 for (kk in seq_along(NAMES)) {
[13:20:29.365]                   name <- removed[[kk]]
[13:20:29.365]                   NAME <- NAMES[[kk]]
[13:20:29.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.365]                     next
[13:20:29.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.365]                 }
[13:20:29.365]                 if (length(args) > 0) 
[13:20:29.365]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.365]             }
[13:20:29.365]             else {
[13:20:29.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.365]             }
[13:20:29.365]             {
[13:20:29.365]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.365]                   0L) {
[13:20:29.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.365]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.365]                   base::options(opts)
[13:20:29.365]                 }
[13:20:29.365]                 {
[13:20:29.365]                   {
[13:20:29.365]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.365]                     NULL
[13:20:29.365]                   }
[13:20:29.365]                   options(future.plan = NULL)
[13:20:29.365]                   if (is.na(NA_character_)) 
[13:20:29.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.365]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.365]                     envir = parent.frame()) 
[13:20:29.365]                   {
[13:20:29.365]                     default_workers <- missing(workers)
[13:20:29.365]                     if (is.function(workers)) 
[13:20:29.365]                       workers <- workers()
[13:20:29.365]                     workers <- structure(as.integer(workers), 
[13:20:29.365]                       class = class(workers))
[13:20:29.365]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.365]                       1L)
[13:20:29.365]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.365]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.365]                       if (default_workers) 
[13:20:29.365]                         supportsMulticore(warn = TRUE)
[13:20:29.365]                       return(sequential(..., envir = envir))
[13:20:29.365]                     }
[13:20:29.365]                     oopts <- options(mc.cores = workers)
[13:20:29.365]                     on.exit(options(oopts))
[13:20:29.365]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.365]                       envir = envir)
[13:20:29.365]                     if (!future$lazy) 
[13:20:29.365]                       future <- run(future)
[13:20:29.365]                     invisible(future)
[13:20:29.365]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.365]                 }
[13:20:29.365]             }
[13:20:29.365]         }
[13:20:29.365]     })
[13:20:29.365]     if (TRUE) {
[13:20:29.365]         base::sink(type = "output", split = FALSE)
[13:20:29.365]         if (TRUE) {
[13:20:29.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.365]         }
[13:20:29.365]         else {
[13:20:29.365]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.365]         }
[13:20:29.365]         base::close(...future.stdout)
[13:20:29.365]         ...future.stdout <- NULL
[13:20:29.365]     }
[13:20:29.365]     ...future.result$conditions <- ...future.conditions
[13:20:29.365]     ...future.result$finished <- base::Sys.time()
[13:20:29.365]     ...future.result
[13:20:29.365] }
[13:20:29.368] requestCore(): workers = 2
[13:20:29.370] MulticoreFuture started
[13:20:29.371] - Launch lazy future ... done
[13:20:29.371] run() for ‘MulticoreFuture’ ... done
[13:20:29.371] getGlobalsAndPackages() ...
[13:20:29.372] Searching for globals...
[13:20:29.371] plan(): Setting new future strategy stack:
[13:20:29.372] List of future strategies:
[13:20:29.372] 1. sequential:
[13:20:29.372]    - args: function (..., envir = parent.frame())
[13:20:29.372]    - tweaked: FALSE
[13:20:29.372]    - call: NULL
[13:20:29.372] 
[13:20:29.373] Searching for globals ... DONE
[13:20:29.373] plan(): nbrOfWorkers() = 1
[13:20:29.373] - globals: [0] <none>
[13:20:29.373] getGlobalsAndPackages() ... DONE
[13:20:29.373] run() for ‘Future’ ...
[13:20:29.374] - state: ‘created’
[13:20:29.374] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.375] plan(): Setting new future strategy stack:
[13:20:29.375] List of future strategies:
[13:20:29.375] 1. multicore:
[13:20:29.375]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.375]    - tweaked: FALSE
[13:20:29.375]    - call: plan(strategy)
[13:20:29.379] plan(): nbrOfWorkers() = 2
[13:20:29.380] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.380]   - Field: ‘label’
[13:20:29.380]   - Field: ‘local’
[13:20:29.381]   - Field: ‘owner’
[13:20:29.381]   - Field: ‘envir’
[13:20:29.381]   - Field: ‘workers’
[13:20:29.381]   - Field: ‘packages’
[13:20:29.381]   - Field: ‘gc’
[13:20:29.381]   - Field: ‘job’
[13:20:29.382]   - Field: ‘conditions’
[13:20:29.382]   - Field: ‘expr’
[13:20:29.382]   - Field: ‘uuid’
[13:20:29.382]   - Field: ‘seed’
[13:20:29.382]   - Field: ‘version’
[13:20:29.382]   - Field: ‘result’
[13:20:29.382]   - Field: ‘asynchronous’
[13:20:29.383]   - Field: ‘calls’
[13:20:29.383]   - Field: ‘globals’
[13:20:29.383]   - Field: ‘stdout’
[13:20:29.383]   - Field: ‘earlySignal’
[13:20:29.383]   - Field: ‘lazy’
[13:20:29.383]   - Field: ‘state’
[13:20:29.384] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.384] - Launch lazy future ...
[13:20:29.384] Packages needed by the future expression (n = 0): <none>
[13:20:29.384] Packages needed by future strategies (n = 0): <none>
[13:20:29.385] {
[13:20:29.385]     {
[13:20:29.385]         {
[13:20:29.385]             ...future.startTime <- base::Sys.time()
[13:20:29.385]             {
[13:20:29.385]                 {
[13:20:29.385]                   {
[13:20:29.385]                     {
[13:20:29.385]                       base::local({
[13:20:29.385]                         has_future <- base::requireNamespace("future", 
[13:20:29.385]                           quietly = TRUE)
[13:20:29.385]                         if (has_future) {
[13:20:29.385]                           ns <- base::getNamespace("future")
[13:20:29.385]                           version <- ns[[".package"]][["version"]]
[13:20:29.385]                           if (is.null(version)) 
[13:20:29.385]                             version <- utils::packageVersion("future")
[13:20:29.385]                         }
[13:20:29.385]                         else {
[13:20:29.385]                           version <- NULL
[13:20:29.385]                         }
[13:20:29.385]                         if (!has_future || version < "1.8.0") {
[13:20:29.385]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.385]                             "", base::R.version$version.string), 
[13:20:29.385]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.385]                               "release", "version")], collapse = " "), 
[13:20:29.385]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.385]                             info)
[13:20:29.385]                           info <- base::paste(info, collapse = "; ")
[13:20:29.385]                           if (!has_future) {
[13:20:29.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.385]                               info)
[13:20:29.385]                           }
[13:20:29.385]                           else {
[13:20:29.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.385]                               info, version)
[13:20:29.385]                           }
[13:20:29.385]                           base::stop(msg)
[13:20:29.385]                         }
[13:20:29.385]                       })
[13:20:29.385]                     }
[13:20:29.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.385]                     base::options(mc.cores = 1L)
[13:20:29.385]                   }
[13:20:29.385]                   options(future.plan = NULL)
[13:20:29.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.385]                 }
[13:20:29.385]                 ...future.workdir <- getwd()
[13:20:29.385]             }
[13:20:29.385]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.385]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.385]         }
[13:20:29.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.385]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.385]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.385]             base::names(...future.oldOptions))
[13:20:29.385]     }
[13:20:29.385]     if (FALSE) {
[13:20:29.385]     }
[13:20:29.385]     else {
[13:20:29.385]         if (TRUE) {
[13:20:29.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.385]                 open = "w")
[13:20:29.385]         }
[13:20:29.385]         else {
[13:20:29.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.385]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.385]         }
[13:20:29.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.385]             base::sink(type = "output", split = FALSE)
[13:20:29.385]             base::close(...future.stdout)
[13:20:29.385]         }, add = TRUE)
[13:20:29.385]     }
[13:20:29.385]     ...future.frame <- base::sys.nframe()
[13:20:29.385]     ...future.conditions <- base::list()
[13:20:29.385]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.385]     if (FALSE) {
[13:20:29.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.385]     }
[13:20:29.385]     ...future.result <- base::tryCatch({
[13:20:29.385]         base::withCallingHandlers({
[13:20:29.385]             ...future.value <- base::withVisible(base::local({
[13:20:29.385]                 withCallingHandlers({
[13:20:29.385]                   NULL
[13:20:29.385]                 }, immediateCondition = function(cond) {
[13:20:29.385]                   save_rds <- function (object, pathname, ...) 
[13:20:29.385]                   {
[13:20:29.385]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.385]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.385]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.385]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.385]                         fi_tmp[["mtime"]])
[13:20:29.385]                     }
[13:20:29.385]                     tryCatch({
[13:20:29.385]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.385]                     }, error = function(ex) {
[13:20:29.385]                       msg <- conditionMessage(ex)
[13:20:29.385]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.385]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.385]                         fi_tmp[["mtime"]], msg)
[13:20:29.385]                       ex$message <- msg
[13:20:29.385]                       stop(ex)
[13:20:29.385]                     })
[13:20:29.385]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.385]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.385]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.385]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.385]                       fi <- file.info(pathname)
[13:20:29.385]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.385]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.385]                         fi[["size"]], fi[["mtime"]])
[13:20:29.385]                       stop(msg)
[13:20:29.385]                     }
[13:20:29.385]                     invisible(pathname)
[13:20:29.385]                   }
[13:20:29.385]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.385]                     rootPath = tempdir()) 
[13:20:29.385]                   {
[13:20:29.385]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.385]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.385]                       tmpdir = path, fileext = ".rds")
[13:20:29.385]                     save_rds(obj, file)
[13:20:29.385]                   }
[13:20:29.385]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.385]                   {
[13:20:29.385]                     inherits <- base::inherits
[13:20:29.385]                     invokeRestart <- base::invokeRestart
[13:20:29.385]                     is.null <- base::is.null
[13:20:29.385]                     muffled <- FALSE
[13:20:29.385]                     if (inherits(cond, "message")) {
[13:20:29.385]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.385]                       if (muffled) 
[13:20:29.385]                         invokeRestart("muffleMessage")
[13:20:29.385]                     }
[13:20:29.385]                     else if (inherits(cond, "warning")) {
[13:20:29.385]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.385]                       if (muffled) 
[13:20:29.385]                         invokeRestart("muffleWarning")
[13:20:29.385]                     }
[13:20:29.385]                     else if (inherits(cond, "condition")) {
[13:20:29.385]                       if (!is.null(pattern)) {
[13:20:29.385]                         computeRestarts <- base::computeRestarts
[13:20:29.385]                         grepl <- base::grepl
[13:20:29.385]                         restarts <- computeRestarts(cond)
[13:20:29.385]                         for (restart in restarts) {
[13:20:29.385]                           name <- restart$name
[13:20:29.385]                           if (is.null(name)) 
[13:20:29.385]                             next
[13:20:29.385]                           if (!grepl(pattern, name)) 
[13:20:29.385]                             next
[13:20:29.385]                           invokeRestart(restart)
[13:20:29.385]                           muffled <- TRUE
[13:20:29.385]                           break
[13:20:29.385]                         }
[13:20:29.385]                       }
[13:20:29.385]                     }
[13:20:29.385]                     invisible(muffled)
[13:20:29.385]                   }
[13:20:29.385]                   muffleCondition(cond)
[13:20:29.385]                 })
[13:20:29.385]             }))
[13:20:29.385]             future::FutureResult(value = ...future.value$value, 
[13:20:29.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.385]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.385]                     ...future.globalenv.names))
[13:20:29.385]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.385]         }, condition = base::local({
[13:20:29.385]             c <- base::c
[13:20:29.385]             inherits <- base::inherits
[13:20:29.385]             invokeRestart <- base::invokeRestart
[13:20:29.385]             length <- base::length
[13:20:29.385]             list <- base::list
[13:20:29.385]             seq.int <- base::seq.int
[13:20:29.385]             signalCondition <- base::signalCondition
[13:20:29.385]             sys.calls <- base::sys.calls
[13:20:29.385]             `[[` <- base::`[[`
[13:20:29.385]             `+` <- base::`+`
[13:20:29.385]             `<<-` <- base::`<<-`
[13:20:29.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.385]                   3L)]
[13:20:29.385]             }
[13:20:29.385]             function(cond) {
[13:20:29.385]                 is_error <- inherits(cond, "error")
[13:20:29.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.385]                   NULL)
[13:20:29.385]                 if (is_error) {
[13:20:29.385]                   sessionInformation <- function() {
[13:20:29.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.385]                       search = base::search(), system = base::Sys.info())
[13:20:29.385]                   }
[13:20:29.385]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.385]                     cond$call), session = sessionInformation(), 
[13:20:29.385]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.385]                   signalCondition(cond)
[13:20:29.385]                 }
[13:20:29.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.385]                 "immediateCondition"))) {
[13:20:29.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.385]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.385]                   if (TRUE && !signal) {
[13:20:29.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.385]                     {
[13:20:29.385]                       inherits <- base::inherits
[13:20:29.385]                       invokeRestart <- base::invokeRestart
[13:20:29.385]                       is.null <- base::is.null
[13:20:29.385]                       muffled <- FALSE
[13:20:29.385]                       if (inherits(cond, "message")) {
[13:20:29.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.385]                         if (muffled) 
[13:20:29.385]                           invokeRestart("muffleMessage")
[13:20:29.385]                       }
[13:20:29.385]                       else if (inherits(cond, "warning")) {
[13:20:29.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.385]                         if (muffled) 
[13:20:29.385]                           invokeRestart("muffleWarning")
[13:20:29.385]                       }
[13:20:29.385]                       else if (inherits(cond, "condition")) {
[13:20:29.385]                         if (!is.null(pattern)) {
[13:20:29.385]                           computeRestarts <- base::computeRestarts
[13:20:29.385]                           grepl <- base::grepl
[13:20:29.385]                           restarts <- computeRestarts(cond)
[13:20:29.385]                           for (restart in restarts) {
[13:20:29.385]                             name <- restart$name
[13:20:29.385]                             if (is.null(name)) 
[13:20:29.385]                               next
[13:20:29.385]                             if (!grepl(pattern, name)) 
[13:20:29.385]                               next
[13:20:29.385]                             invokeRestart(restart)
[13:20:29.385]                             muffled <- TRUE
[13:20:29.385]                             break
[13:20:29.385]                           }
[13:20:29.385]                         }
[13:20:29.385]                       }
[13:20:29.385]                       invisible(muffled)
[13:20:29.385]                     }
[13:20:29.385]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.385]                   }
[13:20:29.385]                 }
[13:20:29.385]                 else {
[13:20:29.385]                   if (TRUE) {
[13:20:29.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.385]                     {
[13:20:29.385]                       inherits <- base::inherits
[13:20:29.385]                       invokeRestart <- base::invokeRestart
[13:20:29.385]                       is.null <- base::is.null
[13:20:29.385]                       muffled <- FALSE
[13:20:29.385]                       if (inherits(cond, "message")) {
[13:20:29.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.385]                         if (muffled) 
[13:20:29.385]                           invokeRestart("muffleMessage")
[13:20:29.385]                       }
[13:20:29.385]                       else if (inherits(cond, "warning")) {
[13:20:29.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.385]                         if (muffled) 
[13:20:29.385]                           invokeRestart("muffleWarning")
[13:20:29.385]                       }
[13:20:29.385]                       else if (inherits(cond, "condition")) {
[13:20:29.385]                         if (!is.null(pattern)) {
[13:20:29.385]                           computeRestarts <- base::computeRestarts
[13:20:29.385]                           grepl <- base::grepl
[13:20:29.385]                           restarts <- computeRestarts(cond)
[13:20:29.385]                           for (restart in restarts) {
[13:20:29.385]                             name <- restart$name
[13:20:29.385]                             if (is.null(name)) 
[13:20:29.385]                               next
[13:20:29.385]                             if (!grepl(pattern, name)) 
[13:20:29.385]                               next
[13:20:29.385]                             invokeRestart(restart)
[13:20:29.385]                             muffled <- TRUE
[13:20:29.385]                             break
[13:20:29.385]                           }
[13:20:29.385]                         }
[13:20:29.385]                       }
[13:20:29.385]                       invisible(muffled)
[13:20:29.385]                     }
[13:20:29.385]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.385]                   }
[13:20:29.385]                 }
[13:20:29.385]             }
[13:20:29.385]         }))
[13:20:29.385]     }, error = function(ex) {
[13:20:29.385]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.385]                 ...future.rng), started = ...future.startTime, 
[13:20:29.385]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.385]             version = "1.8"), class = "FutureResult")
[13:20:29.385]     }, finally = {
[13:20:29.385]         if (!identical(...future.workdir, getwd())) 
[13:20:29.385]             setwd(...future.workdir)
[13:20:29.385]         {
[13:20:29.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.385]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.385]             }
[13:20:29.385]             base::options(...future.oldOptions)
[13:20:29.385]             if (.Platform$OS.type == "windows") {
[13:20:29.385]                 old_names <- names(...future.oldEnvVars)
[13:20:29.385]                 envs <- base::Sys.getenv()
[13:20:29.385]                 names <- names(envs)
[13:20:29.385]                 common <- intersect(names, old_names)
[13:20:29.385]                 added <- setdiff(names, old_names)
[13:20:29.385]                 removed <- setdiff(old_names, names)
[13:20:29.385]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.385]                   envs[common]]
[13:20:29.385]                 NAMES <- toupper(changed)
[13:20:29.385]                 args <- list()
[13:20:29.385]                 for (kk in seq_along(NAMES)) {
[13:20:29.385]                   name <- changed[[kk]]
[13:20:29.385]                   NAME <- NAMES[[kk]]
[13:20:29.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.385]                     next
[13:20:29.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.385]                 }
[13:20:29.385]                 NAMES <- toupper(added)
[13:20:29.385]                 for (kk in seq_along(NAMES)) {
[13:20:29.385]                   name <- added[[kk]]
[13:20:29.385]                   NAME <- NAMES[[kk]]
[13:20:29.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.385]                     next
[13:20:29.385]                   args[[name]] <- ""
[13:20:29.385]                 }
[13:20:29.385]                 NAMES <- toupper(removed)
[13:20:29.385]                 for (kk in seq_along(NAMES)) {
[13:20:29.385]                   name <- removed[[kk]]
[13:20:29.385]                   NAME <- NAMES[[kk]]
[13:20:29.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.385]                     next
[13:20:29.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.385]                 }
[13:20:29.385]                 if (length(args) > 0) 
[13:20:29.385]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.385]             }
[13:20:29.385]             else {
[13:20:29.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.385]             }
[13:20:29.385]             {
[13:20:29.385]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.385]                   0L) {
[13:20:29.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.385]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.385]                   base::options(opts)
[13:20:29.385]                 }
[13:20:29.385]                 {
[13:20:29.385]                   {
[13:20:29.385]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.385]                     NULL
[13:20:29.385]                   }
[13:20:29.385]                   options(future.plan = NULL)
[13:20:29.385]                   if (is.na(NA_character_)) 
[13:20:29.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.385]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.385]                     envir = parent.frame()) 
[13:20:29.385]                   {
[13:20:29.385]                     default_workers <- missing(workers)
[13:20:29.385]                     if (is.function(workers)) 
[13:20:29.385]                       workers <- workers()
[13:20:29.385]                     workers <- structure(as.integer(workers), 
[13:20:29.385]                       class = class(workers))
[13:20:29.385]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.385]                       1L)
[13:20:29.385]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.385]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.385]                       if (default_workers) 
[13:20:29.385]                         supportsMulticore(warn = TRUE)
[13:20:29.385]                       return(sequential(..., envir = envir))
[13:20:29.385]                     }
[13:20:29.385]                     oopts <- options(mc.cores = workers)
[13:20:29.385]                     on.exit(options(oopts))
[13:20:29.385]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.385]                       envir = envir)
[13:20:29.385]                     if (!future$lazy) 
[13:20:29.385]                       future <- run(future)
[13:20:29.385]                     invisible(future)
[13:20:29.385]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.385]                 }
[13:20:29.385]             }
[13:20:29.385]         }
[13:20:29.385]     })
[13:20:29.385]     if (TRUE) {
[13:20:29.385]         base::sink(type = "output", split = FALSE)
[13:20:29.385]         if (TRUE) {
[13:20:29.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.385]         }
[13:20:29.385]         else {
[13:20:29.385]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.385]         }
[13:20:29.385]         base::close(...future.stdout)
[13:20:29.385]         ...future.stdout <- NULL
[13:20:29.385]     }
[13:20:29.385]     ...future.result$conditions <- ...future.conditions
[13:20:29.385]     ...future.result$finished <- base::Sys.time()
[13:20:29.385]     ...future.result
[13:20:29.385] }
[13:20:29.389] requestCore(): workers = 2
[13:20:29.392] MulticoreFuture started
[13:20:29.392] - Launch lazy future ... done
[13:20:29.393] run() for ‘MulticoreFuture’ ... done
[13:20:29.393] plan(): Setting new future strategy stack:
[13:20:29.394] getGlobalsAndPackages() ...
[13:20:29.394] Searching for globals...
[13:20:29.394] List of future strategies:
[13:20:29.394] 1. sequential:
[13:20:29.394]    - args: function (..., envir = parent.frame())
[13:20:29.394]    - tweaked: FALSE
[13:20:29.394]    - call: NULL
[13:20:29.395] plan(): nbrOfWorkers() = 1
[13:20:29.395] - globals found: [1] ‘{’
[13:20:29.395] Searching for globals ... DONE
[13:20:29.396] Resolving globals: FALSE
[13:20:29.396] 
[13:20:29.396] 
[13:20:29.396] getGlobalsAndPackages() ... DONE
[13:20:29.397] plan(): Setting new future strategy stack:
[13:20:29.397] run() for ‘Future’ ...
[13:20:29.397] - state: ‘created’
[13:20:29.397] List of future strategies:
[13:20:29.397] 1. multicore:
[13:20:29.397]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.397]    - tweaked: FALSE
[13:20:29.397]    - call: plan(strategy)
[13:20:29.397] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.402] plan(): nbrOfWorkers() = 2
[13:20:29.403] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.403] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.403]   - Field: ‘label’
[13:20:29.403]   - Field: ‘local’
[13:20:29.403]   - Field: ‘owner’
[13:20:29.404]   - Field: ‘envir’
[13:20:29.404]   - Field: ‘workers’
[13:20:29.404]   - Field: ‘packages’
[13:20:29.404]   - Field: ‘gc’
[13:20:29.404]   - Field: ‘job’
[13:20:29.404]   - Field: ‘conditions’
[13:20:29.404]   - Field: ‘expr’
[13:20:29.405]   - Field: ‘uuid’
[13:20:29.405]   - Field: ‘seed’
[13:20:29.405]   - Field: ‘version’
[13:20:29.405]   - Field: ‘result’
[13:20:29.405]   - Field: ‘asynchronous’
[13:20:29.405]   - Field: ‘calls’
[13:20:29.405]   - Field: ‘globals’
[13:20:29.406]   - Field: ‘stdout’
[13:20:29.406]   - Field: ‘earlySignal’
[13:20:29.406]   - Field: ‘lazy’
[13:20:29.406]   - Field: ‘state’
[13:20:29.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.406] - Launch lazy future ...
[13:20:29.407] Packages needed by the future expression (n = 0): <none>
[13:20:29.407] Packages needed by future strategies (n = 0): <none>
[13:20:29.408] {
[13:20:29.408]     {
[13:20:29.408]         {
[13:20:29.408]             ...future.startTime <- base::Sys.time()
[13:20:29.408]             {
[13:20:29.408]                 {
[13:20:29.408]                   {
[13:20:29.408]                     {
[13:20:29.408]                       base::local({
[13:20:29.408]                         has_future <- base::requireNamespace("future", 
[13:20:29.408]                           quietly = TRUE)
[13:20:29.408]                         if (has_future) {
[13:20:29.408]                           ns <- base::getNamespace("future")
[13:20:29.408]                           version <- ns[[".package"]][["version"]]
[13:20:29.408]                           if (is.null(version)) 
[13:20:29.408]                             version <- utils::packageVersion("future")
[13:20:29.408]                         }
[13:20:29.408]                         else {
[13:20:29.408]                           version <- NULL
[13:20:29.408]                         }
[13:20:29.408]                         if (!has_future || version < "1.8.0") {
[13:20:29.408]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.408]                             "", base::R.version$version.string), 
[13:20:29.408]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.408]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.408]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.408]                               "release", "version")], collapse = " "), 
[13:20:29.408]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.408]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.408]                             info)
[13:20:29.408]                           info <- base::paste(info, collapse = "; ")
[13:20:29.408]                           if (!has_future) {
[13:20:29.408]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.408]                               info)
[13:20:29.408]                           }
[13:20:29.408]                           else {
[13:20:29.408]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.408]                               info, version)
[13:20:29.408]                           }
[13:20:29.408]                           base::stop(msg)
[13:20:29.408]                         }
[13:20:29.408]                       })
[13:20:29.408]                     }
[13:20:29.408]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.408]                     base::options(mc.cores = 1L)
[13:20:29.408]                   }
[13:20:29.408]                   options(future.plan = NULL)
[13:20:29.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.408]                 }
[13:20:29.408]                 ...future.workdir <- getwd()
[13:20:29.408]             }
[13:20:29.408]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.408]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.408]         }
[13:20:29.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.408]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.408]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.408]             base::names(...future.oldOptions))
[13:20:29.408]     }
[13:20:29.408]     if (FALSE) {
[13:20:29.408]     }
[13:20:29.408]     else {
[13:20:29.408]         if (TRUE) {
[13:20:29.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.408]                 open = "w")
[13:20:29.408]         }
[13:20:29.408]         else {
[13:20:29.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.408]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.408]         }
[13:20:29.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.408]             base::sink(type = "output", split = FALSE)
[13:20:29.408]             base::close(...future.stdout)
[13:20:29.408]         }, add = TRUE)
[13:20:29.408]     }
[13:20:29.408]     ...future.frame <- base::sys.nframe()
[13:20:29.408]     ...future.conditions <- base::list()
[13:20:29.408]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.408]     if (FALSE) {
[13:20:29.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.408]     }
[13:20:29.408]     ...future.result <- base::tryCatch({
[13:20:29.408]         base::withCallingHandlers({
[13:20:29.408]             ...future.value <- base::withVisible(base::local({
[13:20:29.408]                 withCallingHandlers({
[13:20:29.408]                   {
[13:20:29.408]                     4
[13:20:29.408]                   }
[13:20:29.408]                 }, immediateCondition = function(cond) {
[13:20:29.408]                   save_rds <- function (object, pathname, ...) 
[13:20:29.408]                   {
[13:20:29.408]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.408]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.408]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.408]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.408]                         fi_tmp[["mtime"]])
[13:20:29.408]                     }
[13:20:29.408]                     tryCatch({
[13:20:29.408]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.408]                     }, error = function(ex) {
[13:20:29.408]                       msg <- conditionMessage(ex)
[13:20:29.408]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.408]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.408]                         fi_tmp[["mtime"]], msg)
[13:20:29.408]                       ex$message <- msg
[13:20:29.408]                       stop(ex)
[13:20:29.408]                     })
[13:20:29.408]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.408]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.408]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.408]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.408]                       fi <- file.info(pathname)
[13:20:29.408]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.408]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.408]                         fi[["size"]], fi[["mtime"]])
[13:20:29.408]                       stop(msg)
[13:20:29.408]                     }
[13:20:29.408]                     invisible(pathname)
[13:20:29.408]                   }
[13:20:29.408]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.408]                     rootPath = tempdir()) 
[13:20:29.408]                   {
[13:20:29.408]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.408]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.408]                       tmpdir = path, fileext = ".rds")
[13:20:29.408]                     save_rds(obj, file)
[13:20:29.408]                   }
[13:20:29.408]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.408]                   {
[13:20:29.408]                     inherits <- base::inherits
[13:20:29.408]                     invokeRestart <- base::invokeRestart
[13:20:29.408]                     is.null <- base::is.null
[13:20:29.408]                     muffled <- FALSE
[13:20:29.408]                     if (inherits(cond, "message")) {
[13:20:29.408]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.408]                       if (muffled) 
[13:20:29.408]                         invokeRestart("muffleMessage")
[13:20:29.408]                     }
[13:20:29.408]                     else if (inherits(cond, "warning")) {
[13:20:29.408]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.408]                       if (muffled) 
[13:20:29.408]                         invokeRestart("muffleWarning")
[13:20:29.408]                     }
[13:20:29.408]                     else if (inherits(cond, "condition")) {
[13:20:29.408]                       if (!is.null(pattern)) {
[13:20:29.408]                         computeRestarts <- base::computeRestarts
[13:20:29.408]                         grepl <- base::grepl
[13:20:29.408]                         restarts <- computeRestarts(cond)
[13:20:29.408]                         for (restart in restarts) {
[13:20:29.408]                           name <- restart$name
[13:20:29.408]                           if (is.null(name)) 
[13:20:29.408]                             next
[13:20:29.408]                           if (!grepl(pattern, name)) 
[13:20:29.408]                             next
[13:20:29.408]                           invokeRestart(restart)
[13:20:29.408]                           muffled <- TRUE
[13:20:29.408]                           break
[13:20:29.408]                         }
[13:20:29.408]                       }
[13:20:29.408]                     }
[13:20:29.408]                     invisible(muffled)
[13:20:29.408]                   }
[13:20:29.408]                   muffleCondition(cond)
[13:20:29.408]                 })
[13:20:29.408]             }))
[13:20:29.408]             future::FutureResult(value = ...future.value$value, 
[13:20:29.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.408]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.408]                     ...future.globalenv.names))
[13:20:29.408]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.408]         }, condition = base::local({
[13:20:29.408]             c <- base::c
[13:20:29.408]             inherits <- base::inherits
[13:20:29.408]             invokeRestart <- base::invokeRestart
[13:20:29.408]             length <- base::length
[13:20:29.408]             list <- base::list
[13:20:29.408]             seq.int <- base::seq.int
[13:20:29.408]             signalCondition <- base::signalCondition
[13:20:29.408]             sys.calls <- base::sys.calls
[13:20:29.408]             `[[` <- base::`[[`
[13:20:29.408]             `+` <- base::`+`
[13:20:29.408]             `<<-` <- base::`<<-`
[13:20:29.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.408]                   3L)]
[13:20:29.408]             }
[13:20:29.408]             function(cond) {
[13:20:29.408]                 is_error <- inherits(cond, "error")
[13:20:29.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.408]                   NULL)
[13:20:29.408]                 if (is_error) {
[13:20:29.408]                   sessionInformation <- function() {
[13:20:29.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.408]                       search = base::search(), system = base::Sys.info())
[13:20:29.408]                   }
[13:20:29.408]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.408]                     cond$call), session = sessionInformation(), 
[13:20:29.408]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.408]                   signalCondition(cond)
[13:20:29.408]                 }
[13:20:29.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.408]                 "immediateCondition"))) {
[13:20:29.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.408]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.408]                   if (TRUE && !signal) {
[13:20:29.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.408]                     {
[13:20:29.408]                       inherits <- base::inherits
[13:20:29.408]                       invokeRestart <- base::invokeRestart
[13:20:29.408]                       is.null <- base::is.null
[13:20:29.408]                       muffled <- FALSE
[13:20:29.408]                       if (inherits(cond, "message")) {
[13:20:29.408]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.408]                         if (muffled) 
[13:20:29.408]                           invokeRestart("muffleMessage")
[13:20:29.408]                       }
[13:20:29.408]                       else if (inherits(cond, "warning")) {
[13:20:29.408]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.408]                         if (muffled) 
[13:20:29.408]                           invokeRestart("muffleWarning")
[13:20:29.408]                       }
[13:20:29.408]                       else if (inherits(cond, "condition")) {
[13:20:29.408]                         if (!is.null(pattern)) {
[13:20:29.408]                           computeRestarts <- base::computeRestarts
[13:20:29.408]                           grepl <- base::grepl
[13:20:29.408]                           restarts <- computeRestarts(cond)
[13:20:29.408]                           for (restart in restarts) {
[13:20:29.408]                             name <- restart$name
[13:20:29.408]                             if (is.null(name)) 
[13:20:29.408]                               next
[13:20:29.408]                             if (!grepl(pattern, name)) 
[13:20:29.408]                               next
[13:20:29.408]                             invokeRestart(restart)
[13:20:29.408]                             muffled <- TRUE
[13:20:29.408]                             break
[13:20:29.408]                           }
[13:20:29.408]                         }
[13:20:29.408]                       }
[13:20:29.408]                       invisible(muffled)
[13:20:29.408]                     }
[13:20:29.408]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.408]                   }
[13:20:29.408]                 }
[13:20:29.408]                 else {
[13:20:29.408]                   if (TRUE) {
[13:20:29.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.408]                     {
[13:20:29.408]                       inherits <- base::inherits
[13:20:29.408]                       invokeRestart <- base::invokeRestart
[13:20:29.408]                       is.null <- base::is.null
[13:20:29.408]                       muffled <- FALSE
[13:20:29.408]                       if (inherits(cond, "message")) {
[13:20:29.408]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.408]                         if (muffled) 
[13:20:29.408]                           invokeRestart("muffleMessage")
[13:20:29.408]                       }
[13:20:29.408]                       else if (inherits(cond, "warning")) {
[13:20:29.408]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.408]                         if (muffled) 
[13:20:29.408]                           invokeRestart("muffleWarning")
[13:20:29.408]                       }
[13:20:29.408]                       else if (inherits(cond, "condition")) {
[13:20:29.408]                         if (!is.null(pattern)) {
[13:20:29.408]                           computeRestarts <- base::computeRestarts
[13:20:29.408]                           grepl <- base::grepl
[13:20:29.408]                           restarts <- computeRestarts(cond)
[13:20:29.408]                           for (restart in restarts) {
[13:20:29.408]                             name <- restart$name
[13:20:29.408]                             if (is.null(name)) 
[13:20:29.408]                               next
[13:20:29.408]                             if (!grepl(pattern, name)) 
[13:20:29.408]                               next
[13:20:29.408]                             invokeRestart(restart)
[13:20:29.408]                             muffled <- TRUE
[13:20:29.408]                             break
[13:20:29.408]                           }
[13:20:29.408]                         }
[13:20:29.408]                       }
[13:20:29.408]                       invisible(muffled)
[13:20:29.408]                     }
[13:20:29.408]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.408]                   }
[13:20:29.408]                 }
[13:20:29.408]             }
[13:20:29.408]         }))
[13:20:29.408]     }, error = function(ex) {
[13:20:29.408]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.408]                 ...future.rng), started = ...future.startTime, 
[13:20:29.408]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.408]             version = "1.8"), class = "FutureResult")
[13:20:29.408]     }, finally = {
[13:20:29.408]         if (!identical(...future.workdir, getwd())) 
[13:20:29.408]             setwd(...future.workdir)
[13:20:29.408]         {
[13:20:29.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.408]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.408]             }
[13:20:29.408]             base::options(...future.oldOptions)
[13:20:29.408]             if (.Platform$OS.type == "windows") {
[13:20:29.408]                 old_names <- names(...future.oldEnvVars)
[13:20:29.408]                 envs <- base::Sys.getenv()
[13:20:29.408]                 names <- names(envs)
[13:20:29.408]                 common <- intersect(names, old_names)
[13:20:29.408]                 added <- setdiff(names, old_names)
[13:20:29.408]                 removed <- setdiff(old_names, names)
[13:20:29.408]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.408]                   envs[common]]
[13:20:29.408]                 NAMES <- toupper(changed)
[13:20:29.408]                 args <- list()
[13:20:29.408]                 for (kk in seq_along(NAMES)) {
[13:20:29.408]                   name <- changed[[kk]]
[13:20:29.408]                   NAME <- NAMES[[kk]]
[13:20:29.408]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.408]                     next
[13:20:29.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.408]                 }
[13:20:29.408]                 NAMES <- toupper(added)
[13:20:29.408]                 for (kk in seq_along(NAMES)) {
[13:20:29.408]                   name <- added[[kk]]
[13:20:29.408]                   NAME <- NAMES[[kk]]
[13:20:29.408]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.408]                     next
[13:20:29.408]                   args[[name]] <- ""
[13:20:29.408]                 }
[13:20:29.408]                 NAMES <- toupper(removed)
[13:20:29.408]                 for (kk in seq_along(NAMES)) {
[13:20:29.408]                   name <- removed[[kk]]
[13:20:29.408]                   NAME <- NAMES[[kk]]
[13:20:29.408]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.408]                     next
[13:20:29.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.408]                 }
[13:20:29.408]                 if (length(args) > 0) 
[13:20:29.408]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.408]             }
[13:20:29.408]             else {
[13:20:29.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.408]             }
[13:20:29.408]             {
[13:20:29.408]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.408]                   0L) {
[13:20:29.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.408]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.408]                   base::options(opts)
[13:20:29.408]                 }
[13:20:29.408]                 {
[13:20:29.408]                   {
[13:20:29.408]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.408]                     NULL
[13:20:29.408]                   }
[13:20:29.408]                   options(future.plan = NULL)
[13:20:29.408]                   if (is.na(NA_character_)) 
[13:20:29.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.408]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.408]                     envir = parent.frame()) 
[13:20:29.408]                   {
[13:20:29.408]                     default_workers <- missing(workers)
[13:20:29.408]                     if (is.function(workers)) 
[13:20:29.408]                       workers <- workers()
[13:20:29.408]                     workers <- structure(as.integer(workers), 
[13:20:29.408]                       class = class(workers))
[13:20:29.408]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.408]                       1L)
[13:20:29.408]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.408]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.408]                       if (default_workers) 
[13:20:29.408]                         supportsMulticore(warn = TRUE)
[13:20:29.408]                       return(sequential(..., envir = envir))
[13:20:29.408]                     }
[13:20:29.408]                     oopts <- options(mc.cores = workers)
[13:20:29.408]                     on.exit(options(oopts))
[13:20:29.408]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.408]                       envir = envir)
[13:20:29.408]                     if (!future$lazy) 
[13:20:29.408]                       future <- run(future)
[13:20:29.408]                     invisible(future)
[13:20:29.408]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.408]                 }
[13:20:29.408]             }
[13:20:29.408]         }
[13:20:29.408]     })
[13:20:29.408]     if (TRUE) {
[13:20:29.408]         base::sink(type = "output", split = FALSE)
[13:20:29.408]         if (TRUE) {
[13:20:29.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.408]         }
[13:20:29.408]         else {
[13:20:29.408]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.408]         }
[13:20:29.408]         base::close(...future.stdout)
[13:20:29.408]         ...future.stdout <- NULL
[13:20:29.408]     }
[13:20:29.408]     ...future.result$conditions <- ...future.conditions
[13:20:29.408]     ...future.result$finished <- base::Sys.time()
[13:20:29.408]     ...future.result
[13:20:29.408] }
[13:20:29.412] requestCore(): workers = 2
[13:20:29.413] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:29.428] MulticoreFuture started
[13:20:29.428] - Launch lazy future ... done
[13:20:29.429] run() for ‘MulticoreFuture’ ... done
[13:20:29.429] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55659b48c1f0> 
[13:20:29.430] List of future strategies:
[13:20:29.430] 1. sequential:
[13:20:29.430]    - args: function (..., envir = parent.frame())
[13:20:29.430]    - tweaked: FALSE
[13:20:29.430]    - call: NULL
[13:20:29.431] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55659cedf688> 
 - attr(*, "dim.")=[13:20:29.434] plan(): Setting new future strategy stack:
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ :[13:20:29.434] List of future strategies:
[13:20:29.434] 1. multicore:
[13:20:29.434]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.434]    - tweaked: FALSE
[13:20:29.434]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:20:29.440] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:29.444] resolve() on list environment ...
[13:20:29.445]  recursive: 0
[13:20:29.446]  length: 6
[13:20:29.446]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:29.446] signalConditionsASAP(numeric, pos=1) ...
[13:20:29.447] - nx: 6
[13:20:29.447] - relay: TRUE
[13:20:29.447] - stdout: TRUE
[13:20:29.447] - signal: TRUE
[13:20:29.447] - resignal: FALSE
[13:20:29.447] - force: TRUE
[13:20:29.447] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.447] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.448]  - until=2
[13:20:29.448]  - relaying element #2
[13:20:29.448] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.448] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.448] signalConditionsASAP(NULL, pos=1) ... done
[13:20:29.448]  length: 5 (resolved future 1)
[13:20:29.448] Future #2
[13:20:29.449] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:29.449] - nx: 6
[13:20:29.449] - relay: TRUE
[13:20:29.449] - stdout: TRUE
[13:20:29.449] - signal: TRUE
[13:20:29.449] - resignal: FALSE
[13:20:29.449] - force: TRUE
[13:20:29.450] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.450] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.450]  - until=2
[13:20:29.450]  - relaying element #2
[13:20:29.450] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.450] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.450] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:29.451]  length: 4 (resolved future 2)
[13:20:29.451] Future #3
[13:20:29.452] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:29.452] - nx: 6
[13:20:29.452] - relay: TRUE
[13:20:29.452] - stdout: TRUE
[13:20:29.452] - signal: TRUE
[13:20:29.453] - resignal: FALSE
[13:20:29.453] - force: TRUE
[13:20:29.453] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.453] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.453]  - until=3
[13:20:29.453]  - relaying element #3
[13:20:29.453] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.454] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.454] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:29.454]  length: 3 (resolved future 3)
[13:20:29.454] Future #4
[13:20:29.455] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:20:29.455] - nx: 6
[13:20:29.455] - relay: TRUE
[13:20:29.455] - stdout: TRUE
[13:20:29.456] - signal: TRUE
[13:20:29.456] - resignal: FALSE
[13:20:29.456] - force: TRUE
[13:20:29.456] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.456] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.456]  - until=4
[13:20:29.457]  - relaying element #4
[13:20:29.457] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.457] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.457] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:20:29.458]  length: 2 (resolved future 4)
[13:20:29.458] signalConditionsASAP(NULL, pos=5) ...
[13:20:29.458] - nx: 6
[13:20:29.458] - relay: TRUE
[13:20:29.458] - stdout: TRUE
[13:20:29.458] - signal: TRUE
[13:20:29.458] - resignal: FALSE
[13:20:29.459] - force: TRUE
[13:20:29.459] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.459] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.459]  - until=6
[13:20:29.459]  - relaying element #6
[13:20:29.459] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:29.459] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.459] signalConditionsASAP(NULL, pos=5) ... done
[13:20:29.459]  length: 1 (resolved future 5)
[13:20:29.460] signalConditionsASAP(numeric, pos=6) ...
[13:20:29.460] - nx: 6
[13:20:29.460] - relay: TRUE
[13:20:29.460] - stdout: TRUE
[13:20:29.460] - signal: TRUE
[13:20:29.460] - resignal: FALSE
[13:20:29.460] - force: TRUE
[13:20:29.460] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:29.460] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.460]  - until=6
[13:20:29.461] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.461] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.461] signalConditionsASAP(numeric, pos=6) ... done
[13:20:29.461]  length: 0 (resolved future 6)
[13:20:29.461] Relaying remaining futures
[13:20:29.461] signalConditionsASAP(NULL, pos=0) ...
[13:20:29.461] - nx: 6
[13:20:29.461] - relay: TRUE
[13:20:29.461] - stdout: TRUE
[13:20:29.462] - signal: TRUE
[13:20:29.462] - resignal: FALSE
[13:20:29.462] - force: TRUE
[13:20:29.462] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.462] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:29.462] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.462] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.462] signalConditionsASAP(NULL, pos=0) ... done
[13:20:29.462] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55659d21cfd0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:20:29.465] getGlobalsAndPackages() ...
[13:20:29.465] Searching for globals...
[13:20:29.466] 
[13:20:29.466] Searching for globals ... DONE
[13:20:29.466] - globals: [0] <none>
[13:20:29.466] getGlobalsAndPackages() ... DONE
[13:20:29.466] run() for ‘Future’ ...
[13:20:29.466] - state: ‘created’
[13:20:29.467] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.471] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.471] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.471]   - Field: ‘label’
[13:20:29.471]   - Field: ‘local’
[13:20:29.471]   - Field: ‘owner’
[13:20:29.471]   - Field: ‘envir’
[13:20:29.471]   - Field: ‘workers’
[13:20:29.472]   - Field: ‘packages’
[13:20:29.472]   - Field: ‘gc’
[13:20:29.472]   - Field: ‘job’
[13:20:29.472]   - Field: ‘conditions’
[13:20:29.472]   - Field: ‘expr’
[13:20:29.472]   - Field: ‘uuid’
[13:20:29.472]   - Field: ‘seed’
[13:20:29.472]   - Field: ‘version’
[13:20:29.472]   - Field: ‘result’
[13:20:29.473]   - Field: ‘asynchronous’
[13:20:29.473]   - Field: ‘calls’
[13:20:29.473]   - Field: ‘globals’
[13:20:29.473]   - Field: ‘stdout’
[13:20:29.477]   - Field: ‘earlySignal’
[13:20:29.477]   - Field: ‘lazy’
[13:20:29.477]   - Field: ‘state’
[13:20:29.478] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.478] - Launch lazy future ...
[13:20:29.478] Packages needed by the future expression (n = 0): <none>
[13:20:29.478] Packages needed by future strategies (n = 0): <none>
[13:20:29.479] {
[13:20:29.479]     {
[13:20:29.479]         {
[13:20:29.479]             ...future.startTime <- base::Sys.time()
[13:20:29.479]             {
[13:20:29.479]                 {
[13:20:29.479]                   {
[13:20:29.479]                     {
[13:20:29.479]                       base::local({
[13:20:29.479]                         has_future <- base::requireNamespace("future", 
[13:20:29.479]                           quietly = TRUE)
[13:20:29.479]                         if (has_future) {
[13:20:29.479]                           ns <- base::getNamespace("future")
[13:20:29.479]                           version <- ns[[".package"]][["version"]]
[13:20:29.479]                           if (is.null(version)) 
[13:20:29.479]                             version <- utils::packageVersion("future")
[13:20:29.479]                         }
[13:20:29.479]                         else {
[13:20:29.479]                           version <- NULL
[13:20:29.479]                         }
[13:20:29.479]                         if (!has_future || version < "1.8.0") {
[13:20:29.479]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.479]                             "", base::R.version$version.string), 
[13:20:29.479]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.479]                               "release", "version")], collapse = " "), 
[13:20:29.479]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.479]                             info)
[13:20:29.479]                           info <- base::paste(info, collapse = "; ")
[13:20:29.479]                           if (!has_future) {
[13:20:29.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.479]                               info)
[13:20:29.479]                           }
[13:20:29.479]                           else {
[13:20:29.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.479]                               info, version)
[13:20:29.479]                           }
[13:20:29.479]                           base::stop(msg)
[13:20:29.479]                         }
[13:20:29.479]                       })
[13:20:29.479]                     }
[13:20:29.479]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.479]                     base::options(mc.cores = 1L)
[13:20:29.479]                   }
[13:20:29.479]                   options(future.plan = NULL)
[13:20:29.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.479]                 }
[13:20:29.479]                 ...future.workdir <- getwd()
[13:20:29.479]             }
[13:20:29.479]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.479]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.479]         }
[13:20:29.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.479]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.479]             base::names(...future.oldOptions))
[13:20:29.479]     }
[13:20:29.479]     if (FALSE) {
[13:20:29.479]     }
[13:20:29.479]     else {
[13:20:29.479]         if (TRUE) {
[13:20:29.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.479]                 open = "w")
[13:20:29.479]         }
[13:20:29.479]         else {
[13:20:29.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.479]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.479]         }
[13:20:29.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.479]             base::sink(type = "output", split = FALSE)
[13:20:29.479]             base::close(...future.stdout)
[13:20:29.479]         }, add = TRUE)
[13:20:29.479]     }
[13:20:29.479]     ...future.frame <- base::sys.nframe()
[13:20:29.479]     ...future.conditions <- base::list()
[13:20:29.479]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.479]     if (FALSE) {
[13:20:29.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.479]     }
[13:20:29.479]     ...future.result <- base::tryCatch({
[13:20:29.479]         base::withCallingHandlers({
[13:20:29.479]             ...future.value <- base::withVisible(base::local({
[13:20:29.479]                 withCallingHandlers({
[13:20:29.479]                   2
[13:20:29.479]                 }, immediateCondition = function(cond) {
[13:20:29.479]                   save_rds <- function (object, pathname, ...) 
[13:20:29.479]                   {
[13:20:29.479]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.479]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.479]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.479]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.479]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.479]                         fi_tmp[["mtime"]])
[13:20:29.479]                     }
[13:20:29.479]                     tryCatch({
[13:20:29.479]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.479]                     }, error = function(ex) {
[13:20:29.479]                       msg <- conditionMessage(ex)
[13:20:29.479]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.479]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.479]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.479]                         fi_tmp[["mtime"]], msg)
[13:20:29.479]                       ex$message <- msg
[13:20:29.479]                       stop(ex)
[13:20:29.479]                     })
[13:20:29.479]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.479]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.479]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.479]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.479]                       fi <- file.info(pathname)
[13:20:29.479]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.479]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.479]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.479]                         fi[["size"]], fi[["mtime"]])
[13:20:29.479]                       stop(msg)
[13:20:29.479]                     }
[13:20:29.479]                     invisible(pathname)
[13:20:29.479]                   }
[13:20:29.479]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.479]                     rootPath = tempdir()) 
[13:20:29.479]                   {
[13:20:29.479]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.479]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.479]                       tmpdir = path, fileext = ".rds")
[13:20:29.479]                     save_rds(obj, file)
[13:20:29.479]                   }
[13:20:29.479]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.479]                   {
[13:20:29.479]                     inherits <- base::inherits
[13:20:29.479]                     invokeRestart <- base::invokeRestart
[13:20:29.479]                     is.null <- base::is.null
[13:20:29.479]                     muffled <- FALSE
[13:20:29.479]                     if (inherits(cond, "message")) {
[13:20:29.479]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.479]                       if (muffled) 
[13:20:29.479]                         invokeRestart("muffleMessage")
[13:20:29.479]                     }
[13:20:29.479]                     else if (inherits(cond, "warning")) {
[13:20:29.479]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.479]                       if (muffled) 
[13:20:29.479]                         invokeRestart("muffleWarning")
[13:20:29.479]                     }
[13:20:29.479]                     else if (inherits(cond, "condition")) {
[13:20:29.479]                       if (!is.null(pattern)) {
[13:20:29.479]                         computeRestarts <- base::computeRestarts
[13:20:29.479]                         grepl <- base::grepl
[13:20:29.479]                         restarts <- computeRestarts(cond)
[13:20:29.479]                         for (restart in restarts) {
[13:20:29.479]                           name <- restart$name
[13:20:29.479]                           if (is.null(name)) 
[13:20:29.479]                             next
[13:20:29.479]                           if (!grepl(pattern, name)) 
[13:20:29.479]                             next
[13:20:29.479]                           invokeRestart(restart)
[13:20:29.479]                           muffled <- TRUE
[13:20:29.479]                           break
[13:20:29.479]                         }
[13:20:29.479]                       }
[13:20:29.479]                     }
[13:20:29.479]                     invisible(muffled)
[13:20:29.479]                   }
[13:20:29.479]                   muffleCondition(cond)
[13:20:29.479]                 })
[13:20:29.479]             }))
[13:20:29.479]             future::FutureResult(value = ...future.value$value, 
[13:20:29.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.479]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.479]                     ...future.globalenv.names))
[13:20:29.479]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.479]         }, condition = base::local({
[13:20:29.479]             c <- base::c
[13:20:29.479]             inherits <- base::inherits
[13:20:29.479]             invokeRestart <- base::invokeRestart
[13:20:29.479]             length <- base::length
[13:20:29.479]             list <- base::list
[13:20:29.479]             seq.int <- base::seq.int
[13:20:29.479]             signalCondition <- base::signalCondition
[13:20:29.479]             sys.calls <- base::sys.calls
[13:20:29.479]             `[[` <- base::`[[`
[13:20:29.479]             `+` <- base::`+`
[13:20:29.479]             `<<-` <- base::`<<-`
[13:20:29.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.479]                   3L)]
[13:20:29.479]             }
[13:20:29.479]             function(cond) {
[13:20:29.479]                 is_error <- inherits(cond, "error")
[13:20:29.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.479]                   NULL)
[13:20:29.479]                 if (is_error) {
[13:20:29.479]                   sessionInformation <- function() {
[13:20:29.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.479]                       search = base::search(), system = base::Sys.info())
[13:20:29.479]                   }
[13:20:29.479]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.479]                     cond$call), session = sessionInformation(), 
[13:20:29.479]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.479]                   signalCondition(cond)
[13:20:29.479]                 }
[13:20:29.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.479]                 "immediateCondition"))) {
[13:20:29.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.479]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.479]                   if (TRUE && !signal) {
[13:20:29.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.479]                     {
[13:20:29.479]                       inherits <- base::inherits
[13:20:29.479]                       invokeRestart <- base::invokeRestart
[13:20:29.479]                       is.null <- base::is.null
[13:20:29.479]                       muffled <- FALSE
[13:20:29.479]                       if (inherits(cond, "message")) {
[13:20:29.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.479]                         if (muffled) 
[13:20:29.479]                           invokeRestart("muffleMessage")
[13:20:29.479]                       }
[13:20:29.479]                       else if (inherits(cond, "warning")) {
[13:20:29.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.479]                         if (muffled) 
[13:20:29.479]                           invokeRestart("muffleWarning")
[13:20:29.479]                       }
[13:20:29.479]                       else if (inherits(cond, "condition")) {
[13:20:29.479]                         if (!is.null(pattern)) {
[13:20:29.479]                           computeRestarts <- base::computeRestarts
[13:20:29.479]                           grepl <- base::grepl
[13:20:29.479]                           restarts <- computeRestarts(cond)
[13:20:29.479]                           for (restart in restarts) {
[13:20:29.479]                             name <- restart$name
[13:20:29.479]                             if (is.null(name)) 
[13:20:29.479]                               next
[13:20:29.479]                             if (!grepl(pattern, name)) 
[13:20:29.479]                               next
[13:20:29.479]                             invokeRestart(restart)
[13:20:29.479]                             muffled <- TRUE
[13:20:29.479]                             break
[13:20:29.479]                           }
[13:20:29.479]                         }
[13:20:29.479]                       }
[13:20:29.479]                       invisible(muffled)
[13:20:29.479]                     }
[13:20:29.479]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.479]                   }
[13:20:29.479]                 }
[13:20:29.479]                 else {
[13:20:29.479]                   if (TRUE) {
[13:20:29.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.479]                     {
[13:20:29.479]                       inherits <- base::inherits
[13:20:29.479]                       invokeRestart <- base::invokeRestart
[13:20:29.479]                       is.null <- base::is.null
[13:20:29.479]                       muffled <- FALSE
[13:20:29.479]                       if (inherits(cond, "message")) {
[13:20:29.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.479]                         if (muffled) 
[13:20:29.479]                           invokeRestart("muffleMessage")
[13:20:29.479]                       }
[13:20:29.479]                       else if (inherits(cond, "warning")) {
[13:20:29.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.479]                         if (muffled) 
[13:20:29.479]                           invokeRestart("muffleWarning")
[13:20:29.479]                       }
[13:20:29.479]                       else if (inherits(cond, "condition")) {
[13:20:29.479]                         if (!is.null(pattern)) {
[13:20:29.479]                           computeRestarts <- base::computeRestarts
[13:20:29.479]                           grepl <- base::grepl
[13:20:29.479]                           restarts <- computeRestarts(cond)
[13:20:29.479]                           for (restart in restarts) {
[13:20:29.479]                             name <- restart$name
[13:20:29.479]                             if (is.null(name)) 
[13:20:29.479]                               next
[13:20:29.479]                             if (!grepl(pattern, name)) 
[13:20:29.479]                               next
[13:20:29.479]                             invokeRestart(restart)
[13:20:29.479]                             muffled <- TRUE
[13:20:29.479]                             break
[13:20:29.479]                           }
[13:20:29.479]                         }
[13:20:29.479]                       }
[13:20:29.479]                       invisible(muffled)
[13:20:29.479]                     }
[13:20:29.479]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.479]                   }
[13:20:29.479]                 }
[13:20:29.479]             }
[13:20:29.479]         }))
[13:20:29.479]     }, error = function(ex) {
[13:20:29.479]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.479]                 ...future.rng), started = ...future.startTime, 
[13:20:29.479]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.479]             version = "1.8"), class = "FutureResult")
[13:20:29.479]     }, finally = {
[13:20:29.479]         if (!identical(...future.workdir, getwd())) 
[13:20:29.479]             setwd(...future.workdir)
[13:20:29.479]         {
[13:20:29.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.479]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.479]             }
[13:20:29.479]             base::options(...future.oldOptions)
[13:20:29.479]             if (.Platform$OS.type == "windows") {
[13:20:29.479]                 old_names <- names(...future.oldEnvVars)
[13:20:29.479]                 envs <- base::Sys.getenv()
[13:20:29.479]                 names <- names(envs)
[13:20:29.479]                 common <- intersect(names, old_names)
[13:20:29.479]                 added <- setdiff(names, old_names)
[13:20:29.479]                 removed <- setdiff(old_names, names)
[13:20:29.479]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.479]                   envs[common]]
[13:20:29.479]                 NAMES <- toupper(changed)
[13:20:29.479]                 args <- list()
[13:20:29.479]                 for (kk in seq_along(NAMES)) {
[13:20:29.479]                   name <- changed[[kk]]
[13:20:29.479]                   NAME <- NAMES[[kk]]
[13:20:29.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.479]                     next
[13:20:29.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.479]                 }
[13:20:29.479]                 NAMES <- toupper(added)
[13:20:29.479]                 for (kk in seq_along(NAMES)) {
[13:20:29.479]                   name <- added[[kk]]
[13:20:29.479]                   NAME <- NAMES[[kk]]
[13:20:29.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.479]                     next
[13:20:29.479]                   args[[name]] <- ""
[13:20:29.479]                 }
[13:20:29.479]                 NAMES <- toupper(removed)
[13:20:29.479]                 for (kk in seq_along(NAMES)) {
[13:20:29.479]                   name <- removed[[kk]]
[13:20:29.479]                   NAME <- NAMES[[kk]]
[13:20:29.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.479]                     next
[13:20:29.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.479]                 }
[13:20:29.479]                 if (length(args) > 0) 
[13:20:29.479]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.479]             }
[13:20:29.479]             else {
[13:20:29.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.479]             }
[13:20:29.479]             {
[13:20:29.479]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.479]                   0L) {
[13:20:29.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.479]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.479]                   base::options(opts)
[13:20:29.479]                 }
[13:20:29.479]                 {
[13:20:29.479]                   {
[13:20:29.479]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.479]                     NULL
[13:20:29.479]                   }
[13:20:29.479]                   options(future.plan = NULL)
[13:20:29.479]                   if (is.na(NA_character_)) 
[13:20:29.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.479]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.479]                     envir = parent.frame()) 
[13:20:29.479]                   {
[13:20:29.479]                     default_workers <- missing(workers)
[13:20:29.479]                     if (is.function(workers)) 
[13:20:29.479]                       workers <- workers()
[13:20:29.479]                     workers <- structure(as.integer(workers), 
[13:20:29.479]                       class = class(workers))
[13:20:29.479]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.479]                       1L)
[13:20:29.479]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.479]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.479]                       if (default_workers) 
[13:20:29.479]                         supportsMulticore(warn = TRUE)
[13:20:29.479]                       return(sequential(..., envir = envir))
[13:20:29.479]                     }
[13:20:29.479]                     oopts <- options(mc.cores = workers)
[13:20:29.479]                     on.exit(options(oopts))
[13:20:29.479]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.479]                       envir = envir)
[13:20:29.479]                     if (!future$lazy) 
[13:20:29.479]                       future <- run(future)
[13:20:29.479]                     invisible(future)
[13:20:29.479]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.479]                 }
[13:20:29.479]             }
[13:20:29.479]         }
[13:20:29.479]     })
[13:20:29.479]     if (TRUE) {
[13:20:29.479]         base::sink(type = "output", split = FALSE)
[13:20:29.479]         if (TRUE) {
[13:20:29.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.479]         }
[13:20:29.479]         else {
[13:20:29.479]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.479]         }
[13:20:29.479]         base::close(...future.stdout)
[13:20:29.479]         ...future.stdout <- NULL
[13:20:29.479]     }
[13:20:29.479]     ...future.result$conditions <- ...future.conditions
[13:20:29.479]     ...future.result$finished <- base::Sys.time()
[13:20:29.479]     ...future.result
[13:20:29.479] }
[13:20:29.482] requestCore(): workers = 2
[13:20:29.484] MulticoreFuture started
[13:20:29.485] - Launch lazy future ... done
[13:20:29.485] run() for ‘MulticoreFuture’ ... done
[13:20:29.485] getGlobalsAndPackages() ...
[13:20:29.486] Searching for globals...
[13:20:29.486] plan(): Setting new future strategy stack:
[13:20:29.486] 
[13:20:29.486] List of future strategies:
[13:20:29.486] 1. sequential:
[13:20:29.486]    - args: function (..., envir = parent.frame())
[13:20:29.486]    - tweaked: FALSE
[13:20:29.486]    - call: NULL
[13:20:29.487] Searching for globals ... DONE
[13:20:29.487] - globals: [0] <none>
[13:20:29.487] plan(): nbrOfWorkers() = 1
[13:20:29.487] getGlobalsAndPackages() ... DONE
[13:20:29.488] run() for ‘Future’ ...
[13:20:29.488] - state: ‘created’
[13:20:29.488] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.489] plan(): Setting new future strategy stack:
[13:20:29.489] List of future strategies:
[13:20:29.489] 1. multicore:
[13:20:29.489]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.489]    - tweaked: FALSE
[13:20:29.489]    - call: plan(strategy)
[13:20:29.494] plan(): nbrOfWorkers() = 2
[13:20:29.494] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.494] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.494]   - Field: ‘label’
[13:20:29.494]   - Field: ‘local’
[13:20:29.495]   - Field: ‘owner’
[13:20:29.495]   - Field: ‘envir’
[13:20:29.495]   - Field: ‘workers’
[13:20:29.495]   - Field: ‘packages’
[13:20:29.495]   - Field: ‘gc’
[13:20:29.496]   - Field: ‘job’
[13:20:29.496]   - Field: ‘conditions’
[13:20:29.496]   - Field: ‘expr’
[13:20:29.496]   - Field: ‘uuid’
[13:20:29.496]   - Field: ‘seed’
[13:20:29.496]   - Field: ‘version’
[13:20:29.497]   - Field: ‘result’
[13:20:29.497]   - Field: ‘asynchronous’
[13:20:29.497]   - Field: ‘calls’
[13:20:29.497]   - Field: ‘globals’
[13:20:29.497]   - Field: ‘stdout’
[13:20:29.497]   - Field: ‘earlySignal’
[13:20:29.498]   - Field: ‘lazy’
[13:20:29.498]   - Field: ‘state’
[13:20:29.498] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.498] - Launch lazy future ...
[13:20:29.498] Packages needed by the future expression (n = 0): <none>
[13:20:29.499] Packages needed by future strategies (n = 0): <none>
[13:20:29.499] {
[13:20:29.499]     {
[13:20:29.499]         {
[13:20:29.499]             ...future.startTime <- base::Sys.time()
[13:20:29.499]             {
[13:20:29.499]                 {
[13:20:29.499]                   {
[13:20:29.499]                     {
[13:20:29.499]                       base::local({
[13:20:29.499]                         has_future <- base::requireNamespace("future", 
[13:20:29.499]                           quietly = TRUE)
[13:20:29.499]                         if (has_future) {
[13:20:29.499]                           ns <- base::getNamespace("future")
[13:20:29.499]                           version <- ns[[".package"]][["version"]]
[13:20:29.499]                           if (is.null(version)) 
[13:20:29.499]                             version <- utils::packageVersion("future")
[13:20:29.499]                         }
[13:20:29.499]                         else {
[13:20:29.499]                           version <- NULL
[13:20:29.499]                         }
[13:20:29.499]                         if (!has_future || version < "1.8.0") {
[13:20:29.499]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.499]                             "", base::R.version$version.string), 
[13:20:29.499]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.499]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.499]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.499]                               "release", "version")], collapse = " "), 
[13:20:29.499]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.499]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.499]                             info)
[13:20:29.499]                           info <- base::paste(info, collapse = "; ")
[13:20:29.499]                           if (!has_future) {
[13:20:29.499]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.499]                               info)
[13:20:29.499]                           }
[13:20:29.499]                           else {
[13:20:29.499]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.499]                               info, version)
[13:20:29.499]                           }
[13:20:29.499]                           base::stop(msg)
[13:20:29.499]                         }
[13:20:29.499]                       })
[13:20:29.499]                     }
[13:20:29.499]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.499]                     base::options(mc.cores = 1L)
[13:20:29.499]                   }
[13:20:29.499]                   options(future.plan = NULL)
[13:20:29.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.499]                 }
[13:20:29.499]                 ...future.workdir <- getwd()
[13:20:29.499]             }
[13:20:29.499]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.499]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.499]         }
[13:20:29.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.499]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.499]             base::names(...future.oldOptions))
[13:20:29.499]     }
[13:20:29.499]     if (FALSE) {
[13:20:29.499]     }
[13:20:29.499]     else {
[13:20:29.499]         if (TRUE) {
[13:20:29.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.499]                 open = "w")
[13:20:29.499]         }
[13:20:29.499]         else {
[13:20:29.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.499]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.499]         }
[13:20:29.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.499]             base::sink(type = "output", split = FALSE)
[13:20:29.499]             base::close(...future.stdout)
[13:20:29.499]         }, add = TRUE)
[13:20:29.499]     }
[13:20:29.499]     ...future.frame <- base::sys.nframe()
[13:20:29.499]     ...future.conditions <- base::list()
[13:20:29.499]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.499]     if (FALSE) {
[13:20:29.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.499]     }
[13:20:29.499]     ...future.result <- base::tryCatch({
[13:20:29.499]         base::withCallingHandlers({
[13:20:29.499]             ...future.value <- base::withVisible(base::local({
[13:20:29.499]                 withCallingHandlers({
[13:20:29.499]                   NULL
[13:20:29.499]                 }, immediateCondition = function(cond) {
[13:20:29.499]                   save_rds <- function (object, pathname, ...) 
[13:20:29.499]                   {
[13:20:29.499]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.499]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.499]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.499]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.499]                         fi_tmp[["mtime"]])
[13:20:29.499]                     }
[13:20:29.499]                     tryCatch({
[13:20:29.499]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.499]                     }, error = function(ex) {
[13:20:29.499]                       msg <- conditionMessage(ex)
[13:20:29.499]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.499]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.499]                         fi_tmp[["mtime"]], msg)
[13:20:29.499]                       ex$message <- msg
[13:20:29.499]                       stop(ex)
[13:20:29.499]                     })
[13:20:29.499]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.499]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.499]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.499]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.499]                       fi <- file.info(pathname)
[13:20:29.499]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.499]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.499]                         fi[["size"]], fi[["mtime"]])
[13:20:29.499]                       stop(msg)
[13:20:29.499]                     }
[13:20:29.499]                     invisible(pathname)
[13:20:29.499]                   }
[13:20:29.499]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.499]                     rootPath = tempdir()) 
[13:20:29.499]                   {
[13:20:29.499]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.499]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.499]                       tmpdir = path, fileext = ".rds")
[13:20:29.499]                     save_rds(obj, file)
[13:20:29.499]                   }
[13:20:29.499]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.499]                   {
[13:20:29.499]                     inherits <- base::inherits
[13:20:29.499]                     invokeRestart <- base::invokeRestart
[13:20:29.499]                     is.null <- base::is.null
[13:20:29.499]                     muffled <- FALSE
[13:20:29.499]                     if (inherits(cond, "message")) {
[13:20:29.499]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.499]                       if (muffled) 
[13:20:29.499]                         invokeRestart("muffleMessage")
[13:20:29.499]                     }
[13:20:29.499]                     else if (inherits(cond, "warning")) {
[13:20:29.499]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.499]                       if (muffled) 
[13:20:29.499]                         invokeRestart("muffleWarning")
[13:20:29.499]                     }
[13:20:29.499]                     else if (inherits(cond, "condition")) {
[13:20:29.499]                       if (!is.null(pattern)) {
[13:20:29.499]                         computeRestarts <- base::computeRestarts
[13:20:29.499]                         grepl <- base::grepl
[13:20:29.499]                         restarts <- computeRestarts(cond)
[13:20:29.499]                         for (restart in restarts) {
[13:20:29.499]                           name <- restart$name
[13:20:29.499]                           if (is.null(name)) 
[13:20:29.499]                             next
[13:20:29.499]                           if (!grepl(pattern, name)) 
[13:20:29.499]                             next
[13:20:29.499]                           invokeRestart(restart)
[13:20:29.499]                           muffled <- TRUE
[13:20:29.499]                           break
[13:20:29.499]                         }
[13:20:29.499]                       }
[13:20:29.499]                     }
[13:20:29.499]                     invisible(muffled)
[13:20:29.499]                   }
[13:20:29.499]                   muffleCondition(cond)
[13:20:29.499]                 })
[13:20:29.499]             }))
[13:20:29.499]             future::FutureResult(value = ...future.value$value, 
[13:20:29.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.499]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.499]                     ...future.globalenv.names))
[13:20:29.499]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.499]         }, condition = base::local({
[13:20:29.499]             c <- base::c
[13:20:29.499]             inherits <- base::inherits
[13:20:29.499]             invokeRestart <- base::invokeRestart
[13:20:29.499]             length <- base::length
[13:20:29.499]             list <- base::list
[13:20:29.499]             seq.int <- base::seq.int
[13:20:29.499]             signalCondition <- base::signalCondition
[13:20:29.499]             sys.calls <- base::sys.calls
[13:20:29.499]             `[[` <- base::`[[`
[13:20:29.499]             `+` <- base::`+`
[13:20:29.499]             `<<-` <- base::`<<-`
[13:20:29.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.499]                   3L)]
[13:20:29.499]             }
[13:20:29.499]             function(cond) {
[13:20:29.499]                 is_error <- inherits(cond, "error")
[13:20:29.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.499]                   NULL)
[13:20:29.499]                 if (is_error) {
[13:20:29.499]                   sessionInformation <- function() {
[13:20:29.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.499]                       search = base::search(), system = base::Sys.info())
[13:20:29.499]                   }
[13:20:29.499]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.499]                     cond$call), session = sessionInformation(), 
[13:20:29.499]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.499]                   signalCondition(cond)
[13:20:29.499]                 }
[13:20:29.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.499]                 "immediateCondition"))) {
[13:20:29.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.499]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.499]                   if (TRUE && !signal) {
[13:20:29.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.499]                     {
[13:20:29.499]                       inherits <- base::inherits
[13:20:29.499]                       invokeRestart <- base::invokeRestart
[13:20:29.499]                       is.null <- base::is.null
[13:20:29.499]                       muffled <- FALSE
[13:20:29.499]                       if (inherits(cond, "message")) {
[13:20:29.499]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.499]                         if (muffled) 
[13:20:29.499]                           invokeRestart("muffleMessage")
[13:20:29.499]                       }
[13:20:29.499]                       else if (inherits(cond, "warning")) {
[13:20:29.499]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.499]                         if (muffled) 
[13:20:29.499]                           invokeRestart("muffleWarning")
[13:20:29.499]                       }
[13:20:29.499]                       else if (inherits(cond, "condition")) {
[13:20:29.499]                         if (!is.null(pattern)) {
[13:20:29.499]                           computeRestarts <- base::computeRestarts
[13:20:29.499]                           grepl <- base::grepl
[13:20:29.499]                           restarts <- computeRestarts(cond)
[13:20:29.499]                           for (restart in restarts) {
[13:20:29.499]                             name <- restart$name
[13:20:29.499]                             if (is.null(name)) 
[13:20:29.499]                               next
[13:20:29.499]                             if (!grepl(pattern, name)) 
[13:20:29.499]                               next
[13:20:29.499]                             invokeRestart(restart)
[13:20:29.499]                             muffled <- TRUE
[13:20:29.499]                             break
[13:20:29.499]                           }
[13:20:29.499]                         }
[13:20:29.499]                       }
[13:20:29.499]                       invisible(muffled)
[13:20:29.499]                     }
[13:20:29.499]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.499]                   }
[13:20:29.499]                 }
[13:20:29.499]                 else {
[13:20:29.499]                   if (TRUE) {
[13:20:29.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.499]                     {
[13:20:29.499]                       inherits <- base::inherits
[13:20:29.499]                       invokeRestart <- base::invokeRestart
[13:20:29.499]                       is.null <- base::is.null
[13:20:29.499]                       muffled <- FALSE
[13:20:29.499]                       if (inherits(cond, "message")) {
[13:20:29.499]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.499]                         if (muffled) 
[13:20:29.499]                           invokeRestart("muffleMessage")
[13:20:29.499]                       }
[13:20:29.499]                       else if (inherits(cond, "warning")) {
[13:20:29.499]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.499]                         if (muffled) 
[13:20:29.499]                           invokeRestart("muffleWarning")
[13:20:29.499]                       }
[13:20:29.499]                       else if (inherits(cond, "condition")) {
[13:20:29.499]                         if (!is.null(pattern)) {
[13:20:29.499]                           computeRestarts <- base::computeRestarts
[13:20:29.499]                           grepl <- base::grepl
[13:20:29.499]                           restarts <- computeRestarts(cond)
[13:20:29.499]                           for (restart in restarts) {
[13:20:29.499]                             name <- restart$name
[13:20:29.499]                             if (is.null(name)) 
[13:20:29.499]                               next
[13:20:29.499]                             if (!grepl(pattern, name)) 
[13:20:29.499]                               next
[13:20:29.499]                             invokeRestart(restart)
[13:20:29.499]                             muffled <- TRUE
[13:20:29.499]                             break
[13:20:29.499]                           }
[13:20:29.499]                         }
[13:20:29.499]                       }
[13:20:29.499]                       invisible(muffled)
[13:20:29.499]                     }
[13:20:29.499]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.499]                   }
[13:20:29.499]                 }
[13:20:29.499]             }
[13:20:29.499]         }))
[13:20:29.499]     }, error = function(ex) {
[13:20:29.499]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.499]                 ...future.rng), started = ...future.startTime, 
[13:20:29.499]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.499]             version = "1.8"), class = "FutureResult")
[13:20:29.499]     }, finally = {
[13:20:29.499]         if (!identical(...future.workdir, getwd())) 
[13:20:29.499]             setwd(...future.workdir)
[13:20:29.499]         {
[13:20:29.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.499]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.499]             }
[13:20:29.499]             base::options(...future.oldOptions)
[13:20:29.499]             if (.Platform$OS.type == "windows") {
[13:20:29.499]                 old_names <- names(...future.oldEnvVars)
[13:20:29.499]                 envs <- base::Sys.getenv()
[13:20:29.499]                 names <- names(envs)
[13:20:29.499]                 common <- intersect(names, old_names)
[13:20:29.499]                 added <- setdiff(names, old_names)
[13:20:29.499]                 removed <- setdiff(old_names, names)
[13:20:29.499]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.499]                   envs[common]]
[13:20:29.499]                 NAMES <- toupper(changed)
[13:20:29.499]                 args <- list()
[13:20:29.499]                 for (kk in seq_along(NAMES)) {
[13:20:29.499]                   name <- changed[[kk]]
[13:20:29.499]                   NAME <- NAMES[[kk]]
[13:20:29.499]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.499]                     next
[13:20:29.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.499]                 }
[13:20:29.499]                 NAMES <- toupper(added)
[13:20:29.499]                 for (kk in seq_along(NAMES)) {
[13:20:29.499]                   name <- added[[kk]]
[13:20:29.499]                   NAME <- NAMES[[kk]]
[13:20:29.499]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.499]                     next
[13:20:29.499]                   args[[name]] <- ""
[13:20:29.499]                 }
[13:20:29.499]                 NAMES <- toupper(removed)
[13:20:29.499]                 for (kk in seq_along(NAMES)) {
[13:20:29.499]                   name <- removed[[kk]]
[13:20:29.499]                   NAME <- NAMES[[kk]]
[13:20:29.499]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.499]                     next
[13:20:29.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.499]                 }
[13:20:29.499]                 if (length(args) > 0) 
[13:20:29.499]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.499]             }
[13:20:29.499]             else {
[13:20:29.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.499]             }
[13:20:29.499]             {
[13:20:29.499]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.499]                   0L) {
[13:20:29.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.499]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.499]                   base::options(opts)
[13:20:29.499]                 }
[13:20:29.499]                 {
[13:20:29.499]                   {
[13:20:29.499]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.499]                     NULL
[13:20:29.499]                   }
[13:20:29.499]                   options(future.plan = NULL)
[13:20:29.499]                   if (is.na(NA_character_)) 
[13:20:29.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.499]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.499]                     envir = parent.frame()) 
[13:20:29.499]                   {
[13:20:29.499]                     default_workers <- missing(workers)
[13:20:29.499]                     if (is.function(workers)) 
[13:20:29.499]                       workers <- workers()
[13:20:29.499]                     workers <- structure(as.integer(workers), 
[13:20:29.499]                       class = class(workers))
[13:20:29.499]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.499]                       1L)
[13:20:29.499]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.499]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.499]                       if (default_workers) 
[13:20:29.499]                         supportsMulticore(warn = TRUE)
[13:20:29.499]                       return(sequential(..., envir = envir))
[13:20:29.499]                     }
[13:20:29.499]                     oopts <- options(mc.cores = workers)
[13:20:29.499]                     on.exit(options(oopts))
[13:20:29.499]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.499]                       envir = envir)
[13:20:29.499]                     if (!future$lazy) 
[13:20:29.499]                       future <- run(future)
[13:20:29.499]                     invisible(future)
[13:20:29.499]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.499]                 }
[13:20:29.499]             }
[13:20:29.499]         }
[13:20:29.499]     })
[13:20:29.499]     if (TRUE) {
[13:20:29.499]         base::sink(type = "output", split = FALSE)
[13:20:29.499]         if (TRUE) {
[13:20:29.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.499]         }
[13:20:29.499]         else {
[13:20:29.499]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.499]         }
[13:20:29.499]         base::close(...future.stdout)
[13:20:29.499]         ...future.stdout <- NULL
[13:20:29.499]     }
[13:20:29.499]     ...future.result$conditions <- ...future.conditions
[13:20:29.499]     ...future.result$finished <- base::Sys.time()
[13:20:29.499]     ...future.result
[13:20:29.499] }
[13:20:29.503] requestCore(): workers = 2
[13:20:29.506] MulticoreFuture started
[13:20:29.507] - Launch lazy future ... done
[13:20:29.507] run() for ‘MulticoreFuture’ ... done
[13:20:29.507] plan(): Setting new future strategy stack:
[13:20:29.508] getGlobalsAndPackages() ...
[13:20:29.508] Searching for globals...
[13:20:29.508] List of future strategies:
[13:20:29.508] 1. sequential:
[13:20:29.508]    - args: function (..., envir = parent.frame())
[13:20:29.508]    - tweaked: FALSE
[13:20:29.508]    - call: NULL
[13:20:29.509] plan(): nbrOfWorkers() = 1
[13:20:29.510] - globals found: [1] ‘{’
[13:20:29.510] Searching for globals ... DONE
[13:20:29.510] Resolving globals: FALSE
[13:20:29.511] 
[13:20:29.511] 
[13:20:29.511] getGlobalsAndPackages() ... DONE
[13:20:29.511] plan(): Setting new future strategy stack:
[13:20:29.512] run() for ‘Future’ ...
[13:20:29.511] List of future strategies:
[13:20:29.511] 1. multicore:
[13:20:29.511]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.511]    - tweaked: FALSE
[13:20:29.511]    - call: plan(strategy)
[13:20:29.512] - state: ‘created’
[13:20:29.512] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:29.517] plan(): nbrOfWorkers() = 2
[13:20:29.517] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:29.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:29.518]   - Field: ‘label’
[13:20:29.518]   - Field: ‘local’
[13:20:29.518]   - Field: ‘owner’
[13:20:29.518]   - Field: ‘envir’
[13:20:29.518]   - Field: ‘workers’
[13:20:29.518]   - Field: ‘packages’
[13:20:29.519]   - Field: ‘gc’
[13:20:29.519]   - Field: ‘job’
[13:20:29.519]   - Field: ‘conditions’
[13:20:29.519]   - Field: ‘expr’
[13:20:29.519]   - Field: ‘uuid’
[13:20:29.519]   - Field: ‘seed’
[13:20:29.519]   - Field: ‘version’
[13:20:29.520]   - Field: ‘result’
[13:20:29.520]   - Field: ‘asynchronous’
[13:20:29.520]   - Field: ‘calls’
[13:20:29.520]   - Field: ‘globals’
[13:20:29.520]   - Field: ‘stdout’
[13:20:29.520]   - Field: ‘earlySignal’
[13:20:29.520]   - Field: ‘lazy’
[13:20:29.521]   - Field: ‘state’
[13:20:29.521] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:29.521] - Launch lazy future ...
[13:20:29.521] Packages needed by the future expression (n = 0): <none>
[13:20:29.522] Packages needed by future strategies (n = 0): <none>
[13:20:29.522] {
[13:20:29.522]     {
[13:20:29.522]         {
[13:20:29.522]             ...future.startTime <- base::Sys.time()
[13:20:29.522]             {
[13:20:29.522]                 {
[13:20:29.522]                   {
[13:20:29.522]                     {
[13:20:29.522]                       base::local({
[13:20:29.522]                         has_future <- base::requireNamespace("future", 
[13:20:29.522]                           quietly = TRUE)
[13:20:29.522]                         if (has_future) {
[13:20:29.522]                           ns <- base::getNamespace("future")
[13:20:29.522]                           version <- ns[[".package"]][["version"]]
[13:20:29.522]                           if (is.null(version)) 
[13:20:29.522]                             version <- utils::packageVersion("future")
[13:20:29.522]                         }
[13:20:29.522]                         else {
[13:20:29.522]                           version <- NULL
[13:20:29.522]                         }
[13:20:29.522]                         if (!has_future || version < "1.8.0") {
[13:20:29.522]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.522]                             "", base::R.version$version.string), 
[13:20:29.522]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.522]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.522]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.522]                               "release", "version")], collapse = " "), 
[13:20:29.522]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.522]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.522]                             info)
[13:20:29.522]                           info <- base::paste(info, collapse = "; ")
[13:20:29.522]                           if (!has_future) {
[13:20:29.522]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.522]                               info)
[13:20:29.522]                           }
[13:20:29.522]                           else {
[13:20:29.522]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.522]                               info, version)
[13:20:29.522]                           }
[13:20:29.522]                           base::stop(msg)
[13:20:29.522]                         }
[13:20:29.522]                       })
[13:20:29.522]                     }
[13:20:29.522]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.522]                     base::options(mc.cores = 1L)
[13:20:29.522]                   }
[13:20:29.522]                   options(future.plan = NULL)
[13:20:29.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.522]                 }
[13:20:29.522]                 ...future.workdir <- getwd()
[13:20:29.522]             }
[13:20:29.522]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.522]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.522]         }
[13:20:29.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.522]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.522]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.522]             base::names(...future.oldOptions))
[13:20:29.522]     }
[13:20:29.522]     if (FALSE) {
[13:20:29.522]     }
[13:20:29.522]     else {
[13:20:29.522]         if (TRUE) {
[13:20:29.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.522]                 open = "w")
[13:20:29.522]         }
[13:20:29.522]         else {
[13:20:29.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.522]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.522]         }
[13:20:29.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.522]             base::sink(type = "output", split = FALSE)
[13:20:29.522]             base::close(...future.stdout)
[13:20:29.522]         }, add = TRUE)
[13:20:29.522]     }
[13:20:29.522]     ...future.frame <- base::sys.nframe()
[13:20:29.522]     ...future.conditions <- base::list()
[13:20:29.522]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.522]     if (FALSE) {
[13:20:29.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.522]     }
[13:20:29.522]     ...future.result <- base::tryCatch({
[13:20:29.522]         base::withCallingHandlers({
[13:20:29.522]             ...future.value <- base::withVisible(base::local({
[13:20:29.522]                 withCallingHandlers({
[13:20:29.522]                   {
[13:20:29.522]                     4
[13:20:29.522]                   }
[13:20:29.522]                 }, immediateCondition = function(cond) {
[13:20:29.522]                   save_rds <- function (object, pathname, ...) 
[13:20:29.522]                   {
[13:20:29.522]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:29.522]                     if (file_test("-f", pathname_tmp)) {
[13:20:29.522]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.522]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:29.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.522]                         fi_tmp[["mtime"]])
[13:20:29.522]                     }
[13:20:29.522]                     tryCatch({
[13:20:29.522]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:29.522]                     }, error = function(ex) {
[13:20:29.522]                       msg <- conditionMessage(ex)
[13:20:29.522]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.522]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:29.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.522]                         fi_tmp[["mtime"]], msg)
[13:20:29.522]                       ex$message <- msg
[13:20:29.522]                       stop(ex)
[13:20:29.522]                     })
[13:20:29.522]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:29.522]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:29.522]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:29.522]                       fi_tmp <- file.info(pathname_tmp)
[13:20:29.522]                       fi <- file.info(pathname)
[13:20:29.522]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:29.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:29.522]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:29.522]                         fi[["size"]], fi[["mtime"]])
[13:20:29.522]                       stop(msg)
[13:20:29.522]                     }
[13:20:29.522]                     invisible(pathname)
[13:20:29.522]                   }
[13:20:29.522]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:29.522]                     rootPath = tempdir()) 
[13:20:29.522]                   {
[13:20:29.522]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:29.522]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:29.522]                       tmpdir = path, fileext = ".rds")
[13:20:29.522]                     save_rds(obj, file)
[13:20:29.522]                   }
[13:20:29.522]                   saveImmediateCondition(cond, path = "/tmp/RtmpXOy31R/.future/immediateConditions")
[13:20:29.522]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.522]                   {
[13:20:29.522]                     inherits <- base::inherits
[13:20:29.522]                     invokeRestart <- base::invokeRestart
[13:20:29.522]                     is.null <- base::is.null
[13:20:29.522]                     muffled <- FALSE
[13:20:29.522]                     if (inherits(cond, "message")) {
[13:20:29.522]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.522]                       if (muffled) 
[13:20:29.522]                         invokeRestart("muffleMessage")
[13:20:29.522]                     }
[13:20:29.522]                     else if (inherits(cond, "warning")) {
[13:20:29.522]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.522]                       if (muffled) 
[13:20:29.522]                         invokeRestart("muffleWarning")
[13:20:29.522]                     }
[13:20:29.522]                     else if (inherits(cond, "condition")) {
[13:20:29.522]                       if (!is.null(pattern)) {
[13:20:29.522]                         computeRestarts <- base::computeRestarts
[13:20:29.522]                         grepl <- base::grepl
[13:20:29.522]                         restarts <- computeRestarts(cond)
[13:20:29.522]                         for (restart in restarts) {
[13:20:29.522]                           name <- restart$name
[13:20:29.522]                           if (is.null(name)) 
[13:20:29.522]                             next
[13:20:29.522]                           if (!grepl(pattern, name)) 
[13:20:29.522]                             next
[13:20:29.522]                           invokeRestart(restart)
[13:20:29.522]                           muffled <- TRUE
[13:20:29.522]                           break
[13:20:29.522]                         }
[13:20:29.522]                       }
[13:20:29.522]                     }
[13:20:29.522]                     invisible(muffled)
[13:20:29.522]                   }
[13:20:29.522]                   muffleCondition(cond)
[13:20:29.522]                 })
[13:20:29.522]             }))
[13:20:29.522]             future::FutureResult(value = ...future.value$value, 
[13:20:29.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.522]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.522]                     ...future.globalenv.names))
[13:20:29.522]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.522]         }, condition = base::local({
[13:20:29.522]             c <- base::c
[13:20:29.522]             inherits <- base::inherits
[13:20:29.522]             invokeRestart <- base::invokeRestart
[13:20:29.522]             length <- base::length
[13:20:29.522]             list <- base::list
[13:20:29.522]             seq.int <- base::seq.int
[13:20:29.522]             signalCondition <- base::signalCondition
[13:20:29.522]             sys.calls <- base::sys.calls
[13:20:29.522]             `[[` <- base::`[[`
[13:20:29.522]             `+` <- base::`+`
[13:20:29.522]             `<<-` <- base::`<<-`
[13:20:29.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.522]                   3L)]
[13:20:29.522]             }
[13:20:29.522]             function(cond) {
[13:20:29.522]                 is_error <- inherits(cond, "error")
[13:20:29.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.522]                   NULL)
[13:20:29.522]                 if (is_error) {
[13:20:29.522]                   sessionInformation <- function() {
[13:20:29.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.522]                       search = base::search(), system = base::Sys.info())
[13:20:29.522]                   }
[13:20:29.522]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.522]                     cond$call), session = sessionInformation(), 
[13:20:29.522]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.522]                   signalCondition(cond)
[13:20:29.522]                 }
[13:20:29.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.522]                 "immediateCondition"))) {
[13:20:29.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.522]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.522]                   if (TRUE && !signal) {
[13:20:29.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.522]                     {
[13:20:29.522]                       inherits <- base::inherits
[13:20:29.522]                       invokeRestart <- base::invokeRestart
[13:20:29.522]                       is.null <- base::is.null
[13:20:29.522]                       muffled <- FALSE
[13:20:29.522]                       if (inherits(cond, "message")) {
[13:20:29.522]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.522]                         if (muffled) 
[13:20:29.522]                           invokeRestart("muffleMessage")
[13:20:29.522]                       }
[13:20:29.522]                       else if (inherits(cond, "warning")) {
[13:20:29.522]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.522]                         if (muffled) 
[13:20:29.522]                           invokeRestart("muffleWarning")
[13:20:29.522]                       }
[13:20:29.522]                       else if (inherits(cond, "condition")) {
[13:20:29.522]                         if (!is.null(pattern)) {
[13:20:29.522]                           computeRestarts <- base::computeRestarts
[13:20:29.522]                           grepl <- base::grepl
[13:20:29.522]                           restarts <- computeRestarts(cond)
[13:20:29.522]                           for (restart in restarts) {
[13:20:29.522]                             name <- restart$name
[13:20:29.522]                             if (is.null(name)) 
[13:20:29.522]                               next
[13:20:29.522]                             if (!grepl(pattern, name)) 
[13:20:29.522]                               next
[13:20:29.522]                             invokeRestart(restart)
[13:20:29.522]                             muffled <- TRUE
[13:20:29.522]                             break
[13:20:29.522]                           }
[13:20:29.522]                         }
[13:20:29.522]                       }
[13:20:29.522]                       invisible(muffled)
[13:20:29.522]                     }
[13:20:29.522]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.522]                   }
[13:20:29.522]                 }
[13:20:29.522]                 else {
[13:20:29.522]                   if (TRUE) {
[13:20:29.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.522]                     {
[13:20:29.522]                       inherits <- base::inherits
[13:20:29.522]                       invokeRestart <- base::invokeRestart
[13:20:29.522]                       is.null <- base::is.null
[13:20:29.522]                       muffled <- FALSE
[13:20:29.522]                       if (inherits(cond, "message")) {
[13:20:29.522]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.522]                         if (muffled) 
[13:20:29.522]                           invokeRestart("muffleMessage")
[13:20:29.522]                       }
[13:20:29.522]                       else if (inherits(cond, "warning")) {
[13:20:29.522]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.522]                         if (muffled) 
[13:20:29.522]                           invokeRestart("muffleWarning")
[13:20:29.522]                       }
[13:20:29.522]                       else if (inherits(cond, "condition")) {
[13:20:29.522]                         if (!is.null(pattern)) {
[13:20:29.522]                           computeRestarts <- base::computeRestarts
[13:20:29.522]                           grepl <- base::grepl
[13:20:29.522]                           restarts <- computeRestarts(cond)
[13:20:29.522]                           for (restart in restarts) {
[13:20:29.522]                             name <- restart$name
[13:20:29.522]                             if (is.null(name)) 
[13:20:29.522]                               next
[13:20:29.522]                             if (!grepl(pattern, name)) 
[13:20:29.522]                               next
[13:20:29.522]                             invokeRestart(restart)
[13:20:29.522]                             muffled <- TRUE
[13:20:29.522]                             break
[13:20:29.522]                           }
[13:20:29.522]                         }
[13:20:29.522]                       }
[13:20:29.522]                       invisible(muffled)
[13:20:29.522]                     }
[13:20:29.522]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.522]                   }
[13:20:29.522]                 }
[13:20:29.522]             }
[13:20:29.522]         }))
[13:20:29.522]     }, error = function(ex) {
[13:20:29.522]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.522]                 ...future.rng), started = ...future.startTime, 
[13:20:29.522]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.522]             version = "1.8"), class = "FutureResult")
[13:20:29.522]     }, finally = {
[13:20:29.522]         if (!identical(...future.workdir, getwd())) 
[13:20:29.522]             setwd(...future.workdir)
[13:20:29.522]         {
[13:20:29.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.522]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.522]             }
[13:20:29.522]             base::options(...future.oldOptions)
[13:20:29.522]             if (.Platform$OS.type == "windows") {
[13:20:29.522]                 old_names <- names(...future.oldEnvVars)
[13:20:29.522]                 envs <- base::Sys.getenv()
[13:20:29.522]                 names <- names(envs)
[13:20:29.522]                 common <- intersect(names, old_names)
[13:20:29.522]                 added <- setdiff(names, old_names)
[13:20:29.522]                 removed <- setdiff(old_names, names)
[13:20:29.522]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.522]                   envs[common]]
[13:20:29.522]                 NAMES <- toupper(changed)
[13:20:29.522]                 args <- list()
[13:20:29.522]                 for (kk in seq_along(NAMES)) {
[13:20:29.522]                   name <- changed[[kk]]
[13:20:29.522]                   NAME <- NAMES[[kk]]
[13:20:29.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.522]                     next
[13:20:29.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.522]                 }
[13:20:29.522]                 NAMES <- toupper(added)
[13:20:29.522]                 for (kk in seq_along(NAMES)) {
[13:20:29.522]                   name <- added[[kk]]
[13:20:29.522]                   NAME <- NAMES[[kk]]
[13:20:29.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.522]                     next
[13:20:29.522]                   args[[name]] <- ""
[13:20:29.522]                 }
[13:20:29.522]                 NAMES <- toupper(removed)
[13:20:29.522]                 for (kk in seq_along(NAMES)) {
[13:20:29.522]                   name <- removed[[kk]]
[13:20:29.522]                   NAME <- NAMES[[kk]]
[13:20:29.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.522]                     next
[13:20:29.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.522]                 }
[13:20:29.522]                 if (length(args) > 0) 
[13:20:29.522]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.522]             }
[13:20:29.522]             else {
[13:20:29.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.522]             }
[13:20:29.522]             {
[13:20:29.522]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.522]                   0L) {
[13:20:29.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.522]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.522]                   base::options(opts)
[13:20:29.522]                 }
[13:20:29.522]                 {
[13:20:29.522]                   {
[13:20:29.522]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.522]                     NULL
[13:20:29.522]                   }
[13:20:29.522]                   options(future.plan = NULL)
[13:20:29.522]                   if (is.na(NA_character_)) 
[13:20:29.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.522]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:29.522]                     envir = parent.frame()) 
[13:20:29.522]                   {
[13:20:29.522]                     default_workers <- missing(workers)
[13:20:29.522]                     if (is.function(workers)) 
[13:20:29.522]                       workers <- workers()
[13:20:29.522]                     workers <- structure(as.integer(workers), 
[13:20:29.522]                       class = class(workers))
[13:20:29.522]                     stop_if_not(is.finite(workers), workers >= 
[13:20:29.522]                       1L)
[13:20:29.522]                     if ((workers == 1L && !inherits(workers, 
[13:20:29.522]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:29.522]                       if (default_workers) 
[13:20:29.522]                         supportsMulticore(warn = TRUE)
[13:20:29.522]                       return(sequential(..., envir = envir))
[13:20:29.522]                     }
[13:20:29.522]                     oopts <- options(mc.cores = workers)
[13:20:29.522]                     on.exit(options(oopts))
[13:20:29.522]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:29.522]                       envir = envir)
[13:20:29.522]                     if (!future$lazy) 
[13:20:29.522]                       future <- run(future)
[13:20:29.522]                     invisible(future)
[13:20:29.522]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.522]                 }
[13:20:29.522]             }
[13:20:29.522]         }
[13:20:29.522]     })
[13:20:29.522]     if (TRUE) {
[13:20:29.522]         base::sink(type = "output", split = FALSE)
[13:20:29.522]         if (TRUE) {
[13:20:29.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.522]         }
[13:20:29.522]         else {
[13:20:29.522]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.522]         }
[13:20:29.522]         base::close(...future.stdout)
[13:20:29.522]         ...future.stdout <- NULL
[13:20:29.522]     }
[13:20:29.522]     ...future.result$conditions <- ...future.conditions
[13:20:29.522]     ...future.result$finished <- base::Sys.time()
[13:20:29.522]     ...future.result
[13:20:29.522] }
[13:20:29.526] requestCore(): workers = 2
[13:20:29.527] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:29.541] MulticoreFuture started
[13:20:29.542] - Launch lazy future ... done
[13:20:29.542] run() for ‘MulticoreFuture’ ... done
[13:20:29.543] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55659da2c580> 
[13:20:29.543] List of future strategies:
[13:20:29.543] 1. sequential:
[13:20:29.543]    - args: function (..., envir = parent.frame())
[13:20:29.543]    - tweaked: FALSE
[13:20:29.543]    - call: NULL
[13:20:29.544] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55659b48c688> 
 - attr(*, "dim.")=[13:20:29.547] plan(): Setting new future strategy stack:
 int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=[13:20:29.547] List of future strategies:
[13:20:29.547] 1. multicore:
[13:20:29.547]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:29.547]    - tweaked: FALSE
[13:20:29.547]    - call: plan(strategy)
List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:20:29.555] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:29.560] resolve() on list environment ...
[13:20:29.560]  recursive: 0
[13:20:29.562]  length: 6
[13:20:29.562]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:29.562] signalConditionsASAP(numeric, pos=1) ...
[13:20:29.563] - nx: 6
[13:20:29.563] - relay: TRUE
[13:20:29.563] - stdout: TRUE
[13:20:29.563] - signal: TRUE
[13:20:29.563] - resignal: FALSE
[13:20:29.563] - force: TRUE
[13:20:29.563] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.564] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.564]  - until=2
[13:20:29.564]  - relaying element #2
[13:20:29.564] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.564] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.564] signalConditionsASAP(NULL, pos=1) ... done
[13:20:29.564]  length: 5 (resolved future 1)
[13:20:29.565] Future #2
[13:20:29.565] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:29.565] - nx: 6
[13:20:29.565] - relay: TRUE
[13:20:29.565] - stdout: TRUE
[13:20:29.565] - signal: TRUE
[13:20:29.566] - resignal: FALSE
[13:20:29.566] - force: TRUE
[13:20:29.566] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.566] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:29.566]  - until=2
[13:20:29.566]  - relaying element #2
[13:20:29.566] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.567] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.567] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:29.567]  length: 4 (resolved future 2)
[13:20:29.567] Future #3
[13:20:29.568] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:20:29.568] - nx: 6
[13:20:29.569] - relay: TRUE
[13:20:29.569] - stdout: TRUE
[13:20:29.569] - signal: TRUE
[13:20:29.569] - resignal: FALSE
[13:20:29.569] - force: TRUE
[13:20:29.569] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.569] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:29.570]  - until=3
[13:20:29.570]  - relaying element #3
[13:20:29.570] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.570] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.570] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:20:29.570]  length: 3 (resolved future 3)
[13:20:29.571] Future #4
[13:20:29.572] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:20:29.572] - nx: 6
[13:20:29.572] - relay: TRUE
[13:20:29.572] - stdout: TRUE
[13:20:29.572] - signal: TRUE
[13:20:29.572] - resignal: FALSE
[13:20:29.573] - force: TRUE
[13:20:29.573] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.573] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:29.573]  - until=4
[13:20:29.573]  - relaying element #4
[13:20:29.574] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.574] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.574] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:20:29.574]  length: 2 (resolved future 4)
[13:20:29.574] signalConditionsASAP(NULL, pos=5) ...
[13:20:29.575] - nx: 6
[13:20:29.575] - relay: TRUE
[13:20:29.575] - stdout: TRUE
[13:20:29.575] - signal: TRUE
[13:20:29.575] - resignal: FALSE
[13:20:29.575] - force: TRUE
[13:20:29.576] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.576] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.576]  - until=6
[13:20:29.576]  - relaying element #6
[13:20:29.576] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:29.576] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.576] signalConditionsASAP(NULL, pos=5) ... done
[13:20:29.576]  length: 1 (resolved future 5)
[13:20:29.576] signalConditionsASAP(numeric, pos=6) ...
[13:20:29.577] - nx: 6
[13:20:29.577] - relay: TRUE
[13:20:29.577] - stdout: TRUE
[13:20:29.577] - signal: TRUE
[13:20:29.577] - resignal: FALSE
[13:20:29.577] - force: TRUE
[13:20:29.577] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:20:29.577] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.577]  - until=6
[13:20:29.577] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.578] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.578] signalConditionsASAP(numeric, pos=6) ... done
[13:20:29.578]  length: 0 (resolved future 6)
[13:20:29.578] Relaying remaining futures
[13:20:29.578] signalConditionsASAP(NULL, pos=0) ...
[13:20:29.578] - nx: 6
[13:20:29.578] - relay: TRUE
[13:20:29.578] - stdout: TRUE
[13:20:29.578] - signal: TRUE
[13:20:29.578] - resignal: FALSE
[13:20:29.579] - force: TRUE
[13:20:29.579] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.579] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:29.579] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:29.579] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:29.579] signalConditionsASAP(NULL, pos=0) ... done
[13:20:29.579] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x556599c0e830> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[13:20:29.582] plan(): Setting new future strategy stack:
[13:20:29.582] List of future strategies:
[13:20:29.582] 1. multisession:
[13:20:29.582]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:29.582]    - tweaked: FALSE
[13:20:29.582]    - call: plan(strategy)
[13:20:29.583] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:20:29.583] multisession:
[13:20:29.583] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:29.583] - tweaked: FALSE
[13:20:29.583] - call: plan(strategy)
[13:20:29.588] getGlobalsAndPackages() ...
[13:20:29.588] Not searching for globals
[13:20:29.588] - globals: [0] <none>
[13:20:29.588] getGlobalsAndPackages() ... DONE
[13:20:29.589] [local output] makeClusterPSOCK() ...
[13:20:29.589] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:20:29.590] [local output] Base port: 11125
[13:20:29.590] [local output] Getting setup options for 2 cluster nodes ...
[13:20:29.590] [local output]  - Node 1 of 2 ...
[13:20:29.590] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:29.591] [local output] Rscript port: 11125

[13:20:29.591] [local output]  - Node 2 of 2 ...
[13:20:29.592] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:29.592] [local output] Rscript port: 11125

[13:20:29.593] [local output] Getting setup options for 2 cluster nodes ... done
[13:20:29.593] [local output]  - Parallel setup requested for some PSOCK nodes
[13:20:29.593] [local output] Setting up PSOCK nodes in parallel
[13:20:29.593] List of 36
[13:20:29.593]  $ worker          : chr "localhost"
[13:20:29.593]   ..- attr(*, "localhost")= logi TRUE
[13:20:29.593]  $ master          : chr "localhost"
[13:20:29.593]  $ port            : int 11125
[13:20:29.593]  $ connectTimeout  : num 120
[13:20:29.593]  $ timeout         : num 2592000
[13:20:29.593]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:20:29.593]  $ homogeneous     : logi TRUE
[13:20:29.593]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:20:29.593]  $ rscript_envs    : NULL
[13:20:29.593]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:29.593]  $ rscript_startup : NULL
[13:20:29.593]  $ rscript_sh      : chr "sh"
[13:20:29.593]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:29.593]  $ methods         : logi TRUE
[13:20:29.593]  $ socketOptions   : chr "no-delay"
[13:20:29.593]  $ useXDR          : logi FALSE
[13:20:29.593]  $ outfile         : chr "/dev/null"
[13:20:29.593]  $ renice          : int NA
[13:20:29.593]  $ rshcmd          : NULL
[13:20:29.593]  $ user            : chr(0) 
[13:20:29.593]  $ revtunnel       : logi FALSE
[13:20:29.593]  $ rshlogfile      : NULL
[13:20:29.593]  $ rshopts         : chr(0) 
[13:20:29.593]  $ rank            : int 1
[13:20:29.593]  $ manual          : logi FALSE
[13:20:29.593]  $ dryrun          : logi FALSE
[13:20:29.593]  $ quiet           : logi FALSE
[13:20:29.593]  $ setup_strategy  : chr "parallel"
[13:20:29.593]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:29.593]  $ pidfile         : chr "/tmp/RtmpXOy31R/worker.rank=1.parallelly.parent=84392.149a822112369.pid"
[13:20:29.593]  $ rshcmd_label    : NULL
[13:20:29.593]  $ rsh_call        : NULL
[13:20:29.593]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:29.593]  $ localMachine    : logi TRUE
[13:20:29.593]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:20:29.593]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:20:29.593]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:20:29.593]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:20:29.593]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:20:29.593]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:20:29.593]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:20:29.593]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:20:29.593]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:20:29.593]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:20:29.593]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:20:29.593]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:20:29.593]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:20:29.593]  $ arguments       :List of 28
[13:20:29.593]   ..$ worker          : chr "localhost"
[13:20:29.593]   ..$ master          : NULL
[13:20:29.593]   ..$ port            : int 11125
[13:20:29.593]   ..$ connectTimeout  : num 120
[13:20:29.593]   ..$ timeout         : num 2592000
[13:20:29.593]   ..$ rscript         : NULL
[13:20:29.593]   ..$ homogeneous     : NULL
[13:20:29.593]   ..$ rscript_args    : NULL
[13:20:29.593]   ..$ rscript_envs    : NULL
[13:20:29.593]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:29.593]   ..$ rscript_startup : NULL
[13:20:29.593]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:20:29.593]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:29.593]   ..$ methods         : logi TRUE
[13:20:29.593]   ..$ socketOptions   : chr "no-delay"
[13:20:29.593]   ..$ useXDR          : logi FALSE
[13:20:29.593]   ..$ outfile         : chr "/dev/null"
[13:20:29.593]   ..$ renice          : int NA
[13:20:29.593]   ..$ rshcmd          : NULL
[13:20:29.593]   ..$ user            : NULL
[13:20:29.593]   ..$ revtunnel       : logi NA
[13:20:29.593]   ..$ rshlogfile      : NULL
[13:20:29.593]   ..$ rshopts         : NULL
[13:20:29.593]   ..$ rank            : int 1
[13:20:29.593]   ..$ manual          : logi FALSE
[13:20:29.593]   ..$ dryrun          : logi FALSE
[13:20:29.593]   ..$ quiet           : logi FALSE
[13:20:29.593]   ..$ setup_strategy  : chr "parallel"
[13:20:29.593]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:20:29.617] [local output] System call to launch all workers:
[13:20:29.617] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpXOy31R/worker.rank=1.parallelly.parent=84392.149a822112369.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11125 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:20:29.617] [local output] Starting PSOCK main server
[13:20:29.618] [local output] Workers launched
[13:20:29.619] [local output] Waiting for workers to connect back
[13:20:29.619]  - [local output] 0 workers out of 2 ready
[13:20:29.867]  - [local output] 0 workers out of 2 ready
[13:20:29.868]  - [local output] 1 workers out of 2 ready
[13:20:29.868]  - [local output] 2 workers out of 2 ready
[13:20:29.868] [local output] Launching of workers completed
[13:20:29.868] [local output] Collecting session information from workers
[13:20:29.869] [local output]  - Worker #1 of 2
[13:20:29.870] [local output]  - Worker #2 of 2
[13:20:29.870] [local output] makeClusterPSOCK() ... done
[13:20:29.882] Packages needed by the future expression (n = 0): <none>
[13:20:29.882] Packages needed by future strategies (n = 0): <none>
[13:20:29.883] {
[13:20:29.883]     {
[13:20:29.883]         {
[13:20:29.883]             ...future.startTime <- base::Sys.time()
[13:20:29.883]             {
[13:20:29.883]                 {
[13:20:29.883]                   {
[13:20:29.883]                     {
[13:20:29.883]                       base::local({
[13:20:29.883]                         has_future <- base::requireNamespace("future", 
[13:20:29.883]                           quietly = TRUE)
[13:20:29.883]                         if (has_future) {
[13:20:29.883]                           ns <- base::getNamespace("future")
[13:20:29.883]                           version <- ns[[".package"]][["version"]]
[13:20:29.883]                           if (is.null(version)) 
[13:20:29.883]                             version <- utils::packageVersion("future")
[13:20:29.883]                         }
[13:20:29.883]                         else {
[13:20:29.883]                           version <- NULL
[13:20:29.883]                         }
[13:20:29.883]                         if (!has_future || version < "1.8.0") {
[13:20:29.883]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:29.883]                             "", base::R.version$version.string), 
[13:20:29.883]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:29.883]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:29.883]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:29.883]                               "release", "version")], collapse = " "), 
[13:20:29.883]                             hostname = base::Sys.info()[["nodename"]])
[13:20:29.883]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:29.883]                             info)
[13:20:29.883]                           info <- base::paste(info, collapse = "; ")
[13:20:29.883]                           if (!has_future) {
[13:20:29.883]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:29.883]                               info)
[13:20:29.883]                           }
[13:20:29.883]                           else {
[13:20:29.883]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:29.883]                               info, version)
[13:20:29.883]                           }
[13:20:29.883]                           base::stop(msg)
[13:20:29.883]                         }
[13:20:29.883]                       })
[13:20:29.883]                     }
[13:20:29.883]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:29.883]                     base::options(mc.cores = 1L)
[13:20:29.883]                   }
[13:20:29.883]                   options(future.plan = NULL)
[13:20:29.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:29.883]                 }
[13:20:29.883]                 ...future.workdir <- getwd()
[13:20:29.883]             }
[13:20:29.883]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:29.883]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:29.883]         }
[13:20:29.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:29.883]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:29.883]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:29.883]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:29.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:29.883]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:29.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:29.883]             base::names(...future.oldOptions))
[13:20:29.883]     }
[13:20:29.883]     if (FALSE) {
[13:20:29.883]     }
[13:20:29.883]     else {
[13:20:29.883]         if (TRUE) {
[13:20:29.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:29.883]                 open = "w")
[13:20:29.883]         }
[13:20:29.883]         else {
[13:20:29.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:29.883]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:29.883]         }
[13:20:29.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:29.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:29.883]             base::sink(type = "output", split = FALSE)
[13:20:29.883]             base::close(...future.stdout)
[13:20:29.883]         }, add = TRUE)
[13:20:29.883]     }
[13:20:29.883]     ...future.frame <- base::sys.nframe()
[13:20:29.883]     ...future.conditions <- base::list()
[13:20:29.883]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:29.883]     if (FALSE) {
[13:20:29.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:29.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:29.883]     }
[13:20:29.883]     ...future.result <- base::tryCatch({
[13:20:29.883]         base::withCallingHandlers({
[13:20:29.883]             ...future.value <- base::withVisible(base::local({
[13:20:29.883]                 ...future.makeSendCondition <- local({
[13:20:29.883]                   sendCondition <- NULL
[13:20:29.883]                   function(frame = 1L) {
[13:20:29.883]                     if (is.function(sendCondition)) 
[13:20:29.883]                       return(sendCondition)
[13:20:29.883]                     ns <- getNamespace("parallel")
[13:20:29.883]                     if (exists("sendData", mode = "function", 
[13:20:29.883]                       envir = ns)) {
[13:20:29.883]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:29.883]                         envir = ns)
[13:20:29.883]                       envir <- sys.frame(frame)
[13:20:29.883]                       master <- NULL
[13:20:29.883]                       while (!identical(envir, .GlobalEnv) && 
[13:20:29.883]                         !identical(envir, emptyenv())) {
[13:20:29.883]                         if (exists("master", mode = "list", envir = envir, 
[13:20:29.883]                           inherits = FALSE)) {
[13:20:29.883]                           master <- get("master", mode = "list", 
[13:20:29.883]                             envir = envir, inherits = FALSE)
[13:20:29.883]                           if (inherits(master, c("SOCKnode", 
[13:20:29.883]                             "SOCK0node"))) {
[13:20:29.883]                             sendCondition <<- function(cond) {
[13:20:29.883]                               data <- list(type = "VALUE", value = cond, 
[13:20:29.883]                                 success = TRUE)
[13:20:29.883]                               parallel_sendData(master, data)
[13:20:29.883]                             }
[13:20:29.883]                             return(sendCondition)
[13:20:29.883]                           }
[13:20:29.883]                         }
[13:20:29.883]                         frame <- frame + 1L
[13:20:29.883]                         envir <- sys.frame(frame)
[13:20:29.883]                       }
[13:20:29.883]                     }
[13:20:29.883]                     sendCondition <<- function(cond) NULL
[13:20:29.883]                   }
[13:20:29.883]                 })
[13:20:29.883]                 withCallingHandlers({
[13:20:29.883]                   NA
[13:20:29.883]                 }, immediateCondition = function(cond) {
[13:20:29.883]                   sendCondition <- ...future.makeSendCondition()
[13:20:29.883]                   sendCondition(cond)
[13:20:29.883]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.883]                   {
[13:20:29.883]                     inherits <- base::inherits
[13:20:29.883]                     invokeRestart <- base::invokeRestart
[13:20:29.883]                     is.null <- base::is.null
[13:20:29.883]                     muffled <- FALSE
[13:20:29.883]                     if (inherits(cond, "message")) {
[13:20:29.883]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:29.883]                       if (muffled) 
[13:20:29.883]                         invokeRestart("muffleMessage")
[13:20:29.883]                     }
[13:20:29.883]                     else if (inherits(cond, "warning")) {
[13:20:29.883]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:29.883]                       if (muffled) 
[13:20:29.883]                         invokeRestart("muffleWarning")
[13:20:29.883]                     }
[13:20:29.883]                     else if (inherits(cond, "condition")) {
[13:20:29.883]                       if (!is.null(pattern)) {
[13:20:29.883]                         computeRestarts <- base::computeRestarts
[13:20:29.883]                         grepl <- base::grepl
[13:20:29.883]                         restarts <- computeRestarts(cond)
[13:20:29.883]                         for (restart in restarts) {
[13:20:29.883]                           name <- restart$name
[13:20:29.883]                           if (is.null(name)) 
[13:20:29.883]                             next
[13:20:29.883]                           if (!grepl(pattern, name)) 
[13:20:29.883]                             next
[13:20:29.883]                           invokeRestart(restart)
[13:20:29.883]                           muffled <- TRUE
[13:20:29.883]                           break
[13:20:29.883]                         }
[13:20:29.883]                       }
[13:20:29.883]                     }
[13:20:29.883]                     invisible(muffled)
[13:20:29.883]                   }
[13:20:29.883]                   muffleCondition(cond)
[13:20:29.883]                 })
[13:20:29.883]             }))
[13:20:29.883]             future::FutureResult(value = ...future.value$value, 
[13:20:29.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.883]                   ...future.rng), globalenv = if (FALSE) 
[13:20:29.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:29.883]                     ...future.globalenv.names))
[13:20:29.883]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:29.883]         }, condition = base::local({
[13:20:29.883]             c <- base::c
[13:20:29.883]             inherits <- base::inherits
[13:20:29.883]             invokeRestart <- base::invokeRestart
[13:20:29.883]             length <- base::length
[13:20:29.883]             list <- base::list
[13:20:29.883]             seq.int <- base::seq.int
[13:20:29.883]             signalCondition <- base::signalCondition
[13:20:29.883]             sys.calls <- base::sys.calls
[13:20:29.883]             `[[` <- base::`[[`
[13:20:29.883]             `+` <- base::`+`
[13:20:29.883]             `<<-` <- base::`<<-`
[13:20:29.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:29.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:29.883]                   3L)]
[13:20:29.883]             }
[13:20:29.883]             function(cond) {
[13:20:29.883]                 is_error <- inherits(cond, "error")
[13:20:29.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:29.883]                   NULL)
[13:20:29.883]                 if (is_error) {
[13:20:29.883]                   sessionInformation <- function() {
[13:20:29.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:29.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:29.883]                       search = base::search(), system = base::Sys.info())
[13:20:29.883]                   }
[13:20:29.883]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:29.883]                     cond$call), session = sessionInformation(), 
[13:20:29.883]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:29.883]                   signalCondition(cond)
[13:20:29.883]                 }
[13:20:29.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:29.883]                 "immediateCondition"))) {
[13:20:29.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:29.883]                   ...future.conditions[[length(...future.conditions) + 
[13:20:29.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:29.883]                   if (TRUE && !signal) {
[13:20:29.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.883]                     {
[13:20:29.883]                       inherits <- base::inherits
[13:20:29.883]                       invokeRestart <- base::invokeRestart
[13:20:29.883]                       is.null <- base::is.null
[13:20:29.883]                       muffled <- FALSE
[13:20:29.883]                       if (inherits(cond, "message")) {
[13:20:29.883]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.883]                         if (muffled) 
[13:20:29.883]                           invokeRestart("muffleMessage")
[13:20:29.883]                       }
[13:20:29.883]                       else if (inherits(cond, "warning")) {
[13:20:29.883]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.883]                         if (muffled) 
[13:20:29.883]                           invokeRestart("muffleWarning")
[13:20:29.883]                       }
[13:20:29.883]                       else if (inherits(cond, "condition")) {
[13:20:29.883]                         if (!is.null(pattern)) {
[13:20:29.883]                           computeRestarts <- base::computeRestarts
[13:20:29.883]                           grepl <- base::grepl
[13:20:29.883]                           restarts <- computeRestarts(cond)
[13:20:29.883]                           for (restart in restarts) {
[13:20:29.883]                             name <- restart$name
[13:20:29.883]                             if (is.null(name)) 
[13:20:29.883]                               next
[13:20:29.883]                             if (!grepl(pattern, name)) 
[13:20:29.883]                               next
[13:20:29.883]                             invokeRestart(restart)
[13:20:29.883]                             muffled <- TRUE
[13:20:29.883]                             break
[13:20:29.883]                           }
[13:20:29.883]                         }
[13:20:29.883]                       }
[13:20:29.883]                       invisible(muffled)
[13:20:29.883]                     }
[13:20:29.883]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.883]                   }
[13:20:29.883]                 }
[13:20:29.883]                 else {
[13:20:29.883]                   if (TRUE) {
[13:20:29.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:29.883]                     {
[13:20:29.883]                       inherits <- base::inherits
[13:20:29.883]                       invokeRestart <- base::invokeRestart
[13:20:29.883]                       is.null <- base::is.null
[13:20:29.883]                       muffled <- FALSE
[13:20:29.883]                       if (inherits(cond, "message")) {
[13:20:29.883]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:29.883]                         if (muffled) 
[13:20:29.883]                           invokeRestart("muffleMessage")
[13:20:29.883]                       }
[13:20:29.883]                       else if (inherits(cond, "warning")) {
[13:20:29.883]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:29.883]                         if (muffled) 
[13:20:29.883]                           invokeRestart("muffleWarning")
[13:20:29.883]                       }
[13:20:29.883]                       else if (inherits(cond, "condition")) {
[13:20:29.883]                         if (!is.null(pattern)) {
[13:20:29.883]                           computeRestarts <- base::computeRestarts
[13:20:29.883]                           grepl <- base::grepl
[13:20:29.883]                           restarts <- computeRestarts(cond)
[13:20:29.883]                           for (restart in restarts) {
[13:20:29.883]                             name <- restart$name
[13:20:29.883]                             if (is.null(name)) 
[13:20:29.883]                               next
[13:20:29.883]                             if (!grepl(pattern, name)) 
[13:20:29.883]                               next
[13:20:29.883]                             invokeRestart(restart)
[13:20:29.883]                             muffled <- TRUE
[13:20:29.883]                             break
[13:20:29.883]                           }
[13:20:29.883]                         }
[13:20:29.883]                       }
[13:20:29.883]                       invisible(muffled)
[13:20:29.883]                     }
[13:20:29.883]                     muffleCondition(cond, pattern = "^muffle")
[13:20:29.883]                   }
[13:20:29.883]                 }
[13:20:29.883]             }
[13:20:29.883]         }))
[13:20:29.883]     }, error = function(ex) {
[13:20:29.883]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:29.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:29.883]                 ...future.rng), started = ...future.startTime, 
[13:20:29.883]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:29.883]             version = "1.8"), class = "FutureResult")
[13:20:29.883]     }, finally = {
[13:20:29.883]         if (!identical(...future.workdir, getwd())) 
[13:20:29.883]             setwd(...future.workdir)
[13:20:29.883]         {
[13:20:29.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:29.883]                 ...future.oldOptions$nwarnings <- NULL
[13:20:29.883]             }
[13:20:29.883]             base::options(...future.oldOptions)
[13:20:29.883]             if (.Platform$OS.type == "windows") {
[13:20:29.883]                 old_names <- names(...future.oldEnvVars)
[13:20:29.883]                 envs <- base::Sys.getenv()
[13:20:29.883]                 names <- names(envs)
[13:20:29.883]                 common <- intersect(names, old_names)
[13:20:29.883]                 added <- setdiff(names, old_names)
[13:20:29.883]                 removed <- setdiff(old_names, names)
[13:20:29.883]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:29.883]                   envs[common]]
[13:20:29.883]                 NAMES <- toupper(changed)
[13:20:29.883]                 args <- list()
[13:20:29.883]                 for (kk in seq_along(NAMES)) {
[13:20:29.883]                   name <- changed[[kk]]
[13:20:29.883]                   NAME <- NAMES[[kk]]
[13:20:29.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.883]                     next
[13:20:29.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.883]                 }
[13:20:29.883]                 NAMES <- toupper(added)
[13:20:29.883]                 for (kk in seq_along(NAMES)) {
[13:20:29.883]                   name <- added[[kk]]
[13:20:29.883]                   NAME <- NAMES[[kk]]
[13:20:29.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.883]                     next
[13:20:29.883]                   args[[name]] <- ""
[13:20:29.883]                 }
[13:20:29.883]                 NAMES <- toupper(removed)
[13:20:29.883]                 for (kk in seq_along(NAMES)) {
[13:20:29.883]                   name <- removed[[kk]]
[13:20:29.883]                   NAME <- NAMES[[kk]]
[13:20:29.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:29.883]                     next
[13:20:29.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:29.883]                 }
[13:20:29.883]                 if (length(args) > 0) 
[13:20:29.883]                   base::do.call(base::Sys.setenv, args = args)
[13:20:29.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:29.883]             }
[13:20:29.883]             else {
[13:20:29.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:29.883]             }
[13:20:29.883]             {
[13:20:29.883]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:29.883]                   0L) {
[13:20:29.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:29.883]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:29.883]                   base::options(opts)
[13:20:29.883]                 }
[13:20:29.883]                 {
[13:20:29.883]                   {
[13:20:29.883]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:29.883]                     NULL
[13:20:29.883]                   }
[13:20:29.883]                   options(future.plan = NULL)
[13:20:29.883]                   if (is.na(NA_character_)) 
[13:20:29.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:29.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:29.883]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:29.883]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:29.883]                     envir = parent.frame()) 
[13:20:29.883]                   {
[13:20:29.883]                     if (is.function(workers)) 
[13:20:29.883]                       workers <- workers()
[13:20:29.883]                     workers <- structure(as.integer(workers), 
[13:20:29.883]                       class = class(workers))
[13:20:29.883]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:29.883]                       workers >= 1)
[13:20:29.883]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:29.883]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:29.883]                     }
[13:20:29.883]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:29.883]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:29.883]                       envir = envir)
[13:20:29.883]                     if (!future$lazy) 
[13:20:29.883]                       future <- run(future)
[13:20:29.883]                     invisible(future)
[13:20:29.883]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:29.883]                 }
[13:20:29.883]             }
[13:20:29.883]         }
[13:20:29.883]     })
[13:20:29.883]     if (TRUE) {
[13:20:29.883]         base::sink(type = "output", split = FALSE)
[13:20:29.883]         if (TRUE) {
[13:20:29.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:29.883]         }
[13:20:29.883]         else {
[13:20:29.883]             ...future.result["stdout"] <- base::list(NULL)
[13:20:29.883]         }
[13:20:29.883]         base::close(...future.stdout)
[13:20:29.883]         ...future.stdout <- NULL
[13:20:29.883]     }
[13:20:29.883]     ...future.result$conditions <- ...future.conditions
[13:20:29.883]     ...future.result$finished <- base::Sys.time()
[13:20:29.883]     ...future.result
[13:20:29.883] }
[13:20:29.954] MultisessionFuture started
[13:20:29.955] result() for ClusterFuture ...
[13:20:29.955] receiveMessageFromWorker() for ClusterFuture ...
[13:20:29.955] - Validating connection of MultisessionFuture
[13:20:29.986] - received message: FutureResult
[13:20:29.986] - Received FutureResult
[13:20:29.987] - Erased future from FutureRegistry
[13:20:29.987] result() for ClusterFuture ...
[13:20:29.987] - result already collected: FutureResult
[13:20:29.987] result() for ClusterFuture ... done
[13:20:29.987] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:29.987] result() for ClusterFuture ... done
[13:20:29.987] result() for ClusterFuture ...
[13:20:29.987] - result already collected: FutureResult
[13:20:29.987] result() for ClusterFuture ... done
[13:20:29.988] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:20:29.991] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:20:29.992] getGlobalsAndPackages() ...
[13:20:29.992] Searching for globals...
[13:20:29.992] 
[13:20:29.992] Searching for globals ... DONE
[13:20:29.992] - globals: [0] <none>
[13:20:29.992] getGlobalsAndPackages() ... DONE
[13:20:29.993] run() for ‘Future’ ...
[13:20:29.993] - state: ‘created’
[13:20:29.993] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.008] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.008] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.008]   - Field: ‘node’
[13:20:30.008]   - Field: ‘label’
[13:20:30.008]   - Field: ‘local’
[13:20:30.009]   - Field: ‘owner’
[13:20:30.009]   - Field: ‘envir’
[13:20:30.009]   - Field: ‘workers’
[13:20:30.009]   - Field: ‘packages’
[13:20:30.009]   - Field: ‘gc’
[13:20:30.009]   - Field: ‘conditions’
[13:20:30.009]   - Field: ‘persistent’
[13:20:30.009]   - Field: ‘expr’
[13:20:30.009]   - Field: ‘uuid’
[13:20:30.010]   - Field: ‘seed’
[13:20:30.010]   - Field: ‘version’
[13:20:30.010]   - Field: ‘result’
[13:20:30.010]   - Field: ‘asynchronous’
[13:20:30.010]   - Field: ‘calls’
[13:20:30.010]   - Field: ‘globals’
[13:20:30.010]   - Field: ‘stdout’
[13:20:30.010]   - Field: ‘earlySignal’
[13:20:30.010]   - Field: ‘lazy’
[13:20:30.011]   - Field: ‘state’
[13:20:30.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.011] - Launch lazy future ...
[13:20:30.011] Packages needed by the future expression (n = 0): <none>
[13:20:30.011] Packages needed by future strategies (n = 0): <none>
[13:20:30.012] {
[13:20:30.012]     {
[13:20:30.012]         {
[13:20:30.012]             ...future.startTime <- base::Sys.time()
[13:20:30.012]             {
[13:20:30.012]                 {
[13:20:30.012]                   {
[13:20:30.012]                     {
[13:20:30.012]                       base::local({
[13:20:30.012]                         has_future <- base::requireNamespace("future", 
[13:20:30.012]                           quietly = TRUE)
[13:20:30.012]                         if (has_future) {
[13:20:30.012]                           ns <- base::getNamespace("future")
[13:20:30.012]                           version <- ns[[".package"]][["version"]]
[13:20:30.012]                           if (is.null(version)) 
[13:20:30.012]                             version <- utils::packageVersion("future")
[13:20:30.012]                         }
[13:20:30.012]                         else {
[13:20:30.012]                           version <- NULL
[13:20:30.012]                         }
[13:20:30.012]                         if (!has_future || version < "1.8.0") {
[13:20:30.012]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.012]                             "", base::R.version$version.string), 
[13:20:30.012]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.012]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.012]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.012]                               "release", "version")], collapse = " "), 
[13:20:30.012]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.012]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.012]                             info)
[13:20:30.012]                           info <- base::paste(info, collapse = "; ")
[13:20:30.012]                           if (!has_future) {
[13:20:30.012]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.012]                               info)
[13:20:30.012]                           }
[13:20:30.012]                           else {
[13:20:30.012]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.012]                               info, version)
[13:20:30.012]                           }
[13:20:30.012]                           base::stop(msg)
[13:20:30.012]                         }
[13:20:30.012]                       })
[13:20:30.012]                     }
[13:20:30.012]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.012]                     base::options(mc.cores = 1L)
[13:20:30.012]                   }
[13:20:30.012]                   options(future.plan = NULL)
[13:20:30.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.012]                 }
[13:20:30.012]                 ...future.workdir <- getwd()
[13:20:30.012]             }
[13:20:30.012]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.012]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.012]         }
[13:20:30.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.012]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.012]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.012]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.012]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.012]             base::names(...future.oldOptions))
[13:20:30.012]     }
[13:20:30.012]     if (FALSE) {
[13:20:30.012]     }
[13:20:30.012]     else {
[13:20:30.012]         if (TRUE) {
[13:20:30.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.012]                 open = "w")
[13:20:30.012]         }
[13:20:30.012]         else {
[13:20:30.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.012]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.012]         }
[13:20:30.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.012]             base::sink(type = "output", split = FALSE)
[13:20:30.012]             base::close(...future.stdout)
[13:20:30.012]         }, add = TRUE)
[13:20:30.012]     }
[13:20:30.012]     ...future.frame <- base::sys.nframe()
[13:20:30.012]     ...future.conditions <- base::list()
[13:20:30.012]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.012]     if (FALSE) {
[13:20:30.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.012]     }
[13:20:30.012]     ...future.result <- base::tryCatch({
[13:20:30.012]         base::withCallingHandlers({
[13:20:30.012]             ...future.value <- base::withVisible(base::local({
[13:20:30.012]                 ...future.makeSendCondition <- local({
[13:20:30.012]                   sendCondition <- NULL
[13:20:30.012]                   function(frame = 1L) {
[13:20:30.012]                     if (is.function(sendCondition)) 
[13:20:30.012]                       return(sendCondition)
[13:20:30.012]                     ns <- getNamespace("parallel")
[13:20:30.012]                     if (exists("sendData", mode = "function", 
[13:20:30.012]                       envir = ns)) {
[13:20:30.012]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.012]                         envir = ns)
[13:20:30.012]                       envir <- sys.frame(frame)
[13:20:30.012]                       master <- NULL
[13:20:30.012]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.012]                         !identical(envir, emptyenv())) {
[13:20:30.012]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.012]                           inherits = FALSE)) {
[13:20:30.012]                           master <- get("master", mode = "list", 
[13:20:30.012]                             envir = envir, inherits = FALSE)
[13:20:30.012]                           if (inherits(master, c("SOCKnode", 
[13:20:30.012]                             "SOCK0node"))) {
[13:20:30.012]                             sendCondition <<- function(cond) {
[13:20:30.012]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.012]                                 success = TRUE)
[13:20:30.012]                               parallel_sendData(master, data)
[13:20:30.012]                             }
[13:20:30.012]                             return(sendCondition)
[13:20:30.012]                           }
[13:20:30.012]                         }
[13:20:30.012]                         frame <- frame + 1L
[13:20:30.012]                         envir <- sys.frame(frame)
[13:20:30.012]                       }
[13:20:30.012]                     }
[13:20:30.012]                     sendCondition <<- function(cond) NULL
[13:20:30.012]                   }
[13:20:30.012]                 })
[13:20:30.012]                 withCallingHandlers({
[13:20:30.012]                   2
[13:20:30.012]                 }, immediateCondition = function(cond) {
[13:20:30.012]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.012]                   sendCondition(cond)
[13:20:30.012]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.012]                   {
[13:20:30.012]                     inherits <- base::inherits
[13:20:30.012]                     invokeRestart <- base::invokeRestart
[13:20:30.012]                     is.null <- base::is.null
[13:20:30.012]                     muffled <- FALSE
[13:20:30.012]                     if (inherits(cond, "message")) {
[13:20:30.012]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.012]                       if (muffled) 
[13:20:30.012]                         invokeRestart("muffleMessage")
[13:20:30.012]                     }
[13:20:30.012]                     else if (inherits(cond, "warning")) {
[13:20:30.012]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.012]                       if (muffled) 
[13:20:30.012]                         invokeRestart("muffleWarning")
[13:20:30.012]                     }
[13:20:30.012]                     else if (inherits(cond, "condition")) {
[13:20:30.012]                       if (!is.null(pattern)) {
[13:20:30.012]                         computeRestarts <- base::computeRestarts
[13:20:30.012]                         grepl <- base::grepl
[13:20:30.012]                         restarts <- computeRestarts(cond)
[13:20:30.012]                         for (restart in restarts) {
[13:20:30.012]                           name <- restart$name
[13:20:30.012]                           if (is.null(name)) 
[13:20:30.012]                             next
[13:20:30.012]                           if (!grepl(pattern, name)) 
[13:20:30.012]                             next
[13:20:30.012]                           invokeRestart(restart)
[13:20:30.012]                           muffled <- TRUE
[13:20:30.012]                           break
[13:20:30.012]                         }
[13:20:30.012]                       }
[13:20:30.012]                     }
[13:20:30.012]                     invisible(muffled)
[13:20:30.012]                   }
[13:20:30.012]                   muffleCondition(cond)
[13:20:30.012]                 })
[13:20:30.012]             }))
[13:20:30.012]             future::FutureResult(value = ...future.value$value, 
[13:20:30.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.012]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.012]                     ...future.globalenv.names))
[13:20:30.012]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.012]         }, condition = base::local({
[13:20:30.012]             c <- base::c
[13:20:30.012]             inherits <- base::inherits
[13:20:30.012]             invokeRestart <- base::invokeRestart
[13:20:30.012]             length <- base::length
[13:20:30.012]             list <- base::list
[13:20:30.012]             seq.int <- base::seq.int
[13:20:30.012]             signalCondition <- base::signalCondition
[13:20:30.012]             sys.calls <- base::sys.calls
[13:20:30.012]             `[[` <- base::`[[`
[13:20:30.012]             `+` <- base::`+`
[13:20:30.012]             `<<-` <- base::`<<-`
[13:20:30.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.012]                   3L)]
[13:20:30.012]             }
[13:20:30.012]             function(cond) {
[13:20:30.012]                 is_error <- inherits(cond, "error")
[13:20:30.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.012]                   NULL)
[13:20:30.012]                 if (is_error) {
[13:20:30.012]                   sessionInformation <- function() {
[13:20:30.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.012]                       search = base::search(), system = base::Sys.info())
[13:20:30.012]                   }
[13:20:30.012]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.012]                     cond$call), session = sessionInformation(), 
[13:20:30.012]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.012]                   signalCondition(cond)
[13:20:30.012]                 }
[13:20:30.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.012]                 "immediateCondition"))) {
[13:20:30.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.012]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.012]                   if (TRUE && !signal) {
[13:20:30.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.012]                     {
[13:20:30.012]                       inherits <- base::inherits
[13:20:30.012]                       invokeRestart <- base::invokeRestart
[13:20:30.012]                       is.null <- base::is.null
[13:20:30.012]                       muffled <- FALSE
[13:20:30.012]                       if (inherits(cond, "message")) {
[13:20:30.012]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.012]                         if (muffled) 
[13:20:30.012]                           invokeRestart("muffleMessage")
[13:20:30.012]                       }
[13:20:30.012]                       else if (inherits(cond, "warning")) {
[13:20:30.012]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.012]                         if (muffled) 
[13:20:30.012]                           invokeRestart("muffleWarning")
[13:20:30.012]                       }
[13:20:30.012]                       else if (inherits(cond, "condition")) {
[13:20:30.012]                         if (!is.null(pattern)) {
[13:20:30.012]                           computeRestarts <- base::computeRestarts
[13:20:30.012]                           grepl <- base::grepl
[13:20:30.012]                           restarts <- computeRestarts(cond)
[13:20:30.012]                           for (restart in restarts) {
[13:20:30.012]                             name <- restart$name
[13:20:30.012]                             if (is.null(name)) 
[13:20:30.012]                               next
[13:20:30.012]                             if (!grepl(pattern, name)) 
[13:20:30.012]                               next
[13:20:30.012]                             invokeRestart(restart)
[13:20:30.012]                             muffled <- TRUE
[13:20:30.012]                             break
[13:20:30.012]                           }
[13:20:30.012]                         }
[13:20:30.012]                       }
[13:20:30.012]                       invisible(muffled)
[13:20:30.012]                     }
[13:20:30.012]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.012]                   }
[13:20:30.012]                 }
[13:20:30.012]                 else {
[13:20:30.012]                   if (TRUE) {
[13:20:30.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.012]                     {
[13:20:30.012]                       inherits <- base::inherits
[13:20:30.012]                       invokeRestart <- base::invokeRestart
[13:20:30.012]                       is.null <- base::is.null
[13:20:30.012]                       muffled <- FALSE
[13:20:30.012]                       if (inherits(cond, "message")) {
[13:20:30.012]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.012]                         if (muffled) 
[13:20:30.012]                           invokeRestart("muffleMessage")
[13:20:30.012]                       }
[13:20:30.012]                       else if (inherits(cond, "warning")) {
[13:20:30.012]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.012]                         if (muffled) 
[13:20:30.012]                           invokeRestart("muffleWarning")
[13:20:30.012]                       }
[13:20:30.012]                       else if (inherits(cond, "condition")) {
[13:20:30.012]                         if (!is.null(pattern)) {
[13:20:30.012]                           computeRestarts <- base::computeRestarts
[13:20:30.012]                           grepl <- base::grepl
[13:20:30.012]                           restarts <- computeRestarts(cond)
[13:20:30.012]                           for (restart in restarts) {
[13:20:30.012]                             name <- restart$name
[13:20:30.012]                             if (is.null(name)) 
[13:20:30.012]                               next
[13:20:30.012]                             if (!grepl(pattern, name)) 
[13:20:30.012]                               next
[13:20:30.012]                             invokeRestart(restart)
[13:20:30.012]                             muffled <- TRUE
[13:20:30.012]                             break
[13:20:30.012]                           }
[13:20:30.012]                         }
[13:20:30.012]                       }
[13:20:30.012]                       invisible(muffled)
[13:20:30.012]                     }
[13:20:30.012]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.012]                   }
[13:20:30.012]                 }
[13:20:30.012]             }
[13:20:30.012]         }))
[13:20:30.012]     }, error = function(ex) {
[13:20:30.012]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.012]                 ...future.rng), started = ...future.startTime, 
[13:20:30.012]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.012]             version = "1.8"), class = "FutureResult")
[13:20:30.012]     }, finally = {
[13:20:30.012]         if (!identical(...future.workdir, getwd())) 
[13:20:30.012]             setwd(...future.workdir)
[13:20:30.012]         {
[13:20:30.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.012]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.012]             }
[13:20:30.012]             base::options(...future.oldOptions)
[13:20:30.012]             if (.Platform$OS.type == "windows") {
[13:20:30.012]                 old_names <- names(...future.oldEnvVars)
[13:20:30.012]                 envs <- base::Sys.getenv()
[13:20:30.012]                 names <- names(envs)
[13:20:30.012]                 common <- intersect(names, old_names)
[13:20:30.012]                 added <- setdiff(names, old_names)
[13:20:30.012]                 removed <- setdiff(old_names, names)
[13:20:30.012]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.012]                   envs[common]]
[13:20:30.012]                 NAMES <- toupper(changed)
[13:20:30.012]                 args <- list()
[13:20:30.012]                 for (kk in seq_along(NAMES)) {
[13:20:30.012]                   name <- changed[[kk]]
[13:20:30.012]                   NAME <- NAMES[[kk]]
[13:20:30.012]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.012]                     next
[13:20:30.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.012]                 }
[13:20:30.012]                 NAMES <- toupper(added)
[13:20:30.012]                 for (kk in seq_along(NAMES)) {
[13:20:30.012]                   name <- added[[kk]]
[13:20:30.012]                   NAME <- NAMES[[kk]]
[13:20:30.012]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.012]                     next
[13:20:30.012]                   args[[name]] <- ""
[13:20:30.012]                 }
[13:20:30.012]                 NAMES <- toupper(removed)
[13:20:30.012]                 for (kk in seq_along(NAMES)) {
[13:20:30.012]                   name <- removed[[kk]]
[13:20:30.012]                   NAME <- NAMES[[kk]]
[13:20:30.012]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.012]                     next
[13:20:30.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.012]                 }
[13:20:30.012]                 if (length(args) > 0) 
[13:20:30.012]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.012]             }
[13:20:30.012]             else {
[13:20:30.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.012]             }
[13:20:30.012]             {
[13:20:30.012]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.012]                   0L) {
[13:20:30.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.012]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.012]                   base::options(opts)
[13:20:30.012]                 }
[13:20:30.012]                 {
[13:20:30.012]                   {
[13:20:30.012]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.012]                     NULL
[13:20:30.012]                   }
[13:20:30.012]                   options(future.plan = NULL)
[13:20:30.012]                   if (is.na(NA_character_)) 
[13:20:30.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.012]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.012]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.012]                     envir = parent.frame()) 
[13:20:30.012]                   {
[13:20:30.012]                     if (is.function(workers)) 
[13:20:30.012]                       workers <- workers()
[13:20:30.012]                     workers <- structure(as.integer(workers), 
[13:20:30.012]                       class = class(workers))
[13:20:30.012]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.012]                       workers >= 1)
[13:20:30.012]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.012]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.012]                     }
[13:20:30.012]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.012]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.012]                       envir = envir)
[13:20:30.012]                     if (!future$lazy) 
[13:20:30.012]                       future <- run(future)
[13:20:30.012]                     invisible(future)
[13:20:30.012]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.012]                 }
[13:20:30.012]             }
[13:20:30.012]         }
[13:20:30.012]     })
[13:20:30.012]     if (TRUE) {
[13:20:30.012]         base::sink(type = "output", split = FALSE)
[13:20:30.012]         if (TRUE) {
[13:20:30.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.012]         }
[13:20:30.012]         else {
[13:20:30.012]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.012]         }
[13:20:30.012]         base::close(...future.stdout)
[13:20:30.012]         ...future.stdout <- NULL
[13:20:30.012]     }
[13:20:30.012]     ...future.result$conditions <- ...future.conditions
[13:20:30.012]     ...future.result$finished <- base::Sys.time()
[13:20:30.012]     ...future.result
[13:20:30.012] }
[13:20:30.015] MultisessionFuture started
[13:20:30.015] - Launch lazy future ... done
[13:20:30.015] run() for ‘MultisessionFuture’ ... done
[13:20:30.016] getGlobalsAndPackages() ...
[13:20:30.016] Searching for globals...
[13:20:30.016] 
[13:20:30.016] Searching for globals ... DONE
[13:20:30.016] - globals: [0] <none>
[13:20:30.016] getGlobalsAndPackages() ... DONE
[13:20:30.017] run() for ‘Future’ ...
[13:20:30.017] - state: ‘created’
[13:20:30.017] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.031] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.032]   - Field: ‘node’
[13:20:30.032]   - Field: ‘label’
[13:20:30.032]   - Field: ‘local’
[13:20:30.032]   - Field: ‘owner’
[13:20:30.032]   - Field: ‘envir’
[13:20:30.032]   - Field: ‘workers’
[13:20:30.032]   - Field: ‘packages’
[13:20:30.033]   - Field: ‘gc’
[13:20:30.033]   - Field: ‘conditions’
[13:20:30.033]   - Field: ‘persistent’
[13:20:30.033]   - Field: ‘expr’
[13:20:30.033]   - Field: ‘uuid’
[13:20:30.033]   - Field: ‘seed’
[13:20:30.033]   - Field: ‘version’
[13:20:30.033]   - Field: ‘result’
[13:20:30.033]   - Field: ‘asynchronous’
[13:20:30.033]   - Field: ‘calls’
[13:20:30.034]   - Field: ‘globals’
[13:20:30.034]   - Field: ‘stdout’
[13:20:30.034]   - Field: ‘earlySignal’
[13:20:30.034]   - Field: ‘lazy’
[13:20:30.034]   - Field: ‘state’
[13:20:30.034] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.034] - Launch lazy future ...
[13:20:30.034] Packages needed by the future expression (n = 0): <none>
[13:20:30.035] Packages needed by future strategies (n = 0): <none>
[13:20:30.035] {
[13:20:30.035]     {
[13:20:30.035]         {
[13:20:30.035]             ...future.startTime <- base::Sys.time()
[13:20:30.035]             {
[13:20:30.035]                 {
[13:20:30.035]                   {
[13:20:30.035]                     {
[13:20:30.035]                       base::local({
[13:20:30.035]                         has_future <- base::requireNamespace("future", 
[13:20:30.035]                           quietly = TRUE)
[13:20:30.035]                         if (has_future) {
[13:20:30.035]                           ns <- base::getNamespace("future")
[13:20:30.035]                           version <- ns[[".package"]][["version"]]
[13:20:30.035]                           if (is.null(version)) 
[13:20:30.035]                             version <- utils::packageVersion("future")
[13:20:30.035]                         }
[13:20:30.035]                         else {
[13:20:30.035]                           version <- NULL
[13:20:30.035]                         }
[13:20:30.035]                         if (!has_future || version < "1.8.0") {
[13:20:30.035]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.035]                             "", base::R.version$version.string), 
[13:20:30.035]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.035]                               "release", "version")], collapse = " "), 
[13:20:30.035]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.035]                             info)
[13:20:30.035]                           info <- base::paste(info, collapse = "; ")
[13:20:30.035]                           if (!has_future) {
[13:20:30.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.035]                               info)
[13:20:30.035]                           }
[13:20:30.035]                           else {
[13:20:30.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.035]                               info, version)
[13:20:30.035]                           }
[13:20:30.035]                           base::stop(msg)
[13:20:30.035]                         }
[13:20:30.035]                       })
[13:20:30.035]                     }
[13:20:30.035]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.035]                     base::options(mc.cores = 1L)
[13:20:30.035]                   }
[13:20:30.035]                   options(future.plan = NULL)
[13:20:30.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.035]                 }
[13:20:30.035]                 ...future.workdir <- getwd()
[13:20:30.035]             }
[13:20:30.035]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.035]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.035]         }
[13:20:30.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.035]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.035]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.035]             base::names(...future.oldOptions))
[13:20:30.035]     }
[13:20:30.035]     if (FALSE) {
[13:20:30.035]     }
[13:20:30.035]     else {
[13:20:30.035]         if (TRUE) {
[13:20:30.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.035]                 open = "w")
[13:20:30.035]         }
[13:20:30.035]         else {
[13:20:30.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.035]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.035]         }
[13:20:30.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.035]             base::sink(type = "output", split = FALSE)
[13:20:30.035]             base::close(...future.stdout)
[13:20:30.035]         }, add = TRUE)
[13:20:30.035]     }
[13:20:30.035]     ...future.frame <- base::sys.nframe()
[13:20:30.035]     ...future.conditions <- base::list()
[13:20:30.035]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.035]     if (FALSE) {
[13:20:30.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.035]     }
[13:20:30.035]     ...future.result <- base::tryCatch({
[13:20:30.035]         base::withCallingHandlers({
[13:20:30.035]             ...future.value <- base::withVisible(base::local({
[13:20:30.035]                 ...future.makeSendCondition <- local({
[13:20:30.035]                   sendCondition <- NULL
[13:20:30.035]                   function(frame = 1L) {
[13:20:30.035]                     if (is.function(sendCondition)) 
[13:20:30.035]                       return(sendCondition)
[13:20:30.035]                     ns <- getNamespace("parallel")
[13:20:30.035]                     if (exists("sendData", mode = "function", 
[13:20:30.035]                       envir = ns)) {
[13:20:30.035]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.035]                         envir = ns)
[13:20:30.035]                       envir <- sys.frame(frame)
[13:20:30.035]                       master <- NULL
[13:20:30.035]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.035]                         !identical(envir, emptyenv())) {
[13:20:30.035]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.035]                           inherits = FALSE)) {
[13:20:30.035]                           master <- get("master", mode = "list", 
[13:20:30.035]                             envir = envir, inherits = FALSE)
[13:20:30.035]                           if (inherits(master, c("SOCKnode", 
[13:20:30.035]                             "SOCK0node"))) {
[13:20:30.035]                             sendCondition <<- function(cond) {
[13:20:30.035]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.035]                                 success = TRUE)
[13:20:30.035]                               parallel_sendData(master, data)
[13:20:30.035]                             }
[13:20:30.035]                             return(sendCondition)
[13:20:30.035]                           }
[13:20:30.035]                         }
[13:20:30.035]                         frame <- frame + 1L
[13:20:30.035]                         envir <- sys.frame(frame)
[13:20:30.035]                       }
[13:20:30.035]                     }
[13:20:30.035]                     sendCondition <<- function(cond) NULL
[13:20:30.035]                   }
[13:20:30.035]                 })
[13:20:30.035]                 withCallingHandlers({
[13:20:30.035]                   NULL
[13:20:30.035]                 }, immediateCondition = function(cond) {
[13:20:30.035]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.035]                   sendCondition(cond)
[13:20:30.035]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.035]                   {
[13:20:30.035]                     inherits <- base::inherits
[13:20:30.035]                     invokeRestart <- base::invokeRestart
[13:20:30.035]                     is.null <- base::is.null
[13:20:30.035]                     muffled <- FALSE
[13:20:30.035]                     if (inherits(cond, "message")) {
[13:20:30.035]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.035]                       if (muffled) 
[13:20:30.035]                         invokeRestart("muffleMessage")
[13:20:30.035]                     }
[13:20:30.035]                     else if (inherits(cond, "warning")) {
[13:20:30.035]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.035]                       if (muffled) 
[13:20:30.035]                         invokeRestart("muffleWarning")
[13:20:30.035]                     }
[13:20:30.035]                     else if (inherits(cond, "condition")) {
[13:20:30.035]                       if (!is.null(pattern)) {
[13:20:30.035]                         computeRestarts <- base::computeRestarts
[13:20:30.035]                         grepl <- base::grepl
[13:20:30.035]                         restarts <- computeRestarts(cond)
[13:20:30.035]                         for (restart in restarts) {
[13:20:30.035]                           name <- restart$name
[13:20:30.035]                           if (is.null(name)) 
[13:20:30.035]                             next
[13:20:30.035]                           if (!grepl(pattern, name)) 
[13:20:30.035]                             next
[13:20:30.035]                           invokeRestart(restart)
[13:20:30.035]                           muffled <- TRUE
[13:20:30.035]                           break
[13:20:30.035]                         }
[13:20:30.035]                       }
[13:20:30.035]                     }
[13:20:30.035]                     invisible(muffled)
[13:20:30.035]                   }
[13:20:30.035]                   muffleCondition(cond)
[13:20:30.035]                 })
[13:20:30.035]             }))
[13:20:30.035]             future::FutureResult(value = ...future.value$value, 
[13:20:30.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.035]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.035]                     ...future.globalenv.names))
[13:20:30.035]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.035]         }, condition = base::local({
[13:20:30.035]             c <- base::c
[13:20:30.035]             inherits <- base::inherits
[13:20:30.035]             invokeRestart <- base::invokeRestart
[13:20:30.035]             length <- base::length
[13:20:30.035]             list <- base::list
[13:20:30.035]             seq.int <- base::seq.int
[13:20:30.035]             signalCondition <- base::signalCondition
[13:20:30.035]             sys.calls <- base::sys.calls
[13:20:30.035]             `[[` <- base::`[[`
[13:20:30.035]             `+` <- base::`+`
[13:20:30.035]             `<<-` <- base::`<<-`
[13:20:30.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.035]                   3L)]
[13:20:30.035]             }
[13:20:30.035]             function(cond) {
[13:20:30.035]                 is_error <- inherits(cond, "error")
[13:20:30.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.035]                   NULL)
[13:20:30.035]                 if (is_error) {
[13:20:30.035]                   sessionInformation <- function() {
[13:20:30.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.035]                       search = base::search(), system = base::Sys.info())
[13:20:30.035]                   }
[13:20:30.035]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.035]                     cond$call), session = sessionInformation(), 
[13:20:30.035]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.035]                   signalCondition(cond)
[13:20:30.035]                 }
[13:20:30.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.035]                 "immediateCondition"))) {
[13:20:30.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.035]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.035]                   if (TRUE && !signal) {
[13:20:30.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.035]                     {
[13:20:30.035]                       inherits <- base::inherits
[13:20:30.035]                       invokeRestart <- base::invokeRestart
[13:20:30.035]                       is.null <- base::is.null
[13:20:30.035]                       muffled <- FALSE
[13:20:30.035]                       if (inherits(cond, "message")) {
[13:20:30.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.035]                         if (muffled) 
[13:20:30.035]                           invokeRestart("muffleMessage")
[13:20:30.035]                       }
[13:20:30.035]                       else if (inherits(cond, "warning")) {
[13:20:30.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.035]                         if (muffled) 
[13:20:30.035]                           invokeRestart("muffleWarning")
[13:20:30.035]                       }
[13:20:30.035]                       else if (inherits(cond, "condition")) {
[13:20:30.035]                         if (!is.null(pattern)) {
[13:20:30.035]                           computeRestarts <- base::computeRestarts
[13:20:30.035]                           grepl <- base::grepl
[13:20:30.035]                           restarts <- computeRestarts(cond)
[13:20:30.035]                           for (restart in restarts) {
[13:20:30.035]                             name <- restart$name
[13:20:30.035]                             if (is.null(name)) 
[13:20:30.035]                               next
[13:20:30.035]                             if (!grepl(pattern, name)) 
[13:20:30.035]                               next
[13:20:30.035]                             invokeRestart(restart)
[13:20:30.035]                             muffled <- TRUE
[13:20:30.035]                             break
[13:20:30.035]                           }
[13:20:30.035]                         }
[13:20:30.035]                       }
[13:20:30.035]                       invisible(muffled)
[13:20:30.035]                     }
[13:20:30.035]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.035]                   }
[13:20:30.035]                 }
[13:20:30.035]                 else {
[13:20:30.035]                   if (TRUE) {
[13:20:30.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.035]                     {
[13:20:30.035]                       inherits <- base::inherits
[13:20:30.035]                       invokeRestart <- base::invokeRestart
[13:20:30.035]                       is.null <- base::is.null
[13:20:30.035]                       muffled <- FALSE
[13:20:30.035]                       if (inherits(cond, "message")) {
[13:20:30.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.035]                         if (muffled) 
[13:20:30.035]                           invokeRestart("muffleMessage")
[13:20:30.035]                       }
[13:20:30.035]                       else if (inherits(cond, "warning")) {
[13:20:30.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.035]                         if (muffled) 
[13:20:30.035]                           invokeRestart("muffleWarning")
[13:20:30.035]                       }
[13:20:30.035]                       else if (inherits(cond, "condition")) {
[13:20:30.035]                         if (!is.null(pattern)) {
[13:20:30.035]                           computeRestarts <- base::computeRestarts
[13:20:30.035]                           grepl <- base::grepl
[13:20:30.035]                           restarts <- computeRestarts(cond)
[13:20:30.035]                           for (restart in restarts) {
[13:20:30.035]                             name <- restart$name
[13:20:30.035]                             if (is.null(name)) 
[13:20:30.035]                               next
[13:20:30.035]                             if (!grepl(pattern, name)) 
[13:20:30.035]                               next
[13:20:30.035]                             invokeRestart(restart)
[13:20:30.035]                             muffled <- TRUE
[13:20:30.035]                             break
[13:20:30.035]                           }
[13:20:30.035]                         }
[13:20:30.035]                       }
[13:20:30.035]                       invisible(muffled)
[13:20:30.035]                     }
[13:20:30.035]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.035]                   }
[13:20:30.035]                 }
[13:20:30.035]             }
[13:20:30.035]         }))
[13:20:30.035]     }, error = function(ex) {
[13:20:30.035]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.035]                 ...future.rng), started = ...future.startTime, 
[13:20:30.035]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.035]             version = "1.8"), class = "FutureResult")
[13:20:30.035]     }, finally = {
[13:20:30.035]         if (!identical(...future.workdir, getwd())) 
[13:20:30.035]             setwd(...future.workdir)
[13:20:30.035]         {
[13:20:30.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.035]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.035]             }
[13:20:30.035]             base::options(...future.oldOptions)
[13:20:30.035]             if (.Platform$OS.type == "windows") {
[13:20:30.035]                 old_names <- names(...future.oldEnvVars)
[13:20:30.035]                 envs <- base::Sys.getenv()
[13:20:30.035]                 names <- names(envs)
[13:20:30.035]                 common <- intersect(names, old_names)
[13:20:30.035]                 added <- setdiff(names, old_names)
[13:20:30.035]                 removed <- setdiff(old_names, names)
[13:20:30.035]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.035]                   envs[common]]
[13:20:30.035]                 NAMES <- toupper(changed)
[13:20:30.035]                 args <- list()
[13:20:30.035]                 for (kk in seq_along(NAMES)) {
[13:20:30.035]                   name <- changed[[kk]]
[13:20:30.035]                   NAME <- NAMES[[kk]]
[13:20:30.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.035]                     next
[13:20:30.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.035]                 }
[13:20:30.035]                 NAMES <- toupper(added)
[13:20:30.035]                 for (kk in seq_along(NAMES)) {
[13:20:30.035]                   name <- added[[kk]]
[13:20:30.035]                   NAME <- NAMES[[kk]]
[13:20:30.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.035]                     next
[13:20:30.035]                   args[[name]] <- ""
[13:20:30.035]                 }
[13:20:30.035]                 NAMES <- toupper(removed)
[13:20:30.035]                 for (kk in seq_along(NAMES)) {
[13:20:30.035]                   name <- removed[[kk]]
[13:20:30.035]                   NAME <- NAMES[[kk]]
[13:20:30.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.035]                     next
[13:20:30.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.035]                 }
[13:20:30.035]                 if (length(args) > 0) 
[13:20:30.035]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.035]             }
[13:20:30.035]             else {
[13:20:30.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.035]             }
[13:20:30.035]             {
[13:20:30.035]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.035]                   0L) {
[13:20:30.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.035]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.035]                   base::options(opts)
[13:20:30.035]                 }
[13:20:30.035]                 {
[13:20:30.035]                   {
[13:20:30.035]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.035]                     NULL
[13:20:30.035]                   }
[13:20:30.035]                   options(future.plan = NULL)
[13:20:30.035]                   if (is.na(NA_character_)) 
[13:20:30.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.035]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.035]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.035]                     envir = parent.frame()) 
[13:20:30.035]                   {
[13:20:30.035]                     if (is.function(workers)) 
[13:20:30.035]                       workers <- workers()
[13:20:30.035]                     workers <- structure(as.integer(workers), 
[13:20:30.035]                       class = class(workers))
[13:20:30.035]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.035]                       workers >= 1)
[13:20:30.035]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.035]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.035]                     }
[13:20:30.035]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.035]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.035]                       envir = envir)
[13:20:30.035]                     if (!future$lazy) 
[13:20:30.035]                       future <- run(future)
[13:20:30.035]                     invisible(future)
[13:20:30.035]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.035]                 }
[13:20:30.035]             }
[13:20:30.035]         }
[13:20:30.035]     })
[13:20:30.035]     if (TRUE) {
[13:20:30.035]         base::sink(type = "output", split = FALSE)
[13:20:30.035]         if (TRUE) {
[13:20:30.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.035]         }
[13:20:30.035]         else {
[13:20:30.035]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.035]         }
[13:20:30.035]         base::close(...future.stdout)
[13:20:30.035]         ...future.stdout <- NULL
[13:20:30.035]     }
[13:20:30.035]     ...future.result$conditions <- ...future.conditions
[13:20:30.035]     ...future.result$finished <- base::Sys.time()
[13:20:30.035]     ...future.result
[13:20:30.035] }
[13:20:30.110] MultisessionFuture started
[13:20:30.110] - Launch lazy future ... done
[13:20:30.111] run() for ‘MultisessionFuture’ ... done
[13:20:30.111] getGlobalsAndPackages() ...
[13:20:30.112] Searching for globals...
[13:20:30.113] - globals found: [1] ‘{’
[13:20:30.113] Searching for globals ... DONE
[13:20:30.113] Resolving globals: FALSE
[13:20:30.114] 
[13:20:30.114] 
[13:20:30.114] getGlobalsAndPackages() ... DONE
[13:20:30.114] run() for ‘Future’ ...
[13:20:30.115] - state: ‘created’
[13:20:30.115] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.134] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.134]   - Field: ‘node’
[13:20:30.135]   - Field: ‘label’
[13:20:30.135]   - Field: ‘local’
[13:20:30.135]   - Field: ‘owner’
[13:20:30.135]   - Field: ‘envir’
[13:20:30.135]   - Field: ‘workers’
[13:20:30.135]   - Field: ‘packages’
[13:20:30.135]   - Field: ‘gc’
[13:20:30.136]   - Field: ‘conditions’
[13:20:30.136]   - Field: ‘persistent’
[13:20:30.136]   - Field: ‘expr’
[13:20:30.136]   - Field: ‘uuid’
[13:20:30.136]   - Field: ‘seed’
[13:20:30.136]   - Field: ‘version’
[13:20:30.136]   - Field: ‘result’
[13:20:30.137]   - Field: ‘asynchronous’
[13:20:30.137]   - Field: ‘calls’
[13:20:30.137]   - Field: ‘globals’
[13:20:30.137]   - Field: ‘stdout’
[13:20:30.137]   - Field: ‘earlySignal’
[13:20:30.137]   - Field: ‘lazy’
[13:20:30.137]   - Field: ‘state’
[13:20:30.138] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.138] - Launch lazy future ...
[13:20:30.138] Packages needed by the future expression (n = 0): <none>
[13:20:30.138] Packages needed by future strategies (n = 0): <none>
[13:20:30.139] {
[13:20:30.139]     {
[13:20:30.139]         {
[13:20:30.139]             ...future.startTime <- base::Sys.time()
[13:20:30.139]             {
[13:20:30.139]                 {
[13:20:30.139]                   {
[13:20:30.139]                     {
[13:20:30.139]                       base::local({
[13:20:30.139]                         has_future <- base::requireNamespace("future", 
[13:20:30.139]                           quietly = TRUE)
[13:20:30.139]                         if (has_future) {
[13:20:30.139]                           ns <- base::getNamespace("future")
[13:20:30.139]                           version <- ns[[".package"]][["version"]]
[13:20:30.139]                           if (is.null(version)) 
[13:20:30.139]                             version <- utils::packageVersion("future")
[13:20:30.139]                         }
[13:20:30.139]                         else {
[13:20:30.139]                           version <- NULL
[13:20:30.139]                         }
[13:20:30.139]                         if (!has_future || version < "1.8.0") {
[13:20:30.139]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.139]                             "", base::R.version$version.string), 
[13:20:30.139]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.139]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.139]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.139]                               "release", "version")], collapse = " "), 
[13:20:30.139]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.139]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.139]                             info)
[13:20:30.139]                           info <- base::paste(info, collapse = "; ")
[13:20:30.139]                           if (!has_future) {
[13:20:30.139]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.139]                               info)
[13:20:30.139]                           }
[13:20:30.139]                           else {
[13:20:30.139]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.139]                               info, version)
[13:20:30.139]                           }
[13:20:30.139]                           base::stop(msg)
[13:20:30.139]                         }
[13:20:30.139]                       })
[13:20:30.139]                     }
[13:20:30.139]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.139]                     base::options(mc.cores = 1L)
[13:20:30.139]                   }
[13:20:30.139]                   options(future.plan = NULL)
[13:20:30.139]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.139]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.139]                 }
[13:20:30.139]                 ...future.workdir <- getwd()
[13:20:30.139]             }
[13:20:30.139]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.139]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.139]         }
[13:20:30.139]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.139]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.139]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.139]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.139]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.139]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.139]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.139]             base::names(...future.oldOptions))
[13:20:30.139]     }
[13:20:30.139]     if (FALSE) {
[13:20:30.139]     }
[13:20:30.139]     else {
[13:20:30.139]         if (TRUE) {
[13:20:30.139]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.139]                 open = "w")
[13:20:30.139]         }
[13:20:30.139]         else {
[13:20:30.139]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.139]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.139]         }
[13:20:30.139]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.139]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.139]             base::sink(type = "output", split = FALSE)
[13:20:30.139]             base::close(...future.stdout)
[13:20:30.139]         }, add = TRUE)
[13:20:30.139]     }
[13:20:30.139]     ...future.frame <- base::sys.nframe()
[13:20:30.139]     ...future.conditions <- base::list()
[13:20:30.139]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.139]     if (FALSE) {
[13:20:30.139]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.139]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.139]     }
[13:20:30.139]     ...future.result <- base::tryCatch({
[13:20:30.139]         base::withCallingHandlers({
[13:20:30.139]             ...future.value <- base::withVisible(base::local({
[13:20:30.139]                 ...future.makeSendCondition <- local({
[13:20:30.139]                   sendCondition <- NULL
[13:20:30.139]                   function(frame = 1L) {
[13:20:30.139]                     if (is.function(sendCondition)) 
[13:20:30.139]                       return(sendCondition)
[13:20:30.139]                     ns <- getNamespace("parallel")
[13:20:30.139]                     if (exists("sendData", mode = "function", 
[13:20:30.139]                       envir = ns)) {
[13:20:30.139]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.139]                         envir = ns)
[13:20:30.139]                       envir <- sys.frame(frame)
[13:20:30.139]                       master <- NULL
[13:20:30.139]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.139]                         !identical(envir, emptyenv())) {
[13:20:30.139]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.139]                           inherits = FALSE)) {
[13:20:30.139]                           master <- get("master", mode = "list", 
[13:20:30.139]                             envir = envir, inherits = FALSE)
[13:20:30.139]                           if (inherits(master, c("SOCKnode", 
[13:20:30.139]                             "SOCK0node"))) {
[13:20:30.139]                             sendCondition <<- function(cond) {
[13:20:30.139]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.139]                                 success = TRUE)
[13:20:30.139]                               parallel_sendData(master, data)
[13:20:30.139]                             }
[13:20:30.139]                             return(sendCondition)
[13:20:30.139]                           }
[13:20:30.139]                         }
[13:20:30.139]                         frame <- frame + 1L
[13:20:30.139]                         envir <- sys.frame(frame)
[13:20:30.139]                       }
[13:20:30.139]                     }
[13:20:30.139]                     sendCondition <<- function(cond) NULL
[13:20:30.139]                   }
[13:20:30.139]                 })
[13:20:30.139]                 withCallingHandlers({
[13:20:30.139]                   {
[13:20:30.139]                     4
[13:20:30.139]                   }
[13:20:30.139]                 }, immediateCondition = function(cond) {
[13:20:30.139]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.139]                   sendCondition(cond)
[13:20:30.139]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.139]                   {
[13:20:30.139]                     inherits <- base::inherits
[13:20:30.139]                     invokeRestart <- base::invokeRestart
[13:20:30.139]                     is.null <- base::is.null
[13:20:30.139]                     muffled <- FALSE
[13:20:30.139]                     if (inherits(cond, "message")) {
[13:20:30.139]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.139]                       if (muffled) 
[13:20:30.139]                         invokeRestart("muffleMessage")
[13:20:30.139]                     }
[13:20:30.139]                     else if (inherits(cond, "warning")) {
[13:20:30.139]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.139]                       if (muffled) 
[13:20:30.139]                         invokeRestart("muffleWarning")
[13:20:30.139]                     }
[13:20:30.139]                     else if (inherits(cond, "condition")) {
[13:20:30.139]                       if (!is.null(pattern)) {
[13:20:30.139]                         computeRestarts <- base::computeRestarts
[13:20:30.139]                         grepl <- base::grepl
[13:20:30.139]                         restarts <- computeRestarts(cond)
[13:20:30.139]                         for (restart in restarts) {
[13:20:30.139]                           name <- restart$name
[13:20:30.139]                           if (is.null(name)) 
[13:20:30.139]                             next
[13:20:30.139]                           if (!grepl(pattern, name)) 
[13:20:30.139]                             next
[13:20:30.139]                           invokeRestart(restart)
[13:20:30.139]                           muffled <- TRUE
[13:20:30.139]                           break
[13:20:30.139]                         }
[13:20:30.139]                       }
[13:20:30.139]                     }
[13:20:30.139]                     invisible(muffled)
[13:20:30.139]                   }
[13:20:30.139]                   muffleCondition(cond)
[13:20:30.139]                 })
[13:20:30.139]             }))
[13:20:30.139]             future::FutureResult(value = ...future.value$value, 
[13:20:30.139]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.139]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.139]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.139]                     ...future.globalenv.names))
[13:20:30.139]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.139]         }, condition = base::local({
[13:20:30.139]             c <- base::c
[13:20:30.139]             inherits <- base::inherits
[13:20:30.139]             invokeRestart <- base::invokeRestart
[13:20:30.139]             length <- base::length
[13:20:30.139]             list <- base::list
[13:20:30.139]             seq.int <- base::seq.int
[13:20:30.139]             signalCondition <- base::signalCondition
[13:20:30.139]             sys.calls <- base::sys.calls
[13:20:30.139]             `[[` <- base::`[[`
[13:20:30.139]             `+` <- base::`+`
[13:20:30.139]             `<<-` <- base::`<<-`
[13:20:30.139]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.139]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.139]                   3L)]
[13:20:30.139]             }
[13:20:30.139]             function(cond) {
[13:20:30.139]                 is_error <- inherits(cond, "error")
[13:20:30.139]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.139]                   NULL)
[13:20:30.139]                 if (is_error) {
[13:20:30.139]                   sessionInformation <- function() {
[13:20:30.139]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.139]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.139]                       search = base::search(), system = base::Sys.info())
[13:20:30.139]                   }
[13:20:30.139]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.139]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.139]                     cond$call), session = sessionInformation(), 
[13:20:30.139]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.139]                   signalCondition(cond)
[13:20:30.139]                 }
[13:20:30.139]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.139]                 "immediateCondition"))) {
[13:20:30.139]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.139]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.139]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.139]                   if (TRUE && !signal) {
[13:20:30.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.139]                     {
[13:20:30.139]                       inherits <- base::inherits
[13:20:30.139]                       invokeRestart <- base::invokeRestart
[13:20:30.139]                       is.null <- base::is.null
[13:20:30.139]                       muffled <- FALSE
[13:20:30.139]                       if (inherits(cond, "message")) {
[13:20:30.139]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.139]                         if (muffled) 
[13:20:30.139]                           invokeRestart("muffleMessage")
[13:20:30.139]                       }
[13:20:30.139]                       else if (inherits(cond, "warning")) {
[13:20:30.139]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.139]                         if (muffled) 
[13:20:30.139]                           invokeRestart("muffleWarning")
[13:20:30.139]                       }
[13:20:30.139]                       else if (inherits(cond, "condition")) {
[13:20:30.139]                         if (!is.null(pattern)) {
[13:20:30.139]                           computeRestarts <- base::computeRestarts
[13:20:30.139]                           grepl <- base::grepl
[13:20:30.139]                           restarts <- computeRestarts(cond)
[13:20:30.139]                           for (restart in restarts) {
[13:20:30.139]                             name <- restart$name
[13:20:30.139]                             if (is.null(name)) 
[13:20:30.139]                               next
[13:20:30.139]                             if (!grepl(pattern, name)) 
[13:20:30.139]                               next
[13:20:30.139]                             invokeRestart(restart)
[13:20:30.139]                             muffled <- TRUE
[13:20:30.139]                             break
[13:20:30.139]                           }
[13:20:30.139]                         }
[13:20:30.139]                       }
[13:20:30.139]                       invisible(muffled)
[13:20:30.139]                     }
[13:20:30.139]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.139]                   }
[13:20:30.139]                 }
[13:20:30.139]                 else {
[13:20:30.139]                   if (TRUE) {
[13:20:30.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.139]                     {
[13:20:30.139]                       inherits <- base::inherits
[13:20:30.139]                       invokeRestart <- base::invokeRestart
[13:20:30.139]                       is.null <- base::is.null
[13:20:30.139]                       muffled <- FALSE
[13:20:30.139]                       if (inherits(cond, "message")) {
[13:20:30.139]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.139]                         if (muffled) 
[13:20:30.139]                           invokeRestart("muffleMessage")
[13:20:30.139]                       }
[13:20:30.139]                       else if (inherits(cond, "warning")) {
[13:20:30.139]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.139]                         if (muffled) 
[13:20:30.139]                           invokeRestart("muffleWarning")
[13:20:30.139]                       }
[13:20:30.139]                       else if (inherits(cond, "condition")) {
[13:20:30.139]                         if (!is.null(pattern)) {
[13:20:30.139]                           computeRestarts <- base::computeRestarts
[13:20:30.139]                           grepl <- base::grepl
[13:20:30.139]                           restarts <- computeRestarts(cond)
[13:20:30.139]                           for (restart in restarts) {
[13:20:30.139]                             name <- restart$name
[13:20:30.139]                             if (is.null(name)) 
[13:20:30.139]                               next
[13:20:30.139]                             if (!grepl(pattern, name)) 
[13:20:30.139]                               next
[13:20:30.139]                             invokeRestart(restart)
[13:20:30.139]                             muffled <- TRUE
[13:20:30.139]                             break
[13:20:30.139]                           }
[13:20:30.139]                         }
[13:20:30.139]                       }
[13:20:30.139]                       invisible(muffled)
[13:20:30.139]                     }
[13:20:30.139]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.139]                   }
[13:20:30.139]                 }
[13:20:30.139]             }
[13:20:30.139]         }))
[13:20:30.139]     }, error = function(ex) {
[13:20:30.139]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.139]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.139]                 ...future.rng), started = ...future.startTime, 
[13:20:30.139]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.139]             version = "1.8"), class = "FutureResult")
[13:20:30.139]     }, finally = {
[13:20:30.139]         if (!identical(...future.workdir, getwd())) 
[13:20:30.139]             setwd(...future.workdir)
[13:20:30.139]         {
[13:20:30.139]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.139]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.139]             }
[13:20:30.139]             base::options(...future.oldOptions)
[13:20:30.139]             if (.Platform$OS.type == "windows") {
[13:20:30.139]                 old_names <- names(...future.oldEnvVars)
[13:20:30.139]                 envs <- base::Sys.getenv()
[13:20:30.139]                 names <- names(envs)
[13:20:30.139]                 common <- intersect(names, old_names)
[13:20:30.139]                 added <- setdiff(names, old_names)
[13:20:30.139]                 removed <- setdiff(old_names, names)
[13:20:30.139]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.139]                   envs[common]]
[13:20:30.139]                 NAMES <- toupper(changed)
[13:20:30.139]                 args <- list()
[13:20:30.139]                 for (kk in seq_along(NAMES)) {
[13:20:30.139]                   name <- changed[[kk]]
[13:20:30.139]                   NAME <- NAMES[[kk]]
[13:20:30.139]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.139]                     next
[13:20:30.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.139]                 }
[13:20:30.139]                 NAMES <- toupper(added)
[13:20:30.139]                 for (kk in seq_along(NAMES)) {
[13:20:30.139]                   name <- added[[kk]]
[13:20:30.139]                   NAME <- NAMES[[kk]]
[13:20:30.139]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.139]                     next
[13:20:30.139]                   args[[name]] <- ""
[13:20:30.139]                 }
[13:20:30.139]                 NAMES <- toupper(removed)
[13:20:30.139]                 for (kk in seq_along(NAMES)) {
[13:20:30.139]                   name <- removed[[kk]]
[13:20:30.139]                   NAME <- NAMES[[kk]]
[13:20:30.139]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.139]                     next
[13:20:30.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.139]                 }
[13:20:30.139]                 if (length(args) > 0) 
[13:20:30.139]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.139]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.139]             }
[13:20:30.139]             else {
[13:20:30.139]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.139]             }
[13:20:30.139]             {
[13:20:30.139]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.139]                   0L) {
[13:20:30.139]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.139]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.139]                   base::options(opts)
[13:20:30.139]                 }
[13:20:30.139]                 {
[13:20:30.139]                   {
[13:20:30.139]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.139]                     NULL
[13:20:30.139]                   }
[13:20:30.139]                   options(future.plan = NULL)
[13:20:30.139]                   if (is.na(NA_character_)) 
[13:20:30.139]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.139]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.139]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.139]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.139]                     envir = parent.frame()) 
[13:20:30.139]                   {
[13:20:30.139]                     if (is.function(workers)) 
[13:20:30.139]                       workers <- workers()
[13:20:30.139]                     workers <- structure(as.integer(workers), 
[13:20:30.139]                       class = class(workers))
[13:20:30.139]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.139]                       workers >= 1)
[13:20:30.139]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.139]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.139]                     }
[13:20:30.139]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.139]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.139]                       envir = envir)
[13:20:30.139]                     if (!future$lazy) 
[13:20:30.139]                       future <- run(future)
[13:20:30.139]                     invisible(future)
[13:20:30.139]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.139]                 }
[13:20:30.139]             }
[13:20:30.139]         }
[13:20:30.139]     })
[13:20:30.139]     if (TRUE) {
[13:20:30.139]         base::sink(type = "output", split = FALSE)
[13:20:30.139]         if (TRUE) {
[13:20:30.139]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.139]         }
[13:20:30.139]         else {
[13:20:30.139]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.139]         }
[13:20:30.139]         base::close(...future.stdout)
[13:20:30.139]         ...future.stdout <- NULL
[13:20:30.139]     }
[13:20:30.139]     ...future.result$conditions <- ...future.conditions
[13:20:30.139]     ...future.result$finished <- base::Sys.time()
[13:20:30.139]     ...future.result
[13:20:30.139] }
[13:20:30.143] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:30.154] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.154] - Validating connection of MultisessionFuture
[13:20:30.155] - received message: FutureResult
[13:20:30.155] - Received FutureResult
[13:20:30.155] - Erased future from FutureRegistry
[13:20:30.155] result() for ClusterFuture ...
[13:20:30.155] - result already collected: FutureResult
[13:20:30.155] result() for ClusterFuture ... done
[13:20:30.156] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:30.156] result() for ClusterFuture ...
[13:20:30.156] - result already collected: FutureResult
[13:20:30.156] result() for ClusterFuture ... done
[13:20:30.156] result() for ClusterFuture ...
[13:20:30.156] - result already collected: FutureResult
[13:20:30.157] result() for ClusterFuture ... done
[13:20:30.158] MultisessionFuture started
[13:20:30.158] - Launch lazy future ... done
[13:20:30.158] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55659be16e28> 
Classes 'listenv', 'environment' <environment: 0x55659cc7b410> 
[13:20:30.161] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.161] - Validating connection of MultisessionFuture
[13:20:30.161] - received message: FutureResult
[13:20:30.161] - Received FutureResult
[13:20:30.161] - Erased future from FutureRegistry
[13:20:30.162] result() for ClusterFuture ...
[13:20:30.162] - result already collected: FutureResult
[13:20:30.162] result() for ClusterFuture ... done
[13:20:30.162] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:30.174] resolve() on list environment ...
[13:20:30.174]  recursive: 0
[13:20:30.175]  length: 6
[13:20:30.175]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:30.175] signalConditionsASAP(numeric, pos=1) ...
[13:20:30.175] - nx: 6
[13:20:30.175] - relay: TRUE
[13:20:30.175] - stdout: TRUE
[13:20:30.175] - signal: TRUE
[13:20:30.176] - resignal: FALSE
[13:20:30.176] - force: TRUE
[13:20:30.176] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.176] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.176]  - until=2
[13:20:30.176]  - relaying element #2
[13:20:30.176] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.176] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.176] signalConditionsASAP(NULL, pos=1) ... done
[13:20:30.176]  length: 5 (resolved future 1)
[13:20:30.177] Future #2
[13:20:30.177] result() for ClusterFuture ...
[13:20:30.177] - result already collected: FutureResult
[13:20:30.177] result() for ClusterFuture ... done
[13:20:30.177] result() for ClusterFuture ...
[13:20:30.177] - result already collected: FutureResult
[13:20:30.177] result() for ClusterFuture ... done
[13:20:30.177] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:30.177] - nx: 6
[13:20:30.177] - relay: TRUE
[13:20:30.177] - stdout: TRUE
[13:20:30.178] - signal: TRUE
[13:20:30.178] - resignal: FALSE
[13:20:30.178] - force: TRUE
[13:20:30.178] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.178] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.178]  - until=2
[13:20:30.178]  - relaying element #2
[13:20:30.178] result() for ClusterFuture ...
[13:20:30.178] - result already collected: FutureResult
[13:20:30.178] result() for ClusterFuture ... done
[13:20:30.178] result() for ClusterFuture ...
[13:20:30.179] - result already collected: FutureResult
[13:20:30.179] result() for ClusterFuture ... done
[13:20:30.179] result() for ClusterFuture ...
[13:20:30.179] - result already collected: FutureResult
[13:20:30.179] result() for ClusterFuture ... done
[13:20:30.179] result() for ClusterFuture ...
[13:20:30.179] - result already collected: FutureResult
[13:20:30.179] result() for ClusterFuture ... done
[13:20:30.179] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.179] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.179] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:30.180]  length: 4 (resolved future 2)
[13:20:30.180] Future #3
[13:20:30.180] result() for ClusterFuture ...
[13:20:30.180] - result already collected: FutureResult
[13:20:30.180] result() for ClusterFuture ... done
[13:20:30.180] result() for ClusterFuture ...
[13:20:30.180] - result already collected: FutureResult
[13:20:30.180] result() for ClusterFuture ... done
[13:20:30.180] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:30.180] - nx: 6
[13:20:30.180] - relay: TRUE
[13:20:30.181] - stdout: TRUE
[13:20:30.181] - signal: TRUE
[13:20:30.181] - resignal: FALSE
[13:20:30.181] - force: TRUE
[13:20:30.181] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.181] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.181]  - until=3
[13:20:30.181]  - relaying element #3
[13:20:30.181] result() for ClusterFuture ...
[13:20:30.181] - result already collected: FutureResult
[13:20:30.181] result() for ClusterFuture ... done
[13:20:30.182] result() for ClusterFuture ...
[13:20:30.182] - result already collected: FutureResult
[13:20:30.182] result() for ClusterFuture ... done
[13:20:30.182] result() for ClusterFuture ...
[13:20:30.182] - result already collected: FutureResult
[13:20:30.182] result() for ClusterFuture ... done
[13:20:30.182] result() for ClusterFuture ...
[13:20:30.182] - result already collected: FutureResult
[13:20:30.182] result() for ClusterFuture ... done
[13:20:30.182] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.182] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.183] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:30.183]  length: 3 (resolved future 3)
[13:20:30.193] signalConditionsASAP(NULL, pos=5) ...
[13:20:30.193] - nx: 6
[13:20:30.194] - relay: TRUE
[13:20:30.194] - stdout: TRUE
[13:20:30.194] - signal: TRUE
[13:20:30.194] - resignal: FALSE
[13:20:30.194] - force: TRUE
[13:20:30.194] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.194] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.194]  - until=6
[13:20:30.194]  - relaying element #4
[13:20:30.194]  - relaying element #6
[13:20:30.194] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:20:30.195] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.195] signalConditionsASAP(NULL, pos=5) ... done
[13:20:30.195]  length: 2 (resolved future 5)
[13:20:30.195] signalConditionsASAP(numeric, pos=6) ...
[13:20:30.195] - nx: 6
[13:20:30.195] - relay: TRUE
[13:20:30.195] - stdout: TRUE
[13:20:30.195] - signal: TRUE
[13:20:30.195] - resignal: FALSE
[13:20:30.195] - force: TRUE
[13:20:30.195] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:20:30.196] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.196]  - until=6
[13:20:30.196]  - relaying element #4
[13:20:30.196] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:20:30.196] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.196] signalConditionsASAP(NULL, pos=6) ... done
[13:20:30.196]  length: 1 (resolved future 6)
[13:20:30.207] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.207] - Validating connection of MultisessionFuture
[13:20:30.207] - received message: FutureResult
[13:20:30.207] - Received FutureResult
[13:20:30.207] - Erased future from FutureRegistry
[13:20:30.207] result() for ClusterFuture ...
[13:20:30.207] - result already collected: FutureResult
[13:20:30.207] result() for ClusterFuture ... done
[13:20:30.208] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:30.208] Future #4
[13:20:30.208] result() for ClusterFuture ...
[13:20:30.208] - result already collected: FutureResult
[13:20:30.208] result() for ClusterFuture ... done
[13:20:30.208] result() for ClusterFuture ...
[13:20:30.208] - result already collected: FutureResult
[13:20:30.208] result() for ClusterFuture ... done
[13:20:30.208] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:20:30.208] - nx: 6
[13:20:30.209] - relay: TRUE
[13:20:30.209] - stdout: TRUE
[13:20:30.209] - signal: TRUE
[13:20:30.209] - resignal: FALSE
[13:20:30.209] - force: TRUE
[13:20:30.209] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:20:30.209] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.209]  - until=6
[13:20:30.209]  - relaying element #4
[13:20:30.209] result() for ClusterFuture ...
[13:20:30.209] - result already collected: FutureResult
[13:20:30.210] result() for ClusterFuture ... done
[13:20:30.210] result() for ClusterFuture ...
[13:20:30.210] - result already collected: FutureResult
[13:20:30.210] result() for ClusterFuture ... done
[13:20:30.210] result() for ClusterFuture ...
[13:20:30.210] - result already collected: FutureResult
[13:20:30.210] result() for ClusterFuture ... done
[13:20:30.210] result() for ClusterFuture ...
[13:20:30.210] - result already collected: FutureResult
[13:20:30.210] result() for ClusterFuture ... done
[13:20:30.210] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.211] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:30.211] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:20:30.211]  length: 0 (resolved future 4)
[13:20:30.211] Relaying remaining futures
[13:20:30.211] signalConditionsASAP(NULL, pos=0) ...
[13:20:30.211] - nx: 6
[13:20:30.211] - relay: TRUE
[13:20:30.211] - stdout: TRUE
[13:20:30.211] - signal: TRUE
[13:20:30.211] - resignal: FALSE
[13:20:30.211] - force: TRUE
[13:20:30.212] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.212] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:30.212] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.212] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:30.212] signalConditionsASAP(NULL, pos=0) ... done
[13:20:30.212] resolve() on list environment ... DONE
[13:20:30.212] result() for ClusterFuture ...
[13:20:30.212] - result already collected: FutureResult
[13:20:30.212] result() for ClusterFuture ... done
[13:20:30.213] result() for ClusterFuture ...
[13:20:30.213] - result already collected: FutureResult
[13:20:30.213] result() for ClusterFuture ... done
[13:20:30.213] result() for ClusterFuture ...
[13:20:30.213] - result already collected: FutureResult
[13:20:30.213] result() for ClusterFuture ... done
[13:20:30.213] result() for ClusterFuture ...
[13:20:30.213] - result already collected: FutureResult
[13:20:30.213] result() for ClusterFuture ... done
[13:20:30.214] result() for ClusterFuture ...
[13:20:30.214] - result already collected: FutureResult
[13:20:30.214] result() for ClusterFuture ... done
[13:20:30.214] result() for ClusterFuture ...
[13:20:30.214] - result already collected: FutureResult
[13:20:30.214] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55659ced46b8> 
Dimensions: c(1, 6)
[13:20:30.215] getGlobalsAndPackages() ...
[13:20:30.215] Searching for globals...
[13:20:30.215] 
[13:20:30.215] Searching for globals ... DONE
[13:20:30.215] - globals: [0] <none>
[13:20:30.215] getGlobalsAndPackages() ... DONE
[13:20:30.216] run() for ‘Future’ ...
[13:20:30.216] - state: ‘created’
[13:20:30.216] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.238] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.239]   - Field: ‘node’
[13:20:30.239]   - Field: ‘label’
[13:20:30.239]   - Field: ‘local’
[13:20:30.239]   - Field: ‘owner’
[13:20:30.239]   - Field: ‘envir’
[13:20:30.239]   - Field: ‘workers’
[13:20:30.239]   - Field: ‘packages’
[13:20:30.239]   - Field: ‘gc’
[13:20:30.240]   - Field: ‘conditions’
[13:20:30.240]   - Field: ‘persistent’
[13:20:30.240]   - Field: ‘expr’
[13:20:30.240]   - Field: ‘uuid’
[13:20:30.240]   - Field: ‘seed’
[13:20:30.240]   - Field: ‘version’
[13:20:30.240]   - Field: ‘result’
[13:20:30.240]   - Field: ‘asynchronous’
[13:20:30.240]   - Field: ‘calls’
[13:20:30.240]   - Field: ‘globals’
[13:20:30.240]   - Field: ‘stdout’
[13:20:30.241]   - Field: ‘earlySignal’
[13:20:30.241]   - Field: ‘lazy’
[13:20:30.241]   - Field: ‘state’
[13:20:30.241] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.241] - Launch lazy future ...
[13:20:30.241] Packages needed by the future expression (n = 0): <none>
[13:20:30.241] Packages needed by future strategies (n = 0): <none>
[13:20:30.242] {
[13:20:30.242]     {
[13:20:30.242]         {
[13:20:30.242]             ...future.startTime <- base::Sys.time()
[13:20:30.242]             {
[13:20:30.242]                 {
[13:20:30.242]                   {
[13:20:30.242]                     {
[13:20:30.242]                       base::local({
[13:20:30.242]                         has_future <- base::requireNamespace("future", 
[13:20:30.242]                           quietly = TRUE)
[13:20:30.242]                         if (has_future) {
[13:20:30.242]                           ns <- base::getNamespace("future")
[13:20:30.242]                           version <- ns[[".package"]][["version"]]
[13:20:30.242]                           if (is.null(version)) 
[13:20:30.242]                             version <- utils::packageVersion("future")
[13:20:30.242]                         }
[13:20:30.242]                         else {
[13:20:30.242]                           version <- NULL
[13:20:30.242]                         }
[13:20:30.242]                         if (!has_future || version < "1.8.0") {
[13:20:30.242]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.242]                             "", base::R.version$version.string), 
[13:20:30.242]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.242]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.242]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.242]                               "release", "version")], collapse = " "), 
[13:20:30.242]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.242]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.242]                             info)
[13:20:30.242]                           info <- base::paste(info, collapse = "; ")
[13:20:30.242]                           if (!has_future) {
[13:20:30.242]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.242]                               info)
[13:20:30.242]                           }
[13:20:30.242]                           else {
[13:20:30.242]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.242]                               info, version)
[13:20:30.242]                           }
[13:20:30.242]                           base::stop(msg)
[13:20:30.242]                         }
[13:20:30.242]                       })
[13:20:30.242]                     }
[13:20:30.242]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.242]                     base::options(mc.cores = 1L)
[13:20:30.242]                   }
[13:20:30.242]                   options(future.plan = NULL)
[13:20:30.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.242]                 }
[13:20:30.242]                 ...future.workdir <- getwd()
[13:20:30.242]             }
[13:20:30.242]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.242]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.242]         }
[13:20:30.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.242]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.242]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.242]             base::names(...future.oldOptions))
[13:20:30.242]     }
[13:20:30.242]     if (FALSE) {
[13:20:30.242]     }
[13:20:30.242]     else {
[13:20:30.242]         if (TRUE) {
[13:20:30.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.242]                 open = "w")
[13:20:30.242]         }
[13:20:30.242]         else {
[13:20:30.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.242]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.242]         }
[13:20:30.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.242]             base::sink(type = "output", split = FALSE)
[13:20:30.242]             base::close(...future.stdout)
[13:20:30.242]         }, add = TRUE)
[13:20:30.242]     }
[13:20:30.242]     ...future.frame <- base::sys.nframe()
[13:20:30.242]     ...future.conditions <- base::list()
[13:20:30.242]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.242]     if (FALSE) {
[13:20:30.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.242]     }
[13:20:30.242]     ...future.result <- base::tryCatch({
[13:20:30.242]         base::withCallingHandlers({
[13:20:30.242]             ...future.value <- base::withVisible(base::local({
[13:20:30.242]                 ...future.makeSendCondition <- local({
[13:20:30.242]                   sendCondition <- NULL
[13:20:30.242]                   function(frame = 1L) {
[13:20:30.242]                     if (is.function(sendCondition)) 
[13:20:30.242]                       return(sendCondition)
[13:20:30.242]                     ns <- getNamespace("parallel")
[13:20:30.242]                     if (exists("sendData", mode = "function", 
[13:20:30.242]                       envir = ns)) {
[13:20:30.242]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.242]                         envir = ns)
[13:20:30.242]                       envir <- sys.frame(frame)
[13:20:30.242]                       master <- NULL
[13:20:30.242]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.242]                         !identical(envir, emptyenv())) {
[13:20:30.242]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.242]                           inherits = FALSE)) {
[13:20:30.242]                           master <- get("master", mode = "list", 
[13:20:30.242]                             envir = envir, inherits = FALSE)
[13:20:30.242]                           if (inherits(master, c("SOCKnode", 
[13:20:30.242]                             "SOCK0node"))) {
[13:20:30.242]                             sendCondition <<- function(cond) {
[13:20:30.242]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.242]                                 success = TRUE)
[13:20:30.242]                               parallel_sendData(master, data)
[13:20:30.242]                             }
[13:20:30.242]                             return(sendCondition)
[13:20:30.242]                           }
[13:20:30.242]                         }
[13:20:30.242]                         frame <- frame + 1L
[13:20:30.242]                         envir <- sys.frame(frame)
[13:20:30.242]                       }
[13:20:30.242]                     }
[13:20:30.242]                     sendCondition <<- function(cond) NULL
[13:20:30.242]                   }
[13:20:30.242]                 })
[13:20:30.242]                 withCallingHandlers({
[13:20:30.242]                   2
[13:20:30.242]                 }, immediateCondition = function(cond) {
[13:20:30.242]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.242]                   sendCondition(cond)
[13:20:30.242]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.242]                   {
[13:20:30.242]                     inherits <- base::inherits
[13:20:30.242]                     invokeRestart <- base::invokeRestart
[13:20:30.242]                     is.null <- base::is.null
[13:20:30.242]                     muffled <- FALSE
[13:20:30.242]                     if (inherits(cond, "message")) {
[13:20:30.242]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.242]                       if (muffled) 
[13:20:30.242]                         invokeRestart("muffleMessage")
[13:20:30.242]                     }
[13:20:30.242]                     else if (inherits(cond, "warning")) {
[13:20:30.242]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.242]                       if (muffled) 
[13:20:30.242]                         invokeRestart("muffleWarning")
[13:20:30.242]                     }
[13:20:30.242]                     else if (inherits(cond, "condition")) {
[13:20:30.242]                       if (!is.null(pattern)) {
[13:20:30.242]                         computeRestarts <- base::computeRestarts
[13:20:30.242]                         grepl <- base::grepl
[13:20:30.242]                         restarts <- computeRestarts(cond)
[13:20:30.242]                         for (restart in restarts) {
[13:20:30.242]                           name <- restart$name
[13:20:30.242]                           if (is.null(name)) 
[13:20:30.242]                             next
[13:20:30.242]                           if (!grepl(pattern, name)) 
[13:20:30.242]                             next
[13:20:30.242]                           invokeRestart(restart)
[13:20:30.242]                           muffled <- TRUE
[13:20:30.242]                           break
[13:20:30.242]                         }
[13:20:30.242]                       }
[13:20:30.242]                     }
[13:20:30.242]                     invisible(muffled)
[13:20:30.242]                   }
[13:20:30.242]                   muffleCondition(cond)
[13:20:30.242]                 })
[13:20:30.242]             }))
[13:20:30.242]             future::FutureResult(value = ...future.value$value, 
[13:20:30.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.242]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.242]                     ...future.globalenv.names))
[13:20:30.242]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.242]         }, condition = base::local({
[13:20:30.242]             c <- base::c
[13:20:30.242]             inherits <- base::inherits
[13:20:30.242]             invokeRestart <- base::invokeRestart
[13:20:30.242]             length <- base::length
[13:20:30.242]             list <- base::list
[13:20:30.242]             seq.int <- base::seq.int
[13:20:30.242]             signalCondition <- base::signalCondition
[13:20:30.242]             sys.calls <- base::sys.calls
[13:20:30.242]             `[[` <- base::`[[`
[13:20:30.242]             `+` <- base::`+`
[13:20:30.242]             `<<-` <- base::`<<-`
[13:20:30.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.242]                   3L)]
[13:20:30.242]             }
[13:20:30.242]             function(cond) {
[13:20:30.242]                 is_error <- inherits(cond, "error")
[13:20:30.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.242]                   NULL)
[13:20:30.242]                 if (is_error) {
[13:20:30.242]                   sessionInformation <- function() {
[13:20:30.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.242]                       search = base::search(), system = base::Sys.info())
[13:20:30.242]                   }
[13:20:30.242]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.242]                     cond$call), session = sessionInformation(), 
[13:20:30.242]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.242]                   signalCondition(cond)
[13:20:30.242]                 }
[13:20:30.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.242]                 "immediateCondition"))) {
[13:20:30.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.242]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.242]                   if (TRUE && !signal) {
[13:20:30.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.242]                     {
[13:20:30.242]                       inherits <- base::inherits
[13:20:30.242]                       invokeRestart <- base::invokeRestart
[13:20:30.242]                       is.null <- base::is.null
[13:20:30.242]                       muffled <- FALSE
[13:20:30.242]                       if (inherits(cond, "message")) {
[13:20:30.242]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.242]                         if (muffled) 
[13:20:30.242]                           invokeRestart("muffleMessage")
[13:20:30.242]                       }
[13:20:30.242]                       else if (inherits(cond, "warning")) {
[13:20:30.242]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.242]                         if (muffled) 
[13:20:30.242]                           invokeRestart("muffleWarning")
[13:20:30.242]                       }
[13:20:30.242]                       else if (inherits(cond, "condition")) {
[13:20:30.242]                         if (!is.null(pattern)) {
[13:20:30.242]                           computeRestarts <- base::computeRestarts
[13:20:30.242]                           grepl <- base::grepl
[13:20:30.242]                           restarts <- computeRestarts(cond)
[13:20:30.242]                           for (restart in restarts) {
[13:20:30.242]                             name <- restart$name
[13:20:30.242]                             if (is.null(name)) 
[13:20:30.242]                               next
[13:20:30.242]                             if (!grepl(pattern, name)) 
[13:20:30.242]                               next
[13:20:30.242]                             invokeRestart(restart)
[13:20:30.242]                             muffled <- TRUE
[13:20:30.242]                             break
[13:20:30.242]                           }
[13:20:30.242]                         }
[13:20:30.242]                       }
[13:20:30.242]                       invisible(muffled)
[13:20:30.242]                     }
[13:20:30.242]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.242]                   }
[13:20:30.242]                 }
[13:20:30.242]                 else {
[13:20:30.242]                   if (TRUE) {
[13:20:30.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.242]                     {
[13:20:30.242]                       inherits <- base::inherits
[13:20:30.242]                       invokeRestart <- base::invokeRestart
[13:20:30.242]                       is.null <- base::is.null
[13:20:30.242]                       muffled <- FALSE
[13:20:30.242]                       if (inherits(cond, "message")) {
[13:20:30.242]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.242]                         if (muffled) 
[13:20:30.242]                           invokeRestart("muffleMessage")
[13:20:30.242]                       }
[13:20:30.242]                       else if (inherits(cond, "warning")) {
[13:20:30.242]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.242]                         if (muffled) 
[13:20:30.242]                           invokeRestart("muffleWarning")
[13:20:30.242]                       }
[13:20:30.242]                       else if (inherits(cond, "condition")) {
[13:20:30.242]                         if (!is.null(pattern)) {
[13:20:30.242]                           computeRestarts <- base::computeRestarts
[13:20:30.242]                           grepl <- base::grepl
[13:20:30.242]                           restarts <- computeRestarts(cond)
[13:20:30.242]                           for (restart in restarts) {
[13:20:30.242]                             name <- restart$name
[13:20:30.242]                             if (is.null(name)) 
[13:20:30.242]                               next
[13:20:30.242]                             if (!grepl(pattern, name)) 
[13:20:30.242]                               next
[13:20:30.242]                             invokeRestart(restart)
[13:20:30.242]                             muffled <- TRUE
[13:20:30.242]                             break
[13:20:30.242]                           }
[13:20:30.242]                         }
[13:20:30.242]                       }
[13:20:30.242]                       invisible(muffled)
[13:20:30.242]                     }
[13:20:30.242]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.242]                   }
[13:20:30.242]                 }
[13:20:30.242]             }
[13:20:30.242]         }))
[13:20:30.242]     }, error = function(ex) {
[13:20:30.242]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.242]                 ...future.rng), started = ...future.startTime, 
[13:20:30.242]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.242]             version = "1.8"), class = "FutureResult")
[13:20:30.242]     }, finally = {
[13:20:30.242]         if (!identical(...future.workdir, getwd())) 
[13:20:30.242]             setwd(...future.workdir)
[13:20:30.242]         {
[13:20:30.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.242]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.242]             }
[13:20:30.242]             base::options(...future.oldOptions)
[13:20:30.242]             if (.Platform$OS.type == "windows") {
[13:20:30.242]                 old_names <- names(...future.oldEnvVars)
[13:20:30.242]                 envs <- base::Sys.getenv()
[13:20:30.242]                 names <- names(envs)
[13:20:30.242]                 common <- intersect(names, old_names)
[13:20:30.242]                 added <- setdiff(names, old_names)
[13:20:30.242]                 removed <- setdiff(old_names, names)
[13:20:30.242]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.242]                   envs[common]]
[13:20:30.242]                 NAMES <- toupper(changed)
[13:20:30.242]                 args <- list()
[13:20:30.242]                 for (kk in seq_along(NAMES)) {
[13:20:30.242]                   name <- changed[[kk]]
[13:20:30.242]                   NAME <- NAMES[[kk]]
[13:20:30.242]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.242]                     next
[13:20:30.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.242]                 }
[13:20:30.242]                 NAMES <- toupper(added)
[13:20:30.242]                 for (kk in seq_along(NAMES)) {
[13:20:30.242]                   name <- added[[kk]]
[13:20:30.242]                   NAME <- NAMES[[kk]]
[13:20:30.242]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.242]                     next
[13:20:30.242]                   args[[name]] <- ""
[13:20:30.242]                 }
[13:20:30.242]                 NAMES <- toupper(removed)
[13:20:30.242]                 for (kk in seq_along(NAMES)) {
[13:20:30.242]                   name <- removed[[kk]]
[13:20:30.242]                   NAME <- NAMES[[kk]]
[13:20:30.242]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.242]                     next
[13:20:30.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.242]                 }
[13:20:30.242]                 if (length(args) > 0) 
[13:20:30.242]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.242]             }
[13:20:30.242]             else {
[13:20:30.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.242]             }
[13:20:30.242]             {
[13:20:30.242]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.242]                   0L) {
[13:20:30.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.242]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.242]                   base::options(opts)
[13:20:30.242]                 }
[13:20:30.242]                 {
[13:20:30.242]                   {
[13:20:30.242]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.242]                     NULL
[13:20:30.242]                   }
[13:20:30.242]                   options(future.plan = NULL)
[13:20:30.242]                   if (is.na(NA_character_)) 
[13:20:30.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.242]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.242]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.242]                     envir = parent.frame()) 
[13:20:30.242]                   {
[13:20:30.242]                     if (is.function(workers)) 
[13:20:30.242]                       workers <- workers()
[13:20:30.242]                     workers <- structure(as.integer(workers), 
[13:20:30.242]                       class = class(workers))
[13:20:30.242]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.242]                       workers >= 1)
[13:20:30.242]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.242]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.242]                     }
[13:20:30.242]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.242]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.242]                       envir = envir)
[13:20:30.242]                     if (!future$lazy) 
[13:20:30.242]                       future <- run(future)
[13:20:30.242]                     invisible(future)
[13:20:30.242]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.242]                 }
[13:20:30.242]             }
[13:20:30.242]         }
[13:20:30.242]     })
[13:20:30.242]     if (TRUE) {
[13:20:30.242]         base::sink(type = "output", split = FALSE)
[13:20:30.242]         if (TRUE) {
[13:20:30.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.242]         }
[13:20:30.242]         else {
[13:20:30.242]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.242]         }
[13:20:30.242]         base::close(...future.stdout)
[13:20:30.242]         ...future.stdout <- NULL
[13:20:30.242]     }
[13:20:30.242]     ...future.result$conditions <- ...future.conditions
[13:20:30.242]     ...future.result$finished <- base::Sys.time()
[13:20:30.242]     ...future.result
[13:20:30.242] }
[13:20:30.245] MultisessionFuture started
[13:20:30.245] - Launch lazy future ... done
[13:20:30.245] run() for ‘MultisessionFuture’ ... done
[13:20:30.246] getGlobalsAndPackages() ...
[13:20:30.246] Searching for globals...
[13:20:30.246] 
[13:20:30.246] Searching for globals ... DONE
[13:20:30.246] - globals: [0] <none>
[13:20:30.246] getGlobalsAndPackages() ... DONE
[13:20:30.247] run() for ‘Future’ ...
[13:20:30.247] - state: ‘created’
[13:20:30.247] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.261] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.261]   - Field: ‘node’
[13:20:30.262]   - Field: ‘label’
[13:20:30.262]   - Field: ‘local’
[13:20:30.262]   - Field: ‘owner’
[13:20:30.262]   - Field: ‘envir’
[13:20:30.262]   - Field: ‘workers’
[13:20:30.262]   - Field: ‘packages’
[13:20:30.262]   - Field: ‘gc’
[13:20:30.262]   - Field: ‘conditions’
[13:20:30.262]   - Field: ‘persistent’
[13:20:30.262]   - Field: ‘expr’
[13:20:30.263]   - Field: ‘uuid’
[13:20:30.263]   - Field: ‘seed’
[13:20:30.263]   - Field: ‘version’
[13:20:30.263]   - Field: ‘result’
[13:20:30.263]   - Field: ‘asynchronous’
[13:20:30.263]   - Field: ‘calls’
[13:20:30.263]   - Field: ‘globals’
[13:20:30.263]   - Field: ‘stdout’
[13:20:30.263]   - Field: ‘earlySignal’
[13:20:30.263]   - Field: ‘lazy’
[13:20:30.263]   - Field: ‘state’
[13:20:30.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.264] - Launch lazy future ...
[13:20:30.264] Packages needed by the future expression (n = 0): <none>
[13:20:30.264] Packages needed by future strategies (n = 0): <none>
[13:20:30.264] {
[13:20:30.264]     {
[13:20:30.264]         {
[13:20:30.264]             ...future.startTime <- base::Sys.time()
[13:20:30.264]             {
[13:20:30.264]                 {
[13:20:30.264]                   {
[13:20:30.264]                     {
[13:20:30.264]                       base::local({
[13:20:30.264]                         has_future <- base::requireNamespace("future", 
[13:20:30.264]                           quietly = TRUE)
[13:20:30.264]                         if (has_future) {
[13:20:30.264]                           ns <- base::getNamespace("future")
[13:20:30.264]                           version <- ns[[".package"]][["version"]]
[13:20:30.264]                           if (is.null(version)) 
[13:20:30.264]                             version <- utils::packageVersion("future")
[13:20:30.264]                         }
[13:20:30.264]                         else {
[13:20:30.264]                           version <- NULL
[13:20:30.264]                         }
[13:20:30.264]                         if (!has_future || version < "1.8.0") {
[13:20:30.264]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.264]                             "", base::R.version$version.string), 
[13:20:30.264]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.264]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.264]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.264]                               "release", "version")], collapse = " "), 
[13:20:30.264]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.264]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.264]                             info)
[13:20:30.264]                           info <- base::paste(info, collapse = "; ")
[13:20:30.264]                           if (!has_future) {
[13:20:30.264]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.264]                               info)
[13:20:30.264]                           }
[13:20:30.264]                           else {
[13:20:30.264]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.264]                               info, version)
[13:20:30.264]                           }
[13:20:30.264]                           base::stop(msg)
[13:20:30.264]                         }
[13:20:30.264]                       })
[13:20:30.264]                     }
[13:20:30.264]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.264]                     base::options(mc.cores = 1L)
[13:20:30.264]                   }
[13:20:30.264]                   options(future.plan = NULL)
[13:20:30.264]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.264]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.264]                 }
[13:20:30.264]                 ...future.workdir <- getwd()
[13:20:30.264]             }
[13:20:30.264]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.264]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.264]         }
[13:20:30.264]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.264]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.264]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.264]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.264]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.264]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.264]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.264]             base::names(...future.oldOptions))
[13:20:30.264]     }
[13:20:30.264]     if (FALSE) {
[13:20:30.264]     }
[13:20:30.264]     else {
[13:20:30.264]         if (TRUE) {
[13:20:30.264]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.264]                 open = "w")
[13:20:30.264]         }
[13:20:30.264]         else {
[13:20:30.264]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.264]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.264]         }
[13:20:30.264]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.264]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.264]             base::sink(type = "output", split = FALSE)
[13:20:30.264]             base::close(...future.stdout)
[13:20:30.264]         }, add = TRUE)
[13:20:30.264]     }
[13:20:30.264]     ...future.frame <- base::sys.nframe()
[13:20:30.264]     ...future.conditions <- base::list()
[13:20:30.264]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.264]     if (FALSE) {
[13:20:30.264]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.264]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.264]     }
[13:20:30.264]     ...future.result <- base::tryCatch({
[13:20:30.264]         base::withCallingHandlers({
[13:20:30.264]             ...future.value <- base::withVisible(base::local({
[13:20:30.264]                 ...future.makeSendCondition <- local({
[13:20:30.264]                   sendCondition <- NULL
[13:20:30.264]                   function(frame = 1L) {
[13:20:30.264]                     if (is.function(sendCondition)) 
[13:20:30.264]                       return(sendCondition)
[13:20:30.264]                     ns <- getNamespace("parallel")
[13:20:30.264]                     if (exists("sendData", mode = "function", 
[13:20:30.264]                       envir = ns)) {
[13:20:30.264]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.264]                         envir = ns)
[13:20:30.264]                       envir <- sys.frame(frame)
[13:20:30.264]                       master <- NULL
[13:20:30.264]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.264]                         !identical(envir, emptyenv())) {
[13:20:30.264]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.264]                           inherits = FALSE)) {
[13:20:30.264]                           master <- get("master", mode = "list", 
[13:20:30.264]                             envir = envir, inherits = FALSE)
[13:20:30.264]                           if (inherits(master, c("SOCKnode", 
[13:20:30.264]                             "SOCK0node"))) {
[13:20:30.264]                             sendCondition <<- function(cond) {
[13:20:30.264]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.264]                                 success = TRUE)
[13:20:30.264]                               parallel_sendData(master, data)
[13:20:30.264]                             }
[13:20:30.264]                             return(sendCondition)
[13:20:30.264]                           }
[13:20:30.264]                         }
[13:20:30.264]                         frame <- frame + 1L
[13:20:30.264]                         envir <- sys.frame(frame)
[13:20:30.264]                       }
[13:20:30.264]                     }
[13:20:30.264]                     sendCondition <<- function(cond) NULL
[13:20:30.264]                   }
[13:20:30.264]                 })
[13:20:30.264]                 withCallingHandlers({
[13:20:30.264]                   NULL
[13:20:30.264]                 }, immediateCondition = function(cond) {
[13:20:30.264]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.264]                   sendCondition(cond)
[13:20:30.264]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.264]                   {
[13:20:30.264]                     inherits <- base::inherits
[13:20:30.264]                     invokeRestart <- base::invokeRestart
[13:20:30.264]                     is.null <- base::is.null
[13:20:30.264]                     muffled <- FALSE
[13:20:30.264]                     if (inherits(cond, "message")) {
[13:20:30.264]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.264]                       if (muffled) 
[13:20:30.264]                         invokeRestart("muffleMessage")
[13:20:30.264]                     }
[13:20:30.264]                     else if (inherits(cond, "warning")) {
[13:20:30.264]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.264]                       if (muffled) 
[13:20:30.264]                         invokeRestart("muffleWarning")
[13:20:30.264]                     }
[13:20:30.264]                     else if (inherits(cond, "condition")) {
[13:20:30.264]                       if (!is.null(pattern)) {
[13:20:30.264]                         computeRestarts <- base::computeRestarts
[13:20:30.264]                         grepl <- base::grepl
[13:20:30.264]                         restarts <- computeRestarts(cond)
[13:20:30.264]                         for (restart in restarts) {
[13:20:30.264]                           name <- restart$name
[13:20:30.264]                           if (is.null(name)) 
[13:20:30.264]                             next
[13:20:30.264]                           if (!grepl(pattern, name)) 
[13:20:30.264]                             next
[13:20:30.264]                           invokeRestart(restart)
[13:20:30.264]                           muffled <- TRUE
[13:20:30.264]                           break
[13:20:30.264]                         }
[13:20:30.264]                       }
[13:20:30.264]                     }
[13:20:30.264]                     invisible(muffled)
[13:20:30.264]                   }
[13:20:30.264]                   muffleCondition(cond)
[13:20:30.264]                 })
[13:20:30.264]             }))
[13:20:30.264]             future::FutureResult(value = ...future.value$value, 
[13:20:30.264]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.264]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.264]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.264]                     ...future.globalenv.names))
[13:20:30.264]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.264]         }, condition = base::local({
[13:20:30.264]             c <- base::c
[13:20:30.264]             inherits <- base::inherits
[13:20:30.264]             invokeRestart <- base::invokeRestart
[13:20:30.264]             length <- base::length
[13:20:30.264]             list <- base::list
[13:20:30.264]             seq.int <- base::seq.int
[13:20:30.264]             signalCondition <- base::signalCondition
[13:20:30.264]             sys.calls <- base::sys.calls
[13:20:30.264]             `[[` <- base::`[[`
[13:20:30.264]             `+` <- base::`+`
[13:20:30.264]             `<<-` <- base::`<<-`
[13:20:30.264]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.264]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.264]                   3L)]
[13:20:30.264]             }
[13:20:30.264]             function(cond) {
[13:20:30.264]                 is_error <- inherits(cond, "error")
[13:20:30.264]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.264]                   NULL)
[13:20:30.264]                 if (is_error) {
[13:20:30.264]                   sessionInformation <- function() {
[13:20:30.264]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.264]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.264]                       search = base::search(), system = base::Sys.info())
[13:20:30.264]                   }
[13:20:30.264]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.264]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.264]                     cond$call), session = sessionInformation(), 
[13:20:30.264]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.264]                   signalCondition(cond)
[13:20:30.264]                 }
[13:20:30.264]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.264]                 "immediateCondition"))) {
[13:20:30.264]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.264]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.264]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.264]                   if (TRUE && !signal) {
[13:20:30.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.264]                     {
[13:20:30.264]                       inherits <- base::inherits
[13:20:30.264]                       invokeRestart <- base::invokeRestart
[13:20:30.264]                       is.null <- base::is.null
[13:20:30.264]                       muffled <- FALSE
[13:20:30.264]                       if (inherits(cond, "message")) {
[13:20:30.264]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.264]                         if (muffled) 
[13:20:30.264]                           invokeRestart("muffleMessage")
[13:20:30.264]                       }
[13:20:30.264]                       else if (inherits(cond, "warning")) {
[13:20:30.264]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.264]                         if (muffled) 
[13:20:30.264]                           invokeRestart("muffleWarning")
[13:20:30.264]                       }
[13:20:30.264]                       else if (inherits(cond, "condition")) {
[13:20:30.264]                         if (!is.null(pattern)) {
[13:20:30.264]                           computeRestarts <- base::computeRestarts
[13:20:30.264]                           grepl <- base::grepl
[13:20:30.264]                           restarts <- computeRestarts(cond)
[13:20:30.264]                           for (restart in restarts) {
[13:20:30.264]                             name <- restart$name
[13:20:30.264]                             if (is.null(name)) 
[13:20:30.264]                               next
[13:20:30.264]                             if (!grepl(pattern, name)) 
[13:20:30.264]                               next
[13:20:30.264]                             invokeRestart(restart)
[13:20:30.264]                             muffled <- TRUE
[13:20:30.264]                             break
[13:20:30.264]                           }
[13:20:30.264]                         }
[13:20:30.264]                       }
[13:20:30.264]                       invisible(muffled)
[13:20:30.264]                     }
[13:20:30.264]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.264]                   }
[13:20:30.264]                 }
[13:20:30.264]                 else {
[13:20:30.264]                   if (TRUE) {
[13:20:30.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.264]                     {
[13:20:30.264]                       inherits <- base::inherits
[13:20:30.264]                       invokeRestart <- base::invokeRestart
[13:20:30.264]                       is.null <- base::is.null
[13:20:30.264]                       muffled <- FALSE
[13:20:30.264]                       if (inherits(cond, "message")) {
[13:20:30.264]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.264]                         if (muffled) 
[13:20:30.264]                           invokeRestart("muffleMessage")
[13:20:30.264]                       }
[13:20:30.264]                       else if (inherits(cond, "warning")) {
[13:20:30.264]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.264]                         if (muffled) 
[13:20:30.264]                           invokeRestart("muffleWarning")
[13:20:30.264]                       }
[13:20:30.264]                       else if (inherits(cond, "condition")) {
[13:20:30.264]                         if (!is.null(pattern)) {
[13:20:30.264]                           computeRestarts <- base::computeRestarts
[13:20:30.264]                           grepl <- base::grepl
[13:20:30.264]                           restarts <- computeRestarts(cond)
[13:20:30.264]                           for (restart in restarts) {
[13:20:30.264]                             name <- restart$name
[13:20:30.264]                             if (is.null(name)) 
[13:20:30.264]                               next
[13:20:30.264]                             if (!grepl(pattern, name)) 
[13:20:30.264]                               next
[13:20:30.264]                             invokeRestart(restart)
[13:20:30.264]                             muffled <- TRUE
[13:20:30.264]                             break
[13:20:30.264]                           }
[13:20:30.264]                         }
[13:20:30.264]                       }
[13:20:30.264]                       invisible(muffled)
[13:20:30.264]                     }
[13:20:30.264]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.264]                   }
[13:20:30.264]                 }
[13:20:30.264]             }
[13:20:30.264]         }))
[13:20:30.264]     }, error = function(ex) {
[13:20:30.264]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.264]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.264]                 ...future.rng), started = ...future.startTime, 
[13:20:30.264]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.264]             version = "1.8"), class = "FutureResult")
[13:20:30.264]     }, finally = {
[13:20:30.264]         if (!identical(...future.workdir, getwd())) 
[13:20:30.264]             setwd(...future.workdir)
[13:20:30.264]         {
[13:20:30.264]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.264]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.264]             }
[13:20:30.264]             base::options(...future.oldOptions)
[13:20:30.264]             if (.Platform$OS.type == "windows") {
[13:20:30.264]                 old_names <- names(...future.oldEnvVars)
[13:20:30.264]                 envs <- base::Sys.getenv()
[13:20:30.264]                 names <- names(envs)
[13:20:30.264]                 common <- intersect(names, old_names)
[13:20:30.264]                 added <- setdiff(names, old_names)
[13:20:30.264]                 removed <- setdiff(old_names, names)
[13:20:30.264]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.264]                   envs[common]]
[13:20:30.264]                 NAMES <- toupper(changed)
[13:20:30.264]                 args <- list()
[13:20:30.264]                 for (kk in seq_along(NAMES)) {
[13:20:30.264]                   name <- changed[[kk]]
[13:20:30.264]                   NAME <- NAMES[[kk]]
[13:20:30.264]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.264]                     next
[13:20:30.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.264]                 }
[13:20:30.264]                 NAMES <- toupper(added)
[13:20:30.264]                 for (kk in seq_along(NAMES)) {
[13:20:30.264]                   name <- added[[kk]]
[13:20:30.264]                   NAME <- NAMES[[kk]]
[13:20:30.264]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.264]                     next
[13:20:30.264]                   args[[name]] <- ""
[13:20:30.264]                 }
[13:20:30.264]                 NAMES <- toupper(removed)
[13:20:30.264]                 for (kk in seq_along(NAMES)) {
[13:20:30.264]                   name <- removed[[kk]]
[13:20:30.264]                   NAME <- NAMES[[kk]]
[13:20:30.264]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.264]                     next
[13:20:30.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.264]                 }
[13:20:30.264]                 if (length(args) > 0) 
[13:20:30.264]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.264]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.264]             }
[13:20:30.264]             else {
[13:20:30.264]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.264]             }
[13:20:30.264]             {
[13:20:30.264]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.264]                   0L) {
[13:20:30.264]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.264]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.264]                   base::options(opts)
[13:20:30.264]                 }
[13:20:30.264]                 {
[13:20:30.264]                   {
[13:20:30.264]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.264]                     NULL
[13:20:30.264]                   }
[13:20:30.264]                   options(future.plan = NULL)
[13:20:30.264]                   if (is.na(NA_character_)) 
[13:20:30.264]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.264]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.264]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.264]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.264]                     envir = parent.frame()) 
[13:20:30.264]                   {
[13:20:30.264]                     if (is.function(workers)) 
[13:20:30.264]                       workers <- workers()
[13:20:30.264]                     workers <- structure(as.integer(workers), 
[13:20:30.264]                       class = class(workers))
[13:20:30.264]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.264]                       workers >= 1)
[13:20:30.264]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.264]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.264]                     }
[13:20:30.264]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.264]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.264]                       envir = envir)
[13:20:30.264]                     if (!future$lazy) 
[13:20:30.264]                       future <- run(future)
[13:20:30.264]                     invisible(future)
[13:20:30.264]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.264]                 }
[13:20:30.264]             }
[13:20:30.264]         }
[13:20:30.264]     })
[13:20:30.264]     if (TRUE) {
[13:20:30.264]         base::sink(type = "output", split = FALSE)
[13:20:30.264]         if (TRUE) {
[13:20:30.264]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.264]         }
[13:20:30.264]         else {
[13:20:30.264]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.264]         }
[13:20:30.264]         base::close(...future.stdout)
[13:20:30.264]         ...future.stdout <- NULL
[13:20:30.264]     }
[13:20:30.264]     ...future.result$conditions <- ...future.conditions
[13:20:30.264]     ...future.result$finished <- base::Sys.time()
[13:20:30.264]     ...future.result
[13:20:30.264] }
[13:20:30.268] MultisessionFuture started
[13:20:30.268] - Launch lazy future ... done
[13:20:30.268] run() for ‘MultisessionFuture’ ... done
[13:20:30.268] getGlobalsAndPackages() ...
[13:20:30.269] Searching for globals...
[13:20:30.269] - globals found: [1] ‘{’
[13:20:30.269] Searching for globals ... DONE
[13:20:30.269] Resolving globals: FALSE
[13:20:30.270] 
[13:20:30.270] 
[13:20:30.270] getGlobalsAndPackages() ... DONE
[13:20:30.270] run() for ‘Future’ ...
[13:20:30.270] - state: ‘created’
[13:20:30.270] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.285] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.285]   - Field: ‘node’
[13:20:30.285]   - Field: ‘label’
[13:20:30.286]   - Field: ‘local’
[13:20:30.286]   - Field: ‘owner’
[13:20:30.286]   - Field: ‘envir’
[13:20:30.286]   - Field: ‘workers’
[13:20:30.286]   - Field: ‘packages’
[13:20:30.286]   - Field: ‘gc’
[13:20:30.286]   - Field: ‘conditions’
[13:20:30.286]   - Field: ‘persistent’
[13:20:30.286]   - Field: ‘expr’
[13:20:30.286]   - Field: ‘uuid’
[13:20:30.286]   - Field: ‘seed’
[13:20:30.287]   - Field: ‘version’
[13:20:30.287]   - Field: ‘result’
[13:20:30.287]   - Field: ‘asynchronous’
[13:20:30.287]   - Field: ‘calls’
[13:20:30.287]   - Field: ‘globals’
[13:20:30.287]   - Field: ‘stdout’
[13:20:30.287]   - Field: ‘earlySignal’
[13:20:30.287]   - Field: ‘lazy’
[13:20:30.287]   - Field: ‘state’
[13:20:30.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.288] - Launch lazy future ...
[13:20:30.288] Packages needed by the future expression (n = 0): <none>
[13:20:30.288] Packages needed by future strategies (n = 0): <none>
[13:20:30.288] {
[13:20:30.288]     {
[13:20:30.288]         {
[13:20:30.288]             ...future.startTime <- base::Sys.time()
[13:20:30.288]             {
[13:20:30.288]                 {
[13:20:30.288]                   {
[13:20:30.288]                     {
[13:20:30.288]                       base::local({
[13:20:30.288]                         has_future <- base::requireNamespace("future", 
[13:20:30.288]                           quietly = TRUE)
[13:20:30.288]                         if (has_future) {
[13:20:30.288]                           ns <- base::getNamespace("future")
[13:20:30.288]                           version <- ns[[".package"]][["version"]]
[13:20:30.288]                           if (is.null(version)) 
[13:20:30.288]                             version <- utils::packageVersion("future")
[13:20:30.288]                         }
[13:20:30.288]                         else {
[13:20:30.288]                           version <- NULL
[13:20:30.288]                         }
[13:20:30.288]                         if (!has_future || version < "1.8.0") {
[13:20:30.288]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.288]                             "", base::R.version$version.string), 
[13:20:30.288]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.288]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.288]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.288]                               "release", "version")], collapse = " "), 
[13:20:30.288]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.288]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.288]                             info)
[13:20:30.288]                           info <- base::paste(info, collapse = "; ")
[13:20:30.288]                           if (!has_future) {
[13:20:30.288]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.288]                               info)
[13:20:30.288]                           }
[13:20:30.288]                           else {
[13:20:30.288]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.288]                               info, version)
[13:20:30.288]                           }
[13:20:30.288]                           base::stop(msg)
[13:20:30.288]                         }
[13:20:30.288]                       })
[13:20:30.288]                     }
[13:20:30.288]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.288]                     base::options(mc.cores = 1L)
[13:20:30.288]                   }
[13:20:30.288]                   options(future.plan = NULL)
[13:20:30.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.288]                 }
[13:20:30.288]                 ...future.workdir <- getwd()
[13:20:30.288]             }
[13:20:30.288]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.288]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.288]         }
[13:20:30.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.288]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.288]             base::names(...future.oldOptions))
[13:20:30.288]     }
[13:20:30.288]     if (FALSE) {
[13:20:30.288]     }
[13:20:30.288]     else {
[13:20:30.288]         if (TRUE) {
[13:20:30.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.288]                 open = "w")
[13:20:30.288]         }
[13:20:30.288]         else {
[13:20:30.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.288]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.288]         }
[13:20:30.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.288]             base::sink(type = "output", split = FALSE)
[13:20:30.288]             base::close(...future.stdout)
[13:20:30.288]         }, add = TRUE)
[13:20:30.288]     }
[13:20:30.288]     ...future.frame <- base::sys.nframe()
[13:20:30.288]     ...future.conditions <- base::list()
[13:20:30.288]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.288]     if (FALSE) {
[13:20:30.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.288]     }
[13:20:30.288]     ...future.result <- base::tryCatch({
[13:20:30.288]         base::withCallingHandlers({
[13:20:30.288]             ...future.value <- base::withVisible(base::local({
[13:20:30.288]                 ...future.makeSendCondition <- local({
[13:20:30.288]                   sendCondition <- NULL
[13:20:30.288]                   function(frame = 1L) {
[13:20:30.288]                     if (is.function(sendCondition)) 
[13:20:30.288]                       return(sendCondition)
[13:20:30.288]                     ns <- getNamespace("parallel")
[13:20:30.288]                     if (exists("sendData", mode = "function", 
[13:20:30.288]                       envir = ns)) {
[13:20:30.288]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.288]                         envir = ns)
[13:20:30.288]                       envir <- sys.frame(frame)
[13:20:30.288]                       master <- NULL
[13:20:30.288]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.288]                         !identical(envir, emptyenv())) {
[13:20:30.288]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.288]                           inherits = FALSE)) {
[13:20:30.288]                           master <- get("master", mode = "list", 
[13:20:30.288]                             envir = envir, inherits = FALSE)
[13:20:30.288]                           if (inherits(master, c("SOCKnode", 
[13:20:30.288]                             "SOCK0node"))) {
[13:20:30.288]                             sendCondition <<- function(cond) {
[13:20:30.288]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.288]                                 success = TRUE)
[13:20:30.288]                               parallel_sendData(master, data)
[13:20:30.288]                             }
[13:20:30.288]                             return(sendCondition)
[13:20:30.288]                           }
[13:20:30.288]                         }
[13:20:30.288]                         frame <- frame + 1L
[13:20:30.288]                         envir <- sys.frame(frame)
[13:20:30.288]                       }
[13:20:30.288]                     }
[13:20:30.288]                     sendCondition <<- function(cond) NULL
[13:20:30.288]                   }
[13:20:30.288]                 })
[13:20:30.288]                 withCallingHandlers({
[13:20:30.288]                   {
[13:20:30.288]                     4
[13:20:30.288]                   }
[13:20:30.288]                 }, immediateCondition = function(cond) {
[13:20:30.288]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.288]                   sendCondition(cond)
[13:20:30.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.288]                   {
[13:20:30.288]                     inherits <- base::inherits
[13:20:30.288]                     invokeRestart <- base::invokeRestart
[13:20:30.288]                     is.null <- base::is.null
[13:20:30.288]                     muffled <- FALSE
[13:20:30.288]                     if (inherits(cond, "message")) {
[13:20:30.288]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.288]                       if (muffled) 
[13:20:30.288]                         invokeRestart("muffleMessage")
[13:20:30.288]                     }
[13:20:30.288]                     else if (inherits(cond, "warning")) {
[13:20:30.288]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.288]                       if (muffled) 
[13:20:30.288]                         invokeRestart("muffleWarning")
[13:20:30.288]                     }
[13:20:30.288]                     else if (inherits(cond, "condition")) {
[13:20:30.288]                       if (!is.null(pattern)) {
[13:20:30.288]                         computeRestarts <- base::computeRestarts
[13:20:30.288]                         grepl <- base::grepl
[13:20:30.288]                         restarts <- computeRestarts(cond)
[13:20:30.288]                         for (restart in restarts) {
[13:20:30.288]                           name <- restart$name
[13:20:30.288]                           if (is.null(name)) 
[13:20:30.288]                             next
[13:20:30.288]                           if (!grepl(pattern, name)) 
[13:20:30.288]                             next
[13:20:30.288]                           invokeRestart(restart)
[13:20:30.288]                           muffled <- TRUE
[13:20:30.288]                           break
[13:20:30.288]                         }
[13:20:30.288]                       }
[13:20:30.288]                     }
[13:20:30.288]                     invisible(muffled)
[13:20:30.288]                   }
[13:20:30.288]                   muffleCondition(cond)
[13:20:30.288]                 })
[13:20:30.288]             }))
[13:20:30.288]             future::FutureResult(value = ...future.value$value, 
[13:20:30.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.288]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.288]                     ...future.globalenv.names))
[13:20:30.288]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.288]         }, condition = base::local({
[13:20:30.288]             c <- base::c
[13:20:30.288]             inherits <- base::inherits
[13:20:30.288]             invokeRestart <- base::invokeRestart
[13:20:30.288]             length <- base::length
[13:20:30.288]             list <- base::list
[13:20:30.288]             seq.int <- base::seq.int
[13:20:30.288]             signalCondition <- base::signalCondition
[13:20:30.288]             sys.calls <- base::sys.calls
[13:20:30.288]             `[[` <- base::`[[`
[13:20:30.288]             `+` <- base::`+`
[13:20:30.288]             `<<-` <- base::`<<-`
[13:20:30.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.288]                   3L)]
[13:20:30.288]             }
[13:20:30.288]             function(cond) {
[13:20:30.288]                 is_error <- inherits(cond, "error")
[13:20:30.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.288]                   NULL)
[13:20:30.288]                 if (is_error) {
[13:20:30.288]                   sessionInformation <- function() {
[13:20:30.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.288]                       search = base::search(), system = base::Sys.info())
[13:20:30.288]                   }
[13:20:30.288]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.288]                     cond$call), session = sessionInformation(), 
[13:20:30.288]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.288]                   signalCondition(cond)
[13:20:30.288]                 }
[13:20:30.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.288]                 "immediateCondition"))) {
[13:20:30.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.288]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.288]                   if (TRUE && !signal) {
[13:20:30.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.288]                     {
[13:20:30.288]                       inherits <- base::inherits
[13:20:30.288]                       invokeRestart <- base::invokeRestart
[13:20:30.288]                       is.null <- base::is.null
[13:20:30.288]                       muffled <- FALSE
[13:20:30.288]                       if (inherits(cond, "message")) {
[13:20:30.288]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.288]                         if (muffled) 
[13:20:30.288]                           invokeRestart("muffleMessage")
[13:20:30.288]                       }
[13:20:30.288]                       else if (inherits(cond, "warning")) {
[13:20:30.288]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.288]                         if (muffled) 
[13:20:30.288]                           invokeRestart("muffleWarning")
[13:20:30.288]                       }
[13:20:30.288]                       else if (inherits(cond, "condition")) {
[13:20:30.288]                         if (!is.null(pattern)) {
[13:20:30.288]                           computeRestarts <- base::computeRestarts
[13:20:30.288]                           grepl <- base::grepl
[13:20:30.288]                           restarts <- computeRestarts(cond)
[13:20:30.288]                           for (restart in restarts) {
[13:20:30.288]                             name <- restart$name
[13:20:30.288]                             if (is.null(name)) 
[13:20:30.288]                               next
[13:20:30.288]                             if (!grepl(pattern, name)) 
[13:20:30.288]                               next
[13:20:30.288]                             invokeRestart(restart)
[13:20:30.288]                             muffled <- TRUE
[13:20:30.288]                             break
[13:20:30.288]                           }
[13:20:30.288]                         }
[13:20:30.288]                       }
[13:20:30.288]                       invisible(muffled)
[13:20:30.288]                     }
[13:20:30.288]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.288]                   }
[13:20:30.288]                 }
[13:20:30.288]                 else {
[13:20:30.288]                   if (TRUE) {
[13:20:30.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.288]                     {
[13:20:30.288]                       inherits <- base::inherits
[13:20:30.288]                       invokeRestart <- base::invokeRestart
[13:20:30.288]                       is.null <- base::is.null
[13:20:30.288]                       muffled <- FALSE
[13:20:30.288]                       if (inherits(cond, "message")) {
[13:20:30.288]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.288]                         if (muffled) 
[13:20:30.288]                           invokeRestart("muffleMessage")
[13:20:30.288]                       }
[13:20:30.288]                       else if (inherits(cond, "warning")) {
[13:20:30.288]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.288]                         if (muffled) 
[13:20:30.288]                           invokeRestart("muffleWarning")
[13:20:30.288]                       }
[13:20:30.288]                       else if (inherits(cond, "condition")) {
[13:20:30.288]                         if (!is.null(pattern)) {
[13:20:30.288]                           computeRestarts <- base::computeRestarts
[13:20:30.288]                           grepl <- base::grepl
[13:20:30.288]                           restarts <- computeRestarts(cond)
[13:20:30.288]                           for (restart in restarts) {
[13:20:30.288]                             name <- restart$name
[13:20:30.288]                             if (is.null(name)) 
[13:20:30.288]                               next
[13:20:30.288]                             if (!grepl(pattern, name)) 
[13:20:30.288]                               next
[13:20:30.288]                             invokeRestart(restart)
[13:20:30.288]                             muffled <- TRUE
[13:20:30.288]                             break
[13:20:30.288]                           }
[13:20:30.288]                         }
[13:20:30.288]                       }
[13:20:30.288]                       invisible(muffled)
[13:20:30.288]                     }
[13:20:30.288]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.288]                   }
[13:20:30.288]                 }
[13:20:30.288]             }
[13:20:30.288]         }))
[13:20:30.288]     }, error = function(ex) {
[13:20:30.288]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.288]                 ...future.rng), started = ...future.startTime, 
[13:20:30.288]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.288]             version = "1.8"), class = "FutureResult")
[13:20:30.288]     }, finally = {
[13:20:30.288]         if (!identical(...future.workdir, getwd())) 
[13:20:30.288]             setwd(...future.workdir)
[13:20:30.288]         {
[13:20:30.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.288]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.288]             }
[13:20:30.288]             base::options(...future.oldOptions)
[13:20:30.288]             if (.Platform$OS.type == "windows") {
[13:20:30.288]                 old_names <- names(...future.oldEnvVars)
[13:20:30.288]                 envs <- base::Sys.getenv()
[13:20:30.288]                 names <- names(envs)
[13:20:30.288]                 common <- intersect(names, old_names)
[13:20:30.288]                 added <- setdiff(names, old_names)
[13:20:30.288]                 removed <- setdiff(old_names, names)
[13:20:30.288]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.288]                   envs[common]]
[13:20:30.288]                 NAMES <- toupper(changed)
[13:20:30.288]                 args <- list()
[13:20:30.288]                 for (kk in seq_along(NAMES)) {
[13:20:30.288]                   name <- changed[[kk]]
[13:20:30.288]                   NAME <- NAMES[[kk]]
[13:20:30.288]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.288]                     next
[13:20:30.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.288]                 }
[13:20:30.288]                 NAMES <- toupper(added)
[13:20:30.288]                 for (kk in seq_along(NAMES)) {
[13:20:30.288]                   name <- added[[kk]]
[13:20:30.288]                   NAME <- NAMES[[kk]]
[13:20:30.288]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.288]                     next
[13:20:30.288]                   args[[name]] <- ""
[13:20:30.288]                 }
[13:20:30.288]                 NAMES <- toupper(removed)
[13:20:30.288]                 for (kk in seq_along(NAMES)) {
[13:20:30.288]                   name <- removed[[kk]]
[13:20:30.288]                   NAME <- NAMES[[kk]]
[13:20:30.288]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.288]                     next
[13:20:30.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.288]                 }
[13:20:30.288]                 if (length(args) > 0) 
[13:20:30.288]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.288]             }
[13:20:30.288]             else {
[13:20:30.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.288]             }
[13:20:30.288]             {
[13:20:30.288]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.288]                   0L) {
[13:20:30.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.288]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.288]                   base::options(opts)
[13:20:30.288]                 }
[13:20:30.288]                 {
[13:20:30.288]                   {
[13:20:30.288]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.288]                     NULL
[13:20:30.288]                   }
[13:20:30.288]                   options(future.plan = NULL)
[13:20:30.288]                   if (is.na(NA_character_)) 
[13:20:30.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.288]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.288]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.288]                     envir = parent.frame()) 
[13:20:30.288]                   {
[13:20:30.288]                     if (is.function(workers)) 
[13:20:30.288]                       workers <- workers()
[13:20:30.288]                     workers <- structure(as.integer(workers), 
[13:20:30.288]                       class = class(workers))
[13:20:30.288]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.288]                       workers >= 1)
[13:20:30.288]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.288]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.288]                     }
[13:20:30.288]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.288]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.288]                       envir = envir)
[13:20:30.288]                     if (!future$lazy) 
[13:20:30.288]                       future <- run(future)
[13:20:30.288]                     invisible(future)
[13:20:30.288]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.288]                 }
[13:20:30.288]             }
[13:20:30.288]         }
[13:20:30.288]     })
[13:20:30.288]     if (TRUE) {
[13:20:30.288]         base::sink(type = "output", split = FALSE)
[13:20:30.288]         if (TRUE) {
[13:20:30.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.288]         }
[13:20:30.288]         else {
[13:20:30.288]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.288]         }
[13:20:30.288]         base::close(...future.stdout)
[13:20:30.288]         ...future.stdout <- NULL
[13:20:30.288]     }
[13:20:30.288]     ...future.result$conditions <- ...future.conditions
[13:20:30.288]     ...future.result$finished <- base::Sys.time()
[13:20:30.288]     ...future.result
[13:20:30.288] }
[13:20:30.291] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:30.301] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.302] - Validating connection of MultisessionFuture
[13:20:30.302] - received message: FutureResult
[13:20:30.302] - Received FutureResult
[13:20:30.302] - Erased future from FutureRegistry
[13:20:30.302] result() for ClusterFuture ...
[13:20:30.302] - result already collected: FutureResult
[13:20:30.302] result() for ClusterFuture ... done
[13:20:30.302] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:30.302] result() for ClusterFuture ...
[13:20:30.303] - result already collected: FutureResult
[13:20:30.303] result() for ClusterFuture ... done
[13:20:30.303] result() for ClusterFuture ...
[13:20:30.303] - result already collected: FutureResult
[13:20:30.303] result() for ClusterFuture ... done
[13:20:30.304] MultisessionFuture started
[13:20:30.304] - Launch lazy future ... done
[13:20:30.304] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55659da19fd0> 
Classes 'listenv', 'environment' <environment: 0x556599a93990> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:20:30.314] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.314] - Validating connection of MultisessionFuture
[13:20:30.314] - received message: FutureResult
[13:20:30.314] - Received FutureResult
[13:20:30.314] - Erased future from FutureRegistry
[13:20:30.314] result() for ClusterFuture ...
[13:20:30.315] - result already collected: FutureResult
[13:20:30.315] result() for ClusterFuture ... done
[13:20:30.315] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:30.328] resolve() on list environment ...
[13:20:30.328]  recursive: 0
[13:20:30.329]  length: 6
[13:20:30.329]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:30.329] signalConditionsASAP(numeric, pos=1) ...
[13:20:30.329] - nx: 6
[13:20:30.329] - relay: TRUE
[13:20:30.329] - stdout: TRUE
[13:20:30.330] - signal: TRUE
[13:20:30.330] - resignal: FALSE
[13:20:30.330] - force: TRUE
[13:20:30.330] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.330] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.330]  - until=2
[13:20:30.330]  - relaying element #2
[13:20:30.330] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.330] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.330] signalConditionsASAP(NULL, pos=1) ... done
[13:20:30.330]  length: 5 (resolved future 1)
[13:20:30.331] Future #2
[13:20:30.331] result() for ClusterFuture ...
[13:20:30.331] - result already collected: FutureResult
[13:20:30.331] result() for ClusterFuture ... done
[13:20:30.331] result() for ClusterFuture ...
[13:20:30.331] - result already collected: FutureResult
[13:20:30.331] result() for ClusterFuture ... done
[13:20:30.331] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:30.331] - nx: 6
[13:20:30.331] - relay: TRUE
[13:20:30.331] - stdout: TRUE
[13:20:30.332] - signal: TRUE
[13:20:30.332] - resignal: FALSE
[13:20:30.332] - force: TRUE
[13:20:30.332] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.332] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.332]  - until=2
[13:20:30.332]  - relaying element #2
[13:20:30.332] result() for ClusterFuture ...
[13:20:30.332] - result already collected: FutureResult
[13:20:30.332] result() for ClusterFuture ... done
[13:20:30.332] result() for ClusterFuture ...
[13:20:30.333] - result already collected: FutureResult
[13:20:30.333] result() for ClusterFuture ... done
[13:20:30.333] result() for ClusterFuture ...
[13:20:30.333] - result already collected: FutureResult
[13:20:30.333] result() for ClusterFuture ... done
[13:20:30.333] result() for ClusterFuture ...
[13:20:30.333] - result already collected: FutureResult
[13:20:30.333] result() for ClusterFuture ... done
[13:20:30.333] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.333] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.333] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:30.334]  length: 4 (resolved future 2)
[13:20:30.334] Future #3
[13:20:30.334] result() for ClusterFuture ...
[13:20:30.334] - result already collected: FutureResult
[13:20:30.334] result() for ClusterFuture ... done
[13:20:30.334] result() for ClusterFuture ...
[13:20:30.334] - result already collected: FutureResult
[13:20:30.334] result() for ClusterFuture ... done
[13:20:30.334] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:30.334] - nx: 6
[13:20:30.335] - relay: TRUE
[13:20:30.335] - stdout: TRUE
[13:20:30.335] - signal: TRUE
[13:20:30.335] - resignal: FALSE
[13:20:30.335] - force: TRUE
[13:20:30.335] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.335] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.335]  - until=3
[13:20:30.335]  - relaying element #3
[13:20:30.335] result() for ClusterFuture ...
[13:20:30.335] - result already collected: FutureResult
[13:20:30.336] result() for ClusterFuture ... done
[13:20:30.336] result() for ClusterFuture ...
[13:20:30.336] - result already collected: FutureResult
[13:20:30.336] result() for ClusterFuture ... done
[13:20:30.336] result() for ClusterFuture ...
[13:20:30.336] - result already collected: FutureResult
[13:20:30.336] result() for ClusterFuture ... done
[13:20:30.336] result() for ClusterFuture ...
[13:20:30.336] - result already collected: FutureResult
[13:20:30.336] result() for ClusterFuture ... done
[13:20:30.336] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.337] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.337] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:30.337]  length: 3 (resolved future 3)
[13:20:30.347] signalConditionsASAP(NULL, pos=5) ...
[13:20:30.347] - nx: 6
[13:20:30.348] - relay: TRUE
[13:20:30.348] - stdout: TRUE
[13:20:30.348] - signal: TRUE
[13:20:30.348] - resignal: FALSE
[13:20:30.348] - force: TRUE
[13:20:30.348] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.348] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.348]  - until=6
[13:20:30.348]  - relaying element #4
[13:20:30.348]  - relaying element #6
[13:20:30.349] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:20:30.349] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.349] signalConditionsASAP(NULL, pos=5) ... done
[13:20:30.349]  length: 2 (resolved future 5)
[13:20:30.349] signalConditionsASAP(numeric, pos=6) ...
[13:20:30.349] - nx: 6
[13:20:30.349] - relay: TRUE
[13:20:30.349] - stdout: TRUE
[13:20:30.349] - signal: TRUE
[13:20:30.349] - resignal: FALSE
[13:20:30.349] - force: TRUE
[13:20:30.350] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:20:30.350] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.350]  - until=6
[13:20:30.350]  - relaying element #4
[13:20:30.350] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:20:30.350] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.350] signalConditionsASAP(NULL, pos=6) ... done
[13:20:30.350]  length: 1 (resolved future 6)
[13:20:30.361] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.361] - Validating connection of MultisessionFuture
[13:20:30.361] - received message: FutureResult
[13:20:30.361] - Received FutureResult
[13:20:30.362] - Erased future from FutureRegistry
[13:20:30.362] result() for ClusterFuture ...
[13:20:30.362] - result already collected: FutureResult
[13:20:30.362] result() for ClusterFuture ... done
[13:20:30.362] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:30.362] Future #4
[13:20:30.362] result() for ClusterFuture ...
[13:20:30.362] - result already collected: FutureResult
[13:20:30.362] result() for ClusterFuture ... done
[13:20:30.362] result() for ClusterFuture ...
[13:20:30.363] - result already collected: FutureResult
[13:20:30.363] result() for ClusterFuture ... done
[13:20:30.363] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:20:30.363] - nx: 6
[13:20:30.363] - relay: TRUE
[13:20:30.363] - stdout: TRUE
[13:20:30.363] - signal: TRUE
[13:20:30.363] - resignal: FALSE
[13:20:30.363] - force: TRUE
[13:20:30.363] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:20:30.363] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.364]  - until=6
[13:20:30.364]  - relaying element #4
[13:20:30.364] result() for ClusterFuture ...
[13:20:30.364] - result already collected: FutureResult
[13:20:30.364] result() for ClusterFuture ... done
[13:20:30.364] result() for ClusterFuture ...
[13:20:30.364] - result already collected: FutureResult
[13:20:30.364] result() for ClusterFuture ... done
[13:20:30.364] result() for ClusterFuture ...
[13:20:30.364] - result already collected: FutureResult
[13:20:30.364] result() for ClusterFuture ... done
[13:20:30.365] result() for ClusterFuture ...
[13:20:30.365] - result already collected: FutureResult
[13:20:30.365] result() for ClusterFuture ... done
[13:20:30.365] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.365] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:30.365] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:20:30.365]  length: 0 (resolved future 4)
[13:20:30.365] Relaying remaining futures
[13:20:30.365] signalConditionsASAP(NULL, pos=0) ...
[13:20:30.366] - nx: 6
[13:20:30.366] - relay: TRUE
[13:20:30.366] - stdout: TRUE
[13:20:30.366] - signal: TRUE
[13:20:30.366] - resignal: FALSE
[13:20:30.366] - force: TRUE
[13:20:30.366] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.366] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:30.366] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.366] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:30.366] signalConditionsASAP(NULL, pos=0) ... done
[13:20:30.367] resolve() on list environment ... DONE
[13:20:30.367] result() for ClusterFuture ...
[13:20:30.367] - result already collected: FutureResult
[13:20:30.367] result() for ClusterFuture ... done
[13:20:30.367] result() for ClusterFuture ...
[13:20:30.367] - result already collected: FutureResult
[13:20:30.367] result() for ClusterFuture ... done
[13:20:30.367] result() for ClusterFuture ...
[13:20:30.367] - result already collected: FutureResult
[13:20:30.367] result() for ClusterFuture ... done
[13:20:30.368] result() for ClusterFuture ...
[13:20:30.368] - result already collected: FutureResult
[13:20:30.368] result() for ClusterFuture ... done
[13:20:30.368] result() for ClusterFuture ...
[13:20:30.368] - result already collected: FutureResult
[13:20:30.368] result() for ClusterFuture ... done
[13:20:30.368] result() for ClusterFuture ...
[13:20:30.368] - result already collected: FutureResult
[13:20:30.368] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55659cab67a8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:20:30.370] getGlobalsAndPackages() ...
[13:20:30.370] Searching for globals...
[13:20:30.371] 
[13:20:30.371] Searching for globals ... DONE
[13:20:30.371] - globals: [0] <none>
[13:20:30.371] getGlobalsAndPackages() ... DONE
[13:20:30.371] run() for ‘Future’ ...
[13:20:30.371] - state: ‘created’
[13:20:30.372] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.386] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.386]   - Field: ‘node’
[13:20:30.387]   - Field: ‘label’
[13:20:30.387]   - Field: ‘local’
[13:20:30.387]   - Field: ‘owner’
[13:20:30.387]   - Field: ‘envir’
[13:20:30.387]   - Field: ‘workers’
[13:20:30.387]   - Field: ‘packages’
[13:20:30.387]   - Field: ‘gc’
[13:20:30.387]   - Field: ‘conditions’
[13:20:30.387]   - Field: ‘persistent’
[13:20:30.387]   - Field: ‘expr’
[13:20:30.388]   - Field: ‘uuid’
[13:20:30.388]   - Field: ‘seed’
[13:20:30.388]   - Field: ‘version’
[13:20:30.388]   - Field: ‘result’
[13:20:30.388]   - Field: ‘asynchronous’
[13:20:30.388]   - Field: ‘calls’
[13:20:30.388]   - Field: ‘globals’
[13:20:30.388]   - Field: ‘stdout’
[13:20:30.388]   - Field: ‘earlySignal’
[13:20:30.388]   - Field: ‘lazy’
[13:20:30.388]   - Field: ‘state’
[13:20:30.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.389] - Launch lazy future ...
[13:20:30.389] Packages needed by the future expression (n = 0): <none>
[13:20:30.389] Packages needed by future strategies (n = 0): <none>
[13:20:30.390] {
[13:20:30.390]     {
[13:20:30.390]         {
[13:20:30.390]             ...future.startTime <- base::Sys.time()
[13:20:30.390]             {
[13:20:30.390]                 {
[13:20:30.390]                   {
[13:20:30.390]                     {
[13:20:30.390]                       base::local({
[13:20:30.390]                         has_future <- base::requireNamespace("future", 
[13:20:30.390]                           quietly = TRUE)
[13:20:30.390]                         if (has_future) {
[13:20:30.390]                           ns <- base::getNamespace("future")
[13:20:30.390]                           version <- ns[[".package"]][["version"]]
[13:20:30.390]                           if (is.null(version)) 
[13:20:30.390]                             version <- utils::packageVersion("future")
[13:20:30.390]                         }
[13:20:30.390]                         else {
[13:20:30.390]                           version <- NULL
[13:20:30.390]                         }
[13:20:30.390]                         if (!has_future || version < "1.8.0") {
[13:20:30.390]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.390]                             "", base::R.version$version.string), 
[13:20:30.390]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.390]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.390]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.390]                               "release", "version")], collapse = " "), 
[13:20:30.390]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.390]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.390]                             info)
[13:20:30.390]                           info <- base::paste(info, collapse = "; ")
[13:20:30.390]                           if (!has_future) {
[13:20:30.390]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.390]                               info)
[13:20:30.390]                           }
[13:20:30.390]                           else {
[13:20:30.390]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.390]                               info, version)
[13:20:30.390]                           }
[13:20:30.390]                           base::stop(msg)
[13:20:30.390]                         }
[13:20:30.390]                       })
[13:20:30.390]                     }
[13:20:30.390]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.390]                     base::options(mc.cores = 1L)
[13:20:30.390]                   }
[13:20:30.390]                   options(future.plan = NULL)
[13:20:30.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.390]                 }
[13:20:30.390]                 ...future.workdir <- getwd()
[13:20:30.390]             }
[13:20:30.390]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.390]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.390]         }
[13:20:30.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.390]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.390]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.390]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.390]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.390]             base::names(...future.oldOptions))
[13:20:30.390]     }
[13:20:30.390]     if (FALSE) {
[13:20:30.390]     }
[13:20:30.390]     else {
[13:20:30.390]         if (TRUE) {
[13:20:30.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.390]                 open = "w")
[13:20:30.390]         }
[13:20:30.390]         else {
[13:20:30.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.390]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.390]         }
[13:20:30.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.390]             base::sink(type = "output", split = FALSE)
[13:20:30.390]             base::close(...future.stdout)
[13:20:30.390]         }, add = TRUE)
[13:20:30.390]     }
[13:20:30.390]     ...future.frame <- base::sys.nframe()
[13:20:30.390]     ...future.conditions <- base::list()
[13:20:30.390]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.390]     if (FALSE) {
[13:20:30.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.390]     }
[13:20:30.390]     ...future.result <- base::tryCatch({
[13:20:30.390]         base::withCallingHandlers({
[13:20:30.390]             ...future.value <- base::withVisible(base::local({
[13:20:30.390]                 ...future.makeSendCondition <- local({
[13:20:30.390]                   sendCondition <- NULL
[13:20:30.390]                   function(frame = 1L) {
[13:20:30.390]                     if (is.function(sendCondition)) 
[13:20:30.390]                       return(sendCondition)
[13:20:30.390]                     ns <- getNamespace("parallel")
[13:20:30.390]                     if (exists("sendData", mode = "function", 
[13:20:30.390]                       envir = ns)) {
[13:20:30.390]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.390]                         envir = ns)
[13:20:30.390]                       envir <- sys.frame(frame)
[13:20:30.390]                       master <- NULL
[13:20:30.390]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.390]                         !identical(envir, emptyenv())) {
[13:20:30.390]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.390]                           inherits = FALSE)) {
[13:20:30.390]                           master <- get("master", mode = "list", 
[13:20:30.390]                             envir = envir, inherits = FALSE)
[13:20:30.390]                           if (inherits(master, c("SOCKnode", 
[13:20:30.390]                             "SOCK0node"))) {
[13:20:30.390]                             sendCondition <<- function(cond) {
[13:20:30.390]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.390]                                 success = TRUE)
[13:20:30.390]                               parallel_sendData(master, data)
[13:20:30.390]                             }
[13:20:30.390]                             return(sendCondition)
[13:20:30.390]                           }
[13:20:30.390]                         }
[13:20:30.390]                         frame <- frame + 1L
[13:20:30.390]                         envir <- sys.frame(frame)
[13:20:30.390]                       }
[13:20:30.390]                     }
[13:20:30.390]                     sendCondition <<- function(cond) NULL
[13:20:30.390]                   }
[13:20:30.390]                 })
[13:20:30.390]                 withCallingHandlers({
[13:20:30.390]                   2
[13:20:30.390]                 }, immediateCondition = function(cond) {
[13:20:30.390]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.390]                   sendCondition(cond)
[13:20:30.390]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.390]                   {
[13:20:30.390]                     inherits <- base::inherits
[13:20:30.390]                     invokeRestart <- base::invokeRestart
[13:20:30.390]                     is.null <- base::is.null
[13:20:30.390]                     muffled <- FALSE
[13:20:30.390]                     if (inherits(cond, "message")) {
[13:20:30.390]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.390]                       if (muffled) 
[13:20:30.390]                         invokeRestart("muffleMessage")
[13:20:30.390]                     }
[13:20:30.390]                     else if (inherits(cond, "warning")) {
[13:20:30.390]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.390]                       if (muffled) 
[13:20:30.390]                         invokeRestart("muffleWarning")
[13:20:30.390]                     }
[13:20:30.390]                     else if (inherits(cond, "condition")) {
[13:20:30.390]                       if (!is.null(pattern)) {
[13:20:30.390]                         computeRestarts <- base::computeRestarts
[13:20:30.390]                         grepl <- base::grepl
[13:20:30.390]                         restarts <- computeRestarts(cond)
[13:20:30.390]                         for (restart in restarts) {
[13:20:30.390]                           name <- restart$name
[13:20:30.390]                           if (is.null(name)) 
[13:20:30.390]                             next
[13:20:30.390]                           if (!grepl(pattern, name)) 
[13:20:30.390]                             next
[13:20:30.390]                           invokeRestart(restart)
[13:20:30.390]                           muffled <- TRUE
[13:20:30.390]                           break
[13:20:30.390]                         }
[13:20:30.390]                       }
[13:20:30.390]                     }
[13:20:30.390]                     invisible(muffled)
[13:20:30.390]                   }
[13:20:30.390]                   muffleCondition(cond)
[13:20:30.390]                 })
[13:20:30.390]             }))
[13:20:30.390]             future::FutureResult(value = ...future.value$value, 
[13:20:30.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.390]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.390]                     ...future.globalenv.names))
[13:20:30.390]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.390]         }, condition = base::local({
[13:20:30.390]             c <- base::c
[13:20:30.390]             inherits <- base::inherits
[13:20:30.390]             invokeRestart <- base::invokeRestart
[13:20:30.390]             length <- base::length
[13:20:30.390]             list <- base::list
[13:20:30.390]             seq.int <- base::seq.int
[13:20:30.390]             signalCondition <- base::signalCondition
[13:20:30.390]             sys.calls <- base::sys.calls
[13:20:30.390]             `[[` <- base::`[[`
[13:20:30.390]             `+` <- base::`+`
[13:20:30.390]             `<<-` <- base::`<<-`
[13:20:30.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.390]                   3L)]
[13:20:30.390]             }
[13:20:30.390]             function(cond) {
[13:20:30.390]                 is_error <- inherits(cond, "error")
[13:20:30.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.390]                   NULL)
[13:20:30.390]                 if (is_error) {
[13:20:30.390]                   sessionInformation <- function() {
[13:20:30.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.390]                       search = base::search(), system = base::Sys.info())
[13:20:30.390]                   }
[13:20:30.390]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.390]                     cond$call), session = sessionInformation(), 
[13:20:30.390]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.390]                   signalCondition(cond)
[13:20:30.390]                 }
[13:20:30.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.390]                 "immediateCondition"))) {
[13:20:30.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.390]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.390]                   if (TRUE && !signal) {
[13:20:30.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.390]                     {
[13:20:30.390]                       inherits <- base::inherits
[13:20:30.390]                       invokeRestart <- base::invokeRestart
[13:20:30.390]                       is.null <- base::is.null
[13:20:30.390]                       muffled <- FALSE
[13:20:30.390]                       if (inherits(cond, "message")) {
[13:20:30.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.390]                         if (muffled) 
[13:20:30.390]                           invokeRestart("muffleMessage")
[13:20:30.390]                       }
[13:20:30.390]                       else if (inherits(cond, "warning")) {
[13:20:30.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.390]                         if (muffled) 
[13:20:30.390]                           invokeRestart("muffleWarning")
[13:20:30.390]                       }
[13:20:30.390]                       else if (inherits(cond, "condition")) {
[13:20:30.390]                         if (!is.null(pattern)) {
[13:20:30.390]                           computeRestarts <- base::computeRestarts
[13:20:30.390]                           grepl <- base::grepl
[13:20:30.390]                           restarts <- computeRestarts(cond)
[13:20:30.390]                           for (restart in restarts) {
[13:20:30.390]                             name <- restart$name
[13:20:30.390]                             if (is.null(name)) 
[13:20:30.390]                               next
[13:20:30.390]                             if (!grepl(pattern, name)) 
[13:20:30.390]                               next
[13:20:30.390]                             invokeRestart(restart)
[13:20:30.390]                             muffled <- TRUE
[13:20:30.390]                             break
[13:20:30.390]                           }
[13:20:30.390]                         }
[13:20:30.390]                       }
[13:20:30.390]                       invisible(muffled)
[13:20:30.390]                     }
[13:20:30.390]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.390]                   }
[13:20:30.390]                 }
[13:20:30.390]                 else {
[13:20:30.390]                   if (TRUE) {
[13:20:30.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.390]                     {
[13:20:30.390]                       inherits <- base::inherits
[13:20:30.390]                       invokeRestart <- base::invokeRestart
[13:20:30.390]                       is.null <- base::is.null
[13:20:30.390]                       muffled <- FALSE
[13:20:30.390]                       if (inherits(cond, "message")) {
[13:20:30.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.390]                         if (muffled) 
[13:20:30.390]                           invokeRestart("muffleMessage")
[13:20:30.390]                       }
[13:20:30.390]                       else if (inherits(cond, "warning")) {
[13:20:30.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.390]                         if (muffled) 
[13:20:30.390]                           invokeRestart("muffleWarning")
[13:20:30.390]                       }
[13:20:30.390]                       else if (inherits(cond, "condition")) {
[13:20:30.390]                         if (!is.null(pattern)) {
[13:20:30.390]                           computeRestarts <- base::computeRestarts
[13:20:30.390]                           grepl <- base::grepl
[13:20:30.390]                           restarts <- computeRestarts(cond)
[13:20:30.390]                           for (restart in restarts) {
[13:20:30.390]                             name <- restart$name
[13:20:30.390]                             if (is.null(name)) 
[13:20:30.390]                               next
[13:20:30.390]                             if (!grepl(pattern, name)) 
[13:20:30.390]                               next
[13:20:30.390]                             invokeRestart(restart)
[13:20:30.390]                             muffled <- TRUE
[13:20:30.390]                             break
[13:20:30.390]                           }
[13:20:30.390]                         }
[13:20:30.390]                       }
[13:20:30.390]                       invisible(muffled)
[13:20:30.390]                     }
[13:20:30.390]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.390]                   }
[13:20:30.390]                 }
[13:20:30.390]             }
[13:20:30.390]         }))
[13:20:30.390]     }, error = function(ex) {
[13:20:30.390]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.390]                 ...future.rng), started = ...future.startTime, 
[13:20:30.390]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.390]             version = "1.8"), class = "FutureResult")
[13:20:30.390]     }, finally = {
[13:20:30.390]         if (!identical(...future.workdir, getwd())) 
[13:20:30.390]             setwd(...future.workdir)
[13:20:30.390]         {
[13:20:30.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.390]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.390]             }
[13:20:30.390]             base::options(...future.oldOptions)
[13:20:30.390]             if (.Platform$OS.type == "windows") {
[13:20:30.390]                 old_names <- names(...future.oldEnvVars)
[13:20:30.390]                 envs <- base::Sys.getenv()
[13:20:30.390]                 names <- names(envs)
[13:20:30.390]                 common <- intersect(names, old_names)
[13:20:30.390]                 added <- setdiff(names, old_names)
[13:20:30.390]                 removed <- setdiff(old_names, names)
[13:20:30.390]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.390]                   envs[common]]
[13:20:30.390]                 NAMES <- toupper(changed)
[13:20:30.390]                 args <- list()
[13:20:30.390]                 for (kk in seq_along(NAMES)) {
[13:20:30.390]                   name <- changed[[kk]]
[13:20:30.390]                   NAME <- NAMES[[kk]]
[13:20:30.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.390]                     next
[13:20:30.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.390]                 }
[13:20:30.390]                 NAMES <- toupper(added)
[13:20:30.390]                 for (kk in seq_along(NAMES)) {
[13:20:30.390]                   name <- added[[kk]]
[13:20:30.390]                   NAME <- NAMES[[kk]]
[13:20:30.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.390]                     next
[13:20:30.390]                   args[[name]] <- ""
[13:20:30.390]                 }
[13:20:30.390]                 NAMES <- toupper(removed)
[13:20:30.390]                 for (kk in seq_along(NAMES)) {
[13:20:30.390]                   name <- removed[[kk]]
[13:20:30.390]                   NAME <- NAMES[[kk]]
[13:20:30.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.390]                     next
[13:20:30.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.390]                 }
[13:20:30.390]                 if (length(args) > 0) 
[13:20:30.390]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.390]             }
[13:20:30.390]             else {
[13:20:30.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.390]             }
[13:20:30.390]             {
[13:20:30.390]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.390]                   0L) {
[13:20:30.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.390]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.390]                   base::options(opts)
[13:20:30.390]                 }
[13:20:30.390]                 {
[13:20:30.390]                   {
[13:20:30.390]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.390]                     NULL
[13:20:30.390]                   }
[13:20:30.390]                   options(future.plan = NULL)
[13:20:30.390]                   if (is.na(NA_character_)) 
[13:20:30.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.390]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.390]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.390]                     envir = parent.frame()) 
[13:20:30.390]                   {
[13:20:30.390]                     if (is.function(workers)) 
[13:20:30.390]                       workers <- workers()
[13:20:30.390]                     workers <- structure(as.integer(workers), 
[13:20:30.390]                       class = class(workers))
[13:20:30.390]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.390]                       workers >= 1)
[13:20:30.390]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.390]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.390]                     }
[13:20:30.390]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.390]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.390]                       envir = envir)
[13:20:30.390]                     if (!future$lazy) 
[13:20:30.390]                       future <- run(future)
[13:20:30.390]                     invisible(future)
[13:20:30.390]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.390]                 }
[13:20:30.390]             }
[13:20:30.390]         }
[13:20:30.390]     })
[13:20:30.390]     if (TRUE) {
[13:20:30.390]         base::sink(type = "output", split = FALSE)
[13:20:30.390]         if (TRUE) {
[13:20:30.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.390]         }
[13:20:30.390]         else {
[13:20:30.390]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.390]         }
[13:20:30.390]         base::close(...future.stdout)
[13:20:30.390]         ...future.stdout <- NULL
[13:20:30.390]     }
[13:20:30.390]     ...future.result$conditions <- ...future.conditions
[13:20:30.390]     ...future.result$finished <- base::Sys.time()
[13:20:30.390]     ...future.result
[13:20:30.390] }
[13:20:30.393] MultisessionFuture started
[13:20:30.393] - Launch lazy future ... done
[13:20:30.393] run() for ‘MultisessionFuture’ ... done
[13:20:30.393] getGlobalsAndPackages() ...
[13:20:30.394] Searching for globals...
[13:20:30.394] 
[13:20:30.394] Searching for globals ... DONE
[13:20:30.394] - globals: [0] <none>
[13:20:30.394] getGlobalsAndPackages() ... DONE
[13:20:30.394] run() for ‘Future’ ...
[13:20:30.394] - state: ‘created’
[13:20:30.395] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.412] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.412]   - Field: ‘node’
[13:20:30.413]   - Field: ‘label’
[13:20:30.413]   - Field: ‘local’
[13:20:30.413]   - Field: ‘owner’
[13:20:30.413]   - Field: ‘envir’
[13:20:30.413]   - Field: ‘workers’
[13:20:30.413]   - Field: ‘packages’
[13:20:30.413]   - Field: ‘gc’
[13:20:30.413]   - Field: ‘conditions’
[13:20:30.413]   - Field: ‘persistent’
[13:20:30.413]   - Field: ‘expr’
[13:20:30.414]   - Field: ‘uuid’
[13:20:30.414]   - Field: ‘seed’
[13:20:30.414]   - Field: ‘version’
[13:20:30.414]   - Field: ‘result’
[13:20:30.414]   - Field: ‘asynchronous’
[13:20:30.414]   - Field: ‘calls’
[13:20:30.414]   - Field: ‘globals’
[13:20:30.414]   - Field: ‘stdout’
[13:20:30.414]   - Field: ‘earlySignal’
[13:20:30.414]   - Field: ‘lazy’
[13:20:30.414]   - Field: ‘state’
[13:20:30.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.415] - Launch lazy future ...
[13:20:30.415] Packages needed by the future expression (n = 0): <none>
[13:20:30.415] Packages needed by future strategies (n = 0): <none>
[13:20:30.415] {
[13:20:30.415]     {
[13:20:30.415]         {
[13:20:30.415]             ...future.startTime <- base::Sys.time()
[13:20:30.415]             {
[13:20:30.415]                 {
[13:20:30.415]                   {
[13:20:30.415]                     {
[13:20:30.415]                       base::local({
[13:20:30.415]                         has_future <- base::requireNamespace("future", 
[13:20:30.415]                           quietly = TRUE)
[13:20:30.415]                         if (has_future) {
[13:20:30.415]                           ns <- base::getNamespace("future")
[13:20:30.415]                           version <- ns[[".package"]][["version"]]
[13:20:30.415]                           if (is.null(version)) 
[13:20:30.415]                             version <- utils::packageVersion("future")
[13:20:30.415]                         }
[13:20:30.415]                         else {
[13:20:30.415]                           version <- NULL
[13:20:30.415]                         }
[13:20:30.415]                         if (!has_future || version < "1.8.0") {
[13:20:30.415]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.415]                             "", base::R.version$version.string), 
[13:20:30.415]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.415]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.415]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.415]                               "release", "version")], collapse = " "), 
[13:20:30.415]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.415]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.415]                             info)
[13:20:30.415]                           info <- base::paste(info, collapse = "; ")
[13:20:30.415]                           if (!has_future) {
[13:20:30.415]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.415]                               info)
[13:20:30.415]                           }
[13:20:30.415]                           else {
[13:20:30.415]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.415]                               info, version)
[13:20:30.415]                           }
[13:20:30.415]                           base::stop(msg)
[13:20:30.415]                         }
[13:20:30.415]                       })
[13:20:30.415]                     }
[13:20:30.415]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.415]                     base::options(mc.cores = 1L)
[13:20:30.415]                   }
[13:20:30.415]                   options(future.plan = NULL)
[13:20:30.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.415]                 }
[13:20:30.415]                 ...future.workdir <- getwd()
[13:20:30.415]             }
[13:20:30.415]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.415]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.415]         }
[13:20:30.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.415]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.415]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.415]             base::names(...future.oldOptions))
[13:20:30.415]     }
[13:20:30.415]     if (FALSE) {
[13:20:30.415]     }
[13:20:30.415]     else {
[13:20:30.415]         if (TRUE) {
[13:20:30.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.415]                 open = "w")
[13:20:30.415]         }
[13:20:30.415]         else {
[13:20:30.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.415]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.415]         }
[13:20:30.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.415]             base::sink(type = "output", split = FALSE)
[13:20:30.415]             base::close(...future.stdout)
[13:20:30.415]         }, add = TRUE)
[13:20:30.415]     }
[13:20:30.415]     ...future.frame <- base::sys.nframe()
[13:20:30.415]     ...future.conditions <- base::list()
[13:20:30.415]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.415]     if (FALSE) {
[13:20:30.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.415]     }
[13:20:30.415]     ...future.result <- base::tryCatch({
[13:20:30.415]         base::withCallingHandlers({
[13:20:30.415]             ...future.value <- base::withVisible(base::local({
[13:20:30.415]                 ...future.makeSendCondition <- local({
[13:20:30.415]                   sendCondition <- NULL
[13:20:30.415]                   function(frame = 1L) {
[13:20:30.415]                     if (is.function(sendCondition)) 
[13:20:30.415]                       return(sendCondition)
[13:20:30.415]                     ns <- getNamespace("parallel")
[13:20:30.415]                     if (exists("sendData", mode = "function", 
[13:20:30.415]                       envir = ns)) {
[13:20:30.415]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.415]                         envir = ns)
[13:20:30.415]                       envir <- sys.frame(frame)
[13:20:30.415]                       master <- NULL
[13:20:30.415]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.415]                         !identical(envir, emptyenv())) {
[13:20:30.415]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.415]                           inherits = FALSE)) {
[13:20:30.415]                           master <- get("master", mode = "list", 
[13:20:30.415]                             envir = envir, inherits = FALSE)
[13:20:30.415]                           if (inherits(master, c("SOCKnode", 
[13:20:30.415]                             "SOCK0node"))) {
[13:20:30.415]                             sendCondition <<- function(cond) {
[13:20:30.415]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.415]                                 success = TRUE)
[13:20:30.415]                               parallel_sendData(master, data)
[13:20:30.415]                             }
[13:20:30.415]                             return(sendCondition)
[13:20:30.415]                           }
[13:20:30.415]                         }
[13:20:30.415]                         frame <- frame + 1L
[13:20:30.415]                         envir <- sys.frame(frame)
[13:20:30.415]                       }
[13:20:30.415]                     }
[13:20:30.415]                     sendCondition <<- function(cond) NULL
[13:20:30.415]                   }
[13:20:30.415]                 })
[13:20:30.415]                 withCallingHandlers({
[13:20:30.415]                   NULL
[13:20:30.415]                 }, immediateCondition = function(cond) {
[13:20:30.415]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.415]                   sendCondition(cond)
[13:20:30.415]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.415]                   {
[13:20:30.415]                     inherits <- base::inherits
[13:20:30.415]                     invokeRestart <- base::invokeRestart
[13:20:30.415]                     is.null <- base::is.null
[13:20:30.415]                     muffled <- FALSE
[13:20:30.415]                     if (inherits(cond, "message")) {
[13:20:30.415]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.415]                       if (muffled) 
[13:20:30.415]                         invokeRestart("muffleMessage")
[13:20:30.415]                     }
[13:20:30.415]                     else if (inherits(cond, "warning")) {
[13:20:30.415]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.415]                       if (muffled) 
[13:20:30.415]                         invokeRestart("muffleWarning")
[13:20:30.415]                     }
[13:20:30.415]                     else if (inherits(cond, "condition")) {
[13:20:30.415]                       if (!is.null(pattern)) {
[13:20:30.415]                         computeRestarts <- base::computeRestarts
[13:20:30.415]                         grepl <- base::grepl
[13:20:30.415]                         restarts <- computeRestarts(cond)
[13:20:30.415]                         for (restart in restarts) {
[13:20:30.415]                           name <- restart$name
[13:20:30.415]                           if (is.null(name)) 
[13:20:30.415]                             next
[13:20:30.415]                           if (!grepl(pattern, name)) 
[13:20:30.415]                             next
[13:20:30.415]                           invokeRestart(restart)
[13:20:30.415]                           muffled <- TRUE
[13:20:30.415]                           break
[13:20:30.415]                         }
[13:20:30.415]                       }
[13:20:30.415]                     }
[13:20:30.415]                     invisible(muffled)
[13:20:30.415]                   }
[13:20:30.415]                   muffleCondition(cond)
[13:20:30.415]                 })
[13:20:30.415]             }))
[13:20:30.415]             future::FutureResult(value = ...future.value$value, 
[13:20:30.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.415]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.415]                     ...future.globalenv.names))
[13:20:30.415]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.415]         }, condition = base::local({
[13:20:30.415]             c <- base::c
[13:20:30.415]             inherits <- base::inherits
[13:20:30.415]             invokeRestart <- base::invokeRestart
[13:20:30.415]             length <- base::length
[13:20:30.415]             list <- base::list
[13:20:30.415]             seq.int <- base::seq.int
[13:20:30.415]             signalCondition <- base::signalCondition
[13:20:30.415]             sys.calls <- base::sys.calls
[13:20:30.415]             `[[` <- base::`[[`
[13:20:30.415]             `+` <- base::`+`
[13:20:30.415]             `<<-` <- base::`<<-`
[13:20:30.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.415]                   3L)]
[13:20:30.415]             }
[13:20:30.415]             function(cond) {
[13:20:30.415]                 is_error <- inherits(cond, "error")
[13:20:30.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.415]                   NULL)
[13:20:30.415]                 if (is_error) {
[13:20:30.415]                   sessionInformation <- function() {
[13:20:30.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.415]                       search = base::search(), system = base::Sys.info())
[13:20:30.415]                   }
[13:20:30.415]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.415]                     cond$call), session = sessionInformation(), 
[13:20:30.415]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.415]                   signalCondition(cond)
[13:20:30.415]                 }
[13:20:30.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.415]                 "immediateCondition"))) {
[13:20:30.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.415]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.415]                   if (TRUE && !signal) {
[13:20:30.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.415]                     {
[13:20:30.415]                       inherits <- base::inherits
[13:20:30.415]                       invokeRestart <- base::invokeRestart
[13:20:30.415]                       is.null <- base::is.null
[13:20:30.415]                       muffled <- FALSE
[13:20:30.415]                       if (inherits(cond, "message")) {
[13:20:30.415]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.415]                         if (muffled) 
[13:20:30.415]                           invokeRestart("muffleMessage")
[13:20:30.415]                       }
[13:20:30.415]                       else if (inherits(cond, "warning")) {
[13:20:30.415]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.415]                         if (muffled) 
[13:20:30.415]                           invokeRestart("muffleWarning")
[13:20:30.415]                       }
[13:20:30.415]                       else if (inherits(cond, "condition")) {
[13:20:30.415]                         if (!is.null(pattern)) {
[13:20:30.415]                           computeRestarts <- base::computeRestarts
[13:20:30.415]                           grepl <- base::grepl
[13:20:30.415]                           restarts <- computeRestarts(cond)
[13:20:30.415]                           for (restart in restarts) {
[13:20:30.415]                             name <- restart$name
[13:20:30.415]                             if (is.null(name)) 
[13:20:30.415]                               next
[13:20:30.415]                             if (!grepl(pattern, name)) 
[13:20:30.415]                               next
[13:20:30.415]                             invokeRestart(restart)
[13:20:30.415]                             muffled <- TRUE
[13:20:30.415]                             break
[13:20:30.415]                           }
[13:20:30.415]                         }
[13:20:30.415]                       }
[13:20:30.415]                       invisible(muffled)
[13:20:30.415]                     }
[13:20:30.415]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.415]                   }
[13:20:30.415]                 }
[13:20:30.415]                 else {
[13:20:30.415]                   if (TRUE) {
[13:20:30.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.415]                     {
[13:20:30.415]                       inherits <- base::inherits
[13:20:30.415]                       invokeRestart <- base::invokeRestart
[13:20:30.415]                       is.null <- base::is.null
[13:20:30.415]                       muffled <- FALSE
[13:20:30.415]                       if (inherits(cond, "message")) {
[13:20:30.415]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.415]                         if (muffled) 
[13:20:30.415]                           invokeRestart("muffleMessage")
[13:20:30.415]                       }
[13:20:30.415]                       else if (inherits(cond, "warning")) {
[13:20:30.415]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.415]                         if (muffled) 
[13:20:30.415]                           invokeRestart("muffleWarning")
[13:20:30.415]                       }
[13:20:30.415]                       else if (inherits(cond, "condition")) {
[13:20:30.415]                         if (!is.null(pattern)) {
[13:20:30.415]                           computeRestarts <- base::computeRestarts
[13:20:30.415]                           grepl <- base::grepl
[13:20:30.415]                           restarts <- computeRestarts(cond)
[13:20:30.415]                           for (restart in restarts) {
[13:20:30.415]                             name <- restart$name
[13:20:30.415]                             if (is.null(name)) 
[13:20:30.415]                               next
[13:20:30.415]                             if (!grepl(pattern, name)) 
[13:20:30.415]                               next
[13:20:30.415]                             invokeRestart(restart)
[13:20:30.415]                             muffled <- TRUE
[13:20:30.415]                             break
[13:20:30.415]                           }
[13:20:30.415]                         }
[13:20:30.415]                       }
[13:20:30.415]                       invisible(muffled)
[13:20:30.415]                     }
[13:20:30.415]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.415]                   }
[13:20:30.415]                 }
[13:20:30.415]             }
[13:20:30.415]         }))
[13:20:30.415]     }, error = function(ex) {
[13:20:30.415]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.415]                 ...future.rng), started = ...future.startTime, 
[13:20:30.415]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.415]             version = "1.8"), class = "FutureResult")
[13:20:30.415]     }, finally = {
[13:20:30.415]         if (!identical(...future.workdir, getwd())) 
[13:20:30.415]             setwd(...future.workdir)
[13:20:30.415]         {
[13:20:30.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.415]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.415]             }
[13:20:30.415]             base::options(...future.oldOptions)
[13:20:30.415]             if (.Platform$OS.type == "windows") {
[13:20:30.415]                 old_names <- names(...future.oldEnvVars)
[13:20:30.415]                 envs <- base::Sys.getenv()
[13:20:30.415]                 names <- names(envs)
[13:20:30.415]                 common <- intersect(names, old_names)
[13:20:30.415]                 added <- setdiff(names, old_names)
[13:20:30.415]                 removed <- setdiff(old_names, names)
[13:20:30.415]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.415]                   envs[common]]
[13:20:30.415]                 NAMES <- toupper(changed)
[13:20:30.415]                 args <- list()
[13:20:30.415]                 for (kk in seq_along(NAMES)) {
[13:20:30.415]                   name <- changed[[kk]]
[13:20:30.415]                   NAME <- NAMES[[kk]]
[13:20:30.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.415]                     next
[13:20:30.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.415]                 }
[13:20:30.415]                 NAMES <- toupper(added)
[13:20:30.415]                 for (kk in seq_along(NAMES)) {
[13:20:30.415]                   name <- added[[kk]]
[13:20:30.415]                   NAME <- NAMES[[kk]]
[13:20:30.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.415]                     next
[13:20:30.415]                   args[[name]] <- ""
[13:20:30.415]                 }
[13:20:30.415]                 NAMES <- toupper(removed)
[13:20:30.415]                 for (kk in seq_along(NAMES)) {
[13:20:30.415]                   name <- removed[[kk]]
[13:20:30.415]                   NAME <- NAMES[[kk]]
[13:20:30.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.415]                     next
[13:20:30.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.415]                 }
[13:20:30.415]                 if (length(args) > 0) 
[13:20:30.415]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.415]             }
[13:20:30.415]             else {
[13:20:30.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.415]             }
[13:20:30.415]             {
[13:20:30.415]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.415]                   0L) {
[13:20:30.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.415]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.415]                   base::options(opts)
[13:20:30.415]                 }
[13:20:30.415]                 {
[13:20:30.415]                   {
[13:20:30.415]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.415]                     NULL
[13:20:30.415]                   }
[13:20:30.415]                   options(future.plan = NULL)
[13:20:30.415]                   if (is.na(NA_character_)) 
[13:20:30.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.415]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.415]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.415]                     envir = parent.frame()) 
[13:20:30.415]                   {
[13:20:30.415]                     if (is.function(workers)) 
[13:20:30.415]                       workers <- workers()
[13:20:30.415]                     workers <- structure(as.integer(workers), 
[13:20:30.415]                       class = class(workers))
[13:20:30.415]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.415]                       workers >= 1)
[13:20:30.415]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.415]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.415]                     }
[13:20:30.415]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.415]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.415]                       envir = envir)
[13:20:30.415]                     if (!future$lazy) 
[13:20:30.415]                       future <- run(future)
[13:20:30.415]                     invisible(future)
[13:20:30.415]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.415]                 }
[13:20:30.415]             }
[13:20:30.415]         }
[13:20:30.415]     })
[13:20:30.415]     if (TRUE) {
[13:20:30.415]         base::sink(type = "output", split = FALSE)
[13:20:30.415]         if (TRUE) {
[13:20:30.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.415]         }
[13:20:30.415]         else {
[13:20:30.415]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.415]         }
[13:20:30.415]         base::close(...future.stdout)
[13:20:30.415]         ...future.stdout <- NULL
[13:20:30.415]     }
[13:20:30.415]     ...future.result$conditions <- ...future.conditions
[13:20:30.415]     ...future.result$finished <- base::Sys.time()
[13:20:30.415]     ...future.result
[13:20:30.415] }
[13:20:30.419] MultisessionFuture started
[13:20:30.419] - Launch lazy future ... done
[13:20:30.419] run() for ‘MultisessionFuture’ ... done
[13:20:30.419] getGlobalsAndPackages() ...
[13:20:30.419] Searching for globals...
[13:20:30.420] - globals found: [1] ‘{’
[13:20:30.420] Searching for globals ... DONE
[13:20:30.420] Resolving globals: FALSE
[13:20:30.421] 
[13:20:30.421] 
[13:20:30.421] getGlobalsAndPackages() ... DONE
[13:20:30.421] run() for ‘Future’ ...
[13:20:30.421] - state: ‘created’
[13:20:30.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.435] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.435]   - Field: ‘node’
[13:20:30.436]   - Field: ‘label’
[13:20:30.436]   - Field: ‘local’
[13:20:30.436]   - Field: ‘owner’
[13:20:30.436]   - Field: ‘envir’
[13:20:30.436]   - Field: ‘workers’
[13:20:30.436]   - Field: ‘packages’
[13:20:30.436]   - Field: ‘gc’
[13:20:30.436]   - Field: ‘conditions’
[13:20:30.436]   - Field: ‘persistent’
[13:20:30.436]   - Field: ‘expr’
[13:20:30.437]   - Field: ‘uuid’
[13:20:30.437]   - Field: ‘seed’
[13:20:30.437]   - Field: ‘version’
[13:20:30.437]   - Field: ‘result’
[13:20:30.437]   - Field: ‘asynchronous’
[13:20:30.437]   - Field: ‘calls’
[13:20:30.438]   - Field: ‘globals’
[13:20:30.438]   - Field: ‘stdout’
[13:20:30.438]   - Field: ‘earlySignal’
[13:20:30.438]   - Field: ‘lazy’
[13:20:30.438]   - Field: ‘state’
[13:20:30.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.438] - Launch lazy future ...
[13:20:30.439] Packages needed by the future expression (n = 0): <none>
[13:20:30.439] Packages needed by future strategies (n = 0): <none>
[13:20:30.440] {
[13:20:30.440]     {
[13:20:30.440]         {
[13:20:30.440]             ...future.startTime <- base::Sys.time()
[13:20:30.440]             {
[13:20:30.440]                 {
[13:20:30.440]                   {
[13:20:30.440]                     {
[13:20:30.440]                       base::local({
[13:20:30.440]                         has_future <- base::requireNamespace("future", 
[13:20:30.440]                           quietly = TRUE)
[13:20:30.440]                         if (has_future) {
[13:20:30.440]                           ns <- base::getNamespace("future")
[13:20:30.440]                           version <- ns[[".package"]][["version"]]
[13:20:30.440]                           if (is.null(version)) 
[13:20:30.440]                             version <- utils::packageVersion("future")
[13:20:30.440]                         }
[13:20:30.440]                         else {
[13:20:30.440]                           version <- NULL
[13:20:30.440]                         }
[13:20:30.440]                         if (!has_future || version < "1.8.0") {
[13:20:30.440]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.440]                             "", base::R.version$version.string), 
[13:20:30.440]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.440]                               "release", "version")], collapse = " "), 
[13:20:30.440]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.440]                             info)
[13:20:30.440]                           info <- base::paste(info, collapse = "; ")
[13:20:30.440]                           if (!has_future) {
[13:20:30.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.440]                               info)
[13:20:30.440]                           }
[13:20:30.440]                           else {
[13:20:30.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.440]                               info, version)
[13:20:30.440]                           }
[13:20:30.440]                           base::stop(msg)
[13:20:30.440]                         }
[13:20:30.440]                       })
[13:20:30.440]                     }
[13:20:30.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.440]                     base::options(mc.cores = 1L)
[13:20:30.440]                   }
[13:20:30.440]                   options(future.plan = NULL)
[13:20:30.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.440]                 }
[13:20:30.440]                 ...future.workdir <- getwd()
[13:20:30.440]             }
[13:20:30.440]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.440]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.440]         }
[13:20:30.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.440]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.440]             base::names(...future.oldOptions))
[13:20:30.440]     }
[13:20:30.440]     if (FALSE) {
[13:20:30.440]     }
[13:20:30.440]     else {
[13:20:30.440]         if (TRUE) {
[13:20:30.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.440]                 open = "w")
[13:20:30.440]         }
[13:20:30.440]         else {
[13:20:30.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.440]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.440]         }
[13:20:30.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.440]             base::sink(type = "output", split = FALSE)
[13:20:30.440]             base::close(...future.stdout)
[13:20:30.440]         }, add = TRUE)
[13:20:30.440]     }
[13:20:30.440]     ...future.frame <- base::sys.nframe()
[13:20:30.440]     ...future.conditions <- base::list()
[13:20:30.440]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.440]     if (FALSE) {
[13:20:30.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.440]     }
[13:20:30.440]     ...future.result <- base::tryCatch({
[13:20:30.440]         base::withCallingHandlers({
[13:20:30.440]             ...future.value <- base::withVisible(base::local({
[13:20:30.440]                 ...future.makeSendCondition <- local({
[13:20:30.440]                   sendCondition <- NULL
[13:20:30.440]                   function(frame = 1L) {
[13:20:30.440]                     if (is.function(sendCondition)) 
[13:20:30.440]                       return(sendCondition)
[13:20:30.440]                     ns <- getNamespace("parallel")
[13:20:30.440]                     if (exists("sendData", mode = "function", 
[13:20:30.440]                       envir = ns)) {
[13:20:30.440]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.440]                         envir = ns)
[13:20:30.440]                       envir <- sys.frame(frame)
[13:20:30.440]                       master <- NULL
[13:20:30.440]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.440]                         !identical(envir, emptyenv())) {
[13:20:30.440]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.440]                           inherits = FALSE)) {
[13:20:30.440]                           master <- get("master", mode = "list", 
[13:20:30.440]                             envir = envir, inherits = FALSE)
[13:20:30.440]                           if (inherits(master, c("SOCKnode", 
[13:20:30.440]                             "SOCK0node"))) {
[13:20:30.440]                             sendCondition <<- function(cond) {
[13:20:30.440]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.440]                                 success = TRUE)
[13:20:30.440]                               parallel_sendData(master, data)
[13:20:30.440]                             }
[13:20:30.440]                             return(sendCondition)
[13:20:30.440]                           }
[13:20:30.440]                         }
[13:20:30.440]                         frame <- frame + 1L
[13:20:30.440]                         envir <- sys.frame(frame)
[13:20:30.440]                       }
[13:20:30.440]                     }
[13:20:30.440]                     sendCondition <<- function(cond) NULL
[13:20:30.440]                   }
[13:20:30.440]                 })
[13:20:30.440]                 withCallingHandlers({
[13:20:30.440]                   {
[13:20:30.440]                     4
[13:20:30.440]                   }
[13:20:30.440]                 }, immediateCondition = function(cond) {
[13:20:30.440]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.440]                   sendCondition(cond)
[13:20:30.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.440]                   {
[13:20:30.440]                     inherits <- base::inherits
[13:20:30.440]                     invokeRestart <- base::invokeRestart
[13:20:30.440]                     is.null <- base::is.null
[13:20:30.440]                     muffled <- FALSE
[13:20:30.440]                     if (inherits(cond, "message")) {
[13:20:30.440]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.440]                       if (muffled) 
[13:20:30.440]                         invokeRestart("muffleMessage")
[13:20:30.440]                     }
[13:20:30.440]                     else if (inherits(cond, "warning")) {
[13:20:30.440]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.440]                       if (muffled) 
[13:20:30.440]                         invokeRestart("muffleWarning")
[13:20:30.440]                     }
[13:20:30.440]                     else if (inherits(cond, "condition")) {
[13:20:30.440]                       if (!is.null(pattern)) {
[13:20:30.440]                         computeRestarts <- base::computeRestarts
[13:20:30.440]                         grepl <- base::grepl
[13:20:30.440]                         restarts <- computeRestarts(cond)
[13:20:30.440]                         for (restart in restarts) {
[13:20:30.440]                           name <- restart$name
[13:20:30.440]                           if (is.null(name)) 
[13:20:30.440]                             next
[13:20:30.440]                           if (!grepl(pattern, name)) 
[13:20:30.440]                             next
[13:20:30.440]                           invokeRestart(restart)
[13:20:30.440]                           muffled <- TRUE
[13:20:30.440]                           break
[13:20:30.440]                         }
[13:20:30.440]                       }
[13:20:30.440]                     }
[13:20:30.440]                     invisible(muffled)
[13:20:30.440]                   }
[13:20:30.440]                   muffleCondition(cond)
[13:20:30.440]                 })
[13:20:30.440]             }))
[13:20:30.440]             future::FutureResult(value = ...future.value$value, 
[13:20:30.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.440]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.440]                     ...future.globalenv.names))
[13:20:30.440]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.440]         }, condition = base::local({
[13:20:30.440]             c <- base::c
[13:20:30.440]             inherits <- base::inherits
[13:20:30.440]             invokeRestart <- base::invokeRestart
[13:20:30.440]             length <- base::length
[13:20:30.440]             list <- base::list
[13:20:30.440]             seq.int <- base::seq.int
[13:20:30.440]             signalCondition <- base::signalCondition
[13:20:30.440]             sys.calls <- base::sys.calls
[13:20:30.440]             `[[` <- base::`[[`
[13:20:30.440]             `+` <- base::`+`
[13:20:30.440]             `<<-` <- base::`<<-`
[13:20:30.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.440]                   3L)]
[13:20:30.440]             }
[13:20:30.440]             function(cond) {
[13:20:30.440]                 is_error <- inherits(cond, "error")
[13:20:30.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.440]                   NULL)
[13:20:30.440]                 if (is_error) {
[13:20:30.440]                   sessionInformation <- function() {
[13:20:30.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.440]                       search = base::search(), system = base::Sys.info())
[13:20:30.440]                   }
[13:20:30.440]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.440]                     cond$call), session = sessionInformation(), 
[13:20:30.440]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.440]                   signalCondition(cond)
[13:20:30.440]                 }
[13:20:30.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.440]                 "immediateCondition"))) {
[13:20:30.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.440]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.440]                   if (TRUE && !signal) {
[13:20:30.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.440]                     {
[13:20:30.440]                       inherits <- base::inherits
[13:20:30.440]                       invokeRestart <- base::invokeRestart
[13:20:30.440]                       is.null <- base::is.null
[13:20:30.440]                       muffled <- FALSE
[13:20:30.440]                       if (inherits(cond, "message")) {
[13:20:30.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.440]                         if (muffled) 
[13:20:30.440]                           invokeRestart("muffleMessage")
[13:20:30.440]                       }
[13:20:30.440]                       else if (inherits(cond, "warning")) {
[13:20:30.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.440]                         if (muffled) 
[13:20:30.440]                           invokeRestart("muffleWarning")
[13:20:30.440]                       }
[13:20:30.440]                       else if (inherits(cond, "condition")) {
[13:20:30.440]                         if (!is.null(pattern)) {
[13:20:30.440]                           computeRestarts <- base::computeRestarts
[13:20:30.440]                           grepl <- base::grepl
[13:20:30.440]                           restarts <- computeRestarts(cond)
[13:20:30.440]                           for (restart in restarts) {
[13:20:30.440]                             name <- restart$name
[13:20:30.440]                             if (is.null(name)) 
[13:20:30.440]                               next
[13:20:30.440]                             if (!grepl(pattern, name)) 
[13:20:30.440]                               next
[13:20:30.440]                             invokeRestart(restart)
[13:20:30.440]                             muffled <- TRUE
[13:20:30.440]                             break
[13:20:30.440]                           }
[13:20:30.440]                         }
[13:20:30.440]                       }
[13:20:30.440]                       invisible(muffled)
[13:20:30.440]                     }
[13:20:30.440]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.440]                   }
[13:20:30.440]                 }
[13:20:30.440]                 else {
[13:20:30.440]                   if (TRUE) {
[13:20:30.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.440]                     {
[13:20:30.440]                       inherits <- base::inherits
[13:20:30.440]                       invokeRestart <- base::invokeRestart
[13:20:30.440]                       is.null <- base::is.null
[13:20:30.440]                       muffled <- FALSE
[13:20:30.440]                       if (inherits(cond, "message")) {
[13:20:30.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.440]                         if (muffled) 
[13:20:30.440]                           invokeRestart("muffleMessage")
[13:20:30.440]                       }
[13:20:30.440]                       else if (inherits(cond, "warning")) {
[13:20:30.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.440]                         if (muffled) 
[13:20:30.440]                           invokeRestart("muffleWarning")
[13:20:30.440]                       }
[13:20:30.440]                       else if (inherits(cond, "condition")) {
[13:20:30.440]                         if (!is.null(pattern)) {
[13:20:30.440]                           computeRestarts <- base::computeRestarts
[13:20:30.440]                           grepl <- base::grepl
[13:20:30.440]                           restarts <- computeRestarts(cond)
[13:20:30.440]                           for (restart in restarts) {
[13:20:30.440]                             name <- restart$name
[13:20:30.440]                             if (is.null(name)) 
[13:20:30.440]                               next
[13:20:30.440]                             if (!grepl(pattern, name)) 
[13:20:30.440]                               next
[13:20:30.440]                             invokeRestart(restart)
[13:20:30.440]                             muffled <- TRUE
[13:20:30.440]                             break
[13:20:30.440]                           }
[13:20:30.440]                         }
[13:20:30.440]                       }
[13:20:30.440]                       invisible(muffled)
[13:20:30.440]                     }
[13:20:30.440]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.440]                   }
[13:20:30.440]                 }
[13:20:30.440]             }
[13:20:30.440]         }))
[13:20:30.440]     }, error = function(ex) {
[13:20:30.440]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.440]                 ...future.rng), started = ...future.startTime, 
[13:20:30.440]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.440]             version = "1.8"), class = "FutureResult")
[13:20:30.440]     }, finally = {
[13:20:30.440]         if (!identical(...future.workdir, getwd())) 
[13:20:30.440]             setwd(...future.workdir)
[13:20:30.440]         {
[13:20:30.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.440]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.440]             }
[13:20:30.440]             base::options(...future.oldOptions)
[13:20:30.440]             if (.Platform$OS.type == "windows") {
[13:20:30.440]                 old_names <- names(...future.oldEnvVars)
[13:20:30.440]                 envs <- base::Sys.getenv()
[13:20:30.440]                 names <- names(envs)
[13:20:30.440]                 common <- intersect(names, old_names)
[13:20:30.440]                 added <- setdiff(names, old_names)
[13:20:30.440]                 removed <- setdiff(old_names, names)
[13:20:30.440]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.440]                   envs[common]]
[13:20:30.440]                 NAMES <- toupper(changed)
[13:20:30.440]                 args <- list()
[13:20:30.440]                 for (kk in seq_along(NAMES)) {
[13:20:30.440]                   name <- changed[[kk]]
[13:20:30.440]                   NAME <- NAMES[[kk]]
[13:20:30.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.440]                     next
[13:20:30.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.440]                 }
[13:20:30.440]                 NAMES <- toupper(added)
[13:20:30.440]                 for (kk in seq_along(NAMES)) {
[13:20:30.440]                   name <- added[[kk]]
[13:20:30.440]                   NAME <- NAMES[[kk]]
[13:20:30.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.440]                     next
[13:20:30.440]                   args[[name]] <- ""
[13:20:30.440]                 }
[13:20:30.440]                 NAMES <- toupper(removed)
[13:20:30.440]                 for (kk in seq_along(NAMES)) {
[13:20:30.440]                   name <- removed[[kk]]
[13:20:30.440]                   NAME <- NAMES[[kk]]
[13:20:30.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.440]                     next
[13:20:30.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.440]                 }
[13:20:30.440]                 if (length(args) > 0) 
[13:20:30.440]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.440]             }
[13:20:30.440]             else {
[13:20:30.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.440]             }
[13:20:30.440]             {
[13:20:30.440]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.440]                   0L) {
[13:20:30.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.440]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.440]                   base::options(opts)
[13:20:30.440]                 }
[13:20:30.440]                 {
[13:20:30.440]                   {
[13:20:30.440]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.440]                     NULL
[13:20:30.440]                   }
[13:20:30.440]                   options(future.plan = NULL)
[13:20:30.440]                   if (is.na(NA_character_)) 
[13:20:30.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.440]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.440]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.440]                     envir = parent.frame()) 
[13:20:30.440]                   {
[13:20:30.440]                     if (is.function(workers)) 
[13:20:30.440]                       workers <- workers()
[13:20:30.440]                     workers <- structure(as.integer(workers), 
[13:20:30.440]                       class = class(workers))
[13:20:30.440]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.440]                       workers >= 1)
[13:20:30.440]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.440]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.440]                     }
[13:20:30.440]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.440]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.440]                       envir = envir)
[13:20:30.440]                     if (!future$lazy) 
[13:20:30.440]                       future <- run(future)
[13:20:30.440]                     invisible(future)
[13:20:30.440]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.440]                 }
[13:20:30.440]             }
[13:20:30.440]         }
[13:20:30.440]     })
[13:20:30.440]     if (TRUE) {
[13:20:30.440]         base::sink(type = "output", split = FALSE)
[13:20:30.440]         if (TRUE) {
[13:20:30.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.440]         }
[13:20:30.440]         else {
[13:20:30.440]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.440]         }
[13:20:30.440]         base::close(...future.stdout)
[13:20:30.440]         ...future.stdout <- NULL
[13:20:30.440]     }
[13:20:30.440]     ...future.result$conditions <- ...future.conditions
[13:20:30.440]     ...future.result$finished <- base::Sys.time()
[13:20:30.440]     ...future.result
[13:20:30.440] }
[13:20:30.442] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:30.453] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.454] - Validating connection of MultisessionFuture
[13:20:30.454] - received message: FutureResult
[13:20:30.454] - Received FutureResult
[13:20:30.454] - Erased future from FutureRegistry
[13:20:30.454] result() for ClusterFuture ...
[13:20:30.454] - result already collected: FutureResult
[13:20:30.454] result() for ClusterFuture ... done
[13:20:30.454] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:30.455] result() for ClusterFuture ...
[13:20:30.455] - result already collected: FutureResult
[13:20:30.455] result() for ClusterFuture ... done
[13:20:30.455] result() for ClusterFuture ...
[13:20:30.455] - result already collected: FutureResult
[13:20:30.455] result() for ClusterFuture ... done
[13:20:30.456] MultisessionFuture started
[13:20:30.456] - Launch lazy future ... done
[13:20:30.457] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55659d727838> 
Classes 'listenv', 'environment' <environment: 0x556599a6a9e8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:20:30.466] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.466] - Validating connection of MultisessionFuture
[13:20:30.466] - received message: FutureResult
[13:20:30.467] - Received FutureResult
[13:20:30.467] - Erased future from FutureRegistry
[13:20:30.467] result() for ClusterFuture ...
[13:20:30.467] - result already collected: FutureResult
[13:20:30.467] result() for ClusterFuture ... done
[13:20:30.467] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:30.480] resolve() on list environment ...
[13:20:30.480]  recursive: 0
[13:20:30.481]  length: 6
[13:20:30.481]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:30.482] signalConditionsASAP(numeric, pos=1) ...
[13:20:30.482] - nx: 6
[13:20:30.482] - relay: TRUE
[13:20:30.482] - stdout: TRUE
[13:20:30.482] - signal: TRUE
[13:20:30.482] - resignal: FALSE
[13:20:30.482] - force: TRUE
[13:20:30.482] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.482] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.482]  - until=2
[13:20:30.482]  - relaying element #2
[13:20:30.483] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.483] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.483] signalConditionsASAP(NULL, pos=1) ... done
[13:20:30.483]  length: 5 (resolved future 1)
[13:20:30.483] Future #2
[13:20:30.483] result() for ClusterFuture ...
[13:20:30.483] - result already collected: FutureResult
[13:20:30.483] result() for ClusterFuture ... done
[13:20:30.483] result() for ClusterFuture ...
[13:20:30.483] - result already collected: FutureResult
[13:20:30.484] result() for ClusterFuture ... done
[13:20:30.484] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:30.484] - nx: 6
[13:20:30.484] - relay: TRUE
[13:20:30.484] - stdout: TRUE
[13:20:30.484] - signal: TRUE
[13:20:30.484] - resignal: FALSE
[13:20:30.484] - force: TRUE
[13:20:30.484] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.484] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.484]  - until=2
[13:20:30.485]  - relaying element #2
[13:20:30.485] result() for ClusterFuture ...
[13:20:30.485] - result already collected: FutureResult
[13:20:30.485] result() for ClusterFuture ... done
[13:20:30.485] result() for ClusterFuture ...
[13:20:30.485] - result already collected: FutureResult
[13:20:30.485] result() for ClusterFuture ... done
[13:20:30.485] result() for ClusterFuture ...
[13:20:30.485] - result already collected: FutureResult
[13:20:30.485] result() for ClusterFuture ... done
[13:20:30.486] result() for ClusterFuture ...
[13:20:30.486] - result already collected: FutureResult
[13:20:30.486] result() for ClusterFuture ... done
[13:20:30.486] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.486] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.486] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:30.486]  length: 4 (resolved future 2)
[13:20:30.486] Future #3
[13:20:30.486] result() for ClusterFuture ...
[13:20:30.486] - result already collected: FutureResult
[13:20:30.486] result() for ClusterFuture ... done
[13:20:30.487] result() for ClusterFuture ...
[13:20:30.487] - result already collected: FutureResult
[13:20:30.487] result() for ClusterFuture ... done
[13:20:30.487] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:30.487] - nx: 6
[13:20:30.487] - relay: TRUE
[13:20:30.487] - stdout: TRUE
[13:20:30.487] - signal: TRUE
[13:20:30.487] - resignal: FALSE
[13:20:30.487] - force: TRUE
[13:20:30.487] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.488] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.488]  - until=3
[13:20:30.488]  - relaying element #3
[13:20:30.488] result() for ClusterFuture ...
[13:20:30.488] - result already collected: FutureResult
[13:20:30.488] result() for ClusterFuture ... done
[13:20:30.488] result() for ClusterFuture ...
[13:20:30.488] - result already collected: FutureResult
[13:20:30.488] result() for ClusterFuture ... done
[13:20:30.488] result() for ClusterFuture ...
[13:20:30.488] - result already collected: FutureResult
[13:20:30.489] result() for ClusterFuture ... done
[13:20:30.489] result() for ClusterFuture ...
[13:20:30.489] - result already collected: FutureResult
[13:20:30.489] result() for ClusterFuture ... done
[13:20:30.489] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.489] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.489] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:30.489]  length: 3 (resolved future 3)
[13:20:30.500] signalConditionsASAP(NULL, pos=5) ...
[13:20:30.500] - nx: 6
[13:20:30.500] - relay: TRUE
[13:20:30.500] - stdout: TRUE
[13:20:30.501] - signal: TRUE
[13:20:30.501] - resignal: FALSE
[13:20:30.501] - force: TRUE
[13:20:30.501] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.501] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.501]  - until=6
[13:20:30.501]  - relaying element #4
[13:20:30.501]  - relaying element #6
[13:20:30.501] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:20:30.501] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.502] signalConditionsASAP(NULL, pos=5) ... done
[13:20:30.502]  length: 2 (resolved future 5)
[13:20:30.502] signalConditionsASAP(numeric, pos=6) ...
[13:20:30.502] - nx: 6
[13:20:30.502] - relay: TRUE
[13:20:30.502] - stdout: TRUE
[13:20:30.502] - signal: TRUE
[13:20:30.502] - resignal: FALSE
[13:20:30.502] - force: TRUE
[13:20:30.502] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:20:30.502] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.503]  - until=6
[13:20:30.503]  - relaying element #4
[13:20:30.503] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:20:30.503] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.503] signalConditionsASAP(NULL, pos=6) ... done
[13:20:30.503]  length: 1 (resolved future 6)
[13:20:30.514] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.514] - Validating connection of MultisessionFuture
[13:20:30.514] - received message: FutureResult
[13:20:30.514] - Received FutureResult
[13:20:30.514] - Erased future from FutureRegistry
[13:20:30.515] result() for ClusterFuture ...
[13:20:30.515] - result already collected: FutureResult
[13:20:30.515] result() for ClusterFuture ... done
[13:20:30.515] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:30.515] Future #4
[13:20:30.515] result() for ClusterFuture ...
[13:20:30.515] - result already collected: FutureResult
[13:20:30.515] result() for ClusterFuture ... done
[13:20:30.515] result() for ClusterFuture ...
[13:20:30.515] - result already collected: FutureResult
[13:20:30.516] result() for ClusterFuture ... done
[13:20:30.516] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:20:30.516] - nx: 6
[13:20:30.516] - relay: TRUE
[13:20:30.516] - stdout: TRUE
[13:20:30.516] - signal: TRUE
[13:20:30.516] - resignal: FALSE
[13:20:30.516] - force: TRUE
[13:20:30.516] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:20:30.516] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.516]  - until=6
[13:20:30.517]  - relaying element #4
[13:20:30.517] result() for ClusterFuture ...
[13:20:30.517] - result already collected: FutureResult
[13:20:30.517] result() for ClusterFuture ... done
[13:20:30.517] result() for ClusterFuture ...
[13:20:30.517] - result already collected: FutureResult
[13:20:30.517] result() for ClusterFuture ... done
[13:20:30.517] result() for ClusterFuture ...
[13:20:30.517] - result already collected: FutureResult
[13:20:30.517] result() for ClusterFuture ... done
[13:20:30.518] result() for ClusterFuture ...
[13:20:30.518] - result already collected: FutureResult
[13:20:30.518] result() for ClusterFuture ... done
[13:20:30.518] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.518] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:30.518] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:20:30.518]  length: 0 (resolved future 4)
[13:20:30.518] Relaying remaining futures
[13:20:30.518] signalConditionsASAP(NULL, pos=0) ...
[13:20:30.518] - nx: 6
[13:20:30.518] - relay: TRUE
[13:20:30.519] - stdout: TRUE
[13:20:30.519] - signal: TRUE
[13:20:30.519] - resignal: FALSE
[13:20:30.519] - force: TRUE
[13:20:30.519] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.519] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:30.519] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.519] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:30.519] signalConditionsASAP(NULL, pos=0) ... done
[13:20:30.519] resolve() on list environment ... DONE
[13:20:30.520] result() for ClusterFuture ...
[13:20:30.520] - result already collected: FutureResult
[13:20:30.520] result() for ClusterFuture ... done
[13:20:30.520] result() for ClusterFuture ...
[13:20:30.520] - result already collected: FutureResult
[13:20:30.520] result() for ClusterFuture ... done
[13:20:30.520] result() for ClusterFuture ...
[13:20:30.520] - result already collected: FutureResult
[13:20:30.520] result() for ClusterFuture ... done
[13:20:30.520] result() for ClusterFuture ...
[13:20:30.521] - result already collected: FutureResult
[13:20:30.521] result() for ClusterFuture ... done
[13:20:30.521] result() for ClusterFuture ...
[13:20:30.521] - result already collected: FutureResult
[13:20:30.521] result() for ClusterFuture ... done
[13:20:30.521] result() for ClusterFuture ...
[13:20:30.521] - result already collected: FutureResult
[13:20:30.521] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5565997daa78> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:20:30.523] getGlobalsAndPackages() ...
[13:20:30.523] Searching for globals...
[13:20:30.524] 
[13:20:30.524] Searching for globals ... DONE
[13:20:30.524] - globals: [0] <none>
[13:20:30.524] getGlobalsAndPackages() ... DONE
[13:20:30.524] run() for ‘Future’ ...
[13:20:30.524] - state: ‘created’
[13:20:30.524] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.539] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.540]   - Field: ‘node’
[13:20:30.540]   - Field: ‘label’
[13:20:30.540]   - Field: ‘local’
[13:20:30.540]   - Field: ‘owner’
[13:20:30.540]   - Field: ‘envir’
[13:20:30.540]   - Field: ‘workers’
[13:20:30.540]   - Field: ‘packages’
[13:20:30.540]   - Field: ‘gc’
[13:20:30.541]   - Field: ‘conditions’
[13:20:30.541]   - Field: ‘persistent’
[13:20:30.541]   - Field: ‘expr’
[13:20:30.541]   - Field: ‘uuid’
[13:20:30.541]   - Field: ‘seed’
[13:20:30.541]   - Field: ‘version’
[13:20:30.541]   - Field: ‘result’
[13:20:30.541]   - Field: ‘asynchronous’
[13:20:30.541]   - Field: ‘calls’
[13:20:30.541]   - Field: ‘globals’
[13:20:30.542]   - Field: ‘stdout’
[13:20:30.542]   - Field: ‘earlySignal’
[13:20:30.542]   - Field: ‘lazy’
[13:20:30.542]   - Field: ‘state’
[13:20:30.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.542] - Launch lazy future ...
[13:20:30.542] Packages needed by the future expression (n = 0): <none>
[13:20:30.543] Packages needed by future strategies (n = 0): <none>
[13:20:30.543] {
[13:20:30.543]     {
[13:20:30.543]         {
[13:20:30.543]             ...future.startTime <- base::Sys.time()
[13:20:30.543]             {
[13:20:30.543]                 {
[13:20:30.543]                   {
[13:20:30.543]                     {
[13:20:30.543]                       base::local({
[13:20:30.543]                         has_future <- base::requireNamespace("future", 
[13:20:30.543]                           quietly = TRUE)
[13:20:30.543]                         if (has_future) {
[13:20:30.543]                           ns <- base::getNamespace("future")
[13:20:30.543]                           version <- ns[[".package"]][["version"]]
[13:20:30.543]                           if (is.null(version)) 
[13:20:30.543]                             version <- utils::packageVersion("future")
[13:20:30.543]                         }
[13:20:30.543]                         else {
[13:20:30.543]                           version <- NULL
[13:20:30.543]                         }
[13:20:30.543]                         if (!has_future || version < "1.8.0") {
[13:20:30.543]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.543]                             "", base::R.version$version.string), 
[13:20:30.543]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.543]                               "release", "version")], collapse = " "), 
[13:20:30.543]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.543]                             info)
[13:20:30.543]                           info <- base::paste(info, collapse = "; ")
[13:20:30.543]                           if (!has_future) {
[13:20:30.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.543]                               info)
[13:20:30.543]                           }
[13:20:30.543]                           else {
[13:20:30.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.543]                               info, version)
[13:20:30.543]                           }
[13:20:30.543]                           base::stop(msg)
[13:20:30.543]                         }
[13:20:30.543]                       })
[13:20:30.543]                     }
[13:20:30.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.543]                     base::options(mc.cores = 1L)
[13:20:30.543]                   }
[13:20:30.543]                   options(future.plan = NULL)
[13:20:30.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.543]                 }
[13:20:30.543]                 ...future.workdir <- getwd()
[13:20:30.543]             }
[13:20:30.543]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.543]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.543]         }
[13:20:30.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.543]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.543]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.543]             base::names(...future.oldOptions))
[13:20:30.543]     }
[13:20:30.543]     if (FALSE) {
[13:20:30.543]     }
[13:20:30.543]     else {
[13:20:30.543]         if (TRUE) {
[13:20:30.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.543]                 open = "w")
[13:20:30.543]         }
[13:20:30.543]         else {
[13:20:30.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.543]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.543]         }
[13:20:30.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.543]             base::sink(type = "output", split = FALSE)
[13:20:30.543]             base::close(...future.stdout)
[13:20:30.543]         }, add = TRUE)
[13:20:30.543]     }
[13:20:30.543]     ...future.frame <- base::sys.nframe()
[13:20:30.543]     ...future.conditions <- base::list()
[13:20:30.543]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.543]     if (FALSE) {
[13:20:30.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.543]     }
[13:20:30.543]     ...future.result <- base::tryCatch({
[13:20:30.543]         base::withCallingHandlers({
[13:20:30.543]             ...future.value <- base::withVisible(base::local({
[13:20:30.543]                 ...future.makeSendCondition <- local({
[13:20:30.543]                   sendCondition <- NULL
[13:20:30.543]                   function(frame = 1L) {
[13:20:30.543]                     if (is.function(sendCondition)) 
[13:20:30.543]                       return(sendCondition)
[13:20:30.543]                     ns <- getNamespace("parallel")
[13:20:30.543]                     if (exists("sendData", mode = "function", 
[13:20:30.543]                       envir = ns)) {
[13:20:30.543]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.543]                         envir = ns)
[13:20:30.543]                       envir <- sys.frame(frame)
[13:20:30.543]                       master <- NULL
[13:20:30.543]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.543]                         !identical(envir, emptyenv())) {
[13:20:30.543]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.543]                           inherits = FALSE)) {
[13:20:30.543]                           master <- get("master", mode = "list", 
[13:20:30.543]                             envir = envir, inherits = FALSE)
[13:20:30.543]                           if (inherits(master, c("SOCKnode", 
[13:20:30.543]                             "SOCK0node"))) {
[13:20:30.543]                             sendCondition <<- function(cond) {
[13:20:30.543]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.543]                                 success = TRUE)
[13:20:30.543]                               parallel_sendData(master, data)
[13:20:30.543]                             }
[13:20:30.543]                             return(sendCondition)
[13:20:30.543]                           }
[13:20:30.543]                         }
[13:20:30.543]                         frame <- frame + 1L
[13:20:30.543]                         envir <- sys.frame(frame)
[13:20:30.543]                       }
[13:20:30.543]                     }
[13:20:30.543]                     sendCondition <<- function(cond) NULL
[13:20:30.543]                   }
[13:20:30.543]                 })
[13:20:30.543]                 withCallingHandlers({
[13:20:30.543]                   2
[13:20:30.543]                 }, immediateCondition = function(cond) {
[13:20:30.543]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.543]                   sendCondition(cond)
[13:20:30.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.543]                   {
[13:20:30.543]                     inherits <- base::inherits
[13:20:30.543]                     invokeRestart <- base::invokeRestart
[13:20:30.543]                     is.null <- base::is.null
[13:20:30.543]                     muffled <- FALSE
[13:20:30.543]                     if (inherits(cond, "message")) {
[13:20:30.543]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.543]                       if (muffled) 
[13:20:30.543]                         invokeRestart("muffleMessage")
[13:20:30.543]                     }
[13:20:30.543]                     else if (inherits(cond, "warning")) {
[13:20:30.543]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.543]                       if (muffled) 
[13:20:30.543]                         invokeRestart("muffleWarning")
[13:20:30.543]                     }
[13:20:30.543]                     else if (inherits(cond, "condition")) {
[13:20:30.543]                       if (!is.null(pattern)) {
[13:20:30.543]                         computeRestarts <- base::computeRestarts
[13:20:30.543]                         grepl <- base::grepl
[13:20:30.543]                         restarts <- computeRestarts(cond)
[13:20:30.543]                         for (restart in restarts) {
[13:20:30.543]                           name <- restart$name
[13:20:30.543]                           if (is.null(name)) 
[13:20:30.543]                             next
[13:20:30.543]                           if (!grepl(pattern, name)) 
[13:20:30.543]                             next
[13:20:30.543]                           invokeRestart(restart)
[13:20:30.543]                           muffled <- TRUE
[13:20:30.543]                           break
[13:20:30.543]                         }
[13:20:30.543]                       }
[13:20:30.543]                     }
[13:20:30.543]                     invisible(muffled)
[13:20:30.543]                   }
[13:20:30.543]                   muffleCondition(cond)
[13:20:30.543]                 })
[13:20:30.543]             }))
[13:20:30.543]             future::FutureResult(value = ...future.value$value, 
[13:20:30.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.543]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.543]                     ...future.globalenv.names))
[13:20:30.543]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.543]         }, condition = base::local({
[13:20:30.543]             c <- base::c
[13:20:30.543]             inherits <- base::inherits
[13:20:30.543]             invokeRestart <- base::invokeRestart
[13:20:30.543]             length <- base::length
[13:20:30.543]             list <- base::list
[13:20:30.543]             seq.int <- base::seq.int
[13:20:30.543]             signalCondition <- base::signalCondition
[13:20:30.543]             sys.calls <- base::sys.calls
[13:20:30.543]             `[[` <- base::`[[`
[13:20:30.543]             `+` <- base::`+`
[13:20:30.543]             `<<-` <- base::`<<-`
[13:20:30.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.543]                   3L)]
[13:20:30.543]             }
[13:20:30.543]             function(cond) {
[13:20:30.543]                 is_error <- inherits(cond, "error")
[13:20:30.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.543]                   NULL)
[13:20:30.543]                 if (is_error) {
[13:20:30.543]                   sessionInformation <- function() {
[13:20:30.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.543]                       search = base::search(), system = base::Sys.info())
[13:20:30.543]                   }
[13:20:30.543]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.543]                     cond$call), session = sessionInformation(), 
[13:20:30.543]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.543]                   signalCondition(cond)
[13:20:30.543]                 }
[13:20:30.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.543]                 "immediateCondition"))) {
[13:20:30.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.543]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.543]                   if (TRUE && !signal) {
[13:20:30.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.543]                     {
[13:20:30.543]                       inherits <- base::inherits
[13:20:30.543]                       invokeRestart <- base::invokeRestart
[13:20:30.543]                       is.null <- base::is.null
[13:20:30.543]                       muffled <- FALSE
[13:20:30.543]                       if (inherits(cond, "message")) {
[13:20:30.543]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.543]                         if (muffled) 
[13:20:30.543]                           invokeRestart("muffleMessage")
[13:20:30.543]                       }
[13:20:30.543]                       else if (inherits(cond, "warning")) {
[13:20:30.543]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.543]                         if (muffled) 
[13:20:30.543]                           invokeRestart("muffleWarning")
[13:20:30.543]                       }
[13:20:30.543]                       else if (inherits(cond, "condition")) {
[13:20:30.543]                         if (!is.null(pattern)) {
[13:20:30.543]                           computeRestarts <- base::computeRestarts
[13:20:30.543]                           grepl <- base::grepl
[13:20:30.543]                           restarts <- computeRestarts(cond)
[13:20:30.543]                           for (restart in restarts) {
[13:20:30.543]                             name <- restart$name
[13:20:30.543]                             if (is.null(name)) 
[13:20:30.543]                               next
[13:20:30.543]                             if (!grepl(pattern, name)) 
[13:20:30.543]                               next
[13:20:30.543]                             invokeRestart(restart)
[13:20:30.543]                             muffled <- TRUE
[13:20:30.543]                             break
[13:20:30.543]                           }
[13:20:30.543]                         }
[13:20:30.543]                       }
[13:20:30.543]                       invisible(muffled)
[13:20:30.543]                     }
[13:20:30.543]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.543]                   }
[13:20:30.543]                 }
[13:20:30.543]                 else {
[13:20:30.543]                   if (TRUE) {
[13:20:30.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.543]                     {
[13:20:30.543]                       inherits <- base::inherits
[13:20:30.543]                       invokeRestart <- base::invokeRestart
[13:20:30.543]                       is.null <- base::is.null
[13:20:30.543]                       muffled <- FALSE
[13:20:30.543]                       if (inherits(cond, "message")) {
[13:20:30.543]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.543]                         if (muffled) 
[13:20:30.543]                           invokeRestart("muffleMessage")
[13:20:30.543]                       }
[13:20:30.543]                       else if (inherits(cond, "warning")) {
[13:20:30.543]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.543]                         if (muffled) 
[13:20:30.543]                           invokeRestart("muffleWarning")
[13:20:30.543]                       }
[13:20:30.543]                       else if (inherits(cond, "condition")) {
[13:20:30.543]                         if (!is.null(pattern)) {
[13:20:30.543]                           computeRestarts <- base::computeRestarts
[13:20:30.543]                           grepl <- base::grepl
[13:20:30.543]                           restarts <- computeRestarts(cond)
[13:20:30.543]                           for (restart in restarts) {
[13:20:30.543]                             name <- restart$name
[13:20:30.543]                             if (is.null(name)) 
[13:20:30.543]                               next
[13:20:30.543]                             if (!grepl(pattern, name)) 
[13:20:30.543]                               next
[13:20:30.543]                             invokeRestart(restart)
[13:20:30.543]                             muffled <- TRUE
[13:20:30.543]                             break
[13:20:30.543]                           }
[13:20:30.543]                         }
[13:20:30.543]                       }
[13:20:30.543]                       invisible(muffled)
[13:20:30.543]                     }
[13:20:30.543]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.543]                   }
[13:20:30.543]                 }
[13:20:30.543]             }
[13:20:30.543]         }))
[13:20:30.543]     }, error = function(ex) {
[13:20:30.543]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.543]                 ...future.rng), started = ...future.startTime, 
[13:20:30.543]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.543]             version = "1.8"), class = "FutureResult")
[13:20:30.543]     }, finally = {
[13:20:30.543]         if (!identical(...future.workdir, getwd())) 
[13:20:30.543]             setwd(...future.workdir)
[13:20:30.543]         {
[13:20:30.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.543]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.543]             }
[13:20:30.543]             base::options(...future.oldOptions)
[13:20:30.543]             if (.Platform$OS.type == "windows") {
[13:20:30.543]                 old_names <- names(...future.oldEnvVars)
[13:20:30.543]                 envs <- base::Sys.getenv()
[13:20:30.543]                 names <- names(envs)
[13:20:30.543]                 common <- intersect(names, old_names)
[13:20:30.543]                 added <- setdiff(names, old_names)
[13:20:30.543]                 removed <- setdiff(old_names, names)
[13:20:30.543]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.543]                   envs[common]]
[13:20:30.543]                 NAMES <- toupper(changed)
[13:20:30.543]                 args <- list()
[13:20:30.543]                 for (kk in seq_along(NAMES)) {
[13:20:30.543]                   name <- changed[[kk]]
[13:20:30.543]                   NAME <- NAMES[[kk]]
[13:20:30.543]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.543]                     next
[13:20:30.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.543]                 }
[13:20:30.543]                 NAMES <- toupper(added)
[13:20:30.543]                 for (kk in seq_along(NAMES)) {
[13:20:30.543]                   name <- added[[kk]]
[13:20:30.543]                   NAME <- NAMES[[kk]]
[13:20:30.543]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.543]                     next
[13:20:30.543]                   args[[name]] <- ""
[13:20:30.543]                 }
[13:20:30.543]                 NAMES <- toupper(removed)
[13:20:30.543]                 for (kk in seq_along(NAMES)) {
[13:20:30.543]                   name <- removed[[kk]]
[13:20:30.543]                   NAME <- NAMES[[kk]]
[13:20:30.543]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.543]                     next
[13:20:30.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.543]                 }
[13:20:30.543]                 if (length(args) > 0) 
[13:20:30.543]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.543]             }
[13:20:30.543]             else {
[13:20:30.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.543]             }
[13:20:30.543]             {
[13:20:30.543]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.543]                   0L) {
[13:20:30.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.543]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.543]                   base::options(opts)
[13:20:30.543]                 }
[13:20:30.543]                 {
[13:20:30.543]                   {
[13:20:30.543]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.543]                     NULL
[13:20:30.543]                   }
[13:20:30.543]                   options(future.plan = NULL)
[13:20:30.543]                   if (is.na(NA_character_)) 
[13:20:30.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.543]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.543]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.543]                     envir = parent.frame()) 
[13:20:30.543]                   {
[13:20:30.543]                     if (is.function(workers)) 
[13:20:30.543]                       workers <- workers()
[13:20:30.543]                     workers <- structure(as.integer(workers), 
[13:20:30.543]                       class = class(workers))
[13:20:30.543]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.543]                       workers >= 1)
[13:20:30.543]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.543]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.543]                     }
[13:20:30.543]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.543]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.543]                       envir = envir)
[13:20:30.543]                     if (!future$lazy) 
[13:20:30.543]                       future <- run(future)
[13:20:30.543]                     invisible(future)
[13:20:30.543]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.543]                 }
[13:20:30.543]             }
[13:20:30.543]         }
[13:20:30.543]     })
[13:20:30.543]     if (TRUE) {
[13:20:30.543]         base::sink(type = "output", split = FALSE)
[13:20:30.543]         if (TRUE) {
[13:20:30.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.543]         }
[13:20:30.543]         else {
[13:20:30.543]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.543]         }
[13:20:30.543]         base::close(...future.stdout)
[13:20:30.543]         ...future.stdout <- NULL
[13:20:30.543]     }
[13:20:30.543]     ...future.result$conditions <- ...future.conditions
[13:20:30.543]     ...future.result$finished <- base::Sys.time()
[13:20:30.543]     ...future.result
[13:20:30.543] }
[13:20:30.546] MultisessionFuture started
[13:20:30.546] - Launch lazy future ... done
[13:20:30.547] run() for ‘MultisessionFuture’ ... done
[13:20:30.547] getGlobalsAndPackages() ...
[13:20:30.547] Searching for globals...
[13:20:30.547] 
[13:20:30.547] Searching for globals ... DONE
[13:20:30.547] - globals: [0] <none>
[13:20:30.548] getGlobalsAndPackages() ... DONE
[13:20:30.548] run() for ‘Future’ ...
[13:20:30.548] - state: ‘created’
[13:20:30.548] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.563] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.563]   - Field: ‘node’
[13:20:30.564]   - Field: ‘label’
[13:20:30.564]   - Field: ‘local’
[13:20:30.564]   - Field: ‘owner’
[13:20:30.564]   - Field: ‘envir’
[13:20:30.564]   - Field: ‘workers’
[13:20:30.564]   - Field: ‘packages’
[13:20:30.564]   - Field: ‘gc’
[13:20:30.564]   - Field: ‘conditions’
[13:20:30.564]   - Field: ‘persistent’
[13:20:30.564]   - Field: ‘expr’
[13:20:30.565]   - Field: ‘uuid’
[13:20:30.565]   - Field: ‘seed’
[13:20:30.565]   - Field: ‘version’
[13:20:30.565]   - Field: ‘result’
[13:20:30.565]   - Field: ‘asynchronous’
[13:20:30.565]   - Field: ‘calls’
[13:20:30.565]   - Field: ‘globals’
[13:20:30.565]   - Field: ‘stdout’
[13:20:30.565]   - Field: ‘earlySignal’
[13:20:30.565]   - Field: ‘lazy’
[13:20:30.566]   - Field: ‘state’
[13:20:30.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.566] - Launch lazy future ...
[13:20:30.566] Packages needed by the future expression (n = 0): <none>
[13:20:30.566] Packages needed by future strategies (n = 0): <none>
[13:20:30.567] {
[13:20:30.567]     {
[13:20:30.567]         {
[13:20:30.567]             ...future.startTime <- base::Sys.time()
[13:20:30.567]             {
[13:20:30.567]                 {
[13:20:30.567]                   {
[13:20:30.567]                     {
[13:20:30.567]                       base::local({
[13:20:30.567]                         has_future <- base::requireNamespace("future", 
[13:20:30.567]                           quietly = TRUE)
[13:20:30.567]                         if (has_future) {
[13:20:30.567]                           ns <- base::getNamespace("future")
[13:20:30.567]                           version <- ns[[".package"]][["version"]]
[13:20:30.567]                           if (is.null(version)) 
[13:20:30.567]                             version <- utils::packageVersion("future")
[13:20:30.567]                         }
[13:20:30.567]                         else {
[13:20:30.567]                           version <- NULL
[13:20:30.567]                         }
[13:20:30.567]                         if (!has_future || version < "1.8.0") {
[13:20:30.567]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.567]                             "", base::R.version$version.string), 
[13:20:30.567]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.567]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.567]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.567]                               "release", "version")], collapse = " "), 
[13:20:30.567]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.567]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.567]                             info)
[13:20:30.567]                           info <- base::paste(info, collapse = "; ")
[13:20:30.567]                           if (!has_future) {
[13:20:30.567]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.567]                               info)
[13:20:30.567]                           }
[13:20:30.567]                           else {
[13:20:30.567]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.567]                               info, version)
[13:20:30.567]                           }
[13:20:30.567]                           base::stop(msg)
[13:20:30.567]                         }
[13:20:30.567]                       })
[13:20:30.567]                     }
[13:20:30.567]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.567]                     base::options(mc.cores = 1L)
[13:20:30.567]                   }
[13:20:30.567]                   options(future.plan = NULL)
[13:20:30.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.567]                 }
[13:20:30.567]                 ...future.workdir <- getwd()
[13:20:30.567]             }
[13:20:30.567]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.567]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.567]         }
[13:20:30.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.567]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.567]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.567]             base::names(...future.oldOptions))
[13:20:30.567]     }
[13:20:30.567]     if (FALSE) {
[13:20:30.567]     }
[13:20:30.567]     else {
[13:20:30.567]         if (TRUE) {
[13:20:30.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.567]                 open = "w")
[13:20:30.567]         }
[13:20:30.567]         else {
[13:20:30.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.567]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.567]         }
[13:20:30.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.567]             base::sink(type = "output", split = FALSE)
[13:20:30.567]             base::close(...future.stdout)
[13:20:30.567]         }, add = TRUE)
[13:20:30.567]     }
[13:20:30.567]     ...future.frame <- base::sys.nframe()
[13:20:30.567]     ...future.conditions <- base::list()
[13:20:30.567]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.567]     if (FALSE) {
[13:20:30.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.567]     }
[13:20:30.567]     ...future.result <- base::tryCatch({
[13:20:30.567]         base::withCallingHandlers({
[13:20:30.567]             ...future.value <- base::withVisible(base::local({
[13:20:30.567]                 ...future.makeSendCondition <- local({
[13:20:30.567]                   sendCondition <- NULL
[13:20:30.567]                   function(frame = 1L) {
[13:20:30.567]                     if (is.function(sendCondition)) 
[13:20:30.567]                       return(sendCondition)
[13:20:30.567]                     ns <- getNamespace("parallel")
[13:20:30.567]                     if (exists("sendData", mode = "function", 
[13:20:30.567]                       envir = ns)) {
[13:20:30.567]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.567]                         envir = ns)
[13:20:30.567]                       envir <- sys.frame(frame)
[13:20:30.567]                       master <- NULL
[13:20:30.567]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.567]                         !identical(envir, emptyenv())) {
[13:20:30.567]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.567]                           inherits = FALSE)) {
[13:20:30.567]                           master <- get("master", mode = "list", 
[13:20:30.567]                             envir = envir, inherits = FALSE)
[13:20:30.567]                           if (inherits(master, c("SOCKnode", 
[13:20:30.567]                             "SOCK0node"))) {
[13:20:30.567]                             sendCondition <<- function(cond) {
[13:20:30.567]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.567]                                 success = TRUE)
[13:20:30.567]                               parallel_sendData(master, data)
[13:20:30.567]                             }
[13:20:30.567]                             return(sendCondition)
[13:20:30.567]                           }
[13:20:30.567]                         }
[13:20:30.567]                         frame <- frame + 1L
[13:20:30.567]                         envir <- sys.frame(frame)
[13:20:30.567]                       }
[13:20:30.567]                     }
[13:20:30.567]                     sendCondition <<- function(cond) NULL
[13:20:30.567]                   }
[13:20:30.567]                 })
[13:20:30.567]                 withCallingHandlers({
[13:20:30.567]                   NULL
[13:20:30.567]                 }, immediateCondition = function(cond) {
[13:20:30.567]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.567]                   sendCondition(cond)
[13:20:30.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.567]                   {
[13:20:30.567]                     inherits <- base::inherits
[13:20:30.567]                     invokeRestart <- base::invokeRestart
[13:20:30.567]                     is.null <- base::is.null
[13:20:30.567]                     muffled <- FALSE
[13:20:30.567]                     if (inherits(cond, "message")) {
[13:20:30.567]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.567]                       if (muffled) 
[13:20:30.567]                         invokeRestart("muffleMessage")
[13:20:30.567]                     }
[13:20:30.567]                     else if (inherits(cond, "warning")) {
[13:20:30.567]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.567]                       if (muffled) 
[13:20:30.567]                         invokeRestart("muffleWarning")
[13:20:30.567]                     }
[13:20:30.567]                     else if (inherits(cond, "condition")) {
[13:20:30.567]                       if (!is.null(pattern)) {
[13:20:30.567]                         computeRestarts <- base::computeRestarts
[13:20:30.567]                         grepl <- base::grepl
[13:20:30.567]                         restarts <- computeRestarts(cond)
[13:20:30.567]                         for (restart in restarts) {
[13:20:30.567]                           name <- restart$name
[13:20:30.567]                           if (is.null(name)) 
[13:20:30.567]                             next
[13:20:30.567]                           if (!grepl(pattern, name)) 
[13:20:30.567]                             next
[13:20:30.567]                           invokeRestart(restart)
[13:20:30.567]                           muffled <- TRUE
[13:20:30.567]                           break
[13:20:30.567]                         }
[13:20:30.567]                       }
[13:20:30.567]                     }
[13:20:30.567]                     invisible(muffled)
[13:20:30.567]                   }
[13:20:30.567]                   muffleCondition(cond)
[13:20:30.567]                 })
[13:20:30.567]             }))
[13:20:30.567]             future::FutureResult(value = ...future.value$value, 
[13:20:30.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.567]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.567]                     ...future.globalenv.names))
[13:20:30.567]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.567]         }, condition = base::local({
[13:20:30.567]             c <- base::c
[13:20:30.567]             inherits <- base::inherits
[13:20:30.567]             invokeRestart <- base::invokeRestart
[13:20:30.567]             length <- base::length
[13:20:30.567]             list <- base::list
[13:20:30.567]             seq.int <- base::seq.int
[13:20:30.567]             signalCondition <- base::signalCondition
[13:20:30.567]             sys.calls <- base::sys.calls
[13:20:30.567]             `[[` <- base::`[[`
[13:20:30.567]             `+` <- base::`+`
[13:20:30.567]             `<<-` <- base::`<<-`
[13:20:30.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.567]                   3L)]
[13:20:30.567]             }
[13:20:30.567]             function(cond) {
[13:20:30.567]                 is_error <- inherits(cond, "error")
[13:20:30.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.567]                   NULL)
[13:20:30.567]                 if (is_error) {
[13:20:30.567]                   sessionInformation <- function() {
[13:20:30.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.567]                       search = base::search(), system = base::Sys.info())
[13:20:30.567]                   }
[13:20:30.567]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.567]                     cond$call), session = sessionInformation(), 
[13:20:30.567]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.567]                   signalCondition(cond)
[13:20:30.567]                 }
[13:20:30.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.567]                 "immediateCondition"))) {
[13:20:30.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.567]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.567]                   if (TRUE && !signal) {
[13:20:30.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.567]                     {
[13:20:30.567]                       inherits <- base::inherits
[13:20:30.567]                       invokeRestart <- base::invokeRestart
[13:20:30.567]                       is.null <- base::is.null
[13:20:30.567]                       muffled <- FALSE
[13:20:30.567]                       if (inherits(cond, "message")) {
[13:20:30.567]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.567]                         if (muffled) 
[13:20:30.567]                           invokeRestart("muffleMessage")
[13:20:30.567]                       }
[13:20:30.567]                       else if (inherits(cond, "warning")) {
[13:20:30.567]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.567]                         if (muffled) 
[13:20:30.567]                           invokeRestart("muffleWarning")
[13:20:30.567]                       }
[13:20:30.567]                       else if (inherits(cond, "condition")) {
[13:20:30.567]                         if (!is.null(pattern)) {
[13:20:30.567]                           computeRestarts <- base::computeRestarts
[13:20:30.567]                           grepl <- base::grepl
[13:20:30.567]                           restarts <- computeRestarts(cond)
[13:20:30.567]                           for (restart in restarts) {
[13:20:30.567]                             name <- restart$name
[13:20:30.567]                             if (is.null(name)) 
[13:20:30.567]                               next
[13:20:30.567]                             if (!grepl(pattern, name)) 
[13:20:30.567]                               next
[13:20:30.567]                             invokeRestart(restart)
[13:20:30.567]                             muffled <- TRUE
[13:20:30.567]                             break
[13:20:30.567]                           }
[13:20:30.567]                         }
[13:20:30.567]                       }
[13:20:30.567]                       invisible(muffled)
[13:20:30.567]                     }
[13:20:30.567]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.567]                   }
[13:20:30.567]                 }
[13:20:30.567]                 else {
[13:20:30.567]                   if (TRUE) {
[13:20:30.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.567]                     {
[13:20:30.567]                       inherits <- base::inherits
[13:20:30.567]                       invokeRestart <- base::invokeRestart
[13:20:30.567]                       is.null <- base::is.null
[13:20:30.567]                       muffled <- FALSE
[13:20:30.567]                       if (inherits(cond, "message")) {
[13:20:30.567]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.567]                         if (muffled) 
[13:20:30.567]                           invokeRestart("muffleMessage")
[13:20:30.567]                       }
[13:20:30.567]                       else if (inherits(cond, "warning")) {
[13:20:30.567]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.567]                         if (muffled) 
[13:20:30.567]                           invokeRestart("muffleWarning")
[13:20:30.567]                       }
[13:20:30.567]                       else if (inherits(cond, "condition")) {
[13:20:30.567]                         if (!is.null(pattern)) {
[13:20:30.567]                           computeRestarts <- base::computeRestarts
[13:20:30.567]                           grepl <- base::grepl
[13:20:30.567]                           restarts <- computeRestarts(cond)
[13:20:30.567]                           for (restart in restarts) {
[13:20:30.567]                             name <- restart$name
[13:20:30.567]                             if (is.null(name)) 
[13:20:30.567]                               next
[13:20:30.567]                             if (!grepl(pattern, name)) 
[13:20:30.567]                               next
[13:20:30.567]                             invokeRestart(restart)
[13:20:30.567]                             muffled <- TRUE
[13:20:30.567]                             break
[13:20:30.567]                           }
[13:20:30.567]                         }
[13:20:30.567]                       }
[13:20:30.567]                       invisible(muffled)
[13:20:30.567]                     }
[13:20:30.567]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.567]                   }
[13:20:30.567]                 }
[13:20:30.567]             }
[13:20:30.567]         }))
[13:20:30.567]     }, error = function(ex) {
[13:20:30.567]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.567]                 ...future.rng), started = ...future.startTime, 
[13:20:30.567]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.567]             version = "1.8"), class = "FutureResult")
[13:20:30.567]     }, finally = {
[13:20:30.567]         if (!identical(...future.workdir, getwd())) 
[13:20:30.567]             setwd(...future.workdir)
[13:20:30.567]         {
[13:20:30.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.567]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.567]             }
[13:20:30.567]             base::options(...future.oldOptions)
[13:20:30.567]             if (.Platform$OS.type == "windows") {
[13:20:30.567]                 old_names <- names(...future.oldEnvVars)
[13:20:30.567]                 envs <- base::Sys.getenv()
[13:20:30.567]                 names <- names(envs)
[13:20:30.567]                 common <- intersect(names, old_names)
[13:20:30.567]                 added <- setdiff(names, old_names)
[13:20:30.567]                 removed <- setdiff(old_names, names)
[13:20:30.567]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.567]                   envs[common]]
[13:20:30.567]                 NAMES <- toupper(changed)
[13:20:30.567]                 args <- list()
[13:20:30.567]                 for (kk in seq_along(NAMES)) {
[13:20:30.567]                   name <- changed[[kk]]
[13:20:30.567]                   NAME <- NAMES[[kk]]
[13:20:30.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.567]                     next
[13:20:30.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.567]                 }
[13:20:30.567]                 NAMES <- toupper(added)
[13:20:30.567]                 for (kk in seq_along(NAMES)) {
[13:20:30.567]                   name <- added[[kk]]
[13:20:30.567]                   NAME <- NAMES[[kk]]
[13:20:30.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.567]                     next
[13:20:30.567]                   args[[name]] <- ""
[13:20:30.567]                 }
[13:20:30.567]                 NAMES <- toupper(removed)
[13:20:30.567]                 for (kk in seq_along(NAMES)) {
[13:20:30.567]                   name <- removed[[kk]]
[13:20:30.567]                   NAME <- NAMES[[kk]]
[13:20:30.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.567]                     next
[13:20:30.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.567]                 }
[13:20:30.567]                 if (length(args) > 0) 
[13:20:30.567]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.567]             }
[13:20:30.567]             else {
[13:20:30.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.567]             }
[13:20:30.567]             {
[13:20:30.567]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.567]                   0L) {
[13:20:30.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.567]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.567]                   base::options(opts)
[13:20:30.567]                 }
[13:20:30.567]                 {
[13:20:30.567]                   {
[13:20:30.567]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.567]                     NULL
[13:20:30.567]                   }
[13:20:30.567]                   options(future.plan = NULL)
[13:20:30.567]                   if (is.na(NA_character_)) 
[13:20:30.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.567]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.567]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.567]                     envir = parent.frame()) 
[13:20:30.567]                   {
[13:20:30.567]                     if (is.function(workers)) 
[13:20:30.567]                       workers <- workers()
[13:20:30.567]                     workers <- structure(as.integer(workers), 
[13:20:30.567]                       class = class(workers))
[13:20:30.567]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.567]                       workers >= 1)
[13:20:30.567]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.567]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.567]                     }
[13:20:30.567]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.567]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.567]                       envir = envir)
[13:20:30.567]                     if (!future$lazy) 
[13:20:30.567]                       future <- run(future)
[13:20:30.567]                     invisible(future)
[13:20:30.567]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.567]                 }
[13:20:30.567]             }
[13:20:30.567]         }
[13:20:30.567]     })
[13:20:30.567]     if (TRUE) {
[13:20:30.567]         base::sink(type = "output", split = FALSE)
[13:20:30.567]         if (TRUE) {
[13:20:30.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.567]         }
[13:20:30.567]         else {
[13:20:30.567]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.567]         }
[13:20:30.567]         base::close(...future.stdout)
[13:20:30.567]         ...future.stdout <- NULL
[13:20:30.567]     }
[13:20:30.567]     ...future.result$conditions <- ...future.conditions
[13:20:30.567]     ...future.result$finished <- base::Sys.time()
[13:20:30.567]     ...future.result
[13:20:30.567] }
[13:20:30.573] MultisessionFuture started
[13:20:30.573] - Launch lazy future ... done
[13:20:30.573] run() for ‘MultisessionFuture’ ... done
[13:20:30.574] getGlobalsAndPackages() ...
[13:20:30.574] Searching for globals...
[13:20:30.574] - globals found: [1] ‘{’
[13:20:30.575] Searching for globals ... DONE
[13:20:30.575] Resolving globals: FALSE
[13:20:30.575] 
[13:20:30.575] 
[13:20:30.575] getGlobalsAndPackages() ... DONE
[13:20:30.575] run() for ‘Future’ ...
[13:20:30.575] - state: ‘created’
[13:20:30.576] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.590] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.590] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.590]   - Field: ‘node’
[13:20:30.590]   - Field: ‘label’
[13:20:30.591]   - Field: ‘local’
[13:20:30.591]   - Field: ‘owner’
[13:20:30.591]   - Field: ‘envir’
[13:20:30.591]   - Field: ‘workers’
[13:20:30.591]   - Field: ‘packages’
[13:20:30.591]   - Field: ‘gc’
[13:20:30.591]   - Field: ‘conditions’
[13:20:30.591]   - Field: ‘persistent’
[13:20:30.591]   - Field: ‘expr’
[13:20:30.592]   - Field: ‘uuid’
[13:20:30.592]   - Field: ‘seed’
[13:20:30.592]   - Field: ‘version’
[13:20:30.592]   - Field: ‘result’
[13:20:30.592]   - Field: ‘asynchronous’
[13:20:30.592]   - Field: ‘calls’
[13:20:30.592]   - Field: ‘globals’
[13:20:30.592]   - Field: ‘stdout’
[13:20:30.593]   - Field: ‘earlySignal’
[13:20:30.593]   - Field: ‘lazy’
[13:20:30.593]   - Field: ‘state’
[13:20:30.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.593] - Launch lazy future ...
[13:20:30.593] Packages needed by the future expression (n = 0): <none>
[13:20:30.594] Packages needed by future strategies (n = 0): <none>
[13:20:30.594] {
[13:20:30.594]     {
[13:20:30.594]         {
[13:20:30.594]             ...future.startTime <- base::Sys.time()
[13:20:30.594]             {
[13:20:30.594]                 {
[13:20:30.594]                   {
[13:20:30.594]                     {
[13:20:30.594]                       base::local({
[13:20:30.594]                         has_future <- base::requireNamespace("future", 
[13:20:30.594]                           quietly = TRUE)
[13:20:30.594]                         if (has_future) {
[13:20:30.594]                           ns <- base::getNamespace("future")
[13:20:30.594]                           version <- ns[[".package"]][["version"]]
[13:20:30.594]                           if (is.null(version)) 
[13:20:30.594]                             version <- utils::packageVersion("future")
[13:20:30.594]                         }
[13:20:30.594]                         else {
[13:20:30.594]                           version <- NULL
[13:20:30.594]                         }
[13:20:30.594]                         if (!has_future || version < "1.8.0") {
[13:20:30.594]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.594]                             "", base::R.version$version.string), 
[13:20:30.594]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.594]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.594]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.594]                               "release", "version")], collapse = " "), 
[13:20:30.594]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.594]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.594]                             info)
[13:20:30.594]                           info <- base::paste(info, collapse = "; ")
[13:20:30.594]                           if (!has_future) {
[13:20:30.594]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.594]                               info)
[13:20:30.594]                           }
[13:20:30.594]                           else {
[13:20:30.594]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.594]                               info, version)
[13:20:30.594]                           }
[13:20:30.594]                           base::stop(msg)
[13:20:30.594]                         }
[13:20:30.594]                       })
[13:20:30.594]                     }
[13:20:30.594]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.594]                     base::options(mc.cores = 1L)
[13:20:30.594]                   }
[13:20:30.594]                   options(future.plan = NULL)
[13:20:30.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.594]                 }
[13:20:30.594]                 ...future.workdir <- getwd()
[13:20:30.594]             }
[13:20:30.594]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.594]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.594]         }
[13:20:30.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.594]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.594]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.594]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.594]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.594]             base::names(...future.oldOptions))
[13:20:30.594]     }
[13:20:30.594]     if (FALSE) {
[13:20:30.594]     }
[13:20:30.594]     else {
[13:20:30.594]         if (TRUE) {
[13:20:30.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.594]                 open = "w")
[13:20:30.594]         }
[13:20:30.594]         else {
[13:20:30.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.594]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.594]         }
[13:20:30.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.594]             base::sink(type = "output", split = FALSE)
[13:20:30.594]             base::close(...future.stdout)
[13:20:30.594]         }, add = TRUE)
[13:20:30.594]     }
[13:20:30.594]     ...future.frame <- base::sys.nframe()
[13:20:30.594]     ...future.conditions <- base::list()
[13:20:30.594]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.594]     if (FALSE) {
[13:20:30.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.594]     }
[13:20:30.594]     ...future.result <- base::tryCatch({
[13:20:30.594]         base::withCallingHandlers({
[13:20:30.594]             ...future.value <- base::withVisible(base::local({
[13:20:30.594]                 ...future.makeSendCondition <- local({
[13:20:30.594]                   sendCondition <- NULL
[13:20:30.594]                   function(frame = 1L) {
[13:20:30.594]                     if (is.function(sendCondition)) 
[13:20:30.594]                       return(sendCondition)
[13:20:30.594]                     ns <- getNamespace("parallel")
[13:20:30.594]                     if (exists("sendData", mode = "function", 
[13:20:30.594]                       envir = ns)) {
[13:20:30.594]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.594]                         envir = ns)
[13:20:30.594]                       envir <- sys.frame(frame)
[13:20:30.594]                       master <- NULL
[13:20:30.594]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.594]                         !identical(envir, emptyenv())) {
[13:20:30.594]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.594]                           inherits = FALSE)) {
[13:20:30.594]                           master <- get("master", mode = "list", 
[13:20:30.594]                             envir = envir, inherits = FALSE)
[13:20:30.594]                           if (inherits(master, c("SOCKnode", 
[13:20:30.594]                             "SOCK0node"))) {
[13:20:30.594]                             sendCondition <<- function(cond) {
[13:20:30.594]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.594]                                 success = TRUE)
[13:20:30.594]                               parallel_sendData(master, data)
[13:20:30.594]                             }
[13:20:30.594]                             return(sendCondition)
[13:20:30.594]                           }
[13:20:30.594]                         }
[13:20:30.594]                         frame <- frame + 1L
[13:20:30.594]                         envir <- sys.frame(frame)
[13:20:30.594]                       }
[13:20:30.594]                     }
[13:20:30.594]                     sendCondition <<- function(cond) NULL
[13:20:30.594]                   }
[13:20:30.594]                 })
[13:20:30.594]                 withCallingHandlers({
[13:20:30.594]                   {
[13:20:30.594]                     4
[13:20:30.594]                   }
[13:20:30.594]                 }, immediateCondition = function(cond) {
[13:20:30.594]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.594]                   sendCondition(cond)
[13:20:30.594]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.594]                   {
[13:20:30.594]                     inherits <- base::inherits
[13:20:30.594]                     invokeRestart <- base::invokeRestart
[13:20:30.594]                     is.null <- base::is.null
[13:20:30.594]                     muffled <- FALSE
[13:20:30.594]                     if (inherits(cond, "message")) {
[13:20:30.594]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.594]                       if (muffled) 
[13:20:30.594]                         invokeRestart("muffleMessage")
[13:20:30.594]                     }
[13:20:30.594]                     else if (inherits(cond, "warning")) {
[13:20:30.594]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.594]                       if (muffled) 
[13:20:30.594]                         invokeRestart("muffleWarning")
[13:20:30.594]                     }
[13:20:30.594]                     else if (inherits(cond, "condition")) {
[13:20:30.594]                       if (!is.null(pattern)) {
[13:20:30.594]                         computeRestarts <- base::computeRestarts
[13:20:30.594]                         grepl <- base::grepl
[13:20:30.594]                         restarts <- computeRestarts(cond)
[13:20:30.594]                         for (restart in restarts) {
[13:20:30.594]                           name <- restart$name
[13:20:30.594]                           if (is.null(name)) 
[13:20:30.594]                             next
[13:20:30.594]                           if (!grepl(pattern, name)) 
[13:20:30.594]                             next
[13:20:30.594]                           invokeRestart(restart)
[13:20:30.594]                           muffled <- TRUE
[13:20:30.594]                           break
[13:20:30.594]                         }
[13:20:30.594]                       }
[13:20:30.594]                     }
[13:20:30.594]                     invisible(muffled)
[13:20:30.594]                   }
[13:20:30.594]                   muffleCondition(cond)
[13:20:30.594]                 })
[13:20:30.594]             }))
[13:20:30.594]             future::FutureResult(value = ...future.value$value, 
[13:20:30.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.594]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.594]                     ...future.globalenv.names))
[13:20:30.594]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.594]         }, condition = base::local({
[13:20:30.594]             c <- base::c
[13:20:30.594]             inherits <- base::inherits
[13:20:30.594]             invokeRestart <- base::invokeRestart
[13:20:30.594]             length <- base::length
[13:20:30.594]             list <- base::list
[13:20:30.594]             seq.int <- base::seq.int
[13:20:30.594]             signalCondition <- base::signalCondition
[13:20:30.594]             sys.calls <- base::sys.calls
[13:20:30.594]             `[[` <- base::`[[`
[13:20:30.594]             `+` <- base::`+`
[13:20:30.594]             `<<-` <- base::`<<-`
[13:20:30.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.594]                   3L)]
[13:20:30.594]             }
[13:20:30.594]             function(cond) {
[13:20:30.594]                 is_error <- inherits(cond, "error")
[13:20:30.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.594]                   NULL)
[13:20:30.594]                 if (is_error) {
[13:20:30.594]                   sessionInformation <- function() {
[13:20:30.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.594]                       search = base::search(), system = base::Sys.info())
[13:20:30.594]                   }
[13:20:30.594]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.594]                     cond$call), session = sessionInformation(), 
[13:20:30.594]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.594]                   signalCondition(cond)
[13:20:30.594]                 }
[13:20:30.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.594]                 "immediateCondition"))) {
[13:20:30.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.594]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.594]                   if (TRUE && !signal) {
[13:20:30.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.594]                     {
[13:20:30.594]                       inherits <- base::inherits
[13:20:30.594]                       invokeRestart <- base::invokeRestart
[13:20:30.594]                       is.null <- base::is.null
[13:20:30.594]                       muffled <- FALSE
[13:20:30.594]                       if (inherits(cond, "message")) {
[13:20:30.594]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.594]                         if (muffled) 
[13:20:30.594]                           invokeRestart("muffleMessage")
[13:20:30.594]                       }
[13:20:30.594]                       else if (inherits(cond, "warning")) {
[13:20:30.594]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.594]                         if (muffled) 
[13:20:30.594]                           invokeRestart("muffleWarning")
[13:20:30.594]                       }
[13:20:30.594]                       else if (inherits(cond, "condition")) {
[13:20:30.594]                         if (!is.null(pattern)) {
[13:20:30.594]                           computeRestarts <- base::computeRestarts
[13:20:30.594]                           grepl <- base::grepl
[13:20:30.594]                           restarts <- computeRestarts(cond)
[13:20:30.594]                           for (restart in restarts) {
[13:20:30.594]                             name <- restart$name
[13:20:30.594]                             if (is.null(name)) 
[13:20:30.594]                               next
[13:20:30.594]                             if (!grepl(pattern, name)) 
[13:20:30.594]                               next
[13:20:30.594]                             invokeRestart(restart)
[13:20:30.594]                             muffled <- TRUE
[13:20:30.594]                             break
[13:20:30.594]                           }
[13:20:30.594]                         }
[13:20:30.594]                       }
[13:20:30.594]                       invisible(muffled)
[13:20:30.594]                     }
[13:20:30.594]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.594]                   }
[13:20:30.594]                 }
[13:20:30.594]                 else {
[13:20:30.594]                   if (TRUE) {
[13:20:30.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.594]                     {
[13:20:30.594]                       inherits <- base::inherits
[13:20:30.594]                       invokeRestart <- base::invokeRestart
[13:20:30.594]                       is.null <- base::is.null
[13:20:30.594]                       muffled <- FALSE
[13:20:30.594]                       if (inherits(cond, "message")) {
[13:20:30.594]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.594]                         if (muffled) 
[13:20:30.594]                           invokeRestart("muffleMessage")
[13:20:30.594]                       }
[13:20:30.594]                       else if (inherits(cond, "warning")) {
[13:20:30.594]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.594]                         if (muffled) 
[13:20:30.594]                           invokeRestart("muffleWarning")
[13:20:30.594]                       }
[13:20:30.594]                       else if (inherits(cond, "condition")) {
[13:20:30.594]                         if (!is.null(pattern)) {
[13:20:30.594]                           computeRestarts <- base::computeRestarts
[13:20:30.594]                           grepl <- base::grepl
[13:20:30.594]                           restarts <- computeRestarts(cond)
[13:20:30.594]                           for (restart in restarts) {
[13:20:30.594]                             name <- restart$name
[13:20:30.594]                             if (is.null(name)) 
[13:20:30.594]                               next
[13:20:30.594]                             if (!grepl(pattern, name)) 
[13:20:30.594]                               next
[13:20:30.594]                             invokeRestart(restart)
[13:20:30.594]                             muffled <- TRUE
[13:20:30.594]                             break
[13:20:30.594]                           }
[13:20:30.594]                         }
[13:20:30.594]                       }
[13:20:30.594]                       invisible(muffled)
[13:20:30.594]                     }
[13:20:30.594]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.594]                   }
[13:20:30.594]                 }
[13:20:30.594]             }
[13:20:30.594]         }))
[13:20:30.594]     }, error = function(ex) {
[13:20:30.594]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.594]                 ...future.rng), started = ...future.startTime, 
[13:20:30.594]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.594]             version = "1.8"), class = "FutureResult")
[13:20:30.594]     }, finally = {
[13:20:30.594]         if (!identical(...future.workdir, getwd())) 
[13:20:30.594]             setwd(...future.workdir)
[13:20:30.594]         {
[13:20:30.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.594]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.594]             }
[13:20:30.594]             base::options(...future.oldOptions)
[13:20:30.594]             if (.Platform$OS.type == "windows") {
[13:20:30.594]                 old_names <- names(...future.oldEnvVars)
[13:20:30.594]                 envs <- base::Sys.getenv()
[13:20:30.594]                 names <- names(envs)
[13:20:30.594]                 common <- intersect(names, old_names)
[13:20:30.594]                 added <- setdiff(names, old_names)
[13:20:30.594]                 removed <- setdiff(old_names, names)
[13:20:30.594]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.594]                   envs[common]]
[13:20:30.594]                 NAMES <- toupper(changed)
[13:20:30.594]                 args <- list()
[13:20:30.594]                 for (kk in seq_along(NAMES)) {
[13:20:30.594]                   name <- changed[[kk]]
[13:20:30.594]                   NAME <- NAMES[[kk]]
[13:20:30.594]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.594]                     next
[13:20:30.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.594]                 }
[13:20:30.594]                 NAMES <- toupper(added)
[13:20:30.594]                 for (kk in seq_along(NAMES)) {
[13:20:30.594]                   name <- added[[kk]]
[13:20:30.594]                   NAME <- NAMES[[kk]]
[13:20:30.594]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.594]                     next
[13:20:30.594]                   args[[name]] <- ""
[13:20:30.594]                 }
[13:20:30.594]                 NAMES <- toupper(removed)
[13:20:30.594]                 for (kk in seq_along(NAMES)) {
[13:20:30.594]                   name <- removed[[kk]]
[13:20:30.594]                   NAME <- NAMES[[kk]]
[13:20:30.594]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.594]                     next
[13:20:30.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.594]                 }
[13:20:30.594]                 if (length(args) > 0) 
[13:20:30.594]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.594]             }
[13:20:30.594]             else {
[13:20:30.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.594]             }
[13:20:30.594]             {
[13:20:30.594]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.594]                   0L) {
[13:20:30.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.594]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.594]                   base::options(opts)
[13:20:30.594]                 }
[13:20:30.594]                 {
[13:20:30.594]                   {
[13:20:30.594]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.594]                     NULL
[13:20:30.594]                   }
[13:20:30.594]                   options(future.plan = NULL)
[13:20:30.594]                   if (is.na(NA_character_)) 
[13:20:30.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.594]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.594]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.594]                     envir = parent.frame()) 
[13:20:30.594]                   {
[13:20:30.594]                     if (is.function(workers)) 
[13:20:30.594]                       workers <- workers()
[13:20:30.594]                     workers <- structure(as.integer(workers), 
[13:20:30.594]                       class = class(workers))
[13:20:30.594]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.594]                       workers >= 1)
[13:20:30.594]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.594]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.594]                     }
[13:20:30.594]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.594]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.594]                       envir = envir)
[13:20:30.594]                     if (!future$lazy) 
[13:20:30.594]                       future <- run(future)
[13:20:30.594]                     invisible(future)
[13:20:30.594]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.594]                 }
[13:20:30.594]             }
[13:20:30.594]         }
[13:20:30.594]     })
[13:20:30.594]     if (TRUE) {
[13:20:30.594]         base::sink(type = "output", split = FALSE)
[13:20:30.594]         if (TRUE) {
[13:20:30.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.594]         }
[13:20:30.594]         else {
[13:20:30.594]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.594]         }
[13:20:30.594]         base::close(...future.stdout)
[13:20:30.594]         ...future.stdout <- NULL
[13:20:30.594]     }
[13:20:30.594]     ...future.result$conditions <- ...future.conditions
[13:20:30.594]     ...future.result$finished <- base::Sys.time()
[13:20:30.594]     ...future.result
[13:20:30.594] }
[13:20:30.596] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:30.607] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.607] - Validating connection of MultisessionFuture
[13:20:30.608] - received message: FutureResult
[13:20:30.608] - Received FutureResult
[13:20:30.608] - Erased future from FutureRegistry
[13:20:30.608] result() for ClusterFuture ...
[13:20:30.608] - result already collected: FutureResult
[13:20:30.608] result() for ClusterFuture ... done
[13:20:30.608] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:30.608] result() for ClusterFuture ...
[13:20:30.608] - result already collected: FutureResult
[13:20:30.608] result() for ClusterFuture ... done
[13:20:30.609] result() for ClusterFuture ...
[13:20:30.609] - result already collected: FutureResult
[13:20:30.609] result() for ClusterFuture ... done
[13:20:30.610] MultisessionFuture started
[13:20:30.610] - Launch lazy future ... done
[13:20:30.610] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55659d3bd1d0> 
Classes 'listenv', 'environment' <environment: 0x55659ba21c60> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:20:30.622] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.622] - Validating connection of MultisessionFuture
[13:20:30.622] - received message: FutureResult
[13:20:30.622] - Received FutureResult
[13:20:30.622] - Erased future from FutureRegistry
[13:20:30.622] result() for ClusterFuture ...
[13:20:30.622] - result already collected: FutureResult
[13:20:30.622] result() for ClusterFuture ... done
[13:20:30.623] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:30.636] resolve() on list environment ...
[13:20:30.636]  recursive: 0
[13:20:30.637]  length: 6
[13:20:30.637]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:30.637] signalConditionsASAP(numeric, pos=1) ...
[13:20:30.637] - nx: 6
[13:20:30.637] - relay: TRUE
[13:20:30.637] - stdout: TRUE
[13:20:30.638] - signal: TRUE
[13:20:30.638] - resignal: FALSE
[13:20:30.638] - force: TRUE
[13:20:30.638] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.638] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.638]  - until=2
[13:20:30.638]  - relaying element #2
[13:20:30.638] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.638] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.638] signalConditionsASAP(NULL, pos=1) ... done
[13:20:30.638]  length: 5 (resolved future 1)
[13:20:30.639] Future #2
[13:20:30.639] result() for ClusterFuture ...
[13:20:30.639] - result already collected: FutureResult
[13:20:30.639] result() for ClusterFuture ... done
[13:20:30.639] result() for ClusterFuture ...
[13:20:30.639] - result already collected: FutureResult
[13:20:30.639] result() for ClusterFuture ... done
[13:20:30.639] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:30.639] - nx: 6
[13:20:30.639] - relay: TRUE
[13:20:30.639] - stdout: TRUE
[13:20:30.640] - signal: TRUE
[13:20:30.640] - resignal: FALSE
[13:20:30.640] - force: TRUE
[13:20:30.640] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.640] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.640]  - until=2
[13:20:30.640]  - relaying element #2
[13:20:30.640] result() for ClusterFuture ...
[13:20:30.640] - result already collected: FutureResult
[13:20:30.640] result() for ClusterFuture ... done
[13:20:30.640] result() for ClusterFuture ...
[13:20:30.641] - result already collected: FutureResult
[13:20:30.641] result() for ClusterFuture ... done
[13:20:30.641] result() for ClusterFuture ...
[13:20:30.641] - result already collected: FutureResult
[13:20:30.641] result() for ClusterFuture ... done
[13:20:30.641] result() for ClusterFuture ...
[13:20:30.641] - result already collected: FutureResult
[13:20:30.641] result() for ClusterFuture ... done
[13:20:30.641] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.641] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.641] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:30.642]  length: 4 (resolved future 2)
[13:20:30.642] Future #3
[13:20:30.642] result() for ClusterFuture ...
[13:20:30.642] - result already collected: FutureResult
[13:20:30.642] result() for ClusterFuture ... done
[13:20:30.642] result() for ClusterFuture ...
[13:20:30.642] - result already collected: FutureResult
[13:20:30.642] result() for ClusterFuture ... done
[13:20:30.642] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:30.642] - nx: 6
[13:20:30.643] - relay: TRUE
[13:20:30.643] - stdout: TRUE
[13:20:30.643] - signal: TRUE
[13:20:30.643] - resignal: FALSE
[13:20:30.643] - force: TRUE
[13:20:30.643] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.643] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.643]  - until=3
[13:20:30.643]  - relaying element #3
[13:20:30.643] result() for ClusterFuture ...
[13:20:30.643] - result already collected: FutureResult
[13:20:30.644] result() for ClusterFuture ... done
[13:20:30.644] result() for ClusterFuture ...
[13:20:30.644] - result already collected: FutureResult
[13:20:30.644] result() for ClusterFuture ... done
[13:20:30.644] result() for ClusterFuture ...
[13:20:30.644] - result already collected: FutureResult
[13:20:30.644] result() for ClusterFuture ... done
[13:20:30.644] result() for ClusterFuture ...
[13:20:30.644] - result already collected: FutureResult
[13:20:30.644] result() for ClusterFuture ... done
[13:20:30.644] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.644] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.645] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:30.645]  length: 3 (resolved future 3)
[13:20:30.655] signalConditionsASAP(NULL, pos=5) ...
[13:20:30.656] - nx: 6
[13:20:30.656] - relay: TRUE
[13:20:30.656] - stdout: TRUE
[13:20:30.656] - signal: TRUE
[13:20:30.656] - resignal: FALSE
[13:20:30.656] - force: TRUE
[13:20:30.656] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.656] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.656]  - until=6
[13:20:30.657]  - relaying element #4
[13:20:30.657]  - relaying element #6
[13:20:30.657] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:20:30.657] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.657] signalConditionsASAP(NULL, pos=5) ... done
[13:20:30.657]  length: 2 (resolved future 5)
[13:20:30.657] signalConditionsASAP(numeric, pos=6) ...
[13:20:30.657] - nx: 6
[13:20:30.657] - relay: TRUE
[13:20:30.657] - stdout: TRUE
[13:20:30.658] - signal: TRUE
[13:20:30.658] - resignal: FALSE
[13:20:30.658] - force: TRUE
[13:20:30.658] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:20:30.658] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.658]  - until=6
[13:20:30.658]  - relaying element #4
[13:20:30.658] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:20:30.658] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.658] signalConditionsASAP(NULL, pos=6) ... done
[13:20:30.658]  length: 1 (resolved future 6)
[13:20:30.669] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.669] - Validating connection of MultisessionFuture
[13:20:30.669] - received message: FutureResult
[13:20:30.670] - Received FutureResult
[13:20:30.670] - Erased future from FutureRegistry
[13:20:30.670] result() for ClusterFuture ...
[13:20:30.670] - result already collected: FutureResult
[13:20:30.670] result() for ClusterFuture ... done
[13:20:30.670] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:30.670] Future #4
[13:20:30.670] result() for ClusterFuture ...
[13:20:30.670] - result already collected: FutureResult
[13:20:30.670] result() for ClusterFuture ... done
[13:20:30.671] result() for ClusterFuture ...
[13:20:30.671] - result already collected: FutureResult
[13:20:30.671] result() for ClusterFuture ... done
[13:20:30.671] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:20:30.671] - nx: 6
[13:20:30.671] - relay: TRUE
[13:20:30.671] - stdout: TRUE
[13:20:30.671] - signal: TRUE
[13:20:30.671] - resignal: FALSE
[13:20:30.671] - force: TRUE
[13:20:30.671] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:20:30.672] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.672]  - until=6
[13:20:30.672]  - relaying element #4
[13:20:30.672] result() for ClusterFuture ...
[13:20:30.672] - result already collected: FutureResult
[13:20:30.672] result() for ClusterFuture ... done
[13:20:30.672] result() for ClusterFuture ...
[13:20:30.672] - result already collected: FutureResult
[13:20:30.672] result() for ClusterFuture ... done
[13:20:30.672] result() for ClusterFuture ...
[13:20:30.672] - result already collected: FutureResult
[13:20:30.673] result() for ClusterFuture ... done
[13:20:30.673] result() for ClusterFuture ...
[13:20:30.673] - result already collected: FutureResult
[13:20:30.673] result() for ClusterFuture ... done
[13:20:30.673] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.673] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:30.673] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:20:30.673]  length: 0 (resolved future 4)
[13:20:30.673] Relaying remaining futures
[13:20:30.673] signalConditionsASAP(NULL, pos=0) ...
[13:20:30.673] - nx: 6
[13:20:30.674] - relay: TRUE
[13:20:30.674] - stdout: TRUE
[13:20:30.674] - signal: TRUE
[13:20:30.674] - resignal: FALSE
[13:20:30.674] - force: TRUE
[13:20:30.674] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.674] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:30.674] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.674] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:30.674] signalConditionsASAP(NULL, pos=0) ... done
[13:20:30.675] resolve() on list environment ... DONE
[13:20:30.675] result() for ClusterFuture ...
[13:20:30.675] - result already collected: FutureResult
[13:20:30.675] result() for ClusterFuture ... done
[13:20:30.675] result() for ClusterFuture ...
[13:20:30.675] - result already collected: FutureResult
[13:20:30.675] result() for ClusterFuture ... done
[13:20:30.675] result() for ClusterFuture ...
[13:20:30.675] - result already collected: FutureResult
[13:20:30.675] result() for ClusterFuture ... done
[13:20:30.675] result() for ClusterFuture ...
[13:20:30.676] - result already collected: FutureResult
[13:20:30.676] result() for ClusterFuture ... done
[13:20:30.676] result() for ClusterFuture ...
[13:20:30.676] - result already collected: FutureResult
[13:20:30.676] result() for ClusterFuture ... done
[13:20:30.676] result() for ClusterFuture ...
[13:20:30.676] - result already collected: FutureResult
[13:20:30.676] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55659b11b658> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:20:30.679] getGlobalsAndPackages() ...
[13:20:30.679] Searching for globals...
[13:20:30.679] 
[13:20:30.679] Searching for globals ... DONE
[13:20:30.679] - globals: [0] <none>
[13:20:30.679] getGlobalsAndPackages() ... DONE
[13:20:30.680] run() for ‘Future’ ...
[13:20:30.680] - state: ‘created’
[13:20:30.680] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.695] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.695] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.695]   - Field: ‘node’
[13:20:30.695]   - Field: ‘label’
[13:20:30.695]   - Field: ‘local’
[13:20:30.696]   - Field: ‘owner’
[13:20:30.696]   - Field: ‘envir’
[13:20:30.696]   - Field: ‘workers’
[13:20:30.696]   - Field: ‘packages’
[13:20:30.696]   - Field: ‘gc’
[13:20:30.696]   - Field: ‘conditions’
[13:20:30.696]   - Field: ‘persistent’
[13:20:30.696]   - Field: ‘expr’
[13:20:30.696]   - Field: ‘uuid’
[13:20:30.696]   - Field: ‘seed’
[13:20:30.697]   - Field: ‘version’
[13:20:30.697]   - Field: ‘result’
[13:20:30.697]   - Field: ‘asynchronous’
[13:20:30.697]   - Field: ‘calls’
[13:20:30.697]   - Field: ‘globals’
[13:20:30.697]   - Field: ‘stdout’
[13:20:30.697]   - Field: ‘earlySignal’
[13:20:30.697]   - Field: ‘lazy’
[13:20:30.697]   - Field: ‘state’
[13:20:30.697] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.697] - Launch lazy future ...
[13:20:30.698] Packages needed by the future expression (n = 0): <none>
[13:20:30.698] Packages needed by future strategies (n = 0): <none>
[13:20:30.698] {
[13:20:30.698]     {
[13:20:30.698]         {
[13:20:30.698]             ...future.startTime <- base::Sys.time()
[13:20:30.698]             {
[13:20:30.698]                 {
[13:20:30.698]                   {
[13:20:30.698]                     {
[13:20:30.698]                       base::local({
[13:20:30.698]                         has_future <- base::requireNamespace("future", 
[13:20:30.698]                           quietly = TRUE)
[13:20:30.698]                         if (has_future) {
[13:20:30.698]                           ns <- base::getNamespace("future")
[13:20:30.698]                           version <- ns[[".package"]][["version"]]
[13:20:30.698]                           if (is.null(version)) 
[13:20:30.698]                             version <- utils::packageVersion("future")
[13:20:30.698]                         }
[13:20:30.698]                         else {
[13:20:30.698]                           version <- NULL
[13:20:30.698]                         }
[13:20:30.698]                         if (!has_future || version < "1.8.0") {
[13:20:30.698]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.698]                             "", base::R.version$version.string), 
[13:20:30.698]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.698]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.698]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.698]                               "release", "version")], collapse = " "), 
[13:20:30.698]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.698]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.698]                             info)
[13:20:30.698]                           info <- base::paste(info, collapse = "; ")
[13:20:30.698]                           if (!has_future) {
[13:20:30.698]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.698]                               info)
[13:20:30.698]                           }
[13:20:30.698]                           else {
[13:20:30.698]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.698]                               info, version)
[13:20:30.698]                           }
[13:20:30.698]                           base::stop(msg)
[13:20:30.698]                         }
[13:20:30.698]                       })
[13:20:30.698]                     }
[13:20:30.698]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.698]                     base::options(mc.cores = 1L)
[13:20:30.698]                   }
[13:20:30.698]                   options(future.plan = NULL)
[13:20:30.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.698]                 }
[13:20:30.698]                 ...future.workdir <- getwd()
[13:20:30.698]             }
[13:20:30.698]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.698]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.698]         }
[13:20:30.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.698]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.698]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.698]             base::names(...future.oldOptions))
[13:20:30.698]     }
[13:20:30.698]     if (FALSE) {
[13:20:30.698]     }
[13:20:30.698]     else {
[13:20:30.698]         if (TRUE) {
[13:20:30.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.698]                 open = "w")
[13:20:30.698]         }
[13:20:30.698]         else {
[13:20:30.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.698]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.698]         }
[13:20:30.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.698]             base::sink(type = "output", split = FALSE)
[13:20:30.698]             base::close(...future.stdout)
[13:20:30.698]         }, add = TRUE)
[13:20:30.698]     }
[13:20:30.698]     ...future.frame <- base::sys.nframe()
[13:20:30.698]     ...future.conditions <- base::list()
[13:20:30.698]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.698]     if (FALSE) {
[13:20:30.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.698]     }
[13:20:30.698]     ...future.result <- base::tryCatch({
[13:20:30.698]         base::withCallingHandlers({
[13:20:30.698]             ...future.value <- base::withVisible(base::local({
[13:20:30.698]                 ...future.makeSendCondition <- local({
[13:20:30.698]                   sendCondition <- NULL
[13:20:30.698]                   function(frame = 1L) {
[13:20:30.698]                     if (is.function(sendCondition)) 
[13:20:30.698]                       return(sendCondition)
[13:20:30.698]                     ns <- getNamespace("parallel")
[13:20:30.698]                     if (exists("sendData", mode = "function", 
[13:20:30.698]                       envir = ns)) {
[13:20:30.698]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.698]                         envir = ns)
[13:20:30.698]                       envir <- sys.frame(frame)
[13:20:30.698]                       master <- NULL
[13:20:30.698]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.698]                         !identical(envir, emptyenv())) {
[13:20:30.698]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.698]                           inherits = FALSE)) {
[13:20:30.698]                           master <- get("master", mode = "list", 
[13:20:30.698]                             envir = envir, inherits = FALSE)
[13:20:30.698]                           if (inherits(master, c("SOCKnode", 
[13:20:30.698]                             "SOCK0node"))) {
[13:20:30.698]                             sendCondition <<- function(cond) {
[13:20:30.698]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.698]                                 success = TRUE)
[13:20:30.698]                               parallel_sendData(master, data)
[13:20:30.698]                             }
[13:20:30.698]                             return(sendCondition)
[13:20:30.698]                           }
[13:20:30.698]                         }
[13:20:30.698]                         frame <- frame + 1L
[13:20:30.698]                         envir <- sys.frame(frame)
[13:20:30.698]                       }
[13:20:30.698]                     }
[13:20:30.698]                     sendCondition <<- function(cond) NULL
[13:20:30.698]                   }
[13:20:30.698]                 })
[13:20:30.698]                 withCallingHandlers({
[13:20:30.698]                   2
[13:20:30.698]                 }, immediateCondition = function(cond) {
[13:20:30.698]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.698]                   sendCondition(cond)
[13:20:30.698]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.698]                   {
[13:20:30.698]                     inherits <- base::inherits
[13:20:30.698]                     invokeRestart <- base::invokeRestart
[13:20:30.698]                     is.null <- base::is.null
[13:20:30.698]                     muffled <- FALSE
[13:20:30.698]                     if (inherits(cond, "message")) {
[13:20:30.698]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.698]                       if (muffled) 
[13:20:30.698]                         invokeRestart("muffleMessage")
[13:20:30.698]                     }
[13:20:30.698]                     else if (inherits(cond, "warning")) {
[13:20:30.698]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.698]                       if (muffled) 
[13:20:30.698]                         invokeRestart("muffleWarning")
[13:20:30.698]                     }
[13:20:30.698]                     else if (inherits(cond, "condition")) {
[13:20:30.698]                       if (!is.null(pattern)) {
[13:20:30.698]                         computeRestarts <- base::computeRestarts
[13:20:30.698]                         grepl <- base::grepl
[13:20:30.698]                         restarts <- computeRestarts(cond)
[13:20:30.698]                         for (restart in restarts) {
[13:20:30.698]                           name <- restart$name
[13:20:30.698]                           if (is.null(name)) 
[13:20:30.698]                             next
[13:20:30.698]                           if (!grepl(pattern, name)) 
[13:20:30.698]                             next
[13:20:30.698]                           invokeRestart(restart)
[13:20:30.698]                           muffled <- TRUE
[13:20:30.698]                           break
[13:20:30.698]                         }
[13:20:30.698]                       }
[13:20:30.698]                     }
[13:20:30.698]                     invisible(muffled)
[13:20:30.698]                   }
[13:20:30.698]                   muffleCondition(cond)
[13:20:30.698]                 })
[13:20:30.698]             }))
[13:20:30.698]             future::FutureResult(value = ...future.value$value, 
[13:20:30.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.698]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.698]                     ...future.globalenv.names))
[13:20:30.698]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.698]         }, condition = base::local({
[13:20:30.698]             c <- base::c
[13:20:30.698]             inherits <- base::inherits
[13:20:30.698]             invokeRestart <- base::invokeRestart
[13:20:30.698]             length <- base::length
[13:20:30.698]             list <- base::list
[13:20:30.698]             seq.int <- base::seq.int
[13:20:30.698]             signalCondition <- base::signalCondition
[13:20:30.698]             sys.calls <- base::sys.calls
[13:20:30.698]             `[[` <- base::`[[`
[13:20:30.698]             `+` <- base::`+`
[13:20:30.698]             `<<-` <- base::`<<-`
[13:20:30.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.698]                   3L)]
[13:20:30.698]             }
[13:20:30.698]             function(cond) {
[13:20:30.698]                 is_error <- inherits(cond, "error")
[13:20:30.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.698]                   NULL)
[13:20:30.698]                 if (is_error) {
[13:20:30.698]                   sessionInformation <- function() {
[13:20:30.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.698]                       search = base::search(), system = base::Sys.info())
[13:20:30.698]                   }
[13:20:30.698]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.698]                     cond$call), session = sessionInformation(), 
[13:20:30.698]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.698]                   signalCondition(cond)
[13:20:30.698]                 }
[13:20:30.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.698]                 "immediateCondition"))) {
[13:20:30.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.698]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.698]                   if (TRUE && !signal) {
[13:20:30.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.698]                     {
[13:20:30.698]                       inherits <- base::inherits
[13:20:30.698]                       invokeRestart <- base::invokeRestart
[13:20:30.698]                       is.null <- base::is.null
[13:20:30.698]                       muffled <- FALSE
[13:20:30.698]                       if (inherits(cond, "message")) {
[13:20:30.698]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.698]                         if (muffled) 
[13:20:30.698]                           invokeRestart("muffleMessage")
[13:20:30.698]                       }
[13:20:30.698]                       else if (inherits(cond, "warning")) {
[13:20:30.698]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.698]                         if (muffled) 
[13:20:30.698]                           invokeRestart("muffleWarning")
[13:20:30.698]                       }
[13:20:30.698]                       else if (inherits(cond, "condition")) {
[13:20:30.698]                         if (!is.null(pattern)) {
[13:20:30.698]                           computeRestarts <- base::computeRestarts
[13:20:30.698]                           grepl <- base::grepl
[13:20:30.698]                           restarts <- computeRestarts(cond)
[13:20:30.698]                           for (restart in restarts) {
[13:20:30.698]                             name <- restart$name
[13:20:30.698]                             if (is.null(name)) 
[13:20:30.698]                               next
[13:20:30.698]                             if (!grepl(pattern, name)) 
[13:20:30.698]                               next
[13:20:30.698]                             invokeRestart(restart)
[13:20:30.698]                             muffled <- TRUE
[13:20:30.698]                             break
[13:20:30.698]                           }
[13:20:30.698]                         }
[13:20:30.698]                       }
[13:20:30.698]                       invisible(muffled)
[13:20:30.698]                     }
[13:20:30.698]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.698]                   }
[13:20:30.698]                 }
[13:20:30.698]                 else {
[13:20:30.698]                   if (TRUE) {
[13:20:30.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.698]                     {
[13:20:30.698]                       inherits <- base::inherits
[13:20:30.698]                       invokeRestart <- base::invokeRestart
[13:20:30.698]                       is.null <- base::is.null
[13:20:30.698]                       muffled <- FALSE
[13:20:30.698]                       if (inherits(cond, "message")) {
[13:20:30.698]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.698]                         if (muffled) 
[13:20:30.698]                           invokeRestart("muffleMessage")
[13:20:30.698]                       }
[13:20:30.698]                       else if (inherits(cond, "warning")) {
[13:20:30.698]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.698]                         if (muffled) 
[13:20:30.698]                           invokeRestart("muffleWarning")
[13:20:30.698]                       }
[13:20:30.698]                       else if (inherits(cond, "condition")) {
[13:20:30.698]                         if (!is.null(pattern)) {
[13:20:30.698]                           computeRestarts <- base::computeRestarts
[13:20:30.698]                           grepl <- base::grepl
[13:20:30.698]                           restarts <- computeRestarts(cond)
[13:20:30.698]                           for (restart in restarts) {
[13:20:30.698]                             name <- restart$name
[13:20:30.698]                             if (is.null(name)) 
[13:20:30.698]                               next
[13:20:30.698]                             if (!grepl(pattern, name)) 
[13:20:30.698]                               next
[13:20:30.698]                             invokeRestart(restart)
[13:20:30.698]                             muffled <- TRUE
[13:20:30.698]                             break
[13:20:30.698]                           }
[13:20:30.698]                         }
[13:20:30.698]                       }
[13:20:30.698]                       invisible(muffled)
[13:20:30.698]                     }
[13:20:30.698]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.698]                   }
[13:20:30.698]                 }
[13:20:30.698]             }
[13:20:30.698]         }))
[13:20:30.698]     }, error = function(ex) {
[13:20:30.698]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.698]                 ...future.rng), started = ...future.startTime, 
[13:20:30.698]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.698]             version = "1.8"), class = "FutureResult")
[13:20:30.698]     }, finally = {
[13:20:30.698]         if (!identical(...future.workdir, getwd())) 
[13:20:30.698]             setwd(...future.workdir)
[13:20:30.698]         {
[13:20:30.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.698]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.698]             }
[13:20:30.698]             base::options(...future.oldOptions)
[13:20:30.698]             if (.Platform$OS.type == "windows") {
[13:20:30.698]                 old_names <- names(...future.oldEnvVars)
[13:20:30.698]                 envs <- base::Sys.getenv()
[13:20:30.698]                 names <- names(envs)
[13:20:30.698]                 common <- intersect(names, old_names)
[13:20:30.698]                 added <- setdiff(names, old_names)
[13:20:30.698]                 removed <- setdiff(old_names, names)
[13:20:30.698]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.698]                   envs[common]]
[13:20:30.698]                 NAMES <- toupper(changed)
[13:20:30.698]                 args <- list()
[13:20:30.698]                 for (kk in seq_along(NAMES)) {
[13:20:30.698]                   name <- changed[[kk]]
[13:20:30.698]                   NAME <- NAMES[[kk]]
[13:20:30.698]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.698]                     next
[13:20:30.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.698]                 }
[13:20:30.698]                 NAMES <- toupper(added)
[13:20:30.698]                 for (kk in seq_along(NAMES)) {
[13:20:30.698]                   name <- added[[kk]]
[13:20:30.698]                   NAME <- NAMES[[kk]]
[13:20:30.698]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.698]                     next
[13:20:30.698]                   args[[name]] <- ""
[13:20:30.698]                 }
[13:20:30.698]                 NAMES <- toupper(removed)
[13:20:30.698]                 for (kk in seq_along(NAMES)) {
[13:20:30.698]                   name <- removed[[kk]]
[13:20:30.698]                   NAME <- NAMES[[kk]]
[13:20:30.698]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.698]                     next
[13:20:30.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.698]                 }
[13:20:30.698]                 if (length(args) > 0) 
[13:20:30.698]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.698]             }
[13:20:30.698]             else {
[13:20:30.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.698]             }
[13:20:30.698]             {
[13:20:30.698]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.698]                   0L) {
[13:20:30.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.698]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.698]                   base::options(opts)
[13:20:30.698]                 }
[13:20:30.698]                 {
[13:20:30.698]                   {
[13:20:30.698]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.698]                     NULL
[13:20:30.698]                   }
[13:20:30.698]                   options(future.plan = NULL)
[13:20:30.698]                   if (is.na(NA_character_)) 
[13:20:30.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.698]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.698]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.698]                     envir = parent.frame()) 
[13:20:30.698]                   {
[13:20:30.698]                     if (is.function(workers)) 
[13:20:30.698]                       workers <- workers()
[13:20:30.698]                     workers <- structure(as.integer(workers), 
[13:20:30.698]                       class = class(workers))
[13:20:30.698]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.698]                       workers >= 1)
[13:20:30.698]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.698]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.698]                     }
[13:20:30.698]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.698]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.698]                       envir = envir)
[13:20:30.698]                     if (!future$lazy) 
[13:20:30.698]                       future <- run(future)
[13:20:30.698]                     invisible(future)
[13:20:30.698]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.698]                 }
[13:20:30.698]             }
[13:20:30.698]         }
[13:20:30.698]     })
[13:20:30.698]     if (TRUE) {
[13:20:30.698]         base::sink(type = "output", split = FALSE)
[13:20:30.698]         if (TRUE) {
[13:20:30.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.698]         }
[13:20:30.698]         else {
[13:20:30.698]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.698]         }
[13:20:30.698]         base::close(...future.stdout)
[13:20:30.698]         ...future.stdout <- NULL
[13:20:30.698]     }
[13:20:30.698]     ...future.result$conditions <- ...future.conditions
[13:20:30.698]     ...future.result$finished <- base::Sys.time()
[13:20:30.698]     ...future.result
[13:20:30.698] }
[13:20:30.702] MultisessionFuture started
[13:20:30.702] - Launch lazy future ... done
[13:20:30.702] run() for ‘MultisessionFuture’ ... done
[13:20:30.702] getGlobalsAndPackages() ...
[13:20:30.702] Searching for globals...
[13:20:30.702] 
[13:20:30.703] Searching for globals ... DONE
[13:20:30.703] - globals: [0] <none>
[13:20:30.703] getGlobalsAndPackages() ... DONE
[13:20:30.703] run() for ‘Future’ ...
[13:20:30.703] - state: ‘created’
[13:20:30.703] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.718] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.718] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.718]   - Field: ‘node’
[13:20:30.719]   - Field: ‘label’
[13:20:30.719]   - Field: ‘local’
[13:20:30.719]   - Field: ‘owner’
[13:20:30.719]   - Field: ‘envir’
[13:20:30.719]   - Field: ‘workers’
[13:20:30.719]   - Field: ‘packages’
[13:20:30.719]   - Field: ‘gc’
[13:20:30.719]   - Field: ‘conditions’
[13:20:30.719]   - Field: ‘persistent’
[13:20:30.719]   - Field: ‘expr’
[13:20:30.719]   - Field: ‘uuid’
[13:20:30.720]   - Field: ‘seed’
[13:20:30.720]   - Field: ‘version’
[13:20:30.720]   - Field: ‘result’
[13:20:30.720]   - Field: ‘asynchronous’
[13:20:30.720]   - Field: ‘calls’
[13:20:30.720]   - Field: ‘globals’
[13:20:30.720]   - Field: ‘stdout’
[13:20:30.720]   - Field: ‘earlySignal’
[13:20:30.720]   - Field: ‘lazy’
[13:20:30.720]   - Field: ‘state’
[13:20:30.721] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.721] - Launch lazy future ...
[13:20:30.721] Packages needed by the future expression (n = 0): <none>
[13:20:30.721] Packages needed by future strategies (n = 0): <none>
[13:20:30.721] {
[13:20:30.721]     {
[13:20:30.721]         {
[13:20:30.721]             ...future.startTime <- base::Sys.time()
[13:20:30.721]             {
[13:20:30.721]                 {
[13:20:30.721]                   {
[13:20:30.721]                     {
[13:20:30.721]                       base::local({
[13:20:30.721]                         has_future <- base::requireNamespace("future", 
[13:20:30.721]                           quietly = TRUE)
[13:20:30.721]                         if (has_future) {
[13:20:30.721]                           ns <- base::getNamespace("future")
[13:20:30.721]                           version <- ns[[".package"]][["version"]]
[13:20:30.721]                           if (is.null(version)) 
[13:20:30.721]                             version <- utils::packageVersion("future")
[13:20:30.721]                         }
[13:20:30.721]                         else {
[13:20:30.721]                           version <- NULL
[13:20:30.721]                         }
[13:20:30.721]                         if (!has_future || version < "1.8.0") {
[13:20:30.721]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.721]                             "", base::R.version$version.string), 
[13:20:30.721]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.721]                               "release", "version")], collapse = " "), 
[13:20:30.721]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.721]                             info)
[13:20:30.721]                           info <- base::paste(info, collapse = "; ")
[13:20:30.721]                           if (!has_future) {
[13:20:30.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.721]                               info)
[13:20:30.721]                           }
[13:20:30.721]                           else {
[13:20:30.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.721]                               info, version)
[13:20:30.721]                           }
[13:20:30.721]                           base::stop(msg)
[13:20:30.721]                         }
[13:20:30.721]                       })
[13:20:30.721]                     }
[13:20:30.721]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.721]                     base::options(mc.cores = 1L)
[13:20:30.721]                   }
[13:20:30.721]                   options(future.plan = NULL)
[13:20:30.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.721]                 }
[13:20:30.721]                 ...future.workdir <- getwd()
[13:20:30.721]             }
[13:20:30.721]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.721]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.721]         }
[13:20:30.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.721]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.721]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.721]             base::names(...future.oldOptions))
[13:20:30.721]     }
[13:20:30.721]     if (FALSE) {
[13:20:30.721]     }
[13:20:30.721]     else {
[13:20:30.721]         if (TRUE) {
[13:20:30.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.721]                 open = "w")
[13:20:30.721]         }
[13:20:30.721]         else {
[13:20:30.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.721]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.721]         }
[13:20:30.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.721]             base::sink(type = "output", split = FALSE)
[13:20:30.721]             base::close(...future.stdout)
[13:20:30.721]         }, add = TRUE)
[13:20:30.721]     }
[13:20:30.721]     ...future.frame <- base::sys.nframe()
[13:20:30.721]     ...future.conditions <- base::list()
[13:20:30.721]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.721]     if (FALSE) {
[13:20:30.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.721]     }
[13:20:30.721]     ...future.result <- base::tryCatch({
[13:20:30.721]         base::withCallingHandlers({
[13:20:30.721]             ...future.value <- base::withVisible(base::local({
[13:20:30.721]                 ...future.makeSendCondition <- local({
[13:20:30.721]                   sendCondition <- NULL
[13:20:30.721]                   function(frame = 1L) {
[13:20:30.721]                     if (is.function(sendCondition)) 
[13:20:30.721]                       return(sendCondition)
[13:20:30.721]                     ns <- getNamespace("parallel")
[13:20:30.721]                     if (exists("sendData", mode = "function", 
[13:20:30.721]                       envir = ns)) {
[13:20:30.721]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.721]                         envir = ns)
[13:20:30.721]                       envir <- sys.frame(frame)
[13:20:30.721]                       master <- NULL
[13:20:30.721]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.721]                         !identical(envir, emptyenv())) {
[13:20:30.721]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.721]                           inherits = FALSE)) {
[13:20:30.721]                           master <- get("master", mode = "list", 
[13:20:30.721]                             envir = envir, inherits = FALSE)
[13:20:30.721]                           if (inherits(master, c("SOCKnode", 
[13:20:30.721]                             "SOCK0node"))) {
[13:20:30.721]                             sendCondition <<- function(cond) {
[13:20:30.721]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.721]                                 success = TRUE)
[13:20:30.721]                               parallel_sendData(master, data)
[13:20:30.721]                             }
[13:20:30.721]                             return(sendCondition)
[13:20:30.721]                           }
[13:20:30.721]                         }
[13:20:30.721]                         frame <- frame + 1L
[13:20:30.721]                         envir <- sys.frame(frame)
[13:20:30.721]                       }
[13:20:30.721]                     }
[13:20:30.721]                     sendCondition <<- function(cond) NULL
[13:20:30.721]                   }
[13:20:30.721]                 })
[13:20:30.721]                 withCallingHandlers({
[13:20:30.721]                   NULL
[13:20:30.721]                 }, immediateCondition = function(cond) {
[13:20:30.721]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.721]                   sendCondition(cond)
[13:20:30.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.721]                   {
[13:20:30.721]                     inherits <- base::inherits
[13:20:30.721]                     invokeRestart <- base::invokeRestart
[13:20:30.721]                     is.null <- base::is.null
[13:20:30.721]                     muffled <- FALSE
[13:20:30.721]                     if (inherits(cond, "message")) {
[13:20:30.721]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.721]                       if (muffled) 
[13:20:30.721]                         invokeRestart("muffleMessage")
[13:20:30.721]                     }
[13:20:30.721]                     else if (inherits(cond, "warning")) {
[13:20:30.721]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.721]                       if (muffled) 
[13:20:30.721]                         invokeRestart("muffleWarning")
[13:20:30.721]                     }
[13:20:30.721]                     else if (inherits(cond, "condition")) {
[13:20:30.721]                       if (!is.null(pattern)) {
[13:20:30.721]                         computeRestarts <- base::computeRestarts
[13:20:30.721]                         grepl <- base::grepl
[13:20:30.721]                         restarts <- computeRestarts(cond)
[13:20:30.721]                         for (restart in restarts) {
[13:20:30.721]                           name <- restart$name
[13:20:30.721]                           if (is.null(name)) 
[13:20:30.721]                             next
[13:20:30.721]                           if (!grepl(pattern, name)) 
[13:20:30.721]                             next
[13:20:30.721]                           invokeRestart(restart)
[13:20:30.721]                           muffled <- TRUE
[13:20:30.721]                           break
[13:20:30.721]                         }
[13:20:30.721]                       }
[13:20:30.721]                     }
[13:20:30.721]                     invisible(muffled)
[13:20:30.721]                   }
[13:20:30.721]                   muffleCondition(cond)
[13:20:30.721]                 })
[13:20:30.721]             }))
[13:20:30.721]             future::FutureResult(value = ...future.value$value, 
[13:20:30.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.721]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.721]                     ...future.globalenv.names))
[13:20:30.721]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.721]         }, condition = base::local({
[13:20:30.721]             c <- base::c
[13:20:30.721]             inherits <- base::inherits
[13:20:30.721]             invokeRestart <- base::invokeRestart
[13:20:30.721]             length <- base::length
[13:20:30.721]             list <- base::list
[13:20:30.721]             seq.int <- base::seq.int
[13:20:30.721]             signalCondition <- base::signalCondition
[13:20:30.721]             sys.calls <- base::sys.calls
[13:20:30.721]             `[[` <- base::`[[`
[13:20:30.721]             `+` <- base::`+`
[13:20:30.721]             `<<-` <- base::`<<-`
[13:20:30.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.721]                   3L)]
[13:20:30.721]             }
[13:20:30.721]             function(cond) {
[13:20:30.721]                 is_error <- inherits(cond, "error")
[13:20:30.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.721]                   NULL)
[13:20:30.721]                 if (is_error) {
[13:20:30.721]                   sessionInformation <- function() {
[13:20:30.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.721]                       search = base::search(), system = base::Sys.info())
[13:20:30.721]                   }
[13:20:30.721]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.721]                     cond$call), session = sessionInformation(), 
[13:20:30.721]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.721]                   signalCondition(cond)
[13:20:30.721]                 }
[13:20:30.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.721]                 "immediateCondition"))) {
[13:20:30.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.721]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.721]                   if (TRUE && !signal) {
[13:20:30.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.721]                     {
[13:20:30.721]                       inherits <- base::inherits
[13:20:30.721]                       invokeRestart <- base::invokeRestart
[13:20:30.721]                       is.null <- base::is.null
[13:20:30.721]                       muffled <- FALSE
[13:20:30.721]                       if (inherits(cond, "message")) {
[13:20:30.721]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.721]                         if (muffled) 
[13:20:30.721]                           invokeRestart("muffleMessage")
[13:20:30.721]                       }
[13:20:30.721]                       else if (inherits(cond, "warning")) {
[13:20:30.721]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.721]                         if (muffled) 
[13:20:30.721]                           invokeRestart("muffleWarning")
[13:20:30.721]                       }
[13:20:30.721]                       else if (inherits(cond, "condition")) {
[13:20:30.721]                         if (!is.null(pattern)) {
[13:20:30.721]                           computeRestarts <- base::computeRestarts
[13:20:30.721]                           grepl <- base::grepl
[13:20:30.721]                           restarts <- computeRestarts(cond)
[13:20:30.721]                           for (restart in restarts) {
[13:20:30.721]                             name <- restart$name
[13:20:30.721]                             if (is.null(name)) 
[13:20:30.721]                               next
[13:20:30.721]                             if (!grepl(pattern, name)) 
[13:20:30.721]                               next
[13:20:30.721]                             invokeRestart(restart)
[13:20:30.721]                             muffled <- TRUE
[13:20:30.721]                             break
[13:20:30.721]                           }
[13:20:30.721]                         }
[13:20:30.721]                       }
[13:20:30.721]                       invisible(muffled)
[13:20:30.721]                     }
[13:20:30.721]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.721]                   }
[13:20:30.721]                 }
[13:20:30.721]                 else {
[13:20:30.721]                   if (TRUE) {
[13:20:30.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.721]                     {
[13:20:30.721]                       inherits <- base::inherits
[13:20:30.721]                       invokeRestart <- base::invokeRestart
[13:20:30.721]                       is.null <- base::is.null
[13:20:30.721]                       muffled <- FALSE
[13:20:30.721]                       if (inherits(cond, "message")) {
[13:20:30.721]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.721]                         if (muffled) 
[13:20:30.721]                           invokeRestart("muffleMessage")
[13:20:30.721]                       }
[13:20:30.721]                       else if (inherits(cond, "warning")) {
[13:20:30.721]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.721]                         if (muffled) 
[13:20:30.721]                           invokeRestart("muffleWarning")
[13:20:30.721]                       }
[13:20:30.721]                       else if (inherits(cond, "condition")) {
[13:20:30.721]                         if (!is.null(pattern)) {
[13:20:30.721]                           computeRestarts <- base::computeRestarts
[13:20:30.721]                           grepl <- base::grepl
[13:20:30.721]                           restarts <- computeRestarts(cond)
[13:20:30.721]                           for (restart in restarts) {
[13:20:30.721]                             name <- restart$name
[13:20:30.721]                             if (is.null(name)) 
[13:20:30.721]                               next
[13:20:30.721]                             if (!grepl(pattern, name)) 
[13:20:30.721]                               next
[13:20:30.721]                             invokeRestart(restart)
[13:20:30.721]                             muffled <- TRUE
[13:20:30.721]                             break
[13:20:30.721]                           }
[13:20:30.721]                         }
[13:20:30.721]                       }
[13:20:30.721]                       invisible(muffled)
[13:20:30.721]                     }
[13:20:30.721]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.721]                   }
[13:20:30.721]                 }
[13:20:30.721]             }
[13:20:30.721]         }))
[13:20:30.721]     }, error = function(ex) {
[13:20:30.721]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.721]                 ...future.rng), started = ...future.startTime, 
[13:20:30.721]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.721]             version = "1.8"), class = "FutureResult")
[13:20:30.721]     }, finally = {
[13:20:30.721]         if (!identical(...future.workdir, getwd())) 
[13:20:30.721]             setwd(...future.workdir)
[13:20:30.721]         {
[13:20:30.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.721]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.721]             }
[13:20:30.721]             base::options(...future.oldOptions)
[13:20:30.721]             if (.Platform$OS.type == "windows") {
[13:20:30.721]                 old_names <- names(...future.oldEnvVars)
[13:20:30.721]                 envs <- base::Sys.getenv()
[13:20:30.721]                 names <- names(envs)
[13:20:30.721]                 common <- intersect(names, old_names)
[13:20:30.721]                 added <- setdiff(names, old_names)
[13:20:30.721]                 removed <- setdiff(old_names, names)
[13:20:30.721]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.721]                   envs[common]]
[13:20:30.721]                 NAMES <- toupper(changed)
[13:20:30.721]                 args <- list()
[13:20:30.721]                 for (kk in seq_along(NAMES)) {
[13:20:30.721]                   name <- changed[[kk]]
[13:20:30.721]                   NAME <- NAMES[[kk]]
[13:20:30.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.721]                     next
[13:20:30.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.721]                 }
[13:20:30.721]                 NAMES <- toupper(added)
[13:20:30.721]                 for (kk in seq_along(NAMES)) {
[13:20:30.721]                   name <- added[[kk]]
[13:20:30.721]                   NAME <- NAMES[[kk]]
[13:20:30.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.721]                     next
[13:20:30.721]                   args[[name]] <- ""
[13:20:30.721]                 }
[13:20:30.721]                 NAMES <- toupper(removed)
[13:20:30.721]                 for (kk in seq_along(NAMES)) {
[13:20:30.721]                   name <- removed[[kk]]
[13:20:30.721]                   NAME <- NAMES[[kk]]
[13:20:30.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.721]                     next
[13:20:30.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.721]                 }
[13:20:30.721]                 if (length(args) > 0) 
[13:20:30.721]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.721]             }
[13:20:30.721]             else {
[13:20:30.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.721]             }
[13:20:30.721]             {
[13:20:30.721]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.721]                   0L) {
[13:20:30.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.721]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.721]                   base::options(opts)
[13:20:30.721]                 }
[13:20:30.721]                 {
[13:20:30.721]                   {
[13:20:30.721]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.721]                     NULL
[13:20:30.721]                   }
[13:20:30.721]                   options(future.plan = NULL)
[13:20:30.721]                   if (is.na(NA_character_)) 
[13:20:30.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.721]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.721]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.721]                     envir = parent.frame()) 
[13:20:30.721]                   {
[13:20:30.721]                     if (is.function(workers)) 
[13:20:30.721]                       workers <- workers()
[13:20:30.721]                     workers <- structure(as.integer(workers), 
[13:20:30.721]                       class = class(workers))
[13:20:30.721]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.721]                       workers >= 1)
[13:20:30.721]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.721]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.721]                     }
[13:20:30.721]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.721]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.721]                       envir = envir)
[13:20:30.721]                     if (!future$lazy) 
[13:20:30.721]                       future <- run(future)
[13:20:30.721]                     invisible(future)
[13:20:30.721]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.721]                 }
[13:20:30.721]             }
[13:20:30.721]         }
[13:20:30.721]     })
[13:20:30.721]     if (TRUE) {
[13:20:30.721]         base::sink(type = "output", split = FALSE)
[13:20:30.721]         if (TRUE) {
[13:20:30.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.721]         }
[13:20:30.721]         else {
[13:20:30.721]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.721]         }
[13:20:30.721]         base::close(...future.stdout)
[13:20:30.721]         ...future.stdout <- NULL
[13:20:30.721]     }
[13:20:30.721]     ...future.result$conditions <- ...future.conditions
[13:20:30.721]     ...future.result$finished <- base::Sys.time()
[13:20:30.721]     ...future.result
[13:20:30.721] }
[13:20:30.725] MultisessionFuture started
[13:20:30.725] - Launch lazy future ... done
[13:20:30.725] run() for ‘MultisessionFuture’ ... done
[13:20:30.725] getGlobalsAndPackages() ...
[13:20:30.725] Searching for globals...
[13:20:30.726] - globals found: [1] ‘{’
[13:20:30.726] Searching for globals ... DONE
[13:20:30.726] Resolving globals: FALSE
[13:20:30.727] 
[13:20:30.727] 
[13:20:30.727] getGlobalsAndPackages() ... DONE
[13:20:30.727] run() for ‘Future’ ...
[13:20:30.727] - state: ‘created’
[13:20:30.727] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:30.746] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:30.746] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:30.746]   - Field: ‘node’
[13:20:30.746]   - Field: ‘label’
[13:20:30.746]   - Field: ‘local’
[13:20:30.746]   - Field: ‘owner’
[13:20:30.746]   - Field: ‘envir’
[13:20:30.746]   - Field: ‘workers’
[13:20:30.747]   - Field: ‘packages’
[13:20:30.747]   - Field: ‘gc’
[13:20:30.747]   - Field: ‘conditions’
[13:20:30.747]   - Field: ‘persistent’
[13:20:30.747]   - Field: ‘expr’
[13:20:30.747]   - Field: ‘uuid’
[13:20:30.747]   - Field: ‘seed’
[13:20:30.747]   - Field: ‘version’
[13:20:30.747]   - Field: ‘result’
[13:20:30.747]   - Field: ‘asynchronous’
[13:20:30.747]   - Field: ‘calls’
[13:20:30.748]   - Field: ‘globals’
[13:20:30.748]   - Field: ‘stdout’
[13:20:30.748]   - Field: ‘earlySignal’
[13:20:30.748]   - Field: ‘lazy’
[13:20:30.748]   - Field: ‘state’
[13:20:30.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:30.748] - Launch lazy future ...
[13:20:30.748] Packages needed by the future expression (n = 0): <none>
[13:20:30.749] Packages needed by future strategies (n = 0): <none>
[13:20:30.749] {
[13:20:30.749]     {
[13:20:30.749]         {
[13:20:30.749]             ...future.startTime <- base::Sys.time()
[13:20:30.749]             {
[13:20:30.749]                 {
[13:20:30.749]                   {
[13:20:30.749]                     {
[13:20:30.749]                       base::local({
[13:20:30.749]                         has_future <- base::requireNamespace("future", 
[13:20:30.749]                           quietly = TRUE)
[13:20:30.749]                         if (has_future) {
[13:20:30.749]                           ns <- base::getNamespace("future")
[13:20:30.749]                           version <- ns[[".package"]][["version"]]
[13:20:30.749]                           if (is.null(version)) 
[13:20:30.749]                             version <- utils::packageVersion("future")
[13:20:30.749]                         }
[13:20:30.749]                         else {
[13:20:30.749]                           version <- NULL
[13:20:30.749]                         }
[13:20:30.749]                         if (!has_future || version < "1.8.0") {
[13:20:30.749]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:30.749]                             "", base::R.version$version.string), 
[13:20:30.749]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:30.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:30.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:30.749]                               "release", "version")], collapse = " "), 
[13:20:30.749]                             hostname = base::Sys.info()[["nodename"]])
[13:20:30.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:30.749]                             info)
[13:20:30.749]                           info <- base::paste(info, collapse = "; ")
[13:20:30.749]                           if (!has_future) {
[13:20:30.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:30.749]                               info)
[13:20:30.749]                           }
[13:20:30.749]                           else {
[13:20:30.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:30.749]                               info, version)
[13:20:30.749]                           }
[13:20:30.749]                           base::stop(msg)
[13:20:30.749]                         }
[13:20:30.749]                       })
[13:20:30.749]                     }
[13:20:30.749]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:30.749]                     base::options(mc.cores = 1L)
[13:20:30.749]                   }
[13:20:30.749]                   options(future.plan = NULL)
[13:20:30.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:30.749]                 }
[13:20:30.749]                 ...future.workdir <- getwd()
[13:20:30.749]             }
[13:20:30.749]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:30.749]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:30.749]         }
[13:20:30.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:30.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:30.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:30.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:30.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:30.749]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:30.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:30.749]             base::names(...future.oldOptions))
[13:20:30.749]     }
[13:20:30.749]     if (FALSE) {
[13:20:30.749]     }
[13:20:30.749]     else {
[13:20:30.749]         if (TRUE) {
[13:20:30.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:30.749]                 open = "w")
[13:20:30.749]         }
[13:20:30.749]         else {
[13:20:30.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:30.749]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:30.749]         }
[13:20:30.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:30.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:30.749]             base::sink(type = "output", split = FALSE)
[13:20:30.749]             base::close(...future.stdout)
[13:20:30.749]         }, add = TRUE)
[13:20:30.749]     }
[13:20:30.749]     ...future.frame <- base::sys.nframe()
[13:20:30.749]     ...future.conditions <- base::list()
[13:20:30.749]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:30.749]     if (FALSE) {
[13:20:30.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:30.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:30.749]     }
[13:20:30.749]     ...future.result <- base::tryCatch({
[13:20:30.749]         base::withCallingHandlers({
[13:20:30.749]             ...future.value <- base::withVisible(base::local({
[13:20:30.749]                 ...future.makeSendCondition <- local({
[13:20:30.749]                   sendCondition <- NULL
[13:20:30.749]                   function(frame = 1L) {
[13:20:30.749]                     if (is.function(sendCondition)) 
[13:20:30.749]                       return(sendCondition)
[13:20:30.749]                     ns <- getNamespace("parallel")
[13:20:30.749]                     if (exists("sendData", mode = "function", 
[13:20:30.749]                       envir = ns)) {
[13:20:30.749]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:30.749]                         envir = ns)
[13:20:30.749]                       envir <- sys.frame(frame)
[13:20:30.749]                       master <- NULL
[13:20:30.749]                       while (!identical(envir, .GlobalEnv) && 
[13:20:30.749]                         !identical(envir, emptyenv())) {
[13:20:30.749]                         if (exists("master", mode = "list", envir = envir, 
[13:20:30.749]                           inherits = FALSE)) {
[13:20:30.749]                           master <- get("master", mode = "list", 
[13:20:30.749]                             envir = envir, inherits = FALSE)
[13:20:30.749]                           if (inherits(master, c("SOCKnode", 
[13:20:30.749]                             "SOCK0node"))) {
[13:20:30.749]                             sendCondition <<- function(cond) {
[13:20:30.749]                               data <- list(type = "VALUE", value = cond, 
[13:20:30.749]                                 success = TRUE)
[13:20:30.749]                               parallel_sendData(master, data)
[13:20:30.749]                             }
[13:20:30.749]                             return(sendCondition)
[13:20:30.749]                           }
[13:20:30.749]                         }
[13:20:30.749]                         frame <- frame + 1L
[13:20:30.749]                         envir <- sys.frame(frame)
[13:20:30.749]                       }
[13:20:30.749]                     }
[13:20:30.749]                     sendCondition <<- function(cond) NULL
[13:20:30.749]                   }
[13:20:30.749]                 })
[13:20:30.749]                 withCallingHandlers({
[13:20:30.749]                   {
[13:20:30.749]                     4
[13:20:30.749]                   }
[13:20:30.749]                 }, immediateCondition = function(cond) {
[13:20:30.749]                   sendCondition <- ...future.makeSendCondition()
[13:20:30.749]                   sendCondition(cond)
[13:20:30.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.749]                   {
[13:20:30.749]                     inherits <- base::inherits
[13:20:30.749]                     invokeRestart <- base::invokeRestart
[13:20:30.749]                     is.null <- base::is.null
[13:20:30.749]                     muffled <- FALSE
[13:20:30.749]                     if (inherits(cond, "message")) {
[13:20:30.749]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:30.749]                       if (muffled) 
[13:20:30.749]                         invokeRestart("muffleMessage")
[13:20:30.749]                     }
[13:20:30.749]                     else if (inherits(cond, "warning")) {
[13:20:30.749]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:30.749]                       if (muffled) 
[13:20:30.749]                         invokeRestart("muffleWarning")
[13:20:30.749]                     }
[13:20:30.749]                     else if (inherits(cond, "condition")) {
[13:20:30.749]                       if (!is.null(pattern)) {
[13:20:30.749]                         computeRestarts <- base::computeRestarts
[13:20:30.749]                         grepl <- base::grepl
[13:20:30.749]                         restarts <- computeRestarts(cond)
[13:20:30.749]                         for (restart in restarts) {
[13:20:30.749]                           name <- restart$name
[13:20:30.749]                           if (is.null(name)) 
[13:20:30.749]                             next
[13:20:30.749]                           if (!grepl(pattern, name)) 
[13:20:30.749]                             next
[13:20:30.749]                           invokeRestart(restart)
[13:20:30.749]                           muffled <- TRUE
[13:20:30.749]                           break
[13:20:30.749]                         }
[13:20:30.749]                       }
[13:20:30.749]                     }
[13:20:30.749]                     invisible(muffled)
[13:20:30.749]                   }
[13:20:30.749]                   muffleCondition(cond)
[13:20:30.749]                 })
[13:20:30.749]             }))
[13:20:30.749]             future::FutureResult(value = ...future.value$value, 
[13:20:30.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.749]                   ...future.rng), globalenv = if (FALSE) 
[13:20:30.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:30.749]                     ...future.globalenv.names))
[13:20:30.749]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:30.749]         }, condition = base::local({
[13:20:30.749]             c <- base::c
[13:20:30.749]             inherits <- base::inherits
[13:20:30.749]             invokeRestart <- base::invokeRestart
[13:20:30.749]             length <- base::length
[13:20:30.749]             list <- base::list
[13:20:30.749]             seq.int <- base::seq.int
[13:20:30.749]             signalCondition <- base::signalCondition
[13:20:30.749]             sys.calls <- base::sys.calls
[13:20:30.749]             `[[` <- base::`[[`
[13:20:30.749]             `+` <- base::`+`
[13:20:30.749]             `<<-` <- base::`<<-`
[13:20:30.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:30.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:30.749]                   3L)]
[13:20:30.749]             }
[13:20:30.749]             function(cond) {
[13:20:30.749]                 is_error <- inherits(cond, "error")
[13:20:30.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:30.749]                   NULL)
[13:20:30.749]                 if (is_error) {
[13:20:30.749]                   sessionInformation <- function() {
[13:20:30.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:30.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:30.749]                       search = base::search(), system = base::Sys.info())
[13:20:30.749]                   }
[13:20:30.749]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:30.749]                     cond$call), session = sessionInformation(), 
[13:20:30.749]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:30.749]                   signalCondition(cond)
[13:20:30.749]                 }
[13:20:30.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:30.749]                 "immediateCondition"))) {
[13:20:30.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:30.749]                   ...future.conditions[[length(...future.conditions) + 
[13:20:30.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:30.749]                   if (TRUE && !signal) {
[13:20:30.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.749]                     {
[13:20:30.749]                       inherits <- base::inherits
[13:20:30.749]                       invokeRestart <- base::invokeRestart
[13:20:30.749]                       is.null <- base::is.null
[13:20:30.749]                       muffled <- FALSE
[13:20:30.749]                       if (inherits(cond, "message")) {
[13:20:30.749]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.749]                         if (muffled) 
[13:20:30.749]                           invokeRestart("muffleMessage")
[13:20:30.749]                       }
[13:20:30.749]                       else if (inherits(cond, "warning")) {
[13:20:30.749]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.749]                         if (muffled) 
[13:20:30.749]                           invokeRestart("muffleWarning")
[13:20:30.749]                       }
[13:20:30.749]                       else if (inherits(cond, "condition")) {
[13:20:30.749]                         if (!is.null(pattern)) {
[13:20:30.749]                           computeRestarts <- base::computeRestarts
[13:20:30.749]                           grepl <- base::grepl
[13:20:30.749]                           restarts <- computeRestarts(cond)
[13:20:30.749]                           for (restart in restarts) {
[13:20:30.749]                             name <- restart$name
[13:20:30.749]                             if (is.null(name)) 
[13:20:30.749]                               next
[13:20:30.749]                             if (!grepl(pattern, name)) 
[13:20:30.749]                               next
[13:20:30.749]                             invokeRestart(restart)
[13:20:30.749]                             muffled <- TRUE
[13:20:30.749]                             break
[13:20:30.749]                           }
[13:20:30.749]                         }
[13:20:30.749]                       }
[13:20:30.749]                       invisible(muffled)
[13:20:30.749]                     }
[13:20:30.749]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.749]                   }
[13:20:30.749]                 }
[13:20:30.749]                 else {
[13:20:30.749]                   if (TRUE) {
[13:20:30.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:30.749]                     {
[13:20:30.749]                       inherits <- base::inherits
[13:20:30.749]                       invokeRestart <- base::invokeRestart
[13:20:30.749]                       is.null <- base::is.null
[13:20:30.749]                       muffled <- FALSE
[13:20:30.749]                       if (inherits(cond, "message")) {
[13:20:30.749]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:30.749]                         if (muffled) 
[13:20:30.749]                           invokeRestart("muffleMessage")
[13:20:30.749]                       }
[13:20:30.749]                       else if (inherits(cond, "warning")) {
[13:20:30.749]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:30.749]                         if (muffled) 
[13:20:30.749]                           invokeRestart("muffleWarning")
[13:20:30.749]                       }
[13:20:30.749]                       else if (inherits(cond, "condition")) {
[13:20:30.749]                         if (!is.null(pattern)) {
[13:20:30.749]                           computeRestarts <- base::computeRestarts
[13:20:30.749]                           grepl <- base::grepl
[13:20:30.749]                           restarts <- computeRestarts(cond)
[13:20:30.749]                           for (restart in restarts) {
[13:20:30.749]                             name <- restart$name
[13:20:30.749]                             if (is.null(name)) 
[13:20:30.749]                               next
[13:20:30.749]                             if (!grepl(pattern, name)) 
[13:20:30.749]                               next
[13:20:30.749]                             invokeRestart(restart)
[13:20:30.749]                             muffled <- TRUE
[13:20:30.749]                             break
[13:20:30.749]                           }
[13:20:30.749]                         }
[13:20:30.749]                       }
[13:20:30.749]                       invisible(muffled)
[13:20:30.749]                     }
[13:20:30.749]                     muffleCondition(cond, pattern = "^muffle")
[13:20:30.749]                   }
[13:20:30.749]                 }
[13:20:30.749]             }
[13:20:30.749]         }))
[13:20:30.749]     }, error = function(ex) {
[13:20:30.749]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:30.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:30.749]                 ...future.rng), started = ...future.startTime, 
[13:20:30.749]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:30.749]             version = "1.8"), class = "FutureResult")
[13:20:30.749]     }, finally = {
[13:20:30.749]         if (!identical(...future.workdir, getwd())) 
[13:20:30.749]             setwd(...future.workdir)
[13:20:30.749]         {
[13:20:30.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:30.749]                 ...future.oldOptions$nwarnings <- NULL
[13:20:30.749]             }
[13:20:30.749]             base::options(...future.oldOptions)
[13:20:30.749]             if (.Platform$OS.type == "windows") {
[13:20:30.749]                 old_names <- names(...future.oldEnvVars)
[13:20:30.749]                 envs <- base::Sys.getenv()
[13:20:30.749]                 names <- names(envs)
[13:20:30.749]                 common <- intersect(names, old_names)
[13:20:30.749]                 added <- setdiff(names, old_names)
[13:20:30.749]                 removed <- setdiff(old_names, names)
[13:20:30.749]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:30.749]                   envs[common]]
[13:20:30.749]                 NAMES <- toupper(changed)
[13:20:30.749]                 args <- list()
[13:20:30.749]                 for (kk in seq_along(NAMES)) {
[13:20:30.749]                   name <- changed[[kk]]
[13:20:30.749]                   NAME <- NAMES[[kk]]
[13:20:30.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.749]                     next
[13:20:30.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.749]                 }
[13:20:30.749]                 NAMES <- toupper(added)
[13:20:30.749]                 for (kk in seq_along(NAMES)) {
[13:20:30.749]                   name <- added[[kk]]
[13:20:30.749]                   NAME <- NAMES[[kk]]
[13:20:30.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.749]                     next
[13:20:30.749]                   args[[name]] <- ""
[13:20:30.749]                 }
[13:20:30.749]                 NAMES <- toupper(removed)
[13:20:30.749]                 for (kk in seq_along(NAMES)) {
[13:20:30.749]                   name <- removed[[kk]]
[13:20:30.749]                   NAME <- NAMES[[kk]]
[13:20:30.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:30.749]                     next
[13:20:30.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:30.749]                 }
[13:20:30.749]                 if (length(args) > 0) 
[13:20:30.749]                   base::do.call(base::Sys.setenv, args = args)
[13:20:30.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:30.749]             }
[13:20:30.749]             else {
[13:20:30.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:30.749]             }
[13:20:30.749]             {
[13:20:30.749]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:30.749]                   0L) {
[13:20:30.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:30.749]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:30.749]                   base::options(opts)
[13:20:30.749]                 }
[13:20:30.749]                 {
[13:20:30.749]                   {
[13:20:30.749]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:30.749]                     NULL
[13:20:30.749]                   }
[13:20:30.749]                   options(future.plan = NULL)
[13:20:30.749]                   if (is.na(NA_character_)) 
[13:20:30.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:30.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:30.749]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:30.749]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:30.749]                     envir = parent.frame()) 
[13:20:30.749]                   {
[13:20:30.749]                     if (is.function(workers)) 
[13:20:30.749]                       workers <- workers()
[13:20:30.749]                     workers <- structure(as.integer(workers), 
[13:20:30.749]                       class = class(workers))
[13:20:30.749]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:30.749]                       workers >= 1)
[13:20:30.749]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:30.749]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:30.749]                     }
[13:20:30.749]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:30.749]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:30.749]                       envir = envir)
[13:20:30.749]                     if (!future$lazy) 
[13:20:30.749]                       future <- run(future)
[13:20:30.749]                     invisible(future)
[13:20:30.749]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:30.749]                 }
[13:20:30.749]             }
[13:20:30.749]         }
[13:20:30.749]     })
[13:20:30.749]     if (TRUE) {
[13:20:30.749]         base::sink(type = "output", split = FALSE)
[13:20:30.749]         if (TRUE) {
[13:20:30.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:30.749]         }
[13:20:30.749]         else {
[13:20:30.749]             ...future.result["stdout"] <- base::list(NULL)
[13:20:30.749]         }
[13:20:30.749]         base::close(...future.stdout)
[13:20:30.749]         ...future.stdout <- NULL
[13:20:30.749]     }
[13:20:30.749]     ...future.result$conditions <- ...future.conditions
[13:20:30.749]     ...future.result$finished <- base::Sys.time()
[13:20:30.749]     ...future.result
[13:20:30.749] }
[13:20:30.751] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:30.762] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.762] - Validating connection of MultisessionFuture
[13:20:30.762] - received message: FutureResult
[13:20:30.763] - Received FutureResult
[13:20:30.763] - Erased future from FutureRegistry
[13:20:30.763] result() for ClusterFuture ...
[13:20:30.763] - result already collected: FutureResult
[13:20:30.763] result() for ClusterFuture ... done
[13:20:30.763] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:30.763] result() for ClusterFuture ...
[13:20:30.763] - result already collected: FutureResult
[13:20:30.763] result() for ClusterFuture ... done
[13:20:30.764] result() for ClusterFuture ...
[13:20:30.764] - result already collected: FutureResult
[13:20:30.764] result() for ClusterFuture ... done
[13:20:30.765] MultisessionFuture started
[13:20:30.765] - Launch lazy future ... done
[13:20:30.765] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55659d12ee30> 
Classes 'listenv', 'environment' <environment: 0x55659bdc5218> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:20:30.773] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.773] - Validating connection of MultisessionFuture
[13:20:30.774] - received message: FutureResult
[13:20:30.774] - Received FutureResult
[13:20:30.774] - Erased future from FutureRegistry
[13:20:30.774] result() for ClusterFuture ...
[13:20:30.774] - result already collected: FutureResult
[13:20:30.774] result() for ClusterFuture ... done
[13:20:30.774] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:20:30.788] resolve() on list environment ...
[13:20:30.788]  recursive: 0
[13:20:30.789]  length: 6
[13:20:30.789]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:20:30.789] signalConditionsASAP(numeric, pos=1) ...
[13:20:30.789] - nx: 6
[13:20:30.790] - relay: TRUE
[13:20:30.790] - stdout: TRUE
[13:20:30.790] - signal: TRUE
[13:20:30.790] - resignal: FALSE
[13:20:30.790] - force: TRUE
[13:20:30.790] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.790] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.790]  - until=2
[13:20:30.790]  - relaying element #2
[13:20:30.790] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.790] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.790] signalConditionsASAP(NULL, pos=1) ... done
[13:20:30.791]  length: 5 (resolved future 1)
[13:20:30.791] Future #2
[13:20:30.791] result() for ClusterFuture ...
[13:20:30.791] - result already collected: FutureResult
[13:20:30.791] result() for ClusterFuture ... done
[13:20:30.791] result() for ClusterFuture ...
[13:20:30.791] - result already collected: FutureResult
[13:20:30.791] result() for ClusterFuture ... done
[13:20:30.791] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:30.792] - nx: 6
[13:20:30.792] - relay: TRUE
[13:20:30.792] - stdout: TRUE
[13:20:30.792] - signal: TRUE
[13:20:30.792] - resignal: FALSE
[13:20:30.792] - force: TRUE
[13:20:30.792] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.792] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:20:30.792]  - until=2
[13:20:30.792]  - relaying element #2
[13:20:30.792] result() for ClusterFuture ...
[13:20:30.793] - result already collected: FutureResult
[13:20:30.793] result() for ClusterFuture ... done
[13:20:30.793] result() for ClusterFuture ...
[13:20:30.793] - result already collected: FutureResult
[13:20:30.793] result() for ClusterFuture ... done
[13:20:30.793] result() for ClusterFuture ...
[13:20:30.793] - result already collected: FutureResult
[13:20:30.793] result() for ClusterFuture ... done
[13:20:30.793] result() for ClusterFuture ...
[13:20:30.794] - result already collected: FutureResult
[13:20:30.794] result() for ClusterFuture ... done
[13:20:30.794] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.794] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.794] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:30.794]  length: 4 (resolved future 2)
[13:20:30.794] Future #3
[13:20:30.794] result() for ClusterFuture ...
[13:20:30.794] - result already collected: FutureResult
[13:20:30.795] result() for ClusterFuture ... done
[13:20:30.795] result() for ClusterFuture ...
[13:20:30.795] - result already collected: FutureResult
[13:20:30.795] result() for ClusterFuture ... done
[13:20:30.795] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:20:30.795] - nx: 6
[13:20:30.795] - relay: TRUE
[13:20:30.795] - stdout: TRUE
[13:20:30.795] - signal: TRUE
[13:20:30.795] - resignal: FALSE
[13:20:30.795] - force: TRUE
[13:20:30.796] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.796] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:20:30.796]  - until=3
[13:20:30.796]  - relaying element #3
[13:20:30.796] result() for ClusterFuture ...
[13:20:30.796] - result already collected: FutureResult
[13:20:30.796] result() for ClusterFuture ... done
[13:20:30.796] result() for ClusterFuture ...
[13:20:30.796] - result already collected: FutureResult
[13:20:30.796] result() for ClusterFuture ... done
[13:20:30.797] result() for ClusterFuture ...
[13:20:30.797] - result already collected: FutureResult
[13:20:30.797] result() for ClusterFuture ... done
[13:20:30.797] result() for ClusterFuture ...
[13:20:30.797] - result already collected: FutureResult
[13:20:30.797] result() for ClusterFuture ... done
[13:20:30.797] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.797] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.797] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:20:30.797]  length: 3 (resolved future 3)
[13:20:30.808] signalConditionsASAP(NULL, pos=5) ...
[13:20:30.808] - nx: 6
[13:20:30.808] - relay: TRUE
[13:20:30.808] - stdout: TRUE
[13:20:30.809] - signal: TRUE
[13:20:30.809] - resignal: FALSE
[13:20:30.809] - force: TRUE
[13:20:30.809] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.809] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.809]  - until=6
[13:20:30.809]  - relaying element #4
[13:20:30.809]  - relaying element #6
[13:20:30.809] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:20:30.809] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.810] signalConditionsASAP(NULL, pos=5) ... done
[13:20:30.810]  length: 2 (resolved future 5)
[13:20:30.810] signalConditionsASAP(numeric, pos=6) ...
[13:20:30.810] - nx: 6
[13:20:30.810] - relay: TRUE
[13:20:30.810] - stdout: TRUE
[13:20:30.810] - signal: TRUE
[13:20:30.810] - resignal: FALSE
[13:20:30.810] - force: TRUE
[13:20:30.810] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:20:30.810] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.811]  - until=6
[13:20:30.811]  - relaying element #4
[13:20:30.811] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:20:30.811] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.811] signalConditionsASAP(NULL, pos=6) ... done
[13:20:30.811]  length: 1 (resolved future 6)
[13:20:30.822] receiveMessageFromWorker() for ClusterFuture ...
[13:20:30.822] - Validating connection of MultisessionFuture
[13:20:30.822] - received message: FutureResult
[13:20:30.822] - Received FutureResult
[13:20:30.823] - Erased future from FutureRegistry
[13:20:30.823] result() for ClusterFuture ...
[13:20:30.823] - result already collected: FutureResult
[13:20:30.823] result() for ClusterFuture ... done
[13:20:30.823] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:30.823] Future #4
[13:20:30.823] result() for ClusterFuture ...
[13:20:30.823] - result already collected: FutureResult
[13:20:30.824] result() for ClusterFuture ... done
[13:20:30.824] result() for ClusterFuture ...
[13:20:30.824] - result already collected: FutureResult
[13:20:30.824] result() for ClusterFuture ... done
[13:20:30.824] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:20:30.824] - nx: 6
[13:20:30.824] - relay: TRUE
[13:20:30.824] - stdout: TRUE
[13:20:30.824] - signal: TRUE
[13:20:30.825] - resignal: FALSE
[13:20:30.825] - force: TRUE
[13:20:30.825] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:20:30.825] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:20:30.825]  - until=6
[13:20:30.825]  - relaying element #4
[13:20:30.825] result() for ClusterFuture ...
[13:20:30.825] - result already collected: FutureResult
[13:20:30.826] result() for ClusterFuture ... done
[13:20:30.826] result() for ClusterFuture ...
[13:20:30.826] - result already collected: FutureResult
[13:20:30.826] result() for ClusterFuture ... done
[13:20:30.826] result() for ClusterFuture ...
[13:20:30.826] - result already collected: FutureResult
[13:20:30.826] result() for ClusterFuture ... done
[13:20:30.826] result() for ClusterFuture ...
[13:20:30.826] - result already collected: FutureResult
[13:20:30.827] result() for ClusterFuture ... done
[13:20:30.827] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.827] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:30.827] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:20:30.827]  length: 0 (resolved future 4)
[13:20:30.827] Relaying remaining futures
[13:20:30.827] signalConditionsASAP(NULL, pos=0) ...
[13:20:30.827] - nx: 6
[13:20:30.827] - relay: TRUE
[13:20:30.828] - stdout: TRUE
[13:20:30.828] - signal: TRUE
[13:20:30.828] - resignal: FALSE
[13:20:30.828] - force: TRUE
[13:20:30.828] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.828] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:20:30.828] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:20:30.828] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:20:30.828] signalConditionsASAP(NULL, pos=0) ... done
[13:20:30.829] resolve() on list environment ... DONE
[13:20:30.829] result() for ClusterFuture ...
[13:20:30.829] - result already collected: FutureResult
[13:20:30.829] result() for ClusterFuture ... done
[13:20:30.829] result() for ClusterFuture ...
[13:20:30.829] - result already collected: FutureResult
[13:20:30.829] result() for ClusterFuture ... done
[13:20:30.829] result() for ClusterFuture ...
[13:20:30.829] - result already collected: FutureResult
[13:20:30.829] result() for ClusterFuture ... done
[13:20:30.830] result() for ClusterFuture ...
[13:20:30.830] - result already collected: FutureResult
[13:20:30.830] result() for ClusterFuture ... done
[13:20:30.830] result() for ClusterFuture ...
[13:20:30.830] - result already collected: FutureResult
[13:20:30.830] result() for ClusterFuture ... done
[13:20:30.830] result() for ClusterFuture ...
[13:20:30.830] - result already collected: FutureResult
[13:20:30.830] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55659b614bf8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[13:20:30.833] plan(): Setting new future strategy stack:
[13:20:30.834] List of future strategies:
[13:20:30.834] 1. FutureStrategy:
[13:20:30.834]    - args: function (..., envir = parent.frame())
[13:20:30.834]    - tweaked: FALSE
[13:20:30.834]    - call: future::plan(oplan)
[13:20:30.834] plan(): nbrOfWorkers() = 1
> 
