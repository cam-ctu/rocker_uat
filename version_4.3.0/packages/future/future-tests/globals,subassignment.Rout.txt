
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:42:39.007] plan(): Setting new future strategy stack:
[17:42:39.008] List of future strategies:
[17:42:39.008] 1. sequential:
[17:42:39.008]    - args: function (..., envir = parent.frame())
[17:42:39.008]    - tweaked: FALSE
[17:42:39.008]    - call: future::plan("sequential")
[17:42:39.022] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[17:42:39.090] plan(): Setting new future strategy stack:
[17:42:39.090] List of future strategies:
[17:42:39.090] 1. sequential:
[17:42:39.090]    - args: function (..., envir = parent.frame())
[17:42:39.090]    - tweaked: FALSE
[17:42:39.090]    - call: plan(strategy)
[17:42:39.101] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.102] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.102] Searching for globals...
[17:42:39.111] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.111] Searching for globals ... DONE
[17:42:39.111] Resolving globals: TRUE
[17:42:39.112] Resolving any globals that are futures ...
[17:42:39.112] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.112] Resolving any globals that are futures ... DONE
[17:42:39.112] Resolving futures part of globals (recursively) ...
[17:42:39.113] resolve() on list ...
[17:42:39.113]  recursive: 99
[17:42:39.114]  length: 1
[17:42:39.114]  elements: ‘x’
[17:42:39.114]  length: 0 (resolved future 1)
[17:42:39.114] resolve() on list ... DONE
[17:42:39.114] - globals: [1] ‘x’
[17:42:39.114] Resolving futures part of globals (recursively) ... DONE
[17:42:39.115] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.115] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.115] - globals: [1] ‘x’
[17:42:39.115] 
[17:42:39.115] getGlobalsAndPackages() ... DONE
[17:42:39.116] run() for ‘Future’ ...
[17:42:39.116] - state: ‘created’
[17:42:39.116] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.117] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.117] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.117]   - Field: ‘label’
[17:42:39.117]   - Field: ‘local’
[17:42:39.117]   - Field: ‘owner’
[17:42:39.117]   - Field: ‘envir’
[17:42:39.117]   - Field: ‘packages’
[17:42:39.117]   - Field: ‘gc’
[17:42:39.117]   - Field: ‘conditions’
[17:42:39.118]   - Field: ‘expr’
[17:42:39.118]   - Field: ‘uuid’
[17:42:39.118]   - Field: ‘seed’
[17:42:39.118]   - Field: ‘version’
[17:42:39.118]   - Field: ‘result’
[17:42:39.118]   - Field: ‘asynchronous’
[17:42:39.118]   - Field: ‘calls’
[17:42:39.118]   - Field: ‘globals’
[17:42:39.118]   - Field: ‘stdout’
[17:42:39.118]   - Field: ‘earlySignal’
[17:42:39.118]   - Field: ‘lazy’
[17:42:39.119]   - Field: ‘state’
[17:42:39.119] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.119] - Launch lazy future ...
[17:42:39.120] Packages needed by the future expression (n = 0): <none>
[17:42:39.120] Packages needed by future strategies (n = 0): <none>
[17:42:39.120] {
[17:42:39.120]     {
[17:42:39.120]         {
[17:42:39.120]             ...future.startTime <- base::Sys.time()
[17:42:39.120]             {
[17:42:39.120]                 {
[17:42:39.120]                   {
[17:42:39.120]                     base::local({
[17:42:39.120]                       has_future <- base::requireNamespace("future", 
[17:42:39.120]                         quietly = TRUE)
[17:42:39.120]                       if (has_future) {
[17:42:39.120]                         ns <- base::getNamespace("future")
[17:42:39.120]                         version <- ns[[".package"]][["version"]]
[17:42:39.120]                         if (is.null(version)) 
[17:42:39.120]                           version <- utils::packageVersion("future")
[17:42:39.120]                       }
[17:42:39.120]                       else {
[17:42:39.120]                         version <- NULL
[17:42:39.120]                       }
[17:42:39.120]                       if (!has_future || version < "1.8.0") {
[17:42:39.120]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.120]                           "", base::R.version$version.string), 
[17:42:39.120]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.120]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.120]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.120]                             "release", "version")], collapse = " "), 
[17:42:39.120]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.120]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.120]                           info)
[17:42:39.120]                         info <- base::paste(info, collapse = "; ")
[17:42:39.120]                         if (!has_future) {
[17:42:39.120]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.120]                             info)
[17:42:39.120]                         }
[17:42:39.120]                         else {
[17:42:39.120]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.120]                             info, version)
[17:42:39.120]                         }
[17:42:39.120]                         base::stop(msg)
[17:42:39.120]                       }
[17:42:39.120]                     })
[17:42:39.120]                   }
[17:42:39.120]                   options(future.plan = NULL)
[17:42:39.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.120]                 }
[17:42:39.120]                 ...future.workdir <- getwd()
[17:42:39.120]             }
[17:42:39.120]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.120]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.120]         }
[17:42:39.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.120]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.120]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.120]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.120]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.120]             base::names(...future.oldOptions))
[17:42:39.120]     }
[17:42:39.120]     if (FALSE) {
[17:42:39.120]     }
[17:42:39.120]     else {
[17:42:39.120]         if (TRUE) {
[17:42:39.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.120]                 open = "w")
[17:42:39.120]         }
[17:42:39.120]         else {
[17:42:39.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.120]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.120]         }
[17:42:39.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.120]             base::sink(type = "output", split = FALSE)
[17:42:39.120]             base::close(...future.stdout)
[17:42:39.120]         }, add = TRUE)
[17:42:39.120]     }
[17:42:39.120]     ...future.frame <- base::sys.nframe()
[17:42:39.120]     ...future.conditions <- base::list()
[17:42:39.120]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.120]     if (FALSE) {
[17:42:39.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.120]     }
[17:42:39.120]     ...future.result <- base::tryCatch({
[17:42:39.120]         base::withCallingHandlers({
[17:42:39.120]             ...future.value <- base::withVisible(base::local({
[17:42:39.120]                 x$a <- 1
[17:42:39.120]                 x
[17:42:39.120]             }))
[17:42:39.120]             future::FutureResult(value = ...future.value$value, 
[17:42:39.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.120]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.120]                     ...future.globalenv.names))
[17:42:39.120]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.120]         }, condition = base::local({
[17:42:39.120]             c <- base::c
[17:42:39.120]             inherits <- base::inherits
[17:42:39.120]             invokeRestart <- base::invokeRestart
[17:42:39.120]             length <- base::length
[17:42:39.120]             list <- base::list
[17:42:39.120]             seq.int <- base::seq.int
[17:42:39.120]             signalCondition <- base::signalCondition
[17:42:39.120]             sys.calls <- base::sys.calls
[17:42:39.120]             `[[` <- base::`[[`
[17:42:39.120]             `+` <- base::`+`
[17:42:39.120]             `<<-` <- base::`<<-`
[17:42:39.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.120]                   3L)]
[17:42:39.120]             }
[17:42:39.120]             function(cond) {
[17:42:39.120]                 is_error <- inherits(cond, "error")
[17:42:39.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.120]                   NULL)
[17:42:39.120]                 if (is_error) {
[17:42:39.120]                   sessionInformation <- function() {
[17:42:39.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.120]                       search = base::search(), system = base::Sys.info())
[17:42:39.120]                   }
[17:42:39.120]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.120]                     cond$call), session = sessionInformation(), 
[17:42:39.120]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.120]                   signalCondition(cond)
[17:42:39.120]                 }
[17:42:39.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.120]                 "immediateCondition"))) {
[17:42:39.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.120]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.120]                   if (TRUE && !signal) {
[17:42:39.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.120]                     {
[17:42:39.120]                       inherits <- base::inherits
[17:42:39.120]                       invokeRestart <- base::invokeRestart
[17:42:39.120]                       is.null <- base::is.null
[17:42:39.120]                       muffled <- FALSE
[17:42:39.120]                       if (inherits(cond, "message")) {
[17:42:39.120]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.120]                         if (muffled) 
[17:42:39.120]                           invokeRestart("muffleMessage")
[17:42:39.120]                       }
[17:42:39.120]                       else if (inherits(cond, "warning")) {
[17:42:39.120]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.120]                         if (muffled) 
[17:42:39.120]                           invokeRestart("muffleWarning")
[17:42:39.120]                       }
[17:42:39.120]                       else if (inherits(cond, "condition")) {
[17:42:39.120]                         if (!is.null(pattern)) {
[17:42:39.120]                           computeRestarts <- base::computeRestarts
[17:42:39.120]                           grepl <- base::grepl
[17:42:39.120]                           restarts <- computeRestarts(cond)
[17:42:39.120]                           for (restart in restarts) {
[17:42:39.120]                             name <- restart$name
[17:42:39.120]                             if (is.null(name)) 
[17:42:39.120]                               next
[17:42:39.120]                             if (!grepl(pattern, name)) 
[17:42:39.120]                               next
[17:42:39.120]                             invokeRestart(restart)
[17:42:39.120]                             muffled <- TRUE
[17:42:39.120]                             break
[17:42:39.120]                           }
[17:42:39.120]                         }
[17:42:39.120]                       }
[17:42:39.120]                       invisible(muffled)
[17:42:39.120]                     }
[17:42:39.120]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.120]                   }
[17:42:39.120]                 }
[17:42:39.120]                 else {
[17:42:39.120]                   if (TRUE) {
[17:42:39.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.120]                     {
[17:42:39.120]                       inherits <- base::inherits
[17:42:39.120]                       invokeRestart <- base::invokeRestart
[17:42:39.120]                       is.null <- base::is.null
[17:42:39.120]                       muffled <- FALSE
[17:42:39.120]                       if (inherits(cond, "message")) {
[17:42:39.120]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.120]                         if (muffled) 
[17:42:39.120]                           invokeRestart("muffleMessage")
[17:42:39.120]                       }
[17:42:39.120]                       else if (inherits(cond, "warning")) {
[17:42:39.120]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.120]                         if (muffled) 
[17:42:39.120]                           invokeRestart("muffleWarning")
[17:42:39.120]                       }
[17:42:39.120]                       else if (inherits(cond, "condition")) {
[17:42:39.120]                         if (!is.null(pattern)) {
[17:42:39.120]                           computeRestarts <- base::computeRestarts
[17:42:39.120]                           grepl <- base::grepl
[17:42:39.120]                           restarts <- computeRestarts(cond)
[17:42:39.120]                           for (restart in restarts) {
[17:42:39.120]                             name <- restart$name
[17:42:39.120]                             if (is.null(name)) 
[17:42:39.120]                               next
[17:42:39.120]                             if (!grepl(pattern, name)) 
[17:42:39.120]                               next
[17:42:39.120]                             invokeRestart(restart)
[17:42:39.120]                             muffled <- TRUE
[17:42:39.120]                             break
[17:42:39.120]                           }
[17:42:39.120]                         }
[17:42:39.120]                       }
[17:42:39.120]                       invisible(muffled)
[17:42:39.120]                     }
[17:42:39.120]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.120]                   }
[17:42:39.120]                 }
[17:42:39.120]             }
[17:42:39.120]         }))
[17:42:39.120]     }, error = function(ex) {
[17:42:39.120]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.120]                 ...future.rng), started = ...future.startTime, 
[17:42:39.120]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.120]             version = "1.8"), class = "FutureResult")
[17:42:39.120]     }, finally = {
[17:42:39.120]         if (!identical(...future.workdir, getwd())) 
[17:42:39.120]             setwd(...future.workdir)
[17:42:39.120]         {
[17:42:39.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.120]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.120]             }
[17:42:39.120]             base::options(...future.oldOptions)
[17:42:39.120]             if (.Platform$OS.type == "windows") {
[17:42:39.120]                 old_names <- names(...future.oldEnvVars)
[17:42:39.120]                 envs <- base::Sys.getenv()
[17:42:39.120]                 names <- names(envs)
[17:42:39.120]                 common <- intersect(names, old_names)
[17:42:39.120]                 added <- setdiff(names, old_names)
[17:42:39.120]                 removed <- setdiff(old_names, names)
[17:42:39.120]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.120]                   envs[common]]
[17:42:39.120]                 NAMES <- toupper(changed)
[17:42:39.120]                 args <- list()
[17:42:39.120]                 for (kk in seq_along(NAMES)) {
[17:42:39.120]                   name <- changed[[kk]]
[17:42:39.120]                   NAME <- NAMES[[kk]]
[17:42:39.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.120]                     next
[17:42:39.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.120]                 }
[17:42:39.120]                 NAMES <- toupper(added)
[17:42:39.120]                 for (kk in seq_along(NAMES)) {
[17:42:39.120]                   name <- added[[kk]]
[17:42:39.120]                   NAME <- NAMES[[kk]]
[17:42:39.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.120]                     next
[17:42:39.120]                   args[[name]] <- ""
[17:42:39.120]                 }
[17:42:39.120]                 NAMES <- toupper(removed)
[17:42:39.120]                 for (kk in seq_along(NAMES)) {
[17:42:39.120]                   name <- removed[[kk]]
[17:42:39.120]                   NAME <- NAMES[[kk]]
[17:42:39.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.120]                     next
[17:42:39.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.120]                 }
[17:42:39.120]                 if (length(args) > 0) 
[17:42:39.120]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.120]             }
[17:42:39.120]             else {
[17:42:39.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.120]             }
[17:42:39.120]             {
[17:42:39.120]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.120]                   0L) {
[17:42:39.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.120]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.120]                   base::options(opts)
[17:42:39.120]                 }
[17:42:39.120]                 {
[17:42:39.120]                   {
[17:42:39.120]                     NULL
[17:42:39.120]                     RNGkind("Mersenne-Twister")
[17:42:39.120]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.120]                       inherits = FALSE)
[17:42:39.120]                   }
[17:42:39.120]                   options(future.plan = NULL)
[17:42:39.120]                   if (is.na(NA_character_)) 
[17:42:39.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.120]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.120]                   {
[17:42:39.120]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.120]                     if (!future$lazy) 
[17:42:39.120]                       future <- run(future)
[17:42:39.120]                     invisible(future)
[17:42:39.120]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.120]                 }
[17:42:39.120]             }
[17:42:39.120]         }
[17:42:39.120]     })
[17:42:39.120]     if (TRUE) {
[17:42:39.120]         base::sink(type = "output", split = FALSE)
[17:42:39.120]         if (TRUE) {
[17:42:39.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.120]         }
[17:42:39.120]         else {
[17:42:39.120]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.120]         }
[17:42:39.120]         base::close(...future.stdout)
[17:42:39.120]         ...future.stdout <- NULL
[17:42:39.120]     }
[17:42:39.120]     ...future.result$conditions <- ...future.conditions
[17:42:39.120]     ...future.result$finished <- base::Sys.time()
[17:42:39.120]     ...future.result
[17:42:39.120] }
[17:42:39.122] assign_globals() ...
[17:42:39.123] List of 1
[17:42:39.123]  $ x: list()
[17:42:39.123]  - attr(*, "where")=List of 1
[17:42:39.123]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.123]  - attr(*, "resolved")= logi TRUE
[17:42:39.123]  - attr(*, "total_size")= num 0
[17:42:39.123]  - attr(*, "already-done")= logi TRUE
[17:42:39.125] - copied ‘x’ to environment
[17:42:39.125] assign_globals() ... done
[17:42:39.126] plan(): Setting new future strategy stack:
[17:42:39.126] List of future strategies:
[17:42:39.126] 1. sequential:
[17:42:39.126]    - args: function (..., envir = parent.frame())
[17:42:39.126]    - tweaked: FALSE
[17:42:39.126]    - call: NULL
[17:42:39.126] plan(): nbrOfWorkers() = 1
[17:42:39.127] plan(): Setting new future strategy stack:
[17:42:39.127] List of future strategies:
[17:42:39.127] 1. sequential:
[17:42:39.127]    - args: function (..., envir = parent.frame())
[17:42:39.127]    - tweaked: FALSE
[17:42:39.127]    - call: plan(strategy)
[17:42:39.128] plan(): nbrOfWorkers() = 1
[17:42:39.128] SequentialFuture started (and completed)
[17:42:39.128] - Launch lazy future ... done
[17:42:39.128] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.129] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.129] Searching for globals...
[17:42:39.131] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.131] Searching for globals ... DONE
[17:42:39.131] Resolving globals: TRUE
[17:42:39.131] Resolving any globals that are futures ...
[17:42:39.132] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.132] Resolving any globals that are futures ... DONE
[17:42:39.132] Resolving futures part of globals (recursively) ...
[17:42:39.132] resolve() on list ...
[17:42:39.132]  recursive: 99
[17:42:39.132]  length: 1
[17:42:39.132]  elements: ‘x’
[17:42:39.133]  length: 0 (resolved future 1)
[17:42:39.133] resolve() on list ... DONE
[17:42:39.133] - globals: [1] ‘x’
[17:42:39.133] Resolving futures part of globals (recursively) ... DONE
[17:42:39.133] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.133] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.133] - globals: [1] ‘x’
[17:42:39.134] 
[17:42:39.134] getGlobalsAndPackages() ... DONE
[17:42:39.134] run() for ‘Future’ ...
[17:42:39.134] - state: ‘created’
[17:42:39.134] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.134] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.135]   - Field: ‘label’
[17:42:39.135]   - Field: ‘local’
[17:42:39.135]   - Field: ‘owner’
[17:42:39.135]   - Field: ‘envir’
[17:42:39.135]   - Field: ‘packages’
[17:42:39.135]   - Field: ‘gc’
[17:42:39.135]   - Field: ‘conditions’
[17:42:39.135]   - Field: ‘expr’
[17:42:39.135]   - Field: ‘uuid’
[17:42:39.136]   - Field: ‘seed’
[17:42:39.136]   - Field: ‘version’
[17:42:39.136]   - Field: ‘result’
[17:42:39.136]   - Field: ‘asynchronous’
[17:42:39.136]   - Field: ‘calls’
[17:42:39.136]   - Field: ‘globals’
[17:42:39.136]   - Field: ‘stdout’
[17:42:39.136]   - Field: ‘earlySignal’
[17:42:39.136]   - Field: ‘lazy’
[17:42:39.136]   - Field: ‘state’
[17:42:39.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.137] - Launch lazy future ...
[17:42:39.137] Packages needed by the future expression (n = 0): <none>
[17:42:39.137] Packages needed by future strategies (n = 0): <none>
[17:42:39.137] {
[17:42:39.137]     {
[17:42:39.137]         {
[17:42:39.137]             ...future.startTime <- base::Sys.time()
[17:42:39.137]             {
[17:42:39.137]                 {
[17:42:39.137]                   {
[17:42:39.137]                     base::local({
[17:42:39.137]                       has_future <- base::requireNamespace("future", 
[17:42:39.137]                         quietly = TRUE)
[17:42:39.137]                       if (has_future) {
[17:42:39.137]                         ns <- base::getNamespace("future")
[17:42:39.137]                         version <- ns[[".package"]][["version"]]
[17:42:39.137]                         if (is.null(version)) 
[17:42:39.137]                           version <- utils::packageVersion("future")
[17:42:39.137]                       }
[17:42:39.137]                       else {
[17:42:39.137]                         version <- NULL
[17:42:39.137]                       }
[17:42:39.137]                       if (!has_future || version < "1.8.0") {
[17:42:39.137]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.137]                           "", base::R.version$version.string), 
[17:42:39.137]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.137]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.137]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.137]                             "release", "version")], collapse = " "), 
[17:42:39.137]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.137]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.137]                           info)
[17:42:39.137]                         info <- base::paste(info, collapse = "; ")
[17:42:39.137]                         if (!has_future) {
[17:42:39.137]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.137]                             info)
[17:42:39.137]                         }
[17:42:39.137]                         else {
[17:42:39.137]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.137]                             info, version)
[17:42:39.137]                         }
[17:42:39.137]                         base::stop(msg)
[17:42:39.137]                       }
[17:42:39.137]                     })
[17:42:39.137]                   }
[17:42:39.137]                   options(future.plan = NULL)
[17:42:39.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.137]                 }
[17:42:39.137]                 ...future.workdir <- getwd()
[17:42:39.137]             }
[17:42:39.137]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.137]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.137]         }
[17:42:39.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.137]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.137]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.137]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.137]             base::names(...future.oldOptions))
[17:42:39.137]     }
[17:42:39.137]     if (FALSE) {
[17:42:39.137]     }
[17:42:39.137]     else {
[17:42:39.137]         if (TRUE) {
[17:42:39.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.137]                 open = "w")
[17:42:39.137]         }
[17:42:39.137]         else {
[17:42:39.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.137]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.137]         }
[17:42:39.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.137]             base::sink(type = "output", split = FALSE)
[17:42:39.137]             base::close(...future.stdout)
[17:42:39.137]         }, add = TRUE)
[17:42:39.137]     }
[17:42:39.137]     ...future.frame <- base::sys.nframe()
[17:42:39.137]     ...future.conditions <- base::list()
[17:42:39.137]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.137]     if (FALSE) {
[17:42:39.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.137]     }
[17:42:39.137]     ...future.result <- base::tryCatch({
[17:42:39.137]         base::withCallingHandlers({
[17:42:39.137]             ...future.value <- base::withVisible(base::local({
[17:42:39.137]                 x$a <- 1
[17:42:39.137]                 x
[17:42:39.137]             }))
[17:42:39.137]             future::FutureResult(value = ...future.value$value, 
[17:42:39.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.137]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.137]                     ...future.globalenv.names))
[17:42:39.137]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.137]         }, condition = base::local({
[17:42:39.137]             c <- base::c
[17:42:39.137]             inherits <- base::inherits
[17:42:39.137]             invokeRestart <- base::invokeRestart
[17:42:39.137]             length <- base::length
[17:42:39.137]             list <- base::list
[17:42:39.137]             seq.int <- base::seq.int
[17:42:39.137]             signalCondition <- base::signalCondition
[17:42:39.137]             sys.calls <- base::sys.calls
[17:42:39.137]             `[[` <- base::`[[`
[17:42:39.137]             `+` <- base::`+`
[17:42:39.137]             `<<-` <- base::`<<-`
[17:42:39.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.137]                   3L)]
[17:42:39.137]             }
[17:42:39.137]             function(cond) {
[17:42:39.137]                 is_error <- inherits(cond, "error")
[17:42:39.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.137]                   NULL)
[17:42:39.137]                 if (is_error) {
[17:42:39.137]                   sessionInformation <- function() {
[17:42:39.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.137]                       search = base::search(), system = base::Sys.info())
[17:42:39.137]                   }
[17:42:39.137]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.137]                     cond$call), session = sessionInformation(), 
[17:42:39.137]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.137]                   signalCondition(cond)
[17:42:39.137]                 }
[17:42:39.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.137]                 "immediateCondition"))) {
[17:42:39.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.137]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.137]                   if (TRUE && !signal) {
[17:42:39.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.137]                     {
[17:42:39.137]                       inherits <- base::inherits
[17:42:39.137]                       invokeRestart <- base::invokeRestart
[17:42:39.137]                       is.null <- base::is.null
[17:42:39.137]                       muffled <- FALSE
[17:42:39.137]                       if (inherits(cond, "message")) {
[17:42:39.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.137]                         if (muffled) 
[17:42:39.137]                           invokeRestart("muffleMessage")
[17:42:39.137]                       }
[17:42:39.137]                       else if (inherits(cond, "warning")) {
[17:42:39.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.137]                         if (muffled) 
[17:42:39.137]                           invokeRestart("muffleWarning")
[17:42:39.137]                       }
[17:42:39.137]                       else if (inherits(cond, "condition")) {
[17:42:39.137]                         if (!is.null(pattern)) {
[17:42:39.137]                           computeRestarts <- base::computeRestarts
[17:42:39.137]                           grepl <- base::grepl
[17:42:39.137]                           restarts <- computeRestarts(cond)
[17:42:39.137]                           for (restart in restarts) {
[17:42:39.137]                             name <- restart$name
[17:42:39.137]                             if (is.null(name)) 
[17:42:39.137]                               next
[17:42:39.137]                             if (!grepl(pattern, name)) 
[17:42:39.137]                               next
[17:42:39.137]                             invokeRestart(restart)
[17:42:39.137]                             muffled <- TRUE
[17:42:39.137]                             break
[17:42:39.137]                           }
[17:42:39.137]                         }
[17:42:39.137]                       }
[17:42:39.137]                       invisible(muffled)
[17:42:39.137]                     }
[17:42:39.137]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.137]                   }
[17:42:39.137]                 }
[17:42:39.137]                 else {
[17:42:39.137]                   if (TRUE) {
[17:42:39.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.137]                     {
[17:42:39.137]                       inherits <- base::inherits
[17:42:39.137]                       invokeRestart <- base::invokeRestart
[17:42:39.137]                       is.null <- base::is.null
[17:42:39.137]                       muffled <- FALSE
[17:42:39.137]                       if (inherits(cond, "message")) {
[17:42:39.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.137]                         if (muffled) 
[17:42:39.137]                           invokeRestart("muffleMessage")
[17:42:39.137]                       }
[17:42:39.137]                       else if (inherits(cond, "warning")) {
[17:42:39.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.137]                         if (muffled) 
[17:42:39.137]                           invokeRestart("muffleWarning")
[17:42:39.137]                       }
[17:42:39.137]                       else if (inherits(cond, "condition")) {
[17:42:39.137]                         if (!is.null(pattern)) {
[17:42:39.137]                           computeRestarts <- base::computeRestarts
[17:42:39.137]                           grepl <- base::grepl
[17:42:39.137]                           restarts <- computeRestarts(cond)
[17:42:39.137]                           for (restart in restarts) {
[17:42:39.137]                             name <- restart$name
[17:42:39.137]                             if (is.null(name)) 
[17:42:39.137]                               next
[17:42:39.137]                             if (!grepl(pattern, name)) 
[17:42:39.137]                               next
[17:42:39.137]                             invokeRestart(restart)
[17:42:39.137]                             muffled <- TRUE
[17:42:39.137]                             break
[17:42:39.137]                           }
[17:42:39.137]                         }
[17:42:39.137]                       }
[17:42:39.137]                       invisible(muffled)
[17:42:39.137]                     }
[17:42:39.137]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.137]                   }
[17:42:39.137]                 }
[17:42:39.137]             }
[17:42:39.137]         }))
[17:42:39.137]     }, error = function(ex) {
[17:42:39.137]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.137]                 ...future.rng), started = ...future.startTime, 
[17:42:39.137]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.137]             version = "1.8"), class = "FutureResult")
[17:42:39.137]     }, finally = {
[17:42:39.137]         if (!identical(...future.workdir, getwd())) 
[17:42:39.137]             setwd(...future.workdir)
[17:42:39.137]         {
[17:42:39.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.137]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.137]             }
[17:42:39.137]             base::options(...future.oldOptions)
[17:42:39.137]             if (.Platform$OS.type == "windows") {
[17:42:39.137]                 old_names <- names(...future.oldEnvVars)
[17:42:39.137]                 envs <- base::Sys.getenv()
[17:42:39.137]                 names <- names(envs)
[17:42:39.137]                 common <- intersect(names, old_names)
[17:42:39.137]                 added <- setdiff(names, old_names)
[17:42:39.137]                 removed <- setdiff(old_names, names)
[17:42:39.137]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.137]                   envs[common]]
[17:42:39.137]                 NAMES <- toupper(changed)
[17:42:39.137]                 args <- list()
[17:42:39.137]                 for (kk in seq_along(NAMES)) {
[17:42:39.137]                   name <- changed[[kk]]
[17:42:39.137]                   NAME <- NAMES[[kk]]
[17:42:39.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.137]                     next
[17:42:39.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.137]                 }
[17:42:39.137]                 NAMES <- toupper(added)
[17:42:39.137]                 for (kk in seq_along(NAMES)) {
[17:42:39.137]                   name <- added[[kk]]
[17:42:39.137]                   NAME <- NAMES[[kk]]
[17:42:39.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.137]                     next
[17:42:39.137]                   args[[name]] <- ""
[17:42:39.137]                 }
[17:42:39.137]                 NAMES <- toupper(removed)
[17:42:39.137]                 for (kk in seq_along(NAMES)) {
[17:42:39.137]                   name <- removed[[kk]]
[17:42:39.137]                   NAME <- NAMES[[kk]]
[17:42:39.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.137]                     next
[17:42:39.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.137]                 }
[17:42:39.137]                 if (length(args) > 0) 
[17:42:39.137]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.137]             }
[17:42:39.137]             else {
[17:42:39.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.137]             }
[17:42:39.137]             {
[17:42:39.137]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.137]                   0L) {
[17:42:39.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.137]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.137]                   base::options(opts)
[17:42:39.137]                 }
[17:42:39.137]                 {
[17:42:39.137]                   {
[17:42:39.137]                     NULL
[17:42:39.137]                     RNGkind("Mersenne-Twister")
[17:42:39.137]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.137]                       inherits = FALSE)
[17:42:39.137]                   }
[17:42:39.137]                   options(future.plan = NULL)
[17:42:39.137]                   if (is.na(NA_character_)) 
[17:42:39.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.137]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.137]                   {
[17:42:39.137]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.137]                     if (!future$lazy) 
[17:42:39.137]                       future <- run(future)
[17:42:39.137]                     invisible(future)
[17:42:39.137]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.137]                 }
[17:42:39.137]             }
[17:42:39.137]         }
[17:42:39.137]     })
[17:42:39.137]     if (TRUE) {
[17:42:39.137]         base::sink(type = "output", split = FALSE)
[17:42:39.137]         if (TRUE) {
[17:42:39.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.137]         }
[17:42:39.137]         else {
[17:42:39.137]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.137]         }
[17:42:39.137]         base::close(...future.stdout)
[17:42:39.137]         ...future.stdout <- NULL
[17:42:39.137]     }
[17:42:39.137]     ...future.result$conditions <- ...future.conditions
[17:42:39.137]     ...future.result$finished <- base::Sys.time()
[17:42:39.137]     ...future.result
[17:42:39.137] }
[17:42:39.139] assign_globals() ...
[17:42:39.139] List of 1
[17:42:39.139]  $ x: list()
[17:42:39.139]  - attr(*, "where")=List of 1
[17:42:39.139]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.139]  - attr(*, "resolved")= logi TRUE
[17:42:39.139]  - attr(*, "total_size")= num 0
[17:42:39.139]  - attr(*, "already-done")= logi TRUE
[17:42:39.141] - copied ‘x’ to environment
[17:42:39.142] assign_globals() ... done
[17:42:39.142] plan(): Setting new future strategy stack:
[17:42:39.144] List of future strategies:
[17:42:39.144] 1. sequential:
[17:42:39.144]    - args: function (..., envir = parent.frame())
[17:42:39.144]    - tweaked: FALSE
[17:42:39.144]    - call: NULL
[17:42:39.144] plan(): nbrOfWorkers() = 1
[17:42:39.145] plan(): Setting new future strategy stack:
[17:42:39.145] List of future strategies:
[17:42:39.145] 1. sequential:
[17:42:39.145]    - args: function (..., envir = parent.frame())
[17:42:39.145]    - tweaked: FALSE
[17:42:39.145]    - call: plan(strategy)
[17:42:39.145] plan(): nbrOfWorkers() = 1
[17:42:39.146] SequentialFuture started (and completed)
[17:42:39.146] - Launch lazy future ... done
[17:42:39.146] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.147] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.147] Searching for globals...
[17:42:39.149] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.149] Searching for globals ... DONE
[17:42:39.150] Resolving globals: TRUE
[17:42:39.150] Resolving any globals that are futures ...
[17:42:39.150] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.150] Resolving any globals that are futures ... DONE
[17:42:39.150] Resolving futures part of globals (recursively) ...
[17:42:39.150] resolve() on list ...
[17:42:39.151]  recursive: 99
[17:42:39.151]  length: 1
[17:42:39.151]  elements: ‘x’
[17:42:39.151]  length: 0 (resolved future 1)
[17:42:39.151] resolve() on list ... DONE
[17:42:39.151] - globals: [1] ‘x’
[17:42:39.151] Resolving futures part of globals (recursively) ... DONE
[17:42:39.151] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.152] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.152] - globals: [1] ‘x’
[17:42:39.152] 
[17:42:39.152] getGlobalsAndPackages() ... DONE
[17:42:39.152] run() for ‘Future’ ...
[17:42:39.152] - state: ‘created’
[17:42:39.152] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.153] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.153] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.153]   - Field: ‘label’
[17:42:39.153]   - Field: ‘local’
[17:42:39.153]   - Field: ‘owner’
[17:42:39.153]   - Field: ‘envir’
[17:42:39.153]   - Field: ‘packages’
[17:42:39.153]   - Field: ‘gc’
[17:42:39.153]   - Field: ‘conditions’
[17:42:39.154]   - Field: ‘expr’
[17:42:39.154]   - Field: ‘uuid’
[17:42:39.154]   - Field: ‘seed’
[17:42:39.154]   - Field: ‘version’
[17:42:39.154]   - Field: ‘result’
[17:42:39.154]   - Field: ‘asynchronous’
[17:42:39.155]   - Field: ‘calls’
[17:42:39.155]   - Field: ‘globals’
[17:42:39.155]   - Field: ‘stdout’
[17:42:39.155]   - Field: ‘earlySignal’
[17:42:39.155]   - Field: ‘lazy’
[17:42:39.155]   - Field: ‘state’
[17:42:39.155] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.155] - Launch lazy future ...
[17:42:39.155] Packages needed by the future expression (n = 0): <none>
[17:42:39.156] Packages needed by future strategies (n = 0): <none>
[17:42:39.156] {
[17:42:39.156]     {
[17:42:39.156]         {
[17:42:39.156]             ...future.startTime <- base::Sys.time()
[17:42:39.156]             {
[17:42:39.156]                 {
[17:42:39.156]                   {
[17:42:39.156]                     base::local({
[17:42:39.156]                       has_future <- base::requireNamespace("future", 
[17:42:39.156]                         quietly = TRUE)
[17:42:39.156]                       if (has_future) {
[17:42:39.156]                         ns <- base::getNamespace("future")
[17:42:39.156]                         version <- ns[[".package"]][["version"]]
[17:42:39.156]                         if (is.null(version)) 
[17:42:39.156]                           version <- utils::packageVersion("future")
[17:42:39.156]                       }
[17:42:39.156]                       else {
[17:42:39.156]                         version <- NULL
[17:42:39.156]                       }
[17:42:39.156]                       if (!has_future || version < "1.8.0") {
[17:42:39.156]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.156]                           "", base::R.version$version.string), 
[17:42:39.156]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.156]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.156]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.156]                             "release", "version")], collapse = " "), 
[17:42:39.156]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.156]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.156]                           info)
[17:42:39.156]                         info <- base::paste(info, collapse = "; ")
[17:42:39.156]                         if (!has_future) {
[17:42:39.156]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.156]                             info)
[17:42:39.156]                         }
[17:42:39.156]                         else {
[17:42:39.156]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.156]                             info, version)
[17:42:39.156]                         }
[17:42:39.156]                         base::stop(msg)
[17:42:39.156]                       }
[17:42:39.156]                     })
[17:42:39.156]                   }
[17:42:39.156]                   options(future.plan = NULL)
[17:42:39.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.156]                 }
[17:42:39.156]                 ...future.workdir <- getwd()
[17:42:39.156]             }
[17:42:39.156]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.156]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.156]         }
[17:42:39.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.156]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.156]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.156]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.156]             base::names(...future.oldOptions))
[17:42:39.156]     }
[17:42:39.156]     if (FALSE) {
[17:42:39.156]     }
[17:42:39.156]     else {
[17:42:39.156]         if (TRUE) {
[17:42:39.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.156]                 open = "w")
[17:42:39.156]         }
[17:42:39.156]         else {
[17:42:39.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.156]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.156]         }
[17:42:39.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.156]             base::sink(type = "output", split = FALSE)
[17:42:39.156]             base::close(...future.stdout)
[17:42:39.156]         }, add = TRUE)
[17:42:39.156]     }
[17:42:39.156]     ...future.frame <- base::sys.nframe()
[17:42:39.156]     ...future.conditions <- base::list()
[17:42:39.156]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.156]     if (FALSE) {
[17:42:39.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.156]     }
[17:42:39.156]     ...future.result <- base::tryCatch({
[17:42:39.156]         base::withCallingHandlers({
[17:42:39.156]             ...future.value <- base::withVisible(base::local({
[17:42:39.156]                 x$a <- 1
[17:42:39.156]                 x
[17:42:39.156]             }))
[17:42:39.156]             future::FutureResult(value = ...future.value$value, 
[17:42:39.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.156]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.156]                     ...future.globalenv.names))
[17:42:39.156]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.156]         }, condition = base::local({
[17:42:39.156]             c <- base::c
[17:42:39.156]             inherits <- base::inherits
[17:42:39.156]             invokeRestart <- base::invokeRestart
[17:42:39.156]             length <- base::length
[17:42:39.156]             list <- base::list
[17:42:39.156]             seq.int <- base::seq.int
[17:42:39.156]             signalCondition <- base::signalCondition
[17:42:39.156]             sys.calls <- base::sys.calls
[17:42:39.156]             `[[` <- base::`[[`
[17:42:39.156]             `+` <- base::`+`
[17:42:39.156]             `<<-` <- base::`<<-`
[17:42:39.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.156]                   3L)]
[17:42:39.156]             }
[17:42:39.156]             function(cond) {
[17:42:39.156]                 is_error <- inherits(cond, "error")
[17:42:39.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.156]                   NULL)
[17:42:39.156]                 if (is_error) {
[17:42:39.156]                   sessionInformation <- function() {
[17:42:39.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.156]                       search = base::search(), system = base::Sys.info())
[17:42:39.156]                   }
[17:42:39.156]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.156]                     cond$call), session = sessionInformation(), 
[17:42:39.156]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.156]                   signalCondition(cond)
[17:42:39.156]                 }
[17:42:39.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.156]                 "immediateCondition"))) {
[17:42:39.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.156]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.156]                   if (TRUE && !signal) {
[17:42:39.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.156]                     {
[17:42:39.156]                       inherits <- base::inherits
[17:42:39.156]                       invokeRestart <- base::invokeRestart
[17:42:39.156]                       is.null <- base::is.null
[17:42:39.156]                       muffled <- FALSE
[17:42:39.156]                       if (inherits(cond, "message")) {
[17:42:39.156]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.156]                         if (muffled) 
[17:42:39.156]                           invokeRestart("muffleMessage")
[17:42:39.156]                       }
[17:42:39.156]                       else if (inherits(cond, "warning")) {
[17:42:39.156]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.156]                         if (muffled) 
[17:42:39.156]                           invokeRestart("muffleWarning")
[17:42:39.156]                       }
[17:42:39.156]                       else if (inherits(cond, "condition")) {
[17:42:39.156]                         if (!is.null(pattern)) {
[17:42:39.156]                           computeRestarts <- base::computeRestarts
[17:42:39.156]                           grepl <- base::grepl
[17:42:39.156]                           restarts <- computeRestarts(cond)
[17:42:39.156]                           for (restart in restarts) {
[17:42:39.156]                             name <- restart$name
[17:42:39.156]                             if (is.null(name)) 
[17:42:39.156]                               next
[17:42:39.156]                             if (!grepl(pattern, name)) 
[17:42:39.156]                               next
[17:42:39.156]                             invokeRestart(restart)
[17:42:39.156]                             muffled <- TRUE
[17:42:39.156]                             break
[17:42:39.156]                           }
[17:42:39.156]                         }
[17:42:39.156]                       }
[17:42:39.156]                       invisible(muffled)
[17:42:39.156]                     }
[17:42:39.156]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.156]                   }
[17:42:39.156]                 }
[17:42:39.156]                 else {
[17:42:39.156]                   if (TRUE) {
[17:42:39.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.156]                     {
[17:42:39.156]                       inherits <- base::inherits
[17:42:39.156]                       invokeRestart <- base::invokeRestart
[17:42:39.156]                       is.null <- base::is.null
[17:42:39.156]                       muffled <- FALSE
[17:42:39.156]                       if (inherits(cond, "message")) {
[17:42:39.156]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.156]                         if (muffled) 
[17:42:39.156]                           invokeRestart("muffleMessage")
[17:42:39.156]                       }
[17:42:39.156]                       else if (inherits(cond, "warning")) {
[17:42:39.156]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.156]                         if (muffled) 
[17:42:39.156]                           invokeRestart("muffleWarning")
[17:42:39.156]                       }
[17:42:39.156]                       else if (inherits(cond, "condition")) {
[17:42:39.156]                         if (!is.null(pattern)) {
[17:42:39.156]                           computeRestarts <- base::computeRestarts
[17:42:39.156]                           grepl <- base::grepl
[17:42:39.156]                           restarts <- computeRestarts(cond)
[17:42:39.156]                           for (restart in restarts) {
[17:42:39.156]                             name <- restart$name
[17:42:39.156]                             if (is.null(name)) 
[17:42:39.156]                               next
[17:42:39.156]                             if (!grepl(pattern, name)) 
[17:42:39.156]                               next
[17:42:39.156]                             invokeRestart(restart)
[17:42:39.156]                             muffled <- TRUE
[17:42:39.156]                             break
[17:42:39.156]                           }
[17:42:39.156]                         }
[17:42:39.156]                       }
[17:42:39.156]                       invisible(muffled)
[17:42:39.156]                     }
[17:42:39.156]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.156]                   }
[17:42:39.156]                 }
[17:42:39.156]             }
[17:42:39.156]         }))
[17:42:39.156]     }, error = function(ex) {
[17:42:39.156]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.156]                 ...future.rng), started = ...future.startTime, 
[17:42:39.156]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.156]             version = "1.8"), class = "FutureResult")
[17:42:39.156]     }, finally = {
[17:42:39.156]         if (!identical(...future.workdir, getwd())) 
[17:42:39.156]             setwd(...future.workdir)
[17:42:39.156]         {
[17:42:39.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.156]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.156]             }
[17:42:39.156]             base::options(...future.oldOptions)
[17:42:39.156]             if (.Platform$OS.type == "windows") {
[17:42:39.156]                 old_names <- names(...future.oldEnvVars)
[17:42:39.156]                 envs <- base::Sys.getenv()
[17:42:39.156]                 names <- names(envs)
[17:42:39.156]                 common <- intersect(names, old_names)
[17:42:39.156]                 added <- setdiff(names, old_names)
[17:42:39.156]                 removed <- setdiff(old_names, names)
[17:42:39.156]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.156]                   envs[common]]
[17:42:39.156]                 NAMES <- toupper(changed)
[17:42:39.156]                 args <- list()
[17:42:39.156]                 for (kk in seq_along(NAMES)) {
[17:42:39.156]                   name <- changed[[kk]]
[17:42:39.156]                   NAME <- NAMES[[kk]]
[17:42:39.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.156]                     next
[17:42:39.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.156]                 }
[17:42:39.156]                 NAMES <- toupper(added)
[17:42:39.156]                 for (kk in seq_along(NAMES)) {
[17:42:39.156]                   name <- added[[kk]]
[17:42:39.156]                   NAME <- NAMES[[kk]]
[17:42:39.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.156]                     next
[17:42:39.156]                   args[[name]] <- ""
[17:42:39.156]                 }
[17:42:39.156]                 NAMES <- toupper(removed)
[17:42:39.156]                 for (kk in seq_along(NAMES)) {
[17:42:39.156]                   name <- removed[[kk]]
[17:42:39.156]                   NAME <- NAMES[[kk]]
[17:42:39.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.156]                     next
[17:42:39.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.156]                 }
[17:42:39.156]                 if (length(args) > 0) 
[17:42:39.156]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.156]             }
[17:42:39.156]             else {
[17:42:39.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.156]             }
[17:42:39.156]             {
[17:42:39.156]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.156]                   0L) {
[17:42:39.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.156]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.156]                   base::options(opts)
[17:42:39.156]                 }
[17:42:39.156]                 {
[17:42:39.156]                   {
[17:42:39.156]                     NULL
[17:42:39.156]                     RNGkind("Mersenne-Twister")
[17:42:39.156]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.156]                       inherits = FALSE)
[17:42:39.156]                   }
[17:42:39.156]                   options(future.plan = NULL)
[17:42:39.156]                   if (is.na(NA_character_)) 
[17:42:39.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.156]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.156]                   {
[17:42:39.156]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.156]                     if (!future$lazy) 
[17:42:39.156]                       future <- run(future)
[17:42:39.156]                     invisible(future)
[17:42:39.156]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.156]                 }
[17:42:39.156]             }
[17:42:39.156]         }
[17:42:39.156]     })
[17:42:39.156]     if (TRUE) {
[17:42:39.156]         base::sink(type = "output", split = FALSE)
[17:42:39.156]         if (TRUE) {
[17:42:39.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.156]         }
[17:42:39.156]         else {
[17:42:39.156]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.156]         }
[17:42:39.156]         base::close(...future.stdout)
[17:42:39.156]         ...future.stdout <- NULL
[17:42:39.156]     }
[17:42:39.156]     ...future.result$conditions <- ...future.conditions
[17:42:39.156]     ...future.result$finished <- base::Sys.time()
[17:42:39.156]     ...future.result
[17:42:39.156] }
[17:42:39.158] assign_globals() ...
[17:42:39.158] List of 1
[17:42:39.158]  $ x: list()
[17:42:39.158]  - attr(*, "where")=List of 1
[17:42:39.158]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.158]  - attr(*, "resolved")= logi TRUE
[17:42:39.158]  - attr(*, "total_size")= num 0
[17:42:39.158]  - attr(*, "already-done")= logi TRUE
[17:42:39.160] - copied ‘x’ to environment
[17:42:39.160] assign_globals() ... done
[17:42:39.160] plan(): Setting new future strategy stack:
[17:42:39.161] List of future strategies:
[17:42:39.161] 1. sequential:
[17:42:39.161]    - args: function (..., envir = parent.frame())
[17:42:39.161]    - tweaked: FALSE
[17:42:39.161]    - call: NULL
[17:42:39.161] plan(): nbrOfWorkers() = 1
[17:42:39.162] plan(): Setting new future strategy stack:
[17:42:39.162] List of future strategies:
[17:42:39.162] 1. sequential:
[17:42:39.162]    - args: function (..., envir = parent.frame())
[17:42:39.162]    - tweaked: FALSE
[17:42:39.162]    - call: plan(strategy)
[17:42:39.162] plan(): nbrOfWorkers() = 1
[17:42:39.162] SequentialFuture started (and completed)
[17:42:39.162] - Launch lazy future ... done
[17:42:39.163] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.163] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.163] Searching for globals...
[17:42:39.165] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.165] Searching for globals ... DONE
[17:42:39.165] Resolving globals: TRUE
[17:42:39.165] Resolving any globals that are futures ...
[17:42:39.166] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.166] Resolving any globals that are futures ... DONE
[17:42:39.166] Resolving futures part of globals (recursively) ...
[17:42:39.166] resolve() on list ...
[17:42:39.166]  recursive: 99
[17:42:39.166]  length: 1
[17:42:39.167]  elements: ‘x’
[17:42:39.167]  length: 0 (resolved future 1)
[17:42:39.167] resolve() on list ... DONE
[17:42:39.167] - globals: [1] ‘x’
[17:42:39.167] Resolving futures part of globals (recursively) ... DONE
[17:42:39.167] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.167] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.168] - globals: [1] ‘x’
[17:42:39.168] 
[17:42:39.168] getGlobalsAndPackages() ... DONE
[17:42:39.168] run() for ‘Future’ ...
[17:42:39.168] - state: ‘created’
[17:42:39.168] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.169] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.169] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.169]   - Field: ‘label’
[17:42:39.169]   - Field: ‘local’
[17:42:39.169]   - Field: ‘owner’
[17:42:39.169]   - Field: ‘envir’
[17:42:39.169]   - Field: ‘packages’
[17:42:39.169]   - Field: ‘gc’
[17:42:39.169]   - Field: ‘conditions’
[17:42:39.169]   - Field: ‘expr’
[17:42:39.170]   - Field: ‘uuid’
[17:42:39.170]   - Field: ‘seed’
[17:42:39.170]   - Field: ‘version’
[17:42:39.170]   - Field: ‘result’
[17:42:39.170]   - Field: ‘asynchronous’
[17:42:39.170]   - Field: ‘calls’
[17:42:39.170]   - Field: ‘globals’
[17:42:39.170]   - Field: ‘stdout’
[17:42:39.170]   - Field: ‘earlySignal’
[17:42:39.170]   - Field: ‘lazy’
[17:42:39.170]   - Field: ‘state’
[17:42:39.171] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.171] - Launch lazy future ...
[17:42:39.173] Packages needed by the future expression (n = 0): <none>
[17:42:39.173] Packages needed by future strategies (n = 0): <none>
[17:42:39.173] {
[17:42:39.173]     {
[17:42:39.173]         {
[17:42:39.173]             ...future.startTime <- base::Sys.time()
[17:42:39.173]             {
[17:42:39.173]                 {
[17:42:39.173]                   {
[17:42:39.173]                     base::local({
[17:42:39.173]                       has_future <- base::requireNamespace("future", 
[17:42:39.173]                         quietly = TRUE)
[17:42:39.173]                       if (has_future) {
[17:42:39.173]                         ns <- base::getNamespace("future")
[17:42:39.173]                         version <- ns[[".package"]][["version"]]
[17:42:39.173]                         if (is.null(version)) 
[17:42:39.173]                           version <- utils::packageVersion("future")
[17:42:39.173]                       }
[17:42:39.173]                       else {
[17:42:39.173]                         version <- NULL
[17:42:39.173]                       }
[17:42:39.173]                       if (!has_future || version < "1.8.0") {
[17:42:39.173]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.173]                           "", base::R.version$version.string), 
[17:42:39.173]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.173]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.173]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.173]                             "release", "version")], collapse = " "), 
[17:42:39.173]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.173]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.173]                           info)
[17:42:39.173]                         info <- base::paste(info, collapse = "; ")
[17:42:39.173]                         if (!has_future) {
[17:42:39.173]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.173]                             info)
[17:42:39.173]                         }
[17:42:39.173]                         else {
[17:42:39.173]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.173]                             info, version)
[17:42:39.173]                         }
[17:42:39.173]                         base::stop(msg)
[17:42:39.173]                       }
[17:42:39.173]                     })
[17:42:39.173]                   }
[17:42:39.173]                   options(future.plan = NULL)
[17:42:39.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.173]                 }
[17:42:39.173]                 ...future.workdir <- getwd()
[17:42:39.173]             }
[17:42:39.173]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.173]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.173]         }
[17:42:39.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.173]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.173]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.173]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.173]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.173]             base::names(...future.oldOptions))
[17:42:39.173]     }
[17:42:39.173]     if (FALSE) {
[17:42:39.173]     }
[17:42:39.173]     else {
[17:42:39.173]         if (TRUE) {
[17:42:39.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.173]                 open = "w")
[17:42:39.173]         }
[17:42:39.173]         else {
[17:42:39.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.173]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.173]         }
[17:42:39.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.173]             base::sink(type = "output", split = FALSE)
[17:42:39.173]             base::close(...future.stdout)
[17:42:39.173]         }, add = TRUE)
[17:42:39.173]     }
[17:42:39.173]     ...future.frame <- base::sys.nframe()
[17:42:39.173]     ...future.conditions <- base::list()
[17:42:39.173]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.173]     if (FALSE) {
[17:42:39.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.173]     }
[17:42:39.173]     ...future.result <- base::tryCatch({
[17:42:39.173]         base::withCallingHandlers({
[17:42:39.173]             ...future.value <- base::withVisible(base::local({
[17:42:39.173]                 x$a <- 1
[17:42:39.173]                 x
[17:42:39.173]             }))
[17:42:39.173]             future::FutureResult(value = ...future.value$value, 
[17:42:39.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.173]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.173]                     ...future.globalenv.names))
[17:42:39.173]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.173]         }, condition = base::local({
[17:42:39.173]             c <- base::c
[17:42:39.173]             inherits <- base::inherits
[17:42:39.173]             invokeRestart <- base::invokeRestart
[17:42:39.173]             length <- base::length
[17:42:39.173]             list <- base::list
[17:42:39.173]             seq.int <- base::seq.int
[17:42:39.173]             signalCondition <- base::signalCondition
[17:42:39.173]             sys.calls <- base::sys.calls
[17:42:39.173]             `[[` <- base::`[[`
[17:42:39.173]             `+` <- base::`+`
[17:42:39.173]             `<<-` <- base::`<<-`
[17:42:39.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.173]                   3L)]
[17:42:39.173]             }
[17:42:39.173]             function(cond) {
[17:42:39.173]                 is_error <- inherits(cond, "error")
[17:42:39.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.173]                   NULL)
[17:42:39.173]                 if (is_error) {
[17:42:39.173]                   sessionInformation <- function() {
[17:42:39.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.173]                       search = base::search(), system = base::Sys.info())
[17:42:39.173]                   }
[17:42:39.173]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.173]                     cond$call), session = sessionInformation(), 
[17:42:39.173]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.173]                   signalCondition(cond)
[17:42:39.173]                 }
[17:42:39.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.173]                 "immediateCondition"))) {
[17:42:39.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.173]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.173]                   if (TRUE && !signal) {
[17:42:39.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.173]                     {
[17:42:39.173]                       inherits <- base::inherits
[17:42:39.173]                       invokeRestart <- base::invokeRestart
[17:42:39.173]                       is.null <- base::is.null
[17:42:39.173]                       muffled <- FALSE
[17:42:39.173]                       if (inherits(cond, "message")) {
[17:42:39.173]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.173]                         if (muffled) 
[17:42:39.173]                           invokeRestart("muffleMessage")
[17:42:39.173]                       }
[17:42:39.173]                       else if (inherits(cond, "warning")) {
[17:42:39.173]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.173]                         if (muffled) 
[17:42:39.173]                           invokeRestart("muffleWarning")
[17:42:39.173]                       }
[17:42:39.173]                       else if (inherits(cond, "condition")) {
[17:42:39.173]                         if (!is.null(pattern)) {
[17:42:39.173]                           computeRestarts <- base::computeRestarts
[17:42:39.173]                           grepl <- base::grepl
[17:42:39.173]                           restarts <- computeRestarts(cond)
[17:42:39.173]                           for (restart in restarts) {
[17:42:39.173]                             name <- restart$name
[17:42:39.173]                             if (is.null(name)) 
[17:42:39.173]                               next
[17:42:39.173]                             if (!grepl(pattern, name)) 
[17:42:39.173]                               next
[17:42:39.173]                             invokeRestart(restart)
[17:42:39.173]                             muffled <- TRUE
[17:42:39.173]                             break
[17:42:39.173]                           }
[17:42:39.173]                         }
[17:42:39.173]                       }
[17:42:39.173]                       invisible(muffled)
[17:42:39.173]                     }
[17:42:39.173]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.173]                   }
[17:42:39.173]                 }
[17:42:39.173]                 else {
[17:42:39.173]                   if (TRUE) {
[17:42:39.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.173]                     {
[17:42:39.173]                       inherits <- base::inherits
[17:42:39.173]                       invokeRestart <- base::invokeRestart
[17:42:39.173]                       is.null <- base::is.null
[17:42:39.173]                       muffled <- FALSE
[17:42:39.173]                       if (inherits(cond, "message")) {
[17:42:39.173]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.173]                         if (muffled) 
[17:42:39.173]                           invokeRestart("muffleMessage")
[17:42:39.173]                       }
[17:42:39.173]                       else if (inherits(cond, "warning")) {
[17:42:39.173]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.173]                         if (muffled) 
[17:42:39.173]                           invokeRestart("muffleWarning")
[17:42:39.173]                       }
[17:42:39.173]                       else if (inherits(cond, "condition")) {
[17:42:39.173]                         if (!is.null(pattern)) {
[17:42:39.173]                           computeRestarts <- base::computeRestarts
[17:42:39.173]                           grepl <- base::grepl
[17:42:39.173]                           restarts <- computeRestarts(cond)
[17:42:39.173]                           for (restart in restarts) {
[17:42:39.173]                             name <- restart$name
[17:42:39.173]                             if (is.null(name)) 
[17:42:39.173]                               next
[17:42:39.173]                             if (!grepl(pattern, name)) 
[17:42:39.173]                               next
[17:42:39.173]                             invokeRestart(restart)
[17:42:39.173]                             muffled <- TRUE
[17:42:39.173]                             break
[17:42:39.173]                           }
[17:42:39.173]                         }
[17:42:39.173]                       }
[17:42:39.173]                       invisible(muffled)
[17:42:39.173]                     }
[17:42:39.173]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.173]                   }
[17:42:39.173]                 }
[17:42:39.173]             }
[17:42:39.173]         }))
[17:42:39.173]     }, error = function(ex) {
[17:42:39.173]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.173]                 ...future.rng), started = ...future.startTime, 
[17:42:39.173]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.173]             version = "1.8"), class = "FutureResult")
[17:42:39.173]     }, finally = {
[17:42:39.173]         if (!identical(...future.workdir, getwd())) 
[17:42:39.173]             setwd(...future.workdir)
[17:42:39.173]         {
[17:42:39.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.173]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.173]             }
[17:42:39.173]             base::options(...future.oldOptions)
[17:42:39.173]             if (.Platform$OS.type == "windows") {
[17:42:39.173]                 old_names <- names(...future.oldEnvVars)
[17:42:39.173]                 envs <- base::Sys.getenv()
[17:42:39.173]                 names <- names(envs)
[17:42:39.173]                 common <- intersect(names, old_names)
[17:42:39.173]                 added <- setdiff(names, old_names)
[17:42:39.173]                 removed <- setdiff(old_names, names)
[17:42:39.173]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.173]                   envs[common]]
[17:42:39.173]                 NAMES <- toupper(changed)
[17:42:39.173]                 args <- list()
[17:42:39.173]                 for (kk in seq_along(NAMES)) {
[17:42:39.173]                   name <- changed[[kk]]
[17:42:39.173]                   NAME <- NAMES[[kk]]
[17:42:39.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.173]                     next
[17:42:39.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.173]                 }
[17:42:39.173]                 NAMES <- toupper(added)
[17:42:39.173]                 for (kk in seq_along(NAMES)) {
[17:42:39.173]                   name <- added[[kk]]
[17:42:39.173]                   NAME <- NAMES[[kk]]
[17:42:39.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.173]                     next
[17:42:39.173]                   args[[name]] <- ""
[17:42:39.173]                 }
[17:42:39.173]                 NAMES <- toupper(removed)
[17:42:39.173]                 for (kk in seq_along(NAMES)) {
[17:42:39.173]                   name <- removed[[kk]]
[17:42:39.173]                   NAME <- NAMES[[kk]]
[17:42:39.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.173]                     next
[17:42:39.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.173]                 }
[17:42:39.173]                 if (length(args) > 0) 
[17:42:39.173]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.173]             }
[17:42:39.173]             else {
[17:42:39.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.173]             }
[17:42:39.173]             {
[17:42:39.173]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.173]                   0L) {
[17:42:39.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.173]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.173]                   base::options(opts)
[17:42:39.173]                 }
[17:42:39.173]                 {
[17:42:39.173]                   {
[17:42:39.173]                     NULL
[17:42:39.173]                     RNGkind("Mersenne-Twister")
[17:42:39.173]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.173]                       inherits = FALSE)
[17:42:39.173]                   }
[17:42:39.173]                   options(future.plan = NULL)
[17:42:39.173]                   if (is.na(NA_character_)) 
[17:42:39.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.173]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.173]                   {
[17:42:39.173]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.173]                     if (!future$lazy) 
[17:42:39.173]                       future <- run(future)
[17:42:39.173]                     invisible(future)
[17:42:39.173]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.173]                 }
[17:42:39.173]             }
[17:42:39.173]         }
[17:42:39.173]     })
[17:42:39.173]     if (TRUE) {
[17:42:39.173]         base::sink(type = "output", split = FALSE)
[17:42:39.173]         if (TRUE) {
[17:42:39.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.173]         }
[17:42:39.173]         else {
[17:42:39.173]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.173]         }
[17:42:39.173]         base::close(...future.stdout)
[17:42:39.173]         ...future.stdout <- NULL
[17:42:39.173]     }
[17:42:39.173]     ...future.result$conditions <- ...future.conditions
[17:42:39.173]     ...future.result$finished <- base::Sys.time()
[17:42:39.173]     ...future.result
[17:42:39.173] }
[17:42:39.175] assign_globals() ...
[17:42:39.175] List of 1
[17:42:39.175]  $ x: list()
[17:42:39.175]  - attr(*, "where")=List of 1
[17:42:39.175]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.175]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.175]  - attr(*, "resolved")= logi TRUE
[17:42:39.175]  - attr(*, "total_size")= num 0
[17:42:39.175]  - attr(*, "already-done")= logi TRUE
[17:42:39.177] - copied ‘x’ to environment
[17:42:39.177] assign_globals() ... done
[17:42:39.178] plan(): Setting new future strategy stack:
[17:42:39.178] List of future strategies:
[17:42:39.178] 1. sequential:
[17:42:39.178]    - args: function (..., envir = parent.frame())
[17:42:39.178]    - tweaked: FALSE
[17:42:39.178]    - call: NULL
[17:42:39.178] plan(): nbrOfWorkers() = 1
[17:42:39.179] plan(): Setting new future strategy stack:
[17:42:39.179] List of future strategies:
[17:42:39.179] 1. sequential:
[17:42:39.179]    - args: function (..., envir = parent.frame())
[17:42:39.179]    - tweaked: FALSE
[17:42:39.179]    - call: plan(strategy)
[17:42:39.179] plan(): nbrOfWorkers() = 1
[17:42:39.180] SequentialFuture started (and completed)
[17:42:39.180] - Launch lazy future ... done
[17:42:39.180] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.180] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.180] Searching for globals...
[17:42:39.183] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:42:39.183] Searching for globals ... DONE
[17:42:39.183] Resolving globals: TRUE
[17:42:39.183] Resolving any globals that are futures ...
[17:42:39.183] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:42:39.183] Resolving any globals that are futures ... DONE
[17:42:39.184] 
[17:42:39.184] 
[17:42:39.184] getGlobalsAndPackages() ... DONE
[17:42:39.184] run() for ‘Future’ ...
[17:42:39.184] - state: ‘created’
[17:42:39.184] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.185] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.185] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.185]   - Field: ‘label’
[17:42:39.185]   - Field: ‘local’
[17:42:39.185]   - Field: ‘owner’
[17:42:39.185]   - Field: ‘envir’
[17:42:39.185]   - Field: ‘packages’
[17:42:39.185]   - Field: ‘gc’
[17:42:39.185]   - Field: ‘conditions’
[17:42:39.186]   - Field: ‘expr’
[17:42:39.186]   - Field: ‘uuid’
[17:42:39.186]   - Field: ‘seed’
[17:42:39.186]   - Field: ‘version’
[17:42:39.186]   - Field: ‘result’
[17:42:39.186]   - Field: ‘asynchronous’
[17:42:39.186]   - Field: ‘calls’
[17:42:39.186]   - Field: ‘globals’
[17:42:39.186]   - Field: ‘stdout’
[17:42:39.186]   - Field: ‘earlySignal’
[17:42:39.186]   - Field: ‘lazy’
[17:42:39.187]   - Field: ‘state’
[17:42:39.187] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.187] - Launch lazy future ...
[17:42:39.187] Packages needed by the future expression (n = 0): <none>
[17:42:39.187] Packages needed by future strategies (n = 0): <none>
[17:42:39.187] {
[17:42:39.187]     {
[17:42:39.187]         {
[17:42:39.187]             ...future.startTime <- base::Sys.time()
[17:42:39.187]             {
[17:42:39.187]                 {
[17:42:39.187]                   {
[17:42:39.187]                     base::local({
[17:42:39.187]                       has_future <- base::requireNamespace("future", 
[17:42:39.187]                         quietly = TRUE)
[17:42:39.187]                       if (has_future) {
[17:42:39.187]                         ns <- base::getNamespace("future")
[17:42:39.187]                         version <- ns[[".package"]][["version"]]
[17:42:39.187]                         if (is.null(version)) 
[17:42:39.187]                           version <- utils::packageVersion("future")
[17:42:39.187]                       }
[17:42:39.187]                       else {
[17:42:39.187]                         version <- NULL
[17:42:39.187]                       }
[17:42:39.187]                       if (!has_future || version < "1.8.0") {
[17:42:39.187]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.187]                           "", base::R.version$version.string), 
[17:42:39.187]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.187]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.187]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.187]                             "release", "version")], collapse = " "), 
[17:42:39.187]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.187]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.187]                           info)
[17:42:39.187]                         info <- base::paste(info, collapse = "; ")
[17:42:39.187]                         if (!has_future) {
[17:42:39.187]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.187]                             info)
[17:42:39.187]                         }
[17:42:39.187]                         else {
[17:42:39.187]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.187]                             info, version)
[17:42:39.187]                         }
[17:42:39.187]                         base::stop(msg)
[17:42:39.187]                       }
[17:42:39.187]                     })
[17:42:39.187]                   }
[17:42:39.187]                   options(future.plan = NULL)
[17:42:39.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.187]                 }
[17:42:39.187]                 ...future.workdir <- getwd()
[17:42:39.187]             }
[17:42:39.187]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.187]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.187]         }
[17:42:39.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.187]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.187]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.187]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.187]             base::names(...future.oldOptions))
[17:42:39.187]     }
[17:42:39.187]     if (FALSE) {
[17:42:39.187]     }
[17:42:39.187]     else {
[17:42:39.187]         if (TRUE) {
[17:42:39.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.187]                 open = "w")
[17:42:39.187]         }
[17:42:39.187]         else {
[17:42:39.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.187]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.187]         }
[17:42:39.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.187]             base::sink(type = "output", split = FALSE)
[17:42:39.187]             base::close(...future.stdout)
[17:42:39.187]         }, add = TRUE)
[17:42:39.187]     }
[17:42:39.187]     ...future.frame <- base::sys.nframe()
[17:42:39.187]     ...future.conditions <- base::list()
[17:42:39.187]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.187]     if (FALSE) {
[17:42:39.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.187]     }
[17:42:39.187]     ...future.result <- base::tryCatch({
[17:42:39.187]         base::withCallingHandlers({
[17:42:39.187]             ...future.value <- base::withVisible(base::local({
[17:42:39.187]                 x <- list(b = 2)
[17:42:39.187]                 x$a <- 1
[17:42:39.187]                 x
[17:42:39.187]             }))
[17:42:39.187]             future::FutureResult(value = ...future.value$value, 
[17:42:39.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.187]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.187]                     ...future.globalenv.names))
[17:42:39.187]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.187]         }, condition = base::local({
[17:42:39.187]             c <- base::c
[17:42:39.187]             inherits <- base::inherits
[17:42:39.187]             invokeRestart <- base::invokeRestart
[17:42:39.187]             length <- base::length
[17:42:39.187]             list <- base::list
[17:42:39.187]             seq.int <- base::seq.int
[17:42:39.187]             signalCondition <- base::signalCondition
[17:42:39.187]             sys.calls <- base::sys.calls
[17:42:39.187]             `[[` <- base::`[[`
[17:42:39.187]             `+` <- base::`+`
[17:42:39.187]             `<<-` <- base::`<<-`
[17:42:39.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.187]                   3L)]
[17:42:39.187]             }
[17:42:39.187]             function(cond) {
[17:42:39.187]                 is_error <- inherits(cond, "error")
[17:42:39.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.187]                   NULL)
[17:42:39.187]                 if (is_error) {
[17:42:39.187]                   sessionInformation <- function() {
[17:42:39.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.187]                       search = base::search(), system = base::Sys.info())
[17:42:39.187]                   }
[17:42:39.187]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.187]                     cond$call), session = sessionInformation(), 
[17:42:39.187]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.187]                   signalCondition(cond)
[17:42:39.187]                 }
[17:42:39.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.187]                 "immediateCondition"))) {
[17:42:39.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.187]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.187]                   if (TRUE && !signal) {
[17:42:39.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.187]                     {
[17:42:39.187]                       inherits <- base::inherits
[17:42:39.187]                       invokeRestart <- base::invokeRestart
[17:42:39.187]                       is.null <- base::is.null
[17:42:39.187]                       muffled <- FALSE
[17:42:39.187]                       if (inherits(cond, "message")) {
[17:42:39.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.187]                         if (muffled) 
[17:42:39.187]                           invokeRestart("muffleMessage")
[17:42:39.187]                       }
[17:42:39.187]                       else if (inherits(cond, "warning")) {
[17:42:39.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.187]                         if (muffled) 
[17:42:39.187]                           invokeRestart("muffleWarning")
[17:42:39.187]                       }
[17:42:39.187]                       else if (inherits(cond, "condition")) {
[17:42:39.187]                         if (!is.null(pattern)) {
[17:42:39.187]                           computeRestarts <- base::computeRestarts
[17:42:39.187]                           grepl <- base::grepl
[17:42:39.187]                           restarts <- computeRestarts(cond)
[17:42:39.187]                           for (restart in restarts) {
[17:42:39.187]                             name <- restart$name
[17:42:39.187]                             if (is.null(name)) 
[17:42:39.187]                               next
[17:42:39.187]                             if (!grepl(pattern, name)) 
[17:42:39.187]                               next
[17:42:39.187]                             invokeRestart(restart)
[17:42:39.187]                             muffled <- TRUE
[17:42:39.187]                             break
[17:42:39.187]                           }
[17:42:39.187]                         }
[17:42:39.187]                       }
[17:42:39.187]                       invisible(muffled)
[17:42:39.187]                     }
[17:42:39.187]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.187]                   }
[17:42:39.187]                 }
[17:42:39.187]                 else {
[17:42:39.187]                   if (TRUE) {
[17:42:39.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.187]                     {
[17:42:39.187]                       inherits <- base::inherits
[17:42:39.187]                       invokeRestart <- base::invokeRestart
[17:42:39.187]                       is.null <- base::is.null
[17:42:39.187]                       muffled <- FALSE
[17:42:39.187]                       if (inherits(cond, "message")) {
[17:42:39.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.187]                         if (muffled) 
[17:42:39.187]                           invokeRestart("muffleMessage")
[17:42:39.187]                       }
[17:42:39.187]                       else if (inherits(cond, "warning")) {
[17:42:39.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.187]                         if (muffled) 
[17:42:39.187]                           invokeRestart("muffleWarning")
[17:42:39.187]                       }
[17:42:39.187]                       else if (inherits(cond, "condition")) {
[17:42:39.187]                         if (!is.null(pattern)) {
[17:42:39.187]                           computeRestarts <- base::computeRestarts
[17:42:39.187]                           grepl <- base::grepl
[17:42:39.187]                           restarts <- computeRestarts(cond)
[17:42:39.187]                           for (restart in restarts) {
[17:42:39.187]                             name <- restart$name
[17:42:39.187]                             if (is.null(name)) 
[17:42:39.187]                               next
[17:42:39.187]                             if (!grepl(pattern, name)) 
[17:42:39.187]                               next
[17:42:39.187]                             invokeRestart(restart)
[17:42:39.187]                             muffled <- TRUE
[17:42:39.187]                             break
[17:42:39.187]                           }
[17:42:39.187]                         }
[17:42:39.187]                       }
[17:42:39.187]                       invisible(muffled)
[17:42:39.187]                     }
[17:42:39.187]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.187]                   }
[17:42:39.187]                 }
[17:42:39.187]             }
[17:42:39.187]         }))
[17:42:39.187]     }, error = function(ex) {
[17:42:39.187]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.187]                 ...future.rng), started = ...future.startTime, 
[17:42:39.187]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.187]             version = "1.8"), class = "FutureResult")
[17:42:39.187]     }, finally = {
[17:42:39.187]         if (!identical(...future.workdir, getwd())) 
[17:42:39.187]             setwd(...future.workdir)
[17:42:39.187]         {
[17:42:39.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.187]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.187]             }
[17:42:39.187]             base::options(...future.oldOptions)
[17:42:39.187]             if (.Platform$OS.type == "windows") {
[17:42:39.187]                 old_names <- names(...future.oldEnvVars)
[17:42:39.187]                 envs <- base::Sys.getenv()
[17:42:39.187]                 names <- names(envs)
[17:42:39.187]                 common <- intersect(names, old_names)
[17:42:39.187]                 added <- setdiff(names, old_names)
[17:42:39.187]                 removed <- setdiff(old_names, names)
[17:42:39.187]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.187]                   envs[common]]
[17:42:39.187]                 NAMES <- toupper(changed)
[17:42:39.187]                 args <- list()
[17:42:39.187]                 for (kk in seq_along(NAMES)) {
[17:42:39.187]                   name <- changed[[kk]]
[17:42:39.187]                   NAME <- NAMES[[kk]]
[17:42:39.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.187]                     next
[17:42:39.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.187]                 }
[17:42:39.187]                 NAMES <- toupper(added)
[17:42:39.187]                 for (kk in seq_along(NAMES)) {
[17:42:39.187]                   name <- added[[kk]]
[17:42:39.187]                   NAME <- NAMES[[kk]]
[17:42:39.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.187]                     next
[17:42:39.187]                   args[[name]] <- ""
[17:42:39.187]                 }
[17:42:39.187]                 NAMES <- toupper(removed)
[17:42:39.187]                 for (kk in seq_along(NAMES)) {
[17:42:39.187]                   name <- removed[[kk]]
[17:42:39.187]                   NAME <- NAMES[[kk]]
[17:42:39.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.187]                     next
[17:42:39.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.187]                 }
[17:42:39.187]                 if (length(args) > 0) 
[17:42:39.187]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.187]             }
[17:42:39.187]             else {
[17:42:39.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.187]             }
[17:42:39.187]             {
[17:42:39.187]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.187]                   0L) {
[17:42:39.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.187]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.187]                   base::options(opts)
[17:42:39.187]                 }
[17:42:39.187]                 {
[17:42:39.187]                   {
[17:42:39.187]                     NULL
[17:42:39.187]                     RNGkind("Mersenne-Twister")
[17:42:39.187]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.187]                       inherits = FALSE)
[17:42:39.187]                   }
[17:42:39.187]                   options(future.plan = NULL)
[17:42:39.187]                   if (is.na(NA_character_)) 
[17:42:39.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.187]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.187]                   {
[17:42:39.187]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.187]                     if (!future$lazy) 
[17:42:39.187]                       future <- run(future)
[17:42:39.187]                     invisible(future)
[17:42:39.187]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.187]                 }
[17:42:39.187]             }
[17:42:39.187]         }
[17:42:39.187]     })
[17:42:39.187]     if (TRUE) {
[17:42:39.187]         base::sink(type = "output", split = FALSE)
[17:42:39.187]         if (TRUE) {
[17:42:39.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.187]         }
[17:42:39.187]         else {
[17:42:39.187]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.187]         }
[17:42:39.187]         base::close(...future.stdout)
[17:42:39.187]         ...future.stdout <- NULL
[17:42:39.187]     }
[17:42:39.187]     ...future.result$conditions <- ...future.conditions
[17:42:39.187]     ...future.result$finished <- base::Sys.time()
[17:42:39.187]     ...future.result
[17:42:39.187] }
[17:42:39.189] plan(): Setting new future strategy stack:
[17:42:39.189] List of future strategies:
[17:42:39.189] 1. sequential:
[17:42:39.189]    - args: function (..., envir = parent.frame())
[17:42:39.189]    - tweaked: FALSE
[17:42:39.189]    - call: NULL
[17:42:39.190] plan(): nbrOfWorkers() = 1
[17:42:39.190] plan(): Setting new future strategy stack:
[17:42:39.190] List of future strategies:
[17:42:39.190] 1. sequential:
[17:42:39.190]    - args: function (..., envir = parent.frame())
[17:42:39.190]    - tweaked: FALSE
[17:42:39.190]    - call: plan(strategy)
[17:42:39.191] plan(): nbrOfWorkers() = 1
[17:42:39.191] SequentialFuture started (and completed)
[17:42:39.191] - Launch lazy future ... done
[17:42:39.191] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.192] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.192] Searching for globals...
[17:42:39.194] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.194] Searching for globals ... DONE
[17:42:39.194] Resolving globals: TRUE
[17:42:39.194] Resolving any globals that are futures ...
[17:42:39.194] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.194] Resolving any globals that are futures ... DONE
[17:42:39.194] Resolving futures part of globals (recursively) ...
[17:42:39.195] resolve() on list ...
[17:42:39.195]  recursive: 99
[17:42:39.195]  length: 1
[17:42:39.195]  elements: ‘x’
[17:42:39.195]  length: 0 (resolved future 1)
[17:42:39.195] resolve() on list ... DONE
[17:42:39.195] - globals: [1] ‘x’
[17:42:39.195] Resolving futures part of globals (recursively) ... DONE
[17:42:39.195] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.196] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.196] - globals: [1] ‘x’
[17:42:39.196] 
[17:42:39.196] getGlobalsAndPackages() ... DONE
[17:42:39.196] run() for ‘Future’ ...
[17:42:39.196] - state: ‘created’
[17:42:39.197] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.197] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.197] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.197]   - Field: ‘label’
[17:42:39.197]   - Field: ‘local’
[17:42:39.197]   - Field: ‘owner’
[17:42:39.197]   - Field: ‘envir’
[17:42:39.197]   - Field: ‘packages’
[17:42:39.197]   - Field: ‘gc’
[17:42:39.198]   - Field: ‘conditions’
[17:42:39.198]   - Field: ‘expr’
[17:42:39.198]   - Field: ‘uuid’
[17:42:39.198]   - Field: ‘seed’
[17:42:39.198]   - Field: ‘version’
[17:42:39.198]   - Field: ‘result’
[17:42:39.198]   - Field: ‘asynchronous’
[17:42:39.198]   - Field: ‘calls’
[17:42:39.198]   - Field: ‘globals’
[17:42:39.198]   - Field: ‘stdout’
[17:42:39.198]   - Field: ‘earlySignal’
[17:42:39.199]   - Field: ‘lazy’
[17:42:39.199]   - Field: ‘state’
[17:42:39.199] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.200] - Launch lazy future ...
[17:42:39.200] Packages needed by the future expression (n = 0): <none>
[17:42:39.200] Packages needed by future strategies (n = 0): <none>
[17:42:39.201] {
[17:42:39.201]     {
[17:42:39.201]         {
[17:42:39.201]             ...future.startTime <- base::Sys.time()
[17:42:39.201]             {
[17:42:39.201]                 {
[17:42:39.201]                   {
[17:42:39.201]                     base::local({
[17:42:39.201]                       has_future <- base::requireNamespace("future", 
[17:42:39.201]                         quietly = TRUE)
[17:42:39.201]                       if (has_future) {
[17:42:39.201]                         ns <- base::getNamespace("future")
[17:42:39.201]                         version <- ns[[".package"]][["version"]]
[17:42:39.201]                         if (is.null(version)) 
[17:42:39.201]                           version <- utils::packageVersion("future")
[17:42:39.201]                       }
[17:42:39.201]                       else {
[17:42:39.201]                         version <- NULL
[17:42:39.201]                       }
[17:42:39.201]                       if (!has_future || version < "1.8.0") {
[17:42:39.201]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.201]                           "", base::R.version$version.string), 
[17:42:39.201]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.201]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.201]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.201]                             "release", "version")], collapse = " "), 
[17:42:39.201]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.201]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.201]                           info)
[17:42:39.201]                         info <- base::paste(info, collapse = "; ")
[17:42:39.201]                         if (!has_future) {
[17:42:39.201]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.201]                             info)
[17:42:39.201]                         }
[17:42:39.201]                         else {
[17:42:39.201]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.201]                             info, version)
[17:42:39.201]                         }
[17:42:39.201]                         base::stop(msg)
[17:42:39.201]                       }
[17:42:39.201]                     })
[17:42:39.201]                   }
[17:42:39.201]                   options(future.plan = NULL)
[17:42:39.201]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.201]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.201]                 }
[17:42:39.201]                 ...future.workdir <- getwd()
[17:42:39.201]             }
[17:42:39.201]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.201]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.201]         }
[17:42:39.201]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.201]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.201]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.201]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.201]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.201]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.201]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.201]             base::names(...future.oldOptions))
[17:42:39.201]     }
[17:42:39.201]     if (FALSE) {
[17:42:39.201]     }
[17:42:39.201]     else {
[17:42:39.201]         if (TRUE) {
[17:42:39.201]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.201]                 open = "w")
[17:42:39.201]         }
[17:42:39.201]         else {
[17:42:39.201]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.201]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.201]         }
[17:42:39.201]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.201]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.201]             base::sink(type = "output", split = FALSE)
[17:42:39.201]             base::close(...future.stdout)
[17:42:39.201]         }, add = TRUE)
[17:42:39.201]     }
[17:42:39.201]     ...future.frame <- base::sys.nframe()
[17:42:39.201]     ...future.conditions <- base::list()
[17:42:39.201]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.201]     if (FALSE) {
[17:42:39.201]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.201]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.201]     }
[17:42:39.201]     ...future.result <- base::tryCatch({
[17:42:39.201]         base::withCallingHandlers({
[17:42:39.201]             ...future.value <- base::withVisible(base::local({
[17:42:39.201]                 x[["a"]] <- 1
[17:42:39.201]                 x
[17:42:39.201]             }))
[17:42:39.201]             future::FutureResult(value = ...future.value$value, 
[17:42:39.201]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.201]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.201]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.201]                     ...future.globalenv.names))
[17:42:39.201]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.201]         }, condition = base::local({
[17:42:39.201]             c <- base::c
[17:42:39.201]             inherits <- base::inherits
[17:42:39.201]             invokeRestart <- base::invokeRestart
[17:42:39.201]             length <- base::length
[17:42:39.201]             list <- base::list
[17:42:39.201]             seq.int <- base::seq.int
[17:42:39.201]             signalCondition <- base::signalCondition
[17:42:39.201]             sys.calls <- base::sys.calls
[17:42:39.201]             `[[` <- base::`[[`
[17:42:39.201]             `+` <- base::`+`
[17:42:39.201]             `<<-` <- base::`<<-`
[17:42:39.201]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.201]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.201]                   3L)]
[17:42:39.201]             }
[17:42:39.201]             function(cond) {
[17:42:39.201]                 is_error <- inherits(cond, "error")
[17:42:39.201]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.201]                   NULL)
[17:42:39.201]                 if (is_error) {
[17:42:39.201]                   sessionInformation <- function() {
[17:42:39.201]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.201]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.201]                       search = base::search(), system = base::Sys.info())
[17:42:39.201]                   }
[17:42:39.201]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.201]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.201]                     cond$call), session = sessionInformation(), 
[17:42:39.201]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.201]                   signalCondition(cond)
[17:42:39.201]                 }
[17:42:39.201]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.201]                 "immediateCondition"))) {
[17:42:39.201]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.201]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.201]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.201]                   if (TRUE && !signal) {
[17:42:39.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.201]                     {
[17:42:39.201]                       inherits <- base::inherits
[17:42:39.201]                       invokeRestart <- base::invokeRestart
[17:42:39.201]                       is.null <- base::is.null
[17:42:39.201]                       muffled <- FALSE
[17:42:39.201]                       if (inherits(cond, "message")) {
[17:42:39.201]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.201]                         if (muffled) 
[17:42:39.201]                           invokeRestart("muffleMessage")
[17:42:39.201]                       }
[17:42:39.201]                       else if (inherits(cond, "warning")) {
[17:42:39.201]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.201]                         if (muffled) 
[17:42:39.201]                           invokeRestart("muffleWarning")
[17:42:39.201]                       }
[17:42:39.201]                       else if (inherits(cond, "condition")) {
[17:42:39.201]                         if (!is.null(pattern)) {
[17:42:39.201]                           computeRestarts <- base::computeRestarts
[17:42:39.201]                           grepl <- base::grepl
[17:42:39.201]                           restarts <- computeRestarts(cond)
[17:42:39.201]                           for (restart in restarts) {
[17:42:39.201]                             name <- restart$name
[17:42:39.201]                             if (is.null(name)) 
[17:42:39.201]                               next
[17:42:39.201]                             if (!grepl(pattern, name)) 
[17:42:39.201]                               next
[17:42:39.201]                             invokeRestart(restart)
[17:42:39.201]                             muffled <- TRUE
[17:42:39.201]                             break
[17:42:39.201]                           }
[17:42:39.201]                         }
[17:42:39.201]                       }
[17:42:39.201]                       invisible(muffled)
[17:42:39.201]                     }
[17:42:39.201]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.201]                   }
[17:42:39.201]                 }
[17:42:39.201]                 else {
[17:42:39.201]                   if (TRUE) {
[17:42:39.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.201]                     {
[17:42:39.201]                       inherits <- base::inherits
[17:42:39.201]                       invokeRestart <- base::invokeRestart
[17:42:39.201]                       is.null <- base::is.null
[17:42:39.201]                       muffled <- FALSE
[17:42:39.201]                       if (inherits(cond, "message")) {
[17:42:39.201]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.201]                         if (muffled) 
[17:42:39.201]                           invokeRestart("muffleMessage")
[17:42:39.201]                       }
[17:42:39.201]                       else if (inherits(cond, "warning")) {
[17:42:39.201]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.201]                         if (muffled) 
[17:42:39.201]                           invokeRestart("muffleWarning")
[17:42:39.201]                       }
[17:42:39.201]                       else if (inherits(cond, "condition")) {
[17:42:39.201]                         if (!is.null(pattern)) {
[17:42:39.201]                           computeRestarts <- base::computeRestarts
[17:42:39.201]                           grepl <- base::grepl
[17:42:39.201]                           restarts <- computeRestarts(cond)
[17:42:39.201]                           for (restart in restarts) {
[17:42:39.201]                             name <- restart$name
[17:42:39.201]                             if (is.null(name)) 
[17:42:39.201]                               next
[17:42:39.201]                             if (!grepl(pattern, name)) 
[17:42:39.201]                               next
[17:42:39.201]                             invokeRestart(restart)
[17:42:39.201]                             muffled <- TRUE
[17:42:39.201]                             break
[17:42:39.201]                           }
[17:42:39.201]                         }
[17:42:39.201]                       }
[17:42:39.201]                       invisible(muffled)
[17:42:39.201]                     }
[17:42:39.201]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.201]                   }
[17:42:39.201]                 }
[17:42:39.201]             }
[17:42:39.201]         }))
[17:42:39.201]     }, error = function(ex) {
[17:42:39.201]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.201]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.201]                 ...future.rng), started = ...future.startTime, 
[17:42:39.201]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.201]             version = "1.8"), class = "FutureResult")
[17:42:39.201]     }, finally = {
[17:42:39.201]         if (!identical(...future.workdir, getwd())) 
[17:42:39.201]             setwd(...future.workdir)
[17:42:39.201]         {
[17:42:39.201]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.201]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.201]             }
[17:42:39.201]             base::options(...future.oldOptions)
[17:42:39.201]             if (.Platform$OS.type == "windows") {
[17:42:39.201]                 old_names <- names(...future.oldEnvVars)
[17:42:39.201]                 envs <- base::Sys.getenv()
[17:42:39.201]                 names <- names(envs)
[17:42:39.201]                 common <- intersect(names, old_names)
[17:42:39.201]                 added <- setdiff(names, old_names)
[17:42:39.201]                 removed <- setdiff(old_names, names)
[17:42:39.201]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.201]                   envs[common]]
[17:42:39.201]                 NAMES <- toupper(changed)
[17:42:39.201]                 args <- list()
[17:42:39.201]                 for (kk in seq_along(NAMES)) {
[17:42:39.201]                   name <- changed[[kk]]
[17:42:39.201]                   NAME <- NAMES[[kk]]
[17:42:39.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.201]                     next
[17:42:39.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.201]                 }
[17:42:39.201]                 NAMES <- toupper(added)
[17:42:39.201]                 for (kk in seq_along(NAMES)) {
[17:42:39.201]                   name <- added[[kk]]
[17:42:39.201]                   NAME <- NAMES[[kk]]
[17:42:39.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.201]                     next
[17:42:39.201]                   args[[name]] <- ""
[17:42:39.201]                 }
[17:42:39.201]                 NAMES <- toupper(removed)
[17:42:39.201]                 for (kk in seq_along(NAMES)) {
[17:42:39.201]                   name <- removed[[kk]]
[17:42:39.201]                   NAME <- NAMES[[kk]]
[17:42:39.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.201]                     next
[17:42:39.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.201]                 }
[17:42:39.201]                 if (length(args) > 0) 
[17:42:39.201]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.201]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.201]             }
[17:42:39.201]             else {
[17:42:39.201]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.201]             }
[17:42:39.201]             {
[17:42:39.201]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.201]                   0L) {
[17:42:39.201]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.201]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.201]                   base::options(opts)
[17:42:39.201]                 }
[17:42:39.201]                 {
[17:42:39.201]                   {
[17:42:39.201]                     NULL
[17:42:39.201]                     RNGkind("Mersenne-Twister")
[17:42:39.201]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.201]                       inherits = FALSE)
[17:42:39.201]                   }
[17:42:39.201]                   options(future.plan = NULL)
[17:42:39.201]                   if (is.na(NA_character_)) 
[17:42:39.201]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.201]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.201]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.201]                   {
[17:42:39.201]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.201]                     if (!future$lazy) 
[17:42:39.201]                       future <- run(future)
[17:42:39.201]                     invisible(future)
[17:42:39.201]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.201]                 }
[17:42:39.201]             }
[17:42:39.201]         }
[17:42:39.201]     })
[17:42:39.201]     if (TRUE) {
[17:42:39.201]         base::sink(type = "output", split = FALSE)
[17:42:39.201]         if (TRUE) {
[17:42:39.201]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.201]         }
[17:42:39.201]         else {
[17:42:39.201]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.201]         }
[17:42:39.201]         base::close(...future.stdout)
[17:42:39.201]         ...future.stdout <- NULL
[17:42:39.201]     }
[17:42:39.201]     ...future.result$conditions <- ...future.conditions
[17:42:39.201]     ...future.result$finished <- base::Sys.time()
[17:42:39.201]     ...future.result
[17:42:39.201] }
[17:42:39.202] assign_globals() ...
[17:42:39.203] List of 1
[17:42:39.203]  $ x: list()
[17:42:39.203]  - attr(*, "where")=List of 1
[17:42:39.203]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.203]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.203]  - attr(*, "resolved")= logi TRUE
[17:42:39.203]  - attr(*, "total_size")= num 0
[17:42:39.203]  - attr(*, "already-done")= logi TRUE
[17:42:39.205] - copied ‘x’ to environment
[17:42:39.205] assign_globals() ... done
[17:42:39.205] plan(): Setting new future strategy stack:
[17:42:39.205] List of future strategies:
[17:42:39.205] 1. sequential:
[17:42:39.205]    - args: function (..., envir = parent.frame())
[17:42:39.205]    - tweaked: FALSE
[17:42:39.205]    - call: NULL
[17:42:39.206] plan(): nbrOfWorkers() = 1
[17:42:39.206] plan(): Setting new future strategy stack:
[17:42:39.206] List of future strategies:
[17:42:39.206] 1. sequential:
[17:42:39.206]    - args: function (..., envir = parent.frame())
[17:42:39.206]    - tweaked: FALSE
[17:42:39.206]    - call: plan(strategy)
[17:42:39.207] plan(): nbrOfWorkers() = 1
[17:42:39.207] SequentialFuture started (and completed)
[17:42:39.207] - Launch lazy future ... done
[17:42:39.207] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.207] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.208] Searching for globals...
[17:42:39.209] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.209] Searching for globals ... DONE
[17:42:39.210] Resolving globals: TRUE
[17:42:39.210] Resolving any globals that are futures ...
[17:42:39.210] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.210] Resolving any globals that are futures ... DONE
[17:42:39.210] Resolving futures part of globals (recursively) ...
[17:42:39.210] resolve() on list ...
[17:42:39.210]  recursive: 99
[17:42:39.210]  length: 1
[17:42:39.211]  elements: ‘x’
[17:42:39.211]  length: 0 (resolved future 1)
[17:42:39.211] resolve() on list ... DONE
[17:42:39.211] - globals: [1] ‘x’
[17:42:39.211] Resolving futures part of globals (recursively) ... DONE
[17:42:39.211] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.211] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.212] - globals: [1] ‘x’
[17:42:39.212] 
[17:42:39.212] getGlobalsAndPackages() ... DONE
[17:42:39.212] run() for ‘Future’ ...
[17:42:39.212] - state: ‘created’
[17:42:39.212] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.212] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.213] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.213]   - Field: ‘label’
[17:42:39.213]   - Field: ‘local’
[17:42:39.213]   - Field: ‘owner’
[17:42:39.213]   - Field: ‘envir’
[17:42:39.213]   - Field: ‘packages’
[17:42:39.213]   - Field: ‘gc’
[17:42:39.213]   - Field: ‘conditions’
[17:42:39.213]   - Field: ‘expr’
[17:42:39.214]   - Field: ‘uuid’
[17:42:39.214]   - Field: ‘seed’
[17:42:39.214]   - Field: ‘version’
[17:42:39.214]   - Field: ‘result’
[17:42:39.214]   - Field: ‘asynchronous’
[17:42:39.214]   - Field: ‘calls’
[17:42:39.214]   - Field: ‘globals’
[17:42:39.214]   - Field: ‘stdout’
[17:42:39.214]   - Field: ‘earlySignal’
[17:42:39.214]   - Field: ‘lazy’
[17:42:39.215]   - Field: ‘state’
[17:42:39.215] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.215] - Launch lazy future ...
[17:42:39.215] Packages needed by the future expression (n = 0): <none>
[17:42:39.215] Packages needed by future strategies (n = 0): <none>
[17:42:39.215] {
[17:42:39.215]     {
[17:42:39.215]         {
[17:42:39.215]             ...future.startTime <- base::Sys.time()
[17:42:39.215]             {
[17:42:39.215]                 {
[17:42:39.215]                   {
[17:42:39.215]                     base::local({
[17:42:39.215]                       has_future <- base::requireNamespace("future", 
[17:42:39.215]                         quietly = TRUE)
[17:42:39.215]                       if (has_future) {
[17:42:39.215]                         ns <- base::getNamespace("future")
[17:42:39.215]                         version <- ns[[".package"]][["version"]]
[17:42:39.215]                         if (is.null(version)) 
[17:42:39.215]                           version <- utils::packageVersion("future")
[17:42:39.215]                       }
[17:42:39.215]                       else {
[17:42:39.215]                         version <- NULL
[17:42:39.215]                       }
[17:42:39.215]                       if (!has_future || version < "1.8.0") {
[17:42:39.215]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.215]                           "", base::R.version$version.string), 
[17:42:39.215]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.215]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.215]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.215]                             "release", "version")], collapse = " "), 
[17:42:39.215]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.215]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.215]                           info)
[17:42:39.215]                         info <- base::paste(info, collapse = "; ")
[17:42:39.215]                         if (!has_future) {
[17:42:39.215]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.215]                             info)
[17:42:39.215]                         }
[17:42:39.215]                         else {
[17:42:39.215]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.215]                             info, version)
[17:42:39.215]                         }
[17:42:39.215]                         base::stop(msg)
[17:42:39.215]                       }
[17:42:39.215]                     })
[17:42:39.215]                   }
[17:42:39.215]                   options(future.plan = NULL)
[17:42:39.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.215]                 }
[17:42:39.215]                 ...future.workdir <- getwd()
[17:42:39.215]             }
[17:42:39.215]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.215]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.215]         }
[17:42:39.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.215]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.215]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.215]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.215]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.215]             base::names(...future.oldOptions))
[17:42:39.215]     }
[17:42:39.215]     if (FALSE) {
[17:42:39.215]     }
[17:42:39.215]     else {
[17:42:39.215]         if (TRUE) {
[17:42:39.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.215]                 open = "w")
[17:42:39.215]         }
[17:42:39.215]         else {
[17:42:39.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.215]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.215]         }
[17:42:39.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.215]             base::sink(type = "output", split = FALSE)
[17:42:39.215]             base::close(...future.stdout)
[17:42:39.215]         }, add = TRUE)
[17:42:39.215]     }
[17:42:39.215]     ...future.frame <- base::sys.nframe()
[17:42:39.215]     ...future.conditions <- base::list()
[17:42:39.215]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.215]     if (FALSE) {
[17:42:39.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.215]     }
[17:42:39.215]     ...future.result <- base::tryCatch({
[17:42:39.215]         base::withCallingHandlers({
[17:42:39.215]             ...future.value <- base::withVisible(base::local({
[17:42:39.215]                 x[["a"]] <- 1
[17:42:39.215]                 x
[17:42:39.215]             }))
[17:42:39.215]             future::FutureResult(value = ...future.value$value, 
[17:42:39.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.215]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.215]                     ...future.globalenv.names))
[17:42:39.215]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.215]         }, condition = base::local({
[17:42:39.215]             c <- base::c
[17:42:39.215]             inherits <- base::inherits
[17:42:39.215]             invokeRestart <- base::invokeRestart
[17:42:39.215]             length <- base::length
[17:42:39.215]             list <- base::list
[17:42:39.215]             seq.int <- base::seq.int
[17:42:39.215]             signalCondition <- base::signalCondition
[17:42:39.215]             sys.calls <- base::sys.calls
[17:42:39.215]             `[[` <- base::`[[`
[17:42:39.215]             `+` <- base::`+`
[17:42:39.215]             `<<-` <- base::`<<-`
[17:42:39.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.215]                   3L)]
[17:42:39.215]             }
[17:42:39.215]             function(cond) {
[17:42:39.215]                 is_error <- inherits(cond, "error")
[17:42:39.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.215]                   NULL)
[17:42:39.215]                 if (is_error) {
[17:42:39.215]                   sessionInformation <- function() {
[17:42:39.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.215]                       search = base::search(), system = base::Sys.info())
[17:42:39.215]                   }
[17:42:39.215]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.215]                     cond$call), session = sessionInformation(), 
[17:42:39.215]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.215]                   signalCondition(cond)
[17:42:39.215]                 }
[17:42:39.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.215]                 "immediateCondition"))) {
[17:42:39.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.215]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.215]                   if (TRUE && !signal) {
[17:42:39.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.215]                     {
[17:42:39.215]                       inherits <- base::inherits
[17:42:39.215]                       invokeRestart <- base::invokeRestart
[17:42:39.215]                       is.null <- base::is.null
[17:42:39.215]                       muffled <- FALSE
[17:42:39.215]                       if (inherits(cond, "message")) {
[17:42:39.215]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.215]                         if (muffled) 
[17:42:39.215]                           invokeRestart("muffleMessage")
[17:42:39.215]                       }
[17:42:39.215]                       else if (inherits(cond, "warning")) {
[17:42:39.215]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.215]                         if (muffled) 
[17:42:39.215]                           invokeRestart("muffleWarning")
[17:42:39.215]                       }
[17:42:39.215]                       else if (inherits(cond, "condition")) {
[17:42:39.215]                         if (!is.null(pattern)) {
[17:42:39.215]                           computeRestarts <- base::computeRestarts
[17:42:39.215]                           grepl <- base::grepl
[17:42:39.215]                           restarts <- computeRestarts(cond)
[17:42:39.215]                           for (restart in restarts) {
[17:42:39.215]                             name <- restart$name
[17:42:39.215]                             if (is.null(name)) 
[17:42:39.215]                               next
[17:42:39.215]                             if (!grepl(pattern, name)) 
[17:42:39.215]                               next
[17:42:39.215]                             invokeRestart(restart)
[17:42:39.215]                             muffled <- TRUE
[17:42:39.215]                             break
[17:42:39.215]                           }
[17:42:39.215]                         }
[17:42:39.215]                       }
[17:42:39.215]                       invisible(muffled)
[17:42:39.215]                     }
[17:42:39.215]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.215]                   }
[17:42:39.215]                 }
[17:42:39.215]                 else {
[17:42:39.215]                   if (TRUE) {
[17:42:39.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.215]                     {
[17:42:39.215]                       inherits <- base::inherits
[17:42:39.215]                       invokeRestart <- base::invokeRestart
[17:42:39.215]                       is.null <- base::is.null
[17:42:39.215]                       muffled <- FALSE
[17:42:39.215]                       if (inherits(cond, "message")) {
[17:42:39.215]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.215]                         if (muffled) 
[17:42:39.215]                           invokeRestart("muffleMessage")
[17:42:39.215]                       }
[17:42:39.215]                       else if (inherits(cond, "warning")) {
[17:42:39.215]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.215]                         if (muffled) 
[17:42:39.215]                           invokeRestart("muffleWarning")
[17:42:39.215]                       }
[17:42:39.215]                       else if (inherits(cond, "condition")) {
[17:42:39.215]                         if (!is.null(pattern)) {
[17:42:39.215]                           computeRestarts <- base::computeRestarts
[17:42:39.215]                           grepl <- base::grepl
[17:42:39.215]                           restarts <- computeRestarts(cond)
[17:42:39.215]                           for (restart in restarts) {
[17:42:39.215]                             name <- restart$name
[17:42:39.215]                             if (is.null(name)) 
[17:42:39.215]                               next
[17:42:39.215]                             if (!grepl(pattern, name)) 
[17:42:39.215]                               next
[17:42:39.215]                             invokeRestart(restart)
[17:42:39.215]                             muffled <- TRUE
[17:42:39.215]                             break
[17:42:39.215]                           }
[17:42:39.215]                         }
[17:42:39.215]                       }
[17:42:39.215]                       invisible(muffled)
[17:42:39.215]                     }
[17:42:39.215]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.215]                   }
[17:42:39.215]                 }
[17:42:39.215]             }
[17:42:39.215]         }))
[17:42:39.215]     }, error = function(ex) {
[17:42:39.215]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.215]                 ...future.rng), started = ...future.startTime, 
[17:42:39.215]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.215]             version = "1.8"), class = "FutureResult")
[17:42:39.215]     }, finally = {
[17:42:39.215]         if (!identical(...future.workdir, getwd())) 
[17:42:39.215]             setwd(...future.workdir)
[17:42:39.215]         {
[17:42:39.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.215]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.215]             }
[17:42:39.215]             base::options(...future.oldOptions)
[17:42:39.215]             if (.Platform$OS.type == "windows") {
[17:42:39.215]                 old_names <- names(...future.oldEnvVars)
[17:42:39.215]                 envs <- base::Sys.getenv()
[17:42:39.215]                 names <- names(envs)
[17:42:39.215]                 common <- intersect(names, old_names)
[17:42:39.215]                 added <- setdiff(names, old_names)
[17:42:39.215]                 removed <- setdiff(old_names, names)
[17:42:39.215]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.215]                   envs[common]]
[17:42:39.215]                 NAMES <- toupper(changed)
[17:42:39.215]                 args <- list()
[17:42:39.215]                 for (kk in seq_along(NAMES)) {
[17:42:39.215]                   name <- changed[[kk]]
[17:42:39.215]                   NAME <- NAMES[[kk]]
[17:42:39.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.215]                     next
[17:42:39.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.215]                 }
[17:42:39.215]                 NAMES <- toupper(added)
[17:42:39.215]                 for (kk in seq_along(NAMES)) {
[17:42:39.215]                   name <- added[[kk]]
[17:42:39.215]                   NAME <- NAMES[[kk]]
[17:42:39.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.215]                     next
[17:42:39.215]                   args[[name]] <- ""
[17:42:39.215]                 }
[17:42:39.215]                 NAMES <- toupper(removed)
[17:42:39.215]                 for (kk in seq_along(NAMES)) {
[17:42:39.215]                   name <- removed[[kk]]
[17:42:39.215]                   NAME <- NAMES[[kk]]
[17:42:39.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.215]                     next
[17:42:39.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.215]                 }
[17:42:39.215]                 if (length(args) > 0) 
[17:42:39.215]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.215]             }
[17:42:39.215]             else {
[17:42:39.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.215]             }
[17:42:39.215]             {
[17:42:39.215]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.215]                   0L) {
[17:42:39.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.215]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.215]                   base::options(opts)
[17:42:39.215]                 }
[17:42:39.215]                 {
[17:42:39.215]                   {
[17:42:39.215]                     NULL
[17:42:39.215]                     RNGkind("Mersenne-Twister")
[17:42:39.215]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.215]                       inherits = FALSE)
[17:42:39.215]                   }
[17:42:39.215]                   options(future.plan = NULL)
[17:42:39.215]                   if (is.na(NA_character_)) 
[17:42:39.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.215]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.215]                   {
[17:42:39.215]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.215]                     if (!future$lazy) 
[17:42:39.215]                       future <- run(future)
[17:42:39.215]                     invisible(future)
[17:42:39.215]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.215]                 }
[17:42:39.215]             }
[17:42:39.215]         }
[17:42:39.215]     })
[17:42:39.215]     if (TRUE) {
[17:42:39.215]         base::sink(type = "output", split = FALSE)
[17:42:39.215]         if (TRUE) {
[17:42:39.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.215]         }
[17:42:39.215]         else {
[17:42:39.215]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.215]         }
[17:42:39.215]         base::close(...future.stdout)
[17:42:39.215]         ...future.stdout <- NULL
[17:42:39.215]     }
[17:42:39.215]     ...future.result$conditions <- ...future.conditions
[17:42:39.215]     ...future.result$finished <- base::Sys.time()
[17:42:39.215]     ...future.result
[17:42:39.215] }
[17:42:39.217] assign_globals() ...
[17:42:39.217] List of 1
[17:42:39.217]  $ x: list()
[17:42:39.217]  - attr(*, "where")=List of 1
[17:42:39.217]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.217]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.217]  - attr(*, "resolved")= logi TRUE
[17:42:39.217]  - attr(*, "total_size")= num 0
[17:42:39.217]  - attr(*, "already-done")= logi TRUE
[17:42:39.219] - copied ‘x’ to environment
[17:42:39.220] assign_globals() ... done
[17:42:39.220] plan(): Setting new future strategy stack:
[17:42:39.220] List of future strategies:
[17:42:39.220] 1. sequential:
[17:42:39.220]    - args: function (..., envir = parent.frame())
[17:42:39.220]    - tweaked: FALSE
[17:42:39.220]    - call: NULL
[17:42:39.220] plan(): nbrOfWorkers() = 1
[17:42:39.221] plan(): Setting new future strategy stack:
[17:42:39.221] List of future strategies:
[17:42:39.221] 1. sequential:
[17:42:39.221]    - args: function (..., envir = parent.frame())
[17:42:39.221]    - tweaked: FALSE
[17:42:39.221]    - call: plan(strategy)
[17:42:39.221] plan(): nbrOfWorkers() = 1
[17:42:39.222] SequentialFuture started (and completed)
[17:42:39.222] - Launch lazy future ... done
[17:42:39.222] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.222] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.222] Searching for globals...
[17:42:39.224] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.224] Searching for globals ... DONE
[17:42:39.224] Resolving globals: TRUE
[17:42:39.225] Resolving any globals that are futures ...
[17:42:39.225] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.225] Resolving any globals that are futures ... DONE
[17:42:39.225] Resolving futures part of globals (recursively) ...
[17:42:39.225] resolve() on list ...
[17:42:39.225]  recursive: 99
[17:42:39.226]  length: 1
[17:42:39.226]  elements: ‘x’
[17:42:39.226]  length: 0 (resolved future 1)
[17:42:39.226] resolve() on list ... DONE
[17:42:39.226] - globals: [1] ‘x’
[17:42:39.227] Resolving futures part of globals (recursively) ... DONE
[17:42:39.228] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.228] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.228] - globals: [1] ‘x’
[17:42:39.228] 
[17:42:39.228] getGlobalsAndPackages() ... DONE
[17:42:39.228] run() for ‘Future’ ...
[17:42:39.229] - state: ‘created’
[17:42:39.229] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.229] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.229]   - Field: ‘label’
[17:42:39.229]   - Field: ‘local’
[17:42:39.229]   - Field: ‘owner’
[17:42:39.230]   - Field: ‘envir’
[17:42:39.230]   - Field: ‘packages’
[17:42:39.230]   - Field: ‘gc’
[17:42:39.230]   - Field: ‘conditions’
[17:42:39.230]   - Field: ‘expr’
[17:42:39.230]   - Field: ‘uuid’
[17:42:39.230]   - Field: ‘seed’
[17:42:39.230]   - Field: ‘version’
[17:42:39.230]   - Field: ‘result’
[17:42:39.230]   - Field: ‘asynchronous’
[17:42:39.230]   - Field: ‘calls’
[17:42:39.231]   - Field: ‘globals’
[17:42:39.231]   - Field: ‘stdout’
[17:42:39.231]   - Field: ‘earlySignal’
[17:42:39.231]   - Field: ‘lazy’
[17:42:39.231]   - Field: ‘state’
[17:42:39.231] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.231] - Launch lazy future ...
[17:42:39.231] Packages needed by the future expression (n = 0): <none>
[17:42:39.231] Packages needed by future strategies (n = 0): <none>
[17:42:39.232] {
[17:42:39.232]     {
[17:42:39.232]         {
[17:42:39.232]             ...future.startTime <- base::Sys.time()
[17:42:39.232]             {
[17:42:39.232]                 {
[17:42:39.232]                   {
[17:42:39.232]                     base::local({
[17:42:39.232]                       has_future <- base::requireNamespace("future", 
[17:42:39.232]                         quietly = TRUE)
[17:42:39.232]                       if (has_future) {
[17:42:39.232]                         ns <- base::getNamespace("future")
[17:42:39.232]                         version <- ns[[".package"]][["version"]]
[17:42:39.232]                         if (is.null(version)) 
[17:42:39.232]                           version <- utils::packageVersion("future")
[17:42:39.232]                       }
[17:42:39.232]                       else {
[17:42:39.232]                         version <- NULL
[17:42:39.232]                       }
[17:42:39.232]                       if (!has_future || version < "1.8.0") {
[17:42:39.232]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.232]                           "", base::R.version$version.string), 
[17:42:39.232]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.232]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.232]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.232]                             "release", "version")], collapse = " "), 
[17:42:39.232]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.232]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.232]                           info)
[17:42:39.232]                         info <- base::paste(info, collapse = "; ")
[17:42:39.232]                         if (!has_future) {
[17:42:39.232]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.232]                             info)
[17:42:39.232]                         }
[17:42:39.232]                         else {
[17:42:39.232]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.232]                             info, version)
[17:42:39.232]                         }
[17:42:39.232]                         base::stop(msg)
[17:42:39.232]                       }
[17:42:39.232]                     })
[17:42:39.232]                   }
[17:42:39.232]                   options(future.plan = NULL)
[17:42:39.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.232]                 }
[17:42:39.232]                 ...future.workdir <- getwd()
[17:42:39.232]             }
[17:42:39.232]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.232]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.232]         }
[17:42:39.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.232]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.232]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.232]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.232]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.232]             base::names(...future.oldOptions))
[17:42:39.232]     }
[17:42:39.232]     if (FALSE) {
[17:42:39.232]     }
[17:42:39.232]     else {
[17:42:39.232]         if (TRUE) {
[17:42:39.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.232]                 open = "w")
[17:42:39.232]         }
[17:42:39.232]         else {
[17:42:39.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.232]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.232]         }
[17:42:39.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.232]             base::sink(type = "output", split = FALSE)
[17:42:39.232]             base::close(...future.stdout)
[17:42:39.232]         }, add = TRUE)
[17:42:39.232]     }
[17:42:39.232]     ...future.frame <- base::sys.nframe()
[17:42:39.232]     ...future.conditions <- base::list()
[17:42:39.232]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.232]     if (FALSE) {
[17:42:39.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.232]     }
[17:42:39.232]     ...future.result <- base::tryCatch({
[17:42:39.232]         base::withCallingHandlers({
[17:42:39.232]             ...future.value <- base::withVisible(base::local({
[17:42:39.232]                 x[["a"]] <- 1
[17:42:39.232]                 x
[17:42:39.232]             }))
[17:42:39.232]             future::FutureResult(value = ...future.value$value, 
[17:42:39.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.232]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.232]                     ...future.globalenv.names))
[17:42:39.232]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.232]         }, condition = base::local({
[17:42:39.232]             c <- base::c
[17:42:39.232]             inherits <- base::inherits
[17:42:39.232]             invokeRestart <- base::invokeRestart
[17:42:39.232]             length <- base::length
[17:42:39.232]             list <- base::list
[17:42:39.232]             seq.int <- base::seq.int
[17:42:39.232]             signalCondition <- base::signalCondition
[17:42:39.232]             sys.calls <- base::sys.calls
[17:42:39.232]             `[[` <- base::`[[`
[17:42:39.232]             `+` <- base::`+`
[17:42:39.232]             `<<-` <- base::`<<-`
[17:42:39.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.232]                   3L)]
[17:42:39.232]             }
[17:42:39.232]             function(cond) {
[17:42:39.232]                 is_error <- inherits(cond, "error")
[17:42:39.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.232]                   NULL)
[17:42:39.232]                 if (is_error) {
[17:42:39.232]                   sessionInformation <- function() {
[17:42:39.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.232]                       search = base::search(), system = base::Sys.info())
[17:42:39.232]                   }
[17:42:39.232]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.232]                     cond$call), session = sessionInformation(), 
[17:42:39.232]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.232]                   signalCondition(cond)
[17:42:39.232]                 }
[17:42:39.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.232]                 "immediateCondition"))) {
[17:42:39.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.232]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.232]                   if (TRUE && !signal) {
[17:42:39.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.232]                     {
[17:42:39.232]                       inherits <- base::inherits
[17:42:39.232]                       invokeRestart <- base::invokeRestart
[17:42:39.232]                       is.null <- base::is.null
[17:42:39.232]                       muffled <- FALSE
[17:42:39.232]                       if (inherits(cond, "message")) {
[17:42:39.232]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.232]                         if (muffled) 
[17:42:39.232]                           invokeRestart("muffleMessage")
[17:42:39.232]                       }
[17:42:39.232]                       else if (inherits(cond, "warning")) {
[17:42:39.232]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.232]                         if (muffled) 
[17:42:39.232]                           invokeRestart("muffleWarning")
[17:42:39.232]                       }
[17:42:39.232]                       else if (inherits(cond, "condition")) {
[17:42:39.232]                         if (!is.null(pattern)) {
[17:42:39.232]                           computeRestarts <- base::computeRestarts
[17:42:39.232]                           grepl <- base::grepl
[17:42:39.232]                           restarts <- computeRestarts(cond)
[17:42:39.232]                           for (restart in restarts) {
[17:42:39.232]                             name <- restart$name
[17:42:39.232]                             if (is.null(name)) 
[17:42:39.232]                               next
[17:42:39.232]                             if (!grepl(pattern, name)) 
[17:42:39.232]                               next
[17:42:39.232]                             invokeRestart(restart)
[17:42:39.232]                             muffled <- TRUE
[17:42:39.232]                             break
[17:42:39.232]                           }
[17:42:39.232]                         }
[17:42:39.232]                       }
[17:42:39.232]                       invisible(muffled)
[17:42:39.232]                     }
[17:42:39.232]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.232]                   }
[17:42:39.232]                 }
[17:42:39.232]                 else {
[17:42:39.232]                   if (TRUE) {
[17:42:39.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.232]                     {
[17:42:39.232]                       inherits <- base::inherits
[17:42:39.232]                       invokeRestart <- base::invokeRestart
[17:42:39.232]                       is.null <- base::is.null
[17:42:39.232]                       muffled <- FALSE
[17:42:39.232]                       if (inherits(cond, "message")) {
[17:42:39.232]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.232]                         if (muffled) 
[17:42:39.232]                           invokeRestart("muffleMessage")
[17:42:39.232]                       }
[17:42:39.232]                       else if (inherits(cond, "warning")) {
[17:42:39.232]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.232]                         if (muffled) 
[17:42:39.232]                           invokeRestart("muffleWarning")
[17:42:39.232]                       }
[17:42:39.232]                       else if (inherits(cond, "condition")) {
[17:42:39.232]                         if (!is.null(pattern)) {
[17:42:39.232]                           computeRestarts <- base::computeRestarts
[17:42:39.232]                           grepl <- base::grepl
[17:42:39.232]                           restarts <- computeRestarts(cond)
[17:42:39.232]                           for (restart in restarts) {
[17:42:39.232]                             name <- restart$name
[17:42:39.232]                             if (is.null(name)) 
[17:42:39.232]                               next
[17:42:39.232]                             if (!grepl(pattern, name)) 
[17:42:39.232]                               next
[17:42:39.232]                             invokeRestart(restart)
[17:42:39.232]                             muffled <- TRUE
[17:42:39.232]                             break
[17:42:39.232]                           }
[17:42:39.232]                         }
[17:42:39.232]                       }
[17:42:39.232]                       invisible(muffled)
[17:42:39.232]                     }
[17:42:39.232]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.232]                   }
[17:42:39.232]                 }
[17:42:39.232]             }
[17:42:39.232]         }))
[17:42:39.232]     }, error = function(ex) {
[17:42:39.232]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.232]                 ...future.rng), started = ...future.startTime, 
[17:42:39.232]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.232]             version = "1.8"), class = "FutureResult")
[17:42:39.232]     }, finally = {
[17:42:39.232]         if (!identical(...future.workdir, getwd())) 
[17:42:39.232]             setwd(...future.workdir)
[17:42:39.232]         {
[17:42:39.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.232]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.232]             }
[17:42:39.232]             base::options(...future.oldOptions)
[17:42:39.232]             if (.Platform$OS.type == "windows") {
[17:42:39.232]                 old_names <- names(...future.oldEnvVars)
[17:42:39.232]                 envs <- base::Sys.getenv()
[17:42:39.232]                 names <- names(envs)
[17:42:39.232]                 common <- intersect(names, old_names)
[17:42:39.232]                 added <- setdiff(names, old_names)
[17:42:39.232]                 removed <- setdiff(old_names, names)
[17:42:39.232]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.232]                   envs[common]]
[17:42:39.232]                 NAMES <- toupper(changed)
[17:42:39.232]                 args <- list()
[17:42:39.232]                 for (kk in seq_along(NAMES)) {
[17:42:39.232]                   name <- changed[[kk]]
[17:42:39.232]                   NAME <- NAMES[[kk]]
[17:42:39.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.232]                     next
[17:42:39.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.232]                 }
[17:42:39.232]                 NAMES <- toupper(added)
[17:42:39.232]                 for (kk in seq_along(NAMES)) {
[17:42:39.232]                   name <- added[[kk]]
[17:42:39.232]                   NAME <- NAMES[[kk]]
[17:42:39.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.232]                     next
[17:42:39.232]                   args[[name]] <- ""
[17:42:39.232]                 }
[17:42:39.232]                 NAMES <- toupper(removed)
[17:42:39.232]                 for (kk in seq_along(NAMES)) {
[17:42:39.232]                   name <- removed[[kk]]
[17:42:39.232]                   NAME <- NAMES[[kk]]
[17:42:39.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.232]                     next
[17:42:39.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.232]                 }
[17:42:39.232]                 if (length(args) > 0) 
[17:42:39.232]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.232]             }
[17:42:39.232]             else {
[17:42:39.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.232]             }
[17:42:39.232]             {
[17:42:39.232]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.232]                   0L) {
[17:42:39.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.232]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.232]                   base::options(opts)
[17:42:39.232]                 }
[17:42:39.232]                 {
[17:42:39.232]                   {
[17:42:39.232]                     NULL
[17:42:39.232]                     RNGkind("Mersenne-Twister")
[17:42:39.232]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.232]                       inherits = FALSE)
[17:42:39.232]                   }
[17:42:39.232]                   options(future.plan = NULL)
[17:42:39.232]                   if (is.na(NA_character_)) 
[17:42:39.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.232]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.232]                   {
[17:42:39.232]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.232]                     if (!future$lazy) 
[17:42:39.232]                       future <- run(future)
[17:42:39.232]                     invisible(future)
[17:42:39.232]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.232]                 }
[17:42:39.232]             }
[17:42:39.232]         }
[17:42:39.232]     })
[17:42:39.232]     if (TRUE) {
[17:42:39.232]         base::sink(type = "output", split = FALSE)
[17:42:39.232]         if (TRUE) {
[17:42:39.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.232]         }
[17:42:39.232]         else {
[17:42:39.232]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.232]         }
[17:42:39.232]         base::close(...future.stdout)
[17:42:39.232]         ...future.stdout <- NULL
[17:42:39.232]     }
[17:42:39.232]     ...future.result$conditions <- ...future.conditions
[17:42:39.232]     ...future.result$finished <- base::Sys.time()
[17:42:39.232]     ...future.result
[17:42:39.232] }
[17:42:39.233] assign_globals() ...
[17:42:39.233] List of 1
[17:42:39.233]  $ x: list()
[17:42:39.233]  - attr(*, "where")=List of 1
[17:42:39.233]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.233]  - attr(*, "resolved")= logi TRUE
[17:42:39.233]  - attr(*, "total_size")= num 0
[17:42:39.233]  - attr(*, "already-done")= logi TRUE
[17:42:39.236] - copied ‘x’ to environment
[17:42:39.236] assign_globals() ... done
[17:42:39.236] plan(): Setting new future strategy stack:
[17:42:39.236] List of future strategies:
[17:42:39.236] 1. sequential:
[17:42:39.236]    - args: function (..., envir = parent.frame())
[17:42:39.236]    - tweaked: FALSE
[17:42:39.236]    - call: NULL
[17:42:39.237] plan(): nbrOfWorkers() = 1
[17:42:39.237] plan(): Setting new future strategy stack:
[17:42:39.237] List of future strategies:
[17:42:39.237] 1. sequential:
[17:42:39.237]    - args: function (..., envir = parent.frame())
[17:42:39.237]    - tweaked: FALSE
[17:42:39.237]    - call: plan(strategy)
[17:42:39.238] plan(): nbrOfWorkers() = 1
[17:42:39.238] SequentialFuture started (and completed)
[17:42:39.238] - Launch lazy future ... done
[17:42:39.238] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.239] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.239] Searching for globals...
[17:42:39.241] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.241] Searching for globals ... DONE
[17:42:39.241] Resolving globals: TRUE
[17:42:39.241] Resolving any globals that are futures ...
[17:42:39.241] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.241] Resolving any globals that are futures ... DONE
[17:42:39.242] Resolving futures part of globals (recursively) ...
[17:42:39.242] resolve() on list ...
[17:42:39.242]  recursive: 99
[17:42:39.242]  length: 1
[17:42:39.242]  elements: ‘x’
[17:42:39.242]  length: 0 (resolved future 1)
[17:42:39.242] resolve() on list ... DONE
[17:42:39.243] - globals: [1] ‘x’
[17:42:39.243] Resolving futures part of globals (recursively) ... DONE
[17:42:39.243] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.243] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.243] - globals: [1] ‘x’
[17:42:39.244] 
[17:42:39.244] getGlobalsAndPackages() ... DONE
[17:42:39.244] run() for ‘Future’ ...
[17:42:39.244] - state: ‘created’
[17:42:39.244] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.244] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.245]   - Field: ‘label’
[17:42:39.245]   - Field: ‘local’
[17:42:39.245]   - Field: ‘owner’
[17:42:39.245]   - Field: ‘envir’
[17:42:39.245]   - Field: ‘packages’
[17:42:39.245]   - Field: ‘gc’
[17:42:39.245]   - Field: ‘conditions’
[17:42:39.245]   - Field: ‘expr’
[17:42:39.245]   - Field: ‘uuid’
[17:42:39.245]   - Field: ‘seed’
[17:42:39.246]   - Field: ‘version’
[17:42:39.246]   - Field: ‘result’
[17:42:39.246]   - Field: ‘asynchronous’
[17:42:39.246]   - Field: ‘calls’
[17:42:39.246]   - Field: ‘globals’
[17:42:39.246]   - Field: ‘stdout’
[17:42:39.246]   - Field: ‘earlySignal’
[17:42:39.246]   - Field: ‘lazy’
[17:42:39.246]   - Field: ‘state’
[17:42:39.246] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.247] - Launch lazy future ...
[17:42:39.247] Packages needed by the future expression (n = 0): <none>
[17:42:39.247] Packages needed by future strategies (n = 0): <none>
[17:42:39.247] {
[17:42:39.247]     {
[17:42:39.247]         {
[17:42:39.247]             ...future.startTime <- base::Sys.time()
[17:42:39.247]             {
[17:42:39.247]                 {
[17:42:39.247]                   {
[17:42:39.247]                     base::local({
[17:42:39.247]                       has_future <- base::requireNamespace("future", 
[17:42:39.247]                         quietly = TRUE)
[17:42:39.247]                       if (has_future) {
[17:42:39.247]                         ns <- base::getNamespace("future")
[17:42:39.247]                         version <- ns[[".package"]][["version"]]
[17:42:39.247]                         if (is.null(version)) 
[17:42:39.247]                           version <- utils::packageVersion("future")
[17:42:39.247]                       }
[17:42:39.247]                       else {
[17:42:39.247]                         version <- NULL
[17:42:39.247]                       }
[17:42:39.247]                       if (!has_future || version < "1.8.0") {
[17:42:39.247]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.247]                           "", base::R.version$version.string), 
[17:42:39.247]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.247]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.247]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.247]                             "release", "version")], collapse = " "), 
[17:42:39.247]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.247]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.247]                           info)
[17:42:39.247]                         info <- base::paste(info, collapse = "; ")
[17:42:39.247]                         if (!has_future) {
[17:42:39.247]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.247]                             info)
[17:42:39.247]                         }
[17:42:39.247]                         else {
[17:42:39.247]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.247]                             info, version)
[17:42:39.247]                         }
[17:42:39.247]                         base::stop(msg)
[17:42:39.247]                       }
[17:42:39.247]                     })
[17:42:39.247]                   }
[17:42:39.247]                   options(future.plan = NULL)
[17:42:39.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.247]                 }
[17:42:39.247]                 ...future.workdir <- getwd()
[17:42:39.247]             }
[17:42:39.247]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.247]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.247]         }
[17:42:39.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.247]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.247]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.247]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.247]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.247]             base::names(...future.oldOptions))
[17:42:39.247]     }
[17:42:39.247]     if (FALSE) {
[17:42:39.247]     }
[17:42:39.247]     else {
[17:42:39.247]         if (TRUE) {
[17:42:39.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.247]                 open = "w")
[17:42:39.247]         }
[17:42:39.247]         else {
[17:42:39.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.247]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.247]         }
[17:42:39.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.247]             base::sink(type = "output", split = FALSE)
[17:42:39.247]             base::close(...future.stdout)
[17:42:39.247]         }, add = TRUE)
[17:42:39.247]     }
[17:42:39.247]     ...future.frame <- base::sys.nframe()
[17:42:39.247]     ...future.conditions <- base::list()
[17:42:39.247]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.247]     if (FALSE) {
[17:42:39.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.247]     }
[17:42:39.247]     ...future.result <- base::tryCatch({
[17:42:39.247]         base::withCallingHandlers({
[17:42:39.247]             ...future.value <- base::withVisible(base::local({
[17:42:39.247]                 x["a"] <- list(1)
[17:42:39.247]                 x
[17:42:39.247]             }))
[17:42:39.247]             future::FutureResult(value = ...future.value$value, 
[17:42:39.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.247]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.247]                     ...future.globalenv.names))
[17:42:39.247]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.247]         }, condition = base::local({
[17:42:39.247]             c <- base::c
[17:42:39.247]             inherits <- base::inherits
[17:42:39.247]             invokeRestart <- base::invokeRestart
[17:42:39.247]             length <- base::length
[17:42:39.247]             list <- base::list
[17:42:39.247]             seq.int <- base::seq.int
[17:42:39.247]             signalCondition <- base::signalCondition
[17:42:39.247]             sys.calls <- base::sys.calls
[17:42:39.247]             `[[` <- base::`[[`
[17:42:39.247]             `+` <- base::`+`
[17:42:39.247]             `<<-` <- base::`<<-`
[17:42:39.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.247]                   3L)]
[17:42:39.247]             }
[17:42:39.247]             function(cond) {
[17:42:39.247]                 is_error <- inherits(cond, "error")
[17:42:39.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.247]                   NULL)
[17:42:39.247]                 if (is_error) {
[17:42:39.247]                   sessionInformation <- function() {
[17:42:39.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.247]                       search = base::search(), system = base::Sys.info())
[17:42:39.247]                   }
[17:42:39.247]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.247]                     cond$call), session = sessionInformation(), 
[17:42:39.247]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.247]                   signalCondition(cond)
[17:42:39.247]                 }
[17:42:39.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.247]                 "immediateCondition"))) {
[17:42:39.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.247]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.247]                   if (TRUE && !signal) {
[17:42:39.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.247]                     {
[17:42:39.247]                       inherits <- base::inherits
[17:42:39.247]                       invokeRestart <- base::invokeRestart
[17:42:39.247]                       is.null <- base::is.null
[17:42:39.247]                       muffled <- FALSE
[17:42:39.247]                       if (inherits(cond, "message")) {
[17:42:39.247]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.247]                         if (muffled) 
[17:42:39.247]                           invokeRestart("muffleMessage")
[17:42:39.247]                       }
[17:42:39.247]                       else if (inherits(cond, "warning")) {
[17:42:39.247]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.247]                         if (muffled) 
[17:42:39.247]                           invokeRestart("muffleWarning")
[17:42:39.247]                       }
[17:42:39.247]                       else if (inherits(cond, "condition")) {
[17:42:39.247]                         if (!is.null(pattern)) {
[17:42:39.247]                           computeRestarts <- base::computeRestarts
[17:42:39.247]                           grepl <- base::grepl
[17:42:39.247]                           restarts <- computeRestarts(cond)
[17:42:39.247]                           for (restart in restarts) {
[17:42:39.247]                             name <- restart$name
[17:42:39.247]                             if (is.null(name)) 
[17:42:39.247]                               next
[17:42:39.247]                             if (!grepl(pattern, name)) 
[17:42:39.247]                               next
[17:42:39.247]                             invokeRestart(restart)
[17:42:39.247]                             muffled <- TRUE
[17:42:39.247]                             break
[17:42:39.247]                           }
[17:42:39.247]                         }
[17:42:39.247]                       }
[17:42:39.247]                       invisible(muffled)
[17:42:39.247]                     }
[17:42:39.247]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.247]                   }
[17:42:39.247]                 }
[17:42:39.247]                 else {
[17:42:39.247]                   if (TRUE) {
[17:42:39.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.247]                     {
[17:42:39.247]                       inherits <- base::inherits
[17:42:39.247]                       invokeRestart <- base::invokeRestart
[17:42:39.247]                       is.null <- base::is.null
[17:42:39.247]                       muffled <- FALSE
[17:42:39.247]                       if (inherits(cond, "message")) {
[17:42:39.247]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.247]                         if (muffled) 
[17:42:39.247]                           invokeRestart("muffleMessage")
[17:42:39.247]                       }
[17:42:39.247]                       else if (inherits(cond, "warning")) {
[17:42:39.247]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.247]                         if (muffled) 
[17:42:39.247]                           invokeRestart("muffleWarning")
[17:42:39.247]                       }
[17:42:39.247]                       else if (inherits(cond, "condition")) {
[17:42:39.247]                         if (!is.null(pattern)) {
[17:42:39.247]                           computeRestarts <- base::computeRestarts
[17:42:39.247]                           grepl <- base::grepl
[17:42:39.247]                           restarts <- computeRestarts(cond)
[17:42:39.247]                           for (restart in restarts) {
[17:42:39.247]                             name <- restart$name
[17:42:39.247]                             if (is.null(name)) 
[17:42:39.247]                               next
[17:42:39.247]                             if (!grepl(pattern, name)) 
[17:42:39.247]                               next
[17:42:39.247]                             invokeRestart(restart)
[17:42:39.247]                             muffled <- TRUE
[17:42:39.247]                             break
[17:42:39.247]                           }
[17:42:39.247]                         }
[17:42:39.247]                       }
[17:42:39.247]                       invisible(muffled)
[17:42:39.247]                     }
[17:42:39.247]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.247]                   }
[17:42:39.247]                 }
[17:42:39.247]             }
[17:42:39.247]         }))
[17:42:39.247]     }, error = function(ex) {
[17:42:39.247]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.247]                 ...future.rng), started = ...future.startTime, 
[17:42:39.247]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.247]             version = "1.8"), class = "FutureResult")
[17:42:39.247]     }, finally = {
[17:42:39.247]         if (!identical(...future.workdir, getwd())) 
[17:42:39.247]             setwd(...future.workdir)
[17:42:39.247]         {
[17:42:39.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.247]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.247]             }
[17:42:39.247]             base::options(...future.oldOptions)
[17:42:39.247]             if (.Platform$OS.type == "windows") {
[17:42:39.247]                 old_names <- names(...future.oldEnvVars)
[17:42:39.247]                 envs <- base::Sys.getenv()
[17:42:39.247]                 names <- names(envs)
[17:42:39.247]                 common <- intersect(names, old_names)
[17:42:39.247]                 added <- setdiff(names, old_names)
[17:42:39.247]                 removed <- setdiff(old_names, names)
[17:42:39.247]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.247]                   envs[common]]
[17:42:39.247]                 NAMES <- toupper(changed)
[17:42:39.247]                 args <- list()
[17:42:39.247]                 for (kk in seq_along(NAMES)) {
[17:42:39.247]                   name <- changed[[kk]]
[17:42:39.247]                   NAME <- NAMES[[kk]]
[17:42:39.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.247]                     next
[17:42:39.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.247]                 }
[17:42:39.247]                 NAMES <- toupper(added)
[17:42:39.247]                 for (kk in seq_along(NAMES)) {
[17:42:39.247]                   name <- added[[kk]]
[17:42:39.247]                   NAME <- NAMES[[kk]]
[17:42:39.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.247]                     next
[17:42:39.247]                   args[[name]] <- ""
[17:42:39.247]                 }
[17:42:39.247]                 NAMES <- toupper(removed)
[17:42:39.247]                 for (kk in seq_along(NAMES)) {
[17:42:39.247]                   name <- removed[[kk]]
[17:42:39.247]                   NAME <- NAMES[[kk]]
[17:42:39.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.247]                     next
[17:42:39.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.247]                 }
[17:42:39.247]                 if (length(args) > 0) 
[17:42:39.247]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.247]             }
[17:42:39.247]             else {
[17:42:39.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.247]             }
[17:42:39.247]             {
[17:42:39.247]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.247]                   0L) {
[17:42:39.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.247]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.247]                   base::options(opts)
[17:42:39.247]                 }
[17:42:39.247]                 {
[17:42:39.247]                   {
[17:42:39.247]                     NULL
[17:42:39.247]                     RNGkind("Mersenne-Twister")
[17:42:39.247]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.247]                       inherits = FALSE)
[17:42:39.247]                   }
[17:42:39.247]                   options(future.plan = NULL)
[17:42:39.247]                   if (is.na(NA_character_)) 
[17:42:39.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.247]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.247]                   {
[17:42:39.247]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.247]                     if (!future$lazy) 
[17:42:39.247]                       future <- run(future)
[17:42:39.247]                     invisible(future)
[17:42:39.247]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.247]                 }
[17:42:39.247]             }
[17:42:39.247]         }
[17:42:39.247]     })
[17:42:39.247]     if (TRUE) {
[17:42:39.247]         base::sink(type = "output", split = FALSE)
[17:42:39.247]         if (TRUE) {
[17:42:39.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.247]         }
[17:42:39.247]         else {
[17:42:39.247]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.247]         }
[17:42:39.247]         base::close(...future.stdout)
[17:42:39.247]         ...future.stdout <- NULL
[17:42:39.247]     }
[17:42:39.247]     ...future.result$conditions <- ...future.conditions
[17:42:39.247]     ...future.result$finished <- base::Sys.time()
[17:42:39.247]     ...future.result
[17:42:39.247] }
[17:42:39.249] assign_globals() ...
[17:42:39.249] List of 1
[17:42:39.249]  $ x: list()
[17:42:39.249]  - attr(*, "where")=List of 1
[17:42:39.249]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.249]  - attr(*, "resolved")= logi TRUE
[17:42:39.249]  - attr(*, "total_size")= num 0
[17:42:39.249]  - attr(*, "already-done")= logi TRUE
[17:42:39.252] - copied ‘x’ to environment
[17:42:39.252] assign_globals() ... done
[17:42:39.252] plan(): Setting new future strategy stack:
[17:42:39.252] List of future strategies:
[17:42:39.252] 1. sequential:
[17:42:39.252]    - args: function (..., envir = parent.frame())
[17:42:39.252]    - tweaked: FALSE
[17:42:39.252]    - call: NULL
[17:42:39.252] plan(): nbrOfWorkers() = 1
[17:42:39.253] plan(): Setting new future strategy stack:
[17:42:39.253] List of future strategies:
[17:42:39.253] 1. sequential:
[17:42:39.253]    - args: function (..., envir = parent.frame())
[17:42:39.253]    - tweaked: FALSE
[17:42:39.253]    - call: plan(strategy)
[17:42:39.254] plan(): nbrOfWorkers() = 1
[17:42:39.254] SequentialFuture started (and completed)
[17:42:39.254] - Launch lazy future ... done
[17:42:39.254] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.254] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.254] Searching for globals...
[17:42:39.258] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.258] Searching for globals ... DONE
[17:42:39.258] Resolving globals: TRUE
[17:42:39.258] Resolving any globals that are futures ...
[17:42:39.258] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.259] Resolving any globals that are futures ... DONE
[17:42:39.259] Resolving futures part of globals (recursively) ...
[17:42:39.259] resolve() on list ...
[17:42:39.259]  recursive: 99
[17:42:39.259]  length: 1
[17:42:39.259]  elements: ‘x’
[17:42:39.260]  length: 0 (resolved future 1)
[17:42:39.260] resolve() on list ... DONE
[17:42:39.260] - globals: [1] ‘x’
[17:42:39.260] Resolving futures part of globals (recursively) ... DONE
[17:42:39.260] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.260] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.260] - globals: [1] ‘x’
[17:42:39.261] 
[17:42:39.261] getGlobalsAndPackages() ... DONE
[17:42:39.261] run() for ‘Future’ ...
[17:42:39.261] - state: ‘created’
[17:42:39.261] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.261] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.262]   - Field: ‘label’
[17:42:39.262]   - Field: ‘local’
[17:42:39.262]   - Field: ‘owner’
[17:42:39.262]   - Field: ‘envir’
[17:42:39.262]   - Field: ‘packages’
[17:42:39.262]   - Field: ‘gc’
[17:42:39.262]   - Field: ‘conditions’
[17:42:39.262]   - Field: ‘expr’
[17:42:39.262]   - Field: ‘uuid’
[17:42:39.262]   - Field: ‘seed’
[17:42:39.263]   - Field: ‘version’
[17:42:39.263]   - Field: ‘result’
[17:42:39.263]   - Field: ‘asynchronous’
[17:42:39.263]   - Field: ‘calls’
[17:42:39.263]   - Field: ‘globals’
[17:42:39.263]   - Field: ‘stdout’
[17:42:39.263]   - Field: ‘earlySignal’
[17:42:39.263]   - Field: ‘lazy’
[17:42:39.263]   - Field: ‘state’
[17:42:39.263] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.263] - Launch lazy future ...
[17:42:39.264] Packages needed by the future expression (n = 0): <none>
[17:42:39.264] Packages needed by future strategies (n = 0): <none>
[17:42:39.264] {
[17:42:39.264]     {
[17:42:39.264]         {
[17:42:39.264]             ...future.startTime <- base::Sys.time()
[17:42:39.264]             {
[17:42:39.264]                 {
[17:42:39.264]                   {
[17:42:39.264]                     base::local({
[17:42:39.264]                       has_future <- base::requireNamespace("future", 
[17:42:39.264]                         quietly = TRUE)
[17:42:39.264]                       if (has_future) {
[17:42:39.264]                         ns <- base::getNamespace("future")
[17:42:39.264]                         version <- ns[[".package"]][["version"]]
[17:42:39.264]                         if (is.null(version)) 
[17:42:39.264]                           version <- utils::packageVersion("future")
[17:42:39.264]                       }
[17:42:39.264]                       else {
[17:42:39.264]                         version <- NULL
[17:42:39.264]                       }
[17:42:39.264]                       if (!has_future || version < "1.8.0") {
[17:42:39.264]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.264]                           "", base::R.version$version.string), 
[17:42:39.264]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.264]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.264]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.264]                             "release", "version")], collapse = " "), 
[17:42:39.264]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.264]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.264]                           info)
[17:42:39.264]                         info <- base::paste(info, collapse = "; ")
[17:42:39.264]                         if (!has_future) {
[17:42:39.264]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.264]                             info)
[17:42:39.264]                         }
[17:42:39.264]                         else {
[17:42:39.264]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.264]                             info, version)
[17:42:39.264]                         }
[17:42:39.264]                         base::stop(msg)
[17:42:39.264]                       }
[17:42:39.264]                     })
[17:42:39.264]                   }
[17:42:39.264]                   options(future.plan = NULL)
[17:42:39.264]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.264]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.264]                 }
[17:42:39.264]                 ...future.workdir <- getwd()
[17:42:39.264]             }
[17:42:39.264]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.264]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.264]         }
[17:42:39.264]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.264]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.264]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.264]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.264]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.264]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.264]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.264]             base::names(...future.oldOptions))
[17:42:39.264]     }
[17:42:39.264]     if (FALSE) {
[17:42:39.264]     }
[17:42:39.264]     else {
[17:42:39.264]         if (TRUE) {
[17:42:39.264]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.264]                 open = "w")
[17:42:39.264]         }
[17:42:39.264]         else {
[17:42:39.264]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.264]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.264]         }
[17:42:39.264]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.264]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.264]             base::sink(type = "output", split = FALSE)
[17:42:39.264]             base::close(...future.stdout)
[17:42:39.264]         }, add = TRUE)
[17:42:39.264]     }
[17:42:39.264]     ...future.frame <- base::sys.nframe()
[17:42:39.264]     ...future.conditions <- base::list()
[17:42:39.264]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.264]     if (FALSE) {
[17:42:39.264]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.264]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.264]     }
[17:42:39.264]     ...future.result <- base::tryCatch({
[17:42:39.264]         base::withCallingHandlers({
[17:42:39.264]             ...future.value <- base::withVisible(base::local({
[17:42:39.264]                 x["a"] <- list(1)
[17:42:39.264]                 x
[17:42:39.264]             }))
[17:42:39.264]             future::FutureResult(value = ...future.value$value, 
[17:42:39.264]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.264]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.264]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.264]                     ...future.globalenv.names))
[17:42:39.264]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.264]         }, condition = base::local({
[17:42:39.264]             c <- base::c
[17:42:39.264]             inherits <- base::inherits
[17:42:39.264]             invokeRestart <- base::invokeRestart
[17:42:39.264]             length <- base::length
[17:42:39.264]             list <- base::list
[17:42:39.264]             seq.int <- base::seq.int
[17:42:39.264]             signalCondition <- base::signalCondition
[17:42:39.264]             sys.calls <- base::sys.calls
[17:42:39.264]             `[[` <- base::`[[`
[17:42:39.264]             `+` <- base::`+`
[17:42:39.264]             `<<-` <- base::`<<-`
[17:42:39.264]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.264]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.264]                   3L)]
[17:42:39.264]             }
[17:42:39.264]             function(cond) {
[17:42:39.264]                 is_error <- inherits(cond, "error")
[17:42:39.264]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.264]                   NULL)
[17:42:39.264]                 if (is_error) {
[17:42:39.264]                   sessionInformation <- function() {
[17:42:39.264]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.264]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.264]                       search = base::search(), system = base::Sys.info())
[17:42:39.264]                   }
[17:42:39.264]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.264]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.264]                     cond$call), session = sessionInformation(), 
[17:42:39.264]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.264]                   signalCondition(cond)
[17:42:39.264]                 }
[17:42:39.264]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.264]                 "immediateCondition"))) {
[17:42:39.264]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.264]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.264]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.264]                   if (TRUE && !signal) {
[17:42:39.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.264]                     {
[17:42:39.264]                       inherits <- base::inherits
[17:42:39.264]                       invokeRestart <- base::invokeRestart
[17:42:39.264]                       is.null <- base::is.null
[17:42:39.264]                       muffled <- FALSE
[17:42:39.264]                       if (inherits(cond, "message")) {
[17:42:39.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.264]                         if (muffled) 
[17:42:39.264]                           invokeRestart("muffleMessage")
[17:42:39.264]                       }
[17:42:39.264]                       else if (inherits(cond, "warning")) {
[17:42:39.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.264]                         if (muffled) 
[17:42:39.264]                           invokeRestart("muffleWarning")
[17:42:39.264]                       }
[17:42:39.264]                       else if (inherits(cond, "condition")) {
[17:42:39.264]                         if (!is.null(pattern)) {
[17:42:39.264]                           computeRestarts <- base::computeRestarts
[17:42:39.264]                           grepl <- base::grepl
[17:42:39.264]                           restarts <- computeRestarts(cond)
[17:42:39.264]                           for (restart in restarts) {
[17:42:39.264]                             name <- restart$name
[17:42:39.264]                             if (is.null(name)) 
[17:42:39.264]                               next
[17:42:39.264]                             if (!grepl(pattern, name)) 
[17:42:39.264]                               next
[17:42:39.264]                             invokeRestart(restart)
[17:42:39.264]                             muffled <- TRUE
[17:42:39.264]                             break
[17:42:39.264]                           }
[17:42:39.264]                         }
[17:42:39.264]                       }
[17:42:39.264]                       invisible(muffled)
[17:42:39.264]                     }
[17:42:39.264]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.264]                   }
[17:42:39.264]                 }
[17:42:39.264]                 else {
[17:42:39.264]                   if (TRUE) {
[17:42:39.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.264]                     {
[17:42:39.264]                       inherits <- base::inherits
[17:42:39.264]                       invokeRestart <- base::invokeRestart
[17:42:39.264]                       is.null <- base::is.null
[17:42:39.264]                       muffled <- FALSE
[17:42:39.264]                       if (inherits(cond, "message")) {
[17:42:39.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.264]                         if (muffled) 
[17:42:39.264]                           invokeRestart("muffleMessage")
[17:42:39.264]                       }
[17:42:39.264]                       else if (inherits(cond, "warning")) {
[17:42:39.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.264]                         if (muffled) 
[17:42:39.264]                           invokeRestart("muffleWarning")
[17:42:39.264]                       }
[17:42:39.264]                       else if (inherits(cond, "condition")) {
[17:42:39.264]                         if (!is.null(pattern)) {
[17:42:39.264]                           computeRestarts <- base::computeRestarts
[17:42:39.264]                           grepl <- base::grepl
[17:42:39.264]                           restarts <- computeRestarts(cond)
[17:42:39.264]                           for (restart in restarts) {
[17:42:39.264]                             name <- restart$name
[17:42:39.264]                             if (is.null(name)) 
[17:42:39.264]                               next
[17:42:39.264]                             if (!grepl(pattern, name)) 
[17:42:39.264]                               next
[17:42:39.264]                             invokeRestart(restart)
[17:42:39.264]                             muffled <- TRUE
[17:42:39.264]                             break
[17:42:39.264]                           }
[17:42:39.264]                         }
[17:42:39.264]                       }
[17:42:39.264]                       invisible(muffled)
[17:42:39.264]                     }
[17:42:39.264]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.264]                   }
[17:42:39.264]                 }
[17:42:39.264]             }
[17:42:39.264]         }))
[17:42:39.264]     }, error = function(ex) {
[17:42:39.264]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.264]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.264]                 ...future.rng), started = ...future.startTime, 
[17:42:39.264]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.264]             version = "1.8"), class = "FutureResult")
[17:42:39.264]     }, finally = {
[17:42:39.264]         if (!identical(...future.workdir, getwd())) 
[17:42:39.264]             setwd(...future.workdir)
[17:42:39.264]         {
[17:42:39.264]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.264]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.264]             }
[17:42:39.264]             base::options(...future.oldOptions)
[17:42:39.264]             if (.Platform$OS.type == "windows") {
[17:42:39.264]                 old_names <- names(...future.oldEnvVars)
[17:42:39.264]                 envs <- base::Sys.getenv()
[17:42:39.264]                 names <- names(envs)
[17:42:39.264]                 common <- intersect(names, old_names)
[17:42:39.264]                 added <- setdiff(names, old_names)
[17:42:39.264]                 removed <- setdiff(old_names, names)
[17:42:39.264]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.264]                   envs[common]]
[17:42:39.264]                 NAMES <- toupper(changed)
[17:42:39.264]                 args <- list()
[17:42:39.264]                 for (kk in seq_along(NAMES)) {
[17:42:39.264]                   name <- changed[[kk]]
[17:42:39.264]                   NAME <- NAMES[[kk]]
[17:42:39.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.264]                     next
[17:42:39.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.264]                 }
[17:42:39.264]                 NAMES <- toupper(added)
[17:42:39.264]                 for (kk in seq_along(NAMES)) {
[17:42:39.264]                   name <- added[[kk]]
[17:42:39.264]                   NAME <- NAMES[[kk]]
[17:42:39.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.264]                     next
[17:42:39.264]                   args[[name]] <- ""
[17:42:39.264]                 }
[17:42:39.264]                 NAMES <- toupper(removed)
[17:42:39.264]                 for (kk in seq_along(NAMES)) {
[17:42:39.264]                   name <- removed[[kk]]
[17:42:39.264]                   NAME <- NAMES[[kk]]
[17:42:39.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.264]                     next
[17:42:39.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.264]                 }
[17:42:39.264]                 if (length(args) > 0) 
[17:42:39.264]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.264]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.264]             }
[17:42:39.264]             else {
[17:42:39.264]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.264]             }
[17:42:39.264]             {
[17:42:39.264]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.264]                   0L) {
[17:42:39.264]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.264]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.264]                   base::options(opts)
[17:42:39.264]                 }
[17:42:39.264]                 {
[17:42:39.264]                   {
[17:42:39.264]                     NULL
[17:42:39.264]                     RNGkind("Mersenne-Twister")
[17:42:39.264]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.264]                       inherits = FALSE)
[17:42:39.264]                   }
[17:42:39.264]                   options(future.plan = NULL)
[17:42:39.264]                   if (is.na(NA_character_)) 
[17:42:39.264]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.264]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.264]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.264]                   {
[17:42:39.264]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.264]                     if (!future$lazy) 
[17:42:39.264]                       future <- run(future)
[17:42:39.264]                     invisible(future)
[17:42:39.264]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.264]                 }
[17:42:39.264]             }
[17:42:39.264]         }
[17:42:39.264]     })
[17:42:39.264]     if (TRUE) {
[17:42:39.264]         base::sink(type = "output", split = FALSE)
[17:42:39.264]         if (TRUE) {
[17:42:39.264]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.264]         }
[17:42:39.264]         else {
[17:42:39.264]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.264]         }
[17:42:39.264]         base::close(...future.stdout)
[17:42:39.264]         ...future.stdout <- NULL
[17:42:39.264]     }
[17:42:39.264]     ...future.result$conditions <- ...future.conditions
[17:42:39.264]     ...future.result$finished <- base::Sys.time()
[17:42:39.264]     ...future.result
[17:42:39.264] }
[17:42:39.266] assign_globals() ...
[17:42:39.266] List of 1
[17:42:39.266]  $ x: list()
[17:42:39.266]  - attr(*, "where")=List of 1
[17:42:39.266]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.266]  - attr(*, "resolved")= logi TRUE
[17:42:39.266]  - attr(*, "total_size")= num 0
[17:42:39.266]  - attr(*, "already-done")= logi TRUE
[17:42:39.268] - copied ‘x’ to environment
[17:42:39.268] assign_globals() ... done
[17:42:39.269] plan(): Setting new future strategy stack:
[17:42:39.269] List of future strategies:
[17:42:39.269] 1. sequential:
[17:42:39.269]    - args: function (..., envir = parent.frame())
[17:42:39.269]    - tweaked: FALSE
[17:42:39.269]    - call: NULL
[17:42:39.269] plan(): nbrOfWorkers() = 1
[17:42:39.270] plan(): Setting new future strategy stack:
[17:42:39.270] List of future strategies:
[17:42:39.270] 1. sequential:
[17:42:39.270]    - args: function (..., envir = parent.frame())
[17:42:39.270]    - tweaked: FALSE
[17:42:39.270]    - call: plan(strategy)
[17:42:39.270] plan(): nbrOfWorkers() = 1
[17:42:39.271] SequentialFuture started (and completed)
[17:42:39.271] - Launch lazy future ... done
[17:42:39.271] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.271] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.271] Searching for globals...
[17:42:39.274] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.274] Searching for globals ... DONE
[17:42:39.274] Resolving globals: TRUE
[17:42:39.274] Resolving any globals that are futures ...
[17:42:39.274] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.274] Resolving any globals that are futures ... DONE
[17:42:39.274] Resolving futures part of globals (recursively) ...
[17:42:39.275] resolve() on list ...
[17:42:39.275]  recursive: 99
[17:42:39.275]  length: 1
[17:42:39.275]  elements: ‘x’
[17:42:39.275]  length: 0 (resolved future 1)
[17:42:39.275] resolve() on list ... DONE
[17:42:39.275] - globals: [1] ‘x’
[17:42:39.275] Resolving futures part of globals (recursively) ... DONE
[17:42:39.276] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.276] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.276] - globals: [1] ‘x’
[17:42:39.276] 
[17:42:39.276] getGlobalsAndPackages() ... DONE
[17:42:39.276] run() for ‘Future’ ...
[17:42:39.277] - state: ‘created’
[17:42:39.277] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.277] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.277]   - Field: ‘label’
[17:42:39.277]   - Field: ‘local’
[17:42:39.277]   - Field: ‘owner’
[17:42:39.277]   - Field: ‘envir’
[17:42:39.278]   - Field: ‘packages’
[17:42:39.278]   - Field: ‘gc’
[17:42:39.278]   - Field: ‘conditions’
[17:42:39.278]   - Field: ‘expr’
[17:42:39.278]   - Field: ‘uuid’
[17:42:39.278]   - Field: ‘seed’
[17:42:39.278]   - Field: ‘version’
[17:42:39.278]   - Field: ‘result’
[17:42:39.278]   - Field: ‘asynchronous’
[17:42:39.278]   - Field: ‘calls’
[17:42:39.278]   - Field: ‘globals’
[17:42:39.279]   - Field: ‘stdout’
[17:42:39.279]   - Field: ‘earlySignal’
[17:42:39.279]   - Field: ‘lazy’
[17:42:39.279]   - Field: ‘state’
[17:42:39.279] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.279] - Launch lazy future ...
[17:42:39.279] Packages needed by the future expression (n = 0): <none>
[17:42:39.279] Packages needed by future strategies (n = 0): <none>
[17:42:39.280] {
[17:42:39.280]     {
[17:42:39.280]         {
[17:42:39.280]             ...future.startTime <- base::Sys.time()
[17:42:39.280]             {
[17:42:39.280]                 {
[17:42:39.280]                   {
[17:42:39.280]                     base::local({
[17:42:39.280]                       has_future <- base::requireNamespace("future", 
[17:42:39.280]                         quietly = TRUE)
[17:42:39.280]                       if (has_future) {
[17:42:39.280]                         ns <- base::getNamespace("future")
[17:42:39.280]                         version <- ns[[".package"]][["version"]]
[17:42:39.280]                         if (is.null(version)) 
[17:42:39.280]                           version <- utils::packageVersion("future")
[17:42:39.280]                       }
[17:42:39.280]                       else {
[17:42:39.280]                         version <- NULL
[17:42:39.280]                       }
[17:42:39.280]                       if (!has_future || version < "1.8.0") {
[17:42:39.280]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.280]                           "", base::R.version$version.string), 
[17:42:39.280]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.280]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.280]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.280]                             "release", "version")], collapse = " "), 
[17:42:39.280]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.280]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.280]                           info)
[17:42:39.280]                         info <- base::paste(info, collapse = "; ")
[17:42:39.280]                         if (!has_future) {
[17:42:39.280]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.280]                             info)
[17:42:39.280]                         }
[17:42:39.280]                         else {
[17:42:39.280]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.280]                             info, version)
[17:42:39.280]                         }
[17:42:39.280]                         base::stop(msg)
[17:42:39.280]                       }
[17:42:39.280]                     })
[17:42:39.280]                   }
[17:42:39.280]                   options(future.plan = NULL)
[17:42:39.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.280]                 }
[17:42:39.280]                 ...future.workdir <- getwd()
[17:42:39.280]             }
[17:42:39.280]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.280]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.280]         }
[17:42:39.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.280]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.280]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.280]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.280]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.280]             base::names(...future.oldOptions))
[17:42:39.280]     }
[17:42:39.280]     if (FALSE) {
[17:42:39.280]     }
[17:42:39.280]     else {
[17:42:39.280]         if (TRUE) {
[17:42:39.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.280]                 open = "w")
[17:42:39.280]         }
[17:42:39.280]         else {
[17:42:39.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.280]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.280]         }
[17:42:39.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.280]             base::sink(type = "output", split = FALSE)
[17:42:39.280]             base::close(...future.stdout)
[17:42:39.280]         }, add = TRUE)
[17:42:39.280]     }
[17:42:39.280]     ...future.frame <- base::sys.nframe()
[17:42:39.280]     ...future.conditions <- base::list()
[17:42:39.280]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.280]     if (FALSE) {
[17:42:39.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.280]     }
[17:42:39.280]     ...future.result <- base::tryCatch({
[17:42:39.280]         base::withCallingHandlers({
[17:42:39.280]             ...future.value <- base::withVisible(base::local({
[17:42:39.280]                 x["a"] <- list(1)
[17:42:39.280]                 x
[17:42:39.280]             }))
[17:42:39.280]             future::FutureResult(value = ...future.value$value, 
[17:42:39.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.280]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.280]                     ...future.globalenv.names))
[17:42:39.280]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.280]         }, condition = base::local({
[17:42:39.280]             c <- base::c
[17:42:39.280]             inherits <- base::inherits
[17:42:39.280]             invokeRestart <- base::invokeRestart
[17:42:39.280]             length <- base::length
[17:42:39.280]             list <- base::list
[17:42:39.280]             seq.int <- base::seq.int
[17:42:39.280]             signalCondition <- base::signalCondition
[17:42:39.280]             sys.calls <- base::sys.calls
[17:42:39.280]             `[[` <- base::`[[`
[17:42:39.280]             `+` <- base::`+`
[17:42:39.280]             `<<-` <- base::`<<-`
[17:42:39.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.280]                   3L)]
[17:42:39.280]             }
[17:42:39.280]             function(cond) {
[17:42:39.280]                 is_error <- inherits(cond, "error")
[17:42:39.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.280]                   NULL)
[17:42:39.280]                 if (is_error) {
[17:42:39.280]                   sessionInformation <- function() {
[17:42:39.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.280]                       search = base::search(), system = base::Sys.info())
[17:42:39.280]                   }
[17:42:39.280]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.280]                     cond$call), session = sessionInformation(), 
[17:42:39.280]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.280]                   signalCondition(cond)
[17:42:39.280]                 }
[17:42:39.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.280]                 "immediateCondition"))) {
[17:42:39.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.280]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.280]                   if (TRUE && !signal) {
[17:42:39.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.280]                     {
[17:42:39.280]                       inherits <- base::inherits
[17:42:39.280]                       invokeRestart <- base::invokeRestart
[17:42:39.280]                       is.null <- base::is.null
[17:42:39.280]                       muffled <- FALSE
[17:42:39.280]                       if (inherits(cond, "message")) {
[17:42:39.280]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.280]                         if (muffled) 
[17:42:39.280]                           invokeRestart("muffleMessage")
[17:42:39.280]                       }
[17:42:39.280]                       else if (inherits(cond, "warning")) {
[17:42:39.280]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.280]                         if (muffled) 
[17:42:39.280]                           invokeRestart("muffleWarning")
[17:42:39.280]                       }
[17:42:39.280]                       else if (inherits(cond, "condition")) {
[17:42:39.280]                         if (!is.null(pattern)) {
[17:42:39.280]                           computeRestarts <- base::computeRestarts
[17:42:39.280]                           grepl <- base::grepl
[17:42:39.280]                           restarts <- computeRestarts(cond)
[17:42:39.280]                           for (restart in restarts) {
[17:42:39.280]                             name <- restart$name
[17:42:39.280]                             if (is.null(name)) 
[17:42:39.280]                               next
[17:42:39.280]                             if (!grepl(pattern, name)) 
[17:42:39.280]                               next
[17:42:39.280]                             invokeRestart(restart)
[17:42:39.280]                             muffled <- TRUE
[17:42:39.280]                             break
[17:42:39.280]                           }
[17:42:39.280]                         }
[17:42:39.280]                       }
[17:42:39.280]                       invisible(muffled)
[17:42:39.280]                     }
[17:42:39.280]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.280]                   }
[17:42:39.280]                 }
[17:42:39.280]                 else {
[17:42:39.280]                   if (TRUE) {
[17:42:39.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.280]                     {
[17:42:39.280]                       inherits <- base::inherits
[17:42:39.280]                       invokeRestart <- base::invokeRestart
[17:42:39.280]                       is.null <- base::is.null
[17:42:39.280]                       muffled <- FALSE
[17:42:39.280]                       if (inherits(cond, "message")) {
[17:42:39.280]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.280]                         if (muffled) 
[17:42:39.280]                           invokeRestart("muffleMessage")
[17:42:39.280]                       }
[17:42:39.280]                       else if (inherits(cond, "warning")) {
[17:42:39.280]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.280]                         if (muffled) 
[17:42:39.280]                           invokeRestart("muffleWarning")
[17:42:39.280]                       }
[17:42:39.280]                       else if (inherits(cond, "condition")) {
[17:42:39.280]                         if (!is.null(pattern)) {
[17:42:39.280]                           computeRestarts <- base::computeRestarts
[17:42:39.280]                           grepl <- base::grepl
[17:42:39.280]                           restarts <- computeRestarts(cond)
[17:42:39.280]                           for (restart in restarts) {
[17:42:39.280]                             name <- restart$name
[17:42:39.280]                             if (is.null(name)) 
[17:42:39.280]                               next
[17:42:39.280]                             if (!grepl(pattern, name)) 
[17:42:39.280]                               next
[17:42:39.280]                             invokeRestart(restart)
[17:42:39.280]                             muffled <- TRUE
[17:42:39.280]                             break
[17:42:39.280]                           }
[17:42:39.280]                         }
[17:42:39.280]                       }
[17:42:39.280]                       invisible(muffled)
[17:42:39.280]                     }
[17:42:39.280]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.280]                   }
[17:42:39.280]                 }
[17:42:39.280]             }
[17:42:39.280]         }))
[17:42:39.280]     }, error = function(ex) {
[17:42:39.280]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.280]                 ...future.rng), started = ...future.startTime, 
[17:42:39.280]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.280]             version = "1.8"), class = "FutureResult")
[17:42:39.280]     }, finally = {
[17:42:39.280]         if (!identical(...future.workdir, getwd())) 
[17:42:39.280]             setwd(...future.workdir)
[17:42:39.280]         {
[17:42:39.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.280]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.280]             }
[17:42:39.280]             base::options(...future.oldOptions)
[17:42:39.280]             if (.Platform$OS.type == "windows") {
[17:42:39.280]                 old_names <- names(...future.oldEnvVars)
[17:42:39.280]                 envs <- base::Sys.getenv()
[17:42:39.280]                 names <- names(envs)
[17:42:39.280]                 common <- intersect(names, old_names)
[17:42:39.280]                 added <- setdiff(names, old_names)
[17:42:39.280]                 removed <- setdiff(old_names, names)
[17:42:39.280]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.280]                   envs[common]]
[17:42:39.280]                 NAMES <- toupper(changed)
[17:42:39.280]                 args <- list()
[17:42:39.280]                 for (kk in seq_along(NAMES)) {
[17:42:39.280]                   name <- changed[[kk]]
[17:42:39.280]                   NAME <- NAMES[[kk]]
[17:42:39.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.280]                     next
[17:42:39.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.280]                 }
[17:42:39.280]                 NAMES <- toupper(added)
[17:42:39.280]                 for (kk in seq_along(NAMES)) {
[17:42:39.280]                   name <- added[[kk]]
[17:42:39.280]                   NAME <- NAMES[[kk]]
[17:42:39.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.280]                     next
[17:42:39.280]                   args[[name]] <- ""
[17:42:39.280]                 }
[17:42:39.280]                 NAMES <- toupper(removed)
[17:42:39.280]                 for (kk in seq_along(NAMES)) {
[17:42:39.280]                   name <- removed[[kk]]
[17:42:39.280]                   NAME <- NAMES[[kk]]
[17:42:39.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.280]                     next
[17:42:39.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.280]                 }
[17:42:39.280]                 if (length(args) > 0) 
[17:42:39.280]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.280]             }
[17:42:39.280]             else {
[17:42:39.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.280]             }
[17:42:39.280]             {
[17:42:39.280]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.280]                   0L) {
[17:42:39.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.280]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.280]                   base::options(opts)
[17:42:39.280]                 }
[17:42:39.280]                 {
[17:42:39.280]                   {
[17:42:39.280]                     NULL
[17:42:39.280]                     RNGkind("Mersenne-Twister")
[17:42:39.280]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.280]                       inherits = FALSE)
[17:42:39.280]                   }
[17:42:39.280]                   options(future.plan = NULL)
[17:42:39.280]                   if (is.na(NA_character_)) 
[17:42:39.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.280]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.280]                   {
[17:42:39.280]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.280]                     if (!future$lazy) 
[17:42:39.280]                       future <- run(future)
[17:42:39.280]                     invisible(future)
[17:42:39.280]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.280]                 }
[17:42:39.280]             }
[17:42:39.280]         }
[17:42:39.280]     })
[17:42:39.280]     if (TRUE) {
[17:42:39.280]         base::sink(type = "output", split = FALSE)
[17:42:39.280]         if (TRUE) {
[17:42:39.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.280]         }
[17:42:39.280]         else {
[17:42:39.280]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.280]         }
[17:42:39.280]         base::close(...future.stdout)
[17:42:39.280]         ...future.stdout <- NULL
[17:42:39.280]     }
[17:42:39.280]     ...future.result$conditions <- ...future.conditions
[17:42:39.280]     ...future.result$finished <- base::Sys.time()
[17:42:39.280]     ...future.result
[17:42:39.280] }
[17:42:39.281] assign_globals() ...
[17:42:39.282] List of 1
[17:42:39.282]  $ x: list()
[17:42:39.282]  - attr(*, "where")=List of 1
[17:42:39.282]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.282]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.282]  - attr(*, "resolved")= logi TRUE
[17:42:39.282]  - attr(*, "total_size")= num 0
[17:42:39.282]  - attr(*, "already-done")= logi TRUE
[17:42:39.286] - copied ‘x’ to environment
[17:42:39.286] assign_globals() ... done
[17:42:39.286] plan(): Setting new future strategy stack:
[17:42:39.286] List of future strategies:
[17:42:39.286] 1. sequential:
[17:42:39.286]    - args: function (..., envir = parent.frame())
[17:42:39.286]    - tweaked: FALSE
[17:42:39.286]    - call: NULL
[17:42:39.286] plan(): nbrOfWorkers() = 1
[17:42:39.287] plan(): Setting new future strategy stack:
[17:42:39.287] List of future strategies:
[17:42:39.287] 1. sequential:
[17:42:39.287]    - args: function (..., envir = parent.frame())
[17:42:39.287]    - tweaked: FALSE
[17:42:39.287]    - call: plan(strategy)
[17:42:39.288] plan(): nbrOfWorkers() = 1
[17:42:39.288] SequentialFuture started (and completed)
[17:42:39.288] - Launch lazy future ... done
[17:42:39.288] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.288] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.289] Searching for globals...
[17:42:39.291] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:42:39.291] Searching for globals ... DONE
[17:42:39.291] Resolving globals: TRUE
[17:42:39.291] Resolving any globals that are futures ...
[17:42:39.291] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:42:39.291] Resolving any globals that are futures ... DONE
[17:42:39.292] Resolving futures part of globals (recursively) ...
[17:42:39.292] resolve() on list ...
[17:42:39.292]  recursive: 99
[17:42:39.292]  length: 2
[17:42:39.292]  elements: ‘x’, ‘name’
[17:42:39.292]  length: 1 (resolved future 1)
[17:42:39.292]  length: 0 (resolved future 2)
[17:42:39.292] resolve() on list ... DONE
[17:42:39.293] - globals: [2] ‘x’, ‘name’
[17:42:39.293] Resolving futures part of globals (recursively) ... DONE
[17:42:39.293] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:39.293] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:42:39.293] - globals: [2] ‘x’, ‘name’
[17:42:39.293] 
[17:42:39.294] getGlobalsAndPackages() ... DONE
[17:42:39.294] run() for ‘Future’ ...
[17:42:39.294] - state: ‘created’
[17:42:39.294] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:39.294] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:39.294] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:39.294]   - Field: ‘label’
[17:42:39.295]   - Field: ‘local’
[17:42:39.295]   - Field: ‘owner’
[17:42:39.295]   - Field: ‘envir’
[17:42:39.295]   - Field: ‘packages’
[17:42:39.295]   - Field: ‘gc’
[17:42:39.295]   - Field: ‘conditions’
[17:42:39.295]   - Field: ‘expr’
[17:42:39.295]   - Field: ‘uuid’
[17:42:39.295]   - Field: ‘seed’
[17:42:39.295]   - Field: ‘version’
[17:42:39.296]   - Field: ‘result’
[17:42:39.296]   - Field: ‘asynchronous’
[17:42:39.296]   - Field: ‘calls’
[17:42:39.296]   - Field: ‘globals’
[17:42:39.296]   - Field: ‘stdout’
[17:42:39.296]   - Field: ‘earlySignal’
[17:42:39.296]   - Field: ‘lazy’
[17:42:39.296]   - Field: ‘state’
[17:42:39.296] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:39.296] - Launch lazy future ...
[17:42:39.297] Packages needed by the future expression (n = 0): <none>
[17:42:39.297] Packages needed by future strategies (n = 0): <none>
[17:42:39.297] {
[17:42:39.297]     {
[17:42:39.297]         {
[17:42:39.297]             ...future.startTime <- base::Sys.time()
[17:42:39.297]             {
[17:42:39.297]                 {
[17:42:39.297]                   {
[17:42:39.297]                     base::local({
[17:42:39.297]                       has_future <- base::requireNamespace("future", 
[17:42:39.297]                         quietly = TRUE)
[17:42:39.297]                       if (has_future) {
[17:42:39.297]                         ns <- base::getNamespace("future")
[17:42:39.297]                         version <- ns[[".package"]][["version"]]
[17:42:39.297]                         if (is.null(version)) 
[17:42:39.297]                           version <- utils::packageVersion("future")
[17:42:39.297]                       }
[17:42:39.297]                       else {
[17:42:39.297]                         version <- NULL
[17:42:39.297]                       }
[17:42:39.297]                       if (!has_future || version < "1.8.0") {
[17:42:39.297]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.297]                           "", base::R.version$version.string), 
[17:42:39.297]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:39.297]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.297]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.297]                             "release", "version")], collapse = " "), 
[17:42:39.297]                           hostname = base::Sys.info()[["nodename"]])
[17:42:39.297]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.297]                           info)
[17:42:39.297]                         info <- base::paste(info, collapse = "; ")
[17:42:39.297]                         if (!has_future) {
[17:42:39.297]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.297]                             info)
[17:42:39.297]                         }
[17:42:39.297]                         else {
[17:42:39.297]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.297]                             info, version)
[17:42:39.297]                         }
[17:42:39.297]                         base::stop(msg)
[17:42:39.297]                       }
[17:42:39.297]                     })
[17:42:39.297]                   }
[17:42:39.297]                   options(future.plan = NULL)
[17:42:39.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.297]                 }
[17:42:39.297]                 ...future.workdir <- getwd()
[17:42:39.297]             }
[17:42:39.297]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.297]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.297]         }
[17:42:39.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.297]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.297]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.297]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.297]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.297]             base::names(...future.oldOptions))
[17:42:39.297]     }
[17:42:39.297]     if (FALSE) {
[17:42:39.297]     }
[17:42:39.297]     else {
[17:42:39.297]         if (TRUE) {
[17:42:39.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.297]                 open = "w")
[17:42:39.297]         }
[17:42:39.297]         else {
[17:42:39.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.297]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.297]         }
[17:42:39.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.297]             base::sink(type = "output", split = FALSE)
[17:42:39.297]             base::close(...future.stdout)
[17:42:39.297]         }, add = TRUE)
[17:42:39.297]     }
[17:42:39.297]     ...future.frame <- base::sys.nframe()
[17:42:39.297]     ...future.conditions <- base::list()
[17:42:39.297]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.297]     if (FALSE) {
[17:42:39.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.297]     }
[17:42:39.297]     ...future.result <- base::tryCatch({
[17:42:39.297]         base::withCallingHandlers({
[17:42:39.297]             ...future.value <- base::withVisible(base::local({
[17:42:39.297]                 x[name] <- list(1)
[17:42:39.297]                 x
[17:42:39.297]             }))
[17:42:39.297]             future::FutureResult(value = ...future.value$value, 
[17:42:39.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.297]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.297]                     ...future.globalenv.names))
[17:42:39.297]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.297]         }, condition = base::local({
[17:42:39.297]             c <- base::c
[17:42:39.297]             inherits <- base::inherits
[17:42:39.297]             invokeRestart <- base::invokeRestart
[17:42:39.297]             length <- base::length
[17:42:39.297]             list <- base::list
[17:42:39.297]             seq.int <- base::seq.int
[17:42:39.297]             signalCondition <- base::signalCondition
[17:42:39.297]             sys.calls <- base::sys.calls
[17:42:39.297]             `[[` <- base::`[[`
[17:42:39.297]             `+` <- base::`+`
[17:42:39.297]             `<<-` <- base::`<<-`
[17:42:39.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.297]                   3L)]
[17:42:39.297]             }
[17:42:39.297]             function(cond) {
[17:42:39.297]                 is_error <- inherits(cond, "error")
[17:42:39.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.297]                   NULL)
[17:42:39.297]                 if (is_error) {
[17:42:39.297]                   sessionInformation <- function() {
[17:42:39.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.297]                       search = base::search(), system = base::Sys.info())
[17:42:39.297]                   }
[17:42:39.297]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.297]                     cond$call), session = sessionInformation(), 
[17:42:39.297]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.297]                   signalCondition(cond)
[17:42:39.297]                 }
[17:42:39.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.297]                 "immediateCondition"))) {
[17:42:39.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.297]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.297]                   if (TRUE && !signal) {
[17:42:39.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.297]                     {
[17:42:39.297]                       inherits <- base::inherits
[17:42:39.297]                       invokeRestart <- base::invokeRestart
[17:42:39.297]                       is.null <- base::is.null
[17:42:39.297]                       muffled <- FALSE
[17:42:39.297]                       if (inherits(cond, "message")) {
[17:42:39.297]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.297]                         if (muffled) 
[17:42:39.297]                           invokeRestart("muffleMessage")
[17:42:39.297]                       }
[17:42:39.297]                       else if (inherits(cond, "warning")) {
[17:42:39.297]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.297]                         if (muffled) 
[17:42:39.297]                           invokeRestart("muffleWarning")
[17:42:39.297]                       }
[17:42:39.297]                       else if (inherits(cond, "condition")) {
[17:42:39.297]                         if (!is.null(pattern)) {
[17:42:39.297]                           computeRestarts <- base::computeRestarts
[17:42:39.297]                           grepl <- base::grepl
[17:42:39.297]                           restarts <- computeRestarts(cond)
[17:42:39.297]                           for (restart in restarts) {
[17:42:39.297]                             name <- restart$name
[17:42:39.297]                             if (is.null(name)) 
[17:42:39.297]                               next
[17:42:39.297]                             if (!grepl(pattern, name)) 
[17:42:39.297]                               next
[17:42:39.297]                             invokeRestart(restart)
[17:42:39.297]                             muffled <- TRUE
[17:42:39.297]                             break
[17:42:39.297]                           }
[17:42:39.297]                         }
[17:42:39.297]                       }
[17:42:39.297]                       invisible(muffled)
[17:42:39.297]                     }
[17:42:39.297]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.297]                   }
[17:42:39.297]                 }
[17:42:39.297]                 else {
[17:42:39.297]                   if (TRUE) {
[17:42:39.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.297]                     {
[17:42:39.297]                       inherits <- base::inherits
[17:42:39.297]                       invokeRestart <- base::invokeRestart
[17:42:39.297]                       is.null <- base::is.null
[17:42:39.297]                       muffled <- FALSE
[17:42:39.297]                       if (inherits(cond, "message")) {
[17:42:39.297]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.297]                         if (muffled) 
[17:42:39.297]                           invokeRestart("muffleMessage")
[17:42:39.297]                       }
[17:42:39.297]                       else if (inherits(cond, "warning")) {
[17:42:39.297]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.297]                         if (muffled) 
[17:42:39.297]                           invokeRestart("muffleWarning")
[17:42:39.297]                       }
[17:42:39.297]                       else if (inherits(cond, "condition")) {
[17:42:39.297]                         if (!is.null(pattern)) {
[17:42:39.297]                           computeRestarts <- base::computeRestarts
[17:42:39.297]                           grepl <- base::grepl
[17:42:39.297]                           restarts <- computeRestarts(cond)
[17:42:39.297]                           for (restart in restarts) {
[17:42:39.297]                             name <- restart$name
[17:42:39.297]                             if (is.null(name)) 
[17:42:39.297]                               next
[17:42:39.297]                             if (!grepl(pattern, name)) 
[17:42:39.297]                               next
[17:42:39.297]                             invokeRestart(restart)
[17:42:39.297]                             muffled <- TRUE
[17:42:39.297]                             break
[17:42:39.297]                           }
[17:42:39.297]                         }
[17:42:39.297]                       }
[17:42:39.297]                       invisible(muffled)
[17:42:39.297]                     }
[17:42:39.297]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.297]                   }
[17:42:39.297]                 }
[17:42:39.297]             }
[17:42:39.297]         }))
[17:42:39.297]     }, error = function(ex) {
[17:42:39.297]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.297]                 ...future.rng), started = ...future.startTime, 
[17:42:39.297]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.297]             version = "1.8"), class = "FutureResult")
[17:42:39.297]     }, finally = {
[17:42:39.297]         if (!identical(...future.workdir, getwd())) 
[17:42:39.297]             setwd(...future.workdir)
[17:42:39.297]         {
[17:42:39.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.297]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.297]             }
[17:42:39.297]             base::options(...future.oldOptions)
[17:42:39.297]             if (.Platform$OS.type == "windows") {
[17:42:39.297]                 old_names <- names(...future.oldEnvVars)
[17:42:39.297]                 envs <- base::Sys.getenv()
[17:42:39.297]                 names <- names(envs)
[17:42:39.297]                 common <- intersect(names, old_names)
[17:42:39.297]                 added <- setdiff(names, old_names)
[17:42:39.297]                 removed <- setdiff(old_names, names)
[17:42:39.297]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.297]                   envs[common]]
[17:42:39.297]                 NAMES <- toupper(changed)
[17:42:39.297]                 args <- list()
[17:42:39.297]                 for (kk in seq_along(NAMES)) {
[17:42:39.297]                   name <- changed[[kk]]
[17:42:39.297]                   NAME <- NAMES[[kk]]
[17:42:39.297]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.297]                     next
[17:42:39.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.297]                 }
[17:42:39.297]                 NAMES <- toupper(added)
[17:42:39.297]                 for (kk in seq_along(NAMES)) {
[17:42:39.297]                   name <- added[[kk]]
[17:42:39.297]                   NAME <- NAMES[[kk]]
[17:42:39.297]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.297]                     next
[17:42:39.297]                   args[[name]] <- ""
[17:42:39.297]                 }
[17:42:39.297]                 NAMES <- toupper(removed)
[17:42:39.297]                 for (kk in seq_along(NAMES)) {
[17:42:39.297]                   name <- removed[[kk]]
[17:42:39.297]                   NAME <- NAMES[[kk]]
[17:42:39.297]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.297]                     next
[17:42:39.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.297]                 }
[17:42:39.297]                 if (length(args) > 0) 
[17:42:39.297]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.297]             }
[17:42:39.297]             else {
[17:42:39.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.297]             }
[17:42:39.297]             {
[17:42:39.297]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.297]                   0L) {
[17:42:39.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.297]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.297]                   base::options(opts)
[17:42:39.297]                 }
[17:42:39.297]                 {
[17:42:39.297]                   {
[17:42:39.297]                     NULL
[17:42:39.297]                     RNGkind("Mersenne-Twister")
[17:42:39.297]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:39.297]                       inherits = FALSE)
[17:42:39.297]                   }
[17:42:39.297]                   options(future.plan = NULL)
[17:42:39.297]                   if (is.na(NA_character_)) 
[17:42:39.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.297]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:39.297]                   {
[17:42:39.297]                     future <- SequentialFuture(..., envir = envir)
[17:42:39.297]                     if (!future$lazy) 
[17:42:39.297]                       future <- run(future)
[17:42:39.297]                     invisible(future)
[17:42:39.297]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.297]                 }
[17:42:39.297]             }
[17:42:39.297]         }
[17:42:39.297]     })
[17:42:39.297]     if (TRUE) {
[17:42:39.297]         base::sink(type = "output", split = FALSE)
[17:42:39.297]         if (TRUE) {
[17:42:39.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.297]         }
[17:42:39.297]         else {
[17:42:39.297]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.297]         }
[17:42:39.297]         base::close(...future.stdout)
[17:42:39.297]         ...future.stdout <- NULL
[17:42:39.297]     }
[17:42:39.297]     ...future.result$conditions <- ...future.conditions
[17:42:39.297]     ...future.result$finished <- base::Sys.time()
[17:42:39.297]     ...future.result
[17:42:39.297] }
[17:42:39.299] assign_globals() ...
[17:42:39.299] List of 2
[17:42:39.299]  $ x   : list()
[17:42:39.299]  $ name: chr "a"
[17:42:39.299]  - attr(*, "where")=List of 2
[17:42:39.299]   ..$ x   :<environment: R_EmptyEnv> 
[17:42:39.299]   ..$ name:<environment: R_EmptyEnv> 
[17:42:39.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.299]  - attr(*, "resolved")= logi TRUE
[17:42:39.299]  - attr(*, "total_size")= num 112
[17:42:39.299]  - attr(*, "already-done")= logi TRUE
[17:42:39.301] - copied ‘x’ to environment
[17:42:39.302] - copied ‘name’ to environment
[17:42:39.302] assign_globals() ... done
[17:42:39.302] plan(): Setting new future strategy stack:
[17:42:39.302] List of future strategies:
[17:42:39.302] 1. sequential:
[17:42:39.302]    - args: function (..., envir = parent.frame())
[17:42:39.302]    - tweaked: FALSE
[17:42:39.302]    - call: NULL
[17:42:39.302] plan(): nbrOfWorkers() = 1
[17:42:39.303] plan(): Setting new future strategy stack:
[17:42:39.303] List of future strategies:
[17:42:39.303] 1. sequential:
[17:42:39.303]    - args: function (..., envir = parent.frame())
[17:42:39.303]    - tweaked: FALSE
[17:42:39.303]    - call: plan(strategy)
[17:42:39.304] plan(): nbrOfWorkers() = 1
[17:42:39.304] SequentialFuture started (and completed)
[17:42:39.304] - Launch lazy future ... done
[17:42:39.304] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[17:42:39.316] plan(): Setting new future strategy stack:
[17:42:39.316] List of future strategies:
[17:42:39.316] 1. multicore:
[17:42:39.316]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.316]    - tweaked: FALSE
[17:42:39.316]    - call: plan(strategy)
[17:42:39.320] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.321] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.321] Searching for globals...
[17:42:39.323] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.323] Searching for globals ... DONE
[17:42:39.323] Resolving globals: TRUE
[17:42:39.323] Resolving any globals that are futures ...
[17:42:39.323] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.323] Resolving any globals that are futures ... DONE
[17:42:39.324] Resolving futures part of globals (recursively) ...
[17:42:39.324] resolve() on list ...
[17:42:39.324]  recursive: 99
[17:42:39.324]  length: 1
[17:42:39.324]  elements: ‘x’
[17:42:39.324]  length: 0 (resolved future 1)
[17:42:39.325] resolve() on list ... DONE
[17:42:39.325] - globals: [1] ‘x’
[17:42:39.325] Resolving futures part of globals (recursively) ... DONE
[17:42:39.325] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.325] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.325] - globals: [1] ‘x’
[17:42:39.325] 
[17:42:39.326] getGlobalsAndPackages() ... DONE
[17:42:39.326] run() for ‘Future’ ...
[17:42:39.326] - state: ‘created’
[17:42:39.326] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.330] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.330]   - Field: ‘label’
[17:42:39.330]   - Field: ‘local’
[17:42:39.330]   - Field: ‘owner’
[17:42:39.330]   - Field: ‘envir’
[17:42:39.330]   - Field: ‘workers’
[17:42:39.330]   - Field: ‘packages’
[17:42:39.331]   - Field: ‘gc’
[17:42:39.331]   - Field: ‘job’
[17:42:39.331]   - Field: ‘conditions’
[17:42:39.331]   - Field: ‘expr’
[17:42:39.331]   - Field: ‘uuid’
[17:42:39.331]   - Field: ‘seed’
[17:42:39.331]   - Field: ‘version’
[17:42:39.331]   - Field: ‘result’
[17:42:39.331]   - Field: ‘asynchronous’
[17:42:39.331]   - Field: ‘calls’
[17:42:39.332]   - Field: ‘globals’
[17:42:39.332]   - Field: ‘stdout’
[17:42:39.332]   - Field: ‘earlySignal’
[17:42:39.332]   - Field: ‘lazy’
[17:42:39.332]   - Field: ‘state’
[17:42:39.332] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.332] - Launch lazy future ...
[17:42:39.333] Packages needed by the future expression (n = 0): <none>
[17:42:39.333] Packages needed by future strategies (n = 0): <none>
[17:42:39.334] {
[17:42:39.334]     {
[17:42:39.334]         {
[17:42:39.334]             ...future.startTime <- base::Sys.time()
[17:42:39.334]             {
[17:42:39.334]                 {
[17:42:39.334]                   {
[17:42:39.334]                     {
[17:42:39.334]                       base::local({
[17:42:39.334]                         has_future <- base::requireNamespace("future", 
[17:42:39.334]                           quietly = TRUE)
[17:42:39.334]                         if (has_future) {
[17:42:39.334]                           ns <- base::getNamespace("future")
[17:42:39.334]                           version <- ns[[".package"]][["version"]]
[17:42:39.334]                           if (is.null(version)) 
[17:42:39.334]                             version <- utils::packageVersion("future")
[17:42:39.334]                         }
[17:42:39.334]                         else {
[17:42:39.334]                           version <- NULL
[17:42:39.334]                         }
[17:42:39.334]                         if (!has_future || version < "1.8.0") {
[17:42:39.334]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.334]                             "", base::R.version$version.string), 
[17:42:39.334]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.334]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.334]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.334]                               "release", "version")], collapse = " "), 
[17:42:39.334]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.334]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.334]                             info)
[17:42:39.334]                           info <- base::paste(info, collapse = "; ")
[17:42:39.334]                           if (!has_future) {
[17:42:39.334]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.334]                               info)
[17:42:39.334]                           }
[17:42:39.334]                           else {
[17:42:39.334]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.334]                               info, version)
[17:42:39.334]                           }
[17:42:39.334]                           base::stop(msg)
[17:42:39.334]                         }
[17:42:39.334]                       })
[17:42:39.334]                     }
[17:42:39.334]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.334]                     base::options(mc.cores = 1L)
[17:42:39.334]                   }
[17:42:39.334]                   options(future.plan = NULL)
[17:42:39.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.334]                 }
[17:42:39.334]                 ...future.workdir <- getwd()
[17:42:39.334]             }
[17:42:39.334]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.334]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.334]         }
[17:42:39.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.334]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.334]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.334]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.334]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.334]             base::names(...future.oldOptions))
[17:42:39.334]     }
[17:42:39.334]     if (FALSE) {
[17:42:39.334]     }
[17:42:39.334]     else {
[17:42:39.334]         if (TRUE) {
[17:42:39.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.334]                 open = "w")
[17:42:39.334]         }
[17:42:39.334]         else {
[17:42:39.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.334]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.334]         }
[17:42:39.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.334]             base::sink(type = "output", split = FALSE)
[17:42:39.334]             base::close(...future.stdout)
[17:42:39.334]         }, add = TRUE)
[17:42:39.334]     }
[17:42:39.334]     ...future.frame <- base::sys.nframe()
[17:42:39.334]     ...future.conditions <- base::list()
[17:42:39.334]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.334]     if (FALSE) {
[17:42:39.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.334]     }
[17:42:39.334]     ...future.result <- base::tryCatch({
[17:42:39.334]         base::withCallingHandlers({
[17:42:39.334]             ...future.value <- base::withVisible(base::local({
[17:42:39.334]                 withCallingHandlers({
[17:42:39.334]                   {
[17:42:39.334]                     x$a <- 1
[17:42:39.334]                     x
[17:42:39.334]                   }
[17:42:39.334]                 }, immediateCondition = function(cond) {
[17:42:39.334]                   save_rds <- function (object, pathname, ...) 
[17:42:39.334]                   {
[17:42:39.334]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.334]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.334]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.334]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.334]                         fi_tmp[["mtime"]])
[17:42:39.334]                     }
[17:42:39.334]                     tryCatch({
[17:42:39.334]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.334]                     }, error = function(ex) {
[17:42:39.334]                       msg <- conditionMessage(ex)
[17:42:39.334]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.334]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.334]                         fi_tmp[["mtime"]], msg)
[17:42:39.334]                       ex$message <- msg
[17:42:39.334]                       stop(ex)
[17:42:39.334]                     })
[17:42:39.334]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.334]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.334]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.334]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.334]                       fi <- file.info(pathname)
[17:42:39.334]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.334]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.334]                         fi[["size"]], fi[["mtime"]])
[17:42:39.334]                       stop(msg)
[17:42:39.334]                     }
[17:42:39.334]                     invisible(pathname)
[17:42:39.334]                   }
[17:42:39.334]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.334]                     rootPath = tempdir()) 
[17:42:39.334]                   {
[17:42:39.334]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.334]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.334]                       tmpdir = path, fileext = ".rds")
[17:42:39.334]                     save_rds(obj, file)
[17:42:39.334]                   }
[17:42:39.334]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.334]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.334]                   {
[17:42:39.334]                     inherits <- base::inherits
[17:42:39.334]                     invokeRestart <- base::invokeRestart
[17:42:39.334]                     is.null <- base::is.null
[17:42:39.334]                     muffled <- FALSE
[17:42:39.334]                     if (inherits(cond, "message")) {
[17:42:39.334]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.334]                       if (muffled) 
[17:42:39.334]                         invokeRestart("muffleMessage")
[17:42:39.334]                     }
[17:42:39.334]                     else if (inherits(cond, "warning")) {
[17:42:39.334]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.334]                       if (muffled) 
[17:42:39.334]                         invokeRestart("muffleWarning")
[17:42:39.334]                     }
[17:42:39.334]                     else if (inherits(cond, "condition")) {
[17:42:39.334]                       if (!is.null(pattern)) {
[17:42:39.334]                         computeRestarts <- base::computeRestarts
[17:42:39.334]                         grepl <- base::grepl
[17:42:39.334]                         restarts <- computeRestarts(cond)
[17:42:39.334]                         for (restart in restarts) {
[17:42:39.334]                           name <- restart$name
[17:42:39.334]                           if (is.null(name)) 
[17:42:39.334]                             next
[17:42:39.334]                           if (!grepl(pattern, name)) 
[17:42:39.334]                             next
[17:42:39.334]                           invokeRestart(restart)
[17:42:39.334]                           muffled <- TRUE
[17:42:39.334]                           break
[17:42:39.334]                         }
[17:42:39.334]                       }
[17:42:39.334]                     }
[17:42:39.334]                     invisible(muffled)
[17:42:39.334]                   }
[17:42:39.334]                   muffleCondition(cond)
[17:42:39.334]                 })
[17:42:39.334]             }))
[17:42:39.334]             future::FutureResult(value = ...future.value$value, 
[17:42:39.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.334]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.334]                     ...future.globalenv.names))
[17:42:39.334]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.334]         }, condition = base::local({
[17:42:39.334]             c <- base::c
[17:42:39.334]             inherits <- base::inherits
[17:42:39.334]             invokeRestart <- base::invokeRestart
[17:42:39.334]             length <- base::length
[17:42:39.334]             list <- base::list
[17:42:39.334]             seq.int <- base::seq.int
[17:42:39.334]             signalCondition <- base::signalCondition
[17:42:39.334]             sys.calls <- base::sys.calls
[17:42:39.334]             `[[` <- base::`[[`
[17:42:39.334]             `+` <- base::`+`
[17:42:39.334]             `<<-` <- base::`<<-`
[17:42:39.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.334]                   3L)]
[17:42:39.334]             }
[17:42:39.334]             function(cond) {
[17:42:39.334]                 is_error <- inherits(cond, "error")
[17:42:39.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.334]                   NULL)
[17:42:39.334]                 if (is_error) {
[17:42:39.334]                   sessionInformation <- function() {
[17:42:39.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.334]                       search = base::search(), system = base::Sys.info())
[17:42:39.334]                   }
[17:42:39.334]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.334]                     cond$call), session = sessionInformation(), 
[17:42:39.334]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.334]                   signalCondition(cond)
[17:42:39.334]                 }
[17:42:39.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.334]                 "immediateCondition"))) {
[17:42:39.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.334]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.334]                   if (TRUE && !signal) {
[17:42:39.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.334]                     {
[17:42:39.334]                       inherits <- base::inherits
[17:42:39.334]                       invokeRestart <- base::invokeRestart
[17:42:39.334]                       is.null <- base::is.null
[17:42:39.334]                       muffled <- FALSE
[17:42:39.334]                       if (inherits(cond, "message")) {
[17:42:39.334]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.334]                         if (muffled) 
[17:42:39.334]                           invokeRestart("muffleMessage")
[17:42:39.334]                       }
[17:42:39.334]                       else if (inherits(cond, "warning")) {
[17:42:39.334]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.334]                         if (muffled) 
[17:42:39.334]                           invokeRestart("muffleWarning")
[17:42:39.334]                       }
[17:42:39.334]                       else if (inherits(cond, "condition")) {
[17:42:39.334]                         if (!is.null(pattern)) {
[17:42:39.334]                           computeRestarts <- base::computeRestarts
[17:42:39.334]                           grepl <- base::grepl
[17:42:39.334]                           restarts <- computeRestarts(cond)
[17:42:39.334]                           for (restart in restarts) {
[17:42:39.334]                             name <- restart$name
[17:42:39.334]                             if (is.null(name)) 
[17:42:39.334]                               next
[17:42:39.334]                             if (!grepl(pattern, name)) 
[17:42:39.334]                               next
[17:42:39.334]                             invokeRestart(restart)
[17:42:39.334]                             muffled <- TRUE
[17:42:39.334]                             break
[17:42:39.334]                           }
[17:42:39.334]                         }
[17:42:39.334]                       }
[17:42:39.334]                       invisible(muffled)
[17:42:39.334]                     }
[17:42:39.334]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.334]                   }
[17:42:39.334]                 }
[17:42:39.334]                 else {
[17:42:39.334]                   if (TRUE) {
[17:42:39.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.334]                     {
[17:42:39.334]                       inherits <- base::inherits
[17:42:39.334]                       invokeRestart <- base::invokeRestart
[17:42:39.334]                       is.null <- base::is.null
[17:42:39.334]                       muffled <- FALSE
[17:42:39.334]                       if (inherits(cond, "message")) {
[17:42:39.334]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.334]                         if (muffled) 
[17:42:39.334]                           invokeRestart("muffleMessage")
[17:42:39.334]                       }
[17:42:39.334]                       else if (inherits(cond, "warning")) {
[17:42:39.334]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.334]                         if (muffled) 
[17:42:39.334]                           invokeRestart("muffleWarning")
[17:42:39.334]                       }
[17:42:39.334]                       else if (inherits(cond, "condition")) {
[17:42:39.334]                         if (!is.null(pattern)) {
[17:42:39.334]                           computeRestarts <- base::computeRestarts
[17:42:39.334]                           grepl <- base::grepl
[17:42:39.334]                           restarts <- computeRestarts(cond)
[17:42:39.334]                           for (restart in restarts) {
[17:42:39.334]                             name <- restart$name
[17:42:39.334]                             if (is.null(name)) 
[17:42:39.334]                               next
[17:42:39.334]                             if (!grepl(pattern, name)) 
[17:42:39.334]                               next
[17:42:39.334]                             invokeRestart(restart)
[17:42:39.334]                             muffled <- TRUE
[17:42:39.334]                             break
[17:42:39.334]                           }
[17:42:39.334]                         }
[17:42:39.334]                       }
[17:42:39.334]                       invisible(muffled)
[17:42:39.334]                     }
[17:42:39.334]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.334]                   }
[17:42:39.334]                 }
[17:42:39.334]             }
[17:42:39.334]         }))
[17:42:39.334]     }, error = function(ex) {
[17:42:39.334]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.334]                 ...future.rng), started = ...future.startTime, 
[17:42:39.334]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.334]             version = "1.8"), class = "FutureResult")
[17:42:39.334]     }, finally = {
[17:42:39.334]         if (!identical(...future.workdir, getwd())) 
[17:42:39.334]             setwd(...future.workdir)
[17:42:39.334]         {
[17:42:39.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.334]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.334]             }
[17:42:39.334]             base::options(...future.oldOptions)
[17:42:39.334]             if (.Platform$OS.type == "windows") {
[17:42:39.334]                 old_names <- names(...future.oldEnvVars)
[17:42:39.334]                 envs <- base::Sys.getenv()
[17:42:39.334]                 names <- names(envs)
[17:42:39.334]                 common <- intersect(names, old_names)
[17:42:39.334]                 added <- setdiff(names, old_names)
[17:42:39.334]                 removed <- setdiff(old_names, names)
[17:42:39.334]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.334]                   envs[common]]
[17:42:39.334]                 NAMES <- toupper(changed)
[17:42:39.334]                 args <- list()
[17:42:39.334]                 for (kk in seq_along(NAMES)) {
[17:42:39.334]                   name <- changed[[kk]]
[17:42:39.334]                   NAME <- NAMES[[kk]]
[17:42:39.334]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.334]                     next
[17:42:39.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.334]                 }
[17:42:39.334]                 NAMES <- toupper(added)
[17:42:39.334]                 for (kk in seq_along(NAMES)) {
[17:42:39.334]                   name <- added[[kk]]
[17:42:39.334]                   NAME <- NAMES[[kk]]
[17:42:39.334]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.334]                     next
[17:42:39.334]                   args[[name]] <- ""
[17:42:39.334]                 }
[17:42:39.334]                 NAMES <- toupper(removed)
[17:42:39.334]                 for (kk in seq_along(NAMES)) {
[17:42:39.334]                   name <- removed[[kk]]
[17:42:39.334]                   NAME <- NAMES[[kk]]
[17:42:39.334]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.334]                     next
[17:42:39.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.334]                 }
[17:42:39.334]                 if (length(args) > 0) 
[17:42:39.334]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.334]             }
[17:42:39.334]             else {
[17:42:39.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.334]             }
[17:42:39.334]             {
[17:42:39.334]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.334]                   0L) {
[17:42:39.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.334]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.334]                   base::options(opts)
[17:42:39.334]                 }
[17:42:39.334]                 {
[17:42:39.334]                   {
[17:42:39.334]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.334]                     NULL
[17:42:39.334]                   }
[17:42:39.334]                   options(future.plan = NULL)
[17:42:39.334]                   if (is.na(NA_character_)) 
[17:42:39.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.334]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.334]                     envir = parent.frame()) 
[17:42:39.334]                   {
[17:42:39.334]                     default_workers <- missing(workers)
[17:42:39.334]                     if (is.function(workers)) 
[17:42:39.334]                       workers <- workers()
[17:42:39.334]                     workers <- structure(as.integer(workers), 
[17:42:39.334]                       class = class(workers))
[17:42:39.334]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.334]                       1L)
[17:42:39.334]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.334]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.334]                       if (default_workers) 
[17:42:39.334]                         supportsMulticore(warn = TRUE)
[17:42:39.334]                       return(sequential(..., envir = envir))
[17:42:39.334]                     }
[17:42:39.334]                     oopts <- options(mc.cores = workers)
[17:42:39.334]                     on.exit(options(oopts))
[17:42:39.334]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.334]                       envir = envir)
[17:42:39.334]                     if (!future$lazy) 
[17:42:39.334]                       future <- run(future)
[17:42:39.334]                     invisible(future)
[17:42:39.334]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.334]                 }
[17:42:39.334]             }
[17:42:39.334]         }
[17:42:39.334]     })
[17:42:39.334]     if (TRUE) {
[17:42:39.334]         base::sink(type = "output", split = FALSE)
[17:42:39.334]         if (TRUE) {
[17:42:39.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.334]         }
[17:42:39.334]         else {
[17:42:39.334]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.334]         }
[17:42:39.334]         base::close(...future.stdout)
[17:42:39.334]         ...future.stdout <- NULL
[17:42:39.334]     }
[17:42:39.334]     ...future.result$conditions <- ...future.conditions
[17:42:39.334]     ...future.result$finished <- base::Sys.time()
[17:42:39.334]     ...future.result
[17:42:39.334] }
[17:42:39.336] assign_globals() ...
[17:42:39.336] List of 1
[17:42:39.336]  $ x: list()
[17:42:39.336]  - attr(*, "where")=List of 1
[17:42:39.336]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.336]  - attr(*, "resolved")= logi TRUE
[17:42:39.336]  - attr(*, "total_size")= num 0
[17:42:39.336]  - attr(*, "already-done")= logi TRUE
[17:42:39.339] - copied ‘x’ to environment
[17:42:39.339] assign_globals() ... done
[17:42:39.339] requestCore(): workers = 2
[17:42:39.342] MulticoreFuture started
[17:42:39.342] - Launch lazy future ... done
[17:42:39.342] run() for ‘MulticoreFuture’ ... done
[17:42:39.342] plan(): Setting new future strategy stack:
[17:42:39.342] List of future strategies:
[17:42:39.342] 1. sequential:
[17:42:39.342]    - args: function (..., envir = parent.frame())
[17:42:39.342]    - tweaked: FALSE
[17:42:39.342]    - call: NULL
[17:42:39.343] plan(): nbrOfWorkers() = 1
[17:42:39.345] plan(): Setting new future strategy stack:
[17:42:39.345] List of future strategies:
[17:42:39.345] 1. multicore:
[17:42:39.345]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.345]    - tweaked: FALSE
[17:42:39.345]    - call: plan(strategy)
[17:42:39.350] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.358] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.358] Searching for globals...
[17:42:39.361] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.361] Searching for globals ... DONE
[17:42:39.361] Resolving globals: TRUE
[17:42:39.361] Resolving any globals that are futures ...
[17:42:39.361] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.361] Resolving any globals that are futures ... DONE
[17:42:39.362] Resolving futures part of globals (recursively) ...
[17:42:39.362] resolve() on list ...
[17:42:39.362]  recursive: 99
[17:42:39.362]  length: 1
[17:42:39.362]  elements: ‘x’
[17:42:39.363]  length: 0 (resolved future 1)
[17:42:39.363] resolve() on list ... DONE
[17:42:39.363] - globals: [1] ‘x’
[17:42:39.363] Resolving futures part of globals (recursively) ... DONE
[17:42:39.363] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.364] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.364] - globals: [1] ‘x’
[17:42:39.364] 
[17:42:39.364] getGlobalsAndPackages() ... DONE
[17:42:39.364] run() for ‘Future’ ...
[17:42:39.364] - state: ‘created’
[17:42:39.365] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.369] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.369]   - Field: ‘label’
[17:42:39.369]   - Field: ‘local’
[17:42:39.369]   - Field: ‘owner’
[17:42:39.369]   - Field: ‘envir’
[17:42:39.370]   - Field: ‘workers’
[17:42:39.370]   - Field: ‘packages’
[17:42:39.370]   - Field: ‘gc’
[17:42:39.370]   - Field: ‘job’
[17:42:39.370]   - Field: ‘conditions’
[17:42:39.370]   - Field: ‘expr’
[17:42:39.370]   - Field: ‘uuid’
[17:42:39.370]   - Field: ‘seed’
[17:42:39.371]   - Field: ‘version’
[17:42:39.371]   - Field: ‘result’
[17:42:39.371]   - Field: ‘asynchronous’
[17:42:39.371]   - Field: ‘calls’
[17:42:39.371]   - Field: ‘globals’
[17:42:39.371]   - Field: ‘stdout’
[17:42:39.371]   - Field: ‘earlySignal’
[17:42:39.371]   - Field: ‘lazy’
[17:42:39.371]   - Field: ‘state’
[17:42:39.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.372] - Launch lazy future ...
[17:42:39.372] Packages needed by the future expression (n = 0): <none>
[17:42:39.372] Packages needed by future strategies (n = 0): <none>
[17:42:39.373] {
[17:42:39.373]     {
[17:42:39.373]         {
[17:42:39.373]             ...future.startTime <- base::Sys.time()
[17:42:39.373]             {
[17:42:39.373]                 {
[17:42:39.373]                   {
[17:42:39.373]                     {
[17:42:39.373]                       base::local({
[17:42:39.373]                         has_future <- base::requireNamespace("future", 
[17:42:39.373]                           quietly = TRUE)
[17:42:39.373]                         if (has_future) {
[17:42:39.373]                           ns <- base::getNamespace("future")
[17:42:39.373]                           version <- ns[[".package"]][["version"]]
[17:42:39.373]                           if (is.null(version)) 
[17:42:39.373]                             version <- utils::packageVersion("future")
[17:42:39.373]                         }
[17:42:39.373]                         else {
[17:42:39.373]                           version <- NULL
[17:42:39.373]                         }
[17:42:39.373]                         if (!has_future || version < "1.8.0") {
[17:42:39.373]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.373]                             "", base::R.version$version.string), 
[17:42:39.373]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.373]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.373]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.373]                               "release", "version")], collapse = " "), 
[17:42:39.373]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.373]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.373]                             info)
[17:42:39.373]                           info <- base::paste(info, collapse = "; ")
[17:42:39.373]                           if (!has_future) {
[17:42:39.373]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.373]                               info)
[17:42:39.373]                           }
[17:42:39.373]                           else {
[17:42:39.373]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.373]                               info, version)
[17:42:39.373]                           }
[17:42:39.373]                           base::stop(msg)
[17:42:39.373]                         }
[17:42:39.373]                       })
[17:42:39.373]                     }
[17:42:39.373]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.373]                     base::options(mc.cores = 1L)
[17:42:39.373]                   }
[17:42:39.373]                   options(future.plan = NULL)
[17:42:39.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.373]                 }
[17:42:39.373]                 ...future.workdir <- getwd()
[17:42:39.373]             }
[17:42:39.373]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.373]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.373]         }
[17:42:39.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.373]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.373]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.373]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.373]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.373]             base::names(...future.oldOptions))
[17:42:39.373]     }
[17:42:39.373]     if (FALSE) {
[17:42:39.373]     }
[17:42:39.373]     else {
[17:42:39.373]         if (TRUE) {
[17:42:39.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.373]                 open = "w")
[17:42:39.373]         }
[17:42:39.373]         else {
[17:42:39.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.373]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.373]         }
[17:42:39.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.373]             base::sink(type = "output", split = FALSE)
[17:42:39.373]             base::close(...future.stdout)
[17:42:39.373]         }, add = TRUE)
[17:42:39.373]     }
[17:42:39.373]     ...future.frame <- base::sys.nframe()
[17:42:39.373]     ...future.conditions <- base::list()
[17:42:39.373]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.373]     if (FALSE) {
[17:42:39.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.373]     }
[17:42:39.373]     ...future.result <- base::tryCatch({
[17:42:39.373]         base::withCallingHandlers({
[17:42:39.373]             ...future.value <- base::withVisible(base::local({
[17:42:39.373]                 withCallingHandlers({
[17:42:39.373]                   {
[17:42:39.373]                     x$a <- 1
[17:42:39.373]                     x
[17:42:39.373]                   }
[17:42:39.373]                 }, immediateCondition = function(cond) {
[17:42:39.373]                   save_rds <- function (object, pathname, ...) 
[17:42:39.373]                   {
[17:42:39.373]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.373]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.373]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.373]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.373]                         fi_tmp[["mtime"]])
[17:42:39.373]                     }
[17:42:39.373]                     tryCatch({
[17:42:39.373]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.373]                     }, error = function(ex) {
[17:42:39.373]                       msg <- conditionMessage(ex)
[17:42:39.373]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.373]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.373]                         fi_tmp[["mtime"]], msg)
[17:42:39.373]                       ex$message <- msg
[17:42:39.373]                       stop(ex)
[17:42:39.373]                     })
[17:42:39.373]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.373]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.373]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.373]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.373]                       fi <- file.info(pathname)
[17:42:39.373]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.373]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.373]                         fi[["size"]], fi[["mtime"]])
[17:42:39.373]                       stop(msg)
[17:42:39.373]                     }
[17:42:39.373]                     invisible(pathname)
[17:42:39.373]                   }
[17:42:39.373]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.373]                     rootPath = tempdir()) 
[17:42:39.373]                   {
[17:42:39.373]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.373]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.373]                       tmpdir = path, fileext = ".rds")
[17:42:39.373]                     save_rds(obj, file)
[17:42:39.373]                   }
[17:42:39.373]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.373]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.373]                   {
[17:42:39.373]                     inherits <- base::inherits
[17:42:39.373]                     invokeRestart <- base::invokeRestart
[17:42:39.373]                     is.null <- base::is.null
[17:42:39.373]                     muffled <- FALSE
[17:42:39.373]                     if (inherits(cond, "message")) {
[17:42:39.373]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.373]                       if (muffled) 
[17:42:39.373]                         invokeRestart("muffleMessage")
[17:42:39.373]                     }
[17:42:39.373]                     else if (inherits(cond, "warning")) {
[17:42:39.373]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.373]                       if (muffled) 
[17:42:39.373]                         invokeRestart("muffleWarning")
[17:42:39.373]                     }
[17:42:39.373]                     else if (inherits(cond, "condition")) {
[17:42:39.373]                       if (!is.null(pattern)) {
[17:42:39.373]                         computeRestarts <- base::computeRestarts
[17:42:39.373]                         grepl <- base::grepl
[17:42:39.373]                         restarts <- computeRestarts(cond)
[17:42:39.373]                         for (restart in restarts) {
[17:42:39.373]                           name <- restart$name
[17:42:39.373]                           if (is.null(name)) 
[17:42:39.373]                             next
[17:42:39.373]                           if (!grepl(pattern, name)) 
[17:42:39.373]                             next
[17:42:39.373]                           invokeRestart(restart)
[17:42:39.373]                           muffled <- TRUE
[17:42:39.373]                           break
[17:42:39.373]                         }
[17:42:39.373]                       }
[17:42:39.373]                     }
[17:42:39.373]                     invisible(muffled)
[17:42:39.373]                   }
[17:42:39.373]                   muffleCondition(cond)
[17:42:39.373]                 })
[17:42:39.373]             }))
[17:42:39.373]             future::FutureResult(value = ...future.value$value, 
[17:42:39.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.373]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.373]                     ...future.globalenv.names))
[17:42:39.373]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.373]         }, condition = base::local({
[17:42:39.373]             c <- base::c
[17:42:39.373]             inherits <- base::inherits
[17:42:39.373]             invokeRestart <- base::invokeRestart
[17:42:39.373]             length <- base::length
[17:42:39.373]             list <- base::list
[17:42:39.373]             seq.int <- base::seq.int
[17:42:39.373]             signalCondition <- base::signalCondition
[17:42:39.373]             sys.calls <- base::sys.calls
[17:42:39.373]             `[[` <- base::`[[`
[17:42:39.373]             `+` <- base::`+`
[17:42:39.373]             `<<-` <- base::`<<-`
[17:42:39.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.373]                   3L)]
[17:42:39.373]             }
[17:42:39.373]             function(cond) {
[17:42:39.373]                 is_error <- inherits(cond, "error")
[17:42:39.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.373]                   NULL)
[17:42:39.373]                 if (is_error) {
[17:42:39.373]                   sessionInformation <- function() {
[17:42:39.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.373]                       search = base::search(), system = base::Sys.info())
[17:42:39.373]                   }
[17:42:39.373]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.373]                     cond$call), session = sessionInformation(), 
[17:42:39.373]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.373]                   signalCondition(cond)
[17:42:39.373]                 }
[17:42:39.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.373]                 "immediateCondition"))) {
[17:42:39.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.373]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.373]                   if (TRUE && !signal) {
[17:42:39.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.373]                     {
[17:42:39.373]                       inherits <- base::inherits
[17:42:39.373]                       invokeRestart <- base::invokeRestart
[17:42:39.373]                       is.null <- base::is.null
[17:42:39.373]                       muffled <- FALSE
[17:42:39.373]                       if (inherits(cond, "message")) {
[17:42:39.373]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.373]                         if (muffled) 
[17:42:39.373]                           invokeRestart("muffleMessage")
[17:42:39.373]                       }
[17:42:39.373]                       else if (inherits(cond, "warning")) {
[17:42:39.373]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.373]                         if (muffled) 
[17:42:39.373]                           invokeRestart("muffleWarning")
[17:42:39.373]                       }
[17:42:39.373]                       else if (inherits(cond, "condition")) {
[17:42:39.373]                         if (!is.null(pattern)) {
[17:42:39.373]                           computeRestarts <- base::computeRestarts
[17:42:39.373]                           grepl <- base::grepl
[17:42:39.373]                           restarts <- computeRestarts(cond)
[17:42:39.373]                           for (restart in restarts) {
[17:42:39.373]                             name <- restart$name
[17:42:39.373]                             if (is.null(name)) 
[17:42:39.373]                               next
[17:42:39.373]                             if (!grepl(pattern, name)) 
[17:42:39.373]                               next
[17:42:39.373]                             invokeRestart(restart)
[17:42:39.373]                             muffled <- TRUE
[17:42:39.373]                             break
[17:42:39.373]                           }
[17:42:39.373]                         }
[17:42:39.373]                       }
[17:42:39.373]                       invisible(muffled)
[17:42:39.373]                     }
[17:42:39.373]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.373]                   }
[17:42:39.373]                 }
[17:42:39.373]                 else {
[17:42:39.373]                   if (TRUE) {
[17:42:39.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.373]                     {
[17:42:39.373]                       inherits <- base::inherits
[17:42:39.373]                       invokeRestart <- base::invokeRestart
[17:42:39.373]                       is.null <- base::is.null
[17:42:39.373]                       muffled <- FALSE
[17:42:39.373]                       if (inherits(cond, "message")) {
[17:42:39.373]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.373]                         if (muffled) 
[17:42:39.373]                           invokeRestart("muffleMessage")
[17:42:39.373]                       }
[17:42:39.373]                       else if (inherits(cond, "warning")) {
[17:42:39.373]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.373]                         if (muffled) 
[17:42:39.373]                           invokeRestart("muffleWarning")
[17:42:39.373]                       }
[17:42:39.373]                       else if (inherits(cond, "condition")) {
[17:42:39.373]                         if (!is.null(pattern)) {
[17:42:39.373]                           computeRestarts <- base::computeRestarts
[17:42:39.373]                           grepl <- base::grepl
[17:42:39.373]                           restarts <- computeRestarts(cond)
[17:42:39.373]                           for (restart in restarts) {
[17:42:39.373]                             name <- restart$name
[17:42:39.373]                             if (is.null(name)) 
[17:42:39.373]                               next
[17:42:39.373]                             if (!grepl(pattern, name)) 
[17:42:39.373]                               next
[17:42:39.373]                             invokeRestart(restart)
[17:42:39.373]                             muffled <- TRUE
[17:42:39.373]                             break
[17:42:39.373]                           }
[17:42:39.373]                         }
[17:42:39.373]                       }
[17:42:39.373]                       invisible(muffled)
[17:42:39.373]                     }
[17:42:39.373]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.373]                   }
[17:42:39.373]                 }
[17:42:39.373]             }
[17:42:39.373]         }))
[17:42:39.373]     }, error = function(ex) {
[17:42:39.373]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.373]                 ...future.rng), started = ...future.startTime, 
[17:42:39.373]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.373]             version = "1.8"), class = "FutureResult")
[17:42:39.373]     }, finally = {
[17:42:39.373]         if (!identical(...future.workdir, getwd())) 
[17:42:39.373]             setwd(...future.workdir)
[17:42:39.373]         {
[17:42:39.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.373]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.373]             }
[17:42:39.373]             base::options(...future.oldOptions)
[17:42:39.373]             if (.Platform$OS.type == "windows") {
[17:42:39.373]                 old_names <- names(...future.oldEnvVars)
[17:42:39.373]                 envs <- base::Sys.getenv()
[17:42:39.373]                 names <- names(envs)
[17:42:39.373]                 common <- intersect(names, old_names)
[17:42:39.373]                 added <- setdiff(names, old_names)
[17:42:39.373]                 removed <- setdiff(old_names, names)
[17:42:39.373]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.373]                   envs[common]]
[17:42:39.373]                 NAMES <- toupper(changed)
[17:42:39.373]                 args <- list()
[17:42:39.373]                 for (kk in seq_along(NAMES)) {
[17:42:39.373]                   name <- changed[[kk]]
[17:42:39.373]                   NAME <- NAMES[[kk]]
[17:42:39.373]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.373]                     next
[17:42:39.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.373]                 }
[17:42:39.373]                 NAMES <- toupper(added)
[17:42:39.373]                 for (kk in seq_along(NAMES)) {
[17:42:39.373]                   name <- added[[kk]]
[17:42:39.373]                   NAME <- NAMES[[kk]]
[17:42:39.373]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.373]                     next
[17:42:39.373]                   args[[name]] <- ""
[17:42:39.373]                 }
[17:42:39.373]                 NAMES <- toupper(removed)
[17:42:39.373]                 for (kk in seq_along(NAMES)) {
[17:42:39.373]                   name <- removed[[kk]]
[17:42:39.373]                   NAME <- NAMES[[kk]]
[17:42:39.373]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.373]                     next
[17:42:39.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.373]                 }
[17:42:39.373]                 if (length(args) > 0) 
[17:42:39.373]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.373]             }
[17:42:39.373]             else {
[17:42:39.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.373]             }
[17:42:39.373]             {
[17:42:39.373]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.373]                   0L) {
[17:42:39.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.373]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.373]                   base::options(opts)
[17:42:39.373]                 }
[17:42:39.373]                 {
[17:42:39.373]                   {
[17:42:39.373]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.373]                     NULL
[17:42:39.373]                   }
[17:42:39.373]                   options(future.plan = NULL)
[17:42:39.373]                   if (is.na(NA_character_)) 
[17:42:39.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.373]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.373]                     envir = parent.frame()) 
[17:42:39.373]                   {
[17:42:39.373]                     default_workers <- missing(workers)
[17:42:39.373]                     if (is.function(workers)) 
[17:42:39.373]                       workers <- workers()
[17:42:39.373]                     workers <- structure(as.integer(workers), 
[17:42:39.373]                       class = class(workers))
[17:42:39.373]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.373]                       1L)
[17:42:39.373]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.373]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.373]                       if (default_workers) 
[17:42:39.373]                         supportsMulticore(warn = TRUE)
[17:42:39.373]                       return(sequential(..., envir = envir))
[17:42:39.373]                     }
[17:42:39.373]                     oopts <- options(mc.cores = workers)
[17:42:39.373]                     on.exit(options(oopts))
[17:42:39.373]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.373]                       envir = envir)
[17:42:39.373]                     if (!future$lazy) 
[17:42:39.373]                       future <- run(future)
[17:42:39.373]                     invisible(future)
[17:42:39.373]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.373]                 }
[17:42:39.373]             }
[17:42:39.373]         }
[17:42:39.373]     })
[17:42:39.373]     if (TRUE) {
[17:42:39.373]         base::sink(type = "output", split = FALSE)
[17:42:39.373]         if (TRUE) {
[17:42:39.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.373]         }
[17:42:39.373]         else {
[17:42:39.373]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.373]         }
[17:42:39.373]         base::close(...future.stdout)
[17:42:39.373]         ...future.stdout <- NULL
[17:42:39.373]     }
[17:42:39.373]     ...future.result$conditions <- ...future.conditions
[17:42:39.373]     ...future.result$finished <- base::Sys.time()
[17:42:39.373]     ...future.result
[17:42:39.373] }
[17:42:39.375] assign_globals() ...
[17:42:39.375] List of 1
[17:42:39.375]  $ x: list()
[17:42:39.375]  - attr(*, "where")=List of 1
[17:42:39.375]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.375]  - attr(*, "resolved")= logi TRUE
[17:42:39.375]  - attr(*, "total_size")= num 0
[17:42:39.375]  - attr(*, "already-done")= logi TRUE
[17:42:39.378] - copied ‘x’ to environment
[17:42:39.378] assign_globals() ... done
[17:42:39.378] requestCore(): workers = 2
[17:42:39.380] MulticoreFuture started
[17:42:39.381] - Launch lazy future ... done
[17:42:39.381] run() for ‘MulticoreFuture’ ... done
[17:42:39.381] plan(): Setting new future strategy stack:
[17:42:39.382] List of future strategies:
[17:42:39.382] 1. sequential:
[17:42:39.382]    - args: function (..., envir = parent.frame())
[17:42:39.382]    - tweaked: FALSE
[17:42:39.382]    - call: NULL
[17:42:39.382] plan(): nbrOfWorkers() = 1
[17:42:39.384] plan(): Setting new future strategy stack:
[17:42:39.385] List of future strategies:
[17:42:39.385] 1. multicore:
[17:42:39.385]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.385]    - tweaked: FALSE
[17:42:39.385]    - call: plan(strategy)
[17:42:39.390] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.391] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.391] Searching for globals...
[17:42:39.394] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.394] Searching for globals ... DONE
[17:42:39.394] Resolving globals: TRUE
[17:42:39.395] Resolving any globals that are futures ...
[17:42:39.395] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.395] Resolving any globals that are futures ... DONE
[17:42:39.395] Resolving futures part of globals (recursively) ...
[17:42:39.396] resolve() on list ...
[17:42:39.396]  recursive: 99
[17:42:39.396]  length: 1
[17:42:39.396]  elements: ‘x’
[17:42:39.396]  length: 0 (resolved future 1)
[17:42:39.396] resolve() on list ... DONE
[17:42:39.396] - globals: [1] ‘x’
[17:42:39.397] Resolving futures part of globals (recursively) ... DONE
[17:42:39.397] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.397] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.397] - globals: [1] ‘x’
[17:42:39.397] 
[17:42:39.398] getGlobalsAndPackages() ... DONE
[17:42:39.398] run() for ‘Future’ ...
[17:42:39.398] - state: ‘created’
[17:42:39.398] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.403] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.403] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.403]   - Field: ‘label’
[17:42:39.403]   - Field: ‘local’
[17:42:39.404]   - Field: ‘owner’
[17:42:39.404]   - Field: ‘envir’
[17:42:39.404]   - Field: ‘workers’
[17:42:39.404]   - Field: ‘packages’
[17:42:39.404]   - Field: ‘gc’
[17:42:39.404]   - Field: ‘job’
[17:42:39.404]   - Field: ‘conditions’
[17:42:39.407]   - Field: ‘expr’
[17:42:39.407]   - Field: ‘uuid’
[17:42:39.407]   - Field: ‘seed’
[17:42:39.407]   - Field: ‘version’
[17:42:39.407]   - Field: ‘result’
[17:42:39.407]   - Field: ‘asynchronous’
[17:42:39.407]   - Field: ‘calls’
[17:42:39.407]   - Field: ‘globals’
[17:42:39.408]   - Field: ‘stdout’
[17:42:39.408]   - Field: ‘earlySignal’
[17:42:39.408]   - Field: ‘lazy’
[17:42:39.408]   - Field: ‘state’
[17:42:39.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.408] - Launch lazy future ...
[17:42:39.409] Packages needed by the future expression (n = 0): <none>
[17:42:39.409] Packages needed by future strategies (n = 0): <none>
[17:42:39.410] {
[17:42:39.410]     {
[17:42:39.410]         {
[17:42:39.410]             ...future.startTime <- base::Sys.time()
[17:42:39.410]             {
[17:42:39.410]                 {
[17:42:39.410]                   {
[17:42:39.410]                     {
[17:42:39.410]                       base::local({
[17:42:39.410]                         has_future <- base::requireNamespace("future", 
[17:42:39.410]                           quietly = TRUE)
[17:42:39.410]                         if (has_future) {
[17:42:39.410]                           ns <- base::getNamespace("future")
[17:42:39.410]                           version <- ns[[".package"]][["version"]]
[17:42:39.410]                           if (is.null(version)) 
[17:42:39.410]                             version <- utils::packageVersion("future")
[17:42:39.410]                         }
[17:42:39.410]                         else {
[17:42:39.410]                           version <- NULL
[17:42:39.410]                         }
[17:42:39.410]                         if (!has_future || version < "1.8.0") {
[17:42:39.410]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.410]                             "", base::R.version$version.string), 
[17:42:39.410]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.410]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.410]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.410]                               "release", "version")], collapse = " "), 
[17:42:39.410]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.410]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.410]                             info)
[17:42:39.410]                           info <- base::paste(info, collapse = "; ")
[17:42:39.410]                           if (!has_future) {
[17:42:39.410]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.410]                               info)
[17:42:39.410]                           }
[17:42:39.410]                           else {
[17:42:39.410]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.410]                               info, version)
[17:42:39.410]                           }
[17:42:39.410]                           base::stop(msg)
[17:42:39.410]                         }
[17:42:39.410]                       })
[17:42:39.410]                     }
[17:42:39.410]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.410]                     base::options(mc.cores = 1L)
[17:42:39.410]                   }
[17:42:39.410]                   options(future.plan = NULL)
[17:42:39.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.410]                 }
[17:42:39.410]                 ...future.workdir <- getwd()
[17:42:39.410]             }
[17:42:39.410]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.410]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.410]         }
[17:42:39.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.410]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.410]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.410]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.410]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.410]             base::names(...future.oldOptions))
[17:42:39.410]     }
[17:42:39.410]     if (FALSE) {
[17:42:39.410]     }
[17:42:39.410]     else {
[17:42:39.410]         if (TRUE) {
[17:42:39.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.410]                 open = "w")
[17:42:39.410]         }
[17:42:39.410]         else {
[17:42:39.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.410]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.410]         }
[17:42:39.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.410]             base::sink(type = "output", split = FALSE)
[17:42:39.410]             base::close(...future.stdout)
[17:42:39.410]         }, add = TRUE)
[17:42:39.410]     }
[17:42:39.410]     ...future.frame <- base::sys.nframe()
[17:42:39.410]     ...future.conditions <- base::list()
[17:42:39.410]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.410]     if (FALSE) {
[17:42:39.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.410]     }
[17:42:39.410]     ...future.result <- base::tryCatch({
[17:42:39.410]         base::withCallingHandlers({
[17:42:39.410]             ...future.value <- base::withVisible(base::local({
[17:42:39.410]                 withCallingHandlers({
[17:42:39.410]                   {
[17:42:39.410]                     x$a <- 1
[17:42:39.410]                     x
[17:42:39.410]                   }
[17:42:39.410]                 }, immediateCondition = function(cond) {
[17:42:39.410]                   save_rds <- function (object, pathname, ...) 
[17:42:39.410]                   {
[17:42:39.410]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.410]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.410]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.410]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.410]                         fi_tmp[["mtime"]])
[17:42:39.410]                     }
[17:42:39.410]                     tryCatch({
[17:42:39.410]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.410]                     }, error = function(ex) {
[17:42:39.410]                       msg <- conditionMessage(ex)
[17:42:39.410]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.410]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.410]                         fi_tmp[["mtime"]], msg)
[17:42:39.410]                       ex$message <- msg
[17:42:39.410]                       stop(ex)
[17:42:39.410]                     })
[17:42:39.410]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.410]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.410]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.410]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.410]                       fi <- file.info(pathname)
[17:42:39.410]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.410]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.410]                         fi[["size"]], fi[["mtime"]])
[17:42:39.410]                       stop(msg)
[17:42:39.410]                     }
[17:42:39.410]                     invisible(pathname)
[17:42:39.410]                   }
[17:42:39.410]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.410]                     rootPath = tempdir()) 
[17:42:39.410]                   {
[17:42:39.410]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.410]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.410]                       tmpdir = path, fileext = ".rds")
[17:42:39.410]                     save_rds(obj, file)
[17:42:39.410]                   }
[17:42:39.410]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.410]                   {
[17:42:39.410]                     inherits <- base::inherits
[17:42:39.410]                     invokeRestart <- base::invokeRestart
[17:42:39.410]                     is.null <- base::is.null
[17:42:39.410]                     muffled <- FALSE
[17:42:39.410]                     if (inherits(cond, "message")) {
[17:42:39.410]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.410]                       if (muffled) 
[17:42:39.410]                         invokeRestart("muffleMessage")
[17:42:39.410]                     }
[17:42:39.410]                     else if (inherits(cond, "warning")) {
[17:42:39.410]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.410]                       if (muffled) 
[17:42:39.410]                         invokeRestart("muffleWarning")
[17:42:39.410]                     }
[17:42:39.410]                     else if (inherits(cond, "condition")) {
[17:42:39.410]                       if (!is.null(pattern)) {
[17:42:39.410]                         computeRestarts <- base::computeRestarts
[17:42:39.410]                         grepl <- base::grepl
[17:42:39.410]                         restarts <- computeRestarts(cond)
[17:42:39.410]                         for (restart in restarts) {
[17:42:39.410]                           name <- restart$name
[17:42:39.410]                           if (is.null(name)) 
[17:42:39.410]                             next
[17:42:39.410]                           if (!grepl(pattern, name)) 
[17:42:39.410]                             next
[17:42:39.410]                           invokeRestart(restart)
[17:42:39.410]                           muffled <- TRUE
[17:42:39.410]                           break
[17:42:39.410]                         }
[17:42:39.410]                       }
[17:42:39.410]                     }
[17:42:39.410]                     invisible(muffled)
[17:42:39.410]                   }
[17:42:39.410]                   muffleCondition(cond)
[17:42:39.410]                 })
[17:42:39.410]             }))
[17:42:39.410]             future::FutureResult(value = ...future.value$value, 
[17:42:39.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.410]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.410]                     ...future.globalenv.names))
[17:42:39.410]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.410]         }, condition = base::local({
[17:42:39.410]             c <- base::c
[17:42:39.410]             inherits <- base::inherits
[17:42:39.410]             invokeRestart <- base::invokeRestart
[17:42:39.410]             length <- base::length
[17:42:39.410]             list <- base::list
[17:42:39.410]             seq.int <- base::seq.int
[17:42:39.410]             signalCondition <- base::signalCondition
[17:42:39.410]             sys.calls <- base::sys.calls
[17:42:39.410]             `[[` <- base::`[[`
[17:42:39.410]             `+` <- base::`+`
[17:42:39.410]             `<<-` <- base::`<<-`
[17:42:39.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.410]                   3L)]
[17:42:39.410]             }
[17:42:39.410]             function(cond) {
[17:42:39.410]                 is_error <- inherits(cond, "error")
[17:42:39.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.410]                   NULL)
[17:42:39.410]                 if (is_error) {
[17:42:39.410]                   sessionInformation <- function() {
[17:42:39.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.410]                       search = base::search(), system = base::Sys.info())
[17:42:39.410]                   }
[17:42:39.410]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.410]                     cond$call), session = sessionInformation(), 
[17:42:39.410]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.410]                   signalCondition(cond)
[17:42:39.410]                 }
[17:42:39.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.410]                 "immediateCondition"))) {
[17:42:39.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.410]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.410]                   if (TRUE && !signal) {
[17:42:39.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.410]                     {
[17:42:39.410]                       inherits <- base::inherits
[17:42:39.410]                       invokeRestart <- base::invokeRestart
[17:42:39.410]                       is.null <- base::is.null
[17:42:39.410]                       muffled <- FALSE
[17:42:39.410]                       if (inherits(cond, "message")) {
[17:42:39.410]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.410]                         if (muffled) 
[17:42:39.410]                           invokeRestart("muffleMessage")
[17:42:39.410]                       }
[17:42:39.410]                       else if (inherits(cond, "warning")) {
[17:42:39.410]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.410]                         if (muffled) 
[17:42:39.410]                           invokeRestart("muffleWarning")
[17:42:39.410]                       }
[17:42:39.410]                       else if (inherits(cond, "condition")) {
[17:42:39.410]                         if (!is.null(pattern)) {
[17:42:39.410]                           computeRestarts <- base::computeRestarts
[17:42:39.410]                           grepl <- base::grepl
[17:42:39.410]                           restarts <- computeRestarts(cond)
[17:42:39.410]                           for (restart in restarts) {
[17:42:39.410]                             name <- restart$name
[17:42:39.410]                             if (is.null(name)) 
[17:42:39.410]                               next
[17:42:39.410]                             if (!grepl(pattern, name)) 
[17:42:39.410]                               next
[17:42:39.410]                             invokeRestart(restart)
[17:42:39.410]                             muffled <- TRUE
[17:42:39.410]                             break
[17:42:39.410]                           }
[17:42:39.410]                         }
[17:42:39.410]                       }
[17:42:39.410]                       invisible(muffled)
[17:42:39.410]                     }
[17:42:39.410]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.410]                   }
[17:42:39.410]                 }
[17:42:39.410]                 else {
[17:42:39.410]                   if (TRUE) {
[17:42:39.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.410]                     {
[17:42:39.410]                       inherits <- base::inherits
[17:42:39.410]                       invokeRestart <- base::invokeRestart
[17:42:39.410]                       is.null <- base::is.null
[17:42:39.410]                       muffled <- FALSE
[17:42:39.410]                       if (inherits(cond, "message")) {
[17:42:39.410]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.410]                         if (muffled) 
[17:42:39.410]                           invokeRestart("muffleMessage")
[17:42:39.410]                       }
[17:42:39.410]                       else if (inherits(cond, "warning")) {
[17:42:39.410]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.410]                         if (muffled) 
[17:42:39.410]                           invokeRestart("muffleWarning")
[17:42:39.410]                       }
[17:42:39.410]                       else if (inherits(cond, "condition")) {
[17:42:39.410]                         if (!is.null(pattern)) {
[17:42:39.410]                           computeRestarts <- base::computeRestarts
[17:42:39.410]                           grepl <- base::grepl
[17:42:39.410]                           restarts <- computeRestarts(cond)
[17:42:39.410]                           for (restart in restarts) {
[17:42:39.410]                             name <- restart$name
[17:42:39.410]                             if (is.null(name)) 
[17:42:39.410]                               next
[17:42:39.410]                             if (!grepl(pattern, name)) 
[17:42:39.410]                               next
[17:42:39.410]                             invokeRestart(restart)
[17:42:39.410]                             muffled <- TRUE
[17:42:39.410]                             break
[17:42:39.410]                           }
[17:42:39.410]                         }
[17:42:39.410]                       }
[17:42:39.410]                       invisible(muffled)
[17:42:39.410]                     }
[17:42:39.410]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.410]                   }
[17:42:39.410]                 }
[17:42:39.410]             }
[17:42:39.410]         }))
[17:42:39.410]     }, error = function(ex) {
[17:42:39.410]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.410]                 ...future.rng), started = ...future.startTime, 
[17:42:39.410]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.410]             version = "1.8"), class = "FutureResult")
[17:42:39.410]     }, finally = {
[17:42:39.410]         if (!identical(...future.workdir, getwd())) 
[17:42:39.410]             setwd(...future.workdir)
[17:42:39.410]         {
[17:42:39.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.410]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.410]             }
[17:42:39.410]             base::options(...future.oldOptions)
[17:42:39.410]             if (.Platform$OS.type == "windows") {
[17:42:39.410]                 old_names <- names(...future.oldEnvVars)
[17:42:39.410]                 envs <- base::Sys.getenv()
[17:42:39.410]                 names <- names(envs)
[17:42:39.410]                 common <- intersect(names, old_names)
[17:42:39.410]                 added <- setdiff(names, old_names)
[17:42:39.410]                 removed <- setdiff(old_names, names)
[17:42:39.410]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.410]                   envs[common]]
[17:42:39.410]                 NAMES <- toupper(changed)
[17:42:39.410]                 args <- list()
[17:42:39.410]                 for (kk in seq_along(NAMES)) {
[17:42:39.410]                   name <- changed[[kk]]
[17:42:39.410]                   NAME <- NAMES[[kk]]
[17:42:39.410]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.410]                     next
[17:42:39.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.410]                 }
[17:42:39.410]                 NAMES <- toupper(added)
[17:42:39.410]                 for (kk in seq_along(NAMES)) {
[17:42:39.410]                   name <- added[[kk]]
[17:42:39.410]                   NAME <- NAMES[[kk]]
[17:42:39.410]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.410]                     next
[17:42:39.410]                   args[[name]] <- ""
[17:42:39.410]                 }
[17:42:39.410]                 NAMES <- toupper(removed)
[17:42:39.410]                 for (kk in seq_along(NAMES)) {
[17:42:39.410]                   name <- removed[[kk]]
[17:42:39.410]                   NAME <- NAMES[[kk]]
[17:42:39.410]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.410]                     next
[17:42:39.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.410]                 }
[17:42:39.410]                 if (length(args) > 0) 
[17:42:39.410]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.410]             }
[17:42:39.410]             else {
[17:42:39.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.410]             }
[17:42:39.410]             {
[17:42:39.410]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.410]                   0L) {
[17:42:39.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.410]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.410]                   base::options(opts)
[17:42:39.410]                 }
[17:42:39.410]                 {
[17:42:39.410]                   {
[17:42:39.410]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.410]                     NULL
[17:42:39.410]                   }
[17:42:39.410]                   options(future.plan = NULL)
[17:42:39.410]                   if (is.na(NA_character_)) 
[17:42:39.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.410]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.410]                     envir = parent.frame()) 
[17:42:39.410]                   {
[17:42:39.410]                     default_workers <- missing(workers)
[17:42:39.410]                     if (is.function(workers)) 
[17:42:39.410]                       workers <- workers()
[17:42:39.410]                     workers <- structure(as.integer(workers), 
[17:42:39.410]                       class = class(workers))
[17:42:39.410]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.410]                       1L)
[17:42:39.410]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.410]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.410]                       if (default_workers) 
[17:42:39.410]                         supportsMulticore(warn = TRUE)
[17:42:39.410]                       return(sequential(..., envir = envir))
[17:42:39.410]                     }
[17:42:39.410]                     oopts <- options(mc.cores = workers)
[17:42:39.410]                     on.exit(options(oopts))
[17:42:39.410]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.410]                       envir = envir)
[17:42:39.410]                     if (!future$lazy) 
[17:42:39.410]                       future <- run(future)
[17:42:39.410]                     invisible(future)
[17:42:39.410]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.410]                 }
[17:42:39.410]             }
[17:42:39.410]         }
[17:42:39.410]     })
[17:42:39.410]     if (TRUE) {
[17:42:39.410]         base::sink(type = "output", split = FALSE)
[17:42:39.410]         if (TRUE) {
[17:42:39.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.410]         }
[17:42:39.410]         else {
[17:42:39.410]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.410]         }
[17:42:39.410]         base::close(...future.stdout)
[17:42:39.410]         ...future.stdout <- NULL
[17:42:39.410]     }
[17:42:39.410]     ...future.result$conditions <- ...future.conditions
[17:42:39.410]     ...future.result$finished <- base::Sys.time()
[17:42:39.410]     ...future.result
[17:42:39.410] }
[17:42:39.412] assign_globals() ...
[17:42:39.412] List of 1
[17:42:39.412]  $ x: list()
[17:42:39.412]  - attr(*, "where")=List of 1
[17:42:39.412]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.412]  - attr(*, "resolved")= logi TRUE
[17:42:39.412]  - attr(*, "total_size")= num 0
[17:42:39.412]  - attr(*, "already-done")= logi TRUE
[17:42:39.415] - copied ‘x’ to environment
[17:42:39.415] assign_globals() ... done
[17:42:39.416] requestCore(): workers = 2
[17:42:39.418] MulticoreFuture started
[17:42:39.418] - Launch lazy future ... done
[17:42:39.418] run() for ‘MulticoreFuture’ ... done
[17:42:39.419] plan(): Setting new future strategy stack:
[17:42:39.419] List of future strategies:
[17:42:39.419] 1. sequential:
[17:42:39.419]    - args: function (..., envir = parent.frame())
[17:42:39.419]    - tweaked: FALSE
[17:42:39.419]    - call: NULL
[17:42:39.420] plan(): nbrOfWorkers() = 1
[17:42:39.422] plan(): Setting new future strategy stack:
[17:42:39.422] List of future strategies:
[17:42:39.422] 1. multicore:
[17:42:39.422]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.422]    - tweaked: FALSE
[17:42:39.422]    - call: plan(strategy)
[17:42:39.427] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.429] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.429] Searching for globals...
[17:42:39.432] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.432] Searching for globals ... DONE
[17:42:39.432] Resolving globals: TRUE
[17:42:39.433] Resolving any globals that are futures ...
[17:42:39.433] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:39.433] Resolving any globals that are futures ... DONE
[17:42:39.433] Resolving futures part of globals (recursively) ...
[17:42:39.434] resolve() on list ...
[17:42:39.434]  recursive: 99
[17:42:39.434]  length: 1
[17:42:39.434]  elements: ‘x’
[17:42:39.434]  length: 0 (resolved future 1)
[17:42:39.434] resolve() on list ... DONE
[17:42:39.434] - globals: [1] ‘x’
[17:42:39.435] Resolving futures part of globals (recursively) ... DONE
[17:42:39.435] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.435] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.435] - globals: [1] ‘x’
[17:42:39.436] 
[17:42:39.436] getGlobalsAndPackages() ... DONE
[17:42:39.436] run() for ‘Future’ ...
[17:42:39.436] - state: ‘created’
[17:42:39.436] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.441] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.441] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.441]   - Field: ‘label’
[17:42:39.441]   - Field: ‘local’
[17:42:39.441]   - Field: ‘owner’
[17:42:39.441]   - Field: ‘envir’
[17:42:39.442]   - Field: ‘workers’
[17:42:39.442]   - Field: ‘packages’
[17:42:39.442]   - Field: ‘gc’
[17:42:39.442]   - Field: ‘job’
[17:42:39.442]   - Field: ‘conditions’
[17:42:39.442]   - Field: ‘expr’
[17:42:39.442]   - Field: ‘uuid’
[17:42:39.442]   - Field: ‘seed’
[17:42:39.442]   - Field: ‘version’
[17:42:39.443]   - Field: ‘result’
[17:42:39.443]   - Field: ‘asynchronous’
[17:42:39.443]   - Field: ‘calls’
[17:42:39.443]   - Field: ‘globals’
[17:42:39.443]   - Field: ‘stdout’
[17:42:39.443]   - Field: ‘earlySignal’
[17:42:39.443]   - Field: ‘lazy’
[17:42:39.443]   - Field: ‘state’
[17:42:39.443] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.444] - Launch lazy future ...
[17:42:39.444] Packages needed by the future expression (n = 0): <none>
[17:42:39.444] Packages needed by future strategies (n = 0): <none>
[17:42:39.445] {
[17:42:39.445]     {
[17:42:39.445]         {
[17:42:39.445]             ...future.startTime <- base::Sys.time()
[17:42:39.445]             {
[17:42:39.445]                 {
[17:42:39.445]                   {
[17:42:39.445]                     {
[17:42:39.445]                       base::local({
[17:42:39.445]                         has_future <- base::requireNamespace("future", 
[17:42:39.445]                           quietly = TRUE)
[17:42:39.445]                         if (has_future) {
[17:42:39.445]                           ns <- base::getNamespace("future")
[17:42:39.445]                           version <- ns[[".package"]][["version"]]
[17:42:39.445]                           if (is.null(version)) 
[17:42:39.445]                             version <- utils::packageVersion("future")
[17:42:39.445]                         }
[17:42:39.445]                         else {
[17:42:39.445]                           version <- NULL
[17:42:39.445]                         }
[17:42:39.445]                         if (!has_future || version < "1.8.0") {
[17:42:39.445]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.445]                             "", base::R.version$version.string), 
[17:42:39.445]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.445]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.445]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.445]                               "release", "version")], collapse = " "), 
[17:42:39.445]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.445]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.445]                             info)
[17:42:39.445]                           info <- base::paste(info, collapse = "; ")
[17:42:39.445]                           if (!has_future) {
[17:42:39.445]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.445]                               info)
[17:42:39.445]                           }
[17:42:39.445]                           else {
[17:42:39.445]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.445]                               info, version)
[17:42:39.445]                           }
[17:42:39.445]                           base::stop(msg)
[17:42:39.445]                         }
[17:42:39.445]                       })
[17:42:39.445]                     }
[17:42:39.445]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.445]                     base::options(mc.cores = 1L)
[17:42:39.445]                   }
[17:42:39.445]                   options(future.plan = NULL)
[17:42:39.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.445]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.445]                 }
[17:42:39.445]                 ...future.workdir <- getwd()
[17:42:39.445]             }
[17:42:39.445]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.445]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.445]         }
[17:42:39.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.445]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.445]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.445]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.445]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.445]             base::names(...future.oldOptions))
[17:42:39.445]     }
[17:42:39.445]     if (FALSE) {
[17:42:39.445]     }
[17:42:39.445]     else {
[17:42:39.445]         if (TRUE) {
[17:42:39.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.445]                 open = "w")
[17:42:39.445]         }
[17:42:39.445]         else {
[17:42:39.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.445]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.445]         }
[17:42:39.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.445]             base::sink(type = "output", split = FALSE)
[17:42:39.445]             base::close(...future.stdout)
[17:42:39.445]         }, add = TRUE)
[17:42:39.445]     }
[17:42:39.445]     ...future.frame <- base::sys.nframe()
[17:42:39.445]     ...future.conditions <- base::list()
[17:42:39.445]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.445]     if (FALSE) {
[17:42:39.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.445]     }
[17:42:39.445]     ...future.result <- base::tryCatch({
[17:42:39.445]         base::withCallingHandlers({
[17:42:39.445]             ...future.value <- base::withVisible(base::local({
[17:42:39.445]                 withCallingHandlers({
[17:42:39.445]                   {
[17:42:39.445]                     x$a <- 1
[17:42:39.445]                     x
[17:42:39.445]                   }
[17:42:39.445]                 }, immediateCondition = function(cond) {
[17:42:39.445]                   save_rds <- function (object, pathname, ...) 
[17:42:39.445]                   {
[17:42:39.445]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.445]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.445]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.445]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.445]                         fi_tmp[["mtime"]])
[17:42:39.445]                     }
[17:42:39.445]                     tryCatch({
[17:42:39.445]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.445]                     }, error = function(ex) {
[17:42:39.445]                       msg <- conditionMessage(ex)
[17:42:39.445]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.445]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.445]                         fi_tmp[["mtime"]], msg)
[17:42:39.445]                       ex$message <- msg
[17:42:39.445]                       stop(ex)
[17:42:39.445]                     })
[17:42:39.445]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.445]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.445]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.445]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.445]                       fi <- file.info(pathname)
[17:42:39.445]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.445]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.445]                         fi[["size"]], fi[["mtime"]])
[17:42:39.445]                       stop(msg)
[17:42:39.445]                     }
[17:42:39.445]                     invisible(pathname)
[17:42:39.445]                   }
[17:42:39.445]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.445]                     rootPath = tempdir()) 
[17:42:39.445]                   {
[17:42:39.445]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.445]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.445]                       tmpdir = path, fileext = ".rds")
[17:42:39.445]                     save_rds(obj, file)
[17:42:39.445]                   }
[17:42:39.445]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.445]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.445]                   {
[17:42:39.445]                     inherits <- base::inherits
[17:42:39.445]                     invokeRestart <- base::invokeRestart
[17:42:39.445]                     is.null <- base::is.null
[17:42:39.445]                     muffled <- FALSE
[17:42:39.445]                     if (inherits(cond, "message")) {
[17:42:39.445]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.445]                       if (muffled) 
[17:42:39.445]                         invokeRestart("muffleMessage")
[17:42:39.445]                     }
[17:42:39.445]                     else if (inherits(cond, "warning")) {
[17:42:39.445]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.445]                       if (muffled) 
[17:42:39.445]                         invokeRestart("muffleWarning")
[17:42:39.445]                     }
[17:42:39.445]                     else if (inherits(cond, "condition")) {
[17:42:39.445]                       if (!is.null(pattern)) {
[17:42:39.445]                         computeRestarts <- base::computeRestarts
[17:42:39.445]                         grepl <- base::grepl
[17:42:39.445]                         restarts <- computeRestarts(cond)
[17:42:39.445]                         for (restart in restarts) {
[17:42:39.445]                           name <- restart$name
[17:42:39.445]                           if (is.null(name)) 
[17:42:39.445]                             next
[17:42:39.445]                           if (!grepl(pattern, name)) 
[17:42:39.445]                             next
[17:42:39.445]                           invokeRestart(restart)
[17:42:39.445]                           muffled <- TRUE
[17:42:39.445]                           break
[17:42:39.445]                         }
[17:42:39.445]                       }
[17:42:39.445]                     }
[17:42:39.445]                     invisible(muffled)
[17:42:39.445]                   }
[17:42:39.445]                   muffleCondition(cond)
[17:42:39.445]                 })
[17:42:39.445]             }))
[17:42:39.445]             future::FutureResult(value = ...future.value$value, 
[17:42:39.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.445]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.445]                     ...future.globalenv.names))
[17:42:39.445]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.445]         }, condition = base::local({
[17:42:39.445]             c <- base::c
[17:42:39.445]             inherits <- base::inherits
[17:42:39.445]             invokeRestart <- base::invokeRestart
[17:42:39.445]             length <- base::length
[17:42:39.445]             list <- base::list
[17:42:39.445]             seq.int <- base::seq.int
[17:42:39.445]             signalCondition <- base::signalCondition
[17:42:39.445]             sys.calls <- base::sys.calls
[17:42:39.445]             `[[` <- base::`[[`
[17:42:39.445]             `+` <- base::`+`
[17:42:39.445]             `<<-` <- base::`<<-`
[17:42:39.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.445]                   3L)]
[17:42:39.445]             }
[17:42:39.445]             function(cond) {
[17:42:39.445]                 is_error <- inherits(cond, "error")
[17:42:39.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.445]                   NULL)
[17:42:39.445]                 if (is_error) {
[17:42:39.445]                   sessionInformation <- function() {
[17:42:39.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.445]                       search = base::search(), system = base::Sys.info())
[17:42:39.445]                   }
[17:42:39.445]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.445]                     cond$call), session = sessionInformation(), 
[17:42:39.445]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.445]                   signalCondition(cond)
[17:42:39.445]                 }
[17:42:39.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.445]                 "immediateCondition"))) {
[17:42:39.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.445]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.445]                   if (TRUE && !signal) {
[17:42:39.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.445]                     {
[17:42:39.445]                       inherits <- base::inherits
[17:42:39.445]                       invokeRestart <- base::invokeRestart
[17:42:39.445]                       is.null <- base::is.null
[17:42:39.445]                       muffled <- FALSE
[17:42:39.445]                       if (inherits(cond, "message")) {
[17:42:39.445]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.445]                         if (muffled) 
[17:42:39.445]                           invokeRestart("muffleMessage")
[17:42:39.445]                       }
[17:42:39.445]                       else if (inherits(cond, "warning")) {
[17:42:39.445]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.445]                         if (muffled) 
[17:42:39.445]                           invokeRestart("muffleWarning")
[17:42:39.445]                       }
[17:42:39.445]                       else if (inherits(cond, "condition")) {
[17:42:39.445]                         if (!is.null(pattern)) {
[17:42:39.445]                           computeRestarts <- base::computeRestarts
[17:42:39.445]                           grepl <- base::grepl
[17:42:39.445]                           restarts <- computeRestarts(cond)
[17:42:39.445]                           for (restart in restarts) {
[17:42:39.445]                             name <- restart$name
[17:42:39.445]                             if (is.null(name)) 
[17:42:39.445]                               next
[17:42:39.445]                             if (!grepl(pattern, name)) 
[17:42:39.445]                               next
[17:42:39.445]                             invokeRestart(restart)
[17:42:39.445]                             muffled <- TRUE
[17:42:39.445]                             break
[17:42:39.445]                           }
[17:42:39.445]                         }
[17:42:39.445]                       }
[17:42:39.445]                       invisible(muffled)
[17:42:39.445]                     }
[17:42:39.445]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.445]                   }
[17:42:39.445]                 }
[17:42:39.445]                 else {
[17:42:39.445]                   if (TRUE) {
[17:42:39.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.445]                     {
[17:42:39.445]                       inherits <- base::inherits
[17:42:39.445]                       invokeRestart <- base::invokeRestart
[17:42:39.445]                       is.null <- base::is.null
[17:42:39.445]                       muffled <- FALSE
[17:42:39.445]                       if (inherits(cond, "message")) {
[17:42:39.445]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.445]                         if (muffled) 
[17:42:39.445]                           invokeRestart("muffleMessage")
[17:42:39.445]                       }
[17:42:39.445]                       else if (inherits(cond, "warning")) {
[17:42:39.445]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.445]                         if (muffled) 
[17:42:39.445]                           invokeRestart("muffleWarning")
[17:42:39.445]                       }
[17:42:39.445]                       else if (inherits(cond, "condition")) {
[17:42:39.445]                         if (!is.null(pattern)) {
[17:42:39.445]                           computeRestarts <- base::computeRestarts
[17:42:39.445]                           grepl <- base::grepl
[17:42:39.445]                           restarts <- computeRestarts(cond)
[17:42:39.445]                           for (restart in restarts) {
[17:42:39.445]                             name <- restart$name
[17:42:39.445]                             if (is.null(name)) 
[17:42:39.445]                               next
[17:42:39.445]                             if (!grepl(pattern, name)) 
[17:42:39.445]                               next
[17:42:39.445]                             invokeRestart(restart)
[17:42:39.445]                             muffled <- TRUE
[17:42:39.445]                             break
[17:42:39.445]                           }
[17:42:39.445]                         }
[17:42:39.445]                       }
[17:42:39.445]                       invisible(muffled)
[17:42:39.445]                     }
[17:42:39.445]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.445]                   }
[17:42:39.445]                 }
[17:42:39.445]             }
[17:42:39.445]         }))
[17:42:39.445]     }, error = function(ex) {
[17:42:39.445]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.445]                 ...future.rng), started = ...future.startTime, 
[17:42:39.445]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.445]             version = "1.8"), class = "FutureResult")
[17:42:39.445]     }, finally = {
[17:42:39.445]         if (!identical(...future.workdir, getwd())) 
[17:42:39.445]             setwd(...future.workdir)
[17:42:39.445]         {
[17:42:39.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.445]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.445]             }
[17:42:39.445]             base::options(...future.oldOptions)
[17:42:39.445]             if (.Platform$OS.type == "windows") {
[17:42:39.445]                 old_names <- names(...future.oldEnvVars)
[17:42:39.445]                 envs <- base::Sys.getenv()
[17:42:39.445]                 names <- names(envs)
[17:42:39.445]                 common <- intersect(names, old_names)
[17:42:39.445]                 added <- setdiff(names, old_names)
[17:42:39.445]                 removed <- setdiff(old_names, names)
[17:42:39.445]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.445]                   envs[common]]
[17:42:39.445]                 NAMES <- toupper(changed)
[17:42:39.445]                 args <- list()
[17:42:39.445]                 for (kk in seq_along(NAMES)) {
[17:42:39.445]                   name <- changed[[kk]]
[17:42:39.445]                   NAME <- NAMES[[kk]]
[17:42:39.445]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.445]                     next
[17:42:39.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.445]                 }
[17:42:39.445]                 NAMES <- toupper(added)
[17:42:39.445]                 for (kk in seq_along(NAMES)) {
[17:42:39.445]                   name <- added[[kk]]
[17:42:39.445]                   NAME <- NAMES[[kk]]
[17:42:39.445]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.445]                     next
[17:42:39.445]                   args[[name]] <- ""
[17:42:39.445]                 }
[17:42:39.445]                 NAMES <- toupper(removed)
[17:42:39.445]                 for (kk in seq_along(NAMES)) {
[17:42:39.445]                   name <- removed[[kk]]
[17:42:39.445]                   NAME <- NAMES[[kk]]
[17:42:39.445]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.445]                     next
[17:42:39.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.445]                 }
[17:42:39.445]                 if (length(args) > 0) 
[17:42:39.445]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.445]             }
[17:42:39.445]             else {
[17:42:39.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.445]             }
[17:42:39.445]             {
[17:42:39.445]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.445]                   0L) {
[17:42:39.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.445]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.445]                   base::options(opts)
[17:42:39.445]                 }
[17:42:39.445]                 {
[17:42:39.445]                   {
[17:42:39.445]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.445]                     NULL
[17:42:39.445]                   }
[17:42:39.445]                   options(future.plan = NULL)
[17:42:39.445]                   if (is.na(NA_character_)) 
[17:42:39.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.445]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.445]                     envir = parent.frame()) 
[17:42:39.445]                   {
[17:42:39.445]                     default_workers <- missing(workers)
[17:42:39.445]                     if (is.function(workers)) 
[17:42:39.445]                       workers <- workers()
[17:42:39.445]                     workers <- structure(as.integer(workers), 
[17:42:39.445]                       class = class(workers))
[17:42:39.445]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.445]                       1L)
[17:42:39.445]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.445]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.445]                       if (default_workers) 
[17:42:39.445]                         supportsMulticore(warn = TRUE)
[17:42:39.445]                       return(sequential(..., envir = envir))
[17:42:39.445]                     }
[17:42:39.445]                     oopts <- options(mc.cores = workers)
[17:42:39.445]                     on.exit(options(oopts))
[17:42:39.445]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.445]                       envir = envir)
[17:42:39.445]                     if (!future$lazy) 
[17:42:39.445]                       future <- run(future)
[17:42:39.445]                     invisible(future)
[17:42:39.445]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.445]                 }
[17:42:39.445]             }
[17:42:39.445]         }
[17:42:39.445]     })
[17:42:39.445]     if (TRUE) {
[17:42:39.445]         base::sink(type = "output", split = FALSE)
[17:42:39.445]         if (TRUE) {
[17:42:39.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.445]         }
[17:42:39.445]         else {
[17:42:39.445]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.445]         }
[17:42:39.445]         base::close(...future.stdout)
[17:42:39.445]         ...future.stdout <- NULL
[17:42:39.445]     }
[17:42:39.445]     ...future.result$conditions <- ...future.conditions
[17:42:39.445]     ...future.result$finished <- base::Sys.time()
[17:42:39.445]     ...future.result
[17:42:39.445] }
[17:42:39.447] assign_globals() ...
[17:42:39.447] List of 1
[17:42:39.447]  $ x: list()
[17:42:39.447]  - attr(*, "where")=List of 1
[17:42:39.447]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.447]  - attr(*, "resolved")= logi TRUE
[17:42:39.447]  - attr(*, "total_size")= num 0
[17:42:39.447]  - attr(*, "already-done")= logi TRUE
[17:42:39.450] - copied ‘x’ to environment
[17:42:39.451] assign_globals() ... done
[17:42:39.451] requestCore(): workers = 2
[17:42:39.453] MulticoreFuture started
[17:42:39.453] - Launch lazy future ... done
[17:42:39.453] run() for ‘MulticoreFuture’ ... done
[17:42:39.454] plan(): Setting new future strategy stack:
[17:42:39.454] List of future strategies:
[17:42:39.454] 1. sequential:
[17:42:39.454]    - args: function (..., envir = parent.frame())
[17:42:39.454]    - tweaked: FALSE
[17:42:39.454]    - call: NULL
[17:42:39.455] plan(): nbrOfWorkers() = 1
[17:42:39.457] plan(): Setting new future strategy stack:
[17:42:39.457] List of future strategies:
[17:42:39.457] 1. multicore:
[17:42:39.457]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.457]    - tweaked: FALSE
[17:42:39.457]    - call: plan(strategy)
[17:42:39.462] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.464] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.464] Searching for globals...
[17:42:39.471] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:42:39.471] Searching for globals ... DONE
[17:42:39.471] Resolving globals: TRUE
[17:42:39.472] Resolving any globals that are futures ...
[17:42:39.472] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:42:39.472] Resolving any globals that are futures ... DONE
[17:42:39.472] 
[17:42:39.473] 
[17:42:39.473] getGlobalsAndPackages() ... DONE
[17:42:39.473] run() for ‘Future’ ...
[17:42:39.473] - state: ‘created’
[17:42:39.473] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.478] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.478] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.478]   - Field: ‘label’
[17:42:39.478]   - Field: ‘local’
[17:42:39.478]   - Field: ‘owner’
[17:42:39.478]   - Field: ‘envir’
[17:42:39.478]   - Field: ‘workers’
[17:42:39.479]   - Field: ‘packages’
[17:42:39.479]   - Field: ‘gc’
[17:42:39.479]   - Field: ‘job’
[17:42:39.479]   - Field: ‘conditions’
[17:42:39.479]   - Field: ‘expr’
[17:42:39.479]   - Field: ‘uuid’
[17:42:39.479]   - Field: ‘seed’
[17:42:39.479]   - Field: ‘version’
[17:42:39.480]   - Field: ‘result’
[17:42:39.480]   - Field: ‘asynchronous’
[17:42:39.480]   - Field: ‘calls’
[17:42:39.480]   - Field: ‘globals’
[17:42:39.480]   - Field: ‘stdout’
[17:42:39.480]   - Field: ‘earlySignal’
[17:42:39.480]   - Field: ‘lazy’
[17:42:39.480]   - Field: ‘state’
[17:42:39.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.481] - Launch lazy future ...
[17:42:39.481] Packages needed by the future expression (n = 0): <none>
[17:42:39.481] Packages needed by future strategies (n = 0): <none>
[17:42:39.482] {
[17:42:39.482]     {
[17:42:39.482]         {
[17:42:39.482]             ...future.startTime <- base::Sys.time()
[17:42:39.482]             {
[17:42:39.482]                 {
[17:42:39.482]                   {
[17:42:39.482]                     {
[17:42:39.482]                       base::local({
[17:42:39.482]                         has_future <- base::requireNamespace("future", 
[17:42:39.482]                           quietly = TRUE)
[17:42:39.482]                         if (has_future) {
[17:42:39.482]                           ns <- base::getNamespace("future")
[17:42:39.482]                           version <- ns[[".package"]][["version"]]
[17:42:39.482]                           if (is.null(version)) 
[17:42:39.482]                             version <- utils::packageVersion("future")
[17:42:39.482]                         }
[17:42:39.482]                         else {
[17:42:39.482]                           version <- NULL
[17:42:39.482]                         }
[17:42:39.482]                         if (!has_future || version < "1.8.0") {
[17:42:39.482]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.482]                             "", base::R.version$version.string), 
[17:42:39.482]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.482]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.482]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.482]                               "release", "version")], collapse = " "), 
[17:42:39.482]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.482]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.482]                             info)
[17:42:39.482]                           info <- base::paste(info, collapse = "; ")
[17:42:39.482]                           if (!has_future) {
[17:42:39.482]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.482]                               info)
[17:42:39.482]                           }
[17:42:39.482]                           else {
[17:42:39.482]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.482]                               info, version)
[17:42:39.482]                           }
[17:42:39.482]                           base::stop(msg)
[17:42:39.482]                         }
[17:42:39.482]                       })
[17:42:39.482]                     }
[17:42:39.482]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.482]                     base::options(mc.cores = 1L)
[17:42:39.482]                   }
[17:42:39.482]                   options(future.plan = NULL)
[17:42:39.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.482]                 }
[17:42:39.482]                 ...future.workdir <- getwd()
[17:42:39.482]             }
[17:42:39.482]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.482]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.482]         }
[17:42:39.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.482]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.482]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.482]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.482]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.482]             base::names(...future.oldOptions))
[17:42:39.482]     }
[17:42:39.482]     if (FALSE) {
[17:42:39.482]     }
[17:42:39.482]     else {
[17:42:39.482]         if (TRUE) {
[17:42:39.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.482]                 open = "w")
[17:42:39.482]         }
[17:42:39.482]         else {
[17:42:39.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.482]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.482]         }
[17:42:39.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.482]             base::sink(type = "output", split = FALSE)
[17:42:39.482]             base::close(...future.stdout)
[17:42:39.482]         }, add = TRUE)
[17:42:39.482]     }
[17:42:39.482]     ...future.frame <- base::sys.nframe()
[17:42:39.482]     ...future.conditions <- base::list()
[17:42:39.482]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.482]     if (FALSE) {
[17:42:39.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.482]     }
[17:42:39.482]     ...future.result <- base::tryCatch({
[17:42:39.482]         base::withCallingHandlers({
[17:42:39.482]             ...future.value <- base::withVisible(base::local({
[17:42:39.482]                 withCallingHandlers({
[17:42:39.482]                   {
[17:42:39.482]                     x <- list(b = 2)
[17:42:39.482]                     x$a <- 1
[17:42:39.482]                     x
[17:42:39.482]                   }
[17:42:39.482]                 }, immediateCondition = function(cond) {
[17:42:39.482]                   save_rds <- function (object, pathname, ...) 
[17:42:39.482]                   {
[17:42:39.482]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.482]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.482]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.482]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.482]                         fi_tmp[["mtime"]])
[17:42:39.482]                     }
[17:42:39.482]                     tryCatch({
[17:42:39.482]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.482]                     }, error = function(ex) {
[17:42:39.482]                       msg <- conditionMessage(ex)
[17:42:39.482]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.482]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.482]                         fi_tmp[["mtime"]], msg)
[17:42:39.482]                       ex$message <- msg
[17:42:39.482]                       stop(ex)
[17:42:39.482]                     })
[17:42:39.482]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.482]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.482]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.482]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.482]                       fi <- file.info(pathname)
[17:42:39.482]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.482]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.482]                         fi[["size"]], fi[["mtime"]])
[17:42:39.482]                       stop(msg)
[17:42:39.482]                     }
[17:42:39.482]                     invisible(pathname)
[17:42:39.482]                   }
[17:42:39.482]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.482]                     rootPath = tempdir()) 
[17:42:39.482]                   {
[17:42:39.482]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.482]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.482]                       tmpdir = path, fileext = ".rds")
[17:42:39.482]                     save_rds(obj, file)
[17:42:39.482]                   }
[17:42:39.482]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.482]                   {
[17:42:39.482]                     inherits <- base::inherits
[17:42:39.482]                     invokeRestart <- base::invokeRestart
[17:42:39.482]                     is.null <- base::is.null
[17:42:39.482]                     muffled <- FALSE
[17:42:39.482]                     if (inherits(cond, "message")) {
[17:42:39.482]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.482]                       if (muffled) 
[17:42:39.482]                         invokeRestart("muffleMessage")
[17:42:39.482]                     }
[17:42:39.482]                     else if (inherits(cond, "warning")) {
[17:42:39.482]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.482]                       if (muffled) 
[17:42:39.482]                         invokeRestart("muffleWarning")
[17:42:39.482]                     }
[17:42:39.482]                     else if (inherits(cond, "condition")) {
[17:42:39.482]                       if (!is.null(pattern)) {
[17:42:39.482]                         computeRestarts <- base::computeRestarts
[17:42:39.482]                         grepl <- base::grepl
[17:42:39.482]                         restarts <- computeRestarts(cond)
[17:42:39.482]                         for (restart in restarts) {
[17:42:39.482]                           name <- restart$name
[17:42:39.482]                           if (is.null(name)) 
[17:42:39.482]                             next
[17:42:39.482]                           if (!grepl(pattern, name)) 
[17:42:39.482]                             next
[17:42:39.482]                           invokeRestart(restart)
[17:42:39.482]                           muffled <- TRUE
[17:42:39.482]                           break
[17:42:39.482]                         }
[17:42:39.482]                       }
[17:42:39.482]                     }
[17:42:39.482]                     invisible(muffled)
[17:42:39.482]                   }
[17:42:39.482]                   muffleCondition(cond)
[17:42:39.482]                 })
[17:42:39.482]             }))
[17:42:39.482]             future::FutureResult(value = ...future.value$value, 
[17:42:39.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.482]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.482]                     ...future.globalenv.names))
[17:42:39.482]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.482]         }, condition = base::local({
[17:42:39.482]             c <- base::c
[17:42:39.482]             inherits <- base::inherits
[17:42:39.482]             invokeRestart <- base::invokeRestart
[17:42:39.482]             length <- base::length
[17:42:39.482]             list <- base::list
[17:42:39.482]             seq.int <- base::seq.int
[17:42:39.482]             signalCondition <- base::signalCondition
[17:42:39.482]             sys.calls <- base::sys.calls
[17:42:39.482]             `[[` <- base::`[[`
[17:42:39.482]             `+` <- base::`+`
[17:42:39.482]             `<<-` <- base::`<<-`
[17:42:39.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.482]                   3L)]
[17:42:39.482]             }
[17:42:39.482]             function(cond) {
[17:42:39.482]                 is_error <- inherits(cond, "error")
[17:42:39.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.482]                   NULL)
[17:42:39.482]                 if (is_error) {
[17:42:39.482]                   sessionInformation <- function() {
[17:42:39.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.482]                       search = base::search(), system = base::Sys.info())
[17:42:39.482]                   }
[17:42:39.482]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.482]                     cond$call), session = sessionInformation(), 
[17:42:39.482]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.482]                   signalCondition(cond)
[17:42:39.482]                 }
[17:42:39.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.482]                 "immediateCondition"))) {
[17:42:39.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.482]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.482]                   if (TRUE && !signal) {
[17:42:39.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.482]                     {
[17:42:39.482]                       inherits <- base::inherits
[17:42:39.482]                       invokeRestart <- base::invokeRestart
[17:42:39.482]                       is.null <- base::is.null
[17:42:39.482]                       muffled <- FALSE
[17:42:39.482]                       if (inherits(cond, "message")) {
[17:42:39.482]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.482]                         if (muffled) 
[17:42:39.482]                           invokeRestart("muffleMessage")
[17:42:39.482]                       }
[17:42:39.482]                       else if (inherits(cond, "warning")) {
[17:42:39.482]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.482]                         if (muffled) 
[17:42:39.482]                           invokeRestart("muffleWarning")
[17:42:39.482]                       }
[17:42:39.482]                       else if (inherits(cond, "condition")) {
[17:42:39.482]                         if (!is.null(pattern)) {
[17:42:39.482]                           computeRestarts <- base::computeRestarts
[17:42:39.482]                           grepl <- base::grepl
[17:42:39.482]                           restarts <- computeRestarts(cond)
[17:42:39.482]                           for (restart in restarts) {
[17:42:39.482]                             name <- restart$name
[17:42:39.482]                             if (is.null(name)) 
[17:42:39.482]                               next
[17:42:39.482]                             if (!grepl(pattern, name)) 
[17:42:39.482]                               next
[17:42:39.482]                             invokeRestart(restart)
[17:42:39.482]                             muffled <- TRUE
[17:42:39.482]                             break
[17:42:39.482]                           }
[17:42:39.482]                         }
[17:42:39.482]                       }
[17:42:39.482]                       invisible(muffled)
[17:42:39.482]                     }
[17:42:39.482]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.482]                   }
[17:42:39.482]                 }
[17:42:39.482]                 else {
[17:42:39.482]                   if (TRUE) {
[17:42:39.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.482]                     {
[17:42:39.482]                       inherits <- base::inherits
[17:42:39.482]                       invokeRestart <- base::invokeRestart
[17:42:39.482]                       is.null <- base::is.null
[17:42:39.482]                       muffled <- FALSE
[17:42:39.482]                       if (inherits(cond, "message")) {
[17:42:39.482]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.482]                         if (muffled) 
[17:42:39.482]                           invokeRestart("muffleMessage")
[17:42:39.482]                       }
[17:42:39.482]                       else if (inherits(cond, "warning")) {
[17:42:39.482]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.482]                         if (muffled) 
[17:42:39.482]                           invokeRestart("muffleWarning")
[17:42:39.482]                       }
[17:42:39.482]                       else if (inherits(cond, "condition")) {
[17:42:39.482]                         if (!is.null(pattern)) {
[17:42:39.482]                           computeRestarts <- base::computeRestarts
[17:42:39.482]                           grepl <- base::grepl
[17:42:39.482]                           restarts <- computeRestarts(cond)
[17:42:39.482]                           for (restart in restarts) {
[17:42:39.482]                             name <- restart$name
[17:42:39.482]                             if (is.null(name)) 
[17:42:39.482]                               next
[17:42:39.482]                             if (!grepl(pattern, name)) 
[17:42:39.482]                               next
[17:42:39.482]                             invokeRestart(restart)
[17:42:39.482]                             muffled <- TRUE
[17:42:39.482]                             break
[17:42:39.482]                           }
[17:42:39.482]                         }
[17:42:39.482]                       }
[17:42:39.482]                       invisible(muffled)
[17:42:39.482]                     }
[17:42:39.482]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.482]                   }
[17:42:39.482]                 }
[17:42:39.482]             }
[17:42:39.482]         }))
[17:42:39.482]     }, error = function(ex) {
[17:42:39.482]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.482]                 ...future.rng), started = ...future.startTime, 
[17:42:39.482]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.482]             version = "1.8"), class = "FutureResult")
[17:42:39.482]     }, finally = {
[17:42:39.482]         if (!identical(...future.workdir, getwd())) 
[17:42:39.482]             setwd(...future.workdir)
[17:42:39.482]         {
[17:42:39.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.482]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.482]             }
[17:42:39.482]             base::options(...future.oldOptions)
[17:42:39.482]             if (.Platform$OS.type == "windows") {
[17:42:39.482]                 old_names <- names(...future.oldEnvVars)
[17:42:39.482]                 envs <- base::Sys.getenv()
[17:42:39.482]                 names <- names(envs)
[17:42:39.482]                 common <- intersect(names, old_names)
[17:42:39.482]                 added <- setdiff(names, old_names)
[17:42:39.482]                 removed <- setdiff(old_names, names)
[17:42:39.482]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.482]                   envs[common]]
[17:42:39.482]                 NAMES <- toupper(changed)
[17:42:39.482]                 args <- list()
[17:42:39.482]                 for (kk in seq_along(NAMES)) {
[17:42:39.482]                   name <- changed[[kk]]
[17:42:39.482]                   NAME <- NAMES[[kk]]
[17:42:39.482]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.482]                     next
[17:42:39.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.482]                 }
[17:42:39.482]                 NAMES <- toupper(added)
[17:42:39.482]                 for (kk in seq_along(NAMES)) {
[17:42:39.482]                   name <- added[[kk]]
[17:42:39.482]                   NAME <- NAMES[[kk]]
[17:42:39.482]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.482]                     next
[17:42:39.482]                   args[[name]] <- ""
[17:42:39.482]                 }
[17:42:39.482]                 NAMES <- toupper(removed)
[17:42:39.482]                 for (kk in seq_along(NAMES)) {
[17:42:39.482]                   name <- removed[[kk]]
[17:42:39.482]                   NAME <- NAMES[[kk]]
[17:42:39.482]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.482]                     next
[17:42:39.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.482]                 }
[17:42:39.482]                 if (length(args) > 0) 
[17:42:39.482]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.482]             }
[17:42:39.482]             else {
[17:42:39.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.482]             }
[17:42:39.482]             {
[17:42:39.482]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.482]                   0L) {
[17:42:39.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.482]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.482]                   base::options(opts)
[17:42:39.482]                 }
[17:42:39.482]                 {
[17:42:39.482]                   {
[17:42:39.482]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.482]                     NULL
[17:42:39.482]                   }
[17:42:39.482]                   options(future.plan = NULL)
[17:42:39.482]                   if (is.na(NA_character_)) 
[17:42:39.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.482]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.482]                     envir = parent.frame()) 
[17:42:39.482]                   {
[17:42:39.482]                     default_workers <- missing(workers)
[17:42:39.482]                     if (is.function(workers)) 
[17:42:39.482]                       workers <- workers()
[17:42:39.482]                     workers <- structure(as.integer(workers), 
[17:42:39.482]                       class = class(workers))
[17:42:39.482]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.482]                       1L)
[17:42:39.482]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.482]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.482]                       if (default_workers) 
[17:42:39.482]                         supportsMulticore(warn = TRUE)
[17:42:39.482]                       return(sequential(..., envir = envir))
[17:42:39.482]                     }
[17:42:39.482]                     oopts <- options(mc.cores = workers)
[17:42:39.482]                     on.exit(options(oopts))
[17:42:39.482]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.482]                       envir = envir)
[17:42:39.482]                     if (!future$lazy) 
[17:42:39.482]                       future <- run(future)
[17:42:39.482]                     invisible(future)
[17:42:39.482]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.482]                 }
[17:42:39.482]             }
[17:42:39.482]         }
[17:42:39.482]     })
[17:42:39.482]     if (TRUE) {
[17:42:39.482]         base::sink(type = "output", split = FALSE)
[17:42:39.482]         if (TRUE) {
[17:42:39.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.482]         }
[17:42:39.482]         else {
[17:42:39.482]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.482]         }
[17:42:39.482]         base::close(...future.stdout)
[17:42:39.482]         ...future.stdout <- NULL
[17:42:39.482]     }
[17:42:39.482]     ...future.result$conditions <- ...future.conditions
[17:42:39.482]     ...future.result$finished <- base::Sys.time()
[17:42:39.482]     ...future.result
[17:42:39.482] }
[17:42:39.484] requestCore(): workers = 2
[17:42:39.486] MulticoreFuture started
[17:42:39.486] - Launch lazy future ... done
[17:42:39.487] run() for ‘MulticoreFuture’ ... done
[17:42:39.487] plan(): Setting new future strategy stack:
[17:42:39.488] List of future strategies:
[17:42:39.488] 1. sequential:
[17:42:39.488]    - args: function (..., envir = parent.frame())
[17:42:39.488]    - tweaked: FALSE
[17:42:39.488]    - call: NULL
[17:42:39.489] plan(): nbrOfWorkers() = 1
[17:42:39.490] plan(): Setting new future strategy stack:
[17:42:39.491] List of future strategies:
[17:42:39.491] 1. multicore:
[17:42:39.491]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.491]    - tweaked: FALSE
[17:42:39.491]    - call: plan(strategy)
[17:42:39.495] plan(): nbrOfWorkers() = 2
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.497] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.497] Searching for globals...
[17:42:39.500] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.500] Searching for globals ... DONE
[17:42:39.500] Resolving globals: TRUE
[17:42:39.501] Resolving any globals that are futures ...
[17:42:39.501] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.501] Resolving any globals that are futures ... DONE
[17:42:39.501] Resolving futures part of globals (recursively) ...
[17:42:39.502] resolve() on list ...
[17:42:39.502]  recursive: 99
[17:42:39.502]  length: 1
[17:42:39.502]  elements: ‘x’
[17:42:39.502]  length: 0 (resolved future 1)
[17:42:39.502] resolve() on list ... DONE
[17:42:39.502] - globals: [1] ‘x’
[17:42:39.503] Resolving futures part of globals (recursively) ... DONE
[17:42:39.503] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.503] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.503] - globals: [1] ‘x’
[17:42:39.504] 
[17:42:39.504] getGlobalsAndPackages() ... DONE
[17:42:39.504] run() for ‘Future’ ...
[17:42:39.504] - state: ‘created’
[17:42:39.504] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.509] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.509] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.509]   - Field: ‘label’
[17:42:39.509]   - Field: ‘local’
[17:42:39.509]   - Field: ‘owner’
[17:42:39.509]   - Field: ‘envir’
[17:42:39.509]   - Field: ‘workers’
[17:42:39.509]   - Field: ‘packages’
[17:42:39.510]   - Field: ‘gc’
[17:42:39.510]   - Field: ‘job’
[17:42:39.510]   - Field: ‘conditions’
[17:42:39.510]   - Field: ‘expr’
[17:42:39.510]   - Field: ‘uuid’
[17:42:39.510]   - Field: ‘seed’
[17:42:39.510]   - Field: ‘version’
[17:42:39.510]   - Field: ‘result’
[17:42:39.511]   - Field: ‘asynchronous’
[17:42:39.511]   - Field: ‘calls’
[17:42:39.511]   - Field: ‘globals’
[17:42:39.511]   - Field: ‘stdout’
[17:42:39.511]   - Field: ‘earlySignal’
[17:42:39.511]   - Field: ‘lazy’
[17:42:39.511]   - Field: ‘state’
[17:42:39.511] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.511] - Launch lazy future ...
[17:42:39.512] Packages needed by the future expression (n = 0): <none>
[17:42:39.512] Packages needed by future strategies (n = 0): <none>
[17:42:39.512] {
[17:42:39.512]     {
[17:42:39.512]         {
[17:42:39.512]             ...future.startTime <- base::Sys.time()
[17:42:39.512]             {
[17:42:39.512]                 {
[17:42:39.512]                   {
[17:42:39.512]                     {
[17:42:39.512]                       base::local({
[17:42:39.512]                         has_future <- base::requireNamespace("future", 
[17:42:39.512]                           quietly = TRUE)
[17:42:39.512]                         if (has_future) {
[17:42:39.512]                           ns <- base::getNamespace("future")
[17:42:39.512]                           version <- ns[[".package"]][["version"]]
[17:42:39.512]                           if (is.null(version)) 
[17:42:39.512]                             version <- utils::packageVersion("future")
[17:42:39.512]                         }
[17:42:39.512]                         else {
[17:42:39.512]                           version <- NULL
[17:42:39.512]                         }
[17:42:39.512]                         if (!has_future || version < "1.8.0") {
[17:42:39.512]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.512]                             "", base::R.version$version.string), 
[17:42:39.512]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.512]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.512]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.512]                               "release", "version")], collapse = " "), 
[17:42:39.512]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.512]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.512]                             info)
[17:42:39.512]                           info <- base::paste(info, collapse = "; ")
[17:42:39.512]                           if (!has_future) {
[17:42:39.512]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.512]                               info)
[17:42:39.512]                           }
[17:42:39.512]                           else {
[17:42:39.512]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.512]                               info, version)
[17:42:39.512]                           }
[17:42:39.512]                           base::stop(msg)
[17:42:39.512]                         }
[17:42:39.512]                       })
[17:42:39.512]                     }
[17:42:39.512]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.512]                     base::options(mc.cores = 1L)
[17:42:39.512]                   }
[17:42:39.512]                   options(future.plan = NULL)
[17:42:39.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.512]                 }
[17:42:39.512]                 ...future.workdir <- getwd()
[17:42:39.512]             }
[17:42:39.512]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.512]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.512]         }
[17:42:39.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.512]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.512]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.512]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.512]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.512]             base::names(...future.oldOptions))
[17:42:39.512]     }
[17:42:39.512]     if (FALSE) {
[17:42:39.512]     }
[17:42:39.512]     else {
[17:42:39.512]         if (TRUE) {
[17:42:39.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.512]                 open = "w")
[17:42:39.512]         }
[17:42:39.512]         else {
[17:42:39.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.512]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.512]         }
[17:42:39.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.512]             base::sink(type = "output", split = FALSE)
[17:42:39.512]             base::close(...future.stdout)
[17:42:39.512]         }, add = TRUE)
[17:42:39.512]     }
[17:42:39.512]     ...future.frame <- base::sys.nframe()
[17:42:39.512]     ...future.conditions <- base::list()
[17:42:39.512]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.512]     if (FALSE) {
[17:42:39.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.512]     }
[17:42:39.512]     ...future.result <- base::tryCatch({
[17:42:39.512]         base::withCallingHandlers({
[17:42:39.512]             ...future.value <- base::withVisible(base::local({
[17:42:39.512]                 withCallingHandlers({
[17:42:39.512]                   {
[17:42:39.512]                     x[["a"]] <- 1
[17:42:39.512]                     x
[17:42:39.512]                   }
[17:42:39.512]                 }, immediateCondition = function(cond) {
[17:42:39.512]                   save_rds <- function (object, pathname, ...) 
[17:42:39.512]                   {
[17:42:39.512]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.512]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.512]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.512]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.512]                         fi_tmp[["mtime"]])
[17:42:39.512]                     }
[17:42:39.512]                     tryCatch({
[17:42:39.512]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.512]                     }, error = function(ex) {
[17:42:39.512]                       msg <- conditionMessage(ex)
[17:42:39.512]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.512]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.512]                         fi_tmp[["mtime"]], msg)
[17:42:39.512]                       ex$message <- msg
[17:42:39.512]                       stop(ex)
[17:42:39.512]                     })
[17:42:39.512]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.512]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.512]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.512]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.512]                       fi <- file.info(pathname)
[17:42:39.512]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.512]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.512]                         fi[["size"]], fi[["mtime"]])
[17:42:39.512]                       stop(msg)
[17:42:39.512]                     }
[17:42:39.512]                     invisible(pathname)
[17:42:39.512]                   }
[17:42:39.512]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.512]                     rootPath = tempdir()) 
[17:42:39.512]                   {
[17:42:39.512]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.512]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.512]                       tmpdir = path, fileext = ".rds")
[17:42:39.512]                     save_rds(obj, file)
[17:42:39.512]                   }
[17:42:39.512]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.512]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.512]                   {
[17:42:39.512]                     inherits <- base::inherits
[17:42:39.512]                     invokeRestart <- base::invokeRestart
[17:42:39.512]                     is.null <- base::is.null
[17:42:39.512]                     muffled <- FALSE
[17:42:39.512]                     if (inherits(cond, "message")) {
[17:42:39.512]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.512]                       if (muffled) 
[17:42:39.512]                         invokeRestart("muffleMessage")
[17:42:39.512]                     }
[17:42:39.512]                     else if (inherits(cond, "warning")) {
[17:42:39.512]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.512]                       if (muffled) 
[17:42:39.512]                         invokeRestart("muffleWarning")
[17:42:39.512]                     }
[17:42:39.512]                     else if (inherits(cond, "condition")) {
[17:42:39.512]                       if (!is.null(pattern)) {
[17:42:39.512]                         computeRestarts <- base::computeRestarts
[17:42:39.512]                         grepl <- base::grepl
[17:42:39.512]                         restarts <- computeRestarts(cond)
[17:42:39.512]                         for (restart in restarts) {
[17:42:39.512]                           name <- restart$name
[17:42:39.512]                           if (is.null(name)) 
[17:42:39.512]                             next
[17:42:39.512]                           if (!grepl(pattern, name)) 
[17:42:39.512]                             next
[17:42:39.512]                           invokeRestart(restart)
[17:42:39.512]                           muffled <- TRUE
[17:42:39.512]                           break
[17:42:39.512]                         }
[17:42:39.512]                       }
[17:42:39.512]                     }
[17:42:39.512]                     invisible(muffled)
[17:42:39.512]                   }
[17:42:39.512]                   muffleCondition(cond)
[17:42:39.512]                 })
[17:42:39.512]             }))
[17:42:39.512]             future::FutureResult(value = ...future.value$value, 
[17:42:39.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.512]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.512]                     ...future.globalenv.names))
[17:42:39.512]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.512]         }, condition = base::local({
[17:42:39.512]             c <- base::c
[17:42:39.512]             inherits <- base::inherits
[17:42:39.512]             invokeRestart <- base::invokeRestart
[17:42:39.512]             length <- base::length
[17:42:39.512]             list <- base::list
[17:42:39.512]             seq.int <- base::seq.int
[17:42:39.512]             signalCondition <- base::signalCondition
[17:42:39.512]             sys.calls <- base::sys.calls
[17:42:39.512]             `[[` <- base::`[[`
[17:42:39.512]             `+` <- base::`+`
[17:42:39.512]             `<<-` <- base::`<<-`
[17:42:39.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.512]                   3L)]
[17:42:39.512]             }
[17:42:39.512]             function(cond) {
[17:42:39.512]                 is_error <- inherits(cond, "error")
[17:42:39.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.512]                   NULL)
[17:42:39.512]                 if (is_error) {
[17:42:39.512]                   sessionInformation <- function() {
[17:42:39.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.512]                       search = base::search(), system = base::Sys.info())
[17:42:39.512]                   }
[17:42:39.512]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.512]                     cond$call), session = sessionInformation(), 
[17:42:39.512]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.512]                   signalCondition(cond)
[17:42:39.512]                 }
[17:42:39.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.512]                 "immediateCondition"))) {
[17:42:39.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.512]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.512]                   if (TRUE && !signal) {
[17:42:39.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.512]                     {
[17:42:39.512]                       inherits <- base::inherits
[17:42:39.512]                       invokeRestart <- base::invokeRestart
[17:42:39.512]                       is.null <- base::is.null
[17:42:39.512]                       muffled <- FALSE
[17:42:39.512]                       if (inherits(cond, "message")) {
[17:42:39.512]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.512]                         if (muffled) 
[17:42:39.512]                           invokeRestart("muffleMessage")
[17:42:39.512]                       }
[17:42:39.512]                       else if (inherits(cond, "warning")) {
[17:42:39.512]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.512]                         if (muffled) 
[17:42:39.512]                           invokeRestart("muffleWarning")
[17:42:39.512]                       }
[17:42:39.512]                       else if (inherits(cond, "condition")) {
[17:42:39.512]                         if (!is.null(pattern)) {
[17:42:39.512]                           computeRestarts <- base::computeRestarts
[17:42:39.512]                           grepl <- base::grepl
[17:42:39.512]                           restarts <- computeRestarts(cond)
[17:42:39.512]                           for (restart in restarts) {
[17:42:39.512]                             name <- restart$name
[17:42:39.512]                             if (is.null(name)) 
[17:42:39.512]                               next
[17:42:39.512]                             if (!grepl(pattern, name)) 
[17:42:39.512]                               next
[17:42:39.512]                             invokeRestart(restart)
[17:42:39.512]                             muffled <- TRUE
[17:42:39.512]                             break
[17:42:39.512]                           }
[17:42:39.512]                         }
[17:42:39.512]                       }
[17:42:39.512]                       invisible(muffled)
[17:42:39.512]                     }
[17:42:39.512]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.512]                   }
[17:42:39.512]                 }
[17:42:39.512]                 else {
[17:42:39.512]                   if (TRUE) {
[17:42:39.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.512]                     {
[17:42:39.512]                       inherits <- base::inherits
[17:42:39.512]                       invokeRestart <- base::invokeRestart
[17:42:39.512]                       is.null <- base::is.null
[17:42:39.512]                       muffled <- FALSE
[17:42:39.512]                       if (inherits(cond, "message")) {
[17:42:39.512]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.512]                         if (muffled) 
[17:42:39.512]                           invokeRestart("muffleMessage")
[17:42:39.512]                       }
[17:42:39.512]                       else if (inherits(cond, "warning")) {
[17:42:39.512]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.512]                         if (muffled) 
[17:42:39.512]                           invokeRestart("muffleWarning")
[17:42:39.512]                       }
[17:42:39.512]                       else if (inherits(cond, "condition")) {
[17:42:39.512]                         if (!is.null(pattern)) {
[17:42:39.512]                           computeRestarts <- base::computeRestarts
[17:42:39.512]                           grepl <- base::grepl
[17:42:39.512]                           restarts <- computeRestarts(cond)
[17:42:39.512]                           for (restart in restarts) {
[17:42:39.512]                             name <- restart$name
[17:42:39.512]                             if (is.null(name)) 
[17:42:39.512]                               next
[17:42:39.512]                             if (!grepl(pattern, name)) 
[17:42:39.512]                               next
[17:42:39.512]                             invokeRestart(restart)
[17:42:39.512]                             muffled <- TRUE
[17:42:39.512]                             break
[17:42:39.512]                           }
[17:42:39.512]                         }
[17:42:39.512]                       }
[17:42:39.512]                       invisible(muffled)
[17:42:39.512]                     }
[17:42:39.512]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.512]                   }
[17:42:39.512]                 }
[17:42:39.512]             }
[17:42:39.512]         }))
[17:42:39.512]     }, error = function(ex) {
[17:42:39.512]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.512]                 ...future.rng), started = ...future.startTime, 
[17:42:39.512]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.512]             version = "1.8"), class = "FutureResult")
[17:42:39.512]     }, finally = {
[17:42:39.512]         if (!identical(...future.workdir, getwd())) 
[17:42:39.512]             setwd(...future.workdir)
[17:42:39.512]         {
[17:42:39.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.512]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.512]             }
[17:42:39.512]             base::options(...future.oldOptions)
[17:42:39.512]             if (.Platform$OS.type == "windows") {
[17:42:39.512]                 old_names <- names(...future.oldEnvVars)
[17:42:39.512]                 envs <- base::Sys.getenv()
[17:42:39.512]                 names <- names(envs)
[17:42:39.512]                 common <- intersect(names, old_names)
[17:42:39.512]                 added <- setdiff(names, old_names)
[17:42:39.512]                 removed <- setdiff(old_names, names)
[17:42:39.512]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.512]                   envs[common]]
[17:42:39.512]                 NAMES <- toupper(changed)
[17:42:39.512]                 args <- list()
[17:42:39.512]                 for (kk in seq_along(NAMES)) {
[17:42:39.512]                   name <- changed[[kk]]
[17:42:39.512]                   NAME <- NAMES[[kk]]
[17:42:39.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.512]                     next
[17:42:39.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.512]                 }
[17:42:39.512]                 NAMES <- toupper(added)
[17:42:39.512]                 for (kk in seq_along(NAMES)) {
[17:42:39.512]                   name <- added[[kk]]
[17:42:39.512]                   NAME <- NAMES[[kk]]
[17:42:39.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.512]                     next
[17:42:39.512]                   args[[name]] <- ""
[17:42:39.512]                 }
[17:42:39.512]                 NAMES <- toupper(removed)
[17:42:39.512]                 for (kk in seq_along(NAMES)) {
[17:42:39.512]                   name <- removed[[kk]]
[17:42:39.512]                   NAME <- NAMES[[kk]]
[17:42:39.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.512]                     next
[17:42:39.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.512]                 }
[17:42:39.512]                 if (length(args) > 0) 
[17:42:39.512]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.512]             }
[17:42:39.512]             else {
[17:42:39.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.512]             }
[17:42:39.512]             {
[17:42:39.512]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.512]                   0L) {
[17:42:39.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.512]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.512]                   base::options(opts)
[17:42:39.512]                 }
[17:42:39.512]                 {
[17:42:39.512]                   {
[17:42:39.512]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.512]                     NULL
[17:42:39.512]                   }
[17:42:39.512]                   options(future.plan = NULL)
[17:42:39.512]                   if (is.na(NA_character_)) 
[17:42:39.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.512]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.512]                     envir = parent.frame()) 
[17:42:39.512]                   {
[17:42:39.512]                     default_workers <- missing(workers)
[17:42:39.512]                     if (is.function(workers)) 
[17:42:39.512]                       workers <- workers()
[17:42:39.512]                     workers <- structure(as.integer(workers), 
[17:42:39.512]                       class = class(workers))
[17:42:39.512]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.512]                       1L)
[17:42:39.512]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.512]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.512]                       if (default_workers) 
[17:42:39.512]                         supportsMulticore(warn = TRUE)
[17:42:39.512]                       return(sequential(..., envir = envir))
[17:42:39.512]                     }
[17:42:39.512]                     oopts <- options(mc.cores = workers)
[17:42:39.512]                     on.exit(options(oopts))
[17:42:39.512]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.512]                       envir = envir)
[17:42:39.512]                     if (!future$lazy) 
[17:42:39.512]                       future <- run(future)
[17:42:39.512]                     invisible(future)
[17:42:39.512]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.512]                 }
[17:42:39.512]             }
[17:42:39.512]         }
[17:42:39.512]     })
[17:42:39.512]     if (TRUE) {
[17:42:39.512]         base::sink(type = "output", split = FALSE)
[17:42:39.512]         if (TRUE) {
[17:42:39.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.512]         }
[17:42:39.512]         else {
[17:42:39.512]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.512]         }
[17:42:39.512]         base::close(...future.stdout)
[17:42:39.512]         ...future.stdout <- NULL
[17:42:39.512]     }
[17:42:39.512]     ...future.result$conditions <- ...future.conditions
[17:42:39.512]     ...future.result$finished <- base::Sys.time()
[17:42:39.512]     ...future.result
[17:42:39.512] }
[17:42:39.515] assign_globals() ...
[17:42:39.515] List of 1
[17:42:39.515]  $ x: list()
[17:42:39.515]  - attr(*, "where")=List of 1
[17:42:39.515]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.515]  - attr(*, "resolved")= logi TRUE
[17:42:39.515]  - attr(*, "total_size")= num 0
[17:42:39.515]  - attr(*, "already-done")= logi TRUE
[17:42:39.518] - copied ‘x’ to environment
[17:42:39.518] assign_globals() ... done
[17:42:39.519] requestCore(): workers = 2
[17:42:39.521] MulticoreFuture started
[17:42:39.525] - Launch lazy future ... done
[17:42:39.525] run() for ‘MulticoreFuture’ ... done
[17:42:39.526] plan(): Setting new future strategy stack:
[17:42:39.526] List of future strategies:
[17:42:39.526] 1. sequential:
[17:42:39.526]    - args: function (..., envir = parent.frame())
[17:42:39.526]    - tweaked: FALSE
[17:42:39.526]    - call: NULL
[17:42:39.527] plan(): nbrOfWorkers() = 1
[17:42:39.529] plan(): Setting new future strategy stack:
[17:42:39.529] List of future strategies:
[17:42:39.529] 1. multicore:
[17:42:39.529]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.529]    - tweaked: FALSE
[17:42:39.529]    - call: plan(strategy)
[17:42:39.535] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.537] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.537] Searching for globals...
[17:42:39.541] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.541] Searching for globals ... DONE
[17:42:39.541] Resolving globals: TRUE
[17:42:39.541] Resolving any globals that are futures ...
[17:42:39.541] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.541] Resolving any globals that are futures ... DONE
[17:42:39.542] Resolving futures part of globals (recursively) ...
[17:42:39.542] resolve() on list ...
[17:42:39.542]  recursive: 99
[17:42:39.542]  length: 1
[17:42:39.542]  elements: ‘x’
[17:42:39.543]  length: 0 (resolved future 1)
[17:42:39.543] resolve() on list ... DONE
[17:42:39.543] - globals: [1] ‘x’
[17:42:39.543] Resolving futures part of globals (recursively) ... DONE
[17:42:39.543] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.544] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.544] - globals: [1] ‘x’
[17:42:39.544] 
[17:42:39.544] getGlobalsAndPackages() ... DONE
[17:42:39.544] run() for ‘Future’ ...
[17:42:39.544] - state: ‘created’
[17:42:39.545] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.549] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.549] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.549]   - Field: ‘label’
[17:42:39.549]   - Field: ‘local’
[17:42:39.549]   - Field: ‘owner’
[17:42:39.549]   - Field: ‘envir’
[17:42:39.550]   - Field: ‘workers’
[17:42:39.550]   - Field: ‘packages’
[17:42:39.550]   - Field: ‘gc’
[17:42:39.550]   - Field: ‘job’
[17:42:39.550]   - Field: ‘conditions’
[17:42:39.550]   - Field: ‘expr’
[17:42:39.550]   - Field: ‘uuid’
[17:42:39.550]   - Field: ‘seed’
[17:42:39.550]   - Field: ‘version’
[17:42:39.551]   - Field: ‘result’
[17:42:39.551]   - Field: ‘asynchronous’
[17:42:39.551]   - Field: ‘calls’
[17:42:39.551]   - Field: ‘globals’
[17:42:39.551]   - Field: ‘stdout’
[17:42:39.551]   - Field: ‘earlySignal’
[17:42:39.551]   - Field: ‘lazy’
[17:42:39.551]   - Field: ‘state’
[17:42:39.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.552] - Launch lazy future ...
[17:42:39.552] Packages needed by the future expression (n = 0): <none>
[17:42:39.552] Packages needed by future strategies (n = 0): <none>
[17:42:39.553] {
[17:42:39.553]     {
[17:42:39.553]         {
[17:42:39.553]             ...future.startTime <- base::Sys.time()
[17:42:39.553]             {
[17:42:39.553]                 {
[17:42:39.553]                   {
[17:42:39.553]                     {
[17:42:39.553]                       base::local({
[17:42:39.553]                         has_future <- base::requireNamespace("future", 
[17:42:39.553]                           quietly = TRUE)
[17:42:39.553]                         if (has_future) {
[17:42:39.553]                           ns <- base::getNamespace("future")
[17:42:39.553]                           version <- ns[[".package"]][["version"]]
[17:42:39.553]                           if (is.null(version)) 
[17:42:39.553]                             version <- utils::packageVersion("future")
[17:42:39.553]                         }
[17:42:39.553]                         else {
[17:42:39.553]                           version <- NULL
[17:42:39.553]                         }
[17:42:39.553]                         if (!has_future || version < "1.8.0") {
[17:42:39.553]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.553]                             "", base::R.version$version.string), 
[17:42:39.553]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.553]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.553]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.553]                               "release", "version")], collapse = " "), 
[17:42:39.553]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.553]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.553]                             info)
[17:42:39.553]                           info <- base::paste(info, collapse = "; ")
[17:42:39.553]                           if (!has_future) {
[17:42:39.553]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.553]                               info)
[17:42:39.553]                           }
[17:42:39.553]                           else {
[17:42:39.553]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.553]                               info, version)
[17:42:39.553]                           }
[17:42:39.553]                           base::stop(msg)
[17:42:39.553]                         }
[17:42:39.553]                       })
[17:42:39.553]                     }
[17:42:39.553]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.553]                     base::options(mc.cores = 1L)
[17:42:39.553]                   }
[17:42:39.553]                   options(future.plan = NULL)
[17:42:39.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.553]                 }
[17:42:39.553]                 ...future.workdir <- getwd()
[17:42:39.553]             }
[17:42:39.553]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.553]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.553]         }
[17:42:39.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.553]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.553]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.553]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.553]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.553]             base::names(...future.oldOptions))
[17:42:39.553]     }
[17:42:39.553]     if (FALSE) {
[17:42:39.553]     }
[17:42:39.553]     else {
[17:42:39.553]         if (TRUE) {
[17:42:39.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.553]                 open = "w")
[17:42:39.553]         }
[17:42:39.553]         else {
[17:42:39.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.553]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.553]         }
[17:42:39.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.553]             base::sink(type = "output", split = FALSE)
[17:42:39.553]             base::close(...future.stdout)
[17:42:39.553]         }, add = TRUE)
[17:42:39.553]     }
[17:42:39.553]     ...future.frame <- base::sys.nframe()
[17:42:39.553]     ...future.conditions <- base::list()
[17:42:39.553]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.553]     if (FALSE) {
[17:42:39.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.553]     }
[17:42:39.553]     ...future.result <- base::tryCatch({
[17:42:39.553]         base::withCallingHandlers({
[17:42:39.553]             ...future.value <- base::withVisible(base::local({
[17:42:39.553]                 withCallingHandlers({
[17:42:39.553]                   {
[17:42:39.553]                     x[["a"]] <- 1
[17:42:39.553]                     x
[17:42:39.553]                   }
[17:42:39.553]                 }, immediateCondition = function(cond) {
[17:42:39.553]                   save_rds <- function (object, pathname, ...) 
[17:42:39.553]                   {
[17:42:39.553]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.553]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.553]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.553]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.553]                         fi_tmp[["mtime"]])
[17:42:39.553]                     }
[17:42:39.553]                     tryCatch({
[17:42:39.553]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.553]                     }, error = function(ex) {
[17:42:39.553]                       msg <- conditionMessage(ex)
[17:42:39.553]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.553]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.553]                         fi_tmp[["mtime"]], msg)
[17:42:39.553]                       ex$message <- msg
[17:42:39.553]                       stop(ex)
[17:42:39.553]                     })
[17:42:39.553]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.553]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.553]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.553]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.553]                       fi <- file.info(pathname)
[17:42:39.553]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.553]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.553]                         fi[["size"]], fi[["mtime"]])
[17:42:39.553]                       stop(msg)
[17:42:39.553]                     }
[17:42:39.553]                     invisible(pathname)
[17:42:39.553]                   }
[17:42:39.553]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.553]                     rootPath = tempdir()) 
[17:42:39.553]                   {
[17:42:39.553]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.553]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.553]                       tmpdir = path, fileext = ".rds")
[17:42:39.553]                     save_rds(obj, file)
[17:42:39.553]                   }
[17:42:39.553]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.553]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.553]                   {
[17:42:39.553]                     inherits <- base::inherits
[17:42:39.553]                     invokeRestart <- base::invokeRestart
[17:42:39.553]                     is.null <- base::is.null
[17:42:39.553]                     muffled <- FALSE
[17:42:39.553]                     if (inherits(cond, "message")) {
[17:42:39.553]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.553]                       if (muffled) 
[17:42:39.553]                         invokeRestart("muffleMessage")
[17:42:39.553]                     }
[17:42:39.553]                     else if (inherits(cond, "warning")) {
[17:42:39.553]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.553]                       if (muffled) 
[17:42:39.553]                         invokeRestart("muffleWarning")
[17:42:39.553]                     }
[17:42:39.553]                     else if (inherits(cond, "condition")) {
[17:42:39.553]                       if (!is.null(pattern)) {
[17:42:39.553]                         computeRestarts <- base::computeRestarts
[17:42:39.553]                         grepl <- base::grepl
[17:42:39.553]                         restarts <- computeRestarts(cond)
[17:42:39.553]                         for (restart in restarts) {
[17:42:39.553]                           name <- restart$name
[17:42:39.553]                           if (is.null(name)) 
[17:42:39.553]                             next
[17:42:39.553]                           if (!grepl(pattern, name)) 
[17:42:39.553]                             next
[17:42:39.553]                           invokeRestart(restart)
[17:42:39.553]                           muffled <- TRUE
[17:42:39.553]                           break
[17:42:39.553]                         }
[17:42:39.553]                       }
[17:42:39.553]                     }
[17:42:39.553]                     invisible(muffled)
[17:42:39.553]                   }
[17:42:39.553]                   muffleCondition(cond)
[17:42:39.553]                 })
[17:42:39.553]             }))
[17:42:39.553]             future::FutureResult(value = ...future.value$value, 
[17:42:39.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.553]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.553]                     ...future.globalenv.names))
[17:42:39.553]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.553]         }, condition = base::local({
[17:42:39.553]             c <- base::c
[17:42:39.553]             inherits <- base::inherits
[17:42:39.553]             invokeRestart <- base::invokeRestart
[17:42:39.553]             length <- base::length
[17:42:39.553]             list <- base::list
[17:42:39.553]             seq.int <- base::seq.int
[17:42:39.553]             signalCondition <- base::signalCondition
[17:42:39.553]             sys.calls <- base::sys.calls
[17:42:39.553]             `[[` <- base::`[[`
[17:42:39.553]             `+` <- base::`+`
[17:42:39.553]             `<<-` <- base::`<<-`
[17:42:39.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.553]                   3L)]
[17:42:39.553]             }
[17:42:39.553]             function(cond) {
[17:42:39.553]                 is_error <- inherits(cond, "error")
[17:42:39.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.553]                   NULL)
[17:42:39.553]                 if (is_error) {
[17:42:39.553]                   sessionInformation <- function() {
[17:42:39.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.553]                       search = base::search(), system = base::Sys.info())
[17:42:39.553]                   }
[17:42:39.553]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.553]                     cond$call), session = sessionInformation(), 
[17:42:39.553]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.553]                   signalCondition(cond)
[17:42:39.553]                 }
[17:42:39.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.553]                 "immediateCondition"))) {
[17:42:39.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.553]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.553]                   if (TRUE && !signal) {
[17:42:39.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.553]                     {
[17:42:39.553]                       inherits <- base::inherits
[17:42:39.553]                       invokeRestart <- base::invokeRestart
[17:42:39.553]                       is.null <- base::is.null
[17:42:39.553]                       muffled <- FALSE
[17:42:39.553]                       if (inherits(cond, "message")) {
[17:42:39.553]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.553]                         if (muffled) 
[17:42:39.553]                           invokeRestart("muffleMessage")
[17:42:39.553]                       }
[17:42:39.553]                       else if (inherits(cond, "warning")) {
[17:42:39.553]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.553]                         if (muffled) 
[17:42:39.553]                           invokeRestart("muffleWarning")
[17:42:39.553]                       }
[17:42:39.553]                       else if (inherits(cond, "condition")) {
[17:42:39.553]                         if (!is.null(pattern)) {
[17:42:39.553]                           computeRestarts <- base::computeRestarts
[17:42:39.553]                           grepl <- base::grepl
[17:42:39.553]                           restarts <- computeRestarts(cond)
[17:42:39.553]                           for (restart in restarts) {
[17:42:39.553]                             name <- restart$name
[17:42:39.553]                             if (is.null(name)) 
[17:42:39.553]                               next
[17:42:39.553]                             if (!grepl(pattern, name)) 
[17:42:39.553]                               next
[17:42:39.553]                             invokeRestart(restart)
[17:42:39.553]                             muffled <- TRUE
[17:42:39.553]                             break
[17:42:39.553]                           }
[17:42:39.553]                         }
[17:42:39.553]                       }
[17:42:39.553]                       invisible(muffled)
[17:42:39.553]                     }
[17:42:39.553]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.553]                   }
[17:42:39.553]                 }
[17:42:39.553]                 else {
[17:42:39.553]                   if (TRUE) {
[17:42:39.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.553]                     {
[17:42:39.553]                       inherits <- base::inherits
[17:42:39.553]                       invokeRestart <- base::invokeRestart
[17:42:39.553]                       is.null <- base::is.null
[17:42:39.553]                       muffled <- FALSE
[17:42:39.553]                       if (inherits(cond, "message")) {
[17:42:39.553]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.553]                         if (muffled) 
[17:42:39.553]                           invokeRestart("muffleMessage")
[17:42:39.553]                       }
[17:42:39.553]                       else if (inherits(cond, "warning")) {
[17:42:39.553]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.553]                         if (muffled) 
[17:42:39.553]                           invokeRestart("muffleWarning")
[17:42:39.553]                       }
[17:42:39.553]                       else if (inherits(cond, "condition")) {
[17:42:39.553]                         if (!is.null(pattern)) {
[17:42:39.553]                           computeRestarts <- base::computeRestarts
[17:42:39.553]                           grepl <- base::grepl
[17:42:39.553]                           restarts <- computeRestarts(cond)
[17:42:39.553]                           for (restart in restarts) {
[17:42:39.553]                             name <- restart$name
[17:42:39.553]                             if (is.null(name)) 
[17:42:39.553]                               next
[17:42:39.553]                             if (!grepl(pattern, name)) 
[17:42:39.553]                               next
[17:42:39.553]                             invokeRestart(restart)
[17:42:39.553]                             muffled <- TRUE
[17:42:39.553]                             break
[17:42:39.553]                           }
[17:42:39.553]                         }
[17:42:39.553]                       }
[17:42:39.553]                       invisible(muffled)
[17:42:39.553]                     }
[17:42:39.553]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.553]                   }
[17:42:39.553]                 }
[17:42:39.553]             }
[17:42:39.553]         }))
[17:42:39.553]     }, error = function(ex) {
[17:42:39.553]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.553]                 ...future.rng), started = ...future.startTime, 
[17:42:39.553]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.553]             version = "1.8"), class = "FutureResult")
[17:42:39.553]     }, finally = {
[17:42:39.553]         if (!identical(...future.workdir, getwd())) 
[17:42:39.553]             setwd(...future.workdir)
[17:42:39.553]         {
[17:42:39.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.553]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.553]             }
[17:42:39.553]             base::options(...future.oldOptions)
[17:42:39.553]             if (.Platform$OS.type == "windows") {
[17:42:39.553]                 old_names <- names(...future.oldEnvVars)
[17:42:39.553]                 envs <- base::Sys.getenv()
[17:42:39.553]                 names <- names(envs)
[17:42:39.553]                 common <- intersect(names, old_names)
[17:42:39.553]                 added <- setdiff(names, old_names)
[17:42:39.553]                 removed <- setdiff(old_names, names)
[17:42:39.553]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.553]                   envs[common]]
[17:42:39.553]                 NAMES <- toupper(changed)
[17:42:39.553]                 args <- list()
[17:42:39.553]                 for (kk in seq_along(NAMES)) {
[17:42:39.553]                   name <- changed[[kk]]
[17:42:39.553]                   NAME <- NAMES[[kk]]
[17:42:39.553]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.553]                     next
[17:42:39.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.553]                 }
[17:42:39.553]                 NAMES <- toupper(added)
[17:42:39.553]                 for (kk in seq_along(NAMES)) {
[17:42:39.553]                   name <- added[[kk]]
[17:42:39.553]                   NAME <- NAMES[[kk]]
[17:42:39.553]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.553]                     next
[17:42:39.553]                   args[[name]] <- ""
[17:42:39.553]                 }
[17:42:39.553]                 NAMES <- toupper(removed)
[17:42:39.553]                 for (kk in seq_along(NAMES)) {
[17:42:39.553]                   name <- removed[[kk]]
[17:42:39.553]                   NAME <- NAMES[[kk]]
[17:42:39.553]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.553]                     next
[17:42:39.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.553]                 }
[17:42:39.553]                 if (length(args) > 0) 
[17:42:39.553]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.553]             }
[17:42:39.553]             else {
[17:42:39.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.553]             }
[17:42:39.553]             {
[17:42:39.553]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.553]                   0L) {
[17:42:39.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.553]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.553]                   base::options(opts)
[17:42:39.553]                 }
[17:42:39.553]                 {
[17:42:39.553]                   {
[17:42:39.553]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.553]                     NULL
[17:42:39.553]                   }
[17:42:39.553]                   options(future.plan = NULL)
[17:42:39.553]                   if (is.na(NA_character_)) 
[17:42:39.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.553]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.553]                     envir = parent.frame()) 
[17:42:39.553]                   {
[17:42:39.553]                     default_workers <- missing(workers)
[17:42:39.553]                     if (is.function(workers)) 
[17:42:39.553]                       workers <- workers()
[17:42:39.553]                     workers <- structure(as.integer(workers), 
[17:42:39.553]                       class = class(workers))
[17:42:39.553]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.553]                       1L)
[17:42:39.553]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.553]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.553]                       if (default_workers) 
[17:42:39.553]                         supportsMulticore(warn = TRUE)
[17:42:39.553]                       return(sequential(..., envir = envir))
[17:42:39.553]                     }
[17:42:39.553]                     oopts <- options(mc.cores = workers)
[17:42:39.553]                     on.exit(options(oopts))
[17:42:39.553]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.553]                       envir = envir)
[17:42:39.553]                     if (!future$lazy) 
[17:42:39.553]                       future <- run(future)
[17:42:39.553]                     invisible(future)
[17:42:39.553]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.553]                 }
[17:42:39.553]             }
[17:42:39.553]         }
[17:42:39.553]     })
[17:42:39.553]     if (TRUE) {
[17:42:39.553]         base::sink(type = "output", split = FALSE)
[17:42:39.553]         if (TRUE) {
[17:42:39.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.553]         }
[17:42:39.553]         else {
[17:42:39.553]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.553]         }
[17:42:39.553]         base::close(...future.stdout)
[17:42:39.553]         ...future.stdout <- NULL
[17:42:39.553]     }
[17:42:39.553]     ...future.result$conditions <- ...future.conditions
[17:42:39.553]     ...future.result$finished <- base::Sys.time()
[17:42:39.553]     ...future.result
[17:42:39.553] }
[17:42:39.555] assign_globals() ...
[17:42:39.555] List of 1
[17:42:39.555]  $ x: list()
[17:42:39.555]  - attr(*, "where")=List of 1
[17:42:39.555]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.555]  - attr(*, "resolved")= logi TRUE
[17:42:39.555]  - attr(*, "total_size")= num 0
[17:42:39.555]  - attr(*, "already-done")= logi TRUE
[17:42:39.558] - copied ‘x’ to environment
[17:42:39.558] assign_globals() ... done
[17:42:39.558] requestCore(): workers = 2
[17:42:39.560] MulticoreFuture started
[17:42:39.561] - Launch lazy future ... done
[17:42:39.561] run() for ‘MulticoreFuture’ ... done
[17:42:39.561] plan(): Setting new future strategy stack:
[17:42:39.562] List of future strategies:
[17:42:39.562] 1. sequential:
[17:42:39.562]    - args: function (..., envir = parent.frame())
[17:42:39.562]    - tweaked: FALSE
[17:42:39.562]    - call: NULL
[17:42:39.562] plan(): nbrOfWorkers() = 1
[17:42:39.564] plan(): Setting new future strategy stack:
[17:42:39.565] List of future strategies:
[17:42:39.565] 1. multicore:
[17:42:39.565]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.565]    - tweaked: FALSE
[17:42:39.565]    - call: plan(strategy)
[17:42:39.570] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.571] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.572] Searching for globals...
[17:42:39.574] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.575] Searching for globals ... DONE
[17:42:39.575] Resolving globals: TRUE
[17:42:39.575] Resolving any globals that are futures ...
[17:42:39.575] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:39.575] Resolving any globals that are futures ... DONE
[17:42:39.576] Resolving futures part of globals (recursively) ...
[17:42:39.576] resolve() on list ...
[17:42:39.576]  recursive: 99
[17:42:39.576]  length: 1
[17:42:39.576]  elements: ‘x’
[17:42:39.577]  length: 0 (resolved future 1)
[17:42:39.577] resolve() on list ... DONE
[17:42:39.577] - globals: [1] ‘x’
[17:42:39.577] Resolving futures part of globals (recursively) ... DONE
[17:42:39.577] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.577] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.578] - globals: [1] ‘x’
[17:42:39.578] 
[17:42:39.578] getGlobalsAndPackages() ... DONE
[17:42:39.578] run() for ‘Future’ ...
[17:42:39.578] - state: ‘created’
[17:42:39.579] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.583] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.583] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.583]   - Field: ‘label’
[17:42:39.583]   - Field: ‘local’
[17:42:39.584]   - Field: ‘owner’
[17:42:39.586]   - Field: ‘envir’
[17:42:39.586]   - Field: ‘workers’
[17:42:39.586]   - Field: ‘packages’
[17:42:39.586]   - Field: ‘gc’
[17:42:39.587]   - Field: ‘job’
[17:42:39.587]   - Field: ‘conditions’
[17:42:39.587]   - Field: ‘expr’
[17:42:39.587]   - Field: ‘uuid’
[17:42:39.587]   - Field: ‘seed’
[17:42:39.587]   - Field: ‘version’
[17:42:39.587]   - Field: ‘result’
[17:42:39.588]   - Field: ‘asynchronous’
[17:42:39.588]   - Field: ‘calls’
[17:42:39.588]   - Field: ‘globals’
[17:42:39.588]   - Field: ‘stdout’
[17:42:39.588]   - Field: ‘earlySignal’
[17:42:39.588]   - Field: ‘lazy’
[17:42:39.588]   - Field: ‘state’
[17:42:39.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.589] - Launch lazy future ...
[17:42:39.589] Packages needed by the future expression (n = 0): <none>
[17:42:39.589] Packages needed by future strategies (n = 0): <none>
[17:42:39.590] {
[17:42:39.590]     {
[17:42:39.590]         {
[17:42:39.590]             ...future.startTime <- base::Sys.time()
[17:42:39.590]             {
[17:42:39.590]                 {
[17:42:39.590]                   {
[17:42:39.590]                     {
[17:42:39.590]                       base::local({
[17:42:39.590]                         has_future <- base::requireNamespace("future", 
[17:42:39.590]                           quietly = TRUE)
[17:42:39.590]                         if (has_future) {
[17:42:39.590]                           ns <- base::getNamespace("future")
[17:42:39.590]                           version <- ns[[".package"]][["version"]]
[17:42:39.590]                           if (is.null(version)) 
[17:42:39.590]                             version <- utils::packageVersion("future")
[17:42:39.590]                         }
[17:42:39.590]                         else {
[17:42:39.590]                           version <- NULL
[17:42:39.590]                         }
[17:42:39.590]                         if (!has_future || version < "1.8.0") {
[17:42:39.590]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.590]                             "", base::R.version$version.string), 
[17:42:39.590]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.590]                               "release", "version")], collapse = " "), 
[17:42:39.590]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.590]                             info)
[17:42:39.590]                           info <- base::paste(info, collapse = "; ")
[17:42:39.590]                           if (!has_future) {
[17:42:39.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.590]                               info)
[17:42:39.590]                           }
[17:42:39.590]                           else {
[17:42:39.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.590]                               info, version)
[17:42:39.590]                           }
[17:42:39.590]                           base::stop(msg)
[17:42:39.590]                         }
[17:42:39.590]                       })
[17:42:39.590]                     }
[17:42:39.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.590]                     base::options(mc.cores = 1L)
[17:42:39.590]                   }
[17:42:39.590]                   options(future.plan = NULL)
[17:42:39.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.590]                 }
[17:42:39.590]                 ...future.workdir <- getwd()
[17:42:39.590]             }
[17:42:39.590]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.590]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.590]         }
[17:42:39.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.590]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.590]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.590]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.590]             base::names(...future.oldOptions))
[17:42:39.590]     }
[17:42:39.590]     if (FALSE) {
[17:42:39.590]     }
[17:42:39.590]     else {
[17:42:39.590]         if (TRUE) {
[17:42:39.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.590]                 open = "w")
[17:42:39.590]         }
[17:42:39.590]         else {
[17:42:39.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.590]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.590]         }
[17:42:39.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.590]             base::sink(type = "output", split = FALSE)
[17:42:39.590]             base::close(...future.stdout)
[17:42:39.590]         }, add = TRUE)
[17:42:39.590]     }
[17:42:39.590]     ...future.frame <- base::sys.nframe()
[17:42:39.590]     ...future.conditions <- base::list()
[17:42:39.590]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.590]     if (FALSE) {
[17:42:39.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.590]     }
[17:42:39.590]     ...future.result <- base::tryCatch({
[17:42:39.590]         base::withCallingHandlers({
[17:42:39.590]             ...future.value <- base::withVisible(base::local({
[17:42:39.590]                 withCallingHandlers({
[17:42:39.590]                   {
[17:42:39.590]                     x[["a"]] <- 1
[17:42:39.590]                     x
[17:42:39.590]                   }
[17:42:39.590]                 }, immediateCondition = function(cond) {
[17:42:39.590]                   save_rds <- function (object, pathname, ...) 
[17:42:39.590]                   {
[17:42:39.590]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.590]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.590]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.590]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.590]                         fi_tmp[["mtime"]])
[17:42:39.590]                     }
[17:42:39.590]                     tryCatch({
[17:42:39.590]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.590]                     }, error = function(ex) {
[17:42:39.590]                       msg <- conditionMessage(ex)
[17:42:39.590]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.590]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.590]                         fi_tmp[["mtime"]], msg)
[17:42:39.590]                       ex$message <- msg
[17:42:39.590]                       stop(ex)
[17:42:39.590]                     })
[17:42:39.590]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.590]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.590]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.590]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.590]                       fi <- file.info(pathname)
[17:42:39.590]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.590]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.590]                         fi[["size"]], fi[["mtime"]])
[17:42:39.590]                       stop(msg)
[17:42:39.590]                     }
[17:42:39.590]                     invisible(pathname)
[17:42:39.590]                   }
[17:42:39.590]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.590]                     rootPath = tempdir()) 
[17:42:39.590]                   {
[17:42:39.590]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.590]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.590]                       tmpdir = path, fileext = ".rds")
[17:42:39.590]                     save_rds(obj, file)
[17:42:39.590]                   }
[17:42:39.590]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.590]                   {
[17:42:39.590]                     inherits <- base::inherits
[17:42:39.590]                     invokeRestart <- base::invokeRestart
[17:42:39.590]                     is.null <- base::is.null
[17:42:39.590]                     muffled <- FALSE
[17:42:39.590]                     if (inherits(cond, "message")) {
[17:42:39.590]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.590]                       if (muffled) 
[17:42:39.590]                         invokeRestart("muffleMessage")
[17:42:39.590]                     }
[17:42:39.590]                     else if (inherits(cond, "warning")) {
[17:42:39.590]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.590]                       if (muffled) 
[17:42:39.590]                         invokeRestart("muffleWarning")
[17:42:39.590]                     }
[17:42:39.590]                     else if (inherits(cond, "condition")) {
[17:42:39.590]                       if (!is.null(pattern)) {
[17:42:39.590]                         computeRestarts <- base::computeRestarts
[17:42:39.590]                         grepl <- base::grepl
[17:42:39.590]                         restarts <- computeRestarts(cond)
[17:42:39.590]                         for (restart in restarts) {
[17:42:39.590]                           name <- restart$name
[17:42:39.590]                           if (is.null(name)) 
[17:42:39.590]                             next
[17:42:39.590]                           if (!grepl(pattern, name)) 
[17:42:39.590]                             next
[17:42:39.590]                           invokeRestart(restart)
[17:42:39.590]                           muffled <- TRUE
[17:42:39.590]                           break
[17:42:39.590]                         }
[17:42:39.590]                       }
[17:42:39.590]                     }
[17:42:39.590]                     invisible(muffled)
[17:42:39.590]                   }
[17:42:39.590]                   muffleCondition(cond)
[17:42:39.590]                 })
[17:42:39.590]             }))
[17:42:39.590]             future::FutureResult(value = ...future.value$value, 
[17:42:39.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.590]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.590]                     ...future.globalenv.names))
[17:42:39.590]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.590]         }, condition = base::local({
[17:42:39.590]             c <- base::c
[17:42:39.590]             inherits <- base::inherits
[17:42:39.590]             invokeRestart <- base::invokeRestart
[17:42:39.590]             length <- base::length
[17:42:39.590]             list <- base::list
[17:42:39.590]             seq.int <- base::seq.int
[17:42:39.590]             signalCondition <- base::signalCondition
[17:42:39.590]             sys.calls <- base::sys.calls
[17:42:39.590]             `[[` <- base::`[[`
[17:42:39.590]             `+` <- base::`+`
[17:42:39.590]             `<<-` <- base::`<<-`
[17:42:39.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.590]                   3L)]
[17:42:39.590]             }
[17:42:39.590]             function(cond) {
[17:42:39.590]                 is_error <- inherits(cond, "error")
[17:42:39.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.590]                   NULL)
[17:42:39.590]                 if (is_error) {
[17:42:39.590]                   sessionInformation <- function() {
[17:42:39.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.590]                       search = base::search(), system = base::Sys.info())
[17:42:39.590]                   }
[17:42:39.590]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.590]                     cond$call), session = sessionInformation(), 
[17:42:39.590]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.590]                   signalCondition(cond)
[17:42:39.590]                 }
[17:42:39.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.590]                 "immediateCondition"))) {
[17:42:39.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.590]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.590]                   if (TRUE && !signal) {
[17:42:39.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.590]                     {
[17:42:39.590]                       inherits <- base::inherits
[17:42:39.590]                       invokeRestart <- base::invokeRestart
[17:42:39.590]                       is.null <- base::is.null
[17:42:39.590]                       muffled <- FALSE
[17:42:39.590]                       if (inherits(cond, "message")) {
[17:42:39.590]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.590]                         if (muffled) 
[17:42:39.590]                           invokeRestart("muffleMessage")
[17:42:39.590]                       }
[17:42:39.590]                       else if (inherits(cond, "warning")) {
[17:42:39.590]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.590]                         if (muffled) 
[17:42:39.590]                           invokeRestart("muffleWarning")
[17:42:39.590]                       }
[17:42:39.590]                       else if (inherits(cond, "condition")) {
[17:42:39.590]                         if (!is.null(pattern)) {
[17:42:39.590]                           computeRestarts <- base::computeRestarts
[17:42:39.590]                           grepl <- base::grepl
[17:42:39.590]                           restarts <- computeRestarts(cond)
[17:42:39.590]                           for (restart in restarts) {
[17:42:39.590]                             name <- restart$name
[17:42:39.590]                             if (is.null(name)) 
[17:42:39.590]                               next
[17:42:39.590]                             if (!grepl(pattern, name)) 
[17:42:39.590]                               next
[17:42:39.590]                             invokeRestart(restart)
[17:42:39.590]                             muffled <- TRUE
[17:42:39.590]                             break
[17:42:39.590]                           }
[17:42:39.590]                         }
[17:42:39.590]                       }
[17:42:39.590]                       invisible(muffled)
[17:42:39.590]                     }
[17:42:39.590]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.590]                   }
[17:42:39.590]                 }
[17:42:39.590]                 else {
[17:42:39.590]                   if (TRUE) {
[17:42:39.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.590]                     {
[17:42:39.590]                       inherits <- base::inherits
[17:42:39.590]                       invokeRestart <- base::invokeRestart
[17:42:39.590]                       is.null <- base::is.null
[17:42:39.590]                       muffled <- FALSE
[17:42:39.590]                       if (inherits(cond, "message")) {
[17:42:39.590]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.590]                         if (muffled) 
[17:42:39.590]                           invokeRestart("muffleMessage")
[17:42:39.590]                       }
[17:42:39.590]                       else if (inherits(cond, "warning")) {
[17:42:39.590]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.590]                         if (muffled) 
[17:42:39.590]                           invokeRestart("muffleWarning")
[17:42:39.590]                       }
[17:42:39.590]                       else if (inherits(cond, "condition")) {
[17:42:39.590]                         if (!is.null(pattern)) {
[17:42:39.590]                           computeRestarts <- base::computeRestarts
[17:42:39.590]                           grepl <- base::grepl
[17:42:39.590]                           restarts <- computeRestarts(cond)
[17:42:39.590]                           for (restart in restarts) {
[17:42:39.590]                             name <- restart$name
[17:42:39.590]                             if (is.null(name)) 
[17:42:39.590]                               next
[17:42:39.590]                             if (!grepl(pattern, name)) 
[17:42:39.590]                               next
[17:42:39.590]                             invokeRestart(restart)
[17:42:39.590]                             muffled <- TRUE
[17:42:39.590]                             break
[17:42:39.590]                           }
[17:42:39.590]                         }
[17:42:39.590]                       }
[17:42:39.590]                       invisible(muffled)
[17:42:39.590]                     }
[17:42:39.590]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.590]                   }
[17:42:39.590]                 }
[17:42:39.590]             }
[17:42:39.590]         }))
[17:42:39.590]     }, error = function(ex) {
[17:42:39.590]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.590]                 ...future.rng), started = ...future.startTime, 
[17:42:39.590]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.590]             version = "1.8"), class = "FutureResult")
[17:42:39.590]     }, finally = {
[17:42:39.590]         if (!identical(...future.workdir, getwd())) 
[17:42:39.590]             setwd(...future.workdir)
[17:42:39.590]         {
[17:42:39.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.590]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.590]             }
[17:42:39.590]             base::options(...future.oldOptions)
[17:42:39.590]             if (.Platform$OS.type == "windows") {
[17:42:39.590]                 old_names <- names(...future.oldEnvVars)
[17:42:39.590]                 envs <- base::Sys.getenv()
[17:42:39.590]                 names <- names(envs)
[17:42:39.590]                 common <- intersect(names, old_names)
[17:42:39.590]                 added <- setdiff(names, old_names)
[17:42:39.590]                 removed <- setdiff(old_names, names)
[17:42:39.590]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.590]                   envs[common]]
[17:42:39.590]                 NAMES <- toupper(changed)
[17:42:39.590]                 args <- list()
[17:42:39.590]                 for (kk in seq_along(NAMES)) {
[17:42:39.590]                   name <- changed[[kk]]
[17:42:39.590]                   NAME <- NAMES[[kk]]
[17:42:39.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.590]                     next
[17:42:39.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.590]                 }
[17:42:39.590]                 NAMES <- toupper(added)
[17:42:39.590]                 for (kk in seq_along(NAMES)) {
[17:42:39.590]                   name <- added[[kk]]
[17:42:39.590]                   NAME <- NAMES[[kk]]
[17:42:39.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.590]                     next
[17:42:39.590]                   args[[name]] <- ""
[17:42:39.590]                 }
[17:42:39.590]                 NAMES <- toupper(removed)
[17:42:39.590]                 for (kk in seq_along(NAMES)) {
[17:42:39.590]                   name <- removed[[kk]]
[17:42:39.590]                   NAME <- NAMES[[kk]]
[17:42:39.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.590]                     next
[17:42:39.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.590]                 }
[17:42:39.590]                 if (length(args) > 0) 
[17:42:39.590]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.590]             }
[17:42:39.590]             else {
[17:42:39.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.590]             }
[17:42:39.590]             {
[17:42:39.590]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.590]                   0L) {
[17:42:39.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.590]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.590]                   base::options(opts)
[17:42:39.590]                 }
[17:42:39.590]                 {
[17:42:39.590]                   {
[17:42:39.590]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.590]                     NULL
[17:42:39.590]                   }
[17:42:39.590]                   options(future.plan = NULL)
[17:42:39.590]                   if (is.na(NA_character_)) 
[17:42:39.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.590]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.590]                     envir = parent.frame()) 
[17:42:39.590]                   {
[17:42:39.590]                     default_workers <- missing(workers)
[17:42:39.590]                     if (is.function(workers)) 
[17:42:39.590]                       workers <- workers()
[17:42:39.590]                     workers <- structure(as.integer(workers), 
[17:42:39.590]                       class = class(workers))
[17:42:39.590]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.590]                       1L)
[17:42:39.590]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.590]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.590]                       if (default_workers) 
[17:42:39.590]                         supportsMulticore(warn = TRUE)
[17:42:39.590]                       return(sequential(..., envir = envir))
[17:42:39.590]                     }
[17:42:39.590]                     oopts <- options(mc.cores = workers)
[17:42:39.590]                     on.exit(options(oopts))
[17:42:39.590]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.590]                       envir = envir)
[17:42:39.590]                     if (!future$lazy) 
[17:42:39.590]                       future <- run(future)
[17:42:39.590]                     invisible(future)
[17:42:39.590]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.590]                 }
[17:42:39.590]             }
[17:42:39.590]         }
[17:42:39.590]     })
[17:42:39.590]     if (TRUE) {
[17:42:39.590]         base::sink(type = "output", split = FALSE)
[17:42:39.590]         if (TRUE) {
[17:42:39.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.590]         }
[17:42:39.590]         else {
[17:42:39.590]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.590]         }
[17:42:39.590]         base::close(...future.stdout)
[17:42:39.590]         ...future.stdout <- NULL
[17:42:39.590]     }
[17:42:39.590]     ...future.result$conditions <- ...future.conditions
[17:42:39.590]     ...future.result$finished <- base::Sys.time()
[17:42:39.590]     ...future.result
[17:42:39.590] }
[17:42:39.592] assign_globals() ...
[17:42:39.592] List of 1
[17:42:39.592]  $ x: list()
[17:42:39.592]  - attr(*, "where")=List of 1
[17:42:39.592]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.592]  - attr(*, "resolved")= logi TRUE
[17:42:39.592]  - attr(*, "total_size")= num 0
[17:42:39.592]  - attr(*, "already-done")= logi TRUE
[17:42:39.595] - copied ‘x’ to environment
[17:42:39.596] assign_globals() ... done
[17:42:39.596] requestCore(): workers = 2
[17:42:39.598] MulticoreFuture started
[17:42:39.598] - Launch lazy future ... done
[17:42:39.598] run() for ‘MulticoreFuture’ ... done
[17:42:39.599] plan(): Setting new future strategy stack:
[17:42:39.599] List of future strategies:
[17:42:39.599] 1. sequential:
[17:42:39.599]    - args: function (..., envir = parent.frame())
[17:42:39.599]    - tweaked: FALSE
[17:42:39.599]    - call: NULL
[17:42:39.600] plan(): nbrOfWorkers() = 1
[17:42:39.602] plan(): Setting new future strategy stack:
[17:42:39.602] List of future strategies:
[17:42:39.602] 1. multicore:
[17:42:39.602]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.602]    - tweaked: FALSE
[17:42:39.602]    - call: plan(strategy)
[17:42:39.607] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.608] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.608] Searching for globals...
[17:42:39.611] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.611] Searching for globals ... DONE
[17:42:39.612] Resolving globals: TRUE
[17:42:39.612] Resolving any globals that are futures ...
[17:42:39.612] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.612] Resolving any globals that are futures ... DONE
[17:42:39.612] Resolving futures part of globals (recursively) ...
[17:42:39.613] resolve() on list ...
[17:42:39.613]  recursive: 99
[17:42:39.613]  length: 1
[17:42:39.613]  elements: ‘x’
[17:42:39.613]  length: 0 (resolved future 1)
[17:42:39.613] resolve() on list ... DONE
[17:42:39.614] - globals: [1] ‘x’
[17:42:39.614] Resolving futures part of globals (recursively) ... DONE
[17:42:39.614] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.614] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.614] - globals: [1] ‘x’
[17:42:39.615] 
[17:42:39.615] getGlobalsAndPackages() ... DONE
[17:42:39.615] run() for ‘Future’ ...
[17:42:39.615] - state: ‘created’
[17:42:39.615] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.619] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.619] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.620]   - Field: ‘label’
[17:42:39.620]   - Field: ‘local’
[17:42:39.620]   - Field: ‘owner’
[17:42:39.620]   - Field: ‘envir’
[17:42:39.620]   - Field: ‘workers’
[17:42:39.620]   - Field: ‘packages’
[17:42:39.620]   - Field: ‘gc’
[17:42:39.620]   - Field: ‘job’
[17:42:39.621]   - Field: ‘conditions’
[17:42:39.621]   - Field: ‘expr’
[17:42:39.621]   - Field: ‘uuid’
[17:42:39.621]   - Field: ‘seed’
[17:42:39.621]   - Field: ‘version’
[17:42:39.621]   - Field: ‘result’
[17:42:39.621]   - Field: ‘asynchronous’
[17:42:39.621]   - Field: ‘calls’
[17:42:39.621]   - Field: ‘globals’
[17:42:39.622]   - Field: ‘stdout’
[17:42:39.622]   - Field: ‘earlySignal’
[17:42:39.622]   - Field: ‘lazy’
[17:42:39.622]   - Field: ‘state’
[17:42:39.622] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.622] - Launch lazy future ...
[17:42:39.622] Packages needed by the future expression (n = 0): <none>
[17:42:39.623] Packages needed by future strategies (n = 0): <none>
[17:42:39.623] {
[17:42:39.623]     {
[17:42:39.623]         {
[17:42:39.623]             ...future.startTime <- base::Sys.time()
[17:42:39.623]             {
[17:42:39.623]                 {
[17:42:39.623]                   {
[17:42:39.623]                     {
[17:42:39.623]                       base::local({
[17:42:39.623]                         has_future <- base::requireNamespace("future", 
[17:42:39.623]                           quietly = TRUE)
[17:42:39.623]                         if (has_future) {
[17:42:39.623]                           ns <- base::getNamespace("future")
[17:42:39.623]                           version <- ns[[".package"]][["version"]]
[17:42:39.623]                           if (is.null(version)) 
[17:42:39.623]                             version <- utils::packageVersion("future")
[17:42:39.623]                         }
[17:42:39.623]                         else {
[17:42:39.623]                           version <- NULL
[17:42:39.623]                         }
[17:42:39.623]                         if (!has_future || version < "1.8.0") {
[17:42:39.623]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.623]                             "", base::R.version$version.string), 
[17:42:39.623]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.623]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.623]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.623]                               "release", "version")], collapse = " "), 
[17:42:39.623]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.623]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.623]                             info)
[17:42:39.623]                           info <- base::paste(info, collapse = "; ")
[17:42:39.623]                           if (!has_future) {
[17:42:39.623]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.623]                               info)
[17:42:39.623]                           }
[17:42:39.623]                           else {
[17:42:39.623]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.623]                               info, version)
[17:42:39.623]                           }
[17:42:39.623]                           base::stop(msg)
[17:42:39.623]                         }
[17:42:39.623]                       })
[17:42:39.623]                     }
[17:42:39.623]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.623]                     base::options(mc.cores = 1L)
[17:42:39.623]                   }
[17:42:39.623]                   options(future.plan = NULL)
[17:42:39.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.623]                 }
[17:42:39.623]                 ...future.workdir <- getwd()
[17:42:39.623]             }
[17:42:39.623]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.623]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.623]         }
[17:42:39.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.623]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.623]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.623]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.623]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.623]             base::names(...future.oldOptions))
[17:42:39.623]     }
[17:42:39.623]     if (FALSE) {
[17:42:39.623]     }
[17:42:39.623]     else {
[17:42:39.623]         if (TRUE) {
[17:42:39.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.623]                 open = "w")
[17:42:39.623]         }
[17:42:39.623]         else {
[17:42:39.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.623]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.623]         }
[17:42:39.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.623]             base::sink(type = "output", split = FALSE)
[17:42:39.623]             base::close(...future.stdout)
[17:42:39.623]         }, add = TRUE)
[17:42:39.623]     }
[17:42:39.623]     ...future.frame <- base::sys.nframe()
[17:42:39.623]     ...future.conditions <- base::list()
[17:42:39.623]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.623]     if (FALSE) {
[17:42:39.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.623]     }
[17:42:39.623]     ...future.result <- base::tryCatch({
[17:42:39.623]         base::withCallingHandlers({
[17:42:39.623]             ...future.value <- base::withVisible(base::local({
[17:42:39.623]                 withCallingHandlers({
[17:42:39.623]                   {
[17:42:39.623]                     x["a"] <- list(1)
[17:42:39.623]                     x
[17:42:39.623]                   }
[17:42:39.623]                 }, immediateCondition = function(cond) {
[17:42:39.623]                   save_rds <- function (object, pathname, ...) 
[17:42:39.623]                   {
[17:42:39.623]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.623]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.623]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.623]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.623]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.623]                         fi_tmp[["mtime"]])
[17:42:39.623]                     }
[17:42:39.623]                     tryCatch({
[17:42:39.623]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.623]                     }, error = function(ex) {
[17:42:39.623]                       msg <- conditionMessage(ex)
[17:42:39.623]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.623]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.623]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.623]                         fi_tmp[["mtime"]], msg)
[17:42:39.623]                       ex$message <- msg
[17:42:39.623]                       stop(ex)
[17:42:39.623]                     })
[17:42:39.623]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.623]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.623]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.623]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.623]                       fi <- file.info(pathname)
[17:42:39.623]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.623]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.623]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.623]                         fi[["size"]], fi[["mtime"]])
[17:42:39.623]                       stop(msg)
[17:42:39.623]                     }
[17:42:39.623]                     invisible(pathname)
[17:42:39.623]                   }
[17:42:39.623]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.623]                     rootPath = tempdir()) 
[17:42:39.623]                   {
[17:42:39.623]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.623]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.623]                       tmpdir = path, fileext = ".rds")
[17:42:39.623]                     save_rds(obj, file)
[17:42:39.623]                   }
[17:42:39.623]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.623]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.623]                   {
[17:42:39.623]                     inherits <- base::inherits
[17:42:39.623]                     invokeRestart <- base::invokeRestart
[17:42:39.623]                     is.null <- base::is.null
[17:42:39.623]                     muffled <- FALSE
[17:42:39.623]                     if (inherits(cond, "message")) {
[17:42:39.623]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.623]                       if (muffled) 
[17:42:39.623]                         invokeRestart("muffleMessage")
[17:42:39.623]                     }
[17:42:39.623]                     else if (inherits(cond, "warning")) {
[17:42:39.623]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.623]                       if (muffled) 
[17:42:39.623]                         invokeRestart("muffleWarning")
[17:42:39.623]                     }
[17:42:39.623]                     else if (inherits(cond, "condition")) {
[17:42:39.623]                       if (!is.null(pattern)) {
[17:42:39.623]                         computeRestarts <- base::computeRestarts
[17:42:39.623]                         grepl <- base::grepl
[17:42:39.623]                         restarts <- computeRestarts(cond)
[17:42:39.623]                         for (restart in restarts) {
[17:42:39.623]                           name <- restart$name
[17:42:39.623]                           if (is.null(name)) 
[17:42:39.623]                             next
[17:42:39.623]                           if (!grepl(pattern, name)) 
[17:42:39.623]                             next
[17:42:39.623]                           invokeRestart(restart)
[17:42:39.623]                           muffled <- TRUE
[17:42:39.623]                           break
[17:42:39.623]                         }
[17:42:39.623]                       }
[17:42:39.623]                     }
[17:42:39.623]                     invisible(muffled)
[17:42:39.623]                   }
[17:42:39.623]                   muffleCondition(cond)
[17:42:39.623]                 })
[17:42:39.623]             }))
[17:42:39.623]             future::FutureResult(value = ...future.value$value, 
[17:42:39.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.623]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.623]                     ...future.globalenv.names))
[17:42:39.623]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.623]         }, condition = base::local({
[17:42:39.623]             c <- base::c
[17:42:39.623]             inherits <- base::inherits
[17:42:39.623]             invokeRestart <- base::invokeRestart
[17:42:39.623]             length <- base::length
[17:42:39.623]             list <- base::list
[17:42:39.623]             seq.int <- base::seq.int
[17:42:39.623]             signalCondition <- base::signalCondition
[17:42:39.623]             sys.calls <- base::sys.calls
[17:42:39.623]             `[[` <- base::`[[`
[17:42:39.623]             `+` <- base::`+`
[17:42:39.623]             `<<-` <- base::`<<-`
[17:42:39.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.623]                   3L)]
[17:42:39.623]             }
[17:42:39.623]             function(cond) {
[17:42:39.623]                 is_error <- inherits(cond, "error")
[17:42:39.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.623]                   NULL)
[17:42:39.623]                 if (is_error) {
[17:42:39.623]                   sessionInformation <- function() {
[17:42:39.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.623]                       search = base::search(), system = base::Sys.info())
[17:42:39.623]                   }
[17:42:39.623]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.623]                     cond$call), session = sessionInformation(), 
[17:42:39.623]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.623]                   signalCondition(cond)
[17:42:39.623]                 }
[17:42:39.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.623]                 "immediateCondition"))) {
[17:42:39.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.623]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.623]                   if (TRUE && !signal) {
[17:42:39.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.623]                     {
[17:42:39.623]                       inherits <- base::inherits
[17:42:39.623]                       invokeRestart <- base::invokeRestart
[17:42:39.623]                       is.null <- base::is.null
[17:42:39.623]                       muffled <- FALSE
[17:42:39.623]                       if (inherits(cond, "message")) {
[17:42:39.623]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.623]                         if (muffled) 
[17:42:39.623]                           invokeRestart("muffleMessage")
[17:42:39.623]                       }
[17:42:39.623]                       else if (inherits(cond, "warning")) {
[17:42:39.623]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.623]                         if (muffled) 
[17:42:39.623]                           invokeRestart("muffleWarning")
[17:42:39.623]                       }
[17:42:39.623]                       else if (inherits(cond, "condition")) {
[17:42:39.623]                         if (!is.null(pattern)) {
[17:42:39.623]                           computeRestarts <- base::computeRestarts
[17:42:39.623]                           grepl <- base::grepl
[17:42:39.623]                           restarts <- computeRestarts(cond)
[17:42:39.623]                           for (restart in restarts) {
[17:42:39.623]                             name <- restart$name
[17:42:39.623]                             if (is.null(name)) 
[17:42:39.623]                               next
[17:42:39.623]                             if (!grepl(pattern, name)) 
[17:42:39.623]                               next
[17:42:39.623]                             invokeRestart(restart)
[17:42:39.623]                             muffled <- TRUE
[17:42:39.623]                             break
[17:42:39.623]                           }
[17:42:39.623]                         }
[17:42:39.623]                       }
[17:42:39.623]                       invisible(muffled)
[17:42:39.623]                     }
[17:42:39.623]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.623]                   }
[17:42:39.623]                 }
[17:42:39.623]                 else {
[17:42:39.623]                   if (TRUE) {
[17:42:39.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.623]                     {
[17:42:39.623]                       inherits <- base::inherits
[17:42:39.623]                       invokeRestart <- base::invokeRestart
[17:42:39.623]                       is.null <- base::is.null
[17:42:39.623]                       muffled <- FALSE
[17:42:39.623]                       if (inherits(cond, "message")) {
[17:42:39.623]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.623]                         if (muffled) 
[17:42:39.623]                           invokeRestart("muffleMessage")
[17:42:39.623]                       }
[17:42:39.623]                       else if (inherits(cond, "warning")) {
[17:42:39.623]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.623]                         if (muffled) 
[17:42:39.623]                           invokeRestart("muffleWarning")
[17:42:39.623]                       }
[17:42:39.623]                       else if (inherits(cond, "condition")) {
[17:42:39.623]                         if (!is.null(pattern)) {
[17:42:39.623]                           computeRestarts <- base::computeRestarts
[17:42:39.623]                           grepl <- base::grepl
[17:42:39.623]                           restarts <- computeRestarts(cond)
[17:42:39.623]                           for (restart in restarts) {
[17:42:39.623]                             name <- restart$name
[17:42:39.623]                             if (is.null(name)) 
[17:42:39.623]                               next
[17:42:39.623]                             if (!grepl(pattern, name)) 
[17:42:39.623]                               next
[17:42:39.623]                             invokeRestart(restart)
[17:42:39.623]                             muffled <- TRUE
[17:42:39.623]                             break
[17:42:39.623]                           }
[17:42:39.623]                         }
[17:42:39.623]                       }
[17:42:39.623]                       invisible(muffled)
[17:42:39.623]                     }
[17:42:39.623]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.623]                   }
[17:42:39.623]                 }
[17:42:39.623]             }
[17:42:39.623]         }))
[17:42:39.623]     }, error = function(ex) {
[17:42:39.623]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.623]                 ...future.rng), started = ...future.startTime, 
[17:42:39.623]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.623]             version = "1.8"), class = "FutureResult")
[17:42:39.623]     }, finally = {
[17:42:39.623]         if (!identical(...future.workdir, getwd())) 
[17:42:39.623]             setwd(...future.workdir)
[17:42:39.623]         {
[17:42:39.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.623]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.623]             }
[17:42:39.623]             base::options(...future.oldOptions)
[17:42:39.623]             if (.Platform$OS.type == "windows") {
[17:42:39.623]                 old_names <- names(...future.oldEnvVars)
[17:42:39.623]                 envs <- base::Sys.getenv()
[17:42:39.623]                 names <- names(envs)
[17:42:39.623]                 common <- intersect(names, old_names)
[17:42:39.623]                 added <- setdiff(names, old_names)
[17:42:39.623]                 removed <- setdiff(old_names, names)
[17:42:39.623]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.623]                   envs[common]]
[17:42:39.623]                 NAMES <- toupper(changed)
[17:42:39.623]                 args <- list()
[17:42:39.623]                 for (kk in seq_along(NAMES)) {
[17:42:39.623]                   name <- changed[[kk]]
[17:42:39.623]                   NAME <- NAMES[[kk]]
[17:42:39.623]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.623]                     next
[17:42:39.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.623]                 }
[17:42:39.623]                 NAMES <- toupper(added)
[17:42:39.623]                 for (kk in seq_along(NAMES)) {
[17:42:39.623]                   name <- added[[kk]]
[17:42:39.623]                   NAME <- NAMES[[kk]]
[17:42:39.623]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.623]                     next
[17:42:39.623]                   args[[name]] <- ""
[17:42:39.623]                 }
[17:42:39.623]                 NAMES <- toupper(removed)
[17:42:39.623]                 for (kk in seq_along(NAMES)) {
[17:42:39.623]                   name <- removed[[kk]]
[17:42:39.623]                   NAME <- NAMES[[kk]]
[17:42:39.623]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.623]                     next
[17:42:39.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.623]                 }
[17:42:39.623]                 if (length(args) > 0) 
[17:42:39.623]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.623]             }
[17:42:39.623]             else {
[17:42:39.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.623]             }
[17:42:39.623]             {
[17:42:39.623]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.623]                   0L) {
[17:42:39.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.623]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.623]                   base::options(opts)
[17:42:39.623]                 }
[17:42:39.623]                 {
[17:42:39.623]                   {
[17:42:39.623]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.623]                     NULL
[17:42:39.623]                   }
[17:42:39.623]                   options(future.plan = NULL)
[17:42:39.623]                   if (is.na(NA_character_)) 
[17:42:39.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.623]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.623]                     envir = parent.frame()) 
[17:42:39.623]                   {
[17:42:39.623]                     default_workers <- missing(workers)
[17:42:39.623]                     if (is.function(workers)) 
[17:42:39.623]                       workers <- workers()
[17:42:39.623]                     workers <- structure(as.integer(workers), 
[17:42:39.623]                       class = class(workers))
[17:42:39.623]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.623]                       1L)
[17:42:39.623]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.623]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.623]                       if (default_workers) 
[17:42:39.623]                         supportsMulticore(warn = TRUE)
[17:42:39.623]                       return(sequential(..., envir = envir))
[17:42:39.623]                     }
[17:42:39.623]                     oopts <- options(mc.cores = workers)
[17:42:39.623]                     on.exit(options(oopts))
[17:42:39.623]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.623]                       envir = envir)
[17:42:39.623]                     if (!future$lazy) 
[17:42:39.623]                       future <- run(future)
[17:42:39.623]                     invisible(future)
[17:42:39.623]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.623]                 }
[17:42:39.623]             }
[17:42:39.623]         }
[17:42:39.623]     })
[17:42:39.623]     if (TRUE) {
[17:42:39.623]         base::sink(type = "output", split = FALSE)
[17:42:39.623]         if (TRUE) {
[17:42:39.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.623]         }
[17:42:39.623]         else {
[17:42:39.623]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.623]         }
[17:42:39.623]         base::close(...future.stdout)
[17:42:39.623]         ...future.stdout <- NULL
[17:42:39.623]     }
[17:42:39.623]     ...future.result$conditions <- ...future.conditions
[17:42:39.623]     ...future.result$finished <- base::Sys.time()
[17:42:39.623]     ...future.result
[17:42:39.623] }
[17:42:39.626] assign_globals() ...
[17:42:39.626] List of 1
[17:42:39.626]  $ x: list()
[17:42:39.626]  - attr(*, "where")=List of 1
[17:42:39.626]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.626]  - attr(*, "resolved")= logi TRUE
[17:42:39.626]  - attr(*, "total_size")= num 0
[17:42:39.626]  - attr(*, "already-done")= logi TRUE
[17:42:39.629] - copied ‘x’ to environment
[17:42:39.629] assign_globals() ... done
[17:42:39.629] requestCore(): workers = 2
[17:42:39.631] MulticoreFuture started
[17:42:39.631] - Launch lazy future ... done
[17:42:39.631] run() for ‘MulticoreFuture’ ... done
[17:42:39.632] plan(): Setting new future strategy stack:
[17:42:39.632] List of future strategies:
[17:42:39.632] 1. sequential:
[17:42:39.632]    - args: function (..., envir = parent.frame())
[17:42:39.632]    - tweaked: FALSE
[17:42:39.632]    - call: NULL
[17:42:39.633] plan(): nbrOfWorkers() = 1
[17:42:39.635] plan(): Setting new future strategy stack:
[17:42:39.635] List of future strategies:
[17:42:39.635] 1. multicore:
[17:42:39.635]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.635]    - tweaked: FALSE
[17:42:39.635]    - call: plan(strategy)
[17:42:39.644] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.646] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.646] Searching for globals...
[17:42:39.652] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.652] Searching for globals ... DONE
[17:42:39.652] Resolving globals: TRUE
[17:42:39.652] Resolving any globals that are futures ...
[17:42:39.653] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.653] Resolving any globals that are futures ... DONE
[17:42:39.653] Resolving futures part of globals (recursively) ...
[17:42:39.654] resolve() on list ...
[17:42:39.654]  recursive: 99
[17:42:39.654]  length: 1
[17:42:39.654]  elements: ‘x’
[17:42:39.654]  length: 0 (resolved future 1)
[17:42:39.654] resolve() on list ... DONE
[17:42:39.654] - globals: [1] ‘x’
[17:42:39.655] Resolving futures part of globals (recursively) ... DONE
[17:42:39.655] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.655] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.655] - globals: [1] ‘x’
[17:42:39.655] 
[17:42:39.656] getGlobalsAndPackages() ... DONE
[17:42:39.656] run() for ‘Future’ ...
[17:42:39.656] - state: ‘created’
[17:42:39.656] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.660] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.660] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.660]   - Field: ‘label’
[17:42:39.661]   - Field: ‘local’
[17:42:39.661]   - Field: ‘owner’
[17:42:39.661]   - Field: ‘envir’
[17:42:39.661]   - Field: ‘workers’
[17:42:39.661]   - Field: ‘packages’
[17:42:39.661]   - Field: ‘gc’
[17:42:39.661]   - Field: ‘job’
[17:42:39.661]   - Field: ‘conditions’
[17:42:39.662]   - Field: ‘expr’
[17:42:39.662]   - Field: ‘uuid’
[17:42:39.662]   - Field: ‘seed’
[17:42:39.662]   - Field: ‘version’
[17:42:39.662]   - Field: ‘result’
[17:42:39.662]   - Field: ‘asynchronous’
[17:42:39.662]   - Field: ‘calls’
[17:42:39.662]   - Field: ‘globals’
[17:42:39.662]   - Field: ‘stdout’
[17:42:39.663]   - Field: ‘earlySignal’
[17:42:39.663]   - Field: ‘lazy’
[17:42:39.663]   - Field: ‘state’
[17:42:39.663] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.663] - Launch lazy future ...
[17:42:39.663] Packages needed by the future expression (n = 0): <none>
[17:42:39.663] Packages needed by future strategies (n = 0): <none>
[17:42:39.664] {
[17:42:39.664]     {
[17:42:39.664]         {
[17:42:39.664]             ...future.startTime <- base::Sys.time()
[17:42:39.664]             {
[17:42:39.664]                 {
[17:42:39.664]                   {
[17:42:39.664]                     {
[17:42:39.664]                       base::local({
[17:42:39.664]                         has_future <- base::requireNamespace("future", 
[17:42:39.664]                           quietly = TRUE)
[17:42:39.664]                         if (has_future) {
[17:42:39.664]                           ns <- base::getNamespace("future")
[17:42:39.664]                           version <- ns[[".package"]][["version"]]
[17:42:39.664]                           if (is.null(version)) 
[17:42:39.664]                             version <- utils::packageVersion("future")
[17:42:39.664]                         }
[17:42:39.664]                         else {
[17:42:39.664]                           version <- NULL
[17:42:39.664]                         }
[17:42:39.664]                         if (!has_future || version < "1.8.0") {
[17:42:39.664]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.664]                             "", base::R.version$version.string), 
[17:42:39.664]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.664]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.664]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.664]                               "release", "version")], collapse = " "), 
[17:42:39.664]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.664]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.664]                             info)
[17:42:39.664]                           info <- base::paste(info, collapse = "; ")
[17:42:39.664]                           if (!has_future) {
[17:42:39.664]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.664]                               info)
[17:42:39.664]                           }
[17:42:39.664]                           else {
[17:42:39.664]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.664]                               info, version)
[17:42:39.664]                           }
[17:42:39.664]                           base::stop(msg)
[17:42:39.664]                         }
[17:42:39.664]                       })
[17:42:39.664]                     }
[17:42:39.664]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.664]                     base::options(mc.cores = 1L)
[17:42:39.664]                   }
[17:42:39.664]                   options(future.plan = NULL)
[17:42:39.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.664]                 }
[17:42:39.664]                 ...future.workdir <- getwd()
[17:42:39.664]             }
[17:42:39.664]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.664]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.664]         }
[17:42:39.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.664]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.664]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.664]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.664]             base::names(...future.oldOptions))
[17:42:39.664]     }
[17:42:39.664]     if (FALSE) {
[17:42:39.664]     }
[17:42:39.664]     else {
[17:42:39.664]         if (TRUE) {
[17:42:39.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.664]                 open = "w")
[17:42:39.664]         }
[17:42:39.664]         else {
[17:42:39.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.664]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.664]         }
[17:42:39.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.664]             base::sink(type = "output", split = FALSE)
[17:42:39.664]             base::close(...future.stdout)
[17:42:39.664]         }, add = TRUE)
[17:42:39.664]     }
[17:42:39.664]     ...future.frame <- base::sys.nframe()
[17:42:39.664]     ...future.conditions <- base::list()
[17:42:39.664]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.664]     if (FALSE) {
[17:42:39.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.664]     }
[17:42:39.664]     ...future.result <- base::tryCatch({
[17:42:39.664]         base::withCallingHandlers({
[17:42:39.664]             ...future.value <- base::withVisible(base::local({
[17:42:39.664]                 withCallingHandlers({
[17:42:39.664]                   {
[17:42:39.664]                     x["a"] <- list(1)
[17:42:39.664]                     x
[17:42:39.664]                   }
[17:42:39.664]                 }, immediateCondition = function(cond) {
[17:42:39.664]                   save_rds <- function (object, pathname, ...) 
[17:42:39.664]                   {
[17:42:39.664]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.664]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.664]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.664]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.664]                         fi_tmp[["mtime"]])
[17:42:39.664]                     }
[17:42:39.664]                     tryCatch({
[17:42:39.664]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.664]                     }, error = function(ex) {
[17:42:39.664]                       msg <- conditionMessage(ex)
[17:42:39.664]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.664]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.664]                         fi_tmp[["mtime"]], msg)
[17:42:39.664]                       ex$message <- msg
[17:42:39.664]                       stop(ex)
[17:42:39.664]                     })
[17:42:39.664]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.664]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.664]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.664]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.664]                       fi <- file.info(pathname)
[17:42:39.664]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.664]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.664]                         fi[["size"]], fi[["mtime"]])
[17:42:39.664]                       stop(msg)
[17:42:39.664]                     }
[17:42:39.664]                     invisible(pathname)
[17:42:39.664]                   }
[17:42:39.664]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.664]                     rootPath = tempdir()) 
[17:42:39.664]                   {
[17:42:39.664]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.664]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.664]                       tmpdir = path, fileext = ".rds")
[17:42:39.664]                     save_rds(obj, file)
[17:42:39.664]                   }
[17:42:39.664]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.664]                   {
[17:42:39.664]                     inherits <- base::inherits
[17:42:39.664]                     invokeRestart <- base::invokeRestart
[17:42:39.664]                     is.null <- base::is.null
[17:42:39.664]                     muffled <- FALSE
[17:42:39.664]                     if (inherits(cond, "message")) {
[17:42:39.664]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.664]                       if (muffled) 
[17:42:39.664]                         invokeRestart("muffleMessage")
[17:42:39.664]                     }
[17:42:39.664]                     else if (inherits(cond, "warning")) {
[17:42:39.664]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.664]                       if (muffled) 
[17:42:39.664]                         invokeRestart("muffleWarning")
[17:42:39.664]                     }
[17:42:39.664]                     else if (inherits(cond, "condition")) {
[17:42:39.664]                       if (!is.null(pattern)) {
[17:42:39.664]                         computeRestarts <- base::computeRestarts
[17:42:39.664]                         grepl <- base::grepl
[17:42:39.664]                         restarts <- computeRestarts(cond)
[17:42:39.664]                         for (restart in restarts) {
[17:42:39.664]                           name <- restart$name
[17:42:39.664]                           if (is.null(name)) 
[17:42:39.664]                             next
[17:42:39.664]                           if (!grepl(pattern, name)) 
[17:42:39.664]                             next
[17:42:39.664]                           invokeRestart(restart)
[17:42:39.664]                           muffled <- TRUE
[17:42:39.664]                           break
[17:42:39.664]                         }
[17:42:39.664]                       }
[17:42:39.664]                     }
[17:42:39.664]                     invisible(muffled)
[17:42:39.664]                   }
[17:42:39.664]                   muffleCondition(cond)
[17:42:39.664]                 })
[17:42:39.664]             }))
[17:42:39.664]             future::FutureResult(value = ...future.value$value, 
[17:42:39.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.664]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.664]                     ...future.globalenv.names))
[17:42:39.664]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.664]         }, condition = base::local({
[17:42:39.664]             c <- base::c
[17:42:39.664]             inherits <- base::inherits
[17:42:39.664]             invokeRestart <- base::invokeRestart
[17:42:39.664]             length <- base::length
[17:42:39.664]             list <- base::list
[17:42:39.664]             seq.int <- base::seq.int
[17:42:39.664]             signalCondition <- base::signalCondition
[17:42:39.664]             sys.calls <- base::sys.calls
[17:42:39.664]             `[[` <- base::`[[`
[17:42:39.664]             `+` <- base::`+`
[17:42:39.664]             `<<-` <- base::`<<-`
[17:42:39.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.664]                   3L)]
[17:42:39.664]             }
[17:42:39.664]             function(cond) {
[17:42:39.664]                 is_error <- inherits(cond, "error")
[17:42:39.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.664]                   NULL)
[17:42:39.664]                 if (is_error) {
[17:42:39.664]                   sessionInformation <- function() {
[17:42:39.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.664]                       search = base::search(), system = base::Sys.info())
[17:42:39.664]                   }
[17:42:39.664]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.664]                     cond$call), session = sessionInformation(), 
[17:42:39.664]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.664]                   signalCondition(cond)
[17:42:39.664]                 }
[17:42:39.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.664]                 "immediateCondition"))) {
[17:42:39.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.664]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.664]                   if (TRUE && !signal) {
[17:42:39.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.664]                     {
[17:42:39.664]                       inherits <- base::inherits
[17:42:39.664]                       invokeRestart <- base::invokeRestart
[17:42:39.664]                       is.null <- base::is.null
[17:42:39.664]                       muffled <- FALSE
[17:42:39.664]                       if (inherits(cond, "message")) {
[17:42:39.664]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.664]                         if (muffled) 
[17:42:39.664]                           invokeRestart("muffleMessage")
[17:42:39.664]                       }
[17:42:39.664]                       else if (inherits(cond, "warning")) {
[17:42:39.664]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.664]                         if (muffled) 
[17:42:39.664]                           invokeRestart("muffleWarning")
[17:42:39.664]                       }
[17:42:39.664]                       else if (inherits(cond, "condition")) {
[17:42:39.664]                         if (!is.null(pattern)) {
[17:42:39.664]                           computeRestarts <- base::computeRestarts
[17:42:39.664]                           grepl <- base::grepl
[17:42:39.664]                           restarts <- computeRestarts(cond)
[17:42:39.664]                           for (restart in restarts) {
[17:42:39.664]                             name <- restart$name
[17:42:39.664]                             if (is.null(name)) 
[17:42:39.664]                               next
[17:42:39.664]                             if (!grepl(pattern, name)) 
[17:42:39.664]                               next
[17:42:39.664]                             invokeRestart(restart)
[17:42:39.664]                             muffled <- TRUE
[17:42:39.664]                             break
[17:42:39.664]                           }
[17:42:39.664]                         }
[17:42:39.664]                       }
[17:42:39.664]                       invisible(muffled)
[17:42:39.664]                     }
[17:42:39.664]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.664]                   }
[17:42:39.664]                 }
[17:42:39.664]                 else {
[17:42:39.664]                   if (TRUE) {
[17:42:39.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.664]                     {
[17:42:39.664]                       inherits <- base::inherits
[17:42:39.664]                       invokeRestart <- base::invokeRestart
[17:42:39.664]                       is.null <- base::is.null
[17:42:39.664]                       muffled <- FALSE
[17:42:39.664]                       if (inherits(cond, "message")) {
[17:42:39.664]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.664]                         if (muffled) 
[17:42:39.664]                           invokeRestart("muffleMessage")
[17:42:39.664]                       }
[17:42:39.664]                       else if (inherits(cond, "warning")) {
[17:42:39.664]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.664]                         if (muffled) 
[17:42:39.664]                           invokeRestart("muffleWarning")
[17:42:39.664]                       }
[17:42:39.664]                       else if (inherits(cond, "condition")) {
[17:42:39.664]                         if (!is.null(pattern)) {
[17:42:39.664]                           computeRestarts <- base::computeRestarts
[17:42:39.664]                           grepl <- base::grepl
[17:42:39.664]                           restarts <- computeRestarts(cond)
[17:42:39.664]                           for (restart in restarts) {
[17:42:39.664]                             name <- restart$name
[17:42:39.664]                             if (is.null(name)) 
[17:42:39.664]                               next
[17:42:39.664]                             if (!grepl(pattern, name)) 
[17:42:39.664]                               next
[17:42:39.664]                             invokeRestart(restart)
[17:42:39.664]                             muffled <- TRUE
[17:42:39.664]                             break
[17:42:39.664]                           }
[17:42:39.664]                         }
[17:42:39.664]                       }
[17:42:39.664]                       invisible(muffled)
[17:42:39.664]                     }
[17:42:39.664]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.664]                   }
[17:42:39.664]                 }
[17:42:39.664]             }
[17:42:39.664]         }))
[17:42:39.664]     }, error = function(ex) {
[17:42:39.664]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.664]                 ...future.rng), started = ...future.startTime, 
[17:42:39.664]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.664]             version = "1.8"), class = "FutureResult")
[17:42:39.664]     }, finally = {
[17:42:39.664]         if (!identical(...future.workdir, getwd())) 
[17:42:39.664]             setwd(...future.workdir)
[17:42:39.664]         {
[17:42:39.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.664]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.664]             }
[17:42:39.664]             base::options(...future.oldOptions)
[17:42:39.664]             if (.Platform$OS.type == "windows") {
[17:42:39.664]                 old_names <- names(...future.oldEnvVars)
[17:42:39.664]                 envs <- base::Sys.getenv()
[17:42:39.664]                 names <- names(envs)
[17:42:39.664]                 common <- intersect(names, old_names)
[17:42:39.664]                 added <- setdiff(names, old_names)
[17:42:39.664]                 removed <- setdiff(old_names, names)
[17:42:39.664]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.664]                   envs[common]]
[17:42:39.664]                 NAMES <- toupper(changed)
[17:42:39.664]                 args <- list()
[17:42:39.664]                 for (kk in seq_along(NAMES)) {
[17:42:39.664]                   name <- changed[[kk]]
[17:42:39.664]                   NAME <- NAMES[[kk]]
[17:42:39.664]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.664]                     next
[17:42:39.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.664]                 }
[17:42:39.664]                 NAMES <- toupper(added)
[17:42:39.664]                 for (kk in seq_along(NAMES)) {
[17:42:39.664]                   name <- added[[kk]]
[17:42:39.664]                   NAME <- NAMES[[kk]]
[17:42:39.664]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.664]                     next
[17:42:39.664]                   args[[name]] <- ""
[17:42:39.664]                 }
[17:42:39.664]                 NAMES <- toupper(removed)
[17:42:39.664]                 for (kk in seq_along(NAMES)) {
[17:42:39.664]                   name <- removed[[kk]]
[17:42:39.664]                   NAME <- NAMES[[kk]]
[17:42:39.664]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.664]                     next
[17:42:39.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.664]                 }
[17:42:39.664]                 if (length(args) > 0) 
[17:42:39.664]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.664]             }
[17:42:39.664]             else {
[17:42:39.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.664]             }
[17:42:39.664]             {
[17:42:39.664]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.664]                   0L) {
[17:42:39.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.664]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.664]                   base::options(opts)
[17:42:39.664]                 }
[17:42:39.664]                 {
[17:42:39.664]                   {
[17:42:39.664]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.664]                     NULL
[17:42:39.664]                   }
[17:42:39.664]                   options(future.plan = NULL)
[17:42:39.664]                   if (is.na(NA_character_)) 
[17:42:39.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.664]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.664]                     envir = parent.frame()) 
[17:42:39.664]                   {
[17:42:39.664]                     default_workers <- missing(workers)
[17:42:39.664]                     if (is.function(workers)) 
[17:42:39.664]                       workers <- workers()
[17:42:39.664]                     workers <- structure(as.integer(workers), 
[17:42:39.664]                       class = class(workers))
[17:42:39.664]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.664]                       1L)
[17:42:39.664]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.664]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.664]                       if (default_workers) 
[17:42:39.664]                         supportsMulticore(warn = TRUE)
[17:42:39.664]                       return(sequential(..., envir = envir))
[17:42:39.664]                     }
[17:42:39.664]                     oopts <- options(mc.cores = workers)
[17:42:39.664]                     on.exit(options(oopts))
[17:42:39.664]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.664]                       envir = envir)
[17:42:39.664]                     if (!future$lazy) 
[17:42:39.664]                       future <- run(future)
[17:42:39.664]                     invisible(future)
[17:42:39.664]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.664]                 }
[17:42:39.664]             }
[17:42:39.664]         }
[17:42:39.664]     })
[17:42:39.664]     if (TRUE) {
[17:42:39.664]         base::sink(type = "output", split = FALSE)
[17:42:39.664]         if (TRUE) {
[17:42:39.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.664]         }
[17:42:39.664]         else {
[17:42:39.664]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.664]         }
[17:42:39.664]         base::close(...future.stdout)
[17:42:39.664]         ...future.stdout <- NULL
[17:42:39.664]     }
[17:42:39.664]     ...future.result$conditions <- ...future.conditions
[17:42:39.664]     ...future.result$finished <- base::Sys.time()
[17:42:39.664]     ...future.result
[17:42:39.664] }
[17:42:39.666] assign_globals() ...
[17:42:39.666] List of 1
[17:42:39.666]  $ x: list()
[17:42:39.666]  - attr(*, "where")=List of 1
[17:42:39.666]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.666]  - attr(*, "resolved")= logi TRUE
[17:42:39.666]  - attr(*, "total_size")= num 0
[17:42:39.666]  - attr(*, "already-done")= logi TRUE
[17:42:39.669] - copied ‘x’ to environment
[17:42:39.669] assign_globals() ... done
[17:42:39.670] requestCore(): workers = 2
[17:42:39.671] MulticoreFuture started
[17:42:39.672] - Launch lazy future ... done
[17:42:39.672] run() for ‘MulticoreFuture’ ... done
[17:42:39.672] plan(): Setting new future strategy stack:
[17:42:39.673] List of future strategies:
[17:42:39.673] 1. sequential:
[17:42:39.673]    - args: function (..., envir = parent.frame())
[17:42:39.673]    - tweaked: FALSE
[17:42:39.673]    - call: NULL
[17:42:39.674] plan(): nbrOfWorkers() = 1
[17:42:39.676] plan(): Setting new future strategy stack:
[17:42:39.676] List of future strategies:
[17:42:39.676] 1. multicore:
[17:42:39.676]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.676]    - tweaked: FALSE
[17:42:39.676]    - call: plan(strategy)
[17:42:39.681] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.682] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.683] Searching for globals...
[17:42:39.685] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.686] Searching for globals ... DONE
[17:42:39.686] Resolving globals: TRUE
[17:42:39.686] Resolving any globals that are futures ...
[17:42:39.686] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:39.686] Resolving any globals that are futures ... DONE
[17:42:39.687] Resolving futures part of globals (recursively) ...
[17:42:39.687] resolve() on list ...
[17:42:39.687]  recursive: 99
[17:42:39.687]  length: 1
[17:42:39.687]  elements: ‘x’
[17:42:39.687]  length: 0 (resolved future 1)
[17:42:39.688] resolve() on list ... DONE
[17:42:39.688] - globals: [1] ‘x’
[17:42:39.688] Resolving futures part of globals (recursively) ... DONE
[17:42:39.688] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:39.688] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:39.689] - globals: [1] ‘x’
[17:42:39.689] 
[17:42:39.689] getGlobalsAndPackages() ... DONE
[17:42:39.689] run() for ‘Future’ ...
[17:42:39.689] - state: ‘created’
[17:42:39.689] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.693] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.694] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.694]   - Field: ‘label’
[17:42:39.694]   - Field: ‘local’
[17:42:39.694]   - Field: ‘owner’
[17:42:39.694]   - Field: ‘envir’
[17:42:39.694]   - Field: ‘workers’
[17:42:39.694]   - Field: ‘packages’
[17:42:39.695]   - Field: ‘gc’
[17:42:39.697]   - Field: ‘job’
[17:42:39.697]   - Field: ‘conditions’
[17:42:39.697]   - Field: ‘expr’
[17:42:39.697]   - Field: ‘uuid’
[17:42:39.697]   - Field: ‘seed’
[17:42:39.698]   - Field: ‘version’
[17:42:39.698]   - Field: ‘result’
[17:42:39.698]   - Field: ‘asynchronous’
[17:42:39.698]   - Field: ‘calls’
[17:42:39.698]   - Field: ‘globals’
[17:42:39.698]   - Field: ‘stdout’
[17:42:39.698]   - Field: ‘earlySignal’
[17:42:39.699]   - Field: ‘lazy’
[17:42:39.699]   - Field: ‘state’
[17:42:39.699] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.699] - Launch lazy future ...
[17:42:39.699] Packages needed by the future expression (n = 0): <none>
[17:42:39.700] Packages needed by future strategies (n = 0): <none>
[17:42:39.700] {
[17:42:39.700]     {
[17:42:39.700]         {
[17:42:39.700]             ...future.startTime <- base::Sys.time()
[17:42:39.700]             {
[17:42:39.700]                 {
[17:42:39.700]                   {
[17:42:39.700]                     {
[17:42:39.700]                       base::local({
[17:42:39.700]                         has_future <- base::requireNamespace("future", 
[17:42:39.700]                           quietly = TRUE)
[17:42:39.700]                         if (has_future) {
[17:42:39.700]                           ns <- base::getNamespace("future")
[17:42:39.700]                           version <- ns[[".package"]][["version"]]
[17:42:39.700]                           if (is.null(version)) 
[17:42:39.700]                             version <- utils::packageVersion("future")
[17:42:39.700]                         }
[17:42:39.700]                         else {
[17:42:39.700]                           version <- NULL
[17:42:39.700]                         }
[17:42:39.700]                         if (!has_future || version < "1.8.0") {
[17:42:39.700]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.700]                             "", base::R.version$version.string), 
[17:42:39.700]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.700]                               "release", "version")], collapse = " "), 
[17:42:39.700]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.700]                             info)
[17:42:39.700]                           info <- base::paste(info, collapse = "; ")
[17:42:39.700]                           if (!has_future) {
[17:42:39.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.700]                               info)
[17:42:39.700]                           }
[17:42:39.700]                           else {
[17:42:39.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.700]                               info, version)
[17:42:39.700]                           }
[17:42:39.700]                           base::stop(msg)
[17:42:39.700]                         }
[17:42:39.700]                       })
[17:42:39.700]                     }
[17:42:39.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.700]                     base::options(mc.cores = 1L)
[17:42:39.700]                   }
[17:42:39.700]                   options(future.plan = NULL)
[17:42:39.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.700]                 }
[17:42:39.700]                 ...future.workdir <- getwd()
[17:42:39.700]             }
[17:42:39.700]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.700]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.700]         }
[17:42:39.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.700]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.700]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.700]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.700]             base::names(...future.oldOptions))
[17:42:39.700]     }
[17:42:39.700]     if (FALSE) {
[17:42:39.700]     }
[17:42:39.700]     else {
[17:42:39.700]         if (TRUE) {
[17:42:39.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.700]                 open = "w")
[17:42:39.700]         }
[17:42:39.700]         else {
[17:42:39.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.700]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.700]         }
[17:42:39.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.700]             base::sink(type = "output", split = FALSE)
[17:42:39.700]             base::close(...future.stdout)
[17:42:39.700]         }, add = TRUE)
[17:42:39.700]     }
[17:42:39.700]     ...future.frame <- base::sys.nframe()
[17:42:39.700]     ...future.conditions <- base::list()
[17:42:39.700]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.700]     if (FALSE) {
[17:42:39.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.700]     }
[17:42:39.700]     ...future.result <- base::tryCatch({
[17:42:39.700]         base::withCallingHandlers({
[17:42:39.700]             ...future.value <- base::withVisible(base::local({
[17:42:39.700]                 withCallingHandlers({
[17:42:39.700]                   {
[17:42:39.700]                     x["a"] <- list(1)
[17:42:39.700]                     x
[17:42:39.700]                   }
[17:42:39.700]                 }, immediateCondition = function(cond) {
[17:42:39.700]                   save_rds <- function (object, pathname, ...) 
[17:42:39.700]                   {
[17:42:39.700]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.700]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.700]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.700]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.700]                         fi_tmp[["mtime"]])
[17:42:39.700]                     }
[17:42:39.700]                     tryCatch({
[17:42:39.700]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.700]                     }, error = function(ex) {
[17:42:39.700]                       msg <- conditionMessage(ex)
[17:42:39.700]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.700]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.700]                         fi_tmp[["mtime"]], msg)
[17:42:39.700]                       ex$message <- msg
[17:42:39.700]                       stop(ex)
[17:42:39.700]                     })
[17:42:39.700]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.700]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.700]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.700]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.700]                       fi <- file.info(pathname)
[17:42:39.700]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.700]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.700]                         fi[["size"]], fi[["mtime"]])
[17:42:39.700]                       stop(msg)
[17:42:39.700]                     }
[17:42:39.700]                     invisible(pathname)
[17:42:39.700]                   }
[17:42:39.700]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.700]                     rootPath = tempdir()) 
[17:42:39.700]                   {
[17:42:39.700]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.700]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.700]                       tmpdir = path, fileext = ".rds")
[17:42:39.700]                     save_rds(obj, file)
[17:42:39.700]                   }
[17:42:39.700]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.700]                   {
[17:42:39.700]                     inherits <- base::inherits
[17:42:39.700]                     invokeRestart <- base::invokeRestart
[17:42:39.700]                     is.null <- base::is.null
[17:42:39.700]                     muffled <- FALSE
[17:42:39.700]                     if (inherits(cond, "message")) {
[17:42:39.700]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.700]                       if (muffled) 
[17:42:39.700]                         invokeRestart("muffleMessage")
[17:42:39.700]                     }
[17:42:39.700]                     else if (inherits(cond, "warning")) {
[17:42:39.700]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.700]                       if (muffled) 
[17:42:39.700]                         invokeRestart("muffleWarning")
[17:42:39.700]                     }
[17:42:39.700]                     else if (inherits(cond, "condition")) {
[17:42:39.700]                       if (!is.null(pattern)) {
[17:42:39.700]                         computeRestarts <- base::computeRestarts
[17:42:39.700]                         grepl <- base::grepl
[17:42:39.700]                         restarts <- computeRestarts(cond)
[17:42:39.700]                         for (restart in restarts) {
[17:42:39.700]                           name <- restart$name
[17:42:39.700]                           if (is.null(name)) 
[17:42:39.700]                             next
[17:42:39.700]                           if (!grepl(pattern, name)) 
[17:42:39.700]                             next
[17:42:39.700]                           invokeRestart(restart)
[17:42:39.700]                           muffled <- TRUE
[17:42:39.700]                           break
[17:42:39.700]                         }
[17:42:39.700]                       }
[17:42:39.700]                     }
[17:42:39.700]                     invisible(muffled)
[17:42:39.700]                   }
[17:42:39.700]                   muffleCondition(cond)
[17:42:39.700]                 })
[17:42:39.700]             }))
[17:42:39.700]             future::FutureResult(value = ...future.value$value, 
[17:42:39.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.700]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.700]                     ...future.globalenv.names))
[17:42:39.700]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.700]         }, condition = base::local({
[17:42:39.700]             c <- base::c
[17:42:39.700]             inherits <- base::inherits
[17:42:39.700]             invokeRestart <- base::invokeRestart
[17:42:39.700]             length <- base::length
[17:42:39.700]             list <- base::list
[17:42:39.700]             seq.int <- base::seq.int
[17:42:39.700]             signalCondition <- base::signalCondition
[17:42:39.700]             sys.calls <- base::sys.calls
[17:42:39.700]             `[[` <- base::`[[`
[17:42:39.700]             `+` <- base::`+`
[17:42:39.700]             `<<-` <- base::`<<-`
[17:42:39.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.700]                   3L)]
[17:42:39.700]             }
[17:42:39.700]             function(cond) {
[17:42:39.700]                 is_error <- inherits(cond, "error")
[17:42:39.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.700]                   NULL)
[17:42:39.700]                 if (is_error) {
[17:42:39.700]                   sessionInformation <- function() {
[17:42:39.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.700]                       search = base::search(), system = base::Sys.info())
[17:42:39.700]                   }
[17:42:39.700]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.700]                     cond$call), session = sessionInformation(), 
[17:42:39.700]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.700]                   signalCondition(cond)
[17:42:39.700]                 }
[17:42:39.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.700]                 "immediateCondition"))) {
[17:42:39.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.700]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.700]                   if (TRUE && !signal) {
[17:42:39.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.700]                     {
[17:42:39.700]                       inherits <- base::inherits
[17:42:39.700]                       invokeRestart <- base::invokeRestart
[17:42:39.700]                       is.null <- base::is.null
[17:42:39.700]                       muffled <- FALSE
[17:42:39.700]                       if (inherits(cond, "message")) {
[17:42:39.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.700]                         if (muffled) 
[17:42:39.700]                           invokeRestart("muffleMessage")
[17:42:39.700]                       }
[17:42:39.700]                       else if (inherits(cond, "warning")) {
[17:42:39.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.700]                         if (muffled) 
[17:42:39.700]                           invokeRestart("muffleWarning")
[17:42:39.700]                       }
[17:42:39.700]                       else if (inherits(cond, "condition")) {
[17:42:39.700]                         if (!is.null(pattern)) {
[17:42:39.700]                           computeRestarts <- base::computeRestarts
[17:42:39.700]                           grepl <- base::grepl
[17:42:39.700]                           restarts <- computeRestarts(cond)
[17:42:39.700]                           for (restart in restarts) {
[17:42:39.700]                             name <- restart$name
[17:42:39.700]                             if (is.null(name)) 
[17:42:39.700]                               next
[17:42:39.700]                             if (!grepl(pattern, name)) 
[17:42:39.700]                               next
[17:42:39.700]                             invokeRestart(restart)
[17:42:39.700]                             muffled <- TRUE
[17:42:39.700]                             break
[17:42:39.700]                           }
[17:42:39.700]                         }
[17:42:39.700]                       }
[17:42:39.700]                       invisible(muffled)
[17:42:39.700]                     }
[17:42:39.700]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.700]                   }
[17:42:39.700]                 }
[17:42:39.700]                 else {
[17:42:39.700]                   if (TRUE) {
[17:42:39.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.700]                     {
[17:42:39.700]                       inherits <- base::inherits
[17:42:39.700]                       invokeRestart <- base::invokeRestart
[17:42:39.700]                       is.null <- base::is.null
[17:42:39.700]                       muffled <- FALSE
[17:42:39.700]                       if (inherits(cond, "message")) {
[17:42:39.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.700]                         if (muffled) 
[17:42:39.700]                           invokeRestart("muffleMessage")
[17:42:39.700]                       }
[17:42:39.700]                       else if (inherits(cond, "warning")) {
[17:42:39.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.700]                         if (muffled) 
[17:42:39.700]                           invokeRestart("muffleWarning")
[17:42:39.700]                       }
[17:42:39.700]                       else if (inherits(cond, "condition")) {
[17:42:39.700]                         if (!is.null(pattern)) {
[17:42:39.700]                           computeRestarts <- base::computeRestarts
[17:42:39.700]                           grepl <- base::grepl
[17:42:39.700]                           restarts <- computeRestarts(cond)
[17:42:39.700]                           for (restart in restarts) {
[17:42:39.700]                             name <- restart$name
[17:42:39.700]                             if (is.null(name)) 
[17:42:39.700]                               next
[17:42:39.700]                             if (!grepl(pattern, name)) 
[17:42:39.700]                               next
[17:42:39.700]                             invokeRestart(restart)
[17:42:39.700]                             muffled <- TRUE
[17:42:39.700]                             break
[17:42:39.700]                           }
[17:42:39.700]                         }
[17:42:39.700]                       }
[17:42:39.700]                       invisible(muffled)
[17:42:39.700]                     }
[17:42:39.700]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.700]                   }
[17:42:39.700]                 }
[17:42:39.700]             }
[17:42:39.700]         }))
[17:42:39.700]     }, error = function(ex) {
[17:42:39.700]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.700]                 ...future.rng), started = ...future.startTime, 
[17:42:39.700]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.700]             version = "1.8"), class = "FutureResult")
[17:42:39.700]     }, finally = {
[17:42:39.700]         if (!identical(...future.workdir, getwd())) 
[17:42:39.700]             setwd(...future.workdir)
[17:42:39.700]         {
[17:42:39.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.700]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.700]             }
[17:42:39.700]             base::options(...future.oldOptions)
[17:42:39.700]             if (.Platform$OS.type == "windows") {
[17:42:39.700]                 old_names <- names(...future.oldEnvVars)
[17:42:39.700]                 envs <- base::Sys.getenv()
[17:42:39.700]                 names <- names(envs)
[17:42:39.700]                 common <- intersect(names, old_names)
[17:42:39.700]                 added <- setdiff(names, old_names)
[17:42:39.700]                 removed <- setdiff(old_names, names)
[17:42:39.700]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.700]                   envs[common]]
[17:42:39.700]                 NAMES <- toupper(changed)
[17:42:39.700]                 args <- list()
[17:42:39.700]                 for (kk in seq_along(NAMES)) {
[17:42:39.700]                   name <- changed[[kk]]
[17:42:39.700]                   NAME <- NAMES[[kk]]
[17:42:39.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.700]                     next
[17:42:39.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.700]                 }
[17:42:39.700]                 NAMES <- toupper(added)
[17:42:39.700]                 for (kk in seq_along(NAMES)) {
[17:42:39.700]                   name <- added[[kk]]
[17:42:39.700]                   NAME <- NAMES[[kk]]
[17:42:39.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.700]                     next
[17:42:39.700]                   args[[name]] <- ""
[17:42:39.700]                 }
[17:42:39.700]                 NAMES <- toupper(removed)
[17:42:39.700]                 for (kk in seq_along(NAMES)) {
[17:42:39.700]                   name <- removed[[kk]]
[17:42:39.700]                   NAME <- NAMES[[kk]]
[17:42:39.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.700]                     next
[17:42:39.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.700]                 }
[17:42:39.700]                 if (length(args) > 0) 
[17:42:39.700]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.700]             }
[17:42:39.700]             else {
[17:42:39.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.700]             }
[17:42:39.700]             {
[17:42:39.700]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.700]                   0L) {
[17:42:39.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.700]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.700]                   base::options(opts)
[17:42:39.700]                 }
[17:42:39.700]                 {
[17:42:39.700]                   {
[17:42:39.700]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.700]                     NULL
[17:42:39.700]                   }
[17:42:39.700]                   options(future.plan = NULL)
[17:42:39.700]                   if (is.na(NA_character_)) 
[17:42:39.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.700]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.700]                     envir = parent.frame()) 
[17:42:39.700]                   {
[17:42:39.700]                     default_workers <- missing(workers)
[17:42:39.700]                     if (is.function(workers)) 
[17:42:39.700]                       workers <- workers()
[17:42:39.700]                     workers <- structure(as.integer(workers), 
[17:42:39.700]                       class = class(workers))
[17:42:39.700]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.700]                       1L)
[17:42:39.700]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.700]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.700]                       if (default_workers) 
[17:42:39.700]                         supportsMulticore(warn = TRUE)
[17:42:39.700]                       return(sequential(..., envir = envir))
[17:42:39.700]                     }
[17:42:39.700]                     oopts <- options(mc.cores = workers)
[17:42:39.700]                     on.exit(options(oopts))
[17:42:39.700]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.700]                       envir = envir)
[17:42:39.700]                     if (!future$lazy) 
[17:42:39.700]                       future <- run(future)
[17:42:39.700]                     invisible(future)
[17:42:39.700]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.700]                 }
[17:42:39.700]             }
[17:42:39.700]         }
[17:42:39.700]     })
[17:42:39.700]     if (TRUE) {
[17:42:39.700]         base::sink(type = "output", split = FALSE)
[17:42:39.700]         if (TRUE) {
[17:42:39.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.700]         }
[17:42:39.700]         else {
[17:42:39.700]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.700]         }
[17:42:39.700]         base::close(...future.stdout)
[17:42:39.700]         ...future.stdout <- NULL
[17:42:39.700]     }
[17:42:39.700]     ...future.result$conditions <- ...future.conditions
[17:42:39.700]     ...future.result$finished <- base::Sys.time()
[17:42:39.700]     ...future.result
[17:42:39.700] }
[17:42:39.703] assign_globals() ...
[17:42:39.703] List of 1
[17:42:39.703]  $ x: list()
[17:42:39.703]  - attr(*, "where")=List of 1
[17:42:39.703]   ..$ x:<environment: R_EmptyEnv> 
[17:42:39.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.703]  - attr(*, "resolved")= logi TRUE
[17:42:39.703]  - attr(*, "total_size")= num 0
[17:42:39.703]  - attr(*, "already-done")= logi TRUE
[17:42:39.706] - copied ‘x’ to environment
[17:42:39.706] assign_globals() ... done
[17:42:39.706] requestCore(): workers = 2
[17:42:39.709] MulticoreFuture started
[17:42:39.709] - Launch lazy future ... done
[17:42:39.709] run() for ‘MulticoreFuture’ ... done
[17:42:39.710] plan(): Setting new future strategy stack:
[17:42:39.710] List of future strategies:
[17:42:39.710] 1. sequential:
[17:42:39.710]    - args: function (..., envir = parent.frame())
[17:42:39.710]    - tweaked: FALSE
[17:42:39.710]    - call: NULL
[17:42:39.711] plan(): nbrOfWorkers() = 1
[17:42:39.713] plan(): Setting new future strategy stack:
[17:42:39.713] List of future strategies:
[17:42:39.713] 1. multicore:
[17:42:39.713]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.713]    - tweaked: FALSE
[17:42:39.713]    - call: plan(strategy)
[17:42:39.718] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.720] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.720] Searching for globals...
[17:42:39.723] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:42:39.723] Searching for globals ... DONE
[17:42:39.724] Resolving globals: TRUE
[17:42:39.724] Resolving any globals that are futures ...
[17:42:39.724] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:42:39.724] Resolving any globals that are futures ... DONE
[17:42:39.725] Resolving futures part of globals (recursively) ...
[17:42:39.725] resolve() on list ...
[17:42:39.725]  recursive: 99
[17:42:39.725]  length: 2
[17:42:39.725]  elements: ‘x’, ‘name’
[17:42:39.725]  length: 1 (resolved future 1)
[17:42:39.726]  length: 0 (resolved future 2)
[17:42:39.726] resolve() on list ... DONE
[17:42:39.726] - globals: [2] ‘x’, ‘name’
[17:42:39.726] Resolving futures part of globals (recursively) ... DONE
[17:42:39.726] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:39.727] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:42:39.727] - globals: [2] ‘x’, ‘name’
[17:42:39.727] 
[17:42:39.727] getGlobalsAndPackages() ... DONE
[17:42:39.727] run() for ‘Future’ ...
[17:42:39.727] - state: ‘created’
[17:42:39.728] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:39.732] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:39.732] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:39.732]   - Field: ‘label’
[17:42:39.732]   - Field: ‘local’
[17:42:39.732]   - Field: ‘owner’
[17:42:39.732]   - Field: ‘envir’
[17:42:39.732]   - Field: ‘workers’
[17:42:39.733]   - Field: ‘packages’
[17:42:39.733]   - Field: ‘gc’
[17:42:39.733]   - Field: ‘job’
[17:42:39.733]   - Field: ‘conditions’
[17:42:39.733]   - Field: ‘expr’
[17:42:39.733]   - Field: ‘uuid’
[17:42:39.733]   - Field: ‘seed’
[17:42:39.733]   - Field: ‘version’
[17:42:39.734]   - Field: ‘result’
[17:42:39.734]   - Field: ‘asynchronous’
[17:42:39.734]   - Field: ‘calls’
[17:42:39.734]   - Field: ‘globals’
[17:42:39.734]   - Field: ‘stdout’
[17:42:39.734]   - Field: ‘earlySignal’
[17:42:39.734]   - Field: ‘lazy’
[17:42:39.734]   - Field: ‘state’
[17:42:39.734] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:39.735] - Launch lazy future ...
[17:42:39.735] Packages needed by the future expression (n = 0): <none>
[17:42:39.735] Packages needed by future strategies (n = 0): <none>
[17:42:39.736] {
[17:42:39.736]     {
[17:42:39.736]         {
[17:42:39.736]             ...future.startTime <- base::Sys.time()
[17:42:39.736]             {
[17:42:39.736]                 {
[17:42:39.736]                   {
[17:42:39.736]                     {
[17:42:39.736]                       base::local({
[17:42:39.736]                         has_future <- base::requireNamespace("future", 
[17:42:39.736]                           quietly = TRUE)
[17:42:39.736]                         if (has_future) {
[17:42:39.736]                           ns <- base::getNamespace("future")
[17:42:39.736]                           version <- ns[[".package"]][["version"]]
[17:42:39.736]                           if (is.null(version)) 
[17:42:39.736]                             version <- utils::packageVersion("future")
[17:42:39.736]                         }
[17:42:39.736]                         else {
[17:42:39.736]                           version <- NULL
[17:42:39.736]                         }
[17:42:39.736]                         if (!has_future || version < "1.8.0") {
[17:42:39.736]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:39.736]                             "", base::R.version$version.string), 
[17:42:39.736]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:39.736]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:39.736]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:39.736]                               "release", "version")], collapse = " "), 
[17:42:39.736]                             hostname = base::Sys.info()[["nodename"]])
[17:42:39.736]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:39.736]                             info)
[17:42:39.736]                           info <- base::paste(info, collapse = "; ")
[17:42:39.736]                           if (!has_future) {
[17:42:39.736]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:39.736]                               info)
[17:42:39.736]                           }
[17:42:39.736]                           else {
[17:42:39.736]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:39.736]                               info, version)
[17:42:39.736]                           }
[17:42:39.736]                           base::stop(msg)
[17:42:39.736]                         }
[17:42:39.736]                       })
[17:42:39.736]                     }
[17:42:39.736]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:39.736]                     base::options(mc.cores = 1L)
[17:42:39.736]                   }
[17:42:39.736]                   options(future.plan = NULL)
[17:42:39.736]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.736]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:39.736]                 }
[17:42:39.736]                 ...future.workdir <- getwd()
[17:42:39.736]             }
[17:42:39.736]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:39.736]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:39.736]         }
[17:42:39.736]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:39.736]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:39.736]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:39.736]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:39.736]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:39.736]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:39.736]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:39.736]             base::names(...future.oldOptions))
[17:42:39.736]     }
[17:42:39.736]     if (FALSE) {
[17:42:39.736]     }
[17:42:39.736]     else {
[17:42:39.736]         if (TRUE) {
[17:42:39.736]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:39.736]                 open = "w")
[17:42:39.736]         }
[17:42:39.736]         else {
[17:42:39.736]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:39.736]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:39.736]         }
[17:42:39.736]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:39.736]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:39.736]             base::sink(type = "output", split = FALSE)
[17:42:39.736]             base::close(...future.stdout)
[17:42:39.736]         }, add = TRUE)
[17:42:39.736]     }
[17:42:39.736]     ...future.frame <- base::sys.nframe()
[17:42:39.736]     ...future.conditions <- base::list()
[17:42:39.736]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:39.736]     if (FALSE) {
[17:42:39.736]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:39.736]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:39.736]     }
[17:42:39.736]     ...future.result <- base::tryCatch({
[17:42:39.736]         base::withCallingHandlers({
[17:42:39.736]             ...future.value <- base::withVisible(base::local({
[17:42:39.736]                 withCallingHandlers({
[17:42:39.736]                   {
[17:42:39.736]                     x[name] <- list(1)
[17:42:39.736]                     x
[17:42:39.736]                   }
[17:42:39.736]                 }, immediateCondition = function(cond) {
[17:42:39.736]                   save_rds <- function (object, pathname, ...) 
[17:42:39.736]                   {
[17:42:39.736]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:39.736]                     if (file_test("-f", pathname_tmp)) {
[17:42:39.736]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.736]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:39.736]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.736]                         fi_tmp[["mtime"]])
[17:42:39.736]                     }
[17:42:39.736]                     tryCatch({
[17:42:39.736]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:39.736]                     }, error = function(ex) {
[17:42:39.736]                       msg <- conditionMessage(ex)
[17:42:39.736]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.736]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:39.736]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.736]                         fi_tmp[["mtime"]], msg)
[17:42:39.736]                       ex$message <- msg
[17:42:39.736]                       stop(ex)
[17:42:39.736]                     })
[17:42:39.736]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:39.736]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:39.736]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:39.736]                       fi_tmp <- file.info(pathname_tmp)
[17:42:39.736]                       fi <- file.info(pathname)
[17:42:39.736]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:39.736]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:39.736]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:39.736]                         fi[["size"]], fi[["mtime"]])
[17:42:39.736]                       stop(msg)
[17:42:39.736]                     }
[17:42:39.736]                     invisible(pathname)
[17:42:39.736]                   }
[17:42:39.736]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:39.736]                     rootPath = tempdir()) 
[17:42:39.736]                   {
[17:42:39.736]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:39.736]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:39.736]                       tmpdir = path, fileext = ".rds")
[17:42:39.736]                     save_rds(obj, file)
[17:42:39.736]                   }
[17:42:39.736]                   saveImmediateCondition(cond, path = "/tmp/Rtmpcpw7Al/.future/immediateConditions")
[17:42:39.736]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.736]                   {
[17:42:39.736]                     inherits <- base::inherits
[17:42:39.736]                     invokeRestart <- base::invokeRestart
[17:42:39.736]                     is.null <- base::is.null
[17:42:39.736]                     muffled <- FALSE
[17:42:39.736]                     if (inherits(cond, "message")) {
[17:42:39.736]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:39.736]                       if (muffled) 
[17:42:39.736]                         invokeRestart("muffleMessage")
[17:42:39.736]                     }
[17:42:39.736]                     else if (inherits(cond, "warning")) {
[17:42:39.736]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:39.736]                       if (muffled) 
[17:42:39.736]                         invokeRestart("muffleWarning")
[17:42:39.736]                     }
[17:42:39.736]                     else if (inherits(cond, "condition")) {
[17:42:39.736]                       if (!is.null(pattern)) {
[17:42:39.736]                         computeRestarts <- base::computeRestarts
[17:42:39.736]                         grepl <- base::grepl
[17:42:39.736]                         restarts <- computeRestarts(cond)
[17:42:39.736]                         for (restart in restarts) {
[17:42:39.736]                           name <- restart$name
[17:42:39.736]                           if (is.null(name)) 
[17:42:39.736]                             next
[17:42:39.736]                           if (!grepl(pattern, name)) 
[17:42:39.736]                             next
[17:42:39.736]                           invokeRestart(restart)
[17:42:39.736]                           muffled <- TRUE
[17:42:39.736]                           break
[17:42:39.736]                         }
[17:42:39.736]                       }
[17:42:39.736]                     }
[17:42:39.736]                     invisible(muffled)
[17:42:39.736]                   }
[17:42:39.736]                   muffleCondition(cond)
[17:42:39.736]                 })
[17:42:39.736]             }))
[17:42:39.736]             future::FutureResult(value = ...future.value$value, 
[17:42:39.736]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.736]                   ...future.rng), globalenv = if (FALSE) 
[17:42:39.736]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:39.736]                     ...future.globalenv.names))
[17:42:39.736]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:39.736]         }, condition = base::local({
[17:42:39.736]             c <- base::c
[17:42:39.736]             inherits <- base::inherits
[17:42:39.736]             invokeRestart <- base::invokeRestart
[17:42:39.736]             length <- base::length
[17:42:39.736]             list <- base::list
[17:42:39.736]             seq.int <- base::seq.int
[17:42:39.736]             signalCondition <- base::signalCondition
[17:42:39.736]             sys.calls <- base::sys.calls
[17:42:39.736]             `[[` <- base::`[[`
[17:42:39.736]             `+` <- base::`+`
[17:42:39.736]             `<<-` <- base::`<<-`
[17:42:39.736]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:39.736]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:39.736]                   3L)]
[17:42:39.736]             }
[17:42:39.736]             function(cond) {
[17:42:39.736]                 is_error <- inherits(cond, "error")
[17:42:39.736]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:39.736]                   NULL)
[17:42:39.736]                 if (is_error) {
[17:42:39.736]                   sessionInformation <- function() {
[17:42:39.736]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:39.736]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:39.736]                       search = base::search(), system = base::Sys.info())
[17:42:39.736]                   }
[17:42:39.736]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.736]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:39.736]                     cond$call), session = sessionInformation(), 
[17:42:39.736]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:39.736]                   signalCondition(cond)
[17:42:39.736]                 }
[17:42:39.736]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:39.736]                 "immediateCondition"))) {
[17:42:39.736]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:39.736]                   ...future.conditions[[length(...future.conditions) + 
[17:42:39.736]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:39.736]                   if (TRUE && !signal) {
[17:42:39.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.736]                     {
[17:42:39.736]                       inherits <- base::inherits
[17:42:39.736]                       invokeRestart <- base::invokeRestart
[17:42:39.736]                       is.null <- base::is.null
[17:42:39.736]                       muffled <- FALSE
[17:42:39.736]                       if (inherits(cond, "message")) {
[17:42:39.736]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.736]                         if (muffled) 
[17:42:39.736]                           invokeRestart("muffleMessage")
[17:42:39.736]                       }
[17:42:39.736]                       else if (inherits(cond, "warning")) {
[17:42:39.736]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.736]                         if (muffled) 
[17:42:39.736]                           invokeRestart("muffleWarning")
[17:42:39.736]                       }
[17:42:39.736]                       else if (inherits(cond, "condition")) {
[17:42:39.736]                         if (!is.null(pattern)) {
[17:42:39.736]                           computeRestarts <- base::computeRestarts
[17:42:39.736]                           grepl <- base::grepl
[17:42:39.736]                           restarts <- computeRestarts(cond)
[17:42:39.736]                           for (restart in restarts) {
[17:42:39.736]                             name <- restart$name
[17:42:39.736]                             if (is.null(name)) 
[17:42:39.736]                               next
[17:42:39.736]                             if (!grepl(pattern, name)) 
[17:42:39.736]                               next
[17:42:39.736]                             invokeRestart(restart)
[17:42:39.736]                             muffled <- TRUE
[17:42:39.736]                             break
[17:42:39.736]                           }
[17:42:39.736]                         }
[17:42:39.736]                       }
[17:42:39.736]                       invisible(muffled)
[17:42:39.736]                     }
[17:42:39.736]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.736]                   }
[17:42:39.736]                 }
[17:42:39.736]                 else {
[17:42:39.736]                   if (TRUE) {
[17:42:39.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:39.736]                     {
[17:42:39.736]                       inherits <- base::inherits
[17:42:39.736]                       invokeRestart <- base::invokeRestart
[17:42:39.736]                       is.null <- base::is.null
[17:42:39.736]                       muffled <- FALSE
[17:42:39.736]                       if (inherits(cond, "message")) {
[17:42:39.736]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:39.736]                         if (muffled) 
[17:42:39.736]                           invokeRestart("muffleMessage")
[17:42:39.736]                       }
[17:42:39.736]                       else if (inherits(cond, "warning")) {
[17:42:39.736]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:39.736]                         if (muffled) 
[17:42:39.736]                           invokeRestart("muffleWarning")
[17:42:39.736]                       }
[17:42:39.736]                       else if (inherits(cond, "condition")) {
[17:42:39.736]                         if (!is.null(pattern)) {
[17:42:39.736]                           computeRestarts <- base::computeRestarts
[17:42:39.736]                           grepl <- base::grepl
[17:42:39.736]                           restarts <- computeRestarts(cond)
[17:42:39.736]                           for (restart in restarts) {
[17:42:39.736]                             name <- restart$name
[17:42:39.736]                             if (is.null(name)) 
[17:42:39.736]                               next
[17:42:39.736]                             if (!grepl(pattern, name)) 
[17:42:39.736]                               next
[17:42:39.736]                             invokeRestart(restart)
[17:42:39.736]                             muffled <- TRUE
[17:42:39.736]                             break
[17:42:39.736]                           }
[17:42:39.736]                         }
[17:42:39.736]                       }
[17:42:39.736]                       invisible(muffled)
[17:42:39.736]                     }
[17:42:39.736]                     muffleCondition(cond, pattern = "^muffle")
[17:42:39.736]                   }
[17:42:39.736]                 }
[17:42:39.736]             }
[17:42:39.736]         }))
[17:42:39.736]     }, error = function(ex) {
[17:42:39.736]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:39.736]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:39.736]                 ...future.rng), started = ...future.startTime, 
[17:42:39.736]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:39.736]             version = "1.8"), class = "FutureResult")
[17:42:39.736]     }, finally = {
[17:42:39.736]         if (!identical(...future.workdir, getwd())) 
[17:42:39.736]             setwd(...future.workdir)
[17:42:39.736]         {
[17:42:39.736]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:39.736]                 ...future.oldOptions$nwarnings <- NULL
[17:42:39.736]             }
[17:42:39.736]             base::options(...future.oldOptions)
[17:42:39.736]             if (.Platform$OS.type == "windows") {
[17:42:39.736]                 old_names <- names(...future.oldEnvVars)
[17:42:39.736]                 envs <- base::Sys.getenv()
[17:42:39.736]                 names <- names(envs)
[17:42:39.736]                 common <- intersect(names, old_names)
[17:42:39.736]                 added <- setdiff(names, old_names)
[17:42:39.736]                 removed <- setdiff(old_names, names)
[17:42:39.736]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:39.736]                   envs[common]]
[17:42:39.736]                 NAMES <- toupper(changed)
[17:42:39.736]                 args <- list()
[17:42:39.736]                 for (kk in seq_along(NAMES)) {
[17:42:39.736]                   name <- changed[[kk]]
[17:42:39.736]                   NAME <- NAMES[[kk]]
[17:42:39.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.736]                     next
[17:42:39.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.736]                 }
[17:42:39.736]                 NAMES <- toupper(added)
[17:42:39.736]                 for (kk in seq_along(NAMES)) {
[17:42:39.736]                   name <- added[[kk]]
[17:42:39.736]                   NAME <- NAMES[[kk]]
[17:42:39.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.736]                     next
[17:42:39.736]                   args[[name]] <- ""
[17:42:39.736]                 }
[17:42:39.736]                 NAMES <- toupper(removed)
[17:42:39.736]                 for (kk in seq_along(NAMES)) {
[17:42:39.736]                   name <- removed[[kk]]
[17:42:39.736]                   NAME <- NAMES[[kk]]
[17:42:39.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:39.736]                     next
[17:42:39.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:39.736]                 }
[17:42:39.736]                 if (length(args) > 0) 
[17:42:39.736]                   base::do.call(base::Sys.setenv, args = args)
[17:42:39.736]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:39.736]             }
[17:42:39.736]             else {
[17:42:39.736]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:39.736]             }
[17:42:39.736]             {
[17:42:39.736]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:39.736]                   0L) {
[17:42:39.736]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:39.736]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:39.736]                   base::options(opts)
[17:42:39.736]                 }
[17:42:39.736]                 {
[17:42:39.736]                   {
[17:42:39.736]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:39.736]                     NULL
[17:42:39.736]                   }
[17:42:39.736]                   options(future.plan = NULL)
[17:42:39.736]                   if (is.na(NA_character_)) 
[17:42:39.736]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:39.736]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:39.736]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:39.736]                     envir = parent.frame()) 
[17:42:39.736]                   {
[17:42:39.736]                     default_workers <- missing(workers)
[17:42:39.736]                     if (is.function(workers)) 
[17:42:39.736]                       workers <- workers()
[17:42:39.736]                     workers <- structure(as.integer(workers), 
[17:42:39.736]                       class = class(workers))
[17:42:39.736]                     stop_if_not(is.finite(workers), workers >= 
[17:42:39.736]                       1L)
[17:42:39.736]                     if ((workers == 1L && !inherits(workers, 
[17:42:39.736]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:39.736]                       if (default_workers) 
[17:42:39.736]                         supportsMulticore(warn = TRUE)
[17:42:39.736]                       return(sequential(..., envir = envir))
[17:42:39.736]                     }
[17:42:39.736]                     oopts <- options(mc.cores = workers)
[17:42:39.736]                     on.exit(options(oopts))
[17:42:39.736]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:39.736]                       envir = envir)
[17:42:39.736]                     if (!future$lazy) 
[17:42:39.736]                       future <- run(future)
[17:42:39.736]                     invisible(future)
[17:42:39.736]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:39.736]                 }
[17:42:39.736]             }
[17:42:39.736]         }
[17:42:39.736]     })
[17:42:39.736]     if (TRUE) {
[17:42:39.736]         base::sink(type = "output", split = FALSE)
[17:42:39.736]         if (TRUE) {
[17:42:39.736]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:39.736]         }
[17:42:39.736]         else {
[17:42:39.736]             ...future.result["stdout"] <- base::list(NULL)
[17:42:39.736]         }
[17:42:39.736]         base::close(...future.stdout)
[17:42:39.736]         ...future.stdout <- NULL
[17:42:39.736]     }
[17:42:39.736]     ...future.result$conditions <- ...future.conditions
[17:42:39.736]     ...future.result$finished <- base::Sys.time()
[17:42:39.736]     ...future.result
[17:42:39.736] }
[17:42:39.739] assign_globals() ...
[17:42:39.739] List of 2
[17:42:39.739]  $ x   : list()
[17:42:39.739]  $ name: chr "a"
[17:42:39.739]  - attr(*, "where")=List of 2
[17:42:39.739]   ..$ x   :<environment: R_EmptyEnv> 
[17:42:39.739]   ..$ name:<environment: R_EmptyEnv> 
[17:42:39.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:39.739]  - attr(*, "resolved")= logi TRUE
[17:42:39.739]  - attr(*, "total_size")= num 112
[17:42:39.739]  - attr(*, "already-done")= logi TRUE
[17:42:39.744] - copied ‘x’ to environment
[17:42:39.744] - copied ‘name’ to environment
[17:42:39.744] assign_globals() ... done
[17:42:39.744] requestCore(): workers = 2
[17:42:39.747] MulticoreFuture started
[17:42:39.747] - Launch lazy future ... done
[17:42:39.747] run() for ‘MulticoreFuture’ ... done
[17:42:39.748] plan(): Setting new future strategy stack:
[17:42:39.748] List of future strategies:
[17:42:39.748] 1. sequential:
[17:42:39.748]    - args: function (..., envir = parent.frame())
[17:42:39.748]    - tweaked: FALSE
[17:42:39.748]    - call: NULL
[17:42:39.754] plan(): nbrOfWorkers() = 1
[17:42:39.755] plan(): Setting new future strategy stack:
[17:42:39.756] List of future strategies:
[17:42:39.756] 1. multicore:
[17:42:39.756]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:39.756]    - tweaked: FALSE
[17:42:39.756]    - call: plan(strategy)
[17:42:39.761] plan(): nbrOfWorkers() = 2
$a
[1] 1

- plan('multisession') ...
[17:42:39.766] plan(): Setting new future strategy stack:
[17:42:39.766] List of future strategies:
[17:42:39.766] 1. multisession:
[17:42:39.766]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:39.766]    - tweaked: FALSE
[17:42:39.766]    - call: plan(strategy)
[17:42:39.767] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:42:39.767] multisession:
[17:42:39.767] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:39.767] - tweaked: FALSE
[17:42:39.767] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:39.775] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:39.775] Not searching for globals
[17:42:39.776] - globals: [0] <none>
[17:42:39.776] getGlobalsAndPackages() ... DONE
[17:42:39.776] [local output] makeClusterPSOCK() ...
[17:42:39.819] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:42:39.825] [local output] Base port: 11353
[17:42:39.825] [local output] Getting setup options for 2 cluster nodes ...
[17:42:39.825] [local output]  - Node 1 of 2 ...
[17:42:39.826] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:39.826] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpcpw7Al/worker.rank=1.parallelly.parent=47045.b7c57807931c.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpcpw7Al/worker.rank=1.parallelly.parent=47045.b7c57807931c.pid")'’
[17:42:40.017] - Possible to infer worker's PID: TRUE
[17:42:40.017] [local output] Rscript port: 11353

[17:42:40.018] [local output]  - Node 2 of 2 ...
[17:42:40.018] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:40.019] [local output] Rscript port: 11353

[17:42:40.019] [local output] Getting setup options for 2 cluster nodes ... done
[17:42:40.019] [local output]  - Parallel setup requested for some PSOCK nodes
[17:42:40.020] [local output] Setting up PSOCK nodes in parallel
[17:42:40.020] List of 36
[17:42:40.020]  $ worker          : chr "localhost"
[17:42:40.020]   ..- attr(*, "localhost")= logi TRUE
[17:42:40.020]  $ master          : chr "localhost"
[17:42:40.020]  $ port            : int 11353
[17:42:40.020]  $ connectTimeout  : num 120
[17:42:40.020]  $ timeout         : num 2592000
[17:42:40.020]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:42:40.020]  $ homogeneous     : logi TRUE
[17:42:40.020]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:42:40.020]  $ rscript_envs    : NULL
[17:42:40.020]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:40.020]  $ rscript_startup : NULL
[17:42:40.020]  $ rscript_sh      : chr "sh"
[17:42:40.020]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:40.020]  $ methods         : logi TRUE
[17:42:40.020]  $ socketOptions   : chr "no-delay"
[17:42:40.020]  $ useXDR          : logi FALSE
[17:42:40.020]  $ outfile         : chr "/dev/null"
[17:42:40.020]  $ renice          : int NA
[17:42:40.020]  $ rshcmd          : NULL
[17:42:40.020]  $ user            : chr(0) 
[17:42:40.020]  $ revtunnel       : logi FALSE
[17:42:40.020]  $ rshlogfile      : NULL
[17:42:40.020]  $ rshopts         : chr(0) 
[17:42:40.020]  $ rank            : int 1
[17:42:40.020]  $ manual          : logi FALSE
[17:42:40.020]  $ dryrun          : logi FALSE
[17:42:40.020]  $ quiet           : logi FALSE
[17:42:40.020]  $ setup_strategy  : chr "parallel"
[17:42:40.020]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:40.020]  $ pidfile         : chr "/tmp/Rtmpcpw7Al/worker.rank=1.parallelly.parent=47045.b7c57807931c.pid"
[17:42:40.020]  $ rshcmd_label    : NULL
[17:42:40.020]  $ rsh_call        : NULL
[17:42:40.020]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:40.020]  $ localMachine    : logi TRUE
[17:42:40.020]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:42:40.020]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:42:40.020]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:42:40.020]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:42:40.020]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:42:40.020]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:42:40.020]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:42:40.020]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:42:40.020]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:42:40.020]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:42:40.020]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:42:40.020]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:42:40.020]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:42:40.020]  $ arguments       :List of 28
[17:42:40.020]   ..$ worker          : chr "localhost"
[17:42:40.020]   ..$ master          : NULL
[17:42:40.020]   ..$ port            : int 11353
[17:42:40.020]   ..$ connectTimeout  : num 120
[17:42:40.020]   ..$ timeout         : num 2592000
[17:42:40.020]   ..$ rscript         : NULL
[17:42:40.020]   ..$ homogeneous     : NULL
[17:42:40.020]   ..$ rscript_args    : NULL
[17:42:40.020]   ..$ rscript_envs    : NULL
[17:42:40.020]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:40.020]   ..$ rscript_startup : NULL
[17:42:40.020]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:42:40.020]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:40.020]   ..$ methods         : logi TRUE
[17:42:40.020]   ..$ socketOptions   : chr "no-delay"
[17:42:40.020]   ..$ useXDR          : logi FALSE
[17:42:40.020]   ..$ outfile         : chr "/dev/null"
[17:42:40.020]   ..$ renice          : int NA
[17:42:40.020]   ..$ rshcmd          : NULL
[17:42:40.020]   ..$ user            : NULL
[17:42:40.020]   ..$ revtunnel       : logi NA
[17:42:40.020]   ..$ rshlogfile      : NULL
[17:42:40.020]   ..$ rshopts         : NULL
[17:42:40.020]   ..$ rank            : int 1
[17:42:40.020]   ..$ manual          : logi FALSE
[17:42:40.020]   ..$ dryrun          : logi FALSE
[17:42:40.020]   ..$ quiet           : logi FALSE
[17:42:40.020]   ..$ setup_strategy  : chr "parallel"
[17:42:40.020]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:42:40.036] [local output] System call to launch all workers:
[17:42:40.037] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpcpw7Al/worker.rank=1.parallelly.parent=47045.b7c57807931c.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11353 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:42:40.037] [local output] Starting PSOCK main server
[17:42:40.038] [local output] Workers launched
[17:42:40.038] [local output] Waiting for workers to connect back
[17:42:40.039]  - [local output] 0 workers out of 2 ready
[17:42:40.279]  - [local output] 0 workers out of 2 ready
[17:42:40.279]  - [local output] 1 workers out of 2 ready
[17:42:40.289]  - [local output] 1 workers out of 2 ready
[17:42:40.289]  - [local output] 2 workers out of 2 ready
[17:42:40.289] [local output] Launching of workers completed
[17:42:40.289] [local output] Collecting session information from workers
[17:42:40.290] [local output]  - Worker #1 of 2
[17:42:40.291] [local output]  - Worker #2 of 2
[17:42:40.291] [local output] makeClusterPSOCK() ... done
[17:42:40.303] Packages needed by the future expression (n = 0): <none>
[17:42:40.303] Packages needed by future strategies (n = 0): <none>
[17:42:40.303] {
[17:42:40.303]     {
[17:42:40.303]         {
[17:42:40.303]             ...future.startTime <- base::Sys.time()
[17:42:40.303]             {
[17:42:40.303]                 {
[17:42:40.303]                   {
[17:42:40.303]                     {
[17:42:40.303]                       base::local({
[17:42:40.303]                         has_future <- base::requireNamespace("future", 
[17:42:40.303]                           quietly = TRUE)
[17:42:40.303]                         if (has_future) {
[17:42:40.303]                           ns <- base::getNamespace("future")
[17:42:40.303]                           version <- ns[[".package"]][["version"]]
[17:42:40.303]                           if (is.null(version)) 
[17:42:40.303]                             version <- utils::packageVersion("future")
[17:42:40.303]                         }
[17:42:40.303]                         else {
[17:42:40.303]                           version <- NULL
[17:42:40.303]                         }
[17:42:40.303]                         if (!has_future || version < "1.8.0") {
[17:42:40.303]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:40.303]                             "", base::R.version$version.string), 
[17:42:40.303]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:40.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:40.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:40.303]                               "release", "version")], collapse = " "), 
[17:42:40.303]                             hostname = base::Sys.info()[["nodename"]])
[17:42:40.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:40.303]                             info)
[17:42:40.303]                           info <- base::paste(info, collapse = "; ")
[17:42:40.303]                           if (!has_future) {
[17:42:40.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:40.303]                               info)
[17:42:40.303]                           }
[17:42:40.303]                           else {
[17:42:40.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:40.303]                               info, version)
[17:42:40.303]                           }
[17:42:40.303]                           base::stop(msg)
[17:42:40.303]                         }
[17:42:40.303]                       })
[17:42:40.303]                     }
[17:42:40.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:40.303]                     base::options(mc.cores = 1L)
[17:42:40.303]                   }
[17:42:40.303]                   options(future.plan = NULL)
[17:42:40.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:40.303]                 }
[17:42:40.303]                 ...future.workdir <- getwd()
[17:42:40.303]             }
[17:42:40.303]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:40.303]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:40.303]         }
[17:42:40.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:40.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:40.303]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:40.303]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:40.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:40.303]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:40.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:40.303]             base::names(...future.oldOptions))
[17:42:40.303]     }
[17:42:40.303]     if (FALSE) {
[17:42:40.303]     }
[17:42:40.303]     else {
[17:42:40.303]         if (TRUE) {
[17:42:40.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:40.303]                 open = "w")
[17:42:40.303]         }
[17:42:40.303]         else {
[17:42:40.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:40.303]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:40.303]         }
[17:42:40.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:40.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:40.303]             base::sink(type = "output", split = FALSE)
[17:42:40.303]             base::close(...future.stdout)
[17:42:40.303]         }, add = TRUE)
[17:42:40.303]     }
[17:42:40.303]     ...future.frame <- base::sys.nframe()
[17:42:40.303]     ...future.conditions <- base::list()
[17:42:40.303]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:40.303]     if (FALSE) {
[17:42:40.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:40.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:40.303]     }
[17:42:40.303]     ...future.result <- base::tryCatch({
[17:42:40.303]         base::withCallingHandlers({
[17:42:40.303]             ...future.value <- base::withVisible(base::local({
[17:42:40.303]                 ...future.makeSendCondition <- local({
[17:42:40.303]                   sendCondition <- NULL
[17:42:40.303]                   function(frame = 1L) {
[17:42:40.303]                     if (is.function(sendCondition)) 
[17:42:40.303]                       return(sendCondition)
[17:42:40.303]                     ns <- getNamespace("parallel")
[17:42:40.303]                     if (exists("sendData", mode = "function", 
[17:42:40.303]                       envir = ns)) {
[17:42:40.303]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:40.303]                         envir = ns)
[17:42:40.303]                       envir <- sys.frame(frame)
[17:42:40.303]                       master <- NULL
[17:42:40.303]                       while (!identical(envir, .GlobalEnv) && 
[17:42:40.303]                         !identical(envir, emptyenv())) {
[17:42:40.303]                         if (exists("master", mode = "list", envir = envir, 
[17:42:40.303]                           inherits = FALSE)) {
[17:42:40.303]                           master <- get("master", mode = "list", 
[17:42:40.303]                             envir = envir, inherits = FALSE)
[17:42:40.303]                           if (inherits(master, c("SOCKnode", 
[17:42:40.303]                             "SOCK0node"))) {
[17:42:40.303]                             sendCondition <<- function(cond) {
[17:42:40.303]                               data <- list(type = "VALUE", value = cond, 
[17:42:40.303]                                 success = TRUE)
[17:42:40.303]                               parallel_sendData(master, data)
[17:42:40.303]                             }
[17:42:40.303]                             return(sendCondition)
[17:42:40.303]                           }
[17:42:40.303]                         }
[17:42:40.303]                         frame <- frame + 1L
[17:42:40.303]                         envir <- sys.frame(frame)
[17:42:40.303]                       }
[17:42:40.303]                     }
[17:42:40.303]                     sendCondition <<- function(cond) NULL
[17:42:40.303]                   }
[17:42:40.303]                 })
[17:42:40.303]                 withCallingHandlers({
[17:42:40.303]                   NA
[17:42:40.303]                 }, immediateCondition = function(cond) {
[17:42:40.303]                   sendCondition <- ...future.makeSendCondition()
[17:42:40.303]                   sendCondition(cond)
[17:42:40.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.303]                   {
[17:42:40.303]                     inherits <- base::inherits
[17:42:40.303]                     invokeRestart <- base::invokeRestart
[17:42:40.303]                     is.null <- base::is.null
[17:42:40.303]                     muffled <- FALSE
[17:42:40.303]                     if (inherits(cond, "message")) {
[17:42:40.303]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:40.303]                       if (muffled) 
[17:42:40.303]                         invokeRestart("muffleMessage")
[17:42:40.303]                     }
[17:42:40.303]                     else if (inherits(cond, "warning")) {
[17:42:40.303]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:40.303]                       if (muffled) 
[17:42:40.303]                         invokeRestart("muffleWarning")
[17:42:40.303]                     }
[17:42:40.303]                     else if (inherits(cond, "condition")) {
[17:42:40.303]                       if (!is.null(pattern)) {
[17:42:40.303]                         computeRestarts <- base::computeRestarts
[17:42:40.303]                         grepl <- base::grepl
[17:42:40.303]                         restarts <- computeRestarts(cond)
[17:42:40.303]                         for (restart in restarts) {
[17:42:40.303]                           name <- restart$name
[17:42:40.303]                           if (is.null(name)) 
[17:42:40.303]                             next
[17:42:40.303]                           if (!grepl(pattern, name)) 
[17:42:40.303]                             next
[17:42:40.303]                           invokeRestart(restart)
[17:42:40.303]                           muffled <- TRUE
[17:42:40.303]                           break
[17:42:40.303]                         }
[17:42:40.303]                       }
[17:42:40.303]                     }
[17:42:40.303]                     invisible(muffled)
[17:42:40.303]                   }
[17:42:40.303]                   muffleCondition(cond)
[17:42:40.303]                 })
[17:42:40.303]             }))
[17:42:40.303]             future::FutureResult(value = ...future.value$value, 
[17:42:40.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.303]                   ...future.rng), globalenv = if (FALSE) 
[17:42:40.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:40.303]                     ...future.globalenv.names))
[17:42:40.303]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:40.303]         }, condition = base::local({
[17:42:40.303]             c <- base::c
[17:42:40.303]             inherits <- base::inherits
[17:42:40.303]             invokeRestart <- base::invokeRestart
[17:42:40.303]             length <- base::length
[17:42:40.303]             list <- base::list
[17:42:40.303]             seq.int <- base::seq.int
[17:42:40.303]             signalCondition <- base::signalCondition
[17:42:40.303]             sys.calls <- base::sys.calls
[17:42:40.303]             `[[` <- base::`[[`
[17:42:40.303]             `+` <- base::`+`
[17:42:40.303]             `<<-` <- base::`<<-`
[17:42:40.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:40.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:40.303]                   3L)]
[17:42:40.303]             }
[17:42:40.303]             function(cond) {
[17:42:40.303]                 is_error <- inherits(cond, "error")
[17:42:40.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:40.303]                   NULL)
[17:42:40.303]                 if (is_error) {
[17:42:40.303]                   sessionInformation <- function() {
[17:42:40.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:40.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:40.303]                       search = base::search(), system = base::Sys.info())
[17:42:40.303]                   }
[17:42:40.303]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:40.303]                     cond$call), session = sessionInformation(), 
[17:42:40.303]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:40.303]                   signalCondition(cond)
[17:42:40.303]                 }
[17:42:40.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:40.303]                 "immediateCondition"))) {
[17:42:40.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:40.303]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:40.303]                   if (TRUE && !signal) {
[17:42:40.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.303]                     {
[17:42:40.303]                       inherits <- base::inherits
[17:42:40.303]                       invokeRestart <- base::invokeRestart
[17:42:40.303]                       is.null <- base::is.null
[17:42:40.303]                       muffled <- FALSE
[17:42:40.303]                       if (inherits(cond, "message")) {
[17:42:40.303]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.303]                         if (muffled) 
[17:42:40.303]                           invokeRestart("muffleMessage")
[17:42:40.303]                       }
[17:42:40.303]                       else if (inherits(cond, "warning")) {
[17:42:40.303]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.303]                         if (muffled) 
[17:42:40.303]                           invokeRestart("muffleWarning")
[17:42:40.303]                       }
[17:42:40.303]                       else if (inherits(cond, "condition")) {
[17:42:40.303]                         if (!is.null(pattern)) {
[17:42:40.303]                           computeRestarts <- base::computeRestarts
[17:42:40.303]                           grepl <- base::grepl
[17:42:40.303]                           restarts <- computeRestarts(cond)
[17:42:40.303]                           for (restart in restarts) {
[17:42:40.303]                             name <- restart$name
[17:42:40.303]                             if (is.null(name)) 
[17:42:40.303]                               next
[17:42:40.303]                             if (!grepl(pattern, name)) 
[17:42:40.303]                               next
[17:42:40.303]                             invokeRestart(restart)
[17:42:40.303]                             muffled <- TRUE
[17:42:40.303]                             break
[17:42:40.303]                           }
[17:42:40.303]                         }
[17:42:40.303]                       }
[17:42:40.303]                       invisible(muffled)
[17:42:40.303]                     }
[17:42:40.303]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.303]                   }
[17:42:40.303]                 }
[17:42:40.303]                 else {
[17:42:40.303]                   if (TRUE) {
[17:42:40.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.303]                     {
[17:42:40.303]                       inherits <- base::inherits
[17:42:40.303]                       invokeRestart <- base::invokeRestart
[17:42:40.303]                       is.null <- base::is.null
[17:42:40.303]                       muffled <- FALSE
[17:42:40.303]                       if (inherits(cond, "message")) {
[17:42:40.303]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.303]                         if (muffled) 
[17:42:40.303]                           invokeRestart("muffleMessage")
[17:42:40.303]                       }
[17:42:40.303]                       else if (inherits(cond, "warning")) {
[17:42:40.303]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.303]                         if (muffled) 
[17:42:40.303]                           invokeRestart("muffleWarning")
[17:42:40.303]                       }
[17:42:40.303]                       else if (inherits(cond, "condition")) {
[17:42:40.303]                         if (!is.null(pattern)) {
[17:42:40.303]                           computeRestarts <- base::computeRestarts
[17:42:40.303]                           grepl <- base::grepl
[17:42:40.303]                           restarts <- computeRestarts(cond)
[17:42:40.303]                           for (restart in restarts) {
[17:42:40.303]                             name <- restart$name
[17:42:40.303]                             if (is.null(name)) 
[17:42:40.303]                               next
[17:42:40.303]                             if (!grepl(pattern, name)) 
[17:42:40.303]                               next
[17:42:40.303]                             invokeRestart(restart)
[17:42:40.303]                             muffled <- TRUE
[17:42:40.303]                             break
[17:42:40.303]                           }
[17:42:40.303]                         }
[17:42:40.303]                       }
[17:42:40.303]                       invisible(muffled)
[17:42:40.303]                     }
[17:42:40.303]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.303]                   }
[17:42:40.303]                 }
[17:42:40.303]             }
[17:42:40.303]         }))
[17:42:40.303]     }, error = function(ex) {
[17:42:40.303]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:40.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.303]                 ...future.rng), started = ...future.startTime, 
[17:42:40.303]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:40.303]             version = "1.8"), class = "FutureResult")
[17:42:40.303]     }, finally = {
[17:42:40.303]         if (!identical(...future.workdir, getwd())) 
[17:42:40.303]             setwd(...future.workdir)
[17:42:40.303]         {
[17:42:40.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:40.303]                 ...future.oldOptions$nwarnings <- NULL
[17:42:40.303]             }
[17:42:40.303]             base::options(...future.oldOptions)
[17:42:40.303]             if (.Platform$OS.type == "windows") {
[17:42:40.303]                 old_names <- names(...future.oldEnvVars)
[17:42:40.303]                 envs <- base::Sys.getenv()
[17:42:40.303]                 names <- names(envs)
[17:42:40.303]                 common <- intersect(names, old_names)
[17:42:40.303]                 added <- setdiff(names, old_names)
[17:42:40.303]                 removed <- setdiff(old_names, names)
[17:42:40.303]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:40.303]                   envs[common]]
[17:42:40.303]                 NAMES <- toupper(changed)
[17:42:40.303]                 args <- list()
[17:42:40.303]                 for (kk in seq_along(NAMES)) {
[17:42:40.303]                   name <- changed[[kk]]
[17:42:40.303]                   NAME <- NAMES[[kk]]
[17:42:40.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.303]                     next
[17:42:40.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.303]                 }
[17:42:40.303]                 NAMES <- toupper(added)
[17:42:40.303]                 for (kk in seq_along(NAMES)) {
[17:42:40.303]                   name <- added[[kk]]
[17:42:40.303]                   NAME <- NAMES[[kk]]
[17:42:40.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.303]                     next
[17:42:40.303]                   args[[name]] <- ""
[17:42:40.303]                 }
[17:42:40.303]                 NAMES <- toupper(removed)
[17:42:40.303]                 for (kk in seq_along(NAMES)) {
[17:42:40.303]                   name <- removed[[kk]]
[17:42:40.303]                   NAME <- NAMES[[kk]]
[17:42:40.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.303]                     next
[17:42:40.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.303]                 }
[17:42:40.303]                 if (length(args) > 0) 
[17:42:40.303]                   base::do.call(base::Sys.setenv, args = args)
[17:42:40.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:40.303]             }
[17:42:40.303]             else {
[17:42:40.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:40.303]             }
[17:42:40.303]             {
[17:42:40.303]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:40.303]                   0L) {
[17:42:40.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:40.303]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:40.303]                   base::options(opts)
[17:42:40.303]                 }
[17:42:40.303]                 {
[17:42:40.303]                   {
[17:42:40.303]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:40.303]                     NULL
[17:42:40.303]                   }
[17:42:40.303]                   options(future.plan = NULL)
[17:42:40.303]                   if (is.na(NA_character_)) 
[17:42:40.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:40.303]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:40.303]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:40.303]                     envir = parent.frame()) 
[17:42:40.303]                   {
[17:42:40.303]                     if (is.function(workers)) 
[17:42:40.303]                       workers <- workers()
[17:42:40.303]                     workers <- structure(as.integer(workers), 
[17:42:40.303]                       class = class(workers))
[17:42:40.303]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:40.303]                       workers >= 1)
[17:42:40.303]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:40.303]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:40.303]                     }
[17:42:40.303]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:40.303]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:40.303]                       envir = envir)
[17:42:40.303]                     if (!future$lazy) 
[17:42:40.303]                       future <- run(future)
[17:42:40.303]                     invisible(future)
[17:42:40.303]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:40.303]                 }
[17:42:40.303]             }
[17:42:40.303]         }
[17:42:40.303]     })
[17:42:40.303]     if (TRUE) {
[17:42:40.303]         base::sink(type = "output", split = FALSE)
[17:42:40.303]         if (TRUE) {
[17:42:40.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:40.303]         }
[17:42:40.303]         else {
[17:42:40.303]             ...future.result["stdout"] <- base::list(NULL)
[17:42:40.303]         }
[17:42:40.303]         base::close(...future.stdout)
[17:42:40.303]         ...future.stdout <- NULL
[17:42:40.303]     }
[17:42:40.303]     ...future.result$conditions <- ...future.conditions
[17:42:40.303]     ...future.result$finished <- base::Sys.time()
[17:42:40.303]     ...future.result
[17:42:40.303] }
[17:42:40.377] MultisessionFuture started
[17:42:40.378] result() for ClusterFuture ...
[17:42:40.379] receiveMessageFromWorker() for ClusterFuture ...
[17:42:40.379] - Validating connection of MultisessionFuture
[17:42:40.411] - received message: FutureResult
[17:42:40.412] - Received FutureResult
[17:42:40.412] - Erased future from FutureRegistry
[17:42:40.412] result() for ClusterFuture ...
[17:42:40.412] - result already collected: FutureResult
[17:42:40.412] result() for ClusterFuture ... done
[17:42:40.412] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:40.412] result() for ClusterFuture ... done
[17:42:40.412] result() for ClusterFuture ...
[17:42:40.413] - result already collected: FutureResult
[17:42:40.413] result() for ClusterFuture ... done
[17:42:40.413] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:42:40.417] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:40.417] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:40.417] Searching for globals...
[17:42:40.420] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:40.420] Searching for globals ... DONE
[17:42:40.420] Resolving globals: TRUE
[17:42:40.420] Resolving any globals that are futures ...
[17:42:40.420] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:40.421] Resolving any globals that are futures ... DONE
[17:42:40.421] Resolving futures part of globals (recursively) ...
[17:42:40.421] resolve() on list ...
[17:42:40.421]  recursive: 99
[17:42:40.421]  length: 1
[17:42:40.422]  elements: ‘x’
[17:42:40.422]  length: 0 (resolved future 1)
[17:42:40.422] resolve() on list ... DONE
[17:42:40.422] - globals: [1] ‘x’
[17:42:40.422] Resolving futures part of globals (recursively) ... DONE
[17:42:40.422] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:40.423] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:40.423] - globals: [1] ‘x’
[17:42:40.423] 
[17:42:40.423] getGlobalsAndPackages() ... DONE
[17:42:40.424] run() for ‘Future’ ...
[17:42:40.424] - state: ‘created’
[17:42:40.424] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:40.439] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:40.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:40.440]   - Field: ‘node’
[17:42:40.440]   - Field: ‘label’
[17:42:40.440]   - Field: ‘local’
[17:42:40.440]   - Field: ‘owner’
[17:42:40.440]   - Field: ‘envir’
[17:42:40.440]   - Field: ‘workers’
[17:42:40.440]   - Field: ‘packages’
[17:42:40.440]   - Field: ‘gc’
[17:42:40.441]   - Field: ‘conditions’
[17:42:40.441]   - Field: ‘persistent’
[17:42:40.441]   - Field: ‘expr’
[17:42:40.441]   - Field: ‘uuid’
[17:42:40.441]   - Field: ‘seed’
[17:42:40.441]   - Field: ‘version’
[17:42:40.441]   - Field: ‘result’
[17:42:40.441]   - Field: ‘asynchronous’
[17:42:40.441]   - Field: ‘calls’
[17:42:40.442]   - Field: ‘globals’
[17:42:40.442]   - Field: ‘stdout’
[17:42:40.442]   - Field: ‘earlySignal’
[17:42:40.442]   - Field: ‘lazy’
[17:42:40.442]   - Field: ‘state’
[17:42:40.442] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:40.442] - Launch lazy future ...
[17:42:40.443] Packages needed by the future expression (n = 0): <none>
[17:42:40.443] Packages needed by future strategies (n = 0): <none>
[17:42:40.443] {
[17:42:40.443]     {
[17:42:40.443]         {
[17:42:40.443]             ...future.startTime <- base::Sys.time()
[17:42:40.443]             {
[17:42:40.443]                 {
[17:42:40.443]                   {
[17:42:40.443]                     {
[17:42:40.443]                       base::local({
[17:42:40.443]                         has_future <- base::requireNamespace("future", 
[17:42:40.443]                           quietly = TRUE)
[17:42:40.443]                         if (has_future) {
[17:42:40.443]                           ns <- base::getNamespace("future")
[17:42:40.443]                           version <- ns[[".package"]][["version"]]
[17:42:40.443]                           if (is.null(version)) 
[17:42:40.443]                             version <- utils::packageVersion("future")
[17:42:40.443]                         }
[17:42:40.443]                         else {
[17:42:40.443]                           version <- NULL
[17:42:40.443]                         }
[17:42:40.443]                         if (!has_future || version < "1.8.0") {
[17:42:40.443]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:40.443]                             "", base::R.version$version.string), 
[17:42:40.443]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:40.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:40.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:40.443]                               "release", "version")], collapse = " "), 
[17:42:40.443]                             hostname = base::Sys.info()[["nodename"]])
[17:42:40.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:40.443]                             info)
[17:42:40.443]                           info <- base::paste(info, collapse = "; ")
[17:42:40.443]                           if (!has_future) {
[17:42:40.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:40.443]                               info)
[17:42:40.443]                           }
[17:42:40.443]                           else {
[17:42:40.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:40.443]                               info, version)
[17:42:40.443]                           }
[17:42:40.443]                           base::stop(msg)
[17:42:40.443]                         }
[17:42:40.443]                       })
[17:42:40.443]                     }
[17:42:40.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:40.443]                     base::options(mc.cores = 1L)
[17:42:40.443]                   }
[17:42:40.443]                   options(future.plan = NULL)
[17:42:40.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:40.443]                 }
[17:42:40.443]                 ...future.workdir <- getwd()
[17:42:40.443]             }
[17:42:40.443]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:40.443]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:40.443]         }
[17:42:40.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:40.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:40.443]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:40.443]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:40.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:40.443]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:40.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:40.443]             base::names(...future.oldOptions))
[17:42:40.443]     }
[17:42:40.443]     if (FALSE) {
[17:42:40.443]     }
[17:42:40.443]     else {
[17:42:40.443]         if (TRUE) {
[17:42:40.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:40.443]                 open = "w")
[17:42:40.443]         }
[17:42:40.443]         else {
[17:42:40.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:40.443]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:40.443]         }
[17:42:40.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:40.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:40.443]             base::sink(type = "output", split = FALSE)
[17:42:40.443]             base::close(...future.stdout)
[17:42:40.443]         }, add = TRUE)
[17:42:40.443]     }
[17:42:40.443]     ...future.frame <- base::sys.nframe()
[17:42:40.443]     ...future.conditions <- base::list()
[17:42:40.443]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:40.443]     if (FALSE) {
[17:42:40.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:40.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:40.443]     }
[17:42:40.443]     ...future.result <- base::tryCatch({
[17:42:40.443]         base::withCallingHandlers({
[17:42:40.443]             ...future.value <- base::withVisible(base::local({
[17:42:40.443]                 ...future.makeSendCondition <- local({
[17:42:40.443]                   sendCondition <- NULL
[17:42:40.443]                   function(frame = 1L) {
[17:42:40.443]                     if (is.function(sendCondition)) 
[17:42:40.443]                       return(sendCondition)
[17:42:40.443]                     ns <- getNamespace("parallel")
[17:42:40.443]                     if (exists("sendData", mode = "function", 
[17:42:40.443]                       envir = ns)) {
[17:42:40.443]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:40.443]                         envir = ns)
[17:42:40.443]                       envir <- sys.frame(frame)
[17:42:40.443]                       master <- NULL
[17:42:40.443]                       while (!identical(envir, .GlobalEnv) && 
[17:42:40.443]                         !identical(envir, emptyenv())) {
[17:42:40.443]                         if (exists("master", mode = "list", envir = envir, 
[17:42:40.443]                           inherits = FALSE)) {
[17:42:40.443]                           master <- get("master", mode = "list", 
[17:42:40.443]                             envir = envir, inherits = FALSE)
[17:42:40.443]                           if (inherits(master, c("SOCKnode", 
[17:42:40.443]                             "SOCK0node"))) {
[17:42:40.443]                             sendCondition <<- function(cond) {
[17:42:40.443]                               data <- list(type = "VALUE", value = cond, 
[17:42:40.443]                                 success = TRUE)
[17:42:40.443]                               parallel_sendData(master, data)
[17:42:40.443]                             }
[17:42:40.443]                             return(sendCondition)
[17:42:40.443]                           }
[17:42:40.443]                         }
[17:42:40.443]                         frame <- frame + 1L
[17:42:40.443]                         envir <- sys.frame(frame)
[17:42:40.443]                       }
[17:42:40.443]                     }
[17:42:40.443]                     sendCondition <<- function(cond) NULL
[17:42:40.443]                   }
[17:42:40.443]                 })
[17:42:40.443]                 withCallingHandlers({
[17:42:40.443]                   {
[17:42:40.443]                     x$a <- 1
[17:42:40.443]                     x
[17:42:40.443]                   }
[17:42:40.443]                 }, immediateCondition = function(cond) {
[17:42:40.443]                   sendCondition <- ...future.makeSendCondition()
[17:42:40.443]                   sendCondition(cond)
[17:42:40.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.443]                   {
[17:42:40.443]                     inherits <- base::inherits
[17:42:40.443]                     invokeRestart <- base::invokeRestart
[17:42:40.443]                     is.null <- base::is.null
[17:42:40.443]                     muffled <- FALSE
[17:42:40.443]                     if (inherits(cond, "message")) {
[17:42:40.443]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:40.443]                       if (muffled) 
[17:42:40.443]                         invokeRestart("muffleMessage")
[17:42:40.443]                     }
[17:42:40.443]                     else if (inherits(cond, "warning")) {
[17:42:40.443]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:40.443]                       if (muffled) 
[17:42:40.443]                         invokeRestart("muffleWarning")
[17:42:40.443]                     }
[17:42:40.443]                     else if (inherits(cond, "condition")) {
[17:42:40.443]                       if (!is.null(pattern)) {
[17:42:40.443]                         computeRestarts <- base::computeRestarts
[17:42:40.443]                         grepl <- base::grepl
[17:42:40.443]                         restarts <- computeRestarts(cond)
[17:42:40.443]                         for (restart in restarts) {
[17:42:40.443]                           name <- restart$name
[17:42:40.443]                           if (is.null(name)) 
[17:42:40.443]                             next
[17:42:40.443]                           if (!grepl(pattern, name)) 
[17:42:40.443]                             next
[17:42:40.443]                           invokeRestart(restart)
[17:42:40.443]                           muffled <- TRUE
[17:42:40.443]                           break
[17:42:40.443]                         }
[17:42:40.443]                       }
[17:42:40.443]                     }
[17:42:40.443]                     invisible(muffled)
[17:42:40.443]                   }
[17:42:40.443]                   muffleCondition(cond)
[17:42:40.443]                 })
[17:42:40.443]             }))
[17:42:40.443]             future::FutureResult(value = ...future.value$value, 
[17:42:40.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.443]                   ...future.rng), globalenv = if (FALSE) 
[17:42:40.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:40.443]                     ...future.globalenv.names))
[17:42:40.443]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:40.443]         }, condition = base::local({
[17:42:40.443]             c <- base::c
[17:42:40.443]             inherits <- base::inherits
[17:42:40.443]             invokeRestart <- base::invokeRestart
[17:42:40.443]             length <- base::length
[17:42:40.443]             list <- base::list
[17:42:40.443]             seq.int <- base::seq.int
[17:42:40.443]             signalCondition <- base::signalCondition
[17:42:40.443]             sys.calls <- base::sys.calls
[17:42:40.443]             `[[` <- base::`[[`
[17:42:40.443]             `+` <- base::`+`
[17:42:40.443]             `<<-` <- base::`<<-`
[17:42:40.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:40.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:40.443]                   3L)]
[17:42:40.443]             }
[17:42:40.443]             function(cond) {
[17:42:40.443]                 is_error <- inherits(cond, "error")
[17:42:40.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:40.443]                   NULL)
[17:42:40.443]                 if (is_error) {
[17:42:40.443]                   sessionInformation <- function() {
[17:42:40.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:40.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:40.443]                       search = base::search(), system = base::Sys.info())
[17:42:40.443]                   }
[17:42:40.443]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:40.443]                     cond$call), session = sessionInformation(), 
[17:42:40.443]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:40.443]                   signalCondition(cond)
[17:42:40.443]                 }
[17:42:40.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:40.443]                 "immediateCondition"))) {
[17:42:40.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:40.443]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:40.443]                   if (TRUE && !signal) {
[17:42:40.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.443]                     {
[17:42:40.443]                       inherits <- base::inherits
[17:42:40.443]                       invokeRestart <- base::invokeRestart
[17:42:40.443]                       is.null <- base::is.null
[17:42:40.443]                       muffled <- FALSE
[17:42:40.443]                       if (inherits(cond, "message")) {
[17:42:40.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.443]                         if (muffled) 
[17:42:40.443]                           invokeRestart("muffleMessage")
[17:42:40.443]                       }
[17:42:40.443]                       else if (inherits(cond, "warning")) {
[17:42:40.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.443]                         if (muffled) 
[17:42:40.443]                           invokeRestart("muffleWarning")
[17:42:40.443]                       }
[17:42:40.443]                       else if (inherits(cond, "condition")) {
[17:42:40.443]                         if (!is.null(pattern)) {
[17:42:40.443]                           computeRestarts <- base::computeRestarts
[17:42:40.443]                           grepl <- base::grepl
[17:42:40.443]                           restarts <- computeRestarts(cond)
[17:42:40.443]                           for (restart in restarts) {
[17:42:40.443]                             name <- restart$name
[17:42:40.443]                             if (is.null(name)) 
[17:42:40.443]                               next
[17:42:40.443]                             if (!grepl(pattern, name)) 
[17:42:40.443]                               next
[17:42:40.443]                             invokeRestart(restart)
[17:42:40.443]                             muffled <- TRUE
[17:42:40.443]                             break
[17:42:40.443]                           }
[17:42:40.443]                         }
[17:42:40.443]                       }
[17:42:40.443]                       invisible(muffled)
[17:42:40.443]                     }
[17:42:40.443]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.443]                   }
[17:42:40.443]                 }
[17:42:40.443]                 else {
[17:42:40.443]                   if (TRUE) {
[17:42:40.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.443]                     {
[17:42:40.443]                       inherits <- base::inherits
[17:42:40.443]                       invokeRestart <- base::invokeRestart
[17:42:40.443]                       is.null <- base::is.null
[17:42:40.443]                       muffled <- FALSE
[17:42:40.443]                       if (inherits(cond, "message")) {
[17:42:40.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.443]                         if (muffled) 
[17:42:40.443]                           invokeRestart("muffleMessage")
[17:42:40.443]                       }
[17:42:40.443]                       else if (inherits(cond, "warning")) {
[17:42:40.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.443]                         if (muffled) 
[17:42:40.443]                           invokeRestart("muffleWarning")
[17:42:40.443]                       }
[17:42:40.443]                       else if (inherits(cond, "condition")) {
[17:42:40.443]                         if (!is.null(pattern)) {
[17:42:40.443]                           computeRestarts <- base::computeRestarts
[17:42:40.443]                           grepl <- base::grepl
[17:42:40.443]                           restarts <- computeRestarts(cond)
[17:42:40.443]                           for (restart in restarts) {
[17:42:40.443]                             name <- restart$name
[17:42:40.443]                             if (is.null(name)) 
[17:42:40.443]                               next
[17:42:40.443]                             if (!grepl(pattern, name)) 
[17:42:40.443]                               next
[17:42:40.443]                             invokeRestart(restart)
[17:42:40.443]                             muffled <- TRUE
[17:42:40.443]                             break
[17:42:40.443]                           }
[17:42:40.443]                         }
[17:42:40.443]                       }
[17:42:40.443]                       invisible(muffled)
[17:42:40.443]                     }
[17:42:40.443]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.443]                   }
[17:42:40.443]                 }
[17:42:40.443]             }
[17:42:40.443]         }))
[17:42:40.443]     }, error = function(ex) {
[17:42:40.443]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:40.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.443]                 ...future.rng), started = ...future.startTime, 
[17:42:40.443]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:40.443]             version = "1.8"), class = "FutureResult")
[17:42:40.443]     }, finally = {
[17:42:40.443]         if (!identical(...future.workdir, getwd())) 
[17:42:40.443]             setwd(...future.workdir)
[17:42:40.443]         {
[17:42:40.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:40.443]                 ...future.oldOptions$nwarnings <- NULL
[17:42:40.443]             }
[17:42:40.443]             base::options(...future.oldOptions)
[17:42:40.443]             if (.Platform$OS.type == "windows") {
[17:42:40.443]                 old_names <- names(...future.oldEnvVars)
[17:42:40.443]                 envs <- base::Sys.getenv()
[17:42:40.443]                 names <- names(envs)
[17:42:40.443]                 common <- intersect(names, old_names)
[17:42:40.443]                 added <- setdiff(names, old_names)
[17:42:40.443]                 removed <- setdiff(old_names, names)
[17:42:40.443]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:40.443]                   envs[common]]
[17:42:40.443]                 NAMES <- toupper(changed)
[17:42:40.443]                 args <- list()
[17:42:40.443]                 for (kk in seq_along(NAMES)) {
[17:42:40.443]                   name <- changed[[kk]]
[17:42:40.443]                   NAME <- NAMES[[kk]]
[17:42:40.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.443]                     next
[17:42:40.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.443]                 }
[17:42:40.443]                 NAMES <- toupper(added)
[17:42:40.443]                 for (kk in seq_along(NAMES)) {
[17:42:40.443]                   name <- added[[kk]]
[17:42:40.443]                   NAME <- NAMES[[kk]]
[17:42:40.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.443]                     next
[17:42:40.443]                   args[[name]] <- ""
[17:42:40.443]                 }
[17:42:40.443]                 NAMES <- toupper(removed)
[17:42:40.443]                 for (kk in seq_along(NAMES)) {
[17:42:40.443]                   name <- removed[[kk]]
[17:42:40.443]                   NAME <- NAMES[[kk]]
[17:42:40.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.443]                     next
[17:42:40.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.443]                 }
[17:42:40.443]                 if (length(args) > 0) 
[17:42:40.443]                   base::do.call(base::Sys.setenv, args = args)
[17:42:40.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:40.443]             }
[17:42:40.443]             else {
[17:42:40.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:40.443]             }
[17:42:40.443]             {
[17:42:40.443]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:40.443]                   0L) {
[17:42:40.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:40.443]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:40.443]                   base::options(opts)
[17:42:40.443]                 }
[17:42:40.443]                 {
[17:42:40.443]                   {
[17:42:40.443]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:40.443]                     NULL
[17:42:40.443]                   }
[17:42:40.443]                   options(future.plan = NULL)
[17:42:40.443]                   if (is.na(NA_character_)) 
[17:42:40.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:40.443]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:40.443]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:40.443]                     envir = parent.frame()) 
[17:42:40.443]                   {
[17:42:40.443]                     if (is.function(workers)) 
[17:42:40.443]                       workers <- workers()
[17:42:40.443]                     workers <- structure(as.integer(workers), 
[17:42:40.443]                       class = class(workers))
[17:42:40.443]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:40.443]                       workers >= 1)
[17:42:40.443]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:40.443]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:40.443]                     }
[17:42:40.443]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:40.443]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:40.443]                       envir = envir)
[17:42:40.443]                     if (!future$lazy) 
[17:42:40.443]                       future <- run(future)
[17:42:40.443]                     invisible(future)
[17:42:40.443]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:40.443]                 }
[17:42:40.443]             }
[17:42:40.443]         }
[17:42:40.443]     })
[17:42:40.443]     if (TRUE) {
[17:42:40.443]         base::sink(type = "output", split = FALSE)
[17:42:40.443]         if (TRUE) {
[17:42:40.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:40.443]         }
[17:42:40.443]         else {
[17:42:40.443]             ...future.result["stdout"] <- base::list(NULL)
[17:42:40.443]         }
[17:42:40.443]         base::close(...future.stdout)
[17:42:40.443]         ...future.stdout <- NULL
[17:42:40.443]     }
[17:42:40.443]     ...future.result$conditions <- ...future.conditions
[17:42:40.443]     ...future.result$finished <- base::Sys.time()
[17:42:40.443]     ...future.result
[17:42:40.443] }
[17:42:40.447] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:42:40.447] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:42:40.447] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:42:40.447] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:42:40.448] MultisessionFuture started
[17:42:40.448] - Launch lazy future ... done
[17:42:40.448] run() for ‘MultisessionFuture’ ... done
[17:42:40.449] result() for ClusterFuture ...
[17:42:40.449] receiveMessageFromWorker() for ClusterFuture ...
[17:42:40.449] - Validating connection of MultisessionFuture
[17:42:40.496] - received message: FutureResult
[17:42:40.496] - Received FutureResult
[17:42:40.496] - Erased future from FutureRegistry
[17:42:40.496] result() for ClusterFuture ...
[17:42:40.497] - result already collected: FutureResult
[17:42:40.497] result() for ClusterFuture ... done
[17:42:40.497] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:40.497] result() for ClusterFuture ... done
[17:42:40.497] result() for ClusterFuture ...
[17:42:40.497] - result already collected: FutureResult
[17:42:40.497] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:40.498] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:40.498] Searching for globals...
[17:42:40.500] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:40.501] Searching for globals ... DONE
[17:42:40.501] Resolving globals: TRUE
[17:42:40.501] Resolving any globals that are futures ...
[17:42:40.501] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:40.501] Resolving any globals that are futures ... DONE
[17:42:40.502] Resolving futures part of globals (recursively) ...
[17:42:40.502] resolve() on list ...
[17:42:40.502]  recursive: 99
[17:42:40.502]  length: 1
[17:42:40.502]  elements: ‘x’
[17:42:40.502]  length: 0 (resolved future 1)
[17:42:40.502] resolve() on list ... DONE
[17:42:40.503] - globals: [1] ‘x’
[17:42:40.503] Resolving futures part of globals (recursively) ... DONE
[17:42:40.503] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:40.503] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:40.503] - globals: [1] ‘x’
[17:42:40.504] 
[17:42:40.504] getGlobalsAndPackages() ... DONE
[17:42:40.504] run() for ‘Future’ ...
[17:42:40.504] - state: ‘created’
[17:42:40.504] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:40.519] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:40.519] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:40.520]   - Field: ‘node’
[17:42:40.520]   - Field: ‘label’
[17:42:40.520]   - Field: ‘local’
[17:42:40.520]   - Field: ‘owner’
[17:42:40.520]   - Field: ‘envir’
[17:42:40.520]   - Field: ‘workers’
[17:42:40.520]   - Field: ‘packages’
[17:42:40.520]   - Field: ‘gc’
[17:42:40.520]   - Field: ‘conditions’
[17:42:40.521]   - Field: ‘persistent’
[17:42:40.521]   - Field: ‘expr’
[17:42:40.521]   - Field: ‘uuid’
[17:42:40.521]   - Field: ‘seed’
[17:42:40.521]   - Field: ‘version’
[17:42:40.521]   - Field: ‘result’
[17:42:40.521]   - Field: ‘asynchronous’
[17:42:40.521]   - Field: ‘calls’
[17:42:40.521]   - Field: ‘globals’
[17:42:40.522]   - Field: ‘stdout’
[17:42:40.522]   - Field: ‘earlySignal’
[17:42:40.522]   - Field: ‘lazy’
[17:42:40.522]   - Field: ‘state’
[17:42:40.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:40.522] - Launch lazy future ...
[17:42:40.522] Packages needed by the future expression (n = 0): <none>
[17:42:40.523] Packages needed by future strategies (n = 0): <none>
[17:42:40.523] {
[17:42:40.523]     {
[17:42:40.523]         {
[17:42:40.523]             ...future.startTime <- base::Sys.time()
[17:42:40.523]             {
[17:42:40.523]                 {
[17:42:40.523]                   {
[17:42:40.523]                     {
[17:42:40.523]                       base::local({
[17:42:40.523]                         has_future <- base::requireNamespace("future", 
[17:42:40.523]                           quietly = TRUE)
[17:42:40.523]                         if (has_future) {
[17:42:40.523]                           ns <- base::getNamespace("future")
[17:42:40.523]                           version <- ns[[".package"]][["version"]]
[17:42:40.523]                           if (is.null(version)) 
[17:42:40.523]                             version <- utils::packageVersion("future")
[17:42:40.523]                         }
[17:42:40.523]                         else {
[17:42:40.523]                           version <- NULL
[17:42:40.523]                         }
[17:42:40.523]                         if (!has_future || version < "1.8.0") {
[17:42:40.523]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:40.523]                             "", base::R.version$version.string), 
[17:42:40.523]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:40.523]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:40.523]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:40.523]                               "release", "version")], collapse = " "), 
[17:42:40.523]                             hostname = base::Sys.info()[["nodename"]])
[17:42:40.523]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:40.523]                             info)
[17:42:40.523]                           info <- base::paste(info, collapse = "; ")
[17:42:40.523]                           if (!has_future) {
[17:42:40.523]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:40.523]                               info)
[17:42:40.523]                           }
[17:42:40.523]                           else {
[17:42:40.523]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:40.523]                               info, version)
[17:42:40.523]                           }
[17:42:40.523]                           base::stop(msg)
[17:42:40.523]                         }
[17:42:40.523]                       })
[17:42:40.523]                     }
[17:42:40.523]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:40.523]                     base::options(mc.cores = 1L)
[17:42:40.523]                   }
[17:42:40.523]                   options(future.plan = NULL)
[17:42:40.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:40.523]                 }
[17:42:40.523]                 ...future.workdir <- getwd()
[17:42:40.523]             }
[17:42:40.523]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:40.523]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:40.523]         }
[17:42:40.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:40.523]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:40.523]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:40.523]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:40.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:40.523]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:40.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:40.523]             base::names(...future.oldOptions))
[17:42:40.523]     }
[17:42:40.523]     if (FALSE) {
[17:42:40.523]     }
[17:42:40.523]     else {
[17:42:40.523]         if (TRUE) {
[17:42:40.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:40.523]                 open = "w")
[17:42:40.523]         }
[17:42:40.523]         else {
[17:42:40.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:40.523]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:40.523]         }
[17:42:40.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:40.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:40.523]             base::sink(type = "output", split = FALSE)
[17:42:40.523]             base::close(...future.stdout)
[17:42:40.523]         }, add = TRUE)
[17:42:40.523]     }
[17:42:40.523]     ...future.frame <- base::sys.nframe()
[17:42:40.523]     ...future.conditions <- base::list()
[17:42:40.523]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:40.523]     if (FALSE) {
[17:42:40.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:40.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:40.523]     }
[17:42:40.523]     ...future.result <- base::tryCatch({
[17:42:40.523]         base::withCallingHandlers({
[17:42:40.523]             ...future.value <- base::withVisible(base::local({
[17:42:40.523]                 ...future.makeSendCondition <- local({
[17:42:40.523]                   sendCondition <- NULL
[17:42:40.523]                   function(frame = 1L) {
[17:42:40.523]                     if (is.function(sendCondition)) 
[17:42:40.523]                       return(sendCondition)
[17:42:40.523]                     ns <- getNamespace("parallel")
[17:42:40.523]                     if (exists("sendData", mode = "function", 
[17:42:40.523]                       envir = ns)) {
[17:42:40.523]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:40.523]                         envir = ns)
[17:42:40.523]                       envir <- sys.frame(frame)
[17:42:40.523]                       master <- NULL
[17:42:40.523]                       while (!identical(envir, .GlobalEnv) && 
[17:42:40.523]                         !identical(envir, emptyenv())) {
[17:42:40.523]                         if (exists("master", mode = "list", envir = envir, 
[17:42:40.523]                           inherits = FALSE)) {
[17:42:40.523]                           master <- get("master", mode = "list", 
[17:42:40.523]                             envir = envir, inherits = FALSE)
[17:42:40.523]                           if (inherits(master, c("SOCKnode", 
[17:42:40.523]                             "SOCK0node"))) {
[17:42:40.523]                             sendCondition <<- function(cond) {
[17:42:40.523]                               data <- list(type = "VALUE", value = cond, 
[17:42:40.523]                                 success = TRUE)
[17:42:40.523]                               parallel_sendData(master, data)
[17:42:40.523]                             }
[17:42:40.523]                             return(sendCondition)
[17:42:40.523]                           }
[17:42:40.523]                         }
[17:42:40.523]                         frame <- frame + 1L
[17:42:40.523]                         envir <- sys.frame(frame)
[17:42:40.523]                       }
[17:42:40.523]                     }
[17:42:40.523]                     sendCondition <<- function(cond) NULL
[17:42:40.523]                   }
[17:42:40.523]                 })
[17:42:40.523]                 withCallingHandlers({
[17:42:40.523]                   {
[17:42:40.523]                     x$a <- 1
[17:42:40.523]                     x
[17:42:40.523]                   }
[17:42:40.523]                 }, immediateCondition = function(cond) {
[17:42:40.523]                   sendCondition <- ...future.makeSendCondition()
[17:42:40.523]                   sendCondition(cond)
[17:42:40.523]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.523]                   {
[17:42:40.523]                     inherits <- base::inherits
[17:42:40.523]                     invokeRestart <- base::invokeRestart
[17:42:40.523]                     is.null <- base::is.null
[17:42:40.523]                     muffled <- FALSE
[17:42:40.523]                     if (inherits(cond, "message")) {
[17:42:40.523]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:40.523]                       if (muffled) 
[17:42:40.523]                         invokeRestart("muffleMessage")
[17:42:40.523]                     }
[17:42:40.523]                     else if (inherits(cond, "warning")) {
[17:42:40.523]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:40.523]                       if (muffled) 
[17:42:40.523]                         invokeRestart("muffleWarning")
[17:42:40.523]                     }
[17:42:40.523]                     else if (inherits(cond, "condition")) {
[17:42:40.523]                       if (!is.null(pattern)) {
[17:42:40.523]                         computeRestarts <- base::computeRestarts
[17:42:40.523]                         grepl <- base::grepl
[17:42:40.523]                         restarts <- computeRestarts(cond)
[17:42:40.523]                         for (restart in restarts) {
[17:42:40.523]                           name <- restart$name
[17:42:40.523]                           if (is.null(name)) 
[17:42:40.523]                             next
[17:42:40.523]                           if (!grepl(pattern, name)) 
[17:42:40.523]                             next
[17:42:40.523]                           invokeRestart(restart)
[17:42:40.523]                           muffled <- TRUE
[17:42:40.523]                           break
[17:42:40.523]                         }
[17:42:40.523]                       }
[17:42:40.523]                     }
[17:42:40.523]                     invisible(muffled)
[17:42:40.523]                   }
[17:42:40.523]                   muffleCondition(cond)
[17:42:40.523]                 })
[17:42:40.523]             }))
[17:42:40.523]             future::FutureResult(value = ...future.value$value, 
[17:42:40.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.523]                   ...future.rng), globalenv = if (FALSE) 
[17:42:40.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:40.523]                     ...future.globalenv.names))
[17:42:40.523]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:40.523]         }, condition = base::local({
[17:42:40.523]             c <- base::c
[17:42:40.523]             inherits <- base::inherits
[17:42:40.523]             invokeRestart <- base::invokeRestart
[17:42:40.523]             length <- base::length
[17:42:40.523]             list <- base::list
[17:42:40.523]             seq.int <- base::seq.int
[17:42:40.523]             signalCondition <- base::signalCondition
[17:42:40.523]             sys.calls <- base::sys.calls
[17:42:40.523]             `[[` <- base::`[[`
[17:42:40.523]             `+` <- base::`+`
[17:42:40.523]             `<<-` <- base::`<<-`
[17:42:40.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:40.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:40.523]                   3L)]
[17:42:40.523]             }
[17:42:40.523]             function(cond) {
[17:42:40.523]                 is_error <- inherits(cond, "error")
[17:42:40.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:40.523]                   NULL)
[17:42:40.523]                 if (is_error) {
[17:42:40.523]                   sessionInformation <- function() {
[17:42:40.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:40.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:40.523]                       search = base::search(), system = base::Sys.info())
[17:42:40.523]                   }
[17:42:40.523]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:40.523]                     cond$call), session = sessionInformation(), 
[17:42:40.523]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:40.523]                   signalCondition(cond)
[17:42:40.523]                 }
[17:42:40.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:40.523]                 "immediateCondition"))) {
[17:42:40.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:40.523]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:40.523]                   if (TRUE && !signal) {
[17:42:40.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.523]                     {
[17:42:40.523]                       inherits <- base::inherits
[17:42:40.523]                       invokeRestart <- base::invokeRestart
[17:42:40.523]                       is.null <- base::is.null
[17:42:40.523]                       muffled <- FALSE
[17:42:40.523]                       if (inherits(cond, "message")) {
[17:42:40.523]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.523]                         if (muffled) 
[17:42:40.523]                           invokeRestart("muffleMessage")
[17:42:40.523]                       }
[17:42:40.523]                       else if (inherits(cond, "warning")) {
[17:42:40.523]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.523]                         if (muffled) 
[17:42:40.523]                           invokeRestart("muffleWarning")
[17:42:40.523]                       }
[17:42:40.523]                       else if (inherits(cond, "condition")) {
[17:42:40.523]                         if (!is.null(pattern)) {
[17:42:40.523]                           computeRestarts <- base::computeRestarts
[17:42:40.523]                           grepl <- base::grepl
[17:42:40.523]                           restarts <- computeRestarts(cond)
[17:42:40.523]                           for (restart in restarts) {
[17:42:40.523]                             name <- restart$name
[17:42:40.523]                             if (is.null(name)) 
[17:42:40.523]                               next
[17:42:40.523]                             if (!grepl(pattern, name)) 
[17:42:40.523]                               next
[17:42:40.523]                             invokeRestart(restart)
[17:42:40.523]                             muffled <- TRUE
[17:42:40.523]                             break
[17:42:40.523]                           }
[17:42:40.523]                         }
[17:42:40.523]                       }
[17:42:40.523]                       invisible(muffled)
[17:42:40.523]                     }
[17:42:40.523]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.523]                   }
[17:42:40.523]                 }
[17:42:40.523]                 else {
[17:42:40.523]                   if (TRUE) {
[17:42:40.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.523]                     {
[17:42:40.523]                       inherits <- base::inherits
[17:42:40.523]                       invokeRestart <- base::invokeRestart
[17:42:40.523]                       is.null <- base::is.null
[17:42:40.523]                       muffled <- FALSE
[17:42:40.523]                       if (inherits(cond, "message")) {
[17:42:40.523]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.523]                         if (muffled) 
[17:42:40.523]                           invokeRestart("muffleMessage")
[17:42:40.523]                       }
[17:42:40.523]                       else if (inherits(cond, "warning")) {
[17:42:40.523]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.523]                         if (muffled) 
[17:42:40.523]                           invokeRestart("muffleWarning")
[17:42:40.523]                       }
[17:42:40.523]                       else if (inherits(cond, "condition")) {
[17:42:40.523]                         if (!is.null(pattern)) {
[17:42:40.523]                           computeRestarts <- base::computeRestarts
[17:42:40.523]                           grepl <- base::grepl
[17:42:40.523]                           restarts <- computeRestarts(cond)
[17:42:40.523]                           for (restart in restarts) {
[17:42:40.523]                             name <- restart$name
[17:42:40.523]                             if (is.null(name)) 
[17:42:40.523]                               next
[17:42:40.523]                             if (!grepl(pattern, name)) 
[17:42:40.523]                               next
[17:42:40.523]                             invokeRestart(restart)
[17:42:40.523]                             muffled <- TRUE
[17:42:40.523]                             break
[17:42:40.523]                           }
[17:42:40.523]                         }
[17:42:40.523]                       }
[17:42:40.523]                       invisible(muffled)
[17:42:40.523]                     }
[17:42:40.523]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.523]                   }
[17:42:40.523]                 }
[17:42:40.523]             }
[17:42:40.523]         }))
[17:42:40.523]     }, error = function(ex) {
[17:42:40.523]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:40.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.523]                 ...future.rng), started = ...future.startTime, 
[17:42:40.523]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:40.523]             version = "1.8"), class = "FutureResult")
[17:42:40.523]     }, finally = {
[17:42:40.523]         if (!identical(...future.workdir, getwd())) 
[17:42:40.523]             setwd(...future.workdir)
[17:42:40.523]         {
[17:42:40.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:40.523]                 ...future.oldOptions$nwarnings <- NULL
[17:42:40.523]             }
[17:42:40.523]             base::options(...future.oldOptions)
[17:42:40.523]             if (.Platform$OS.type == "windows") {
[17:42:40.523]                 old_names <- names(...future.oldEnvVars)
[17:42:40.523]                 envs <- base::Sys.getenv()
[17:42:40.523]                 names <- names(envs)
[17:42:40.523]                 common <- intersect(names, old_names)
[17:42:40.523]                 added <- setdiff(names, old_names)
[17:42:40.523]                 removed <- setdiff(old_names, names)
[17:42:40.523]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:40.523]                   envs[common]]
[17:42:40.523]                 NAMES <- toupper(changed)
[17:42:40.523]                 args <- list()
[17:42:40.523]                 for (kk in seq_along(NAMES)) {
[17:42:40.523]                   name <- changed[[kk]]
[17:42:40.523]                   NAME <- NAMES[[kk]]
[17:42:40.523]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.523]                     next
[17:42:40.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.523]                 }
[17:42:40.523]                 NAMES <- toupper(added)
[17:42:40.523]                 for (kk in seq_along(NAMES)) {
[17:42:40.523]                   name <- added[[kk]]
[17:42:40.523]                   NAME <- NAMES[[kk]]
[17:42:40.523]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.523]                     next
[17:42:40.523]                   args[[name]] <- ""
[17:42:40.523]                 }
[17:42:40.523]                 NAMES <- toupper(removed)
[17:42:40.523]                 for (kk in seq_along(NAMES)) {
[17:42:40.523]                   name <- removed[[kk]]
[17:42:40.523]                   NAME <- NAMES[[kk]]
[17:42:40.523]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.523]                     next
[17:42:40.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.523]                 }
[17:42:40.523]                 if (length(args) > 0) 
[17:42:40.523]                   base::do.call(base::Sys.setenv, args = args)
[17:42:40.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:40.523]             }
[17:42:40.523]             else {
[17:42:40.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:40.523]             }
[17:42:40.523]             {
[17:42:40.523]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:40.523]                   0L) {
[17:42:40.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:40.523]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:40.523]                   base::options(opts)
[17:42:40.523]                 }
[17:42:40.523]                 {
[17:42:40.523]                   {
[17:42:40.523]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:40.523]                     NULL
[17:42:40.523]                   }
[17:42:40.523]                   options(future.plan = NULL)
[17:42:40.523]                   if (is.na(NA_character_)) 
[17:42:40.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:40.523]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:40.523]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:40.523]                     envir = parent.frame()) 
[17:42:40.523]                   {
[17:42:40.523]                     if (is.function(workers)) 
[17:42:40.523]                       workers <- workers()
[17:42:40.523]                     workers <- structure(as.integer(workers), 
[17:42:40.523]                       class = class(workers))
[17:42:40.523]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:40.523]                       workers >= 1)
[17:42:40.523]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:40.523]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:40.523]                     }
[17:42:40.523]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:40.523]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:40.523]                       envir = envir)
[17:42:40.523]                     if (!future$lazy) 
[17:42:40.523]                       future <- run(future)
[17:42:40.523]                     invisible(future)
[17:42:40.523]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:40.523]                 }
[17:42:40.523]             }
[17:42:40.523]         }
[17:42:40.523]     })
[17:42:40.523]     if (TRUE) {
[17:42:40.523]         base::sink(type = "output", split = FALSE)
[17:42:40.523]         if (TRUE) {
[17:42:40.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:40.523]         }
[17:42:40.523]         else {
[17:42:40.523]             ...future.result["stdout"] <- base::list(NULL)
[17:42:40.523]         }
[17:42:40.523]         base::close(...future.stdout)
[17:42:40.523]         ...future.stdout <- NULL
[17:42:40.523]     }
[17:42:40.523]     ...future.result$conditions <- ...future.conditions
[17:42:40.523]     ...future.result$finished <- base::Sys.time()
[17:42:40.523]     ...future.result
[17:42:40.523] }
[17:42:40.526] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:42:40.526] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:42:40.527] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:42:40.527] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:42:40.528] MultisessionFuture started
[17:42:40.528] - Launch lazy future ... done
[17:42:40.528] run() for ‘MultisessionFuture’ ... done
[17:42:40.528] result() for ClusterFuture ...
[17:42:40.528] receiveMessageFromWorker() for ClusterFuture ...
[17:42:40.528] - Validating connection of MultisessionFuture
[17:42:40.576] - received message: FutureResult
[17:42:40.576] - Received FutureResult
[17:42:40.576] - Erased future from FutureRegistry
[17:42:40.577] result() for ClusterFuture ...
[17:42:40.577] - result already collected: FutureResult
[17:42:40.577] result() for ClusterFuture ... done
[17:42:40.577] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:40.577] result() for ClusterFuture ... done
[17:42:40.577] result() for ClusterFuture ...
[17:42:40.577] - result already collected: FutureResult
[17:42:40.577] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:40.578] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:40.578] Searching for globals...
[17:42:40.581] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:40.581] Searching for globals ... DONE
[17:42:40.581] Resolving globals: TRUE
[17:42:40.581] Resolving any globals that are futures ...
[17:42:40.581] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:40.581] Resolving any globals that are futures ... DONE
[17:42:40.582] Resolving futures part of globals (recursively) ...
[17:42:40.582] resolve() on list ...
[17:42:40.582]  recursive: 99
[17:42:40.582]  length: 1
[17:42:40.583]  elements: ‘x’
[17:42:40.583]  length: 0 (resolved future 1)
[17:42:40.583] resolve() on list ... DONE
[17:42:40.583] - globals: [1] ‘x’
[17:42:40.583] Resolving futures part of globals (recursively) ... DONE
[17:42:40.583] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:40.584] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:40.584] - globals: [1] ‘x’
[17:42:40.584] 
[17:42:40.584] getGlobalsAndPackages() ... DONE
[17:42:40.584] run() for ‘Future’ ...
[17:42:40.585] - state: ‘created’
[17:42:40.585] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:40.603] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:40.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:40.603]   - Field: ‘node’
[17:42:40.604]   - Field: ‘label’
[17:42:40.604]   - Field: ‘local’
[17:42:40.604]   - Field: ‘owner’
[17:42:40.604]   - Field: ‘envir’
[17:42:40.604]   - Field: ‘workers’
[17:42:40.604]   - Field: ‘packages’
[17:42:40.604]   - Field: ‘gc’
[17:42:40.604]   - Field: ‘conditions’
[17:42:40.604]   - Field: ‘persistent’
[17:42:40.604]   - Field: ‘expr’
[17:42:40.604]   - Field: ‘uuid’
[17:42:40.605]   - Field: ‘seed’
[17:42:40.605]   - Field: ‘version’
[17:42:40.605]   - Field: ‘result’
[17:42:40.605]   - Field: ‘asynchronous’
[17:42:40.605]   - Field: ‘calls’
[17:42:40.605]   - Field: ‘globals’
[17:42:40.605]   - Field: ‘stdout’
[17:42:40.605]   - Field: ‘earlySignal’
[17:42:40.605]   - Field: ‘lazy’
[17:42:40.605]   - Field: ‘state’
[17:42:40.605] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:40.606] - Launch lazy future ...
[17:42:40.606] Packages needed by the future expression (n = 0): <none>
[17:42:40.606] Packages needed by future strategies (n = 0): <none>
[17:42:40.606] {
[17:42:40.606]     {
[17:42:40.606]         {
[17:42:40.606]             ...future.startTime <- base::Sys.time()
[17:42:40.606]             {
[17:42:40.606]                 {
[17:42:40.606]                   {
[17:42:40.606]                     {
[17:42:40.606]                       base::local({
[17:42:40.606]                         has_future <- base::requireNamespace("future", 
[17:42:40.606]                           quietly = TRUE)
[17:42:40.606]                         if (has_future) {
[17:42:40.606]                           ns <- base::getNamespace("future")
[17:42:40.606]                           version <- ns[[".package"]][["version"]]
[17:42:40.606]                           if (is.null(version)) 
[17:42:40.606]                             version <- utils::packageVersion("future")
[17:42:40.606]                         }
[17:42:40.606]                         else {
[17:42:40.606]                           version <- NULL
[17:42:40.606]                         }
[17:42:40.606]                         if (!has_future || version < "1.8.0") {
[17:42:40.606]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:40.606]                             "", base::R.version$version.string), 
[17:42:40.606]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:40.606]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:40.606]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:40.606]                               "release", "version")], collapse = " "), 
[17:42:40.606]                             hostname = base::Sys.info()[["nodename"]])
[17:42:40.606]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:40.606]                             info)
[17:42:40.606]                           info <- base::paste(info, collapse = "; ")
[17:42:40.606]                           if (!has_future) {
[17:42:40.606]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:40.606]                               info)
[17:42:40.606]                           }
[17:42:40.606]                           else {
[17:42:40.606]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:40.606]                               info, version)
[17:42:40.606]                           }
[17:42:40.606]                           base::stop(msg)
[17:42:40.606]                         }
[17:42:40.606]                       })
[17:42:40.606]                     }
[17:42:40.606]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:40.606]                     base::options(mc.cores = 1L)
[17:42:40.606]                   }
[17:42:40.606]                   options(future.plan = NULL)
[17:42:40.606]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.606]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:40.606]                 }
[17:42:40.606]                 ...future.workdir <- getwd()
[17:42:40.606]             }
[17:42:40.606]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:40.606]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:40.606]         }
[17:42:40.606]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:40.606]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:40.606]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:40.606]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:40.606]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:40.606]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:40.606]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:40.606]             base::names(...future.oldOptions))
[17:42:40.606]     }
[17:42:40.606]     if (FALSE) {
[17:42:40.606]     }
[17:42:40.606]     else {
[17:42:40.606]         if (TRUE) {
[17:42:40.606]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:40.606]                 open = "w")
[17:42:40.606]         }
[17:42:40.606]         else {
[17:42:40.606]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:40.606]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:40.606]         }
[17:42:40.606]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:40.606]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:40.606]             base::sink(type = "output", split = FALSE)
[17:42:40.606]             base::close(...future.stdout)
[17:42:40.606]         }, add = TRUE)
[17:42:40.606]     }
[17:42:40.606]     ...future.frame <- base::sys.nframe()
[17:42:40.606]     ...future.conditions <- base::list()
[17:42:40.606]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:40.606]     if (FALSE) {
[17:42:40.606]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:40.606]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:40.606]     }
[17:42:40.606]     ...future.result <- base::tryCatch({
[17:42:40.606]         base::withCallingHandlers({
[17:42:40.606]             ...future.value <- base::withVisible(base::local({
[17:42:40.606]                 ...future.makeSendCondition <- local({
[17:42:40.606]                   sendCondition <- NULL
[17:42:40.606]                   function(frame = 1L) {
[17:42:40.606]                     if (is.function(sendCondition)) 
[17:42:40.606]                       return(sendCondition)
[17:42:40.606]                     ns <- getNamespace("parallel")
[17:42:40.606]                     if (exists("sendData", mode = "function", 
[17:42:40.606]                       envir = ns)) {
[17:42:40.606]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:40.606]                         envir = ns)
[17:42:40.606]                       envir <- sys.frame(frame)
[17:42:40.606]                       master <- NULL
[17:42:40.606]                       while (!identical(envir, .GlobalEnv) && 
[17:42:40.606]                         !identical(envir, emptyenv())) {
[17:42:40.606]                         if (exists("master", mode = "list", envir = envir, 
[17:42:40.606]                           inherits = FALSE)) {
[17:42:40.606]                           master <- get("master", mode = "list", 
[17:42:40.606]                             envir = envir, inherits = FALSE)
[17:42:40.606]                           if (inherits(master, c("SOCKnode", 
[17:42:40.606]                             "SOCK0node"))) {
[17:42:40.606]                             sendCondition <<- function(cond) {
[17:42:40.606]                               data <- list(type = "VALUE", value = cond, 
[17:42:40.606]                                 success = TRUE)
[17:42:40.606]                               parallel_sendData(master, data)
[17:42:40.606]                             }
[17:42:40.606]                             return(sendCondition)
[17:42:40.606]                           }
[17:42:40.606]                         }
[17:42:40.606]                         frame <- frame + 1L
[17:42:40.606]                         envir <- sys.frame(frame)
[17:42:40.606]                       }
[17:42:40.606]                     }
[17:42:40.606]                     sendCondition <<- function(cond) NULL
[17:42:40.606]                   }
[17:42:40.606]                 })
[17:42:40.606]                 withCallingHandlers({
[17:42:40.606]                   {
[17:42:40.606]                     x$a <- 1
[17:42:40.606]                     x
[17:42:40.606]                   }
[17:42:40.606]                 }, immediateCondition = function(cond) {
[17:42:40.606]                   sendCondition <- ...future.makeSendCondition()
[17:42:40.606]                   sendCondition(cond)
[17:42:40.606]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.606]                   {
[17:42:40.606]                     inherits <- base::inherits
[17:42:40.606]                     invokeRestart <- base::invokeRestart
[17:42:40.606]                     is.null <- base::is.null
[17:42:40.606]                     muffled <- FALSE
[17:42:40.606]                     if (inherits(cond, "message")) {
[17:42:40.606]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:40.606]                       if (muffled) 
[17:42:40.606]                         invokeRestart("muffleMessage")
[17:42:40.606]                     }
[17:42:40.606]                     else if (inherits(cond, "warning")) {
[17:42:40.606]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:40.606]                       if (muffled) 
[17:42:40.606]                         invokeRestart("muffleWarning")
[17:42:40.606]                     }
[17:42:40.606]                     else if (inherits(cond, "condition")) {
[17:42:40.606]                       if (!is.null(pattern)) {
[17:42:40.606]                         computeRestarts <- base::computeRestarts
[17:42:40.606]                         grepl <- base::grepl
[17:42:40.606]                         restarts <- computeRestarts(cond)
[17:42:40.606]                         for (restart in restarts) {
[17:42:40.606]                           name <- restart$name
[17:42:40.606]                           if (is.null(name)) 
[17:42:40.606]                             next
[17:42:40.606]                           if (!grepl(pattern, name)) 
[17:42:40.606]                             next
[17:42:40.606]                           invokeRestart(restart)
[17:42:40.606]                           muffled <- TRUE
[17:42:40.606]                           break
[17:42:40.606]                         }
[17:42:40.606]                       }
[17:42:40.606]                     }
[17:42:40.606]                     invisible(muffled)
[17:42:40.606]                   }
[17:42:40.606]                   muffleCondition(cond)
[17:42:40.606]                 })
[17:42:40.606]             }))
[17:42:40.606]             future::FutureResult(value = ...future.value$value, 
[17:42:40.606]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.606]                   ...future.rng), globalenv = if (FALSE) 
[17:42:40.606]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:40.606]                     ...future.globalenv.names))
[17:42:40.606]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:40.606]         }, condition = base::local({
[17:42:40.606]             c <- base::c
[17:42:40.606]             inherits <- base::inherits
[17:42:40.606]             invokeRestart <- base::invokeRestart
[17:42:40.606]             length <- base::length
[17:42:40.606]             list <- base::list
[17:42:40.606]             seq.int <- base::seq.int
[17:42:40.606]             signalCondition <- base::signalCondition
[17:42:40.606]             sys.calls <- base::sys.calls
[17:42:40.606]             `[[` <- base::`[[`
[17:42:40.606]             `+` <- base::`+`
[17:42:40.606]             `<<-` <- base::`<<-`
[17:42:40.606]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:40.606]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:40.606]                   3L)]
[17:42:40.606]             }
[17:42:40.606]             function(cond) {
[17:42:40.606]                 is_error <- inherits(cond, "error")
[17:42:40.606]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:40.606]                   NULL)
[17:42:40.606]                 if (is_error) {
[17:42:40.606]                   sessionInformation <- function() {
[17:42:40.606]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:40.606]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:40.606]                       search = base::search(), system = base::Sys.info())
[17:42:40.606]                   }
[17:42:40.606]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.606]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:40.606]                     cond$call), session = sessionInformation(), 
[17:42:40.606]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:40.606]                   signalCondition(cond)
[17:42:40.606]                 }
[17:42:40.606]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:40.606]                 "immediateCondition"))) {
[17:42:40.606]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:40.606]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.606]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:40.606]                   if (TRUE && !signal) {
[17:42:40.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.606]                     {
[17:42:40.606]                       inherits <- base::inherits
[17:42:40.606]                       invokeRestart <- base::invokeRestart
[17:42:40.606]                       is.null <- base::is.null
[17:42:40.606]                       muffled <- FALSE
[17:42:40.606]                       if (inherits(cond, "message")) {
[17:42:40.606]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.606]                         if (muffled) 
[17:42:40.606]                           invokeRestart("muffleMessage")
[17:42:40.606]                       }
[17:42:40.606]                       else if (inherits(cond, "warning")) {
[17:42:40.606]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.606]                         if (muffled) 
[17:42:40.606]                           invokeRestart("muffleWarning")
[17:42:40.606]                       }
[17:42:40.606]                       else if (inherits(cond, "condition")) {
[17:42:40.606]                         if (!is.null(pattern)) {
[17:42:40.606]                           computeRestarts <- base::computeRestarts
[17:42:40.606]                           grepl <- base::grepl
[17:42:40.606]                           restarts <- computeRestarts(cond)
[17:42:40.606]                           for (restart in restarts) {
[17:42:40.606]                             name <- restart$name
[17:42:40.606]                             if (is.null(name)) 
[17:42:40.606]                               next
[17:42:40.606]                             if (!grepl(pattern, name)) 
[17:42:40.606]                               next
[17:42:40.606]                             invokeRestart(restart)
[17:42:40.606]                             muffled <- TRUE
[17:42:40.606]                             break
[17:42:40.606]                           }
[17:42:40.606]                         }
[17:42:40.606]                       }
[17:42:40.606]                       invisible(muffled)
[17:42:40.606]                     }
[17:42:40.606]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.606]                   }
[17:42:40.606]                 }
[17:42:40.606]                 else {
[17:42:40.606]                   if (TRUE) {
[17:42:40.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.606]                     {
[17:42:40.606]                       inherits <- base::inherits
[17:42:40.606]                       invokeRestart <- base::invokeRestart
[17:42:40.606]                       is.null <- base::is.null
[17:42:40.606]                       muffled <- FALSE
[17:42:40.606]                       if (inherits(cond, "message")) {
[17:42:40.606]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.606]                         if (muffled) 
[17:42:40.606]                           invokeRestart("muffleMessage")
[17:42:40.606]                       }
[17:42:40.606]                       else if (inherits(cond, "warning")) {
[17:42:40.606]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.606]                         if (muffled) 
[17:42:40.606]                           invokeRestart("muffleWarning")
[17:42:40.606]                       }
[17:42:40.606]                       else if (inherits(cond, "condition")) {
[17:42:40.606]                         if (!is.null(pattern)) {
[17:42:40.606]                           computeRestarts <- base::computeRestarts
[17:42:40.606]                           grepl <- base::grepl
[17:42:40.606]                           restarts <- computeRestarts(cond)
[17:42:40.606]                           for (restart in restarts) {
[17:42:40.606]                             name <- restart$name
[17:42:40.606]                             if (is.null(name)) 
[17:42:40.606]                               next
[17:42:40.606]                             if (!grepl(pattern, name)) 
[17:42:40.606]                               next
[17:42:40.606]                             invokeRestart(restart)
[17:42:40.606]                             muffled <- TRUE
[17:42:40.606]                             break
[17:42:40.606]                           }
[17:42:40.606]                         }
[17:42:40.606]                       }
[17:42:40.606]                       invisible(muffled)
[17:42:40.606]                     }
[17:42:40.606]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.606]                   }
[17:42:40.606]                 }
[17:42:40.606]             }
[17:42:40.606]         }))
[17:42:40.606]     }, error = function(ex) {
[17:42:40.606]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:40.606]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.606]                 ...future.rng), started = ...future.startTime, 
[17:42:40.606]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:40.606]             version = "1.8"), class = "FutureResult")
[17:42:40.606]     }, finally = {
[17:42:40.606]         if (!identical(...future.workdir, getwd())) 
[17:42:40.606]             setwd(...future.workdir)
[17:42:40.606]         {
[17:42:40.606]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:40.606]                 ...future.oldOptions$nwarnings <- NULL
[17:42:40.606]             }
[17:42:40.606]             base::options(...future.oldOptions)
[17:42:40.606]             if (.Platform$OS.type == "windows") {
[17:42:40.606]                 old_names <- names(...future.oldEnvVars)
[17:42:40.606]                 envs <- base::Sys.getenv()
[17:42:40.606]                 names <- names(envs)
[17:42:40.606]                 common <- intersect(names, old_names)
[17:42:40.606]                 added <- setdiff(names, old_names)
[17:42:40.606]                 removed <- setdiff(old_names, names)
[17:42:40.606]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:40.606]                   envs[common]]
[17:42:40.606]                 NAMES <- toupper(changed)
[17:42:40.606]                 args <- list()
[17:42:40.606]                 for (kk in seq_along(NAMES)) {
[17:42:40.606]                   name <- changed[[kk]]
[17:42:40.606]                   NAME <- NAMES[[kk]]
[17:42:40.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.606]                     next
[17:42:40.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.606]                 }
[17:42:40.606]                 NAMES <- toupper(added)
[17:42:40.606]                 for (kk in seq_along(NAMES)) {
[17:42:40.606]                   name <- added[[kk]]
[17:42:40.606]                   NAME <- NAMES[[kk]]
[17:42:40.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.606]                     next
[17:42:40.606]                   args[[name]] <- ""
[17:42:40.606]                 }
[17:42:40.606]                 NAMES <- toupper(removed)
[17:42:40.606]                 for (kk in seq_along(NAMES)) {
[17:42:40.606]                   name <- removed[[kk]]
[17:42:40.606]                   NAME <- NAMES[[kk]]
[17:42:40.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.606]                     next
[17:42:40.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.606]                 }
[17:42:40.606]                 if (length(args) > 0) 
[17:42:40.606]                   base::do.call(base::Sys.setenv, args = args)
[17:42:40.606]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:40.606]             }
[17:42:40.606]             else {
[17:42:40.606]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:40.606]             }
[17:42:40.606]             {
[17:42:40.606]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:40.606]                   0L) {
[17:42:40.606]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:40.606]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:40.606]                   base::options(opts)
[17:42:40.606]                 }
[17:42:40.606]                 {
[17:42:40.606]                   {
[17:42:40.606]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:40.606]                     NULL
[17:42:40.606]                   }
[17:42:40.606]                   options(future.plan = NULL)
[17:42:40.606]                   if (is.na(NA_character_)) 
[17:42:40.606]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.606]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:40.606]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:40.606]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:40.606]                     envir = parent.frame()) 
[17:42:40.606]                   {
[17:42:40.606]                     if (is.function(workers)) 
[17:42:40.606]                       workers <- workers()
[17:42:40.606]                     workers <- structure(as.integer(workers), 
[17:42:40.606]                       class = class(workers))
[17:42:40.606]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:40.606]                       workers >= 1)
[17:42:40.606]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:40.606]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:40.606]                     }
[17:42:40.606]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:40.606]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:40.606]                       envir = envir)
[17:42:40.606]                     if (!future$lazy) 
[17:42:40.606]                       future <- run(future)
[17:42:40.606]                     invisible(future)
[17:42:40.606]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:40.606]                 }
[17:42:40.606]             }
[17:42:40.606]         }
[17:42:40.606]     })
[17:42:40.606]     if (TRUE) {
[17:42:40.606]         base::sink(type = "output", split = FALSE)
[17:42:40.606]         if (TRUE) {
[17:42:40.606]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:40.606]         }
[17:42:40.606]         else {
[17:42:40.606]             ...future.result["stdout"] <- base::list(NULL)
[17:42:40.606]         }
[17:42:40.606]         base::close(...future.stdout)
[17:42:40.606]         ...future.stdout <- NULL
[17:42:40.606]     }
[17:42:40.606]     ...future.result$conditions <- ...future.conditions
[17:42:40.606]     ...future.result$finished <- base::Sys.time()
[17:42:40.606]     ...future.result
[17:42:40.606] }
[17:42:40.609] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:42:40.609] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:42:40.610] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:42:40.610] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:42:40.610] MultisessionFuture started
[17:42:40.611] - Launch lazy future ... done
[17:42:40.611] run() for ‘MultisessionFuture’ ... done
[17:42:40.611] result() for ClusterFuture ...
[17:42:40.611] receiveMessageFromWorker() for ClusterFuture ...
[17:42:40.611] - Validating connection of MultisessionFuture
[17:42:40.656] - received message: FutureResult
[17:42:40.657] - Received FutureResult
[17:42:40.657] - Erased future from FutureRegistry
[17:42:40.657] result() for ClusterFuture ...
[17:42:40.657] - result already collected: FutureResult
[17:42:40.657] result() for ClusterFuture ... done
[17:42:40.657] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:40.657] result() for ClusterFuture ... done
[17:42:40.657] result() for ClusterFuture ...
[17:42:40.657] - result already collected: FutureResult
[17:42:40.657] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:40.658] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:40.658] Searching for globals...
[17:42:40.660] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:40.660] Searching for globals ... DONE
[17:42:40.660] Resolving globals: TRUE
[17:42:40.660] Resolving any globals that are futures ...
[17:42:40.661] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:42:40.661] Resolving any globals that are futures ... DONE
[17:42:40.661] Resolving futures part of globals (recursively) ...
[17:42:40.661] resolve() on list ...
[17:42:40.661]  recursive: 99
[17:42:40.661]  length: 1
[17:42:40.661]  elements: ‘x’
[17:42:40.662]  length: 0 (resolved future 1)
[17:42:40.662] resolve() on list ... DONE
[17:42:40.662] - globals: [1] ‘x’
[17:42:40.662] Resolving futures part of globals (recursively) ... DONE
[17:42:40.662] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:40.662] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:40.663] - globals: [1] ‘x’
[17:42:40.663] 
[17:42:40.663] getGlobalsAndPackages() ... DONE
[17:42:40.663] run() for ‘Future’ ...
[17:42:40.663] - state: ‘created’
[17:42:40.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:40.678] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:40.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:40.679]   - Field: ‘node’
[17:42:40.679]   - Field: ‘label’
[17:42:40.679]   - Field: ‘local’
[17:42:40.679]   - Field: ‘owner’
[17:42:40.679]   - Field: ‘envir’
[17:42:40.679]   - Field: ‘workers’
[17:42:40.679]   - Field: ‘packages’
[17:42:40.679]   - Field: ‘gc’
[17:42:40.680]   - Field: ‘conditions’
[17:42:40.680]   - Field: ‘persistent’
[17:42:40.680]   - Field: ‘expr’
[17:42:40.680]   - Field: ‘uuid’
[17:42:40.680]   - Field: ‘seed’
[17:42:40.680]   - Field: ‘version’
[17:42:40.680]   - Field: ‘result’
[17:42:40.680]   - Field: ‘asynchronous’
[17:42:40.680]   - Field: ‘calls’
[17:42:40.680]   - Field: ‘globals’
[17:42:40.680]   - Field: ‘stdout’
[17:42:40.681]   - Field: ‘earlySignal’
[17:42:40.681]   - Field: ‘lazy’
[17:42:40.681]   - Field: ‘state’
[17:42:40.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:40.681] - Launch lazy future ...
[17:42:40.681] Packages needed by the future expression (n = 0): <none>
[17:42:40.681] Packages needed by future strategies (n = 0): <none>
[17:42:40.682] {
[17:42:40.682]     {
[17:42:40.682]         {
[17:42:40.682]             ...future.startTime <- base::Sys.time()
[17:42:40.682]             {
[17:42:40.682]                 {
[17:42:40.682]                   {
[17:42:40.682]                     {
[17:42:40.682]                       base::local({
[17:42:40.682]                         has_future <- base::requireNamespace("future", 
[17:42:40.682]                           quietly = TRUE)
[17:42:40.682]                         if (has_future) {
[17:42:40.682]                           ns <- base::getNamespace("future")
[17:42:40.682]                           version <- ns[[".package"]][["version"]]
[17:42:40.682]                           if (is.null(version)) 
[17:42:40.682]                             version <- utils::packageVersion("future")
[17:42:40.682]                         }
[17:42:40.682]                         else {
[17:42:40.682]                           version <- NULL
[17:42:40.682]                         }
[17:42:40.682]                         if (!has_future || version < "1.8.0") {
[17:42:40.682]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:40.682]                             "", base::R.version$version.string), 
[17:42:40.682]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:40.682]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:40.682]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:40.682]                               "release", "version")], collapse = " "), 
[17:42:40.682]                             hostname = base::Sys.info()[["nodename"]])
[17:42:40.682]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:40.682]                             info)
[17:42:40.682]                           info <- base::paste(info, collapse = "; ")
[17:42:40.682]                           if (!has_future) {
[17:42:40.682]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:40.682]                               info)
[17:42:40.682]                           }
[17:42:40.682]                           else {
[17:42:40.682]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:40.682]                               info, version)
[17:42:40.682]                           }
[17:42:40.682]                           base::stop(msg)
[17:42:40.682]                         }
[17:42:40.682]                       })
[17:42:40.682]                     }
[17:42:40.682]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:40.682]                     base::options(mc.cores = 1L)
[17:42:40.682]                   }
[17:42:40.682]                   options(future.plan = NULL)
[17:42:40.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:40.682]                 }
[17:42:40.682]                 ...future.workdir <- getwd()
[17:42:40.682]             }
[17:42:40.682]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:40.682]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:40.682]         }
[17:42:40.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:40.682]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:40.682]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:40.682]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:40.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:40.682]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:40.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:40.682]             base::names(...future.oldOptions))
[17:42:40.682]     }
[17:42:40.682]     if (FALSE) {
[17:42:40.682]     }
[17:42:40.682]     else {
[17:42:40.682]         if (TRUE) {
[17:42:40.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:40.682]                 open = "w")
[17:42:40.682]         }
[17:42:40.682]         else {
[17:42:40.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:40.682]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:40.682]         }
[17:42:40.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:40.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:40.682]             base::sink(type = "output", split = FALSE)
[17:42:40.682]             base::close(...future.stdout)
[17:42:40.682]         }, add = TRUE)
[17:42:40.682]     }
[17:42:40.682]     ...future.frame <- base::sys.nframe()
[17:42:40.682]     ...future.conditions <- base::list()
[17:42:40.682]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:40.682]     if (FALSE) {
[17:42:40.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:40.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:40.682]     }
[17:42:40.682]     ...future.result <- base::tryCatch({
[17:42:40.682]         base::withCallingHandlers({
[17:42:40.682]             ...future.value <- base::withVisible(base::local({
[17:42:40.682]                 ...future.makeSendCondition <- local({
[17:42:40.682]                   sendCondition <- NULL
[17:42:40.682]                   function(frame = 1L) {
[17:42:40.682]                     if (is.function(sendCondition)) 
[17:42:40.682]                       return(sendCondition)
[17:42:40.682]                     ns <- getNamespace("parallel")
[17:42:40.682]                     if (exists("sendData", mode = "function", 
[17:42:40.682]                       envir = ns)) {
[17:42:40.682]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:40.682]                         envir = ns)
[17:42:40.682]                       envir <- sys.frame(frame)
[17:42:40.682]                       master <- NULL
[17:42:40.682]                       while (!identical(envir, .GlobalEnv) && 
[17:42:40.682]                         !identical(envir, emptyenv())) {
[17:42:40.682]                         if (exists("master", mode = "list", envir = envir, 
[17:42:40.682]                           inherits = FALSE)) {
[17:42:40.682]                           master <- get("master", mode = "list", 
[17:42:40.682]                             envir = envir, inherits = FALSE)
[17:42:40.682]                           if (inherits(master, c("SOCKnode", 
[17:42:40.682]                             "SOCK0node"))) {
[17:42:40.682]                             sendCondition <<- function(cond) {
[17:42:40.682]                               data <- list(type = "VALUE", value = cond, 
[17:42:40.682]                                 success = TRUE)
[17:42:40.682]                               parallel_sendData(master, data)
[17:42:40.682]                             }
[17:42:40.682]                             return(sendCondition)
[17:42:40.682]                           }
[17:42:40.682]                         }
[17:42:40.682]                         frame <- frame + 1L
[17:42:40.682]                         envir <- sys.frame(frame)
[17:42:40.682]                       }
[17:42:40.682]                     }
[17:42:40.682]                     sendCondition <<- function(cond) NULL
[17:42:40.682]                   }
[17:42:40.682]                 })
[17:42:40.682]                 withCallingHandlers({
[17:42:40.682]                   {
[17:42:40.682]                     x$a <- 1
[17:42:40.682]                     x
[17:42:40.682]                   }
[17:42:40.682]                 }, immediateCondition = function(cond) {
[17:42:40.682]                   sendCondition <- ...future.makeSendCondition()
[17:42:40.682]                   sendCondition(cond)
[17:42:40.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.682]                   {
[17:42:40.682]                     inherits <- base::inherits
[17:42:40.682]                     invokeRestart <- base::invokeRestart
[17:42:40.682]                     is.null <- base::is.null
[17:42:40.682]                     muffled <- FALSE
[17:42:40.682]                     if (inherits(cond, "message")) {
[17:42:40.682]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:40.682]                       if (muffled) 
[17:42:40.682]                         invokeRestart("muffleMessage")
[17:42:40.682]                     }
[17:42:40.682]                     else if (inherits(cond, "warning")) {
[17:42:40.682]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:40.682]                       if (muffled) 
[17:42:40.682]                         invokeRestart("muffleWarning")
[17:42:40.682]                     }
[17:42:40.682]                     else if (inherits(cond, "condition")) {
[17:42:40.682]                       if (!is.null(pattern)) {
[17:42:40.682]                         computeRestarts <- base::computeRestarts
[17:42:40.682]                         grepl <- base::grepl
[17:42:40.682]                         restarts <- computeRestarts(cond)
[17:42:40.682]                         for (restart in restarts) {
[17:42:40.682]                           name <- restart$name
[17:42:40.682]                           if (is.null(name)) 
[17:42:40.682]                             next
[17:42:40.682]                           if (!grepl(pattern, name)) 
[17:42:40.682]                             next
[17:42:40.682]                           invokeRestart(restart)
[17:42:40.682]                           muffled <- TRUE
[17:42:40.682]                           break
[17:42:40.682]                         }
[17:42:40.682]                       }
[17:42:40.682]                     }
[17:42:40.682]                     invisible(muffled)
[17:42:40.682]                   }
[17:42:40.682]                   muffleCondition(cond)
[17:42:40.682]                 })
[17:42:40.682]             }))
[17:42:40.682]             future::FutureResult(value = ...future.value$value, 
[17:42:40.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.682]                   ...future.rng), globalenv = if (FALSE) 
[17:42:40.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:40.682]                     ...future.globalenv.names))
[17:42:40.682]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:40.682]         }, condition = base::local({
[17:42:40.682]             c <- base::c
[17:42:40.682]             inherits <- base::inherits
[17:42:40.682]             invokeRestart <- base::invokeRestart
[17:42:40.682]             length <- base::length
[17:42:40.682]             list <- base::list
[17:42:40.682]             seq.int <- base::seq.int
[17:42:40.682]             signalCondition <- base::signalCondition
[17:42:40.682]             sys.calls <- base::sys.calls
[17:42:40.682]             `[[` <- base::`[[`
[17:42:40.682]             `+` <- base::`+`
[17:42:40.682]             `<<-` <- base::`<<-`
[17:42:40.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:40.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:40.682]                   3L)]
[17:42:40.682]             }
[17:42:40.682]             function(cond) {
[17:42:40.682]                 is_error <- inherits(cond, "error")
[17:42:40.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:40.682]                   NULL)
[17:42:40.682]                 if (is_error) {
[17:42:40.682]                   sessionInformation <- function() {
[17:42:40.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:40.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:40.682]                       search = base::search(), system = base::Sys.info())
[17:42:40.682]                   }
[17:42:40.682]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:40.682]                     cond$call), session = sessionInformation(), 
[17:42:40.682]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:40.682]                   signalCondition(cond)
[17:42:40.682]                 }
[17:42:40.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:40.682]                 "immediateCondition"))) {
[17:42:40.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:40.682]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:40.682]                   if (TRUE && !signal) {
[17:42:40.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.682]                     {
[17:42:40.682]                       inherits <- base::inherits
[17:42:40.682]                       invokeRestart <- base::invokeRestart
[17:42:40.682]                       is.null <- base::is.null
[17:42:40.682]                       muffled <- FALSE
[17:42:40.682]                       if (inherits(cond, "message")) {
[17:42:40.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.682]                         if (muffled) 
[17:42:40.682]                           invokeRestart("muffleMessage")
[17:42:40.682]                       }
[17:42:40.682]                       else if (inherits(cond, "warning")) {
[17:42:40.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.682]                         if (muffled) 
[17:42:40.682]                           invokeRestart("muffleWarning")
[17:42:40.682]                       }
[17:42:40.682]                       else if (inherits(cond, "condition")) {
[17:42:40.682]                         if (!is.null(pattern)) {
[17:42:40.682]                           computeRestarts <- base::computeRestarts
[17:42:40.682]                           grepl <- base::grepl
[17:42:40.682]                           restarts <- computeRestarts(cond)
[17:42:40.682]                           for (restart in restarts) {
[17:42:40.682]                             name <- restart$name
[17:42:40.682]                             if (is.null(name)) 
[17:42:40.682]                               next
[17:42:40.682]                             if (!grepl(pattern, name)) 
[17:42:40.682]                               next
[17:42:40.682]                             invokeRestart(restart)
[17:42:40.682]                             muffled <- TRUE
[17:42:40.682]                             break
[17:42:40.682]                           }
[17:42:40.682]                         }
[17:42:40.682]                       }
[17:42:40.682]                       invisible(muffled)
[17:42:40.682]                     }
[17:42:40.682]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.682]                   }
[17:42:40.682]                 }
[17:42:40.682]                 else {
[17:42:40.682]                   if (TRUE) {
[17:42:40.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.682]                     {
[17:42:40.682]                       inherits <- base::inherits
[17:42:40.682]                       invokeRestart <- base::invokeRestart
[17:42:40.682]                       is.null <- base::is.null
[17:42:40.682]                       muffled <- FALSE
[17:42:40.682]                       if (inherits(cond, "message")) {
[17:42:40.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.682]                         if (muffled) 
[17:42:40.682]                           invokeRestart("muffleMessage")
[17:42:40.682]                       }
[17:42:40.682]                       else if (inherits(cond, "warning")) {
[17:42:40.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.682]                         if (muffled) 
[17:42:40.682]                           invokeRestart("muffleWarning")
[17:42:40.682]                       }
[17:42:40.682]                       else if (inherits(cond, "condition")) {
[17:42:40.682]                         if (!is.null(pattern)) {
[17:42:40.682]                           computeRestarts <- base::computeRestarts
[17:42:40.682]                           grepl <- base::grepl
[17:42:40.682]                           restarts <- computeRestarts(cond)
[17:42:40.682]                           for (restart in restarts) {
[17:42:40.682]                             name <- restart$name
[17:42:40.682]                             if (is.null(name)) 
[17:42:40.682]                               next
[17:42:40.682]                             if (!grepl(pattern, name)) 
[17:42:40.682]                               next
[17:42:40.682]                             invokeRestart(restart)
[17:42:40.682]                             muffled <- TRUE
[17:42:40.682]                             break
[17:42:40.682]                           }
[17:42:40.682]                         }
[17:42:40.682]                       }
[17:42:40.682]                       invisible(muffled)
[17:42:40.682]                     }
[17:42:40.682]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.682]                   }
[17:42:40.682]                 }
[17:42:40.682]             }
[17:42:40.682]         }))
[17:42:40.682]     }, error = function(ex) {
[17:42:40.682]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:40.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.682]                 ...future.rng), started = ...future.startTime, 
[17:42:40.682]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:40.682]             version = "1.8"), class = "FutureResult")
[17:42:40.682]     }, finally = {
[17:42:40.682]         if (!identical(...future.workdir, getwd())) 
[17:42:40.682]             setwd(...future.workdir)
[17:42:40.682]         {
[17:42:40.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:40.682]                 ...future.oldOptions$nwarnings <- NULL
[17:42:40.682]             }
[17:42:40.682]             base::options(...future.oldOptions)
[17:42:40.682]             if (.Platform$OS.type == "windows") {
[17:42:40.682]                 old_names <- names(...future.oldEnvVars)
[17:42:40.682]                 envs <- base::Sys.getenv()
[17:42:40.682]                 names <- names(envs)
[17:42:40.682]                 common <- intersect(names, old_names)
[17:42:40.682]                 added <- setdiff(names, old_names)
[17:42:40.682]                 removed <- setdiff(old_names, names)
[17:42:40.682]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:40.682]                   envs[common]]
[17:42:40.682]                 NAMES <- toupper(changed)
[17:42:40.682]                 args <- list()
[17:42:40.682]                 for (kk in seq_along(NAMES)) {
[17:42:40.682]                   name <- changed[[kk]]
[17:42:40.682]                   NAME <- NAMES[[kk]]
[17:42:40.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.682]                     next
[17:42:40.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.682]                 }
[17:42:40.682]                 NAMES <- toupper(added)
[17:42:40.682]                 for (kk in seq_along(NAMES)) {
[17:42:40.682]                   name <- added[[kk]]
[17:42:40.682]                   NAME <- NAMES[[kk]]
[17:42:40.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.682]                     next
[17:42:40.682]                   args[[name]] <- ""
[17:42:40.682]                 }
[17:42:40.682]                 NAMES <- toupper(removed)
[17:42:40.682]                 for (kk in seq_along(NAMES)) {
[17:42:40.682]                   name <- removed[[kk]]
[17:42:40.682]                   NAME <- NAMES[[kk]]
[17:42:40.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.682]                     next
[17:42:40.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.682]                 }
[17:42:40.682]                 if (length(args) > 0) 
[17:42:40.682]                   base::do.call(base::Sys.setenv, args = args)
[17:42:40.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:40.682]             }
[17:42:40.682]             else {
[17:42:40.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:40.682]             }
[17:42:40.682]             {
[17:42:40.682]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:40.682]                   0L) {
[17:42:40.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:40.682]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:40.682]                   base::options(opts)
[17:42:40.682]                 }
[17:42:40.682]                 {
[17:42:40.682]                   {
[17:42:40.682]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:40.682]                     NULL
[17:42:40.682]                   }
[17:42:40.682]                   options(future.plan = NULL)
[17:42:40.682]                   if (is.na(NA_character_)) 
[17:42:40.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:40.682]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:40.682]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:40.682]                     envir = parent.frame()) 
[17:42:40.682]                   {
[17:42:40.682]                     if (is.function(workers)) 
[17:42:40.682]                       workers <- workers()
[17:42:40.682]                     workers <- structure(as.integer(workers), 
[17:42:40.682]                       class = class(workers))
[17:42:40.682]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:40.682]                       workers >= 1)
[17:42:40.682]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:40.682]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:40.682]                     }
[17:42:40.682]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:40.682]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:40.682]                       envir = envir)
[17:42:40.682]                     if (!future$lazy) 
[17:42:40.682]                       future <- run(future)
[17:42:40.682]                     invisible(future)
[17:42:40.682]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:40.682]                 }
[17:42:40.682]             }
[17:42:40.682]         }
[17:42:40.682]     })
[17:42:40.682]     if (TRUE) {
[17:42:40.682]         base::sink(type = "output", split = FALSE)
[17:42:40.682]         if (TRUE) {
[17:42:40.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:40.682]         }
[17:42:40.682]         else {
[17:42:40.682]             ...future.result["stdout"] <- base::list(NULL)
[17:42:40.682]         }
[17:42:40.682]         base::close(...future.stdout)
[17:42:40.682]         ...future.stdout <- NULL
[17:42:40.682]     }
[17:42:40.682]     ...future.result$conditions <- ...future.conditions
[17:42:40.682]     ...future.result$finished <- base::Sys.time()
[17:42:40.682]     ...future.result
[17:42:40.682] }
[17:42:40.685] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:42:40.685] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:42:40.685] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:42:40.685] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:42:40.686] MultisessionFuture started
[17:42:40.686] - Launch lazy future ... done
[17:42:40.686] run() for ‘MultisessionFuture’ ... done
[17:42:40.686] result() for ClusterFuture ...
[17:42:40.686] receiveMessageFromWorker() for ClusterFuture ...
[17:42:40.687] - Validating connection of MultisessionFuture
[17:42:40.732] - received message: FutureResult
[17:42:40.732] - Received FutureResult
[17:42:40.732] - Erased future from FutureRegistry
[17:42:40.732] result() for ClusterFuture ...
[17:42:40.732] - result already collected: FutureResult
[17:42:40.732] result() for ClusterFuture ... done
[17:42:40.733] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:40.733] result() for ClusterFuture ... done
[17:42:40.733] result() for ClusterFuture ...
[17:42:40.733] - result already collected: FutureResult
[17:42:40.733] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:40.734] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:40.734] Searching for globals...
[17:42:40.736] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:42:40.736] Searching for globals ... DONE
[17:42:40.736] Resolving globals: TRUE
[17:42:40.737] Resolving any globals that are futures ...
[17:42:40.737] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:42:40.737] Resolving any globals that are futures ... DONE
[17:42:40.737] 
[17:42:40.737] 
[17:42:40.737] getGlobalsAndPackages() ... DONE
[17:42:40.738] run() for ‘Future’ ...
[17:42:40.738] - state: ‘created’
[17:42:40.738] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:40.752] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:40.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:40.753]   - Field: ‘node’
[17:42:40.753]   - Field: ‘label’
[17:42:40.753]   - Field: ‘local’
[17:42:40.753]   - Field: ‘owner’
[17:42:40.753]   - Field: ‘envir’
[17:42:40.753]   - Field: ‘workers’
[17:42:40.753]   - Field: ‘packages’
[17:42:40.753]   - Field: ‘gc’
[17:42:40.754]   - Field: ‘conditions’
[17:42:40.754]   - Field: ‘persistent’
[17:42:40.754]   - Field: ‘expr’
[17:42:40.754]   - Field: ‘uuid’
[17:42:40.754]   - Field: ‘seed’
[17:42:40.754]   - Field: ‘version’
[17:42:40.754]   - Field: ‘result’
[17:42:40.754]   - Field: ‘asynchronous’
[17:42:40.754]   - Field: ‘calls’
[17:42:40.754]   - Field: ‘globals’
[17:42:40.754]   - Field: ‘stdout’
[17:42:40.755]   - Field: ‘earlySignal’
[17:42:40.755]   - Field: ‘lazy’
[17:42:40.755]   - Field: ‘state’
[17:42:40.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:40.755] - Launch lazy future ...
[17:42:40.755] Packages needed by the future expression (n = 0): <none>
[17:42:40.755] Packages needed by future strategies (n = 0): <none>
[17:42:40.756] {
[17:42:40.756]     {
[17:42:40.756]         {
[17:42:40.756]             ...future.startTime <- base::Sys.time()
[17:42:40.756]             {
[17:42:40.756]                 {
[17:42:40.756]                   {
[17:42:40.756]                     {
[17:42:40.756]                       base::local({
[17:42:40.756]                         has_future <- base::requireNamespace("future", 
[17:42:40.756]                           quietly = TRUE)
[17:42:40.756]                         if (has_future) {
[17:42:40.756]                           ns <- base::getNamespace("future")
[17:42:40.756]                           version <- ns[[".package"]][["version"]]
[17:42:40.756]                           if (is.null(version)) 
[17:42:40.756]                             version <- utils::packageVersion("future")
[17:42:40.756]                         }
[17:42:40.756]                         else {
[17:42:40.756]                           version <- NULL
[17:42:40.756]                         }
[17:42:40.756]                         if (!has_future || version < "1.8.0") {
[17:42:40.756]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:40.756]                             "", base::R.version$version.string), 
[17:42:40.756]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:40.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:40.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:40.756]                               "release", "version")], collapse = " "), 
[17:42:40.756]                             hostname = base::Sys.info()[["nodename"]])
[17:42:40.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:40.756]                             info)
[17:42:40.756]                           info <- base::paste(info, collapse = "; ")
[17:42:40.756]                           if (!has_future) {
[17:42:40.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:40.756]                               info)
[17:42:40.756]                           }
[17:42:40.756]                           else {
[17:42:40.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:40.756]                               info, version)
[17:42:40.756]                           }
[17:42:40.756]                           base::stop(msg)
[17:42:40.756]                         }
[17:42:40.756]                       })
[17:42:40.756]                     }
[17:42:40.756]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:40.756]                     base::options(mc.cores = 1L)
[17:42:40.756]                   }
[17:42:40.756]                   options(future.plan = NULL)
[17:42:40.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:40.756]                 }
[17:42:40.756]                 ...future.workdir <- getwd()
[17:42:40.756]             }
[17:42:40.756]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:40.756]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:40.756]         }
[17:42:40.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:40.756]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:40.756]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:40.756]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:40.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:40.756]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:40.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:40.756]             base::names(...future.oldOptions))
[17:42:40.756]     }
[17:42:40.756]     if (FALSE) {
[17:42:40.756]     }
[17:42:40.756]     else {
[17:42:40.756]         if (TRUE) {
[17:42:40.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:40.756]                 open = "w")
[17:42:40.756]         }
[17:42:40.756]         else {
[17:42:40.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:40.756]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:40.756]         }
[17:42:40.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:40.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:40.756]             base::sink(type = "output", split = FALSE)
[17:42:40.756]             base::close(...future.stdout)
[17:42:40.756]         }, add = TRUE)
[17:42:40.756]     }
[17:42:40.756]     ...future.frame <- base::sys.nframe()
[17:42:40.756]     ...future.conditions <- base::list()
[17:42:40.756]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:40.756]     if (FALSE) {
[17:42:40.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:40.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:40.756]     }
[17:42:40.756]     ...future.result <- base::tryCatch({
[17:42:40.756]         base::withCallingHandlers({
[17:42:40.756]             ...future.value <- base::withVisible(base::local({
[17:42:40.756]                 ...future.makeSendCondition <- local({
[17:42:40.756]                   sendCondition <- NULL
[17:42:40.756]                   function(frame = 1L) {
[17:42:40.756]                     if (is.function(sendCondition)) 
[17:42:40.756]                       return(sendCondition)
[17:42:40.756]                     ns <- getNamespace("parallel")
[17:42:40.756]                     if (exists("sendData", mode = "function", 
[17:42:40.756]                       envir = ns)) {
[17:42:40.756]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:40.756]                         envir = ns)
[17:42:40.756]                       envir <- sys.frame(frame)
[17:42:40.756]                       master <- NULL
[17:42:40.756]                       while (!identical(envir, .GlobalEnv) && 
[17:42:40.756]                         !identical(envir, emptyenv())) {
[17:42:40.756]                         if (exists("master", mode = "list", envir = envir, 
[17:42:40.756]                           inherits = FALSE)) {
[17:42:40.756]                           master <- get("master", mode = "list", 
[17:42:40.756]                             envir = envir, inherits = FALSE)
[17:42:40.756]                           if (inherits(master, c("SOCKnode", 
[17:42:40.756]                             "SOCK0node"))) {
[17:42:40.756]                             sendCondition <<- function(cond) {
[17:42:40.756]                               data <- list(type = "VALUE", value = cond, 
[17:42:40.756]                                 success = TRUE)
[17:42:40.756]                               parallel_sendData(master, data)
[17:42:40.756]                             }
[17:42:40.756]                             return(sendCondition)
[17:42:40.756]                           }
[17:42:40.756]                         }
[17:42:40.756]                         frame <- frame + 1L
[17:42:40.756]                         envir <- sys.frame(frame)
[17:42:40.756]                       }
[17:42:40.756]                     }
[17:42:40.756]                     sendCondition <<- function(cond) NULL
[17:42:40.756]                   }
[17:42:40.756]                 })
[17:42:40.756]                 withCallingHandlers({
[17:42:40.756]                   {
[17:42:40.756]                     x <- list(b = 2)
[17:42:40.756]                     x$a <- 1
[17:42:40.756]                     x
[17:42:40.756]                   }
[17:42:40.756]                 }, immediateCondition = function(cond) {
[17:42:40.756]                   sendCondition <- ...future.makeSendCondition()
[17:42:40.756]                   sendCondition(cond)
[17:42:40.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.756]                   {
[17:42:40.756]                     inherits <- base::inherits
[17:42:40.756]                     invokeRestart <- base::invokeRestart
[17:42:40.756]                     is.null <- base::is.null
[17:42:40.756]                     muffled <- FALSE
[17:42:40.756]                     if (inherits(cond, "message")) {
[17:42:40.756]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:40.756]                       if (muffled) 
[17:42:40.756]                         invokeRestart("muffleMessage")
[17:42:40.756]                     }
[17:42:40.756]                     else if (inherits(cond, "warning")) {
[17:42:40.756]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:40.756]                       if (muffled) 
[17:42:40.756]                         invokeRestart("muffleWarning")
[17:42:40.756]                     }
[17:42:40.756]                     else if (inherits(cond, "condition")) {
[17:42:40.756]                       if (!is.null(pattern)) {
[17:42:40.756]                         computeRestarts <- base::computeRestarts
[17:42:40.756]                         grepl <- base::grepl
[17:42:40.756]                         restarts <- computeRestarts(cond)
[17:42:40.756]                         for (restart in restarts) {
[17:42:40.756]                           name <- restart$name
[17:42:40.756]                           if (is.null(name)) 
[17:42:40.756]                             next
[17:42:40.756]                           if (!grepl(pattern, name)) 
[17:42:40.756]                             next
[17:42:40.756]                           invokeRestart(restart)
[17:42:40.756]                           muffled <- TRUE
[17:42:40.756]                           break
[17:42:40.756]                         }
[17:42:40.756]                       }
[17:42:40.756]                     }
[17:42:40.756]                     invisible(muffled)
[17:42:40.756]                   }
[17:42:40.756]                   muffleCondition(cond)
[17:42:40.756]                 })
[17:42:40.756]             }))
[17:42:40.756]             future::FutureResult(value = ...future.value$value, 
[17:42:40.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.756]                   ...future.rng), globalenv = if (FALSE) 
[17:42:40.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:40.756]                     ...future.globalenv.names))
[17:42:40.756]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:40.756]         }, condition = base::local({
[17:42:40.756]             c <- base::c
[17:42:40.756]             inherits <- base::inherits
[17:42:40.756]             invokeRestart <- base::invokeRestart
[17:42:40.756]             length <- base::length
[17:42:40.756]             list <- base::list
[17:42:40.756]             seq.int <- base::seq.int
[17:42:40.756]             signalCondition <- base::signalCondition
[17:42:40.756]             sys.calls <- base::sys.calls
[17:42:40.756]             `[[` <- base::`[[`
[17:42:40.756]             `+` <- base::`+`
[17:42:40.756]             `<<-` <- base::`<<-`
[17:42:40.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:40.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:40.756]                   3L)]
[17:42:40.756]             }
[17:42:40.756]             function(cond) {
[17:42:40.756]                 is_error <- inherits(cond, "error")
[17:42:40.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:40.756]                   NULL)
[17:42:40.756]                 if (is_error) {
[17:42:40.756]                   sessionInformation <- function() {
[17:42:40.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:40.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:40.756]                       search = base::search(), system = base::Sys.info())
[17:42:40.756]                   }
[17:42:40.756]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:40.756]                     cond$call), session = sessionInformation(), 
[17:42:40.756]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:40.756]                   signalCondition(cond)
[17:42:40.756]                 }
[17:42:40.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:40.756]                 "immediateCondition"))) {
[17:42:40.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:40.756]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:40.756]                   if (TRUE && !signal) {
[17:42:40.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.756]                     {
[17:42:40.756]                       inherits <- base::inherits
[17:42:40.756]                       invokeRestart <- base::invokeRestart
[17:42:40.756]                       is.null <- base::is.null
[17:42:40.756]                       muffled <- FALSE
[17:42:40.756]                       if (inherits(cond, "message")) {
[17:42:40.756]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.756]                         if (muffled) 
[17:42:40.756]                           invokeRestart("muffleMessage")
[17:42:40.756]                       }
[17:42:40.756]                       else if (inherits(cond, "warning")) {
[17:42:40.756]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.756]                         if (muffled) 
[17:42:40.756]                           invokeRestart("muffleWarning")
[17:42:40.756]                       }
[17:42:40.756]                       else if (inherits(cond, "condition")) {
[17:42:40.756]                         if (!is.null(pattern)) {
[17:42:40.756]                           computeRestarts <- base::computeRestarts
[17:42:40.756]                           grepl <- base::grepl
[17:42:40.756]                           restarts <- computeRestarts(cond)
[17:42:40.756]                           for (restart in restarts) {
[17:42:40.756]                             name <- restart$name
[17:42:40.756]                             if (is.null(name)) 
[17:42:40.756]                               next
[17:42:40.756]                             if (!grepl(pattern, name)) 
[17:42:40.756]                               next
[17:42:40.756]                             invokeRestart(restart)
[17:42:40.756]                             muffled <- TRUE
[17:42:40.756]                             break
[17:42:40.756]                           }
[17:42:40.756]                         }
[17:42:40.756]                       }
[17:42:40.756]                       invisible(muffled)
[17:42:40.756]                     }
[17:42:40.756]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.756]                   }
[17:42:40.756]                 }
[17:42:40.756]                 else {
[17:42:40.756]                   if (TRUE) {
[17:42:40.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.756]                     {
[17:42:40.756]                       inherits <- base::inherits
[17:42:40.756]                       invokeRestart <- base::invokeRestart
[17:42:40.756]                       is.null <- base::is.null
[17:42:40.756]                       muffled <- FALSE
[17:42:40.756]                       if (inherits(cond, "message")) {
[17:42:40.756]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.756]                         if (muffled) 
[17:42:40.756]                           invokeRestart("muffleMessage")
[17:42:40.756]                       }
[17:42:40.756]                       else if (inherits(cond, "warning")) {
[17:42:40.756]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.756]                         if (muffled) 
[17:42:40.756]                           invokeRestart("muffleWarning")
[17:42:40.756]                       }
[17:42:40.756]                       else if (inherits(cond, "condition")) {
[17:42:40.756]                         if (!is.null(pattern)) {
[17:42:40.756]                           computeRestarts <- base::computeRestarts
[17:42:40.756]                           grepl <- base::grepl
[17:42:40.756]                           restarts <- computeRestarts(cond)
[17:42:40.756]                           for (restart in restarts) {
[17:42:40.756]                             name <- restart$name
[17:42:40.756]                             if (is.null(name)) 
[17:42:40.756]                               next
[17:42:40.756]                             if (!grepl(pattern, name)) 
[17:42:40.756]                               next
[17:42:40.756]                             invokeRestart(restart)
[17:42:40.756]                             muffled <- TRUE
[17:42:40.756]                             break
[17:42:40.756]                           }
[17:42:40.756]                         }
[17:42:40.756]                       }
[17:42:40.756]                       invisible(muffled)
[17:42:40.756]                     }
[17:42:40.756]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.756]                   }
[17:42:40.756]                 }
[17:42:40.756]             }
[17:42:40.756]         }))
[17:42:40.756]     }, error = function(ex) {
[17:42:40.756]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:40.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.756]                 ...future.rng), started = ...future.startTime, 
[17:42:40.756]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:40.756]             version = "1.8"), class = "FutureResult")
[17:42:40.756]     }, finally = {
[17:42:40.756]         if (!identical(...future.workdir, getwd())) 
[17:42:40.756]             setwd(...future.workdir)
[17:42:40.756]         {
[17:42:40.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:40.756]                 ...future.oldOptions$nwarnings <- NULL
[17:42:40.756]             }
[17:42:40.756]             base::options(...future.oldOptions)
[17:42:40.756]             if (.Platform$OS.type == "windows") {
[17:42:40.756]                 old_names <- names(...future.oldEnvVars)
[17:42:40.756]                 envs <- base::Sys.getenv()
[17:42:40.756]                 names <- names(envs)
[17:42:40.756]                 common <- intersect(names, old_names)
[17:42:40.756]                 added <- setdiff(names, old_names)
[17:42:40.756]                 removed <- setdiff(old_names, names)
[17:42:40.756]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:40.756]                   envs[common]]
[17:42:40.756]                 NAMES <- toupper(changed)
[17:42:40.756]                 args <- list()
[17:42:40.756]                 for (kk in seq_along(NAMES)) {
[17:42:40.756]                   name <- changed[[kk]]
[17:42:40.756]                   NAME <- NAMES[[kk]]
[17:42:40.756]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.756]                     next
[17:42:40.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.756]                 }
[17:42:40.756]                 NAMES <- toupper(added)
[17:42:40.756]                 for (kk in seq_along(NAMES)) {
[17:42:40.756]                   name <- added[[kk]]
[17:42:40.756]                   NAME <- NAMES[[kk]]
[17:42:40.756]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.756]                     next
[17:42:40.756]                   args[[name]] <- ""
[17:42:40.756]                 }
[17:42:40.756]                 NAMES <- toupper(removed)
[17:42:40.756]                 for (kk in seq_along(NAMES)) {
[17:42:40.756]                   name <- removed[[kk]]
[17:42:40.756]                   NAME <- NAMES[[kk]]
[17:42:40.756]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.756]                     next
[17:42:40.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.756]                 }
[17:42:40.756]                 if (length(args) > 0) 
[17:42:40.756]                   base::do.call(base::Sys.setenv, args = args)
[17:42:40.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:40.756]             }
[17:42:40.756]             else {
[17:42:40.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:40.756]             }
[17:42:40.756]             {
[17:42:40.756]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:40.756]                   0L) {
[17:42:40.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:40.756]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:40.756]                   base::options(opts)
[17:42:40.756]                 }
[17:42:40.756]                 {
[17:42:40.756]                   {
[17:42:40.756]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:40.756]                     NULL
[17:42:40.756]                   }
[17:42:40.756]                   options(future.plan = NULL)
[17:42:40.756]                   if (is.na(NA_character_)) 
[17:42:40.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:40.756]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:40.756]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:40.756]                     envir = parent.frame()) 
[17:42:40.756]                   {
[17:42:40.756]                     if (is.function(workers)) 
[17:42:40.756]                       workers <- workers()
[17:42:40.756]                     workers <- structure(as.integer(workers), 
[17:42:40.756]                       class = class(workers))
[17:42:40.756]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:40.756]                       workers >= 1)
[17:42:40.756]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:40.756]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:40.756]                     }
[17:42:40.756]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:40.756]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:40.756]                       envir = envir)
[17:42:40.756]                     if (!future$lazy) 
[17:42:40.756]                       future <- run(future)
[17:42:40.756]                     invisible(future)
[17:42:40.756]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:40.756]                 }
[17:42:40.756]             }
[17:42:40.756]         }
[17:42:40.756]     })
[17:42:40.756]     if (TRUE) {
[17:42:40.756]         base::sink(type = "output", split = FALSE)
[17:42:40.756]         if (TRUE) {
[17:42:40.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:40.756]         }
[17:42:40.756]         else {
[17:42:40.756]             ...future.result["stdout"] <- base::list(NULL)
[17:42:40.756]         }
[17:42:40.756]         base::close(...future.stdout)
[17:42:40.756]         ...future.stdout <- NULL
[17:42:40.756]     }
[17:42:40.756]     ...future.result$conditions <- ...future.conditions
[17:42:40.756]     ...future.result$finished <- base::Sys.time()
[17:42:40.756]     ...future.result
[17:42:40.756] }
[17:42:40.759] MultisessionFuture started
[17:42:40.759] - Launch lazy future ... done
[17:42:40.759] run() for ‘MultisessionFuture’ ... done
[17:42:40.760] result() for ClusterFuture ...
[17:42:40.760] receiveMessageFromWorker() for ClusterFuture ...
[17:42:40.760] - Validating connection of MultisessionFuture
[17:42:40.808] - received message: FutureResult
[17:42:40.808] - Received FutureResult
[17:42:40.808] - Erased future from FutureRegistry
[17:42:40.809] result() for ClusterFuture ...
[17:42:40.809] - result already collected: FutureResult
[17:42:40.809] result() for ClusterFuture ... done
[17:42:40.809] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:40.809] result() for ClusterFuture ... done
[17:42:40.809] result() for ClusterFuture ...
[17:42:40.809] - result already collected: FutureResult
[17:42:40.809] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:40.810] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:40.810] Searching for globals...
[17:42:40.812] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:40.812] Searching for globals ... DONE
[17:42:40.812] Resolving globals: TRUE
[17:42:40.812] Resolving any globals that are futures ...
[17:42:40.813] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:40.813] Resolving any globals that are futures ... DONE
[17:42:40.813] Resolving futures part of globals (recursively) ...
[17:42:40.813] resolve() on list ...
[17:42:40.813]  recursive: 99
[17:42:40.813]  length: 1
[17:42:40.814]  elements: ‘x’
[17:42:40.814]  length: 0 (resolved future 1)
[17:42:40.814] resolve() on list ... DONE
[17:42:40.814] - globals: [1] ‘x’
[17:42:40.814] Resolving futures part of globals (recursively) ... DONE
[17:42:40.814] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:40.814] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:40.815] - globals: [1] ‘x’
[17:42:40.815] 
[17:42:40.815] getGlobalsAndPackages() ... DONE
[17:42:40.815] run() for ‘Future’ ...
[17:42:40.815] - state: ‘created’
[17:42:40.815] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:40.830] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:40.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:40.830]   - Field: ‘node’
[17:42:40.830]   - Field: ‘label’
[17:42:40.830]   - Field: ‘local’
[17:42:40.830]   - Field: ‘owner’
[17:42:40.831]   - Field: ‘envir’
[17:42:40.831]   - Field: ‘workers’
[17:42:40.831]   - Field: ‘packages’
[17:42:40.831]   - Field: ‘gc’
[17:42:40.831]   - Field: ‘conditions’
[17:42:40.831]   - Field: ‘persistent’
[17:42:40.831]   - Field: ‘expr’
[17:42:40.831]   - Field: ‘uuid’
[17:42:40.831]   - Field: ‘seed’
[17:42:40.831]   - Field: ‘version’
[17:42:40.832]   - Field: ‘result’
[17:42:40.832]   - Field: ‘asynchronous’
[17:42:40.832]   - Field: ‘calls’
[17:42:40.832]   - Field: ‘globals’
[17:42:40.832]   - Field: ‘stdout’
[17:42:40.832]   - Field: ‘earlySignal’
[17:42:40.832]   - Field: ‘lazy’
[17:42:40.832]   - Field: ‘state’
[17:42:40.832] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:40.832] - Launch lazy future ...
[17:42:40.833] Packages needed by the future expression (n = 0): <none>
[17:42:40.833] Packages needed by future strategies (n = 0): <none>
[17:42:40.833] {
[17:42:40.833]     {
[17:42:40.833]         {
[17:42:40.833]             ...future.startTime <- base::Sys.time()
[17:42:40.833]             {
[17:42:40.833]                 {
[17:42:40.833]                   {
[17:42:40.833]                     {
[17:42:40.833]                       base::local({
[17:42:40.833]                         has_future <- base::requireNamespace("future", 
[17:42:40.833]                           quietly = TRUE)
[17:42:40.833]                         if (has_future) {
[17:42:40.833]                           ns <- base::getNamespace("future")
[17:42:40.833]                           version <- ns[[".package"]][["version"]]
[17:42:40.833]                           if (is.null(version)) 
[17:42:40.833]                             version <- utils::packageVersion("future")
[17:42:40.833]                         }
[17:42:40.833]                         else {
[17:42:40.833]                           version <- NULL
[17:42:40.833]                         }
[17:42:40.833]                         if (!has_future || version < "1.8.0") {
[17:42:40.833]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:40.833]                             "", base::R.version$version.string), 
[17:42:40.833]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:40.833]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:40.833]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:40.833]                               "release", "version")], collapse = " "), 
[17:42:40.833]                             hostname = base::Sys.info()[["nodename"]])
[17:42:40.833]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:40.833]                             info)
[17:42:40.833]                           info <- base::paste(info, collapse = "; ")
[17:42:40.833]                           if (!has_future) {
[17:42:40.833]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:40.833]                               info)
[17:42:40.833]                           }
[17:42:40.833]                           else {
[17:42:40.833]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:40.833]                               info, version)
[17:42:40.833]                           }
[17:42:40.833]                           base::stop(msg)
[17:42:40.833]                         }
[17:42:40.833]                       })
[17:42:40.833]                     }
[17:42:40.833]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:40.833]                     base::options(mc.cores = 1L)
[17:42:40.833]                   }
[17:42:40.833]                   options(future.plan = NULL)
[17:42:40.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:40.833]                 }
[17:42:40.833]                 ...future.workdir <- getwd()
[17:42:40.833]             }
[17:42:40.833]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:40.833]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:40.833]         }
[17:42:40.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:40.833]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:40.833]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:40.833]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:40.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:40.833]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:40.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:40.833]             base::names(...future.oldOptions))
[17:42:40.833]     }
[17:42:40.833]     if (FALSE) {
[17:42:40.833]     }
[17:42:40.833]     else {
[17:42:40.833]         if (TRUE) {
[17:42:40.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:40.833]                 open = "w")
[17:42:40.833]         }
[17:42:40.833]         else {
[17:42:40.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:40.833]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:40.833]         }
[17:42:40.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:40.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:40.833]             base::sink(type = "output", split = FALSE)
[17:42:40.833]             base::close(...future.stdout)
[17:42:40.833]         }, add = TRUE)
[17:42:40.833]     }
[17:42:40.833]     ...future.frame <- base::sys.nframe()
[17:42:40.833]     ...future.conditions <- base::list()
[17:42:40.833]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:40.833]     if (FALSE) {
[17:42:40.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:40.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:40.833]     }
[17:42:40.833]     ...future.result <- base::tryCatch({
[17:42:40.833]         base::withCallingHandlers({
[17:42:40.833]             ...future.value <- base::withVisible(base::local({
[17:42:40.833]                 ...future.makeSendCondition <- local({
[17:42:40.833]                   sendCondition <- NULL
[17:42:40.833]                   function(frame = 1L) {
[17:42:40.833]                     if (is.function(sendCondition)) 
[17:42:40.833]                       return(sendCondition)
[17:42:40.833]                     ns <- getNamespace("parallel")
[17:42:40.833]                     if (exists("sendData", mode = "function", 
[17:42:40.833]                       envir = ns)) {
[17:42:40.833]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:40.833]                         envir = ns)
[17:42:40.833]                       envir <- sys.frame(frame)
[17:42:40.833]                       master <- NULL
[17:42:40.833]                       while (!identical(envir, .GlobalEnv) && 
[17:42:40.833]                         !identical(envir, emptyenv())) {
[17:42:40.833]                         if (exists("master", mode = "list", envir = envir, 
[17:42:40.833]                           inherits = FALSE)) {
[17:42:40.833]                           master <- get("master", mode = "list", 
[17:42:40.833]                             envir = envir, inherits = FALSE)
[17:42:40.833]                           if (inherits(master, c("SOCKnode", 
[17:42:40.833]                             "SOCK0node"))) {
[17:42:40.833]                             sendCondition <<- function(cond) {
[17:42:40.833]                               data <- list(type = "VALUE", value = cond, 
[17:42:40.833]                                 success = TRUE)
[17:42:40.833]                               parallel_sendData(master, data)
[17:42:40.833]                             }
[17:42:40.833]                             return(sendCondition)
[17:42:40.833]                           }
[17:42:40.833]                         }
[17:42:40.833]                         frame <- frame + 1L
[17:42:40.833]                         envir <- sys.frame(frame)
[17:42:40.833]                       }
[17:42:40.833]                     }
[17:42:40.833]                     sendCondition <<- function(cond) NULL
[17:42:40.833]                   }
[17:42:40.833]                 })
[17:42:40.833]                 withCallingHandlers({
[17:42:40.833]                   {
[17:42:40.833]                     x[["a"]] <- 1
[17:42:40.833]                     x
[17:42:40.833]                   }
[17:42:40.833]                 }, immediateCondition = function(cond) {
[17:42:40.833]                   sendCondition <- ...future.makeSendCondition()
[17:42:40.833]                   sendCondition(cond)
[17:42:40.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.833]                   {
[17:42:40.833]                     inherits <- base::inherits
[17:42:40.833]                     invokeRestart <- base::invokeRestart
[17:42:40.833]                     is.null <- base::is.null
[17:42:40.833]                     muffled <- FALSE
[17:42:40.833]                     if (inherits(cond, "message")) {
[17:42:40.833]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:40.833]                       if (muffled) 
[17:42:40.833]                         invokeRestart("muffleMessage")
[17:42:40.833]                     }
[17:42:40.833]                     else if (inherits(cond, "warning")) {
[17:42:40.833]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:40.833]                       if (muffled) 
[17:42:40.833]                         invokeRestart("muffleWarning")
[17:42:40.833]                     }
[17:42:40.833]                     else if (inherits(cond, "condition")) {
[17:42:40.833]                       if (!is.null(pattern)) {
[17:42:40.833]                         computeRestarts <- base::computeRestarts
[17:42:40.833]                         grepl <- base::grepl
[17:42:40.833]                         restarts <- computeRestarts(cond)
[17:42:40.833]                         for (restart in restarts) {
[17:42:40.833]                           name <- restart$name
[17:42:40.833]                           if (is.null(name)) 
[17:42:40.833]                             next
[17:42:40.833]                           if (!grepl(pattern, name)) 
[17:42:40.833]                             next
[17:42:40.833]                           invokeRestart(restart)
[17:42:40.833]                           muffled <- TRUE
[17:42:40.833]                           break
[17:42:40.833]                         }
[17:42:40.833]                       }
[17:42:40.833]                     }
[17:42:40.833]                     invisible(muffled)
[17:42:40.833]                   }
[17:42:40.833]                   muffleCondition(cond)
[17:42:40.833]                 })
[17:42:40.833]             }))
[17:42:40.833]             future::FutureResult(value = ...future.value$value, 
[17:42:40.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.833]                   ...future.rng), globalenv = if (FALSE) 
[17:42:40.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:40.833]                     ...future.globalenv.names))
[17:42:40.833]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:40.833]         }, condition = base::local({
[17:42:40.833]             c <- base::c
[17:42:40.833]             inherits <- base::inherits
[17:42:40.833]             invokeRestart <- base::invokeRestart
[17:42:40.833]             length <- base::length
[17:42:40.833]             list <- base::list
[17:42:40.833]             seq.int <- base::seq.int
[17:42:40.833]             signalCondition <- base::signalCondition
[17:42:40.833]             sys.calls <- base::sys.calls
[17:42:40.833]             `[[` <- base::`[[`
[17:42:40.833]             `+` <- base::`+`
[17:42:40.833]             `<<-` <- base::`<<-`
[17:42:40.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:40.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:40.833]                   3L)]
[17:42:40.833]             }
[17:42:40.833]             function(cond) {
[17:42:40.833]                 is_error <- inherits(cond, "error")
[17:42:40.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:40.833]                   NULL)
[17:42:40.833]                 if (is_error) {
[17:42:40.833]                   sessionInformation <- function() {
[17:42:40.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:40.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:40.833]                       search = base::search(), system = base::Sys.info())
[17:42:40.833]                   }
[17:42:40.833]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:40.833]                     cond$call), session = sessionInformation(), 
[17:42:40.833]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:40.833]                   signalCondition(cond)
[17:42:40.833]                 }
[17:42:40.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:40.833]                 "immediateCondition"))) {
[17:42:40.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:40.833]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:40.833]                   if (TRUE && !signal) {
[17:42:40.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.833]                     {
[17:42:40.833]                       inherits <- base::inherits
[17:42:40.833]                       invokeRestart <- base::invokeRestart
[17:42:40.833]                       is.null <- base::is.null
[17:42:40.833]                       muffled <- FALSE
[17:42:40.833]                       if (inherits(cond, "message")) {
[17:42:40.833]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.833]                         if (muffled) 
[17:42:40.833]                           invokeRestart("muffleMessage")
[17:42:40.833]                       }
[17:42:40.833]                       else if (inherits(cond, "warning")) {
[17:42:40.833]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.833]                         if (muffled) 
[17:42:40.833]                           invokeRestart("muffleWarning")
[17:42:40.833]                       }
[17:42:40.833]                       else if (inherits(cond, "condition")) {
[17:42:40.833]                         if (!is.null(pattern)) {
[17:42:40.833]                           computeRestarts <- base::computeRestarts
[17:42:40.833]                           grepl <- base::grepl
[17:42:40.833]                           restarts <- computeRestarts(cond)
[17:42:40.833]                           for (restart in restarts) {
[17:42:40.833]                             name <- restart$name
[17:42:40.833]                             if (is.null(name)) 
[17:42:40.833]                               next
[17:42:40.833]                             if (!grepl(pattern, name)) 
[17:42:40.833]                               next
[17:42:40.833]                             invokeRestart(restart)
[17:42:40.833]                             muffled <- TRUE
[17:42:40.833]                             break
[17:42:40.833]                           }
[17:42:40.833]                         }
[17:42:40.833]                       }
[17:42:40.833]                       invisible(muffled)
[17:42:40.833]                     }
[17:42:40.833]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.833]                   }
[17:42:40.833]                 }
[17:42:40.833]                 else {
[17:42:40.833]                   if (TRUE) {
[17:42:40.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.833]                     {
[17:42:40.833]                       inherits <- base::inherits
[17:42:40.833]                       invokeRestart <- base::invokeRestart
[17:42:40.833]                       is.null <- base::is.null
[17:42:40.833]                       muffled <- FALSE
[17:42:40.833]                       if (inherits(cond, "message")) {
[17:42:40.833]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.833]                         if (muffled) 
[17:42:40.833]                           invokeRestart("muffleMessage")
[17:42:40.833]                       }
[17:42:40.833]                       else if (inherits(cond, "warning")) {
[17:42:40.833]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.833]                         if (muffled) 
[17:42:40.833]                           invokeRestart("muffleWarning")
[17:42:40.833]                       }
[17:42:40.833]                       else if (inherits(cond, "condition")) {
[17:42:40.833]                         if (!is.null(pattern)) {
[17:42:40.833]                           computeRestarts <- base::computeRestarts
[17:42:40.833]                           grepl <- base::grepl
[17:42:40.833]                           restarts <- computeRestarts(cond)
[17:42:40.833]                           for (restart in restarts) {
[17:42:40.833]                             name <- restart$name
[17:42:40.833]                             if (is.null(name)) 
[17:42:40.833]                               next
[17:42:40.833]                             if (!grepl(pattern, name)) 
[17:42:40.833]                               next
[17:42:40.833]                             invokeRestart(restart)
[17:42:40.833]                             muffled <- TRUE
[17:42:40.833]                             break
[17:42:40.833]                           }
[17:42:40.833]                         }
[17:42:40.833]                       }
[17:42:40.833]                       invisible(muffled)
[17:42:40.833]                     }
[17:42:40.833]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.833]                   }
[17:42:40.833]                 }
[17:42:40.833]             }
[17:42:40.833]         }))
[17:42:40.833]     }, error = function(ex) {
[17:42:40.833]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:40.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.833]                 ...future.rng), started = ...future.startTime, 
[17:42:40.833]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:40.833]             version = "1.8"), class = "FutureResult")
[17:42:40.833]     }, finally = {
[17:42:40.833]         if (!identical(...future.workdir, getwd())) 
[17:42:40.833]             setwd(...future.workdir)
[17:42:40.833]         {
[17:42:40.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:40.833]                 ...future.oldOptions$nwarnings <- NULL
[17:42:40.833]             }
[17:42:40.833]             base::options(...future.oldOptions)
[17:42:40.833]             if (.Platform$OS.type == "windows") {
[17:42:40.833]                 old_names <- names(...future.oldEnvVars)
[17:42:40.833]                 envs <- base::Sys.getenv()
[17:42:40.833]                 names <- names(envs)
[17:42:40.833]                 common <- intersect(names, old_names)
[17:42:40.833]                 added <- setdiff(names, old_names)
[17:42:40.833]                 removed <- setdiff(old_names, names)
[17:42:40.833]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:40.833]                   envs[common]]
[17:42:40.833]                 NAMES <- toupper(changed)
[17:42:40.833]                 args <- list()
[17:42:40.833]                 for (kk in seq_along(NAMES)) {
[17:42:40.833]                   name <- changed[[kk]]
[17:42:40.833]                   NAME <- NAMES[[kk]]
[17:42:40.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.833]                     next
[17:42:40.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.833]                 }
[17:42:40.833]                 NAMES <- toupper(added)
[17:42:40.833]                 for (kk in seq_along(NAMES)) {
[17:42:40.833]                   name <- added[[kk]]
[17:42:40.833]                   NAME <- NAMES[[kk]]
[17:42:40.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.833]                     next
[17:42:40.833]                   args[[name]] <- ""
[17:42:40.833]                 }
[17:42:40.833]                 NAMES <- toupper(removed)
[17:42:40.833]                 for (kk in seq_along(NAMES)) {
[17:42:40.833]                   name <- removed[[kk]]
[17:42:40.833]                   NAME <- NAMES[[kk]]
[17:42:40.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.833]                     next
[17:42:40.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.833]                 }
[17:42:40.833]                 if (length(args) > 0) 
[17:42:40.833]                   base::do.call(base::Sys.setenv, args = args)
[17:42:40.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:40.833]             }
[17:42:40.833]             else {
[17:42:40.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:40.833]             }
[17:42:40.833]             {
[17:42:40.833]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:40.833]                   0L) {
[17:42:40.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:40.833]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:40.833]                   base::options(opts)
[17:42:40.833]                 }
[17:42:40.833]                 {
[17:42:40.833]                   {
[17:42:40.833]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:40.833]                     NULL
[17:42:40.833]                   }
[17:42:40.833]                   options(future.plan = NULL)
[17:42:40.833]                   if (is.na(NA_character_)) 
[17:42:40.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:40.833]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:40.833]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:40.833]                     envir = parent.frame()) 
[17:42:40.833]                   {
[17:42:40.833]                     if (is.function(workers)) 
[17:42:40.833]                       workers <- workers()
[17:42:40.833]                     workers <- structure(as.integer(workers), 
[17:42:40.833]                       class = class(workers))
[17:42:40.833]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:40.833]                       workers >= 1)
[17:42:40.833]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:40.833]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:40.833]                     }
[17:42:40.833]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:40.833]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:40.833]                       envir = envir)
[17:42:40.833]                     if (!future$lazy) 
[17:42:40.833]                       future <- run(future)
[17:42:40.833]                     invisible(future)
[17:42:40.833]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:40.833]                 }
[17:42:40.833]             }
[17:42:40.833]         }
[17:42:40.833]     })
[17:42:40.833]     if (TRUE) {
[17:42:40.833]         base::sink(type = "output", split = FALSE)
[17:42:40.833]         if (TRUE) {
[17:42:40.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:40.833]         }
[17:42:40.833]         else {
[17:42:40.833]             ...future.result["stdout"] <- base::list(NULL)
[17:42:40.833]         }
[17:42:40.833]         base::close(...future.stdout)
[17:42:40.833]         ...future.stdout <- NULL
[17:42:40.833]     }
[17:42:40.833]     ...future.result$conditions <- ...future.conditions
[17:42:40.833]     ...future.result$finished <- base::Sys.time()
[17:42:40.833]     ...future.result
[17:42:40.833] }
[17:42:40.836] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:42:40.836] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:42:40.837] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:42:40.837] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:42:40.837] MultisessionFuture started
[17:42:40.838] - Launch lazy future ... done
[17:42:40.838] run() for ‘MultisessionFuture’ ... done
[17:42:40.838] result() for ClusterFuture ...
[17:42:40.838] receiveMessageFromWorker() for ClusterFuture ...
[17:42:40.838] - Validating connection of MultisessionFuture
[17:42:40.884] - received message: FutureResult
[17:42:40.884] - Received FutureResult
[17:42:40.884] - Erased future from FutureRegistry
[17:42:40.884] result() for ClusterFuture ...
[17:42:40.885] - result already collected: FutureResult
[17:42:40.885] result() for ClusterFuture ... done
[17:42:40.885] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:40.885] result() for ClusterFuture ... done
[17:42:40.885] result() for ClusterFuture ...
[17:42:40.885] - result already collected: FutureResult
[17:42:40.885] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:40.885] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:40.886] Searching for globals...
[17:42:40.888] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:40.888] Searching for globals ... DONE
[17:42:40.888] Resolving globals: TRUE
[17:42:40.888] Resolving any globals that are futures ...
[17:42:40.888] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:40.888] Resolving any globals that are futures ... DONE
[17:42:40.889] Resolving futures part of globals (recursively) ...
[17:42:40.889] resolve() on list ...
[17:42:40.889]  recursive: 99
[17:42:40.889]  length: 1
[17:42:40.889]  elements: ‘x’
[17:42:40.889]  length: 0 (resolved future 1)
[17:42:40.889] resolve() on list ... DONE
[17:42:40.889] - globals: [1] ‘x’
[17:42:40.890] Resolving futures part of globals (recursively) ... DONE
[17:42:40.890] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:40.890] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:40.890] - globals: [1] ‘x’
[17:42:40.890] 
[17:42:40.890] getGlobalsAndPackages() ... DONE
[17:42:40.891] run() for ‘Future’ ...
[17:42:40.891] - state: ‘created’
[17:42:40.891] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:40.905] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:40.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:40.906]   - Field: ‘node’
[17:42:40.906]   - Field: ‘label’
[17:42:40.906]   - Field: ‘local’
[17:42:40.906]   - Field: ‘owner’
[17:42:40.906]   - Field: ‘envir’
[17:42:40.906]   - Field: ‘workers’
[17:42:40.906]   - Field: ‘packages’
[17:42:40.906]   - Field: ‘gc’
[17:42:40.906]   - Field: ‘conditions’
[17:42:40.907]   - Field: ‘persistent’
[17:42:40.907]   - Field: ‘expr’
[17:42:40.907]   - Field: ‘uuid’
[17:42:40.907]   - Field: ‘seed’
[17:42:40.907]   - Field: ‘version’
[17:42:40.907]   - Field: ‘result’
[17:42:40.907]   - Field: ‘asynchronous’
[17:42:40.907]   - Field: ‘calls’
[17:42:40.907]   - Field: ‘globals’
[17:42:40.907]   - Field: ‘stdout’
[17:42:40.908]   - Field: ‘earlySignal’
[17:42:40.908]   - Field: ‘lazy’
[17:42:40.908]   - Field: ‘state’
[17:42:40.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:40.908] - Launch lazy future ...
[17:42:40.908] Packages needed by the future expression (n = 0): <none>
[17:42:40.908] Packages needed by future strategies (n = 0): <none>
[17:42:40.909] {
[17:42:40.909]     {
[17:42:40.909]         {
[17:42:40.909]             ...future.startTime <- base::Sys.time()
[17:42:40.909]             {
[17:42:40.909]                 {
[17:42:40.909]                   {
[17:42:40.909]                     {
[17:42:40.909]                       base::local({
[17:42:40.909]                         has_future <- base::requireNamespace("future", 
[17:42:40.909]                           quietly = TRUE)
[17:42:40.909]                         if (has_future) {
[17:42:40.909]                           ns <- base::getNamespace("future")
[17:42:40.909]                           version <- ns[[".package"]][["version"]]
[17:42:40.909]                           if (is.null(version)) 
[17:42:40.909]                             version <- utils::packageVersion("future")
[17:42:40.909]                         }
[17:42:40.909]                         else {
[17:42:40.909]                           version <- NULL
[17:42:40.909]                         }
[17:42:40.909]                         if (!has_future || version < "1.8.0") {
[17:42:40.909]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:40.909]                             "", base::R.version$version.string), 
[17:42:40.909]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:40.909]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:40.909]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:40.909]                               "release", "version")], collapse = " "), 
[17:42:40.909]                             hostname = base::Sys.info()[["nodename"]])
[17:42:40.909]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:40.909]                             info)
[17:42:40.909]                           info <- base::paste(info, collapse = "; ")
[17:42:40.909]                           if (!has_future) {
[17:42:40.909]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:40.909]                               info)
[17:42:40.909]                           }
[17:42:40.909]                           else {
[17:42:40.909]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:40.909]                               info, version)
[17:42:40.909]                           }
[17:42:40.909]                           base::stop(msg)
[17:42:40.909]                         }
[17:42:40.909]                       })
[17:42:40.909]                     }
[17:42:40.909]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:40.909]                     base::options(mc.cores = 1L)
[17:42:40.909]                   }
[17:42:40.909]                   options(future.plan = NULL)
[17:42:40.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:40.909]                 }
[17:42:40.909]                 ...future.workdir <- getwd()
[17:42:40.909]             }
[17:42:40.909]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:40.909]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:40.909]         }
[17:42:40.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:40.909]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:40.909]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:40.909]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:40.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:40.909]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:40.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:40.909]             base::names(...future.oldOptions))
[17:42:40.909]     }
[17:42:40.909]     if (FALSE) {
[17:42:40.909]     }
[17:42:40.909]     else {
[17:42:40.909]         if (TRUE) {
[17:42:40.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:40.909]                 open = "w")
[17:42:40.909]         }
[17:42:40.909]         else {
[17:42:40.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:40.909]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:40.909]         }
[17:42:40.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:40.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:40.909]             base::sink(type = "output", split = FALSE)
[17:42:40.909]             base::close(...future.stdout)
[17:42:40.909]         }, add = TRUE)
[17:42:40.909]     }
[17:42:40.909]     ...future.frame <- base::sys.nframe()
[17:42:40.909]     ...future.conditions <- base::list()
[17:42:40.909]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:40.909]     if (FALSE) {
[17:42:40.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:40.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:40.909]     }
[17:42:40.909]     ...future.result <- base::tryCatch({
[17:42:40.909]         base::withCallingHandlers({
[17:42:40.909]             ...future.value <- base::withVisible(base::local({
[17:42:40.909]                 ...future.makeSendCondition <- local({
[17:42:40.909]                   sendCondition <- NULL
[17:42:40.909]                   function(frame = 1L) {
[17:42:40.909]                     if (is.function(sendCondition)) 
[17:42:40.909]                       return(sendCondition)
[17:42:40.909]                     ns <- getNamespace("parallel")
[17:42:40.909]                     if (exists("sendData", mode = "function", 
[17:42:40.909]                       envir = ns)) {
[17:42:40.909]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:40.909]                         envir = ns)
[17:42:40.909]                       envir <- sys.frame(frame)
[17:42:40.909]                       master <- NULL
[17:42:40.909]                       while (!identical(envir, .GlobalEnv) && 
[17:42:40.909]                         !identical(envir, emptyenv())) {
[17:42:40.909]                         if (exists("master", mode = "list", envir = envir, 
[17:42:40.909]                           inherits = FALSE)) {
[17:42:40.909]                           master <- get("master", mode = "list", 
[17:42:40.909]                             envir = envir, inherits = FALSE)
[17:42:40.909]                           if (inherits(master, c("SOCKnode", 
[17:42:40.909]                             "SOCK0node"))) {
[17:42:40.909]                             sendCondition <<- function(cond) {
[17:42:40.909]                               data <- list(type = "VALUE", value = cond, 
[17:42:40.909]                                 success = TRUE)
[17:42:40.909]                               parallel_sendData(master, data)
[17:42:40.909]                             }
[17:42:40.909]                             return(sendCondition)
[17:42:40.909]                           }
[17:42:40.909]                         }
[17:42:40.909]                         frame <- frame + 1L
[17:42:40.909]                         envir <- sys.frame(frame)
[17:42:40.909]                       }
[17:42:40.909]                     }
[17:42:40.909]                     sendCondition <<- function(cond) NULL
[17:42:40.909]                   }
[17:42:40.909]                 })
[17:42:40.909]                 withCallingHandlers({
[17:42:40.909]                   {
[17:42:40.909]                     x[["a"]] <- 1
[17:42:40.909]                     x
[17:42:40.909]                   }
[17:42:40.909]                 }, immediateCondition = function(cond) {
[17:42:40.909]                   sendCondition <- ...future.makeSendCondition()
[17:42:40.909]                   sendCondition(cond)
[17:42:40.909]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.909]                   {
[17:42:40.909]                     inherits <- base::inherits
[17:42:40.909]                     invokeRestart <- base::invokeRestart
[17:42:40.909]                     is.null <- base::is.null
[17:42:40.909]                     muffled <- FALSE
[17:42:40.909]                     if (inherits(cond, "message")) {
[17:42:40.909]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:40.909]                       if (muffled) 
[17:42:40.909]                         invokeRestart("muffleMessage")
[17:42:40.909]                     }
[17:42:40.909]                     else if (inherits(cond, "warning")) {
[17:42:40.909]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:40.909]                       if (muffled) 
[17:42:40.909]                         invokeRestart("muffleWarning")
[17:42:40.909]                     }
[17:42:40.909]                     else if (inherits(cond, "condition")) {
[17:42:40.909]                       if (!is.null(pattern)) {
[17:42:40.909]                         computeRestarts <- base::computeRestarts
[17:42:40.909]                         grepl <- base::grepl
[17:42:40.909]                         restarts <- computeRestarts(cond)
[17:42:40.909]                         for (restart in restarts) {
[17:42:40.909]                           name <- restart$name
[17:42:40.909]                           if (is.null(name)) 
[17:42:40.909]                             next
[17:42:40.909]                           if (!grepl(pattern, name)) 
[17:42:40.909]                             next
[17:42:40.909]                           invokeRestart(restart)
[17:42:40.909]                           muffled <- TRUE
[17:42:40.909]                           break
[17:42:40.909]                         }
[17:42:40.909]                       }
[17:42:40.909]                     }
[17:42:40.909]                     invisible(muffled)
[17:42:40.909]                   }
[17:42:40.909]                   muffleCondition(cond)
[17:42:40.909]                 })
[17:42:40.909]             }))
[17:42:40.909]             future::FutureResult(value = ...future.value$value, 
[17:42:40.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.909]                   ...future.rng), globalenv = if (FALSE) 
[17:42:40.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:40.909]                     ...future.globalenv.names))
[17:42:40.909]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:40.909]         }, condition = base::local({
[17:42:40.909]             c <- base::c
[17:42:40.909]             inherits <- base::inherits
[17:42:40.909]             invokeRestart <- base::invokeRestart
[17:42:40.909]             length <- base::length
[17:42:40.909]             list <- base::list
[17:42:40.909]             seq.int <- base::seq.int
[17:42:40.909]             signalCondition <- base::signalCondition
[17:42:40.909]             sys.calls <- base::sys.calls
[17:42:40.909]             `[[` <- base::`[[`
[17:42:40.909]             `+` <- base::`+`
[17:42:40.909]             `<<-` <- base::`<<-`
[17:42:40.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:40.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:40.909]                   3L)]
[17:42:40.909]             }
[17:42:40.909]             function(cond) {
[17:42:40.909]                 is_error <- inherits(cond, "error")
[17:42:40.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:40.909]                   NULL)
[17:42:40.909]                 if (is_error) {
[17:42:40.909]                   sessionInformation <- function() {
[17:42:40.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:40.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:40.909]                       search = base::search(), system = base::Sys.info())
[17:42:40.909]                   }
[17:42:40.909]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:40.909]                     cond$call), session = sessionInformation(), 
[17:42:40.909]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:40.909]                   signalCondition(cond)
[17:42:40.909]                 }
[17:42:40.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:40.909]                 "immediateCondition"))) {
[17:42:40.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:40.909]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:40.909]                   if (TRUE && !signal) {
[17:42:40.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.909]                     {
[17:42:40.909]                       inherits <- base::inherits
[17:42:40.909]                       invokeRestart <- base::invokeRestart
[17:42:40.909]                       is.null <- base::is.null
[17:42:40.909]                       muffled <- FALSE
[17:42:40.909]                       if (inherits(cond, "message")) {
[17:42:40.909]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.909]                         if (muffled) 
[17:42:40.909]                           invokeRestart("muffleMessage")
[17:42:40.909]                       }
[17:42:40.909]                       else if (inherits(cond, "warning")) {
[17:42:40.909]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.909]                         if (muffled) 
[17:42:40.909]                           invokeRestart("muffleWarning")
[17:42:40.909]                       }
[17:42:40.909]                       else if (inherits(cond, "condition")) {
[17:42:40.909]                         if (!is.null(pattern)) {
[17:42:40.909]                           computeRestarts <- base::computeRestarts
[17:42:40.909]                           grepl <- base::grepl
[17:42:40.909]                           restarts <- computeRestarts(cond)
[17:42:40.909]                           for (restart in restarts) {
[17:42:40.909]                             name <- restart$name
[17:42:40.909]                             if (is.null(name)) 
[17:42:40.909]                               next
[17:42:40.909]                             if (!grepl(pattern, name)) 
[17:42:40.909]                               next
[17:42:40.909]                             invokeRestart(restart)
[17:42:40.909]                             muffled <- TRUE
[17:42:40.909]                             break
[17:42:40.909]                           }
[17:42:40.909]                         }
[17:42:40.909]                       }
[17:42:40.909]                       invisible(muffled)
[17:42:40.909]                     }
[17:42:40.909]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.909]                   }
[17:42:40.909]                 }
[17:42:40.909]                 else {
[17:42:40.909]                   if (TRUE) {
[17:42:40.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.909]                     {
[17:42:40.909]                       inherits <- base::inherits
[17:42:40.909]                       invokeRestart <- base::invokeRestart
[17:42:40.909]                       is.null <- base::is.null
[17:42:40.909]                       muffled <- FALSE
[17:42:40.909]                       if (inherits(cond, "message")) {
[17:42:40.909]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.909]                         if (muffled) 
[17:42:40.909]                           invokeRestart("muffleMessage")
[17:42:40.909]                       }
[17:42:40.909]                       else if (inherits(cond, "warning")) {
[17:42:40.909]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.909]                         if (muffled) 
[17:42:40.909]                           invokeRestart("muffleWarning")
[17:42:40.909]                       }
[17:42:40.909]                       else if (inherits(cond, "condition")) {
[17:42:40.909]                         if (!is.null(pattern)) {
[17:42:40.909]                           computeRestarts <- base::computeRestarts
[17:42:40.909]                           grepl <- base::grepl
[17:42:40.909]                           restarts <- computeRestarts(cond)
[17:42:40.909]                           for (restart in restarts) {
[17:42:40.909]                             name <- restart$name
[17:42:40.909]                             if (is.null(name)) 
[17:42:40.909]                               next
[17:42:40.909]                             if (!grepl(pattern, name)) 
[17:42:40.909]                               next
[17:42:40.909]                             invokeRestart(restart)
[17:42:40.909]                             muffled <- TRUE
[17:42:40.909]                             break
[17:42:40.909]                           }
[17:42:40.909]                         }
[17:42:40.909]                       }
[17:42:40.909]                       invisible(muffled)
[17:42:40.909]                     }
[17:42:40.909]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.909]                   }
[17:42:40.909]                 }
[17:42:40.909]             }
[17:42:40.909]         }))
[17:42:40.909]     }, error = function(ex) {
[17:42:40.909]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:40.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.909]                 ...future.rng), started = ...future.startTime, 
[17:42:40.909]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:40.909]             version = "1.8"), class = "FutureResult")
[17:42:40.909]     }, finally = {
[17:42:40.909]         if (!identical(...future.workdir, getwd())) 
[17:42:40.909]             setwd(...future.workdir)
[17:42:40.909]         {
[17:42:40.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:40.909]                 ...future.oldOptions$nwarnings <- NULL
[17:42:40.909]             }
[17:42:40.909]             base::options(...future.oldOptions)
[17:42:40.909]             if (.Platform$OS.type == "windows") {
[17:42:40.909]                 old_names <- names(...future.oldEnvVars)
[17:42:40.909]                 envs <- base::Sys.getenv()
[17:42:40.909]                 names <- names(envs)
[17:42:40.909]                 common <- intersect(names, old_names)
[17:42:40.909]                 added <- setdiff(names, old_names)
[17:42:40.909]                 removed <- setdiff(old_names, names)
[17:42:40.909]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:40.909]                   envs[common]]
[17:42:40.909]                 NAMES <- toupper(changed)
[17:42:40.909]                 args <- list()
[17:42:40.909]                 for (kk in seq_along(NAMES)) {
[17:42:40.909]                   name <- changed[[kk]]
[17:42:40.909]                   NAME <- NAMES[[kk]]
[17:42:40.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.909]                     next
[17:42:40.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.909]                 }
[17:42:40.909]                 NAMES <- toupper(added)
[17:42:40.909]                 for (kk in seq_along(NAMES)) {
[17:42:40.909]                   name <- added[[kk]]
[17:42:40.909]                   NAME <- NAMES[[kk]]
[17:42:40.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.909]                     next
[17:42:40.909]                   args[[name]] <- ""
[17:42:40.909]                 }
[17:42:40.909]                 NAMES <- toupper(removed)
[17:42:40.909]                 for (kk in seq_along(NAMES)) {
[17:42:40.909]                   name <- removed[[kk]]
[17:42:40.909]                   NAME <- NAMES[[kk]]
[17:42:40.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.909]                     next
[17:42:40.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.909]                 }
[17:42:40.909]                 if (length(args) > 0) 
[17:42:40.909]                   base::do.call(base::Sys.setenv, args = args)
[17:42:40.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:40.909]             }
[17:42:40.909]             else {
[17:42:40.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:40.909]             }
[17:42:40.909]             {
[17:42:40.909]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:40.909]                   0L) {
[17:42:40.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:40.909]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:40.909]                   base::options(opts)
[17:42:40.909]                 }
[17:42:40.909]                 {
[17:42:40.909]                   {
[17:42:40.909]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:40.909]                     NULL
[17:42:40.909]                   }
[17:42:40.909]                   options(future.plan = NULL)
[17:42:40.909]                   if (is.na(NA_character_)) 
[17:42:40.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:40.909]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:40.909]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:40.909]                     envir = parent.frame()) 
[17:42:40.909]                   {
[17:42:40.909]                     if (is.function(workers)) 
[17:42:40.909]                       workers <- workers()
[17:42:40.909]                     workers <- structure(as.integer(workers), 
[17:42:40.909]                       class = class(workers))
[17:42:40.909]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:40.909]                       workers >= 1)
[17:42:40.909]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:40.909]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:40.909]                     }
[17:42:40.909]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:40.909]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:40.909]                       envir = envir)
[17:42:40.909]                     if (!future$lazy) 
[17:42:40.909]                       future <- run(future)
[17:42:40.909]                     invisible(future)
[17:42:40.909]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:40.909]                 }
[17:42:40.909]             }
[17:42:40.909]         }
[17:42:40.909]     })
[17:42:40.909]     if (TRUE) {
[17:42:40.909]         base::sink(type = "output", split = FALSE)
[17:42:40.909]         if (TRUE) {
[17:42:40.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:40.909]         }
[17:42:40.909]         else {
[17:42:40.909]             ...future.result["stdout"] <- base::list(NULL)
[17:42:40.909]         }
[17:42:40.909]         base::close(...future.stdout)
[17:42:40.909]         ...future.stdout <- NULL
[17:42:40.909]     }
[17:42:40.909]     ...future.result$conditions <- ...future.conditions
[17:42:40.909]     ...future.result$finished <- base::Sys.time()
[17:42:40.909]     ...future.result
[17:42:40.909] }
[17:42:40.912] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:42:40.912] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:42:40.912] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:42:40.912] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:42:40.913] MultisessionFuture started
[17:42:40.913] - Launch lazy future ... done
[17:42:40.913] run() for ‘MultisessionFuture’ ... done
[17:42:40.913] result() for ClusterFuture ...
[17:42:40.913] receiveMessageFromWorker() for ClusterFuture ...
[17:42:40.914] - Validating connection of MultisessionFuture
[17:42:40.960] - received message: FutureResult
[17:42:40.960] - Received FutureResult
[17:42:40.960] - Erased future from FutureRegistry
[17:42:40.960] result() for ClusterFuture ...
[17:42:40.960] - result already collected: FutureResult
[17:42:40.961] result() for ClusterFuture ... done
[17:42:40.961] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:40.961] result() for ClusterFuture ... done
[17:42:40.961] result() for ClusterFuture ...
[17:42:40.961] - result already collected: FutureResult
[17:42:40.961] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:40.962] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:40.962] Searching for globals...
[17:42:40.964] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:40.964] Searching for globals ... DONE
[17:42:40.965] Resolving globals: TRUE
[17:42:40.965] Resolving any globals that are futures ...
[17:42:40.965] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:42:40.965] Resolving any globals that are futures ... DONE
[17:42:40.965] Resolving futures part of globals (recursively) ...
[17:42:40.966] resolve() on list ...
[17:42:40.966]  recursive: 99
[17:42:40.968]  length: 1
[17:42:40.968]  elements: ‘x’
[17:42:40.968]  length: 0 (resolved future 1)
[17:42:40.968] resolve() on list ... DONE
[17:42:40.968] - globals: [1] ‘x’
[17:42:40.968] Resolving futures part of globals (recursively) ... DONE
[17:42:40.969] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:40.969] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:40.969] - globals: [1] ‘x’
[17:42:40.969] 
[17:42:40.969] getGlobalsAndPackages() ... DONE
[17:42:40.970] run() for ‘Future’ ...
[17:42:40.970] - state: ‘created’
[17:42:40.970] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:40.984] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:40.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:40.985]   - Field: ‘node’
[17:42:40.985]   - Field: ‘label’
[17:42:40.985]   - Field: ‘local’
[17:42:40.985]   - Field: ‘owner’
[17:42:40.985]   - Field: ‘envir’
[17:42:40.985]   - Field: ‘workers’
[17:42:40.985]   - Field: ‘packages’
[17:42:40.985]   - Field: ‘gc’
[17:42:40.985]   - Field: ‘conditions’
[17:42:40.986]   - Field: ‘persistent’
[17:42:40.986]   - Field: ‘expr’
[17:42:40.986]   - Field: ‘uuid’
[17:42:40.986]   - Field: ‘seed’
[17:42:40.986]   - Field: ‘version’
[17:42:40.986]   - Field: ‘result’
[17:42:40.986]   - Field: ‘asynchronous’
[17:42:40.986]   - Field: ‘calls’
[17:42:40.986]   - Field: ‘globals’
[17:42:40.986]   - Field: ‘stdout’
[17:42:40.986]   - Field: ‘earlySignal’
[17:42:40.987]   - Field: ‘lazy’
[17:42:40.987]   - Field: ‘state’
[17:42:40.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:40.987] - Launch lazy future ...
[17:42:40.987] Packages needed by the future expression (n = 0): <none>
[17:42:40.987] Packages needed by future strategies (n = 0): <none>
[17:42:40.988] {
[17:42:40.988]     {
[17:42:40.988]         {
[17:42:40.988]             ...future.startTime <- base::Sys.time()
[17:42:40.988]             {
[17:42:40.988]                 {
[17:42:40.988]                   {
[17:42:40.988]                     {
[17:42:40.988]                       base::local({
[17:42:40.988]                         has_future <- base::requireNamespace("future", 
[17:42:40.988]                           quietly = TRUE)
[17:42:40.988]                         if (has_future) {
[17:42:40.988]                           ns <- base::getNamespace("future")
[17:42:40.988]                           version <- ns[[".package"]][["version"]]
[17:42:40.988]                           if (is.null(version)) 
[17:42:40.988]                             version <- utils::packageVersion("future")
[17:42:40.988]                         }
[17:42:40.988]                         else {
[17:42:40.988]                           version <- NULL
[17:42:40.988]                         }
[17:42:40.988]                         if (!has_future || version < "1.8.0") {
[17:42:40.988]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:40.988]                             "", base::R.version$version.string), 
[17:42:40.988]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:40.988]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:40.988]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:40.988]                               "release", "version")], collapse = " "), 
[17:42:40.988]                             hostname = base::Sys.info()[["nodename"]])
[17:42:40.988]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:40.988]                             info)
[17:42:40.988]                           info <- base::paste(info, collapse = "; ")
[17:42:40.988]                           if (!has_future) {
[17:42:40.988]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:40.988]                               info)
[17:42:40.988]                           }
[17:42:40.988]                           else {
[17:42:40.988]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:40.988]                               info, version)
[17:42:40.988]                           }
[17:42:40.988]                           base::stop(msg)
[17:42:40.988]                         }
[17:42:40.988]                       })
[17:42:40.988]                     }
[17:42:40.988]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:40.988]                     base::options(mc.cores = 1L)
[17:42:40.988]                   }
[17:42:40.988]                   options(future.plan = NULL)
[17:42:40.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:40.988]                 }
[17:42:40.988]                 ...future.workdir <- getwd()
[17:42:40.988]             }
[17:42:40.988]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:40.988]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:40.988]         }
[17:42:40.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:40.988]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:40.988]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:40.988]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:40.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:40.988]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:40.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:40.988]             base::names(...future.oldOptions))
[17:42:40.988]     }
[17:42:40.988]     if (FALSE) {
[17:42:40.988]     }
[17:42:40.988]     else {
[17:42:40.988]         if (TRUE) {
[17:42:40.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:40.988]                 open = "w")
[17:42:40.988]         }
[17:42:40.988]         else {
[17:42:40.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:40.988]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:40.988]         }
[17:42:40.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:40.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:40.988]             base::sink(type = "output", split = FALSE)
[17:42:40.988]             base::close(...future.stdout)
[17:42:40.988]         }, add = TRUE)
[17:42:40.988]     }
[17:42:40.988]     ...future.frame <- base::sys.nframe()
[17:42:40.988]     ...future.conditions <- base::list()
[17:42:40.988]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:40.988]     if (FALSE) {
[17:42:40.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:40.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:40.988]     }
[17:42:40.988]     ...future.result <- base::tryCatch({
[17:42:40.988]         base::withCallingHandlers({
[17:42:40.988]             ...future.value <- base::withVisible(base::local({
[17:42:40.988]                 ...future.makeSendCondition <- local({
[17:42:40.988]                   sendCondition <- NULL
[17:42:40.988]                   function(frame = 1L) {
[17:42:40.988]                     if (is.function(sendCondition)) 
[17:42:40.988]                       return(sendCondition)
[17:42:40.988]                     ns <- getNamespace("parallel")
[17:42:40.988]                     if (exists("sendData", mode = "function", 
[17:42:40.988]                       envir = ns)) {
[17:42:40.988]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:40.988]                         envir = ns)
[17:42:40.988]                       envir <- sys.frame(frame)
[17:42:40.988]                       master <- NULL
[17:42:40.988]                       while (!identical(envir, .GlobalEnv) && 
[17:42:40.988]                         !identical(envir, emptyenv())) {
[17:42:40.988]                         if (exists("master", mode = "list", envir = envir, 
[17:42:40.988]                           inherits = FALSE)) {
[17:42:40.988]                           master <- get("master", mode = "list", 
[17:42:40.988]                             envir = envir, inherits = FALSE)
[17:42:40.988]                           if (inherits(master, c("SOCKnode", 
[17:42:40.988]                             "SOCK0node"))) {
[17:42:40.988]                             sendCondition <<- function(cond) {
[17:42:40.988]                               data <- list(type = "VALUE", value = cond, 
[17:42:40.988]                                 success = TRUE)
[17:42:40.988]                               parallel_sendData(master, data)
[17:42:40.988]                             }
[17:42:40.988]                             return(sendCondition)
[17:42:40.988]                           }
[17:42:40.988]                         }
[17:42:40.988]                         frame <- frame + 1L
[17:42:40.988]                         envir <- sys.frame(frame)
[17:42:40.988]                       }
[17:42:40.988]                     }
[17:42:40.988]                     sendCondition <<- function(cond) NULL
[17:42:40.988]                   }
[17:42:40.988]                 })
[17:42:40.988]                 withCallingHandlers({
[17:42:40.988]                   {
[17:42:40.988]                     x[["a"]] <- 1
[17:42:40.988]                     x
[17:42:40.988]                   }
[17:42:40.988]                 }, immediateCondition = function(cond) {
[17:42:40.988]                   sendCondition <- ...future.makeSendCondition()
[17:42:40.988]                   sendCondition(cond)
[17:42:40.988]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.988]                   {
[17:42:40.988]                     inherits <- base::inherits
[17:42:40.988]                     invokeRestart <- base::invokeRestart
[17:42:40.988]                     is.null <- base::is.null
[17:42:40.988]                     muffled <- FALSE
[17:42:40.988]                     if (inherits(cond, "message")) {
[17:42:40.988]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:40.988]                       if (muffled) 
[17:42:40.988]                         invokeRestart("muffleMessage")
[17:42:40.988]                     }
[17:42:40.988]                     else if (inherits(cond, "warning")) {
[17:42:40.988]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:40.988]                       if (muffled) 
[17:42:40.988]                         invokeRestart("muffleWarning")
[17:42:40.988]                     }
[17:42:40.988]                     else if (inherits(cond, "condition")) {
[17:42:40.988]                       if (!is.null(pattern)) {
[17:42:40.988]                         computeRestarts <- base::computeRestarts
[17:42:40.988]                         grepl <- base::grepl
[17:42:40.988]                         restarts <- computeRestarts(cond)
[17:42:40.988]                         for (restart in restarts) {
[17:42:40.988]                           name <- restart$name
[17:42:40.988]                           if (is.null(name)) 
[17:42:40.988]                             next
[17:42:40.988]                           if (!grepl(pattern, name)) 
[17:42:40.988]                             next
[17:42:40.988]                           invokeRestart(restart)
[17:42:40.988]                           muffled <- TRUE
[17:42:40.988]                           break
[17:42:40.988]                         }
[17:42:40.988]                       }
[17:42:40.988]                     }
[17:42:40.988]                     invisible(muffled)
[17:42:40.988]                   }
[17:42:40.988]                   muffleCondition(cond)
[17:42:40.988]                 })
[17:42:40.988]             }))
[17:42:40.988]             future::FutureResult(value = ...future.value$value, 
[17:42:40.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.988]                   ...future.rng), globalenv = if (FALSE) 
[17:42:40.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:40.988]                     ...future.globalenv.names))
[17:42:40.988]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:40.988]         }, condition = base::local({
[17:42:40.988]             c <- base::c
[17:42:40.988]             inherits <- base::inherits
[17:42:40.988]             invokeRestart <- base::invokeRestart
[17:42:40.988]             length <- base::length
[17:42:40.988]             list <- base::list
[17:42:40.988]             seq.int <- base::seq.int
[17:42:40.988]             signalCondition <- base::signalCondition
[17:42:40.988]             sys.calls <- base::sys.calls
[17:42:40.988]             `[[` <- base::`[[`
[17:42:40.988]             `+` <- base::`+`
[17:42:40.988]             `<<-` <- base::`<<-`
[17:42:40.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:40.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:40.988]                   3L)]
[17:42:40.988]             }
[17:42:40.988]             function(cond) {
[17:42:40.988]                 is_error <- inherits(cond, "error")
[17:42:40.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:40.988]                   NULL)
[17:42:40.988]                 if (is_error) {
[17:42:40.988]                   sessionInformation <- function() {
[17:42:40.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:40.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:40.988]                       search = base::search(), system = base::Sys.info())
[17:42:40.988]                   }
[17:42:40.988]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:40.988]                     cond$call), session = sessionInformation(), 
[17:42:40.988]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:40.988]                   signalCondition(cond)
[17:42:40.988]                 }
[17:42:40.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:40.988]                 "immediateCondition"))) {
[17:42:40.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:40.988]                   ...future.conditions[[length(...future.conditions) + 
[17:42:40.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:40.988]                   if (TRUE && !signal) {
[17:42:40.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.988]                     {
[17:42:40.988]                       inherits <- base::inherits
[17:42:40.988]                       invokeRestart <- base::invokeRestart
[17:42:40.988]                       is.null <- base::is.null
[17:42:40.988]                       muffled <- FALSE
[17:42:40.988]                       if (inherits(cond, "message")) {
[17:42:40.988]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.988]                         if (muffled) 
[17:42:40.988]                           invokeRestart("muffleMessage")
[17:42:40.988]                       }
[17:42:40.988]                       else if (inherits(cond, "warning")) {
[17:42:40.988]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.988]                         if (muffled) 
[17:42:40.988]                           invokeRestart("muffleWarning")
[17:42:40.988]                       }
[17:42:40.988]                       else if (inherits(cond, "condition")) {
[17:42:40.988]                         if (!is.null(pattern)) {
[17:42:40.988]                           computeRestarts <- base::computeRestarts
[17:42:40.988]                           grepl <- base::grepl
[17:42:40.988]                           restarts <- computeRestarts(cond)
[17:42:40.988]                           for (restart in restarts) {
[17:42:40.988]                             name <- restart$name
[17:42:40.988]                             if (is.null(name)) 
[17:42:40.988]                               next
[17:42:40.988]                             if (!grepl(pattern, name)) 
[17:42:40.988]                               next
[17:42:40.988]                             invokeRestart(restart)
[17:42:40.988]                             muffled <- TRUE
[17:42:40.988]                             break
[17:42:40.988]                           }
[17:42:40.988]                         }
[17:42:40.988]                       }
[17:42:40.988]                       invisible(muffled)
[17:42:40.988]                     }
[17:42:40.988]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.988]                   }
[17:42:40.988]                 }
[17:42:40.988]                 else {
[17:42:40.988]                   if (TRUE) {
[17:42:40.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:40.988]                     {
[17:42:40.988]                       inherits <- base::inherits
[17:42:40.988]                       invokeRestart <- base::invokeRestart
[17:42:40.988]                       is.null <- base::is.null
[17:42:40.988]                       muffled <- FALSE
[17:42:40.988]                       if (inherits(cond, "message")) {
[17:42:40.988]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:40.988]                         if (muffled) 
[17:42:40.988]                           invokeRestart("muffleMessage")
[17:42:40.988]                       }
[17:42:40.988]                       else if (inherits(cond, "warning")) {
[17:42:40.988]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:40.988]                         if (muffled) 
[17:42:40.988]                           invokeRestart("muffleWarning")
[17:42:40.988]                       }
[17:42:40.988]                       else if (inherits(cond, "condition")) {
[17:42:40.988]                         if (!is.null(pattern)) {
[17:42:40.988]                           computeRestarts <- base::computeRestarts
[17:42:40.988]                           grepl <- base::grepl
[17:42:40.988]                           restarts <- computeRestarts(cond)
[17:42:40.988]                           for (restart in restarts) {
[17:42:40.988]                             name <- restart$name
[17:42:40.988]                             if (is.null(name)) 
[17:42:40.988]                               next
[17:42:40.988]                             if (!grepl(pattern, name)) 
[17:42:40.988]                               next
[17:42:40.988]                             invokeRestart(restart)
[17:42:40.988]                             muffled <- TRUE
[17:42:40.988]                             break
[17:42:40.988]                           }
[17:42:40.988]                         }
[17:42:40.988]                       }
[17:42:40.988]                       invisible(muffled)
[17:42:40.988]                     }
[17:42:40.988]                     muffleCondition(cond, pattern = "^muffle")
[17:42:40.988]                   }
[17:42:40.988]                 }
[17:42:40.988]             }
[17:42:40.988]         }))
[17:42:40.988]     }, error = function(ex) {
[17:42:40.988]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:40.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:40.988]                 ...future.rng), started = ...future.startTime, 
[17:42:40.988]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:40.988]             version = "1.8"), class = "FutureResult")
[17:42:40.988]     }, finally = {
[17:42:40.988]         if (!identical(...future.workdir, getwd())) 
[17:42:40.988]             setwd(...future.workdir)
[17:42:40.988]         {
[17:42:40.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:40.988]                 ...future.oldOptions$nwarnings <- NULL
[17:42:40.988]             }
[17:42:40.988]             base::options(...future.oldOptions)
[17:42:40.988]             if (.Platform$OS.type == "windows") {
[17:42:40.988]                 old_names <- names(...future.oldEnvVars)
[17:42:40.988]                 envs <- base::Sys.getenv()
[17:42:40.988]                 names <- names(envs)
[17:42:40.988]                 common <- intersect(names, old_names)
[17:42:40.988]                 added <- setdiff(names, old_names)
[17:42:40.988]                 removed <- setdiff(old_names, names)
[17:42:40.988]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:40.988]                   envs[common]]
[17:42:40.988]                 NAMES <- toupper(changed)
[17:42:40.988]                 args <- list()
[17:42:40.988]                 for (kk in seq_along(NAMES)) {
[17:42:40.988]                   name <- changed[[kk]]
[17:42:40.988]                   NAME <- NAMES[[kk]]
[17:42:40.988]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.988]                     next
[17:42:40.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.988]                 }
[17:42:40.988]                 NAMES <- toupper(added)
[17:42:40.988]                 for (kk in seq_along(NAMES)) {
[17:42:40.988]                   name <- added[[kk]]
[17:42:40.988]                   NAME <- NAMES[[kk]]
[17:42:40.988]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.988]                     next
[17:42:40.988]                   args[[name]] <- ""
[17:42:40.988]                 }
[17:42:40.988]                 NAMES <- toupper(removed)
[17:42:40.988]                 for (kk in seq_along(NAMES)) {
[17:42:40.988]                   name <- removed[[kk]]
[17:42:40.988]                   NAME <- NAMES[[kk]]
[17:42:40.988]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:40.988]                     next
[17:42:40.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:40.988]                 }
[17:42:40.988]                 if (length(args) > 0) 
[17:42:40.988]                   base::do.call(base::Sys.setenv, args = args)
[17:42:40.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:40.988]             }
[17:42:40.988]             else {
[17:42:40.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:40.988]             }
[17:42:40.988]             {
[17:42:40.988]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:40.988]                   0L) {
[17:42:40.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:40.988]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:40.988]                   base::options(opts)
[17:42:40.988]                 }
[17:42:40.988]                 {
[17:42:40.988]                   {
[17:42:40.988]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:40.988]                     NULL
[17:42:40.988]                   }
[17:42:40.988]                   options(future.plan = NULL)
[17:42:40.988]                   if (is.na(NA_character_)) 
[17:42:40.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:40.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:40.988]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:40.988]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:40.988]                     envir = parent.frame()) 
[17:42:40.988]                   {
[17:42:40.988]                     if (is.function(workers)) 
[17:42:40.988]                       workers <- workers()
[17:42:40.988]                     workers <- structure(as.integer(workers), 
[17:42:40.988]                       class = class(workers))
[17:42:40.988]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:40.988]                       workers >= 1)
[17:42:40.988]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:40.988]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:40.988]                     }
[17:42:40.988]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:40.988]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:40.988]                       envir = envir)
[17:42:40.988]                     if (!future$lazy) 
[17:42:40.988]                       future <- run(future)
[17:42:40.988]                     invisible(future)
[17:42:40.988]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:40.988]                 }
[17:42:40.988]             }
[17:42:40.988]         }
[17:42:40.988]     })
[17:42:40.988]     if (TRUE) {
[17:42:40.988]         base::sink(type = "output", split = FALSE)
[17:42:40.988]         if (TRUE) {
[17:42:40.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:40.988]         }
[17:42:40.988]         else {
[17:42:40.988]             ...future.result["stdout"] <- base::list(NULL)
[17:42:40.988]         }
[17:42:40.988]         base::close(...future.stdout)
[17:42:40.988]         ...future.stdout <- NULL
[17:42:40.988]     }
[17:42:40.988]     ...future.result$conditions <- ...future.conditions
[17:42:40.988]     ...future.result$finished <- base::Sys.time()
[17:42:40.988]     ...future.result
[17:42:40.988] }
[17:42:40.990] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:42:40.990] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:42:40.991] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:42:40.991] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:42:40.992] MultisessionFuture started
[17:42:40.992] - Launch lazy future ... done
[17:42:40.992] run() for ‘MultisessionFuture’ ... done
[17:42:40.992] result() for ClusterFuture ...
[17:42:40.992] receiveMessageFromWorker() for ClusterFuture ...
[17:42:40.992] - Validating connection of MultisessionFuture
[17:42:41.040] - received message: FutureResult
[17:42:41.040] - Received FutureResult
[17:42:41.040] - Erased future from FutureRegistry
[17:42:41.041] result() for ClusterFuture ...
[17:42:41.041] - result already collected: FutureResult
[17:42:41.041] result() for ClusterFuture ... done
[17:42:41.041] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:41.041] result() for ClusterFuture ... done
[17:42:41.041] result() for ClusterFuture ...
[17:42:41.041] - result already collected: FutureResult
[17:42:41.041] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:41.042] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:41.042] Searching for globals...
[17:42:41.044] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:41.044] Searching for globals ... DONE
[17:42:41.044] Resolving globals: TRUE
[17:42:41.044] Resolving any globals that are futures ...
[17:42:41.044] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:41.044] Resolving any globals that are futures ... DONE
[17:42:41.045] Resolving futures part of globals (recursively) ...
[17:42:41.045] resolve() on list ...
[17:42:41.045]  recursive: 99
[17:42:41.045]  length: 1
[17:42:41.045]  elements: ‘x’
[17:42:41.045]  length: 0 (resolved future 1)
[17:42:41.046] resolve() on list ... DONE
[17:42:41.046] - globals: [1] ‘x’
[17:42:41.046] Resolving futures part of globals (recursively) ... DONE
[17:42:41.046] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:41.046] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:41.046] - globals: [1] ‘x’
[17:42:41.046] 
[17:42:41.047] getGlobalsAndPackages() ... DONE
[17:42:41.047] run() for ‘Future’ ...
[17:42:41.047] - state: ‘created’
[17:42:41.047] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:41.061] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:41.062] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:41.062]   - Field: ‘node’
[17:42:41.062]   - Field: ‘label’
[17:42:41.062]   - Field: ‘local’
[17:42:41.062]   - Field: ‘owner’
[17:42:41.062]   - Field: ‘envir’
[17:42:41.062]   - Field: ‘workers’
[17:42:41.062]   - Field: ‘packages’
[17:42:41.062]   - Field: ‘gc’
[17:42:41.063]   - Field: ‘conditions’
[17:42:41.063]   - Field: ‘persistent’
[17:42:41.063]   - Field: ‘expr’
[17:42:41.063]   - Field: ‘uuid’
[17:42:41.063]   - Field: ‘seed’
[17:42:41.063]   - Field: ‘version’
[17:42:41.063]   - Field: ‘result’
[17:42:41.063]   - Field: ‘asynchronous’
[17:42:41.063]   - Field: ‘calls’
[17:42:41.063]   - Field: ‘globals’
[17:42:41.064]   - Field: ‘stdout’
[17:42:41.064]   - Field: ‘earlySignal’
[17:42:41.064]   - Field: ‘lazy’
[17:42:41.064]   - Field: ‘state’
[17:42:41.064] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:41.064] - Launch lazy future ...
[17:42:41.064] Packages needed by the future expression (n = 0): <none>
[17:42:41.064] Packages needed by future strategies (n = 0): <none>
[17:42:41.065] {
[17:42:41.065]     {
[17:42:41.065]         {
[17:42:41.065]             ...future.startTime <- base::Sys.time()
[17:42:41.065]             {
[17:42:41.065]                 {
[17:42:41.065]                   {
[17:42:41.065]                     {
[17:42:41.065]                       base::local({
[17:42:41.065]                         has_future <- base::requireNamespace("future", 
[17:42:41.065]                           quietly = TRUE)
[17:42:41.065]                         if (has_future) {
[17:42:41.065]                           ns <- base::getNamespace("future")
[17:42:41.065]                           version <- ns[[".package"]][["version"]]
[17:42:41.065]                           if (is.null(version)) 
[17:42:41.065]                             version <- utils::packageVersion("future")
[17:42:41.065]                         }
[17:42:41.065]                         else {
[17:42:41.065]                           version <- NULL
[17:42:41.065]                         }
[17:42:41.065]                         if (!has_future || version < "1.8.0") {
[17:42:41.065]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:41.065]                             "", base::R.version$version.string), 
[17:42:41.065]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:41.065]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:41.065]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:41.065]                               "release", "version")], collapse = " "), 
[17:42:41.065]                             hostname = base::Sys.info()[["nodename"]])
[17:42:41.065]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:41.065]                             info)
[17:42:41.065]                           info <- base::paste(info, collapse = "; ")
[17:42:41.065]                           if (!has_future) {
[17:42:41.065]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:41.065]                               info)
[17:42:41.065]                           }
[17:42:41.065]                           else {
[17:42:41.065]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:41.065]                               info, version)
[17:42:41.065]                           }
[17:42:41.065]                           base::stop(msg)
[17:42:41.065]                         }
[17:42:41.065]                       })
[17:42:41.065]                     }
[17:42:41.065]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:41.065]                     base::options(mc.cores = 1L)
[17:42:41.065]                   }
[17:42:41.065]                   options(future.plan = NULL)
[17:42:41.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:41.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:41.065]                 }
[17:42:41.065]                 ...future.workdir <- getwd()
[17:42:41.065]             }
[17:42:41.065]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:41.065]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:41.065]         }
[17:42:41.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:41.065]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:41.065]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:41.065]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:41.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:41.065]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:41.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:41.065]             base::names(...future.oldOptions))
[17:42:41.065]     }
[17:42:41.065]     if (FALSE) {
[17:42:41.065]     }
[17:42:41.065]     else {
[17:42:41.065]         if (TRUE) {
[17:42:41.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:41.065]                 open = "w")
[17:42:41.065]         }
[17:42:41.065]         else {
[17:42:41.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:41.065]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:41.065]         }
[17:42:41.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:41.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:41.065]             base::sink(type = "output", split = FALSE)
[17:42:41.065]             base::close(...future.stdout)
[17:42:41.065]         }, add = TRUE)
[17:42:41.065]     }
[17:42:41.065]     ...future.frame <- base::sys.nframe()
[17:42:41.065]     ...future.conditions <- base::list()
[17:42:41.065]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:41.065]     if (FALSE) {
[17:42:41.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:41.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:41.065]     }
[17:42:41.065]     ...future.result <- base::tryCatch({
[17:42:41.065]         base::withCallingHandlers({
[17:42:41.065]             ...future.value <- base::withVisible(base::local({
[17:42:41.065]                 ...future.makeSendCondition <- local({
[17:42:41.065]                   sendCondition <- NULL
[17:42:41.065]                   function(frame = 1L) {
[17:42:41.065]                     if (is.function(sendCondition)) 
[17:42:41.065]                       return(sendCondition)
[17:42:41.065]                     ns <- getNamespace("parallel")
[17:42:41.065]                     if (exists("sendData", mode = "function", 
[17:42:41.065]                       envir = ns)) {
[17:42:41.065]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:41.065]                         envir = ns)
[17:42:41.065]                       envir <- sys.frame(frame)
[17:42:41.065]                       master <- NULL
[17:42:41.065]                       while (!identical(envir, .GlobalEnv) && 
[17:42:41.065]                         !identical(envir, emptyenv())) {
[17:42:41.065]                         if (exists("master", mode = "list", envir = envir, 
[17:42:41.065]                           inherits = FALSE)) {
[17:42:41.065]                           master <- get("master", mode = "list", 
[17:42:41.065]                             envir = envir, inherits = FALSE)
[17:42:41.065]                           if (inherits(master, c("SOCKnode", 
[17:42:41.065]                             "SOCK0node"))) {
[17:42:41.065]                             sendCondition <<- function(cond) {
[17:42:41.065]                               data <- list(type = "VALUE", value = cond, 
[17:42:41.065]                                 success = TRUE)
[17:42:41.065]                               parallel_sendData(master, data)
[17:42:41.065]                             }
[17:42:41.065]                             return(sendCondition)
[17:42:41.065]                           }
[17:42:41.065]                         }
[17:42:41.065]                         frame <- frame + 1L
[17:42:41.065]                         envir <- sys.frame(frame)
[17:42:41.065]                       }
[17:42:41.065]                     }
[17:42:41.065]                     sendCondition <<- function(cond) NULL
[17:42:41.065]                   }
[17:42:41.065]                 })
[17:42:41.065]                 withCallingHandlers({
[17:42:41.065]                   {
[17:42:41.065]                     x["a"] <- list(1)
[17:42:41.065]                     x
[17:42:41.065]                   }
[17:42:41.065]                 }, immediateCondition = function(cond) {
[17:42:41.065]                   sendCondition <- ...future.makeSendCondition()
[17:42:41.065]                   sendCondition(cond)
[17:42:41.065]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.065]                   {
[17:42:41.065]                     inherits <- base::inherits
[17:42:41.065]                     invokeRestart <- base::invokeRestart
[17:42:41.065]                     is.null <- base::is.null
[17:42:41.065]                     muffled <- FALSE
[17:42:41.065]                     if (inherits(cond, "message")) {
[17:42:41.065]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:41.065]                       if (muffled) 
[17:42:41.065]                         invokeRestart("muffleMessage")
[17:42:41.065]                     }
[17:42:41.065]                     else if (inherits(cond, "warning")) {
[17:42:41.065]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:41.065]                       if (muffled) 
[17:42:41.065]                         invokeRestart("muffleWarning")
[17:42:41.065]                     }
[17:42:41.065]                     else if (inherits(cond, "condition")) {
[17:42:41.065]                       if (!is.null(pattern)) {
[17:42:41.065]                         computeRestarts <- base::computeRestarts
[17:42:41.065]                         grepl <- base::grepl
[17:42:41.065]                         restarts <- computeRestarts(cond)
[17:42:41.065]                         for (restart in restarts) {
[17:42:41.065]                           name <- restart$name
[17:42:41.065]                           if (is.null(name)) 
[17:42:41.065]                             next
[17:42:41.065]                           if (!grepl(pattern, name)) 
[17:42:41.065]                             next
[17:42:41.065]                           invokeRestart(restart)
[17:42:41.065]                           muffled <- TRUE
[17:42:41.065]                           break
[17:42:41.065]                         }
[17:42:41.065]                       }
[17:42:41.065]                     }
[17:42:41.065]                     invisible(muffled)
[17:42:41.065]                   }
[17:42:41.065]                   muffleCondition(cond)
[17:42:41.065]                 })
[17:42:41.065]             }))
[17:42:41.065]             future::FutureResult(value = ...future.value$value, 
[17:42:41.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:41.065]                   ...future.rng), globalenv = if (FALSE) 
[17:42:41.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:41.065]                     ...future.globalenv.names))
[17:42:41.065]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:41.065]         }, condition = base::local({
[17:42:41.065]             c <- base::c
[17:42:41.065]             inherits <- base::inherits
[17:42:41.065]             invokeRestart <- base::invokeRestart
[17:42:41.065]             length <- base::length
[17:42:41.065]             list <- base::list
[17:42:41.065]             seq.int <- base::seq.int
[17:42:41.065]             signalCondition <- base::signalCondition
[17:42:41.065]             sys.calls <- base::sys.calls
[17:42:41.065]             `[[` <- base::`[[`
[17:42:41.065]             `+` <- base::`+`
[17:42:41.065]             `<<-` <- base::`<<-`
[17:42:41.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:41.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:41.065]                   3L)]
[17:42:41.065]             }
[17:42:41.065]             function(cond) {
[17:42:41.065]                 is_error <- inherits(cond, "error")
[17:42:41.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:41.065]                   NULL)
[17:42:41.065]                 if (is_error) {
[17:42:41.065]                   sessionInformation <- function() {
[17:42:41.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:41.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:41.065]                       search = base::search(), system = base::Sys.info())
[17:42:41.065]                   }
[17:42:41.065]                   ...future.conditions[[length(...future.conditions) + 
[17:42:41.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:41.065]                     cond$call), session = sessionInformation(), 
[17:42:41.065]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:41.065]                   signalCondition(cond)
[17:42:41.065]                 }
[17:42:41.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:41.065]                 "immediateCondition"))) {
[17:42:41.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:41.065]                   ...future.conditions[[length(...future.conditions) + 
[17:42:41.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:41.065]                   if (TRUE && !signal) {
[17:42:41.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.065]                     {
[17:42:41.065]                       inherits <- base::inherits
[17:42:41.065]                       invokeRestart <- base::invokeRestart
[17:42:41.065]                       is.null <- base::is.null
[17:42:41.065]                       muffled <- FALSE
[17:42:41.065]                       if (inherits(cond, "message")) {
[17:42:41.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:41.065]                         if (muffled) 
[17:42:41.065]                           invokeRestart("muffleMessage")
[17:42:41.065]                       }
[17:42:41.065]                       else if (inherits(cond, "warning")) {
[17:42:41.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:41.065]                         if (muffled) 
[17:42:41.065]                           invokeRestart("muffleWarning")
[17:42:41.065]                       }
[17:42:41.065]                       else if (inherits(cond, "condition")) {
[17:42:41.065]                         if (!is.null(pattern)) {
[17:42:41.065]                           computeRestarts <- base::computeRestarts
[17:42:41.065]                           grepl <- base::grepl
[17:42:41.065]                           restarts <- computeRestarts(cond)
[17:42:41.065]                           for (restart in restarts) {
[17:42:41.065]                             name <- restart$name
[17:42:41.065]                             if (is.null(name)) 
[17:42:41.065]                               next
[17:42:41.065]                             if (!grepl(pattern, name)) 
[17:42:41.065]                               next
[17:42:41.065]                             invokeRestart(restart)
[17:42:41.065]                             muffled <- TRUE
[17:42:41.065]                             break
[17:42:41.065]                           }
[17:42:41.065]                         }
[17:42:41.065]                       }
[17:42:41.065]                       invisible(muffled)
[17:42:41.065]                     }
[17:42:41.065]                     muffleCondition(cond, pattern = "^muffle")
[17:42:41.065]                   }
[17:42:41.065]                 }
[17:42:41.065]                 else {
[17:42:41.065]                   if (TRUE) {
[17:42:41.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.065]                     {
[17:42:41.065]                       inherits <- base::inherits
[17:42:41.065]                       invokeRestart <- base::invokeRestart
[17:42:41.065]                       is.null <- base::is.null
[17:42:41.065]                       muffled <- FALSE
[17:42:41.065]                       if (inherits(cond, "message")) {
[17:42:41.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:41.065]                         if (muffled) 
[17:42:41.065]                           invokeRestart("muffleMessage")
[17:42:41.065]                       }
[17:42:41.065]                       else if (inherits(cond, "warning")) {
[17:42:41.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:41.065]                         if (muffled) 
[17:42:41.065]                           invokeRestart("muffleWarning")
[17:42:41.065]                       }
[17:42:41.065]                       else if (inherits(cond, "condition")) {
[17:42:41.065]                         if (!is.null(pattern)) {
[17:42:41.065]                           computeRestarts <- base::computeRestarts
[17:42:41.065]                           grepl <- base::grepl
[17:42:41.065]                           restarts <- computeRestarts(cond)
[17:42:41.065]                           for (restart in restarts) {
[17:42:41.065]                             name <- restart$name
[17:42:41.065]                             if (is.null(name)) 
[17:42:41.065]                               next
[17:42:41.065]                             if (!grepl(pattern, name)) 
[17:42:41.065]                               next
[17:42:41.065]                             invokeRestart(restart)
[17:42:41.065]                             muffled <- TRUE
[17:42:41.065]                             break
[17:42:41.065]                           }
[17:42:41.065]                         }
[17:42:41.065]                       }
[17:42:41.065]                       invisible(muffled)
[17:42:41.065]                     }
[17:42:41.065]                     muffleCondition(cond, pattern = "^muffle")
[17:42:41.065]                   }
[17:42:41.065]                 }
[17:42:41.065]             }
[17:42:41.065]         }))
[17:42:41.065]     }, error = function(ex) {
[17:42:41.065]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:41.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:41.065]                 ...future.rng), started = ...future.startTime, 
[17:42:41.065]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:41.065]             version = "1.8"), class = "FutureResult")
[17:42:41.065]     }, finally = {
[17:42:41.065]         if (!identical(...future.workdir, getwd())) 
[17:42:41.065]             setwd(...future.workdir)
[17:42:41.065]         {
[17:42:41.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:41.065]                 ...future.oldOptions$nwarnings <- NULL
[17:42:41.065]             }
[17:42:41.065]             base::options(...future.oldOptions)
[17:42:41.065]             if (.Platform$OS.type == "windows") {
[17:42:41.065]                 old_names <- names(...future.oldEnvVars)
[17:42:41.065]                 envs <- base::Sys.getenv()
[17:42:41.065]                 names <- names(envs)
[17:42:41.065]                 common <- intersect(names, old_names)
[17:42:41.065]                 added <- setdiff(names, old_names)
[17:42:41.065]                 removed <- setdiff(old_names, names)
[17:42:41.065]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:41.065]                   envs[common]]
[17:42:41.065]                 NAMES <- toupper(changed)
[17:42:41.065]                 args <- list()
[17:42:41.065]                 for (kk in seq_along(NAMES)) {
[17:42:41.065]                   name <- changed[[kk]]
[17:42:41.065]                   NAME <- NAMES[[kk]]
[17:42:41.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.065]                     next
[17:42:41.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:41.065]                 }
[17:42:41.065]                 NAMES <- toupper(added)
[17:42:41.065]                 for (kk in seq_along(NAMES)) {
[17:42:41.065]                   name <- added[[kk]]
[17:42:41.065]                   NAME <- NAMES[[kk]]
[17:42:41.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.065]                     next
[17:42:41.065]                   args[[name]] <- ""
[17:42:41.065]                 }
[17:42:41.065]                 NAMES <- toupper(removed)
[17:42:41.065]                 for (kk in seq_along(NAMES)) {
[17:42:41.065]                   name <- removed[[kk]]
[17:42:41.065]                   NAME <- NAMES[[kk]]
[17:42:41.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.065]                     next
[17:42:41.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:41.065]                 }
[17:42:41.065]                 if (length(args) > 0) 
[17:42:41.065]                   base::do.call(base::Sys.setenv, args = args)
[17:42:41.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:41.065]             }
[17:42:41.065]             else {
[17:42:41.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:41.065]             }
[17:42:41.065]             {
[17:42:41.065]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:41.065]                   0L) {
[17:42:41.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:41.065]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:41.065]                   base::options(opts)
[17:42:41.065]                 }
[17:42:41.065]                 {
[17:42:41.065]                   {
[17:42:41.065]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:41.065]                     NULL
[17:42:41.065]                   }
[17:42:41.065]                   options(future.plan = NULL)
[17:42:41.065]                   if (is.na(NA_character_)) 
[17:42:41.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:41.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:41.065]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:41.065]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:41.065]                     envir = parent.frame()) 
[17:42:41.065]                   {
[17:42:41.065]                     if (is.function(workers)) 
[17:42:41.065]                       workers <- workers()
[17:42:41.065]                     workers <- structure(as.integer(workers), 
[17:42:41.065]                       class = class(workers))
[17:42:41.065]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:41.065]                       workers >= 1)
[17:42:41.065]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:41.065]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:41.065]                     }
[17:42:41.065]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:41.065]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:41.065]                       envir = envir)
[17:42:41.065]                     if (!future$lazy) 
[17:42:41.065]                       future <- run(future)
[17:42:41.065]                     invisible(future)
[17:42:41.065]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:41.065]                 }
[17:42:41.065]             }
[17:42:41.065]         }
[17:42:41.065]     })
[17:42:41.065]     if (TRUE) {
[17:42:41.065]         base::sink(type = "output", split = FALSE)
[17:42:41.065]         if (TRUE) {
[17:42:41.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:41.065]         }
[17:42:41.065]         else {
[17:42:41.065]             ...future.result["stdout"] <- base::list(NULL)
[17:42:41.065]         }
[17:42:41.065]         base::close(...future.stdout)
[17:42:41.065]         ...future.stdout <- NULL
[17:42:41.065]     }
[17:42:41.065]     ...future.result$conditions <- ...future.conditions
[17:42:41.065]     ...future.result$finished <- base::Sys.time()
[17:42:41.065]     ...future.result
[17:42:41.065] }
[17:42:41.068] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:42:41.068] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:42:41.068] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:42:41.068] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:42:41.069] MultisessionFuture started
[17:42:41.069] - Launch lazy future ... done
[17:42:41.069] run() for ‘MultisessionFuture’ ... done
[17:42:41.069] result() for ClusterFuture ...
[17:42:41.069] receiveMessageFromWorker() for ClusterFuture ...
[17:42:41.069] - Validating connection of MultisessionFuture
[17:42:41.116] - received message: FutureResult
[17:42:41.117] - Received FutureResult
[17:42:41.117] - Erased future from FutureRegistry
[17:42:41.117] result() for ClusterFuture ...
[17:42:41.117] - result already collected: FutureResult
[17:42:41.117] result() for ClusterFuture ... done
[17:42:41.117] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:41.117] result() for ClusterFuture ... done
[17:42:41.117] result() for ClusterFuture ...
[17:42:41.117] - result already collected: FutureResult
[17:42:41.118] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:41.118] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:41.118] Searching for globals...
[17:42:41.120] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:41.120] Searching for globals ... DONE
[17:42:41.120] Resolving globals: TRUE
[17:42:41.121] Resolving any globals that are futures ...
[17:42:41.121] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:41.121] Resolving any globals that are futures ... DONE
[17:42:41.121] Resolving futures part of globals (recursively) ...
[17:42:41.121] resolve() on list ...
[17:42:41.122]  recursive: 99
[17:42:41.122]  length: 1
[17:42:41.122]  elements: ‘x’
[17:42:41.122]  length: 0 (resolved future 1)
[17:42:41.122] resolve() on list ... DONE
[17:42:41.122] - globals: [1] ‘x’
[17:42:41.122] Resolving futures part of globals (recursively) ... DONE
[17:42:41.122] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:41.123] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:41.123] - globals: [1] ‘x’
[17:42:41.123] 
[17:42:41.123] getGlobalsAndPackages() ... DONE
[17:42:41.123] run() for ‘Future’ ...
[17:42:41.123] - state: ‘created’
[17:42:41.123] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:41.138] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:41.138] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:41.138]   - Field: ‘node’
[17:42:41.138]   - Field: ‘label’
[17:42:41.138]   - Field: ‘local’
[17:42:41.138]   - Field: ‘owner’
[17:42:41.138]   - Field: ‘envir’
[17:42:41.139]   - Field: ‘workers’
[17:42:41.139]   - Field: ‘packages’
[17:42:41.139]   - Field: ‘gc’
[17:42:41.139]   - Field: ‘conditions’
[17:42:41.139]   - Field: ‘persistent’
[17:42:41.139]   - Field: ‘expr’
[17:42:41.139]   - Field: ‘uuid’
[17:42:41.139]   - Field: ‘seed’
[17:42:41.139]   - Field: ‘version’
[17:42:41.139]   - Field: ‘result’
[17:42:41.140]   - Field: ‘asynchronous’
[17:42:41.140]   - Field: ‘calls’
[17:42:41.140]   - Field: ‘globals’
[17:42:41.140]   - Field: ‘stdout’
[17:42:41.140]   - Field: ‘earlySignal’
[17:42:41.140]   - Field: ‘lazy’
[17:42:41.140]   - Field: ‘state’
[17:42:41.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:41.140] - Launch lazy future ...
[17:42:41.141] Packages needed by the future expression (n = 0): <none>
[17:42:41.141] Packages needed by future strategies (n = 0): <none>
[17:42:41.141] {
[17:42:41.141]     {
[17:42:41.141]         {
[17:42:41.141]             ...future.startTime <- base::Sys.time()
[17:42:41.141]             {
[17:42:41.141]                 {
[17:42:41.141]                   {
[17:42:41.141]                     {
[17:42:41.141]                       base::local({
[17:42:41.141]                         has_future <- base::requireNamespace("future", 
[17:42:41.141]                           quietly = TRUE)
[17:42:41.141]                         if (has_future) {
[17:42:41.141]                           ns <- base::getNamespace("future")
[17:42:41.141]                           version <- ns[[".package"]][["version"]]
[17:42:41.141]                           if (is.null(version)) 
[17:42:41.141]                             version <- utils::packageVersion("future")
[17:42:41.141]                         }
[17:42:41.141]                         else {
[17:42:41.141]                           version <- NULL
[17:42:41.141]                         }
[17:42:41.141]                         if (!has_future || version < "1.8.0") {
[17:42:41.141]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:41.141]                             "", base::R.version$version.string), 
[17:42:41.141]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:41.141]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:41.141]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:41.141]                               "release", "version")], collapse = " "), 
[17:42:41.141]                             hostname = base::Sys.info()[["nodename"]])
[17:42:41.141]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:41.141]                             info)
[17:42:41.141]                           info <- base::paste(info, collapse = "; ")
[17:42:41.141]                           if (!has_future) {
[17:42:41.141]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:41.141]                               info)
[17:42:41.141]                           }
[17:42:41.141]                           else {
[17:42:41.141]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:41.141]                               info, version)
[17:42:41.141]                           }
[17:42:41.141]                           base::stop(msg)
[17:42:41.141]                         }
[17:42:41.141]                       })
[17:42:41.141]                     }
[17:42:41.141]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:41.141]                     base::options(mc.cores = 1L)
[17:42:41.141]                   }
[17:42:41.141]                   options(future.plan = NULL)
[17:42:41.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:41.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:41.141]                 }
[17:42:41.141]                 ...future.workdir <- getwd()
[17:42:41.141]             }
[17:42:41.141]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:41.141]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:41.141]         }
[17:42:41.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:41.141]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:41.141]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:41.141]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:41.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:41.141]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:41.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:41.141]             base::names(...future.oldOptions))
[17:42:41.141]     }
[17:42:41.141]     if (FALSE) {
[17:42:41.141]     }
[17:42:41.141]     else {
[17:42:41.141]         if (TRUE) {
[17:42:41.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:41.141]                 open = "w")
[17:42:41.141]         }
[17:42:41.141]         else {
[17:42:41.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:41.141]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:41.141]         }
[17:42:41.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:41.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:41.141]             base::sink(type = "output", split = FALSE)
[17:42:41.141]             base::close(...future.stdout)
[17:42:41.141]         }, add = TRUE)
[17:42:41.141]     }
[17:42:41.141]     ...future.frame <- base::sys.nframe()
[17:42:41.141]     ...future.conditions <- base::list()
[17:42:41.141]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:41.141]     if (FALSE) {
[17:42:41.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:41.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:41.141]     }
[17:42:41.141]     ...future.result <- base::tryCatch({
[17:42:41.141]         base::withCallingHandlers({
[17:42:41.141]             ...future.value <- base::withVisible(base::local({
[17:42:41.141]                 ...future.makeSendCondition <- local({
[17:42:41.141]                   sendCondition <- NULL
[17:42:41.141]                   function(frame = 1L) {
[17:42:41.141]                     if (is.function(sendCondition)) 
[17:42:41.141]                       return(sendCondition)
[17:42:41.141]                     ns <- getNamespace("parallel")
[17:42:41.141]                     if (exists("sendData", mode = "function", 
[17:42:41.141]                       envir = ns)) {
[17:42:41.141]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:41.141]                         envir = ns)
[17:42:41.141]                       envir <- sys.frame(frame)
[17:42:41.141]                       master <- NULL
[17:42:41.141]                       while (!identical(envir, .GlobalEnv) && 
[17:42:41.141]                         !identical(envir, emptyenv())) {
[17:42:41.141]                         if (exists("master", mode = "list", envir = envir, 
[17:42:41.141]                           inherits = FALSE)) {
[17:42:41.141]                           master <- get("master", mode = "list", 
[17:42:41.141]                             envir = envir, inherits = FALSE)
[17:42:41.141]                           if (inherits(master, c("SOCKnode", 
[17:42:41.141]                             "SOCK0node"))) {
[17:42:41.141]                             sendCondition <<- function(cond) {
[17:42:41.141]                               data <- list(type = "VALUE", value = cond, 
[17:42:41.141]                                 success = TRUE)
[17:42:41.141]                               parallel_sendData(master, data)
[17:42:41.141]                             }
[17:42:41.141]                             return(sendCondition)
[17:42:41.141]                           }
[17:42:41.141]                         }
[17:42:41.141]                         frame <- frame + 1L
[17:42:41.141]                         envir <- sys.frame(frame)
[17:42:41.141]                       }
[17:42:41.141]                     }
[17:42:41.141]                     sendCondition <<- function(cond) NULL
[17:42:41.141]                   }
[17:42:41.141]                 })
[17:42:41.141]                 withCallingHandlers({
[17:42:41.141]                   {
[17:42:41.141]                     x["a"] <- list(1)
[17:42:41.141]                     x
[17:42:41.141]                   }
[17:42:41.141]                 }, immediateCondition = function(cond) {
[17:42:41.141]                   sendCondition <- ...future.makeSendCondition()
[17:42:41.141]                   sendCondition(cond)
[17:42:41.141]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.141]                   {
[17:42:41.141]                     inherits <- base::inherits
[17:42:41.141]                     invokeRestart <- base::invokeRestart
[17:42:41.141]                     is.null <- base::is.null
[17:42:41.141]                     muffled <- FALSE
[17:42:41.141]                     if (inherits(cond, "message")) {
[17:42:41.141]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:41.141]                       if (muffled) 
[17:42:41.141]                         invokeRestart("muffleMessage")
[17:42:41.141]                     }
[17:42:41.141]                     else if (inherits(cond, "warning")) {
[17:42:41.141]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:41.141]                       if (muffled) 
[17:42:41.141]                         invokeRestart("muffleWarning")
[17:42:41.141]                     }
[17:42:41.141]                     else if (inherits(cond, "condition")) {
[17:42:41.141]                       if (!is.null(pattern)) {
[17:42:41.141]                         computeRestarts <- base::computeRestarts
[17:42:41.141]                         grepl <- base::grepl
[17:42:41.141]                         restarts <- computeRestarts(cond)
[17:42:41.141]                         for (restart in restarts) {
[17:42:41.141]                           name <- restart$name
[17:42:41.141]                           if (is.null(name)) 
[17:42:41.141]                             next
[17:42:41.141]                           if (!grepl(pattern, name)) 
[17:42:41.141]                             next
[17:42:41.141]                           invokeRestart(restart)
[17:42:41.141]                           muffled <- TRUE
[17:42:41.141]                           break
[17:42:41.141]                         }
[17:42:41.141]                       }
[17:42:41.141]                     }
[17:42:41.141]                     invisible(muffled)
[17:42:41.141]                   }
[17:42:41.141]                   muffleCondition(cond)
[17:42:41.141]                 })
[17:42:41.141]             }))
[17:42:41.141]             future::FutureResult(value = ...future.value$value, 
[17:42:41.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:41.141]                   ...future.rng), globalenv = if (FALSE) 
[17:42:41.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:41.141]                     ...future.globalenv.names))
[17:42:41.141]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:41.141]         }, condition = base::local({
[17:42:41.141]             c <- base::c
[17:42:41.141]             inherits <- base::inherits
[17:42:41.141]             invokeRestart <- base::invokeRestart
[17:42:41.141]             length <- base::length
[17:42:41.141]             list <- base::list
[17:42:41.141]             seq.int <- base::seq.int
[17:42:41.141]             signalCondition <- base::signalCondition
[17:42:41.141]             sys.calls <- base::sys.calls
[17:42:41.141]             `[[` <- base::`[[`
[17:42:41.141]             `+` <- base::`+`
[17:42:41.141]             `<<-` <- base::`<<-`
[17:42:41.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:41.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:41.141]                   3L)]
[17:42:41.141]             }
[17:42:41.141]             function(cond) {
[17:42:41.141]                 is_error <- inherits(cond, "error")
[17:42:41.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:41.141]                   NULL)
[17:42:41.141]                 if (is_error) {
[17:42:41.141]                   sessionInformation <- function() {
[17:42:41.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:41.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:41.141]                       search = base::search(), system = base::Sys.info())
[17:42:41.141]                   }
[17:42:41.141]                   ...future.conditions[[length(...future.conditions) + 
[17:42:41.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:41.141]                     cond$call), session = sessionInformation(), 
[17:42:41.141]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:41.141]                   signalCondition(cond)
[17:42:41.141]                 }
[17:42:41.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:41.141]                 "immediateCondition"))) {
[17:42:41.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:41.141]                   ...future.conditions[[length(...future.conditions) + 
[17:42:41.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:41.141]                   if (TRUE && !signal) {
[17:42:41.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.141]                     {
[17:42:41.141]                       inherits <- base::inherits
[17:42:41.141]                       invokeRestart <- base::invokeRestart
[17:42:41.141]                       is.null <- base::is.null
[17:42:41.141]                       muffled <- FALSE
[17:42:41.141]                       if (inherits(cond, "message")) {
[17:42:41.141]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:41.141]                         if (muffled) 
[17:42:41.141]                           invokeRestart("muffleMessage")
[17:42:41.141]                       }
[17:42:41.141]                       else if (inherits(cond, "warning")) {
[17:42:41.141]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:41.141]                         if (muffled) 
[17:42:41.141]                           invokeRestart("muffleWarning")
[17:42:41.141]                       }
[17:42:41.141]                       else if (inherits(cond, "condition")) {
[17:42:41.141]                         if (!is.null(pattern)) {
[17:42:41.141]                           computeRestarts <- base::computeRestarts
[17:42:41.141]                           grepl <- base::grepl
[17:42:41.141]                           restarts <- computeRestarts(cond)
[17:42:41.141]                           for (restart in restarts) {
[17:42:41.141]                             name <- restart$name
[17:42:41.141]                             if (is.null(name)) 
[17:42:41.141]                               next
[17:42:41.141]                             if (!grepl(pattern, name)) 
[17:42:41.141]                               next
[17:42:41.141]                             invokeRestart(restart)
[17:42:41.141]                             muffled <- TRUE
[17:42:41.141]                             break
[17:42:41.141]                           }
[17:42:41.141]                         }
[17:42:41.141]                       }
[17:42:41.141]                       invisible(muffled)
[17:42:41.141]                     }
[17:42:41.141]                     muffleCondition(cond, pattern = "^muffle")
[17:42:41.141]                   }
[17:42:41.141]                 }
[17:42:41.141]                 else {
[17:42:41.141]                   if (TRUE) {
[17:42:41.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.141]                     {
[17:42:41.141]                       inherits <- base::inherits
[17:42:41.141]                       invokeRestart <- base::invokeRestart
[17:42:41.141]                       is.null <- base::is.null
[17:42:41.141]                       muffled <- FALSE
[17:42:41.141]                       if (inherits(cond, "message")) {
[17:42:41.141]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:41.141]                         if (muffled) 
[17:42:41.141]                           invokeRestart("muffleMessage")
[17:42:41.141]                       }
[17:42:41.141]                       else if (inherits(cond, "warning")) {
[17:42:41.141]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:41.141]                         if (muffled) 
[17:42:41.141]                           invokeRestart("muffleWarning")
[17:42:41.141]                       }
[17:42:41.141]                       else if (inherits(cond, "condition")) {
[17:42:41.141]                         if (!is.null(pattern)) {
[17:42:41.141]                           computeRestarts <- base::computeRestarts
[17:42:41.141]                           grepl <- base::grepl
[17:42:41.141]                           restarts <- computeRestarts(cond)
[17:42:41.141]                           for (restart in restarts) {
[17:42:41.141]                             name <- restart$name
[17:42:41.141]                             if (is.null(name)) 
[17:42:41.141]                               next
[17:42:41.141]                             if (!grepl(pattern, name)) 
[17:42:41.141]                               next
[17:42:41.141]                             invokeRestart(restart)
[17:42:41.141]                             muffled <- TRUE
[17:42:41.141]                             break
[17:42:41.141]                           }
[17:42:41.141]                         }
[17:42:41.141]                       }
[17:42:41.141]                       invisible(muffled)
[17:42:41.141]                     }
[17:42:41.141]                     muffleCondition(cond, pattern = "^muffle")
[17:42:41.141]                   }
[17:42:41.141]                 }
[17:42:41.141]             }
[17:42:41.141]         }))
[17:42:41.141]     }, error = function(ex) {
[17:42:41.141]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:41.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:41.141]                 ...future.rng), started = ...future.startTime, 
[17:42:41.141]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:41.141]             version = "1.8"), class = "FutureResult")
[17:42:41.141]     }, finally = {
[17:42:41.141]         if (!identical(...future.workdir, getwd())) 
[17:42:41.141]             setwd(...future.workdir)
[17:42:41.141]         {
[17:42:41.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:41.141]                 ...future.oldOptions$nwarnings <- NULL
[17:42:41.141]             }
[17:42:41.141]             base::options(...future.oldOptions)
[17:42:41.141]             if (.Platform$OS.type == "windows") {
[17:42:41.141]                 old_names <- names(...future.oldEnvVars)
[17:42:41.141]                 envs <- base::Sys.getenv()
[17:42:41.141]                 names <- names(envs)
[17:42:41.141]                 common <- intersect(names, old_names)
[17:42:41.141]                 added <- setdiff(names, old_names)
[17:42:41.141]                 removed <- setdiff(old_names, names)
[17:42:41.141]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:41.141]                   envs[common]]
[17:42:41.141]                 NAMES <- toupper(changed)
[17:42:41.141]                 args <- list()
[17:42:41.141]                 for (kk in seq_along(NAMES)) {
[17:42:41.141]                   name <- changed[[kk]]
[17:42:41.141]                   NAME <- NAMES[[kk]]
[17:42:41.141]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.141]                     next
[17:42:41.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:41.141]                 }
[17:42:41.141]                 NAMES <- toupper(added)
[17:42:41.141]                 for (kk in seq_along(NAMES)) {
[17:42:41.141]                   name <- added[[kk]]
[17:42:41.141]                   NAME <- NAMES[[kk]]
[17:42:41.141]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.141]                     next
[17:42:41.141]                   args[[name]] <- ""
[17:42:41.141]                 }
[17:42:41.141]                 NAMES <- toupper(removed)
[17:42:41.141]                 for (kk in seq_along(NAMES)) {
[17:42:41.141]                   name <- removed[[kk]]
[17:42:41.141]                   NAME <- NAMES[[kk]]
[17:42:41.141]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.141]                     next
[17:42:41.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:41.141]                 }
[17:42:41.141]                 if (length(args) > 0) 
[17:42:41.141]                   base::do.call(base::Sys.setenv, args = args)
[17:42:41.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:41.141]             }
[17:42:41.141]             else {
[17:42:41.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:41.141]             }
[17:42:41.141]             {
[17:42:41.141]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:41.141]                   0L) {
[17:42:41.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:41.141]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:41.141]                   base::options(opts)
[17:42:41.141]                 }
[17:42:41.141]                 {
[17:42:41.141]                   {
[17:42:41.141]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:41.141]                     NULL
[17:42:41.141]                   }
[17:42:41.141]                   options(future.plan = NULL)
[17:42:41.141]                   if (is.na(NA_character_)) 
[17:42:41.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:41.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:41.141]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:41.141]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:41.141]                     envir = parent.frame()) 
[17:42:41.141]                   {
[17:42:41.141]                     if (is.function(workers)) 
[17:42:41.141]                       workers <- workers()
[17:42:41.141]                     workers <- structure(as.integer(workers), 
[17:42:41.141]                       class = class(workers))
[17:42:41.141]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:41.141]                       workers >= 1)
[17:42:41.141]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:41.141]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:41.141]                     }
[17:42:41.141]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:41.141]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:41.141]                       envir = envir)
[17:42:41.141]                     if (!future$lazy) 
[17:42:41.141]                       future <- run(future)
[17:42:41.141]                     invisible(future)
[17:42:41.141]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:41.141]                 }
[17:42:41.141]             }
[17:42:41.141]         }
[17:42:41.141]     })
[17:42:41.141]     if (TRUE) {
[17:42:41.141]         base::sink(type = "output", split = FALSE)
[17:42:41.141]         if (TRUE) {
[17:42:41.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:41.141]         }
[17:42:41.141]         else {
[17:42:41.141]             ...future.result["stdout"] <- base::list(NULL)
[17:42:41.141]         }
[17:42:41.141]         base::close(...future.stdout)
[17:42:41.141]         ...future.stdout <- NULL
[17:42:41.141]     }
[17:42:41.141]     ...future.result$conditions <- ...future.conditions
[17:42:41.141]     ...future.result$finished <- base::Sys.time()
[17:42:41.141]     ...future.result
[17:42:41.141] }
[17:42:41.144] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:42:41.144] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:42:41.144] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:42:41.145] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:42:41.145] MultisessionFuture started
[17:42:41.145] - Launch lazy future ... done
[17:42:41.145] run() for ‘MultisessionFuture’ ... done
[17:42:41.145] result() for ClusterFuture ...
[17:42:41.145] receiveMessageFromWorker() for ClusterFuture ...
[17:42:41.146] - Validating connection of MultisessionFuture
[17:42:41.192] - received message: FutureResult
[17:42:41.192] - Received FutureResult
[17:42:41.192] - Erased future from FutureRegistry
[17:42:41.192] result() for ClusterFuture ...
[17:42:41.192] - result already collected: FutureResult
[17:42:41.192] result() for ClusterFuture ... done
[17:42:41.192] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:41.192] result() for ClusterFuture ... done
[17:42:41.192] result() for ClusterFuture ...
[17:42:41.193] - result already collected: FutureResult
[17:42:41.193] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:41.193] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:41.193] Searching for globals...
[17:42:41.195] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:41.196] Searching for globals ... DONE
[17:42:41.196] Resolving globals: TRUE
[17:42:41.196] Resolving any globals that are futures ...
[17:42:41.196] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:42:41.196] Resolving any globals that are futures ... DONE
[17:42:41.196] Resolving futures part of globals (recursively) ...
[17:42:41.197] resolve() on list ...
[17:42:41.197]  recursive: 99
[17:42:41.197]  length: 1
[17:42:41.197]  elements: ‘x’
[17:42:41.197]  length: 0 (resolved future 1)
[17:42:41.197] resolve() on list ... DONE
[17:42:41.197] - globals: [1] ‘x’
[17:42:41.197] Resolving futures part of globals (recursively) ... DONE
[17:42:41.197] The total size of the 1 globals is 0 bytes (0 bytes)
[17:42:41.198] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:42:41.198] - globals: [1] ‘x’
[17:42:41.198] 
[17:42:41.198] getGlobalsAndPackages() ... DONE
[17:42:41.198] run() for ‘Future’ ...
[17:42:41.198] - state: ‘created’
[17:42:41.199] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:41.213] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:41.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:41.213]   - Field: ‘node’
[17:42:41.214]   - Field: ‘label’
[17:42:41.214]   - Field: ‘local’
[17:42:41.214]   - Field: ‘owner’
[17:42:41.214]   - Field: ‘envir’
[17:42:41.214]   - Field: ‘workers’
[17:42:41.214]   - Field: ‘packages’
[17:42:41.214]   - Field: ‘gc’
[17:42:41.214]   - Field: ‘conditions’
[17:42:41.214]   - Field: ‘persistent’
[17:42:41.214]   - Field: ‘expr’
[17:42:41.215]   - Field: ‘uuid’
[17:42:41.215]   - Field: ‘seed’
[17:42:41.215]   - Field: ‘version’
[17:42:41.215]   - Field: ‘result’
[17:42:41.215]   - Field: ‘asynchronous’
[17:42:41.215]   - Field: ‘calls’
[17:42:41.215]   - Field: ‘globals’
[17:42:41.215]   - Field: ‘stdout’
[17:42:41.215]   - Field: ‘earlySignal’
[17:42:41.215]   - Field: ‘lazy’
[17:42:41.215]   - Field: ‘state’
[17:42:41.216] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:41.216] - Launch lazy future ...
[17:42:41.216] Packages needed by the future expression (n = 0): <none>
[17:42:41.216] Packages needed by future strategies (n = 0): <none>
[17:42:41.217] {
[17:42:41.217]     {
[17:42:41.217]         {
[17:42:41.217]             ...future.startTime <- base::Sys.time()
[17:42:41.217]             {
[17:42:41.217]                 {
[17:42:41.217]                   {
[17:42:41.217]                     {
[17:42:41.217]                       base::local({
[17:42:41.217]                         has_future <- base::requireNamespace("future", 
[17:42:41.217]                           quietly = TRUE)
[17:42:41.217]                         if (has_future) {
[17:42:41.217]                           ns <- base::getNamespace("future")
[17:42:41.217]                           version <- ns[[".package"]][["version"]]
[17:42:41.217]                           if (is.null(version)) 
[17:42:41.217]                             version <- utils::packageVersion("future")
[17:42:41.217]                         }
[17:42:41.217]                         else {
[17:42:41.217]                           version <- NULL
[17:42:41.217]                         }
[17:42:41.217]                         if (!has_future || version < "1.8.0") {
[17:42:41.217]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:41.217]                             "", base::R.version$version.string), 
[17:42:41.217]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:41.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:41.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:41.217]                               "release", "version")], collapse = " "), 
[17:42:41.217]                             hostname = base::Sys.info()[["nodename"]])
[17:42:41.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:41.217]                             info)
[17:42:41.217]                           info <- base::paste(info, collapse = "; ")
[17:42:41.217]                           if (!has_future) {
[17:42:41.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:41.217]                               info)
[17:42:41.217]                           }
[17:42:41.217]                           else {
[17:42:41.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:41.217]                               info, version)
[17:42:41.217]                           }
[17:42:41.217]                           base::stop(msg)
[17:42:41.217]                         }
[17:42:41.217]                       })
[17:42:41.217]                     }
[17:42:41.217]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:41.217]                     base::options(mc.cores = 1L)
[17:42:41.217]                   }
[17:42:41.217]                   options(future.plan = NULL)
[17:42:41.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:41.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:41.217]                 }
[17:42:41.217]                 ...future.workdir <- getwd()
[17:42:41.217]             }
[17:42:41.217]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:41.217]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:41.217]         }
[17:42:41.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:41.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:41.217]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:41.217]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:41.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:41.217]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:41.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:41.217]             base::names(...future.oldOptions))
[17:42:41.217]     }
[17:42:41.217]     if (FALSE) {
[17:42:41.217]     }
[17:42:41.217]     else {
[17:42:41.217]         if (TRUE) {
[17:42:41.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:41.217]                 open = "w")
[17:42:41.217]         }
[17:42:41.217]         else {
[17:42:41.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:41.217]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:41.217]         }
[17:42:41.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:41.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:41.217]             base::sink(type = "output", split = FALSE)
[17:42:41.217]             base::close(...future.stdout)
[17:42:41.217]         }, add = TRUE)
[17:42:41.217]     }
[17:42:41.217]     ...future.frame <- base::sys.nframe()
[17:42:41.217]     ...future.conditions <- base::list()
[17:42:41.217]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:41.217]     if (FALSE) {
[17:42:41.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:41.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:41.217]     }
[17:42:41.217]     ...future.result <- base::tryCatch({
[17:42:41.217]         base::withCallingHandlers({
[17:42:41.217]             ...future.value <- base::withVisible(base::local({
[17:42:41.217]                 ...future.makeSendCondition <- local({
[17:42:41.217]                   sendCondition <- NULL
[17:42:41.217]                   function(frame = 1L) {
[17:42:41.217]                     if (is.function(sendCondition)) 
[17:42:41.217]                       return(sendCondition)
[17:42:41.217]                     ns <- getNamespace("parallel")
[17:42:41.217]                     if (exists("sendData", mode = "function", 
[17:42:41.217]                       envir = ns)) {
[17:42:41.217]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:41.217]                         envir = ns)
[17:42:41.217]                       envir <- sys.frame(frame)
[17:42:41.217]                       master <- NULL
[17:42:41.217]                       while (!identical(envir, .GlobalEnv) && 
[17:42:41.217]                         !identical(envir, emptyenv())) {
[17:42:41.217]                         if (exists("master", mode = "list", envir = envir, 
[17:42:41.217]                           inherits = FALSE)) {
[17:42:41.217]                           master <- get("master", mode = "list", 
[17:42:41.217]                             envir = envir, inherits = FALSE)
[17:42:41.217]                           if (inherits(master, c("SOCKnode", 
[17:42:41.217]                             "SOCK0node"))) {
[17:42:41.217]                             sendCondition <<- function(cond) {
[17:42:41.217]                               data <- list(type = "VALUE", value = cond, 
[17:42:41.217]                                 success = TRUE)
[17:42:41.217]                               parallel_sendData(master, data)
[17:42:41.217]                             }
[17:42:41.217]                             return(sendCondition)
[17:42:41.217]                           }
[17:42:41.217]                         }
[17:42:41.217]                         frame <- frame + 1L
[17:42:41.217]                         envir <- sys.frame(frame)
[17:42:41.217]                       }
[17:42:41.217]                     }
[17:42:41.217]                     sendCondition <<- function(cond) NULL
[17:42:41.217]                   }
[17:42:41.217]                 })
[17:42:41.217]                 withCallingHandlers({
[17:42:41.217]                   {
[17:42:41.217]                     x["a"] <- list(1)
[17:42:41.217]                     x
[17:42:41.217]                   }
[17:42:41.217]                 }, immediateCondition = function(cond) {
[17:42:41.217]                   sendCondition <- ...future.makeSendCondition()
[17:42:41.217]                   sendCondition(cond)
[17:42:41.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.217]                   {
[17:42:41.217]                     inherits <- base::inherits
[17:42:41.217]                     invokeRestart <- base::invokeRestart
[17:42:41.217]                     is.null <- base::is.null
[17:42:41.217]                     muffled <- FALSE
[17:42:41.217]                     if (inherits(cond, "message")) {
[17:42:41.217]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:41.217]                       if (muffled) 
[17:42:41.217]                         invokeRestart("muffleMessage")
[17:42:41.217]                     }
[17:42:41.217]                     else if (inherits(cond, "warning")) {
[17:42:41.217]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:41.217]                       if (muffled) 
[17:42:41.217]                         invokeRestart("muffleWarning")
[17:42:41.217]                     }
[17:42:41.217]                     else if (inherits(cond, "condition")) {
[17:42:41.217]                       if (!is.null(pattern)) {
[17:42:41.217]                         computeRestarts <- base::computeRestarts
[17:42:41.217]                         grepl <- base::grepl
[17:42:41.217]                         restarts <- computeRestarts(cond)
[17:42:41.217]                         for (restart in restarts) {
[17:42:41.217]                           name <- restart$name
[17:42:41.217]                           if (is.null(name)) 
[17:42:41.217]                             next
[17:42:41.217]                           if (!grepl(pattern, name)) 
[17:42:41.217]                             next
[17:42:41.217]                           invokeRestart(restart)
[17:42:41.217]                           muffled <- TRUE
[17:42:41.217]                           break
[17:42:41.217]                         }
[17:42:41.217]                       }
[17:42:41.217]                     }
[17:42:41.217]                     invisible(muffled)
[17:42:41.217]                   }
[17:42:41.217]                   muffleCondition(cond)
[17:42:41.217]                 })
[17:42:41.217]             }))
[17:42:41.217]             future::FutureResult(value = ...future.value$value, 
[17:42:41.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:41.217]                   ...future.rng), globalenv = if (FALSE) 
[17:42:41.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:41.217]                     ...future.globalenv.names))
[17:42:41.217]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:41.217]         }, condition = base::local({
[17:42:41.217]             c <- base::c
[17:42:41.217]             inherits <- base::inherits
[17:42:41.217]             invokeRestart <- base::invokeRestart
[17:42:41.217]             length <- base::length
[17:42:41.217]             list <- base::list
[17:42:41.217]             seq.int <- base::seq.int
[17:42:41.217]             signalCondition <- base::signalCondition
[17:42:41.217]             sys.calls <- base::sys.calls
[17:42:41.217]             `[[` <- base::`[[`
[17:42:41.217]             `+` <- base::`+`
[17:42:41.217]             `<<-` <- base::`<<-`
[17:42:41.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:41.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:41.217]                   3L)]
[17:42:41.217]             }
[17:42:41.217]             function(cond) {
[17:42:41.217]                 is_error <- inherits(cond, "error")
[17:42:41.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:41.217]                   NULL)
[17:42:41.217]                 if (is_error) {
[17:42:41.217]                   sessionInformation <- function() {
[17:42:41.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:41.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:41.217]                       search = base::search(), system = base::Sys.info())
[17:42:41.217]                   }
[17:42:41.217]                   ...future.conditions[[length(...future.conditions) + 
[17:42:41.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:41.217]                     cond$call), session = sessionInformation(), 
[17:42:41.217]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:41.217]                   signalCondition(cond)
[17:42:41.217]                 }
[17:42:41.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:41.217]                 "immediateCondition"))) {
[17:42:41.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:41.217]                   ...future.conditions[[length(...future.conditions) + 
[17:42:41.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:41.217]                   if (TRUE && !signal) {
[17:42:41.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.217]                     {
[17:42:41.217]                       inherits <- base::inherits
[17:42:41.217]                       invokeRestart <- base::invokeRestart
[17:42:41.217]                       is.null <- base::is.null
[17:42:41.217]                       muffled <- FALSE
[17:42:41.217]                       if (inherits(cond, "message")) {
[17:42:41.217]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:41.217]                         if (muffled) 
[17:42:41.217]                           invokeRestart("muffleMessage")
[17:42:41.217]                       }
[17:42:41.217]                       else if (inherits(cond, "warning")) {
[17:42:41.217]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:41.217]                         if (muffled) 
[17:42:41.217]                           invokeRestart("muffleWarning")
[17:42:41.217]                       }
[17:42:41.217]                       else if (inherits(cond, "condition")) {
[17:42:41.217]                         if (!is.null(pattern)) {
[17:42:41.217]                           computeRestarts <- base::computeRestarts
[17:42:41.217]                           grepl <- base::grepl
[17:42:41.217]                           restarts <- computeRestarts(cond)
[17:42:41.217]                           for (restart in restarts) {
[17:42:41.217]                             name <- restart$name
[17:42:41.217]                             if (is.null(name)) 
[17:42:41.217]                               next
[17:42:41.217]                             if (!grepl(pattern, name)) 
[17:42:41.217]                               next
[17:42:41.217]                             invokeRestart(restart)
[17:42:41.217]                             muffled <- TRUE
[17:42:41.217]                             break
[17:42:41.217]                           }
[17:42:41.217]                         }
[17:42:41.217]                       }
[17:42:41.217]                       invisible(muffled)
[17:42:41.217]                     }
[17:42:41.217]                     muffleCondition(cond, pattern = "^muffle")
[17:42:41.217]                   }
[17:42:41.217]                 }
[17:42:41.217]                 else {
[17:42:41.217]                   if (TRUE) {
[17:42:41.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.217]                     {
[17:42:41.217]                       inherits <- base::inherits
[17:42:41.217]                       invokeRestart <- base::invokeRestart
[17:42:41.217]                       is.null <- base::is.null
[17:42:41.217]                       muffled <- FALSE
[17:42:41.217]                       if (inherits(cond, "message")) {
[17:42:41.217]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:41.217]                         if (muffled) 
[17:42:41.217]                           invokeRestart("muffleMessage")
[17:42:41.217]                       }
[17:42:41.217]                       else if (inherits(cond, "warning")) {
[17:42:41.217]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:41.217]                         if (muffled) 
[17:42:41.217]                           invokeRestart("muffleWarning")
[17:42:41.217]                       }
[17:42:41.217]                       else if (inherits(cond, "condition")) {
[17:42:41.217]                         if (!is.null(pattern)) {
[17:42:41.217]                           computeRestarts <- base::computeRestarts
[17:42:41.217]                           grepl <- base::grepl
[17:42:41.217]                           restarts <- computeRestarts(cond)
[17:42:41.217]                           for (restart in restarts) {
[17:42:41.217]                             name <- restart$name
[17:42:41.217]                             if (is.null(name)) 
[17:42:41.217]                               next
[17:42:41.217]                             if (!grepl(pattern, name)) 
[17:42:41.217]                               next
[17:42:41.217]                             invokeRestart(restart)
[17:42:41.217]                             muffled <- TRUE
[17:42:41.217]                             break
[17:42:41.217]                           }
[17:42:41.217]                         }
[17:42:41.217]                       }
[17:42:41.217]                       invisible(muffled)
[17:42:41.217]                     }
[17:42:41.217]                     muffleCondition(cond, pattern = "^muffle")
[17:42:41.217]                   }
[17:42:41.217]                 }
[17:42:41.217]             }
[17:42:41.217]         }))
[17:42:41.217]     }, error = function(ex) {
[17:42:41.217]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:41.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:41.217]                 ...future.rng), started = ...future.startTime, 
[17:42:41.217]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:41.217]             version = "1.8"), class = "FutureResult")
[17:42:41.217]     }, finally = {
[17:42:41.217]         if (!identical(...future.workdir, getwd())) 
[17:42:41.217]             setwd(...future.workdir)
[17:42:41.217]         {
[17:42:41.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:41.217]                 ...future.oldOptions$nwarnings <- NULL
[17:42:41.217]             }
[17:42:41.217]             base::options(...future.oldOptions)
[17:42:41.217]             if (.Platform$OS.type == "windows") {
[17:42:41.217]                 old_names <- names(...future.oldEnvVars)
[17:42:41.217]                 envs <- base::Sys.getenv()
[17:42:41.217]                 names <- names(envs)
[17:42:41.217]                 common <- intersect(names, old_names)
[17:42:41.217]                 added <- setdiff(names, old_names)
[17:42:41.217]                 removed <- setdiff(old_names, names)
[17:42:41.217]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:41.217]                   envs[common]]
[17:42:41.217]                 NAMES <- toupper(changed)
[17:42:41.217]                 args <- list()
[17:42:41.217]                 for (kk in seq_along(NAMES)) {
[17:42:41.217]                   name <- changed[[kk]]
[17:42:41.217]                   NAME <- NAMES[[kk]]
[17:42:41.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.217]                     next
[17:42:41.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:41.217]                 }
[17:42:41.217]                 NAMES <- toupper(added)
[17:42:41.217]                 for (kk in seq_along(NAMES)) {
[17:42:41.217]                   name <- added[[kk]]
[17:42:41.217]                   NAME <- NAMES[[kk]]
[17:42:41.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.217]                     next
[17:42:41.217]                   args[[name]] <- ""
[17:42:41.217]                 }
[17:42:41.217]                 NAMES <- toupper(removed)
[17:42:41.217]                 for (kk in seq_along(NAMES)) {
[17:42:41.217]                   name <- removed[[kk]]
[17:42:41.217]                   NAME <- NAMES[[kk]]
[17:42:41.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.217]                     next
[17:42:41.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:41.217]                 }
[17:42:41.217]                 if (length(args) > 0) 
[17:42:41.217]                   base::do.call(base::Sys.setenv, args = args)
[17:42:41.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:41.217]             }
[17:42:41.217]             else {
[17:42:41.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:41.217]             }
[17:42:41.217]             {
[17:42:41.217]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:41.217]                   0L) {
[17:42:41.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:41.217]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:41.217]                   base::options(opts)
[17:42:41.217]                 }
[17:42:41.217]                 {
[17:42:41.217]                   {
[17:42:41.217]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:41.217]                     NULL
[17:42:41.217]                   }
[17:42:41.217]                   options(future.plan = NULL)
[17:42:41.217]                   if (is.na(NA_character_)) 
[17:42:41.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:41.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:41.217]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:41.217]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:41.217]                     envir = parent.frame()) 
[17:42:41.217]                   {
[17:42:41.217]                     if (is.function(workers)) 
[17:42:41.217]                       workers <- workers()
[17:42:41.217]                     workers <- structure(as.integer(workers), 
[17:42:41.217]                       class = class(workers))
[17:42:41.217]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:41.217]                       workers >= 1)
[17:42:41.217]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:41.217]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:41.217]                     }
[17:42:41.217]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:41.217]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:41.217]                       envir = envir)
[17:42:41.217]                     if (!future$lazy) 
[17:42:41.217]                       future <- run(future)
[17:42:41.217]                     invisible(future)
[17:42:41.217]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:41.217]                 }
[17:42:41.217]             }
[17:42:41.217]         }
[17:42:41.217]     })
[17:42:41.217]     if (TRUE) {
[17:42:41.217]         base::sink(type = "output", split = FALSE)
[17:42:41.217]         if (TRUE) {
[17:42:41.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:41.217]         }
[17:42:41.217]         else {
[17:42:41.217]             ...future.result["stdout"] <- base::list(NULL)
[17:42:41.217]         }
[17:42:41.217]         base::close(...future.stdout)
[17:42:41.217]         ...future.stdout <- NULL
[17:42:41.217]     }
[17:42:41.217]     ...future.result$conditions <- ...future.conditions
[17:42:41.217]     ...future.result$finished <- base::Sys.time()
[17:42:41.217]     ...future.result
[17:42:41.217] }
[17:42:41.219] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:42:41.219] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:42:41.220] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:42:41.220] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:42:41.220] MultisessionFuture started
[17:42:41.221] - Launch lazy future ... done
[17:42:41.221] run() for ‘MultisessionFuture’ ... done
[17:42:41.221] result() for ClusterFuture ...
[17:42:41.221] receiveMessageFromWorker() for ClusterFuture ...
[17:42:41.221] - Validating connection of MultisessionFuture
[17:42:41.268] - received message: FutureResult
[17:42:41.268] - Received FutureResult
[17:42:41.268] - Erased future from FutureRegistry
[17:42:41.269] result() for ClusterFuture ...
[17:42:41.269] - result already collected: FutureResult
[17:42:41.269] result() for ClusterFuture ... done
[17:42:41.269] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:41.269] result() for ClusterFuture ... done
[17:42:41.269] result() for ClusterFuture ...
[17:42:41.269] - result already collected: FutureResult
[17:42:41.269] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:41.270] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:41.270] Searching for globals...
[17:42:41.272] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:42:41.272] Searching for globals ... DONE
[17:42:41.273] Resolving globals: TRUE
[17:42:41.273] Resolving any globals that are futures ...
[17:42:41.273] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:42:41.273] Resolving any globals that are futures ... DONE
[17:42:41.273] Resolving futures part of globals (recursively) ...
[17:42:41.274] resolve() on list ...
[17:42:41.274]  recursive: 99
[17:42:41.274]  length: 2
[17:42:41.274]  elements: ‘x’, ‘name’
[17:42:41.274]  length: 1 (resolved future 1)
[17:42:41.274]  length: 0 (resolved future 2)
[17:42:41.274] resolve() on list ... DONE
[17:42:41.274] - globals: [2] ‘x’, ‘name’
[17:42:41.274] Resolving futures part of globals (recursively) ... DONE
[17:42:41.274] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:41.275] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:42:41.275] - globals: [2] ‘x’, ‘name’
[17:42:41.275] 
[17:42:41.275] getGlobalsAndPackages() ... DONE
[17:42:41.275] run() for ‘Future’ ...
[17:42:41.276] - state: ‘created’
[17:42:41.276] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:41.290] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:41.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:41.290]   - Field: ‘node’
[17:42:41.290]   - Field: ‘label’
[17:42:41.290]   - Field: ‘local’
[17:42:41.291]   - Field: ‘owner’
[17:42:41.291]   - Field: ‘envir’
[17:42:41.291]   - Field: ‘workers’
[17:42:41.291]   - Field: ‘packages’
[17:42:41.291]   - Field: ‘gc’
[17:42:41.291]   - Field: ‘conditions’
[17:42:41.291]   - Field: ‘persistent’
[17:42:41.291]   - Field: ‘expr’
[17:42:41.291]   - Field: ‘uuid’
[17:42:41.291]   - Field: ‘seed’
[17:42:41.292]   - Field: ‘version’
[17:42:41.292]   - Field: ‘result’
[17:42:41.292]   - Field: ‘asynchronous’
[17:42:41.292]   - Field: ‘calls’
[17:42:41.292]   - Field: ‘globals’
[17:42:41.292]   - Field: ‘stdout’
[17:42:41.292]   - Field: ‘earlySignal’
[17:42:41.292]   - Field: ‘lazy’
[17:42:41.292]   - Field: ‘state’
[17:42:41.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:41.292] - Launch lazy future ...
[17:42:41.293] Packages needed by the future expression (n = 0): <none>
[17:42:41.293] Packages needed by future strategies (n = 0): <none>
[17:42:41.293] {
[17:42:41.293]     {
[17:42:41.293]         {
[17:42:41.293]             ...future.startTime <- base::Sys.time()
[17:42:41.293]             {
[17:42:41.293]                 {
[17:42:41.293]                   {
[17:42:41.293]                     {
[17:42:41.293]                       base::local({
[17:42:41.293]                         has_future <- base::requireNamespace("future", 
[17:42:41.293]                           quietly = TRUE)
[17:42:41.293]                         if (has_future) {
[17:42:41.293]                           ns <- base::getNamespace("future")
[17:42:41.293]                           version <- ns[[".package"]][["version"]]
[17:42:41.293]                           if (is.null(version)) 
[17:42:41.293]                             version <- utils::packageVersion("future")
[17:42:41.293]                         }
[17:42:41.293]                         else {
[17:42:41.293]                           version <- NULL
[17:42:41.293]                         }
[17:42:41.293]                         if (!has_future || version < "1.8.0") {
[17:42:41.293]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:41.293]                             "", base::R.version$version.string), 
[17:42:41.293]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:41.293]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:41.293]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:41.293]                               "release", "version")], collapse = " "), 
[17:42:41.293]                             hostname = base::Sys.info()[["nodename"]])
[17:42:41.293]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:41.293]                             info)
[17:42:41.293]                           info <- base::paste(info, collapse = "; ")
[17:42:41.293]                           if (!has_future) {
[17:42:41.293]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:41.293]                               info)
[17:42:41.293]                           }
[17:42:41.293]                           else {
[17:42:41.293]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:41.293]                               info, version)
[17:42:41.293]                           }
[17:42:41.293]                           base::stop(msg)
[17:42:41.293]                         }
[17:42:41.293]                       })
[17:42:41.293]                     }
[17:42:41.293]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:41.293]                     base::options(mc.cores = 1L)
[17:42:41.293]                   }
[17:42:41.293]                   options(future.plan = NULL)
[17:42:41.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:41.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:41.293]                 }
[17:42:41.293]                 ...future.workdir <- getwd()
[17:42:41.293]             }
[17:42:41.293]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:41.293]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:41.293]         }
[17:42:41.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:41.293]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:41.293]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:41.293]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:41.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:41.293]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:41.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:41.293]             base::names(...future.oldOptions))
[17:42:41.293]     }
[17:42:41.293]     if (FALSE) {
[17:42:41.293]     }
[17:42:41.293]     else {
[17:42:41.293]         if (TRUE) {
[17:42:41.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:41.293]                 open = "w")
[17:42:41.293]         }
[17:42:41.293]         else {
[17:42:41.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:41.293]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:41.293]         }
[17:42:41.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:41.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:41.293]             base::sink(type = "output", split = FALSE)
[17:42:41.293]             base::close(...future.stdout)
[17:42:41.293]         }, add = TRUE)
[17:42:41.293]     }
[17:42:41.293]     ...future.frame <- base::sys.nframe()
[17:42:41.293]     ...future.conditions <- base::list()
[17:42:41.293]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:41.293]     if (FALSE) {
[17:42:41.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:41.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:41.293]     }
[17:42:41.293]     ...future.result <- base::tryCatch({
[17:42:41.293]         base::withCallingHandlers({
[17:42:41.293]             ...future.value <- base::withVisible(base::local({
[17:42:41.293]                 ...future.makeSendCondition <- local({
[17:42:41.293]                   sendCondition <- NULL
[17:42:41.293]                   function(frame = 1L) {
[17:42:41.293]                     if (is.function(sendCondition)) 
[17:42:41.293]                       return(sendCondition)
[17:42:41.293]                     ns <- getNamespace("parallel")
[17:42:41.293]                     if (exists("sendData", mode = "function", 
[17:42:41.293]                       envir = ns)) {
[17:42:41.293]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:41.293]                         envir = ns)
[17:42:41.293]                       envir <- sys.frame(frame)
[17:42:41.293]                       master <- NULL
[17:42:41.293]                       while (!identical(envir, .GlobalEnv) && 
[17:42:41.293]                         !identical(envir, emptyenv())) {
[17:42:41.293]                         if (exists("master", mode = "list", envir = envir, 
[17:42:41.293]                           inherits = FALSE)) {
[17:42:41.293]                           master <- get("master", mode = "list", 
[17:42:41.293]                             envir = envir, inherits = FALSE)
[17:42:41.293]                           if (inherits(master, c("SOCKnode", 
[17:42:41.293]                             "SOCK0node"))) {
[17:42:41.293]                             sendCondition <<- function(cond) {
[17:42:41.293]                               data <- list(type = "VALUE", value = cond, 
[17:42:41.293]                                 success = TRUE)
[17:42:41.293]                               parallel_sendData(master, data)
[17:42:41.293]                             }
[17:42:41.293]                             return(sendCondition)
[17:42:41.293]                           }
[17:42:41.293]                         }
[17:42:41.293]                         frame <- frame + 1L
[17:42:41.293]                         envir <- sys.frame(frame)
[17:42:41.293]                       }
[17:42:41.293]                     }
[17:42:41.293]                     sendCondition <<- function(cond) NULL
[17:42:41.293]                   }
[17:42:41.293]                 })
[17:42:41.293]                 withCallingHandlers({
[17:42:41.293]                   {
[17:42:41.293]                     x[name] <- list(1)
[17:42:41.293]                     x
[17:42:41.293]                   }
[17:42:41.293]                 }, immediateCondition = function(cond) {
[17:42:41.293]                   sendCondition <- ...future.makeSendCondition()
[17:42:41.293]                   sendCondition(cond)
[17:42:41.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.293]                   {
[17:42:41.293]                     inherits <- base::inherits
[17:42:41.293]                     invokeRestart <- base::invokeRestart
[17:42:41.293]                     is.null <- base::is.null
[17:42:41.293]                     muffled <- FALSE
[17:42:41.293]                     if (inherits(cond, "message")) {
[17:42:41.293]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:41.293]                       if (muffled) 
[17:42:41.293]                         invokeRestart("muffleMessage")
[17:42:41.293]                     }
[17:42:41.293]                     else if (inherits(cond, "warning")) {
[17:42:41.293]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:41.293]                       if (muffled) 
[17:42:41.293]                         invokeRestart("muffleWarning")
[17:42:41.293]                     }
[17:42:41.293]                     else if (inherits(cond, "condition")) {
[17:42:41.293]                       if (!is.null(pattern)) {
[17:42:41.293]                         computeRestarts <- base::computeRestarts
[17:42:41.293]                         grepl <- base::grepl
[17:42:41.293]                         restarts <- computeRestarts(cond)
[17:42:41.293]                         for (restart in restarts) {
[17:42:41.293]                           name <- restart$name
[17:42:41.293]                           if (is.null(name)) 
[17:42:41.293]                             next
[17:42:41.293]                           if (!grepl(pattern, name)) 
[17:42:41.293]                             next
[17:42:41.293]                           invokeRestart(restart)
[17:42:41.293]                           muffled <- TRUE
[17:42:41.293]                           break
[17:42:41.293]                         }
[17:42:41.293]                       }
[17:42:41.293]                     }
[17:42:41.293]                     invisible(muffled)
[17:42:41.293]                   }
[17:42:41.293]                   muffleCondition(cond)
[17:42:41.293]                 })
[17:42:41.293]             }))
[17:42:41.293]             future::FutureResult(value = ...future.value$value, 
[17:42:41.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:41.293]                   ...future.rng), globalenv = if (FALSE) 
[17:42:41.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:41.293]                     ...future.globalenv.names))
[17:42:41.293]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:41.293]         }, condition = base::local({
[17:42:41.293]             c <- base::c
[17:42:41.293]             inherits <- base::inherits
[17:42:41.293]             invokeRestart <- base::invokeRestart
[17:42:41.293]             length <- base::length
[17:42:41.293]             list <- base::list
[17:42:41.293]             seq.int <- base::seq.int
[17:42:41.293]             signalCondition <- base::signalCondition
[17:42:41.293]             sys.calls <- base::sys.calls
[17:42:41.293]             `[[` <- base::`[[`
[17:42:41.293]             `+` <- base::`+`
[17:42:41.293]             `<<-` <- base::`<<-`
[17:42:41.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:41.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:41.293]                   3L)]
[17:42:41.293]             }
[17:42:41.293]             function(cond) {
[17:42:41.293]                 is_error <- inherits(cond, "error")
[17:42:41.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:41.293]                   NULL)
[17:42:41.293]                 if (is_error) {
[17:42:41.293]                   sessionInformation <- function() {
[17:42:41.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:41.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:41.293]                       search = base::search(), system = base::Sys.info())
[17:42:41.293]                   }
[17:42:41.293]                   ...future.conditions[[length(...future.conditions) + 
[17:42:41.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:41.293]                     cond$call), session = sessionInformation(), 
[17:42:41.293]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:41.293]                   signalCondition(cond)
[17:42:41.293]                 }
[17:42:41.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:41.293]                 "immediateCondition"))) {
[17:42:41.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:41.293]                   ...future.conditions[[length(...future.conditions) + 
[17:42:41.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:41.293]                   if (TRUE && !signal) {
[17:42:41.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.293]                     {
[17:42:41.293]                       inherits <- base::inherits
[17:42:41.293]                       invokeRestart <- base::invokeRestart
[17:42:41.293]                       is.null <- base::is.null
[17:42:41.293]                       muffled <- FALSE
[17:42:41.293]                       if (inherits(cond, "message")) {
[17:42:41.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:41.293]                         if (muffled) 
[17:42:41.293]                           invokeRestart("muffleMessage")
[17:42:41.293]                       }
[17:42:41.293]                       else if (inherits(cond, "warning")) {
[17:42:41.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:41.293]                         if (muffled) 
[17:42:41.293]                           invokeRestart("muffleWarning")
[17:42:41.293]                       }
[17:42:41.293]                       else if (inherits(cond, "condition")) {
[17:42:41.293]                         if (!is.null(pattern)) {
[17:42:41.293]                           computeRestarts <- base::computeRestarts
[17:42:41.293]                           grepl <- base::grepl
[17:42:41.293]                           restarts <- computeRestarts(cond)
[17:42:41.293]                           for (restart in restarts) {
[17:42:41.293]                             name <- restart$name
[17:42:41.293]                             if (is.null(name)) 
[17:42:41.293]                               next
[17:42:41.293]                             if (!grepl(pattern, name)) 
[17:42:41.293]                               next
[17:42:41.293]                             invokeRestart(restart)
[17:42:41.293]                             muffled <- TRUE
[17:42:41.293]                             break
[17:42:41.293]                           }
[17:42:41.293]                         }
[17:42:41.293]                       }
[17:42:41.293]                       invisible(muffled)
[17:42:41.293]                     }
[17:42:41.293]                     muffleCondition(cond, pattern = "^muffle")
[17:42:41.293]                   }
[17:42:41.293]                 }
[17:42:41.293]                 else {
[17:42:41.293]                   if (TRUE) {
[17:42:41.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:41.293]                     {
[17:42:41.293]                       inherits <- base::inherits
[17:42:41.293]                       invokeRestart <- base::invokeRestart
[17:42:41.293]                       is.null <- base::is.null
[17:42:41.293]                       muffled <- FALSE
[17:42:41.293]                       if (inherits(cond, "message")) {
[17:42:41.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:41.293]                         if (muffled) 
[17:42:41.293]                           invokeRestart("muffleMessage")
[17:42:41.293]                       }
[17:42:41.293]                       else if (inherits(cond, "warning")) {
[17:42:41.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:41.293]                         if (muffled) 
[17:42:41.293]                           invokeRestart("muffleWarning")
[17:42:41.293]                       }
[17:42:41.293]                       else if (inherits(cond, "condition")) {
[17:42:41.293]                         if (!is.null(pattern)) {
[17:42:41.293]                           computeRestarts <- base::computeRestarts
[17:42:41.293]                           grepl <- base::grepl
[17:42:41.293]                           restarts <- computeRestarts(cond)
[17:42:41.293]                           for (restart in restarts) {
[17:42:41.293]                             name <- restart$name
[17:42:41.293]                             if (is.null(name)) 
[17:42:41.293]                               next
[17:42:41.293]                             if (!grepl(pattern, name)) 
[17:42:41.293]                               next
[17:42:41.293]                             invokeRestart(restart)
[17:42:41.293]                             muffled <- TRUE
[17:42:41.293]                             break
[17:42:41.293]                           }
[17:42:41.293]                         }
[17:42:41.293]                       }
[17:42:41.293]                       invisible(muffled)
[17:42:41.293]                     }
[17:42:41.293]                     muffleCondition(cond, pattern = "^muffle")
[17:42:41.293]                   }
[17:42:41.293]                 }
[17:42:41.293]             }
[17:42:41.293]         }))
[17:42:41.293]     }, error = function(ex) {
[17:42:41.293]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:41.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:41.293]                 ...future.rng), started = ...future.startTime, 
[17:42:41.293]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:41.293]             version = "1.8"), class = "FutureResult")
[17:42:41.293]     }, finally = {
[17:42:41.293]         if (!identical(...future.workdir, getwd())) 
[17:42:41.293]             setwd(...future.workdir)
[17:42:41.293]         {
[17:42:41.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:41.293]                 ...future.oldOptions$nwarnings <- NULL
[17:42:41.293]             }
[17:42:41.293]             base::options(...future.oldOptions)
[17:42:41.293]             if (.Platform$OS.type == "windows") {
[17:42:41.293]                 old_names <- names(...future.oldEnvVars)
[17:42:41.293]                 envs <- base::Sys.getenv()
[17:42:41.293]                 names <- names(envs)
[17:42:41.293]                 common <- intersect(names, old_names)
[17:42:41.293]                 added <- setdiff(names, old_names)
[17:42:41.293]                 removed <- setdiff(old_names, names)
[17:42:41.293]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:41.293]                   envs[common]]
[17:42:41.293]                 NAMES <- toupper(changed)
[17:42:41.293]                 args <- list()
[17:42:41.293]                 for (kk in seq_along(NAMES)) {
[17:42:41.293]                   name <- changed[[kk]]
[17:42:41.293]                   NAME <- NAMES[[kk]]
[17:42:41.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.293]                     next
[17:42:41.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:41.293]                 }
[17:42:41.293]                 NAMES <- toupper(added)
[17:42:41.293]                 for (kk in seq_along(NAMES)) {
[17:42:41.293]                   name <- added[[kk]]
[17:42:41.293]                   NAME <- NAMES[[kk]]
[17:42:41.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.293]                     next
[17:42:41.293]                   args[[name]] <- ""
[17:42:41.293]                 }
[17:42:41.293]                 NAMES <- toupper(removed)
[17:42:41.293]                 for (kk in seq_along(NAMES)) {
[17:42:41.293]                   name <- removed[[kk]]
[17:42:41.293]                   NAME <- NAMES[[kk]]
[17:42:41.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:41.293]                     next
[17:42:41.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:41.293]                 }
[17:42:41.293]                 if (length(args) > 0) 
[17:42:41.293]                   base::do.call(base::Sys.setenv, args = args)
[17:42:41.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:41.293]             }
[17:42:41.293]             else {
[17:42:41.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:41.293]             }
[17:42:41.293]             {
[17:42:41.293]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:41.293]                   0L) {
[17:42:41.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:41.293]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:41.293]                   base::options(opts)
[17:42:41.293]                 }
[17:42:41.293]                 {
[17:42:41.293]                   {
[17:42:41.293]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:41.293]                     NULL
[17:42:41.293]                   }
[17:42:41.293]                   options(future.plan = NULL)
[17:42:41.293]                   if (is.na(NA_character_)) 
[17:42:41.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:41.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:41.293]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:41.293]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:41.293]                     envir = parent.frame()) 
[17:42:41.293]                   {
[17:42:41.293]                     if (is.function(workers)) 
[17:42:41.293]                       workers <- workers()
[17:42:41.293]                     workers <- structure(as.integer(workers), 
[17:42:41.293]                       class = class(workers))
[17:42:41.293]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:41.293]                       workers >= 1)
[17:42:41.293]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:41.293]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:41.293]                     }
[17:42:41.293]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:41.293]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:41.293]                       envir = envir)
[17:42:41.293]                     if (!future$lazy) 
[17:42:41.293]                       future <- run(future)
[17:42:41.293]                     invisible(future)
[17:42:41.293]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:41.293]                 }
[17:42:41.293]             }
[17:42:41.293]         }
[17:42:41.293]     })
[17:42:41.293]     if (TRUE) {
[17:42:41.293]         base::sink(type = "output", split = FALSE)
[17:42:41.293]         if (TRUE) {
[17:42:41.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:41.293]         }
[17:42:41.293]         else {
[17:42:41.293]             ...future.result["stdout"] <- base::list(NULL)
[17:42:41.293]         }
[17:42:41.293]         base::close(...future.stdout)
[17:42:41.293]         ...future.stdout <- NULL
[17:42:41.293]     }
[17:42:41.293]     ...future.result$conditions <- ...future.conditions
[17:42:41.293]     ...future.result$finished <- base::Sys.time()
[17:42:41.293]     ...future.result
[17:42:41.293] }
[17:42:41.296] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:42:41.298] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:42:41.299] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:42:41.299] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[17:42:41.299] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[17:42:41.299] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:42:41.300] MultisessionFuture started
[17:42:41.300] - Launch lazy future ... done
[17:42:41.300] run() for ‘MultisessionFuture’ ... done
[17:42:41.300] result() for ClusterFuture ...
[17:42:41.300] receiveMessageFromWorker() for ClusterFuture ...
[17:42:41.300] - Validating connection of MultisessionFuture
[17:42:41.348] - received message: FutureResult
[17:42:41.348] - Received FutureResult
[17:42:41.348] - Erased future from FutureRegistry
[17:42:41.349] result() for ClusterFuture ...
[17:42:41.349] - result already collected: FutureResult
[17:42:41.349] result() for ClusterFuture ... done
[17:42:41.349] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:41.349] result() for ClusterFuture ... done
[17:42:41.349] result() for ClusterFuture ...
[17:42:41.349] - result already collected: FutureResult
[17:42:41.349] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[17:42:41.350] plan(): Setting new future strategy stack:
[17:42:41.350] List of future strategies:
[17:42:41.350] 1. FutureStrategy:
[17:42:41.350]    - args: function (..., envir = parent.frame())
[17:42:41.350]    - tweaked: FALSE
[17:42:41.350]    - call: future::plan(oplan)
[17:42:41.351] plan(): nbrOfWorkers() = 1
> 
