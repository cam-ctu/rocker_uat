
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:20:44.925] plan(): Setting new future strategy stack:
[13:20:44.926] List of future strategies:
[13:20:44.926] 1. sequential:
[13:20:44.926]    - args: function (..., envir = parent.frame())
[13:20:44.926]    - tweaked: FALSE
[13:20:44.926]    - call: future::plan("sequential")
[13:20:44.939] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[13:20:45.008] plan(): Setting new future strategy stack:
[13:20:45.008] List of future strategies:
[13:20:45.008] 1. sequential:
[13:20:45.008]    - args: function (..., envir = parent.frame())
[13:20:45.008]    - tweaked: FALSE
[13:20:45.008]    - call: plan(strategy)
[13:20:45.019] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.020] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.020] Searching for globals...
[13:20:45.030] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.030] Searching for globals ... DONE
[13:20:45.030] Resolving globals: TRUE
[13:20:45.030] Resolving any globals that are futures ...
[13:20:45.031] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.031] Resolving any globals that are futures ... DONE
[13:20:45.031] Resolving futures part of globals (recursively) ...
[13:20:45.032] resolve() on list ...
[13:20:45.032]  recursive: 99
[13:20:45.033]  length: 1
[13:20:45.033]  elements: ‘x’
[13:20:45.033]  length: 0 (resolved future 1)
[13:20:45.033] resolve() on list ... DONE
[13:20:45.033] - globals: [1] ‘x’
[13:20:45.033] Resolving futures part of globals (recursively) ... DONE
[13:20:45.034] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.034] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.034] - globals: [1] ‘x’
[13:20:45.034] 
[13:20:45.034] getGlobalsAndPackages() ... DONE
[13:20:45.035] run() for ‘Future’ ...
[13:20:45.035] - state: ‘created’
[13:20:45.035] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.036] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.036] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.036]   - Field: ‘label’
[13:20:45.036]   - Field: ‘local’
[13:20:45.036]   - Field: ‘owner’
[13:20:45.036]   - Field: ‘envir’
[13:20:45.036]   - Field: ‘packages’
[13:20:45.037]   - Field: ‘gc’
[13:20:45.037]   - Field: ‘conditions’
[13:20:45.037]   - Field: ‘expr’
[13:20:45.037]   - Field: ‘uuid’
[13:20:45.037]   - Field: ‘seed’
[13:20:45.037]   - Field: ‘version’
[13:20:45.037]   - Field: ‘result’
[13:20:45.037]   - Field: ‘asynchronous’
[13:20:45.037]   - Field: ‘calls’
[13:20:45.037]   - Field: ‘globals’
[13:20:45.037]   - Field: ‘stdout’
[13:20:45.038]   - Field: ‘earlySignal’
[13:20:45.038]   - Field: ‘lazy’
[13:20:45.038]   - Field: ‘state’
[13:20:45.038] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.038] - Launch lazy future ...
[13:20:45.039] Packages needed by the future expression (n = 0): <none>
[13:20:45.039] Packages needed by future strategies (n = 0): <none>
[13:20:45.040] {
[13:20:45.040]     {
[13:20:45.040]         {
[13:20:45.040]             ...future.startTime <- base::Sys.time()
[13:20:45.040]             {
[13:20:45.040]                 {
[13:20:45.040]                   {
[13:20:45.040]                     base::local({
[13:20:45.040]                       has_future <- base::requireNamespace("future", 
[13:20:45.040]                         quietly = TRUE)
[13:20:45.040]                       if (has_future) {
[13:20:45.040]                         ns <- base::getNamespace("future")
[13:20:45.040]                         version <- ns[[".package"]][["version"]]
[13:20:45.040]                         if (is.null(version)) 
[13:20:45.040]                           version <- utils::packageVersion("future")
[13:20:45.040]                       }
[13:20:45.040]                       else {
[13:20:45.040]                         version <- NULL
[13:20:45.040]                       }
[13:20:45.040]                       if (!has_future || version < "1.8.0") {
[13:20:45.040]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.040]                           "", base::R.version$version.string), 
[13:20:45.040]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.040]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.040]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.040]                             "release", "version")], collapse = " "), 
[13:20:45.040]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.040]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.040]                           info)
[13:20:45.040]                         info <- base::paste(info, collapse = "; ")
[13:20:45.040]                         if (!has_future) {
[13:20:45.040]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.040]                             info)
[13:20:45.040]                         }
[13:20:45.040]                         else {
[13:20:45.040]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.040]                             info, version)
[13:20:45.040]                         }
[13:20:45.040]                         base::stop(msg)
[13:20:45.040]                       }
[13:20:45.040]                     })
[13:20:45.040]                   }
[13:20:45.040]                   options(future.plan = NULL)
[13:20:45.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.040]                 }
[13:20:45.040]                 ...future.workdir <- getwd()
[13:20:45.040]             }
[13:20:45.040]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.040]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.040]         }
[13:20:45.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.040]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.040]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.040]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.040]             base::names(...future.oldOptions))
[13:20:45.040]     }
[13:20:45.040]     if (FALSE) {
[13:20:45.040]     }
[13:20:45.040]     else {
[13:20:45.040]         if (TRUE) {
[13:20:45.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.040]                 open = "w")
[13:20:45.040]         }
[13:20:45.040]         else {
[13:20:45.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.040]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.040]         }
[13:20:45.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.040]             base::sink(type = "output", split = FALSE)
[13:20:45.040]             base::close(...future.stdout)
[13:20:45.040]         }, add = TRUE)
[13:20:45.040]     }
[13:20:45.040]     ...future.frame <- base::sys.nframe()
[13:20:45.040]     ...future.conditions <- base::list()
[13:20:45.040]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.040]     if (FALSE) {
[13:20:45.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.040]     }
[13:20:45.040]     ...future.result <- base::tryCatch({
[13:20:45.040]         base::withCallingHandlers({
[13:20:45.040]             ...future.value <- base::withVisible(base::local({
[13:20:45.040]                 x$a <- 1
[13:20:45.040]                 x
[13:20:45.040]             }))
[13:20:45.040]             future::FutureResult(value = ...future.value$value, 
[13:20:45.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.040]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.040]                     ...future.globalenv.names))
[13:20:45.040]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.040]         }, condition = base::local({
[13:20:45.040]             c <- base::c
[13:20:45.040]             inherits <- base::inherits
[13:20:45.040]             invokeRestart <- base::invokeRestart
[13:20:45.040]             length <- base::length
[13:20:45.040]             list <- base::list
[13:20:45.040]             seq.int <- base::seq.int
[13:20:45.040]             signalCondition <- base::signalCondition
[13:20:45.040]             sys.calls <- base::sys.calls
[13:20:45.040]             `[[` <- base::`[[`
[13:20:45.040]             `+` <- base::`+`
[13:20:45.040]             `<<-` <- base::`<<-`
[13:20:45.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.040]                   3L)]
[13:20:45.040]             }
[13:20:45.040]             function(cond) {
[13:20:45.040]                 is_error <- inherits(cond, "error")
[13:20:45.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.040]                   NULL)
[13:20:45.040]                 if (is_error) {
[13:20:45.040]                   sessionInformation <- function() {
[13:20:45.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.040]                       search = base::search(), system = base::Sys.info())
[13:20:45.040]                   }
[13:20:45.040]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.040]                     cond$call), session = sessionInformation(), 
[13:20:45.040]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.040]                   signalCondition(cond)
[13:20:45.040]                 }
[13:20:45.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.040]                 "immediateCondition"))) {
[13:20:45.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.040]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.040]                   if (TRUE && !signal) {
[13:20:45.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.040]                     {
[13:20:45.040]                       inherits <- base::inherits
[13:20:45.040]                       invokeRestart <- base::invokeRestart
[13:20:45.040]                       is.null <- base::is.null
[13:20:45.040]                       muffled <- FALSE
[13:20:45.040]                       if (inherits(cond, "message")) {
[13:20:45.040]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.040]                         if (muffled) 
[13:20:45.040]                           invokeRestart("muffleMessage")
[13:20:45.040]                       }
[13:20:45.040]                       else if (inherits(cond, "warning")) {
[13:20:45.040]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.040]                         if (muffled) 
[13:20:45.040]                           invokeRestart("muffleWarning")
[13:20:45.040]                       }
[13:20:45.040]                       else if (inherits(cond, "condition")) {
[13:20:45.040]                         if (!is.null(pattern)) {
[13:20:45.040]                           computeRestarts <- base::computeRestarts
[13:20:45.040]                           grepl <- base::grepl
[13:20:45.040]                           restarts <- computeRestarts(cond)
[13:20:45.040]                           for (restart in restarts) {
[13:20:45.040]                             name <- restart$name
[13:20:45.040]                             if (is.null(name)) 
[13:20:45.040]                               next
[13:20:45.040]                             if (!grepl(pattern, name)) 
[13:20:45.040]                               next
[13:20:45.040]                             invokeRestart(restart)
[13:20:45.040]                             muffled <- TRUE
[13:20:45.040]                             break
[13:20:45.040]                           }
[13:20:45.040]                         }
[13:20:45.040]                       }
[13:20:45.040]                       invisible(muffled)
[13:20:45.040]                     }
[13:20:45.040]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.040]                   }
[13:20:45.040]                 }
[13:20:45.040]                 else {
[13:20:45.040]                   if (TRUE) {
[13:20:45.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.040]                     {
[13:20:45.040]                       inherits <- base::inherits
[13:20:45.040]                       invokeRestart <- base::invokeRestart
[13:20:45.040]                       is.null <- base::is.null
[13:20:45.040]                       muffled <- FALSE
[13:20:45.040]                       if (inherits(cond, "message")) {
[13:20:45.040]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.040]                         if (muffled) 
[13:20:45.040]                           invokeRestart("muffleMessage")
[13:20:45.040]                       }
[13:20:45.040]                       else if (inherits(cond, "warning")) {
[13:20:45.040]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.040]                         if (muffled) 
[13:20:45.040]                           invokeRestart("muffleWarning")
[13:20:45.040]                       }
[13:20:45.040]                       else if (inherits(cond, "condition")) {
[13:20:45.040]                         if (!is.null(pattern)) {
[13:20:45.040]                           computeRestarts <- base::computeRestarts
[13:20:45.040]                           grepl <- base::grepl
[13:20:45.040]                           restarts <- computeRestarts(cond)
[13:20:45.040]                           for (restart in restarts) {
[13:20:45.040]                             name <- restart$name
[13:20:45.040]                             if (is.null(name)) 
[13:20:45.040]                               next
[13:20:45.040]                             if (!grepl(pattern, name)) 
[13:20:45.040]                               next
[13:20:45.040]                             invokeRestart(restart)
[13:20:45.040]                             muffled <- TRUE
[13:20:45.040]                             break
[13:20:45.040]                           }
[13:20:45.040]                         }
[13:20:45.040]                       }
[13:20:45.040]                       invisible(muffled)
[13:20:45.040]                     }
[13:20:45.040]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.040]                   }
[13:20:45.040]                 }
[13:20:45.040]             }
[13:20:45.040]         }))
[13:20:45.040]     }, error = function(ex) {
[13:20:45.040]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.040]                 ...future.rng), started = ...future.startTime, 
[13:20:45.040]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.040]             version = "1.8"), class = "FutureResult")
[13:20:45.040]     }, finally = {
[13:20:45.040]         if (!identical(...future.workdir, getwd())) 
[13:20:45.040]             setwd(...future.workdir)
[13:20:45.040]         {
[13:20:45.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.040]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.040]             }
[13:20:45.040]             base::options(...future.oldOptions)
[13:20:45.040]             if (.Platform$OS.type == "windows") {
[13:20:45.040]                 old_names <- names(...future.oldEnvVars)
[13:20:45.040]                 envs <- base::Sys.getenv()
[13:20:45.040]                 names <- names(envs)
[13:20:45.040]                 common <- intersect(names, old_names)
[13:20:45.040]                 added <- setdiff(names, old_names)
[13:20:45.040]                 removed <- setdiff(old_names, names)
[13:20:45.040]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.040]                   envs[common]]
[13:20:45.040]                 NAMES <- toupper(changed)
[13:20:45.040]                 args <- list()
[13:20:45.040]                 for (kk in seq_along(NAMES)) {
[13:20:45.040]                   name <- changed[[kk]]
[13:20:45.040]                   NAME <- NAMES[[kk]]
[13:20:45.040]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.040]                     next
[13:20:45.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.040]                 }
[13:20:45.040]                 NAMES <- toupper(added)
[13:20:45.040]                 for (kk in seq_along(NAMES)) {
[13:20:45.040]                   name <- added[[kk]]
[13:20:45.040]                   NAME <- NAMES[[kk]]
[13:20:45.040]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.040]                     next
[13:20:45.040]                   args[[name]] <- ""
[13:20:45.040]                 }
[13:20:45.040]                 NAMES <- toupper(removed)
[13:20:45.040]                 for (kk in seq_along(NAMES)) {
[13:20:45.040]                   name <- removed[[kk]]
[13:20:45.040]                   NAME <- NAMES[[kk]]
[13:20:45.040]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.040]                     next
[13:20:45.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.040]                 }
[13:20:45.040]                 if (length(args) > 0) 
[13:20:45.040]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.040]             }
[13:20:45.040]             else {
[13:20:45.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.040]             }
[13:20:45.040]             {
[13:20:45.040]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.040]                   0L) {
[13:20:45.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.040]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.040]                   base::options(opts)
[13:20:45.040]                 }
[13:20:45.040]                 {
[13:20:45.040]                   {
[13:20:45.040]                     NULL
[13:20:45.040]                     RNGkind("Mersenne-Twister")
[13:20:45.040]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.040]                       inherits = FALSE)
[13:20:45.040]                   }
[13:20:45.040]                   options(future.plan = NULL)
[13:20:45.040]                   if (is.na(NA_character_)) 
[13:20:45.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.040]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.040]                   {
[13:20:45.040]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.040]                     if (!future$lazy) 
[13:20:45.040]                       future <- run(future)
[13:20:45.040]                     invisible(future)
[13:20:45.040]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.040]                 }
[13:20:45.040]             }
[13:20:45.040]         }
[13:20:45.040]     })
[13:20:45.040]     if (TRUE) {
[13:20:45.040]         base::sink(type = "output", split = FALSE)
[13:20:45.040]         if (TRUE) {
[13:20:45.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.040]         }
[13:20:45.040]         else {
[13:20:45.040]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.040]         }
[13:20:45.040]         base::close(...future.stdout)
[13:20:45.040]         ...future.stdout <- NULL
[13:20:45.040]     }
[13:20:45.040]     ...future.result$conditions <- ...future.conditions
[13:20:45.040]     ...future.result$finished <- base::Sys.time()
[13:20:45.040]     ...future.result
[13:20:45.040] }
[13:20:45.042] assign_globals() ...
[13:20:45.042] List of 1
[13:20:45.042]  $ x: list()
[13:20:45.042]  - attr(*, "where")=List of 1
[13:20:45.042]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.042]  - attr(*, "resolved")= logi TRUE
[13:20:45.042]  - attr(*, "total_size")= num 0
[13:20:45.042]  - attr(*, "already-done")= logi TRUE
[13:20:45.044] - copied ‘x’ to environment
[13:20:45.044] assign_globals() ... done
[13:20:45.045] plan(): Setting new future strategy stack:
[13:20:45.045] List of future strategies:
[13:20:45.045] 1. sequential:
[13:20:45.045]    - args: function (..., envir = parent.frame())
[13:20:45.045]    - tweaked: FALSE
[13:20:45.045]    - call: NULL
[13:20:45.045] plan(): nbrOfWorkers() = 1
[13:20:45.046] plan(): Setting new future strategy stack:
[13:20:45.046] List of future strategies:
[13:20:45.046] 1. sequential:
[13:20:45.046]    - args: function (..., envir = parent.frame())
[13:20:45.046]    - tweaked: FALSE
[13:20:45.046]    - call: plan(strategy)
[13:20:45.047] plan(): nbrOfWorkers() = 1
[13:20:45.047] SequentialFuture started (and completed)
[13:20:45.047] - Launch lazy future ... done
[13:20:45.047] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.048] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.048] Searching for globals...
[13:20:45.050] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.050] Searching for globals ... DONE
[13:20:45.050] Resolving globals: TRUE
[13:20:45.050] Resolving any globals that are futures ...
[13:20:45.050] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.051] Resolving any globals that are futures ... DONE
[13:20:45.051] Resolving futures part of globals (recursively) ...
[13:20:45.051] resolve() on list ...
[13:20:45.051]  recursive: 99
[13:20:45.051]  length: 1
[13:20:45.051]  elements: ‘x’
[13:20:45.052]  length: 0 (resolved future 1)
[13:20:45.052] resolve() on list ... DONE
[13:20:45.052] - globals: [1] ‘x’
[13:20:45.052] Resolving futures part of globals (recursively) ... DONE
[13:20:45.052] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.052] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.052] - globals: [1] ‘x’
[13:20:45.053] 
[13:20:45.053] getGlobalsAndPackages() ... DONE
[13:20:45.053] run() for ‘Future’ ...
[13:20:45.053] - state: ‘created’
[13:20:45.053] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.053] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.054]   - Field: ‘label’
[13:20:45.054]   - Field: ‘local’
[13:20:45.054]   - Field: ‘owner’
[13:20:45.054]   - Field: ‘envir’
[13:20:45.054]   - Field: ‘packages’
[13:20:45.054]   - Field: ‘gc’
[13:20:45.054]   - Field: ‘conditions’
[13:20:45.054]   - Field: ‘expr’
[13:20:45.054]   - Field: ‘uuid’
[13:20:45.054]   - Field: ‘seed’
[13:20:45.054]   - Field: ‘version’
[13:20:45.055]   - Field: ‘result’
[13:20:45.055]   - Field: ‘asynchronous’
[13:20:45.055]   - Field: ‘calls’
[13:20:45.055]   - Field: ‘globals’
[13:20:45.055]   - Field: ‘stdout’
[13:20:45.055]   - Field: ‘earlySignal’
[13:20:45.055]   - Field: ‘lazy’
[13:20:45.055]   - Field: ‘state’
[13:20:45.055] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.055] - Launch lazy future ...
[13:20:45.056] Packages needed by the future expression (n = 0): <none>
[13:20:45.056] Packages needed by future strategies (n = 0): <none>
[13:20:45.056] {
[13:20:45.056]     {
[13:20:45.056]         {
[13:20:45.056]             ...future.startTime <- base::Sys.time()
[13:20:45.056]             {
[13:20:45.056]                 {
[13:20:45.056]                   {
[13:20:45.056]                     base::local({
[13:20:45.056]                       has_future <- base::requireNamespace("future", 
[13:20:45.056]                         quietly = TRUE)
[13:20:45.056]                       if (has_future) {
[13:20:45.056]                         ns <- base::getNamespace("future")
[13:20:45.056]                         version <- ns[[".package"]][["version"]]
[13:20:45.056]                         if (is.null(version)) 
[13:20:45.056]                           version <- utils::packageVersion("future")
[13:20:45.056]                       }
[13:20:45.056]                       else {
[13:20:45.056]                         version <- NULL
[13:20:45.056]                       }
[13:20:45.056]                       if (!has_future || version < "1.8.0") {
[13:20:45.056]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.056]                           "", base::R.version$version.string), 
[13:20:45.056]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.056]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.056]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.056]                             "release", "version")], collapse = " "), 
[13:20:45.056]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.056]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.056]                           info)
[13:20:45.056]                         info <- base::paste(info, collapse = "; ")
[13:20:45.056]                         if (!has_future) {
[13:20:45.056]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.056]                             info)
[13:20:45.056]                         }
[13:20:45.056]                         else {
[13:20:45.056]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.056]                             info, version)
[13:20:45.056]                         }
[13:20:45.056]                         base::stop(msg)
[13:20:45.056]                       }
[13:20:45.056]                     })
[13:20:45.056]                   }
[13:20:45.056]                   options(future.plan = NULL)
[13:20:45.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.056]                 }
[13:20:45.056]                 ...future.workdir <- getwd()
[13:20:45.056]             }
[13:20:45.056]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.056]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.056]         }
[13:20:45.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.056]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.056]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.056]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.056]             base::names(...future.oldOptions))
[13:20:45.056]     }
[13:20:45.056]     if (FALSE) {
[13:20:45.056]     }
[13:20:45.056]     else {
[13:20:45.056]         if (TRUE) {
[13:20:45.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.056]                 open = "w")
[13:20:45.056]         }
[13:20:45.056]         else {
[13:20:45.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.056]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.056]         }
[13:20:45.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.056]             base::sink(type = "output", split = FALSE)
[13:20:45.056]             base::close(...future.stdout)
[13:20:45.056]         }, add = TRUE)
[13:20:45.056]     }
[13:20:45.056]     ...future.frame <- base::sys.nframe()
[13:20:45.056]     ...future.conditions <- base::list()
[13:20:45.056]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.056]     if (FALSE) {
[13:20:45.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.056]     }
[13:20:45.056]     ...future.result <- base::tryCatch({
[13:20:45.056]         base::withCallingHandlers({
[13:20:45.056]             ...future.value <- base::withVisible(base::local({
[13:20:45.056]                 x$a <- 1
[13:20:45.056]                 x
[13:20:45.056]             }))
[13:20:45.056]             future::FutureResult(value = ...future.value$value, 
[13:20:45.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.056]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.056]                     ...future.globalenv.names))
[13:20:45.056]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.056]         }, condition = base::local({
[13:20:45.056]             c <- base::c
[13:20:45.056]             inherits <- base::inherits
[13:20:45.056]             invokeRestart <- base::invokeRestart
[13:20:45.056]             length <- base::length
[13:20:45.056]             list <- base::list
[13:20:45.056]             seq.int <- base::seq.int
[13:20:45.056]             signalCondition <- base::signalCondition
[13:20:45.056]             sys.calls <- base::sys.calls
[13:20:45.056]             `[[` <- base::`[[`
[13:20:45.056]             `+` <- base::`+`
[13:20:45.056]             `<<-` <- base::`<<-`
[13:20:45.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.056]                   3L)]
[13:20:45.056]             }
[13:20:45.056]             function(cond) {
[13:20:45.056]                 is_error <- inherits(cond, "error")
[13:20:45.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.056]                   NULL)
[13:20:45.056]                 if (is_error) {
[13:20:45.056]                   sessionInformation <- function() {
[13:20:45.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.056]                       search = base::search(), system = base::Sys.info())
[13:20:45.056]                   }
[13:20:45.056]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.056]                     cond$call), session = sessionInformation(), 
[13:20:45.056]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.056]                   signalCondition(cond)
[13:20:45.056]                 }
[13:20:45.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.056]                 "immediateCondition"))) {
[13:20:45.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.056]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.056]                   if (TRUE && !signal) {
[13:20:45.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.056]                     {
[13:20:45.056]                       inherits <- base::inherits
[13:20:45.056]                       invokeRestart <- base::invokeRestart
[13:20:45.056]                       is.null <- base::is.null
[13:20:45.056]                       muffled <- FALSE
[13:20:45.056]                       if (inherits(cond, "message")) {
[13:20:45.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.056]                         if (muffled) 
[13:20:45.056]                           invokeRestart("muffleMessage")
[13:20:45.056]                       }
[13:20:45.056]                       else if (inherits(cond, "warning")) {
[13:20:45.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.056]                         if (muffled) 
[13:20:45.056]                           invokeRestart("muffleWarning")
[13:20:45.056]                       }
[13:20:45.056]                       else if (inherits(cond, "condition")) {
[13:20:45.056]                         if (!is.null(pattern)) {
[13:20:45.056]                           computeRestarts <- base::computeRestarts
[13:20:45.056]                           grepl <- base::grepl
[13:20:45.056]                           restarts <- computeRestarts(cond)
[13:20:45.056]                           for (restart in restarts) {
[13:20:45.056]                             name <- restart$name
[13:20:45.056]                             if (is.null(name)) 
[13:20:45.056]                               next
[13:20:45.056]                             if (!grepl(pattern, name)) 
[13:20:45.056]                               next
[13:20:45.056]                             invokeRestart(restart)
[13:20:45.056]                             muffled <- TRUE
[13:20:45.056]                             break
[13:20:45.056]                           }
[13:20:45.056]                         }
[13:20:45.056]                       }
[13:20:45.056]                       invisible(muffled)
[13:20:45.056]                     }
[13:20:45.056]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.056]                   }
[13:20:45.056]                 }
[13:20:45.056]                 else {
[13:20:45.056]                   if (TRUE) {
[13:20:45.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.056]                     {
[13:20:45.056]                       inherits <- base::inherits
[13:20:45.056]                       invokeRestart <- base::invokeRestart
[13:20:45.056]                       is.null <- base::is.null
[13:20:45.056]                       muffled <- FALSE
[13:20:45.056]                       if (inherits(cond, "message")) {
[13:20:45.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.056]                         if (muffled) 
[13:20:45.056]                           invokeRestart("muffleMessage")
[13:20:45.056]                       }
[13:20:45.056]                       else if (inherits(cond, "warning")) {
[13:20:45.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.056]                         if (muffled) 
[13:20:45.056]                           invokeRestart("muffleWarning")
[13:20:45.056]                       }
[13:20:45.056]                       else if (inherits(cond, "condition")) {
[13:20:45.056]                         if (!is.null(pattern)) {
[13:20:45.056]                           computeRestarts <- base::computeRestarts
[13:20:45.056]                           grepl <- base::grepl
[13:20:45.056]                           restarts <- computeRestarts(cond)
[13:20:45.056]                           for (restart in restarts) {
[13:20:45.056]                             name <- restart$name
[13:20:45.056]                             if (is.null(name)) 
[13:20:45.056]                               next
[13:20:45.056]                             if (!grepl(pattern, name)) 
[13:20:45.056]                               next
[13:20:45.056]                             invokeRestart(restart)
[13:20:45.056]                             muffled <- TRUE
[13:20:45.056]                             break
[13:20:45.056]                           }
[13:20:45.056]                         }
[13:20:45.056]                       }
[13:20:45.056]                       invisible(muffled)
[13:20:45.056]                     }
[13:20:45.056]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.056]                   }
[13:20:45.056]                 }
[13:20:45.056]             }
[13:20:45.056]         }))
[13:20:45.056]     }, error = function(ex) {
[13:20:45.056]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.056]                 ...future.rng), started = ...future.startTime, 
[13:20:45.056]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.056]             version = "1.8"), class = "FutureResult")
[13:20:45.056]     }, finally = {
[13:20:45.056]         if (!identical(...future.workdir, getwd())) 
[13:20:45.056]             setwd(...future.workdir)
[13:20:45.056]         {
[13:20:45.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.056]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.056]             }
[13:20:45.056]             base::options(...future.oldOptions)
[13:20:45.056]             if (.Platform$OS.type == "windows") {
[13:20:45.056]                 old_names <- names(...future.oldEnvVars)
[13:20:45.056]                 envs <- base::Sys.getenv()
[13:20:45.056]                 names <- names(envs)
[13:20:45.056]                 common <- intersect(names, old_names)
[13:20:45.056]                 added <- setdiff(names, old_names)
[13:20:45.056]                 removed <- setdiff(old_names, names)
[13:20:45.056]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.056]                   envs[common]]
[13:20:45.056]                 NAMES <- toupper(changed)
[13:20:45.056]                 args <- list()
[13:20:45.056]                 for (kk in seq_along(NAMES)) {
[13:20:45.056]                   name <- changed[[kk]]
[13:20:45.056]                   NAME <- NAMES[[kk]]
[13:20:45.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.056]                     next
[13:20:45.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.056]                 }
[13:20:45.056]                 NAMES <- toupper(added)
[13:20:45.056]                 for (kk in seq_along(NAMES)) {
[13:20:45.056]                   name <- added[[kk]]
[13:20:45.056]                   NAME <- NAMES[[kk]]
[13:20:45.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.056]                     next
[13:20:45.056]                   args[[name]] <- ""
[13:20:45.056]                 }
[13:20:45.056]                 NAMES <- toupper(removed)
[13:20:45.056]                 for (kk in seq_along(NAMES)) {
[13:20:45.056]                   name <- removed[[kk]]
[13:20:45.056]                   NAME <- NAMES[[kk]]
[13:20:45.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.056]                     next
[13:20:45.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.056]                 }
[13:20:45.056]                 if (length(args) > 0) 
[13:20:45.056]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.056]             }
[13:20:45.056]             else {
[13:20:45.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.056]             }
[13:20:45.056]             {
[13:20:45.056]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.056]                   0L) {
[13:20:45.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.056]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.056]                   base::options(opts)
[13:20:45.056]                 }
[13:20:45.056]                 {
[13:20:45.056]                   {
[13:20:45.056]                     NULL
[13:20:45.056]                     RNGkind("Mersenne-Twister")
[13:20:45.056]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.056]                       inherits = FALSE)
[13:20:45.056]                   }
[13:20:45.056]                   options(future.plan = NULL)
[13:20:45.056]                   if (is.na(NA_character_)) 
[13:20:45.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.056]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.056]                   {
[13:20:45.056]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.056]                     if (!future$lazy) 
[13:20:45.056]                       future <- run(future)
[13:20:45.056]                     invisible(future)
[13:20:45.056]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.056]                 }
[13:20:45.056]             }
[13:20:45.056]         }
[13:20:45.056]     })
[13:20:45.056]     if (TRUE) {
[13:20:45.056]         base::sink(type = "output", split = FALSE)
[13:20:45.056]         if (TRUE) {
[13:20:45.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.056]         }
[13:20:45.056]         else {
[13:20:45.056]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.056]         }
[13:20:45.056]         base::close(...future.stdout)
[13:20:45.056]         ...future.stdout <- NULL
[13:20:45.056]     }
[13:20:45.056]     ...future.result$conditions <- ...future.conditions
[13:20:45.056]     ...future.result$finished <- base::Sys.time()
[13:20:45.056]     ...future.result
[13:20:45.056] }
[13:20:45.058] assign_globals() ...
[13:20:45.058] List of 1
[13:20:45.058]  $ x: list()
[13:20:45.058]  - attr(*, "where")=List of 1
[13:20:45.058]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.058]  - attr(*, "resolved")= logi TRUE
[13:20:45.058]  - attr(*, "total_size")= num 0
[13:20:45.058]  - attr(*, "already-done")= logi TRUE
[13:20:45.060] - copied ‘x’ to environment
[13:20:45.060] assign_globals() ... done
[13:20:45.060] plan(): Setting new future strategy stack:
[13:20:45.062] List of future strategies:
[13:20:45.062] 1. sequential:
[13:20:45.062]    - args: function (..., envir = parent.frame())
[13:20:45.062]    - tweaked: FALSE
[13:20:45.062]    - call: NULL
[13:20:45.063] plan(): nbrOfWorkers() = 1
[13:20:45.063] plan(): Setting new future strategy stack:
[13:20:45.063] List of future strategies:
[13:20:45.063] 1. sequential:
[13:20:45.063]    - args: function (..., envir = parent.frame())
[13:20:45.063]    - tweaked: FALSE
[13:20:45.063]    - call: plan(strategy)
[13:20:45.064] plan(): nbrOfWorkers() = 1
[13:20:45.064] SequentialFuture started (and completed)
[13:20:45.064] - Launch lazy future ... done
[13:20:45.064] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.066] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.066] Searching for globals...
[13:20:45.068] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.068] Searching for globals ... DONE
[13:20:45.068] Resolving globals: TRUE
[13:20:45.068] Resolving any globals that are futures ...
[13:20:45.068] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.068] Resolving any globals that are futures ... DONE
[13:20:45.068] Resolving futures part of globals (recursively) ...
[13:20:45.069] resolve() on list ...
[13:20:45.069]  recursive: 99
[13:20:45.069]  length: 1
[13:20:45.069]  elements: ‘x’
[13:20:45.069]  length: 0 (resolved future 1)
[13:20:45.069] resolve() on list ... DONE
[13:20:45.069] - globals: [1] ‘x’
[13:20:45.069] Resolving futures part of globals (recursively) ... DONE
[13:20:45.069] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.070] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.070] - globals: [1] ‘x’
[13:20:45.070] 
[13:20:45.070] getGlobalsAndPackages() ... DONE
[13:20:45.070] run() for ‘Future’ ...
[13:20:45.070] - state: ‘created’
[13:20:45.071] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.071] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.071] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.071]   - Field: ‘label’
[13:20:45.071]   - Field: ‘local’
[13:20:45.071]   - Field: ‘owner’
[13:20:45.071]   - Field: ‘envir’
[13:20:45.071]   - Field: ‘packages’
[13:20:45.071]   - Field: ‘gc’
[13:20:45.072]   - Field: ‘conditions’
[13:20:45.072]   - Field: ‘expr’
[13:20:45.072]   - Field: ‘uuid’
[13:20:45.072]   - Field: ‘seed’
[13:20:45.072]   - Field: ‘version’
[13:20:45.072]   - Field: ‘result’
[13:20:45.072]   - Field: ‘asynchronous’
[13:20:45.072]   - Field: ‘calls’
[13:20:45.072]   - Field: ‘globals’
[13:20:45.072]   - Field: ‘stdout’
[13:20:45.072]   - Field: ‘earlySignal’
[13:20:45.073]   - Field: ‘lazy’
[13:20:45.073]   - Field: ‘state’
[13:20:45.073] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.073] - Launch lazy future ...
[13:20:45.073] Packages needed by the future expression (n = 0): <none>
[13:20:45.073] Packages needed by future strategies (n = 0): <none>
[13:20:45.074] {
[13:20:45.074]     {
[13:20:45.074]         {
[13:20:45.074]             ...future.startTime <- base::Sys.time()
[13:20:45.074]             {
[13:20:45.074]                 {
[13:20:45.074]                   {
[13:20:45.074]                     base::local({
[13:20:45.074]                       has_future <- base::requireNamespace("future", 
[13:20:45.074]                         quietly = TRUE)
[13:20:45.074]                       if (has_future) {
[13:20:45.074]                         ns <- base::getNamespace("future")
[13:20:45.074]                         version <- ns[[".package"]][["version"]]
[13:20:45.074]                         if (is.null(version)) 
[13:20:45.074]                           version <- utils::packageVersion("future")
[13:20:45.074]                       }
[13:20:45.074]                       else {
[13:20:45.074]                         version <- NULL
[13:20:45.074]                       }
[13:20:45.074]                       if (!has_future || version < "1.8.0") {
[13:20:45.074]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.074]                           "", base::R.version$version.string), 
[13:20:45.074]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.074]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.074]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.074]                             "release", "version")], collapse = " "), 
[13:20:45.074]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.074]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.074]                           info)
[13:20:45.074]                         info <- base::paste(info, collapse = "; ")
[13:20:45.074]                         if (!has_future) {
[13:20:45.074]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.074]                             info)
[13:20:45.074]                         }
[13:20:45.074]                         else {
[13:20:45.074]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.074]                             info, version)
[13:20:45.074]                         }
[13:20:45.074]                         base::stop(msg)
[13:20:45.074]                       }
[13:20:45.074]                     })
[13:20:45.074]                   }
[13:20:45.074]                   options(future.plan = NULL)
[13:20:45.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.074]                 }
[13:20:45.074]                 ...future.workdir <- getwd()
[13:20:45.074]             }
[13:20:45.074]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.074]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.074]         }
[13:20:45.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.074]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.074]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.074]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.074]             base::names(...future.oldOptions))
[13:20:45.074]     }
[13:20:45.074]     if (FALSE) {
[13:20:45.074]     }
[13:20:45.074]     else {
[13:20:45.074]         if (TRUE) {
[13:20:45.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.074]                 open = "w")
[13:20:45.074]         }
[13:20:45.074]         else {
[13:20:45.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.074]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.074]         }
[13:20:45.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.074]             base::sink(type = "output", split = FALSE)
[13:20:45.074]             base::close(...future.stdout)
[13:20:45.074]         }, add = TRUE)
[13:20:45.074]     }
[13:20:45.074]     ...future.frame <- base::sys.nframe()
[13:20:45.074]     ...future.conditions <- base::list()
[13:20:45.074]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.074]     if (FALSE) {
[13:20:45.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.074]     }
[13:20:45.074]     ...future.result <- base::tryCatch({
[13:20:45.074]         base::withCallingHandlers({
[13:20:45.074]             ...future.value <- base::withVisible(base::local({
[13:20:45.074]                 x$a <- 1
[13:20:45.074]                 x
[13:20:45.074]             }))
[13:20:45.074]             future::FutureResult(value = ...future.value$value, 
[13:20:45.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.074]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.074]                     ...future.globalenv.names))
[13:20:45.074]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.074]         }, condition = base::local({
[13:20:45.074]             c <- base::c
[13:20:45.074]             inherits <- base::inherits
[13:20:45.074]             invokeRestart <- base::invokeRestart
[13:20:45.074]             length <- base::length
[13:20:45.074]             list <- base::list
[13:20:45.074]             seq.int <- base::seq.int
[13:20:45.074]             signalCondition <- base::signalCondition
[13:20:45.074]             sys.calls <- base::sys.calls
[13:20:45.074]             `[[` <- base::`[[`
[13:20:45.074]             `+` <- base::`+`
[13:20:45.074]             `<<-` <- base::`<<-`
[13:20:45.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.074]                   3L)]
[13:20:45.074]             }
[13:20:45.074]             function(cond) {
[13:20:45.074]                 is_error <- inherits(cond, "error")
[13:20:45.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.074]                   NULL)
[13:20:45.074]                 if (is_error) {
[13:20:45.074]                   sessionInformation <- function() {
[13:20:45.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.074]                       search = base::search(), system = base::Sys.info())
[13:20:45.074]                   }
[13:20:45.074]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.074]                     cond$call), session = sessionInformation(), 
[13:20:45.074]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.074]                   signalCondition(cond)
[13:20:45.074]                 }
[13:20:45.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.074]                 "immediateCondition"))) {
[13:20:45.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.074]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.074]                   if (TRUE && !signal) {
[13:20:45.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.074]                     {
[13:20:45.074]                       inherits <- base::inherits
[13:20:45.074]                       invokeRestart <- base::invokeRestart
[13:20:45.074]                       is.null <- base::is.null
[13:20:45.074]                       muffled <- FALSE
[13:20:45.074]                       if (inherits(cond, "message")) {
[13:20:45.074]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.074]                         if (muffled) 
[13:20:45.074]                           invokeRestart("muffleMessage")
[13:20:45.074]                       }
[13:20:45.074]                       else if (inherits(cond, "warning")) {
[13:20:45.074]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.074]                         if (muffled) 
[13:20:45.074]                           invokeRestart("muffleWarning")
[13:20:45.074]                       }
[13:20:45.074]                       else if (inherits(cond, "condition")) {
[13:20:45.074]                         if (!is.null(pattern)) {
[13:20:45.074]                           computeRestarts <- base::computeRestarts
[13:20:45.074]                           grepl <- base::grepl
[13:20:45.074]                           restarts <- computeRestarts(cond)
[13:20:45.074]                           for (restart in restarts) {
[13:20:45.074]                             name <- restart$name
[13:20:45.074]                             if (is.null(name)) 
[13:20:45.074]                               next
[13:20:45.074]                             if (!grepl(pattern, name)) 
[13:20:45.074]                               next
[13:20:45.074]                             invokeRestart(restart)
[13:20:45.074]                             muffled <- TRUE
[13:20:45.074]                             break
[13:20:45.074]                           }
[13:20:45.074]                         }
[13:20:45.074]                       }
[13:20:45.074]                       invisible(muffled)
[13:20:45.074]                     }
[13:20:45.074]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.074]                   }
[13:20:45.074]                 }
[13:20:45.074]                 else {
[13:20:45.074]                   if (TRUE) {
[13:20:45.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.074]                     {
[13:20:45.074]                       inherits <- base::inherits
[13:20:45.074]                       invokeRestart <- base::invokeRestart
[13:20:45.074]                       is.null <- base::is.null
[13:20:45.074]                       muffled <- FALSE
[13:20:45.074]                       if (inherits(cond, "message")) {
[13:20:45.074]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.074]                         if (muffled) 
[13:20:45.074]                           invokeRestart("muffleMessage")
[13:20:45.074]                       }
[13:20:45.074]                       else if (inherits(cond, "warning")) {
[13:20:45.074]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.074]                         if (muffled) 
[13:20:45.074]                           invokeRestart("muffleWarning")
[13:20:45.074]                       }
[13:20:45.074]                       else if (inherits(cond, "condition")) {
[13:20:45.074]                         if (!is.null(pattern)) {
[13:20:45.074]                           computeRestarts <- base::computeRestarts
[13:20:45.074]                           grepl <- base::grepl
[13:20:45.074]                           restarts <- computeRestarts(cond)
[13:20:45.074]                           for (restart in restarts) {
[13:20:45.074]                             name <- restart$name
[13:20:45.074]                             if (is.null(name)) 
[13:20:45.074]                               next
[13:20:45.074]                             if (!grepl(pattern, name)) 
[13:20:45.074]                               next
[13:20:45.074]                             invokeRestart(restart)
[13:20:45.074]                             muffled <- TRUE
[13:20:45.074]                             break
[13:20:45.074]                           }
[13:20:45.074]                         }
[13:20:45.074]                       }
[13:20:45.074]                       invisible(muffled)
[13:20:45.074]                     }
[13:20:45.074]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.074]                   }
[13:20:45.074]                 }
[13:20:45.074]             }
[13:20:45.074]         }))
[13:20:45.074]     }, error = function(ex) {
[13:20:45.074]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.074]                 ...future.rng), started = ...future.startTime, 
[13:20:45.074]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.074]             version = "1.8"), class = "FutureResult")
[13:20:45.074]     }, finally = {
[13:20:45.074]         if (!identical(...future.workdir, getwd())) 
[13:20:45.074]             setwd(...future.workdir)
[13:20:45.074]         {
[13:20:45.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.074]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.074]             }
[13:20:45.074]             base::options(...future.oldOptions)
[13:20:45.074]             if (.Platform$OS.type == "windows") {
[13:20:45.074]                 old_names <- names(...future.oldEnvVars)
[13:20:45.074]                 envs <- base::Sys.getenv()
[13:20:45.074]                 names <- names(envs)
[13:20:45.074]                 common <- intersect(names, old_names)
[13:20:45.074]                 added <- setdiff(names, old_names)
[13:20:45.074]                 removed <- setdiff(old_names, names)
[13:20:45.074]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.074]                   envs[common]]
[13:20:45.074]                 NAMES <- toupper(changed)
[13:20:45.074]                 args <- list()
[13:20:45.074]                 for (kk in seq_along(NAMES)) {
[13:20:45.074]                   name <- changed[[kk]]
[13:20:45.074]                   NAME <- NAMES[[kk]]
[13:20:45.074]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.074]                     next
[13:20:45.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.074]                 }
[13:20:45.074]                 NAMES <- toupper(added)
[13:20:45.074]                 for (kk in seq_along(NAMES)) {
[13:20:45.074]                   name <- added[[kk]]
[13:20:45.074]                   NAME <- NAMES[[kk]]
[13:20:45.074]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.074]                     next
[13:20:45.074]                   args[[name]] <- ""
[13:20:45.074]                 }
[13:20:45.074]                 NAMES <- toupper(removed)
[13:20:45.074]                 for (kk in seq_along(NAMES)) {
[13:20:45.074]                   name <- removed[[kk]]
[13:20:45.074]                   NAME <- NAMES[[kk]]
[13:20:45.074]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.074]                     next
[13:20:45.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.074]                 }
[13:20:45.074]                 if (length(args) > 0) 
[13:20:45.074]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.074]             }
[13:20:45.074]             else {
[13:20:45.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.074]             }
[13:20:45.074]             {
[13:20:45.074]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.074]                   0L) {
[13:20:45.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.074]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.074]                   base::options(opts)
[13:20:45.074]                 }
[13:20:45.074]                 {
[13:20:45.074]                   {
[13:20:45.074]                     NULL
[13:20:45.074]                     RNGkind("Mersenne-Twister")
[13:20:45.074]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.074]                       inherits = FALSE)
[13:20:45.074]                   }
[13:20:45.074]                   options(future.plan = NULL)
[13:20:45.074]                   if (is.na(NA_character_)) 
[13:20:45.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.074]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.074]                   {
[13:20:45.074]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.074]                     if (!future$lazy) 
[13:20:45.074]                       future <- run(future)
[13:20:45.074]                     invisible(future)
[13:20:45.074]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.074]                 }
[13:20:45.074]             }
[13:20:45.074]         }
[13:20:45.074]     })
[13:20:45.074]     if (TRUE) {
[13:20:45.074]         base::sink(type = "output", split = FALSE)
[13:20:45.074]         if (TRUE) {
[13:20:45.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.074]         }
[13:20:45.074]         else {
[13:20:45.074]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.074]         }
[13:20:45.074]         base::close(...future.stdout)
[13:20:45.074]         ...future.stdout <- NULL
[13:20:45.074]     }
[13:20:45.074]     ...future.result$conditions <- ...future.conditions
[13:20:45.074]     ...future.result$finished <- base::Sys.time()
[13:20:45.074]     ...future.result
[13:20:45.074] }
[13:20:45.075] assign_globals() ...
[13:20:45.075] List of 1
[13:20:45.075]  $ x: list()
[13:20:45.075]  - attr(*, "where")=List of 1
[13:20:45.075]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.075]  - attr(*, "resolved")= logi TRUE
[13:20:45.075]  - attr(*, "total_size")= num 0
[13:20:45.075]  - attr(*, "already-done")= logi TRUE
[13:20:45.078] - copied ‘x’ to environment
[13:20:45.078] assign_globals() ... done
[13:20:45.078] plan(): Setting new future strategy stack:
[13:20:45.078] List of future strategies:
[13:20:45.078] 1. sequential:
[13:20:45.078]    - args: function (..., envir = parent.frame())
[13:20:45.078]    - tweaked: FALSE
[13:20:45.078]    - call: NULL
[13:20:45.078] plan(): nbrOfWorkers() = 1
[13:20:45.079] plan(): Setting new future strategy stack:
[13:20:45.079] List of future strategies:
[13:20:45.079] 1. sequential:
[13:20:45.079]    - args: function (..., envir = parent.frame())
[13:20:45.079]    - tweaked: FALSE
[13:20:45.079]    - call: plan(strategy)
[13:20:45.080] plan(): nbrOfWorkers() = 1
[13:20:45.080] SequentialFuture started (and completed)
[13:20:45.080] - Launch lazy future ... done
[13:20:45.080] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.080] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.081] Searching for globals...
[13:20:45.082] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.083] Searching for globals ... DONE
[13:20:45.083] Resolving globals: TRUE
[13:20:45.083] Resolving any globals that are futures ...
[13:20:45.083] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.083] Resolving any globals that are futures ... DONE
[13:20:45.083] Resolving futures part of globals (recursively) ...
[13:20:45.083] resolve() on list ...
[13:20:45.084]  recursive: 99
[13:20:45.084]  length: 1
[13:20:45.084]  elements: ‘x’
[13:20:45.084]  length: 0 (resolved future 1)
[13:20:45.084] resolve() on list ... DONE
[13:20:45.084] - globals: [1] ‘x’
[13:20:45.084] Resolving futures part of globals (recursively) ... DONE
[13:20:45.084] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.085] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.085] - globals: [1] ‘x’
[13:20:45.085] 
[13:20:45.085] getGlobalsAndPackages() ... DONE
[13:20:45.085] run() for ‘Future’ ...
[13:20:45.085] - state: ‘created’
[13:20:45.085] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.086] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.086] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.086]   - Field: ‘label’
[13:20:45.086]   - Field: ‘local’
[13:20:45.086]   - Field: ‘owner’
[13:20:45.086]   - Field: ‘envir’
[13:20:45.086]   - Field: ‘packages’
[13:20:45.086]   - Field: ‘gc’
[13:20:45.086]   - Field: ‘conditions’
[13:20:45.087]   - Field: ‘expr’
[13:20:45.087]   - Field: ‘uuid’
[13:20:45.087]   - Field: ‘seed’
[13:20:45.087]   - Field: ‘version’
[13:20:45.087]   - Field: ‘result’
[13:20:45.087]   - Field: ‘asynchronous’
[13:20:45.087]   - Field: ‘calls’
[13:20:45.087]   - Field: ‘globals’
[13:20:45.087]   - Field: ‘stdout’
[13:20:45.087]   - Field: ‘earlySignal’
[13:20:45.087]   - Field: ‘lazy’
[13:20:45.088]   - Field: ‘state’
[13:20:45.088] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.088] - Launch lazy future ...
[13:20:45.089] Packages needed by the future expression (n = 0): <none>
[13:20:45.090] Packages needed by future strategies (n = 0): <none>
[13:20:45.090] {
[13:20:45.090]     {
[13:20:45.090]         {
[13:20:45.090]             ...future.startTime <- base::Sys.time()
[13:20:45.090]             {
[13:20:45.090]                 {
[13:20:45.090]                   {
[13:20:45.090]                     base::local({
[13:20:45.090]                       has_future <- base::requireNamespace("future", 
[13:20:45.090]                         quietly = TRUE)
[13:20:45.090]                       if (has_future) {
[13:20:45.090]                         ns <- base::getNamespace("future")
[13:20:45.090]                         version <- ns[[".package"]][["version"]]
[13:20:45.090]                         if (is.null(version)) 
[13:20:45.090]                           version <- utils::packageVersion("future")
[13:20:45.090]                       }
[13:20:45.090]                       else {
[13:20:45.090]                         version <- NULL
[13:20:45.090]                       }
[13:20:45.090]                       if (!has_future || version < "1.8.0") {
[13:20:45.090]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.090]                           "", base::R.version$version.string), 
[13:20:45.090]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.090]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.090]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.090]                             "release", "version")], collapse = " "), 
[13:20:45.090]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.090]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.090]                           info)
[13:20:45.090]                         info <- base::paste(info, collapse = "; ")
[13:20:45.090]                         if (!has_future) {
[13:20:45.090]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.090]                             info)
[13:20:45.090]                         }
[13:20:45.090]                         else {
[13:20:45.090]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.090]                             info, version)
[13:20:45.090]                         }
[13:20:45.090]                         base::stop(msg)
[13:20:45.090]                       }
[13:20:45.090]                     })
[13:20:45.090]                   }
[13:20:45.090]                   options(future.plan = NULL)
[13:20:45.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.090]                 }
[13:20:45.090]                 ...future.workdir <- getwd()
[13:20:45.090]             }
[13:20:45.090]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.090]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.090]         }
[13:20:45.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.090]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.090]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.090]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.090]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.090]             base::names(...future.oldOptions))
[13:20:45.090]     }
[13:20:45.090]     if (FALSE) {
[13:20:45.090]     }
[13:20:45.090]     else {
[13:20:45.090]         if (TRUE) {
[13:20:45.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.090]                 open = "w")
[13:20:45.090]         }
[13:20:45.090]         else {
[13:20:45.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.090]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.090]         }
[13:20:45.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.090]             base::sink(type = "output", split = FALSE)
[13:20:45.090]             base::close(...future.stdout)
[13:20:45.090]         }, add = TRUE)
[13:20:45.090]     }
[13:20:45.090]     ...future.frame <- base::sys.nframe()
[13:20:45.090]     ...future.conditions <- base::list()
[13:20:45.090]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.090]     if (FALSE) {
[13:20:45.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.090]     }
[13:20:45.090]     ...future.result <- base::tryCatch({
[13:20:45.090]         base::withCallingHandlers({
[13:20:45.090]             ...future.value <- base::withVisible(base::local({
[13:20:45.090]                 x$a <- 1
[13:20:45.090]                 x
[13:20:45.090]             }))
[13:20:45.090]             future::FutureResult(value = ...future.value$value, 
[13:20:45.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.090]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.090]                     ...future.globalenv.names))
[13:20:45.090]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.090]         }, condition = base::local({
[13:20:45.090]             c <- base::c
[13:20:45.090]             inherits <- base::inherits
[13:20:45.090]             invokeRestart <- base::invokeRestart
[13:20:45.090]             length <- base::length
[13:20:45.090]             list <- base::list
[13:20:45.090]             seq.int <- base::seq.int
[13:20:45.090]             signalCondition <- base::signalCondition
[13:20:45.090]             sys.calls <- base::sys.calls
[13:20:45.090]             `[[` <- base::`[[`
[13:20:45.090]             `+` <- base::`+`
[13:20:45.090]             `<<-` <- base::`<<-`
[13:20:45.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.090]                   3L)]
[13:20:45.090]             }
[13:20:45.090]             function(cond) {
[13:20:45.090]                 is_error <- inherits(cond, "error")
[13:20:45.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.090]                   NULL)
[13:20:45.090]                 if (is_error) {
[13:20:45.090]                   sessionInformation <- function() {
[13:20:45.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.090]                       search = base::search(), system = base::Sys.info())
[13:20:45.090]                   }
[13:20:45.090]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.090]                     cond$call), session = sessionInformation(), 
[13:20:45.090]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.090]                   signalCondition(cond)
[13:20:45.090]                 }
[13:20:45.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.090]                 "immediateCondition"))) {
[13:20:45.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.090]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.090]                   if (TRUE && !signal) {
[13:20:45.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.090]                     {
[13:20:45.090]                       inherits <- base::inherits
[13:20:45.090]                       invokeRestart <- base::invokeRestart
[13:20:45.090]                       is.null <- base::is.null
[13:20:45.090]                       muffled <- FALSE
[13:20:45.090]                       if (inherits(cond, "message")) {
[13:20:45.090]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.090]                         if (muffled) 
[13:20:45.090]                           invokeRestart("muffleMessage")
[13:20:45.090]                       }
[13:20:45.090]                       else if (inherits(cond, "warning")) {
[13:20:45.090]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.090]                         if (muffled) 
[13:20:45.090]                           invokeRestart("muffleWarning")
[13:20:45.090]                       }
[13:20:45.090]                       else if (inherits(cond, "condition")) {
[13:20:45.090]                         if (!is.null(pattern)) {
[13:20:45.090]                           computeRestarts <- base::computeRestarts
[13:20:45.090]                           grepl <- base::grepl
[13:20:45.090]                           restarts <- computeRestarts(cond)
[13:20:45.090]                           for (restart in restarts) {
[13:20:45.090]                             name <- restart$name
[13:20:45.090]                             if (is.null(name)) 
[13:20:45.090]                               next
[13:20:45.090]                             if (!grepl(pattern, name)) 
[13:20:45.090]                               next
[13:20:45.090]                             invokeRestart(restart)
[13:20:45.090]                             muffled <- TRUE
[13:20:45.090]                             break
[13:20:45.090]                           }
[13:20:45.090]                         }
[13:20:45.090]                       }
[13:20:45.090]                       invisible(muffled)
[13:20:45.090]                     }
[13:20:45.090]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.090]                   }
[13:20:45.090]                 }
[13:20:45.090]                 else {
[13:20:45.090]                   if (TRUE) {
[13:20:45.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.090]                     {
[13:20:45.090]                       inherits <- base::inherits
[13:20:45.090]                       invokeRestart <- base::invokeRestart
[13:20:45.090]                       is.null <- base::is.null
[13:20:45.090]                       muffled <- FALSE
[13:20:45.090]                       if (inherits(cond, "message")) {
[13:20:45.090]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.090]                         if (muffled) 
[13:20:45.090]                           invokeRestart("muffleMessage")
[13:20:45.090]                       }
[13:20:45.090]                       else if (inherits(cond, "warning")) {
[13:20:45.090]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.090]                         if (muffled) 
[13:20:45.090]                           invokeRestart("muffleWarning")
[13:20:45.090]                       }
[13:20:45.090]                       else if (inherits(cond, "condition")) {
[13:20:45.090]                         if (!is.null(pattern)) {
[13:20:45.090]                           computeRestarts <- base::computeRestarts
[13:20:45.090]                           grepl <- base::grepl
[13:20:45.090]                           restarts <- computeRestarts(cond)
[13:20:45.090]                           for (restart in restarts) {
[13:20:45.090]                             name <- restart$name
[13:20:45.090]                             if (is.null(name)) 
[13:20:45.090]                               next
[13:20:45.090]                             if (!grepl(pattern, name)) 
[13:20:45.090]                               next
[13:20:45.090]                             invokeRestart(restart)
[13:20:45.090]                             muffled <- TRUE
[13:20:45.090]                             break
[13:20:45.090]                           }
[13:20:45.090]                         }
[13:20:45.090]                       }
[13:20:45.090]                       invisible(muffled)
[13:20:45.090]                     }
[13:20:45.090]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.090]                   }
[13:20:45.090]                 }
[13:20:45.090]             }
[13:20:45.090]         }))
[13:20:45.090]     }, error = function(ex) {
[13:20:45.090]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.090]                 ...future.rng), started = ...future.startTime, 
[13:20:45.090]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.090]             version = "1.8"), class = "FutureResult")
[13:20:45.090]     }, finally = {
[13:20:45.090]         if (!identical(...future.workdir, getwd())) 
[13:20:45.090]             setwd(...future.workdir)
[13:20:45.090]         {
[13:20:45.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.090]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.090]             }
[13:20:45.090]             base::options(...future.oldOptions)
[13:20:45.090]             if (.Platform$OS.type == "windows") {
[13:20:45.090]                 old_names <- names(...future.oldEnvVars)
[13:20:45.090]                 envs <- base::Sys.getenv()
[13:20:45.090]                 names <- names(envs)
[13:20:45.090]                 common <- intersect(names, old_names)
[13:20:45.090]                 added <- setdiff(names, old_names)
[13:20:45.090]                 removed <- setdiff(old_names, names)
[13:20:45.090]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.090]                   envs[common]]
[13:20:45.090]                 NAMES <- toupper(changed)
[13:20:45.090]                 args <- list()
[13:20:45.090]                 for (kk in seq_along(NAMES)) {
[13:20:45.090]                   name <- changed[[kk]]
[13:20:45.090]                   NAME <- NAMES[[kk]]
[13:20:45.090]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.090]                     next
[13:20:45.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.090]                 }
[13:20:45.090]                 NAMES <- toupper(added)
[13:20:45.090]                 for (kk in seq_along(NAMES)) {
[13:20:45.090]                   name <- added[[kk]]
[13:20:45.090]                   NAME <- NAMES[[kk]]
[13:20:45.090]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.090]                     next
[13:20:45.090]                   args[[name]] <- ""
[13:20:45.090]                 }
[13:20:45.090]                 NAMES <- toupper(removed)
[13:20:45.090]                 for (kk in seq_along(NAMES)) {
[13:20:45.090]                   name <- removed[[kk]]
[13:20:45.090]                   NAME <- NAMES[[kk]]
[13:20:45.090]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.090]                     next
[13:20:45.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.090]                 }
[13:20:45.090]                 if (length(args) > 0) 
[13:20:45.090]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.090]             }
[13:20:45.090]             else {
[13:20:45.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.090]             }
[13:20:45.090]             {
[13:20:45.090]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.090]                   0L) {
[13:20:45.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.090]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.090]                   base::options(opts)
[13:20:45.090]                 }
[13:20:45.090]                 {
[13:20:45.090]                   {
[13:20:45.090]                     NULL
[13:20:45.090]                     RNGkind("Mersenne-Twister")
[13:20:45.090]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.090]                       inherits = FALSE)
[13:20:45.090]                   }
[13:20:45.090]                   options(future.plan = NULL)
[13:20:45.090]                   if (is.na(NA_character_)) 
[13:20:45.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.090]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.090]                   {
[13:20:45.090]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.090]                     if (!future$lazy) 
[13:20:45.090]                       future <- run(future)
[13:20:45.090]                     invisible(future)
[13:20:45.090]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.090]                 }
[13:20:45.090]             }
[13:20:45.090]         }
[13:20:45.090]     })
[13:20:45.090]     if (TRUE) {
[13:20:45.090]         base::sink(type = "output", split = FALSE)
[13:20:45.090]         if (TRUE) {
[13:20:45.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.090]         }
[13:20:45.090]         else {
[13:20:45.090]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.090]         }
[13:20:45.090]         base::close(...future.stdout)
[13:20:45.090]         ...future.stdout <- NULL
[13:20:45.090]     }
[13:20:45.090]     ...future.result$conditions <- ...future.conditions
[13:20:45.090]     ...future.result$finished <- base::Sys.time()
[13:20:45.090]     ...future.result
[13:20:45.090] }
[13:20:45.092] assign_globals() ...
[13:20:45.092] List of 1
[13:20:45.092]  $ x: list()
[13:20:45.092]  - attr(*, "where")=List of 1
[13:20:45.092]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.092]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.092]  - attr(*, "resolved")= logi TRUE
[13:20:45.092]  - attr(*, "total_size")= num 0
[13:20:45.092]  - attr(*, "already-done")= logi TRUE
[13:20:45.094] - copied ‘x’ to environment
[13:20:45.094] assign_globals() ... done
[13:20:45.094] plan(): Setting new future strategy stack:
[13:20:45.094] List of future strategies:
[13:20:45.094] 1. sequential:
[13:20:45.094]    - args: function (..., envir = parent.frame())
[13:20:45.094]    - tweaked: FALSE
[13:20:45.094]    - call: NULL
[13:20:45.095] plan(): nbrOfWorkers() = 1
[13:20:45.096] plan(): Setting new future strategy stack:
[13:20:45.096] List of future strategies:
[13:20:45.096] 1. sequential:
[13:20:45.096]    - args: function (..., envir = parent.frame())
[13:20:45.096]    - tweaked: FALSE
[13:20:45.096]    - call: plan(strategy)
[13:20:45.096] plan(): nbrOfWorkers() = 1
[13:20:45.096] SequentialFuture started (and completed)
[13:20:45.097] - Launch lazy future ... done
[13:20:45.097] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.097] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.098] Searching for globals...
[13:20:45.100] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:20:45.100] Searching for globals ... DONE
[13:20:45.100] Resolving globals: TRUE
[13:20:45.100] Resolving any globals that are futures ...
[13:20:45.101] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:20:45.101] Resolving any globals that are futures ... DONE
[13:20:45.101] 
[13:20:45.101] 
[13:20:45.101] getGlobalsAndPackages() ... DONE
[13:20:45.101] run() for ‘Future’ ...
[13:20:45.102] - state: ‘created’
[13:20:45.102] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.102] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.102]   - Field: ‘label’
[13:20:45.102]   - Field: ‘local’
[13:20:45.102]   - Field: ‘owner’
[13:20:45.103]   - Field: ‘envir’
[13:20:45.103]   - Field: ‘packages’
[13:20:45.103]   - Field: ‘gc’
[13:20:45.103]   - Field: ‘conditions’
[13:20:45.103]   - Field: ‘expr’
[13:20:45.103]   - Field: ‘uuid’
[13:20:45.103]   - Field: ‘seed’
[13:20:45.103]   - Field: ‘version’
[13:20:45.103]   - Field: ‘result’
[13:20:45.103]   - Field: ‘asynchronous’
[13:20:45.103]   - Field: ‘calls’
[13:20:45.104]   - Field: ‘globals’
[13:20:45.104]   - Field: ‘stdout’
[13:20:45.104]   - Field: ‘earlySignal’
[13:20:45.104]   - Field: ‘lazy’
[13:20:45.104]   - Field: ‘state’
[13:20:45.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.104] - Launch lazy future ...
[13:20:45.104] Packages needed by the future expression (n = 0): <none>
[13:20:45.104] Packages needed by future strategies (n = 0): <none>
[13:20:45.105] {
[13:20:45.105]     {
[13:20:45.105]         {
[13:20:45.105]             ...future.startTime <- base::Sys.time()
[13:20:45.105]             {
[13:20:45.105]                 {
[13:20:45.105]                   {
[13:20:45.105]                     base::local({
[13:20:45.105]                       has_future <- base::requireNamespace("future", 
[13:20:45.105]                         quietly = TRUE)
[13:20:45.105]                       if (has_future) {
[13:20:45.105]                         ns <- base::getNamespace("future")
[13:20:45.105]                         version <- ns[[".package"]][["version"]]
[13:20:45.105]                         if (is.null(version)) 
[13:20:45.105]                           version <- utils::packageVersion("future")
[13:20:45.105]                       }
[13:20:45.105]                       else {
[13:20:45.105]                         version <- NULL
[13:20:45.105]                       }
[13:20:45.105]                       if (!has_future || version < "1.8.0") {
[13:20:45.105]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.105]                           "", base::R.version$version.string), 
[13:20:45.105]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.105]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.105]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.105]                             "release", "version")], collapse = " "), 
[13:20:45.105]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.105]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.105]                           info)
[13:20:45.105]                         info <- base::paste(info, collapse = "; ")
[13:20:45.105]                         if (!has_future) {
[13:20:45.105]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.105]                             info)
[13:20:45.105]                         }
[13:20:45.105]                         else {
[13:20:45.105]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.105]                             info, version)
[13:20:45.105]                         }
[13:20:45.105]                         base::stop(msg)
[13:20:45.105]                       }
[13:20:45.105]                     })
[13:20:45.105]                   }
[13:20:45.105]                   options(future.plan = NULL)
[13:20:45.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.105]                 }
[13:20:45.105]                 ...future.workdir <- getwd()
[13:20:45.105]             }
[13:20:45.105]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.105]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.105]         }
[13:20:45.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.105]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.105]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.105]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.105]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.105]             base::names(...future.oldOptions))
[13:20:45.105]     }
[13:20:45.105]     if (FALSE) {
[13:20:45.105]     }
[13:20:45.105]     else {
[13:20:45.105]         if (TRUE) {
[13:20:45.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.105]                 open = "w")
[13:20:45.105]         }
[13:20:45.105]         else {
[13:20:45.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.105]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.105]         }
[13:20:45.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.105]             base::sink(type = "output", split = FALSE)
[13:20:45.105]             base::close(...future.stdout)
[13:20:45.105]         }, add = TRUE)
[13:20:45.105]     }
[13:20:45.105]     ...future.frame <- base::sys.nframe()
[13:20:45.105]     ...future.conditions <- base::list()
[13:20:45.105]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.105]     if (FALSE) {
[13:20:45.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.105]     }
[13:20:45.105]     ...future.result <- base::tryCatch({
[13:20:45.105]         base::withCallingHandlers({
[13:20:45.105]             ...future.value <- base::withVisible(base::local({
[13:20:45.105]                 x <- list(b = 2)
[13:20:45.105]                 x$a <- 1
[13:20:45.105]                 x
[13:20:45.105]             }))
[13:20:45.105]             future::FutureResult(value = ...future.value$value, 
[13:20:45.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.105]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.105]                     ...future.globalenv.names))
[13:20:45.105]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.105]         }, condition = base::local({
[13:20:45.105]             c <- base::c
[13:20:45.105]             inherits <- base::inherits
[13:20:45.105]             invokeRestart <- base::invokeRestart
[13:20:45.105]             length <- base::length
[13:20:45.105]             list <- base::list
[13:20:45.105]             seq.int <- base::seq.int
[13:20:45.105]             signalCondition <- base::signalCondition
[13:20:45.105]             sys.calls <- base::sys.calls
[13:20:45.105]             `[[` <- base::`[[`
[13:20:45.105]             `+` <- base::`+`
[13:20:45.105]             `<<-` <- base::`<<-`
[13:20:45.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.105]                   3L)]
[13:20:45.105]             }
[13:20:45.105]             function(cond) {
[13:20:45.105]                 is_error <- inherits(cond, "error")
[13:20:45.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.105]                   NULL)
[13:20:45.105]                 if (is_error) {
[13:20:45.105]                   sessionInformation <- function() {
[13:20:45.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.105]                       search = base::search(), system = base::Sys.info())
[13:20:45.105]                   }
[13:20:45.105]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.105]                     cond$call), session = sessionInformation(), 
[13:20:45.105]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.105]                   signalCondition(cond)
[13:20:45.105]                 }
[13:20:45.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.105]                 "immediateCondition"))) {
[13:20:45.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.105]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.105]                   if (TRUE && !signal) {
[13:20:45.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.105]                     {
[13:20:45.105]                       inherits <- base::inherits
[13:20:45.105]                       invokeRestart <- base::invokeRestart
[13:20:45.105]                       is.null <- base::is.null
[13:20:45.105]                       muffled <- FALSE
[13:20:45.105]                       if (inherits(cond, "message")) {
[13:20:45.105]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.105]                         if (muffled) 
[13:20:45.105]                           invokeRestart("muffleMessage")
[13:20:45.105]                       }
[13:20:45.105]                       else if (inherits(cond, "warning")) {
[13:20:45.105]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.105]                         if (muffled) 
[13:20:45.105]                           invokeRestart("muffleWarning")
[13:20:45.105]                       }
[13:20:45.105]                       else if (inherits(cond, "condition")) {
[13:20:45.105]                         if (!is.null(pattern)) {
[13:20:45.105]                           computeRestarts <- base::computeRestarts
[13:20:45.105]                           grepl <- base::grepl
[13:20:45.105]                           restarts <- computeRestarts(cond)
[13:20:45.105]                           for (restart in restarts) {
[13:20:45.105]                             name <- restart$name
[13:20:45.105]                             if (is.null(name)) 
[13:20:45.105]                               next
[13:20:45.105]                             if (!grepl(pattern, name)) 
[13:20:45.105]                               next
[13:20:45.105]                             invokeRestart(restart)
[13:20:45.105]                             muffled <- TRUE
[13:20:45.105]                             break
[13:20:45.105]                           }
[13:20:45.105]                         }
[13:20:45.105]                       }
[13:20:45.105]                       invisible(muffled)
[13:20:45.105]                     }
[13:20:45.105]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.105]                   }
[13:20:45.105]                 }
[13:20:45.105]                 else {
[13:20:45.105]                   if (TRUE) {
[13:20:45.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.105]                     {
[13:20:45.105]                       inherits <- base::inherits
[13:20:45.105]                       invokeRestart <- base::invokeRestart
[13:20:45.105]                       is.null <- base::is.null
[13:20:45.105]                       muffled <- FALSE
[13:20:45.105]                       if (inherits(cond, "message")) {
[13:20:45.105]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.105]                         if (muffled) 
[13:20:45.105]                           invokeRestart("muffleMessage")
[13:20:45.105]                       }
[13:20:45.105]                       else if (inherits(cond, "warning")) {
[13:20:45.105]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.105]                         if (muffled) 
[13:20:45.105]                           invokeRestart("muffleWarning")
[13:20:45.105]                       }
[13:20:45.105]                       else if (inherits(cond, "condition")) {
[13:20:45.105]                         if (!is.null(pattern)) {
[13:20:45.105]                           computeRestarts <- base::computeRestarts
[13:20:45.105]                           grepl <- base::grepl
[13:20:45.105]                           restarts <- computeRestarts(cond)
[13:20:45.105]                           for (restart in restarts) {
[13:20:45.105]                             name <- restart$name
[13:20:45.105]                             if (is.null(name)) 
[13:20:45.105]                               next
[13:20:45.105]                             if (!grepl(pattern, name)) 
[13:20:45.105]                               next
[13:20:45.105]                             invokeRestart(restart)
[13:20:45.105]                             muffled <- TRUE
[13:20:45.105]                             break
[13:20:45.105]                           }
[13:20:45.105]                         }
[13:20:45.105]                       }
[13:20:45.105]                       invisible(muffled)
[13:20:45.105]                     }
[13:20:45.105]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.105]                   }
[13:20:45.105]                 }
[13:20:45.105]             }
[13:20:45.105]         }))
[13:20:45.105]     }, error = function(ex) {
[13:20:45.105]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.105]                 ...future.rng), started = ...future.startTime, 
[13:20:45.105]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.105]             version = "1.8"), class = "FutureResult")
[13:20:45.105]     }, finally = {
[13:20:45.105]         if (!identical(...future.workdir, getwd())) 
[13:20:45.105]             setwd(...future.workdir)
[13:20:45.105]         {
[13:20:45.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.105]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.105]             }
[13:20:45.105]             base::options(...future.oldOptions)
[13:20:45.105]             if (.Platform$OS.type == "windows") {
[13:20:45.105]                 old_names <- names(...future.oldEnvVars)
[13:20:45.105]                 envs <- base::Sys.getenv()
[13:20:45.105]                 names <- names(envs)
[13:20:45.105]                 common <- intersect(names, old_names)
[13:20:45.105]                 added <- setdiff(names, old_names)
[13:20:45.105]                 removed <- setdiff(old_names, names)
[13:20:45.105]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.105]                   envs[common]]
[13:20:45.105]                 NAMES <- toupper(changed)
[13:20:45.105]                 args <- list()
[13:20:45.105]                 for (kk in seq_along(NAMES)) {
[13:20:45.105]                   name <- changed[[kk]]
[13:20:45.105]                   NAME <- NAMES[[kk]]
[13:20:45.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.105]                     next
[13:20:45.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.105]                 }
[13:20:45.105]                 NAMES <- toupper(added)
[13:20:45.105]                 for (kk in seq_along(NAMES)) {
[13:20:45.105]                   name <- added[[kk]]
[13:20:45.105]                   NAME <- NAMES[[kk]]
[13:20:45.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.105]                     next
[13:20:45.105]                   args[[name]] <- ""
[13:20:45.105]                 }
[13:20:45.105]                 NAMES <- toupper(removed)
[13:20:45.105]                 for (kk in seq_along(NAMES)) {
[13:20:45.105]                   name <- removed[[kk]]
[13:20:45.105]                   NAME <- NAMES[[kk]]
[13:20:45.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.105]                     next
[13:20:45.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.105]                 }
[13:20:45.105]                 if (length(args) > 0) 
[13:20:45.105]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.105]             }
[13:20:45.105]             else {
[13:20:45.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.105]             }
[13:20:45.105]             {
[13:20:45.105]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.105]                   0L) {
[13:20:45.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.105]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.105]                   base::options(opts)
[13:20:45.105]                 }
[13:20:45.105]                 {
[13:20:45.105]                   {
[13:20:45.105]                     NULL
[13:20:45.105]                     RNGkind("Mersenne-Twister")
[13:20:45.105]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.105]                       inherits = FALSE)
[13:20:45.105]                   }
[13:20:45.105]                   options(future.plan = NULL)
[13:20:45.105]                   if (is.na(NA_character_)) 
[13:20:45.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.105]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.105]                   {
[13:20:45.105]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.105]                     if (!future$lazy) 
[13:20:45.105]                       future <- run(future)
[13:20:45.105]                     invisible(future)
[13:20:45.105]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.105]                 }
[13:20:45.105]             }
[13:20:45.105]         }
[13:20:45.105]     })
[13:20:45.105]     if (TRUE) {
[13:20:45.105]         base::sink(type = "output", split = FALSE)
[13:20:45.105]         if (TRUE) {
[13:20:45.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.105]         }
[13:20:45.105]         else {
[13:20:45.105]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.105]         }
[13:20:45.105]         base::close(...future.stdout)
[13:20:45.105]         ...future.stdout <- NULL
[13:20:45.105]     }
[13:20:45.105]     ...future.result$conditions <- ...future.conditions
[13:20:45.105]     ...future.result$finished <- base::Sys.time()
[13:20:45.105]     ...future.result
[13:20:45.105] }
[13:20:45.107] plan(): Setting new future strategy stack:
[13:20:45.107] List of future strategies:
[13:20:45.107] 1. sequential:
[13:20:45.107]    - args: function (..., envir = parent.frame())
[13:20:45.107]    - tweaked: FALSE
[13:20:45.107]    - call: NULL
[13:20:45.107] plan(): nbrOfWorkers() = 1
[13:20:45.108] plan(): Setting new future strategy stack:
[13:20:45.108] List of future strategies:
[13:20:45.108] 1. sequential:
[13:20:45.108]    - args: function (..., envir = parent.frame())
[13:20:45.108]    - tweaked: FALSE
[13:20:45.108]    - call: plan(strategy)
[13:20:45.108] plan(): nbrOfWorkers() = 1
[13:20:45.108] SequentialFuture started (and completed)
[13:20:45.109] - Launch lazy future ... done
[13:20:45.109] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.109] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.109] Searching for globals...
[13:20:45.111] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.111] Searching for globals ... DONE
[13:20:45.111] Resolving globals: TRUE
[13:20:45.111] Resolving any globals that are futures ...
[13:20:45.111] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.112] Resolving any globals that are futures ... DONE
[13:20:45.112] Resolving futures part of globals (recursively) ...
[13:20:45.112] resolve() on list ...
[13:20:45.112]  recursive: 99
[13:20:45.112]  length: 1
[13:20:45.112]  elements: ‘x’
[13:20:45.113]  length: 0 (resolved future 1)
[13:20:45.113] resolve() on list ... DONE
[13:20:45.113] - globals: [1] ‘x’
[13:20:45.113] Resolving futures part of globals (recursively) ... DONE
[13:20:45.113] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.113] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.113] - globals: [1] ‘x’
[13:20:45.114] 
[13:20:45.114] getGlobalsAndPackages() ... DONE
[13:20:45.114] run() for ‘Future’ ...
[13:20:45.114] - state: ‘created’
[13:20:45.114] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.114] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.114] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.115]   - Field: ‘label’
[13:20:45.115]   - Field: ‘local’
[13:20:45.115]   - Field: ‘owner’
[13:20:45.115]   - Field: ‘envir’
[13:20:45.115]   - Field: ‘packages’
[13:20:45.115]   - Field: ‘gc’
[13:20:45.115]   - Field: ‘conditions’
[13:20:45.115]   - Field: ‘expr’
[13:20:45.115]   - Field: ‘uuid’
[13:20:45.115]   - Field: ‘seed’
[13:20:45.115]   - Field: ‘version’
[13:20:45.116]   - Field: ‘result’
[13:20:45.116]   - Field: ‘asynchronous’
[13:20:45.116]   - Field: ‘calls’
[13:20:45.116]   - Field: ‘globals’
[13:20:45.116]   - Field: ‘stdout’
[13:20:45.116]   - Field: ‘earlySignal’
[13:20:45.116]   - Field: ‘lazy’
[13:20:45.116]   - Field: ‘state’
[13:20:45.116] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.118] - Launch lazy future ...
[13:20:45.118] Packages needed by the future expression (n = 0): <none>
[13:20:45.118] Packages needed by future strategies (n = 0): <none>
[13:20:45.119] {
[13:20:45.119]     {
[13:20:45.119]         {
[13:20:45.119]             ...future.startTime <- base::Sys.time()
[13:20:45.119]             {
[13:20:45.119]                 {
[13:20:45.119]                   {
[13:20:45.119]                     base::local({
[13:20:45.119]                       has_future <- base::requireNamespace("future", 
[13:20:45.119]                         quietly = TRUE)
[13:20:45.119]                       if (has_future) {
[13:20:45.119]                         ns <- base::getNamespace("future")
[13:20:45.119]                         version <- ns[[".package"]][["version"]]
[13:20:45.119]                         if (is.null(version)) 
[13:20:45.119]                           version <- utils::packageVersion("future")
[13:20:45.119]                       }
[13:20:45.119]                       else {
[13:20:45.119]                         version <- NULL
[13:20:45.119]                       }
[13:20:45.119]                       if (!has_future || version < "1.8.0") {
[13:20:45.119]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.119]                           "", base::R.version$version.string), 
[13:20:45.119]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.119]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.119]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.119]                             "release", "version")], collapse = " "), 
[13:20:45.119]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.119]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.119]                           info)
[13:20:45.119]                         info <- base::paste(info, collapse = "; ")
[13:20:45.119]                         if (!has_future) {
[13:20:45.119]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.119]                             info)
[13:20:45.119]                         }
[13:20:45.119]                         else {
[13:20:45.119]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.119]                             info, version)
[13:20:45.119]                         }
[13:20:45.119]                         base::stop(msg)
[13:20:45.119]                       }
[13:20:45.119]                     })
[13:20:45.119]                   }
[13:20:45.119]                   options(future.plan = NULL)
[13:20:45.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.119]                 }
[13:20:45.119]                 ...future.workdir <- getwd()
[13:20:45.119]             }
[13:20:45.119]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.119]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.119]         }
[13:20:45.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.119]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.119]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.119]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.119]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.119]             base::names(...future.oldOptions))
[13:20:45.119]     }
[13:20:45.119]     if (FALSE) {
[13:20:45.119]     }
[13:20:45.119]     else {
[13:20:45.119]         if (TRUE) {
[13:20:45.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.119]                 open = "w")
[13:20:45.119]         }
[13:20:45.119]         else {
[13:20:45.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.119]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.119]         }
[13:20:45.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.119]             base::sink(type = "output", split = FALSE)
[13:20:45.119]             base::close(...future.stdout)
[13:20:45.119]         }, add = TRUE)
[13:20:45.119]     }
[13:20:45.119]     ...future.frame <- base::sys.nframe()
[13:20:45.119]     ...future.conditions <- base::list()
[13:20:45.119]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.119]     if (FALSE) {
[13:20:45.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.119]     }
[13:20:45.119]     ...future.result <- base::tryCatch({
[13:20:45.119]         base::withCallingHandlers({
[13:20:45.119]             ...future.value <- base::withVisible(base::local({
[13:20:45.119]                 x[["a"]] <- 1
[13:20:45.119]                 x
[13:20:45.119]             }))
[13:20:45.119]             future::FutureResult(value = ...future.value$value, 
[13:20:45.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.119]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.119]                     ...future.globalenv.names))
[13:20:45.119]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.119]         }, condition = base::local({
[13:20:45.119]             c <- base::c
[13:20:45.119]             inherits <- base::inherits
[13:20:45.119]             invokeRestart <- base::invokeRestart
[13:20:45.119]             length <- base::length
[13:20:45.119]             list <- base::list
[13:20:45.119]             seq.int <- base::seq.int
[13:20:45.119]             signalCondition <- base::signalCondition
[13:20:45.119]             sys.calls <- base::sys.calls
[13:20:45.119]             `[[` <- base::`[[`
[13:20:45.119]             `+` <- base::`+`
[13:20:45.119]             `<<-` <- base::`<<-`
[13:20:45.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.119]                   3L)]
[13:20:45.119]             }
[13:20:45.119]             function(cond) {
[13:20:45.119]                 is_error <- inherits(cond, "error")
[13:20:45.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.119]                   NULL)
[13:20:45.119]                 if (is_error) {
[13:20:45.119]                   sessionInformation <- function() {
[13:20:45.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.119]                       search = base::search(), system = base::Sys.info())
[13:20:45.119]                   }
[13:20:45.119]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.119]                     cond$call), session = sessionInformation(), 
[13:20:45.119]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.119]                   signalCondition(cond)
[13:20:45.119]                 }
[13:20:45.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.119]                 "immediateCondition"))) {
[13:20:45.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.119]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.119]                   if (TRUE && !signal) {
[13:20:45.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.119]                     {
[13:20:45.119]                       inherits <- base::inherits
[13:20:45.119]                       invokeRestart <- base::invokeRestart
[13:20:45.119]                       is.null <- base::is.null
[13:20:45.119]                       muffled <- FALSE
[13:20:45.119]                       if (inherits(cond, "message")) {
[13:20:45.119]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.119]                         if (muffled) 
[13:20:45.119]                           invokeRestart("muffleMessage")
[13:20:45.119]                       }
[13:20:45.119]                       else if (inherits(cond, "warning")) {
[13:20:45.119]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.119]                         if (muffled) 
[13:20:45.119]                           invokeRestart("muffleWarning")
[13:20:45.119]                       }
[13:20:45.119]                       else if (inherits(cond, "condition")) {
[13:20:45.119]                         if (!is.null(pattern)) {
[13:20:45.119]                           computeRestarts <- base::computeRestarts
[13:20:45.119]                           grepl <- base::grepl
[13:20:45.119]                           restarts <- computeRestarts(cond)
[13:20:45.119]                           for (restart in restarts) {
[13:20:45.119]                             name <- restart$name
[13:20:45.119]                             if (is.null(name)) 
[13:20:45.119]                               next
[13:20:45.119]                             if (!grepl(pattern, name)) 
[13:20:45.119]                               next
[13:20:45.119]                             invokeRestart(restart)
[13:20:45.119]                             muffled <- TRUE
[13:20:45.119]                             break
[13:20:45.119]                           }
[13:20:45.119]                         }
[13:20:45.119]                       }
[13:20:45.119]                       invisible(muffled)
[13:20:45.119]                     }
[13:20:45.119]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.119]                   }
[13:20:45.119]                 }
[13:20:45.119]                 else {
[13:20:45.119]                   if (TRUE) {
[13:20:45.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.119]                     {
[13:20:45.119]                       inherits <- base::inherits
[13:20:45.119]                       invokeRestart <- base::invokeRestart
[13:20:45.119]                       is.null <- base::is.null
[13:20:45.119]                       muffled <- FALSE
[13:20:45.119]                       if (inherits(cond, "message")) {
[13:20:45.119]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.119]                         if (muffled) 
[13:20:45.119]                           invokeRestart("muffleMessage")
[13:20:45.119]                       }
[13:20:45.119]                       else if (inherits(cond, "warning")) {
[13:20:45.119]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.119]                         if (muffled) 
[13:20:45.119]                           invokeRestart("muffleWarning")
[13:20:45.119]                       }
[13:20:45.119]                       else if (inherits(cond, "condition")) {
[13:20:45.119]                         if (!is.null(pattern)) {
[13:20:45.119]                           computeRestarts <- base::computeRestarts
[13:20:45.119]                           grepl <- base::grepl
[13:20:45.119]                           restarts <- computeRestarts(cond)
[13:20:45.119]                           for (restart in restarts) {
[13:20:45.119]                             name <- restart$name
[13:20:45.119]                             if (is.null(name)) 
[13:20:45.119]                               next
[13:20:45.119]                             if (!grepl(pattern, name)) 
[13:20:45.119]                               next
[13:20:45.119]                             invokeRestart(restart)
[13:20:45.119]                             muffled <- TRUE
[13:20:45.119]                             break
[13:20:45.119]                           }
[13:20:45.119]                         }
[13:20:45.119]                       }
[13:20:45.119]                       invisible(muffled)
[13:20:45.119]                     }
[13:20:45.119]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.119]                   }
[13:20:45.119]                 }
[13:20:45.119]             }
[13:20:45.119]         }))
[13:20:45.119]     }, error = function(ex) {
[13:20:45.119]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.119]                 ...future.rng), started = ...future.startTime, 
[13:20:45.119]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.119]             version = "1.8"), class = "FutureResult")
[13:20:45.119]     }, finally = {
[13:20:45.119]         if (!identical(...future.workdir, getwd())) 
[13:20:45.119]             setwd(...future.workdir)
[13:20:45.119]         {
[13:20:45.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.119]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.119]             }
[13:20:45.119]             base::options(...future.oldOptions)
[13:20:45.119]             if (.Platform$OS.type == "windows") {
[13:20:45.119]                 old_names <- names(...future.oldEnvVars)
[13:20:45.119]                 envs <- base::Sys.getenv()
[13:20:45.119]                 names <- names(envs)
[13:20:45.119]                 common <- intersect(names, old_names)
[13:20:45.119]                 added <- setdiff(names, old_names)
[13:20:45.119]                 removed <- setdiff(old_names, names)
[13:20:45.119]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.119]                   envs[common]]
[13:20:45.119]                 NAMES <- toupper(changed)
[13:20:45.119]                 args <- list()
[13:20:45.119]                 for (kk in seq_along(NAMES)) {
[13:20:45.119]                   name <- changed[[kk]]
[13:20:45.119]                   NAME <- NAMES[[kk]]
[13:20:45.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.119]                     next
[13:20:45.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.119]                 }
[13:20:45.119]                 NAMES <- toupper(added)
[13:20:45.119]                 for (kk in seq_along(NAMES)) {
[13:20:45.119]                   name <- added[[kk]]
[13:20:45.119]                   NAME <- NAMES[[kk]]
[13:20:45.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.119]                     next
[13:20:45.119]                   args[[name]] <- ""
[13:20:45.119]                 }
[13:20:45.119]                 NAMES <- toupper(removed)
[13:20:45.119]                 for (kk in seq_along(NAMES)) {
[13:20:45.119]                   name <- removed[[kk]]
[13:20:45.119]                   NAME <- NAMES[[kk]]
[13:20:45.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.119]                     next
[13:20:45.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.119]                 }
[13:20:45.119]                 if (length(args) > 0) 
[13:20:45.119]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.119]             }
[13:20:45.119]             else {
[13:20:45.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.119]             }
[13:20:45.119]             {
[13:20:45.119]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.119]                   0L) {
[13:20:45.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.119]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.119]                   base::options(opts)
[13:20:45.119]                 }
[13:20:45.119]                 {
[13:20:45.119]                   {
[13:20:45.119]                     NULL
[13:20:45.119]                     RNGkind("Mersenne-Twister")
[13:20:45.119]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.119]                       inherits = FALSE)
[13:20:45.119]                   }
[13:20:45.119]                   options(future.plan = NULL)
[13:20:45.119]                   if (is.na(NA_character_)) 
[13:20:45.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.119]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.119]                   {
[13:20:45.119]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.119]                     if (!future$lazy) 
[13:20:45.119]                       future <- run(future)
[13:20:45.119]                     invisible(future)
[13:20:45.119]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.119]                 }
[13:20:45.119]             }
[13:20:45.119]         }
[13:20:45.119]     })
[13:20:45.119]     if (TRUE) {
[13:20:45.119]         base::sink(type = "output", split = FALSE)
[13:20:45.119]         if (TRUE) {
[13:20:45.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.119]         }
[13:20:45.119]         else {
[13:20:45.119]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.119]         }
[13:20:45.119]         base::close(...future.stdout)
[13:20:45.119]         ...future.stdout <- NULL
[13:20:45.119]     }
[13:20:45.119]     ...future.result$conditions <- ...future.conditions
[13:20:45.119]     ...future.result$finished <- base::Sys.time()
[13:20:45.119]     ...future.result
[13:20:45.119] }
[13:20:45.120] assign_globals() ...
[13:20:45.120] List of 1
[13:20:45.120]  $ x: list()
[13:20:45.120]  - attr(*, "where")=List of 1
[13:20:45.120]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.120]  - attr(*, "resolved")= logi TRUE
[13:20:45.120]  - attr(*, "total_size")= num 0
[13:20:45.120]  - attr(*, "already-done")= logi TRUE
[13:20:45.123] - copied ‘x’ to environment
[13:20:45.123] assign_globals() ... done
[13:20:45.123] plan(): Setting new future strategy stack:
[13:20:45.123] List of future strategies:
[13:20:45.123] 1. sequential:
[13:20:45.123]    - args: function (..., envir = parent.frame())
[13:20:45.123]    - tweaked: FALSE
[13:20:45.123]    - call: NULL
[13:20:45.124] plan(): nbrOfWorkers() = 1
[13:20:45.124] plan(): Setting new future strategy stack:
[13:20:45.124] List of future strategies:
[13:20:45.124] 1. sequential:
[13:20:45.124]    - args: function (..., envir = parent.frame())
[13:20:45.124]    - tweaked: FALSE
[13:20:45.124]    - call: plan(strategy)
[13:20:45.125] plan(): nbrOfWorkers() = 1
[13:20:45.125] SequentialFuture started (and completed)
[13:20:45.125] - Launch lazy future ... done
[13:20:45.125] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.126] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.126] Searching for globals...
[13:20:45.128] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.128] Searching for globals ... DONE
[13:20:45.128] Resolving globals: TRUE
[13:20:45.128] Resolving any globals that are futures ...
[13:20:45.128] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.128] Resolving any globals that are futures ... DONE
[13:20:45.128] Resolving futures part of globals (recursively) ...
[13:20:45.129] resolve() on list ...
[13:20:45.129]  recursive: 99
[13:20:45.129]  length: 1
[13:20:45.129]  elements: ‘x’
[13:20:45.129]  length: 0 (resolved future 1)
[13:20:45.129] resolve() on list ... DONE
[13:20:45.129] - globals: [1] ‘x’
[13:20:45.129] Resolving futures part of globals (recursively) ... DONE
[13:20:45.130] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.130] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.130] - globals: [1] ‘x’
[13:20:45.130] 
[13:20:45.130] getGlobalsAndPackages() ... DONE
[13:20:45.130] run() for ‘Future’ ...
[13:20:45.130] - state: ‘created’
[13:20:45.131] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.131] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.131] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.131]   - Field: ‘label’
[13:20:45.131]   - Field: ‘local’
[13:20:45.131]   - Field: ‘owner’
[13:20:45.131]   - Field: ‘envir’
[13:20:45.131]   - Field: ‘packages’
[13:20:45.132]   - Field: ‘gc’
[13:20:45.132]   - Field: ‘conditions’
[13:20:45.132]   - Field: ‘expr’
[13:20:45.132]   - Field: ‘uuid’
[13:20:45.132]   - Field: ‘seed’
[13:20:45.132]   - Field: ‘version’
[13:20:45.132]   - Field: ‘result’
[13:20:45.132]   - Field: ‘asynchronous’
[13:20:45.132]   - Field: ‘calls’
[13:20:45.132]   - Field: ‘globals’
[13:20:45.132]   - Field: ‘stdout’
[13:20:45.133]   - Field: ‘earlySignal’
[13:20:45.133]   - Field: ‘lazy’
[13:20:45.133]   - Field: ‘state’
[13:20:45.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.133] - Launch lazy future ...
[13:20:45.133] Packages needed by the future expression (n = 0): <none>
[13:20:45.133] Packages needed by future strategies (n = 0): <none>
[13:20:45.134] {
[13:20:45.134]     {
[13:20:45.134]         {
[13:20:45.134]             ...future.startTime <- base::Sys.time()
[13:20:45.134]             {
[13:20:45.134]                 {
[13:20:45.134]                   {
[13:20:45.134]                     base::local({
[13:20:45.134]                       has_future <- base::requireNamespace("future", 
[13:20:45.134]                         quietly = TRUE)
[13:20:45.134]                       if (has_future) {
[13:20:45.134]                         ns <- base::getNamespace("future")
[13:20:45.134]                         version <- ns[[".package"]][["version"]]
[13:20:45.134]                         if (is.null(version)) 
[13:20:45.134]                           version <- utils::packageVersion("future")
[13:20:45.134]                       }
[13:20:45.134]                       else {
[13:20:45.134]                         version <- NULL
[13:20:45.134]                       }
[13:20:45.134]                       if (!has_future || version < "1.8.0") {
[13:20:45.134]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.134]                           "", base::R.version$version.string), 
[13:20:45.134]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.134]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.134]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.134]                             "release", "version")], collapse = " "), 
[13:20:45.134]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.134]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.134]                           info)
[13:20:45.134]                         info <- base::paste(info, collapse = "; ")
[13:20:45.134]                         if (!has_future) {
[13:20:45.134]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.134]                             info)
[13:20:45.134]                         }
[13:20:45.134]                         else {
[13:20:45.134]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.134]                             info, version)
[13:20:45.134]                         }
[13:20:45.134]                         base::stop(msg)
[13:20:45.134]                       }
[13:20:45.134]                     })
[13:20:45.134]                   }
[13:20:45.134]                   options(future.plan = NULL)
[13:20:45.134]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.134]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.134]                 }
[13:20:45.134]                 ...future.workdir <- getwd()
[13:20:45.134]             }
[13:20:45.134]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.134]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.134]         }
[13:20:45.134]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.134]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.134]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.134]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.134]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.134]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.134]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.134]             base::names(...future.oldOptions))
[13:20:45.134]     }
[13:20:45.134]     if (FALSE) {
[13:20:45.134]     }
[13:20:45.134]     else {
[13:20:45.134]         if (TRUE) {
[13:20:45.134]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.134]                 open = "w")
[13:20:45.134]         }
[13:20:45.134]         else {
[13:20:45.134]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.134]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.134]         }
[13:20:45.134]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.134]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.134]             base::sink(type = "output", split = FALSE)
[13:20:45.134]             base::close(...future.stdout)
[13:20:45.134]         }, add = TRUE)
[13:20:45.134]     }
[13:20:45.134]     ...future.frame <- base::sys.nframe()
[13:20:45.134]     ...future.conditions <- base::list()
[13:20:45.134]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.134]     if (FALSE) {
[13:20:45.134]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.134]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.134]     }
[13:20:45.134]     ...future.result <- base::tryCatch({
[13:20:45.134]         base::withCallingHandlers({
[13:20:45.134]             ...future.value <- base::withVisible(base::local({
[13:20:45.134]                 x[["a"]] <- 1
[13:20:45.134]                 x
[13:20:45.134]             }))
[13:20:45.134]             future::FutureResult(value = ...future.value$value, 
[13:20:45.134]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.134]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.134]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.134]                     ...future.globalenv.names))
[13:20:45.134]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.134]         }, condition = base::local({
[13:20:45.134]             c <- base::c
[13:20:45.134]             inherits <- base::inherits
[13:20:45.134]             invokeRestart <- base::invokeRestart
[13:20:45.134]             length <- base::length
[13:20:45.134]             list <- base::list
[13:20:45.134]             seq.int <- base::seq.int
[13:20:45.134]             signalCondition <- base::signalCondition
[13:20:45.134]             sys.calls <- base::sys.calls
[13:20:45.134]             `[[` <- base::`[[`
[13:20:45.134]             `+` <- base::`+`
[13:20:45.134]             `<<-` <- base::`<<-`
[13:20:45.134]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.134]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.134]                   3L)]
[13:20:45.134]             }
[13:20:45.134]             function(cond) {
[13:20:45.134]                 is_error <- inherits(cond, "error")
[13:20:45.134]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.134]                   NULL)
[13:20:45.134]                 if (is_error) {
[13:20:45.134]                   sessionInformation <- function() {
[13:20:45.134]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.134]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.134]                       search = base::search(), system = base::Sys.info())
[13:20:45.134]                   }
[13:20:45.134]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.134]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.134]                     cond$call), session = sessionInformation(), 
[13:20:45.134]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.134]                   signalCondition(cond)
[13:20:45.134]                 }
[13:20:45.134]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.134]                 "immediateCondition"))) {
[13:20:45.134]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.134]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.134]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.134]                   if (TRUE && !signal) {
[13:20:45.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.134]                     {
[13:20:45.134]                       inherits <- base::inherits
[13:20:45.134]                       invokeRestart <- base::invokeRestart
[13:20:45.134]                       is.null <- base::is.null
[13:20:45.134]                       muffled <- FALSE
[13:20:45.134]                       if (inherits(cond, "message")) {
[13:20:45.134]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.134]                         if (muffled) 
[13:20:45.134]                           invokeRestart("muffleMessage")
[13:20:45.134]                       }
[13:20:45.134]                       else if (inherits(cond, "warning")) {
[13:20:45.134]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.134]                         if (muffled) 
[13:20:45.134]                           invokeRestart("muffleWarning")
[13:20:45.134]                       }
[13:20:45.134]                       else if (inherits(cond, "condition")) {
[13:20:45.134]                         if (!is.null(pattern)) {
[13:20:45.134]                           computeRestarts <- base::computeRestarts
[13:20:45.134]                           grepl <- base::grepl
[13:20:45.134]                           restarts <- computeRestarts(cond)
[13:20:45.134]                           for (restart in restarts) {
[13:20:45.134]                             name <- restart$name
[13:20:45.134]                             if (is.null(name)) 
[13:20:45.134]                               next
[13:20:45.134]                             if (!grepl(pattern, name)) 
[13:20:45.134]                               next
[13:20:45.134]                             invokeRestart(restart)
[13:20:45.134]                             muffled <- TRUE
[13:20:45.134]                             break
[13:20:45.134]                           }
[13:20:45.134]                         }
[13:20:45.134]                       }
[13:20:45.134]                       invisible(muffled)
[13:20:45.134]                     }
[13:20:45.134]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.134]                   }
[13:20:45.134]                 }
[13:20:45.134]                 else {
[13:20:45.134]                   if (TRUE) {
[13:20:45.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.134]                     {
[13:20:45.134]                       inherits <- base::inherits
[13:20:45.134]                       invokeRestart <- base::invokeRestart
[13:20:45.134]                       is.null <- base::is.null
[13:20:45.134]                       muffled <- FALSE
[13:20:45.134]                       if (inherits(cond, "message")) {
[13:20:45.134]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.134]                         if (muffled) 
[13:20:45.134]                           invokeRestart("muffleMessage")
[13:20:45.134]                       }
[13:20:45.134]                       else if (inherits(cond, "warning")) {
[13:20:45.134]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.134]                         if (muffled) 
[13:20:45.134]                           invokeRestart("muffleWarning")
[13:20:45.134]                       }
[13:20:45.134]                       else if (inherits(cond, "condition")) {
[13:20:45.134]                         if (!is.null(pattern)) {
[13:20:45.134]                           computeRestarts <- base::computeRestarts
[13:20:45.134]                           grepl <- base::grepl
[13:20:45.134]                           restarts <- computeRestarts(cond)
[13:20:45.134]                           for (restart in restarts) {
[13:20:45.134]                             name <- restart$name
[13:20:45.134]                             if (is.null(name)) 
[13:20:45.134]                               next
[13:20:45.134]                             if (!grepl(pattern, name)) 
[13:20:45.134]                               next
[13:20:45.134]                             invokeRestart(restart)
[13:20:45.134]                             muffled <- TRUE
[13:20:45.134]                             break
[13:20:45.134]                           }
[13:20:45.134]                         }
[13:20:45.134]                       }
[13:20:45.134]                       invisible(muffled)
[13:20:45.134]                     }
[13:20:45.134]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.134]                   }
[13:20:45.134]                 }
[13:20:45.134]             }
[13:20:45.134]         }))
[13:20:45.134]     }, error = function(ex) {
[13:20:45.134]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.134]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.134]                 ...future.rng), started = ...future.startTime, 
[13:20:45.134]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.134]             version = "1.8"), class = "FutureResult")
[13:20:45.134]     }, finally = {
[13:20:45.134]         if (!identical(...future.workdir, getwd())) 
[13:20:45.134]             setwd(...future.workdir)
[13:20:45.134]         {
[13:20:45.134]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.134]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.134]             }
[13:20:45.134]             base::options(...future.oldOptions)
[13:20:45.134]             if (.Platform$OS.type == "windows") {
[13:20:45.134]                 old_names <- names(...future.oldEnvVars)
[13:20:45.134]                 envs <- base::Sys.getenv()
[13:20:45.134]                 names <- names(envs)
[13:20:45.134]                 common <- intersect(names, old_names)
[13:20:45.134]                 added <- setdiff(names, old_names)
[13:20:45.134]                 removed <- setdiff(old_names, names)
[13:20:45.134]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.134]                   envs[common]]
[13:20:45.134]                 NAMES <- toupper(changed)
[13:20:45.134]                 args <- list()
[13:20:45.134]                 for (kk in seq_along(NAMES)) {
[13:20:45.134]                   name <- changed[[kk]]
[13:20:45.134]                   NAME <- NAMES[[kk]]
[13:20:45.134]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.134]                     next
[13:20:45.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.134]                 }
[13:20:45.134]                 NAMES <- toupper(added)
[13:20:45.134]                 for (kk in seq_along(NAMES)) {
[13:20:45.134]                   name <- added[[kk]]
[13:20:45.134]                   NAME <- NAMES[[kk]]
[13:20:45.134]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.134]                     next
[13:20:45.134]                   args[[name]] <- ""
[13:20:45.134]                 }
[13:20:45.134]                 NAMES <- toupper(removed)
[13:20:45.134]                 for (kk in seq_along(NAMES)) {
[13:20:45.134]                   name <- removed[[kk]]
[13:20:45.134]                   NAME <- NAMES[[kk]]
[13:20:45.134]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.134]                     next
[13:20:45.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.134]                 }
[13:20:45.134]                 if (length(args) > 0) 
[13:20:45.134]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.134]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.134]             }
[13:20:45.134]             else {
[13:20:45.134]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.134]             }
[13:20:45.134]             {
[13:20:45.134]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.134]                   0L) {
[13:20:45.134]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.134]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.134]                   base::options(opts)
[13:20:45.134]                 }
[13:20:45.134]                 {
[13:20:45.134]                   {
[13:20:45.134]                     NULL
[13:20:45.134]                     RNGkind("Mersenne-Twister")
[13:20:45.134]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.134]                       inherits = FALSE)
[13:20:45.134]                   }
[13:20:45.134]                   options(future.plan = NULL)
[13:20:45.134]                   if (is.na(NA_character_)) 
[13:20:45.134]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.134]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.134]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.134]                   {
[13:20:45.134]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.134]                     if (!future$lazy) 
[13:20:45.134]                       future <- run(future)
[13:20:45.134]                     invisible(future)
[13:20:45.134]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.134]                 }
[13:20:45.134]             }
[13:20:45.134]         }
[13:20:45.134]     })
[13:20:45.134]     if (TRUE) {
[13:20:45.134]         base::sink(type = "output", split = FALSE)
[13:20:45.134]         if (TRUE) {
[13:20:45.134]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.134]         }
[13:20:45.134]         else {
[13:20:45.134]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.134]         }
[13:20:45.134]         base::close(...future.stdout)
[13:20:45.134]         ...future.stdout <- NULL
[13:20:45.134]     }
[13:20:45.134]     ...future.result$conditions <- ...future.conditions
[13:20:45.134]     ...future.result$finished <- base::Sys.time()
[13:20:45.134]     ...future.result
[13:20:45.134] }
[13:20:45.135] assign_globals() ...
[13:20:45.135] List of 1
[13:20:45.135]  $ x: list()
[13:20:45.135]  - attr(*, "where")=List of 1
[13:20:45.135]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.135]  - attr(*, "resolved")= logi TRUE
[13:20:45.135]  - attr(*, "total_size")= num 0
[13:20:45.135]  - attr(*, "already-done")= logi TRUE
[13:20:45.138] - copied ‘x’ to environment
[13:20:45.138] assign_globals() ... done
[13:20:45.138] plan(): Setting new future strategy stack:
[13:20:45.138] List of future strategies:
[13:20:45.138] 1. sequential:
[13:20:45.138]    - args: function (..., envir = parent.frame())
[13:20:45.138]    - tweaked: FALSE
[13:20:45.138]    - call: NULL
[13:20:45.138] plan(): nbrOfWorkers() = 1
[13:20:45.139] plan(): Setting new future strategy stack:
[13:20:45.139] List of future strategies:
[13:20:45.139] 1. sequential:
[13:20:45.139]    - args: function (..., envir = parent.frame())
[13:20:45.139]    - tweaked: FALSE
[13:20:45.139]    - call: plan(strategy)
[13:20:45.140] plan(): nbrOfWorkers() = 1
[13:20:45.140] SequentialFuture started (and completed)
[13:20:45.140] - Launch lazy future ... done
[13:20:45.140] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.140] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.141] Searching for globals...
[13:20:45.142] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.142] Searching for globals ... DONE
[13:20:45.143] Resolving globals: TRUE
[13:20:45.143] Resolving any globals that are futures ...
[13:20:45.143] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.143] Resolving any globals that are futures ... DONE
[13:20:45.143] Resolving futures part of globals (recursively) ...
[13:20:45.144] resolve() on list ...
[13:20:45.144]  recursive: 99
[13:20:45.144]  length: 1
[13:20:45.144]  elements: ‘x’
[13:20:45.144]  length: 0 (resolved future 1)
[13:20:45.144] resolve() on list ... DONE
[13:20:45.144] - globals: [1] ‘x’
[13:20:45.146] Resolving futures part of globals (recursively) ... DONE
[13:20:45.146] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.146] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.147] - globals: [1] ‘x’
[13:20:45.147] 
[13:20:45.147] getGlobalsAndPackages() ... DONE
[13:20:45.147] run() for ‘Future’ ...
[13:20:45.147] - state: ‘created’
[13:20:45.147] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.148] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.148] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.148]   - Field: ‘label’
[13:20:45.148]   - Field: ‘local’
[13:20:45.148]   - Field: ‘owner’
[13:20:45.148]   - Field: ‘envir’
[13:20:45.148]   - Field: ‘packages’
[13:20:45.148]   - Field: ‘gc’
[13:20:45.148]   - Field: ‘conditions’
[13:20:45.148]   - Field: ‘expr’
[13:20:45.149]   - Field: ‘uuid’
[13:20:45.149]   - Field: ‘seed’
[13:20:45.149]   - Field: ‘version’
[13:20:45.149]   - Field: ‘result’
[13:20:45.149]   - Field: ‘asynchronous’
[13:20:45.149]   - Field: ‘calls’
[13:20:45.149]   - Field: ‘globals’
[13:20:45.149]   - Field: ‘stdout’
[13:20:45.149]   - Field: ‘earlySignal’
[13:20:45.149]   - Field: ‘lazy’
[13:20:45.150]   - Field: ‘state’
[13:20:45.150] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.150] - Launch lazy future ...
[13:20:45.150] Packages needed by the future expression (n = 0): <none>
[13:20:45.150] Packages needed by future strategies (n = 0): <none>
[13:20:45.150] {
[13:20:45.150]     {
[13:20:45.150]         {
[13:20:45.150]             ...future.startTime <- base::Sys.time()
[13:20:45.150]             {
[13:20:45.150]                 {
[13:20:45.150]                   {
[13:20:45.150]                     base::local({
[13:20:45.150]                       has_future <- base::requireNamespace("future", 
[13:20:45.150]                         quietly = TRUE)
[13:20:45.150]                       if (has_future) {
[13:20:45.150]                         ns <- base::getNamespace("future")
[13:20:45.150]                         version <- ns[[".package"]][["version"]]
[13:20:45.150]                         if (is.null(version)) 
[13:20:45.150]                           version <- utils::packageVersion("future")
[13:20:45.150]                       }
[13:20:45.150]                       else {
[13:20:45.150]                         version <- NULL
[13:20:45.150]                       }
[13:20:45.150]                       if (!has_future || version < "1.8.0") {
[13:20:45.150]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.150]                           "", base::R.version$version.string), 
[13:20:45.150]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.150]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.150]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.150]                             "release", "version")], collapse = " "), 
[13:20:45.150]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.150]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.150]                           info)
[13:20:45.150]                         info <- base::paste(info, collapse = "; ")
[13:20:45.150]                         if (!has_future) {
[13:20:45.150]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.150]                             info)
[13:20:45.150]                         }
[13:20:45.150]                         else {
[13:20:45.150]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.150]                             info, version)
[13:20:45.150]                         }
[13:20:45.150]                         base::stop(msg)
[13:20:45.150]                       }
[13:20:45.150]                     })
[13:20:45.150]                   }
[13:20:45.150]                   options(future.plan = NULL)
[13:20:45.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.150]                 }
[13:20:45.150]                 ...future.workdir <- getwd()
[13:20:45.150]             }
[13:20:45.150]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.150]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.150]         }
[13:20:45.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.150]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.150]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.150]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.150]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.150]             base::names(...future.oldOptions))
[13:20:45.150]     }
[13:20:45.150]     if (FALSE) {
[13:20:45.150]     }
[13:20:45.150]     else {
[13:20:45.150]         if (TRUE) {
[13:20:45.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.150]                 open = "w")
[13:20:45.150]         }
[13:20:45.150]         else {
[13:20:45.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.150]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.150]         }
[13:20:45.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.150]             base::sink(type = "output", split = FALSE)
[13:20:45.150]             base::close(...future.stdout)
[13:20:45.150]         }, add = TRUE)
[13:20:45.150]     }
[13:20:45.150]     ...future.frame <- base::sys.nframe()
[13:20:45.150]     ...future.conditions <- base::list()
[13:20:45.150]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.150]     if (FALSE) {
[13:20:45.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.150]     }
[13:20:45.150]     ...future.result <- base::tryCatch({
[13:20:45.150]         base::withCallingHandlers({
[13:20:45.150]             ...future.value <- base::withVisible(base::local({
[13:20:45.150]                 x[["a"]] <- 1
[13:20:45.150]                 x
[13:20:45.150]             }))
[13:20:45.150]             future::FutureResult(value = ...future.value$value, 
[13:20:45.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.150]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.150]                     ...future.globalenv.names))
[13:20:45.150]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.150]         }, condition = base::local({
[13:20:45.150]             c <- base::c
[13:20:45.150]             inherits <- base::inherits
[13:20:45.150]             invokeRestart <- base::invokeRestart
[13:20:45.150]             length <- base::length
[13:20:45.150]             list <- base::list
[13:20:45.150]             seq.int <- base::seq.int
[13:20:45.150]             signalCondition <- base::signalCondition
[13:20:45.150]             sys.calls <- base::sys.calls
[13:20:45.150]             `[[` <- base::`[[`
[13:20:45.150]             `+` <- base::`+`
[13:20:45.150]             `<<-` <- base::`<<-`
[13:20:45.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.150]                   3L)]
[13:20:45.150]             }
[13:20:45.150]             function(cond) {
[13:20:45.150]                 is_error <- inherits(cond, "error")
[13:20:45.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.150]                   NULL)
[13:20:45.150]                 if (is_error) {
[13:20:45.150]                   sessionInformation <- function() {
[13:20:45.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.150]                       search = base::search(), system = base::Sys.info())
[13:20:45.150]                   }
[13:20:45.150]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.150]                     cond$call), session = sessionInformation(), 
[13:20:45.150]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.150]                   signalCondition(cond)
[13:20:45.150]                 }
[13:20:45.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.150]                 "immediateCondition"))) {
[13:20:45.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.150]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.150]                   if (TRUE && !signal) {
[13:20:45.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.150]                     {
[13:20:45.150]                       inherits <- base::inherits
[13:20:45.150]                       invokeRestart <- base::invokeRestart
[13:20:45.150]                       is.null <- base::is.null
[13:20:45.150]                       muffled <- FALSE
[13:20:45.150]                       if (inherits(cond, "message")) {
[13:20:45.150]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.150]                         if (muffled) 
[13:20:45.150]                           invokeRestart("muffleMessage")
[13:20:45.150]                       }
[13:20:45.150]                       else if (inherits(cond, "warning")) {
[13:20:45.150]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.150]                         if (muffled) 
[13:20:45.150]                           invokeRestart("muffleWarning")
[13:20:45.150]                       }
[13:20:45.150]                       else if (inherits(cond, "condition")) {
[13:20:45.150]                         if (!is.null(pattern)) {
[13:20:45.150]                           computeRestarts <- base::computeRestarts
[13:20:45.150]                           grepl <- base::grepl
[13:20:45.150]                           restarts <- computeRestarts(cond)
[13:20:45.150]                           for (restart in restarts) {
[13:20:45.150]                             name <- restart$name
[13:20:45.150]                             if (is.null(name)) 
[13:20:45.150]                               next
[13:20:45.150]                             if (!grepl(pattern, name)) 
[13:20:45.150]                               next
[13:20:45.150]                             invokeRestart(restart)
[13:20:45.150]                             muffled <- TRUE
[13:20:45.150]                             break
[13:20:45.150]                           }
[13:20:45.150]                         }
[13:20:45.150]                       }
[13:20:45.150]                       invisible(muffled)
[13:20:45.150]                     }
[13:20:45.150]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.150]                   }
[13:20:45.150]                 }
[13:20:45.150]                 else {
[13:20:45.150]                   if (TRUE) {
[13:20:45.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.150]                     {
[13:20:45.150]                       inherits <- base::inherits
[13:20:45.150]                       invokeRestart <- base::invokeRestart
[13:20:45.150]                       is.null <- base::is.null
[13:20:45.150]                       muffled <- FALSE
[13:20:45.150]                       if (inherits(cond, "message")) {
[13:20:45.150]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.150]                         if (muffled) 
[13:20:45.150]                           invokeRestart("muffleMessage")
[13:20:45.150]                       }
[13:20:45.150]                       else if (inherits(cond, "warning")) {
[13:20:45.150]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.150]                         if (muffled) 
[13:20:45.150]                           invokeRestart("muffleWarning")
[13:20:45.150]                       }
[13:20:45.150]                       else if (inherits(cond, "condition")) {
[13:20:45.150]                         if (!is.null(pattern)) {
[13:20:45.150]                           computeRestarts <- base::computeRestarts
[13:20:45.150]                           grepl <- base::grepl
[13:20:45.150]                           restarts <- computeRestarts(cond)
[13:20:45.150]                           for (restart in restarts) {
[13:20:45.150]                             name <- restart$name
[13:20:45.150]                             if (is.null(name)) 
[13:20:45.150]                               next
[13:20:45.150]                             if (!grepl(pattern, name)) 
[13:20:45.150]                               next
[13:20:45.150]                             invokeRestart(restart)
[13:20:45.150]                             muffled <- TRUE
[13:20:45.150]                             break
[13:20:45.150]                           }
[13:20:45.150]                         }
[13:20:45.150]                       }
[13:20:45.150]                       invisible(muffled)
[13:20:45.150]                     }
[13:20:45.150]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.150]                   }
[13:20:45.150]                 }
[13:20:45.150]             }
[13:20:45.150]         }))
[13:20:45.150]     }, error = function(ex) {
[13:20:45.150]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.150]                 ...future.rng), started = ...future.startTime, 
[13:20:45.150]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.150]             version = "1.8"), class = "FutureResult")
[13:20:45.150]     }, finally = {
[13:20:45.150]         if (!identical(...future.workdir, getwd())) 
[13:20:45.150]             setwd(...future.workdir)
[13:20:45.150]         {
[13:20:45.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.150]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.150]             }
[13:20:45.150]             base::options(...future.oldOptions)
[13:20:45.150]             if (.Platform$OS.type == "windows") {
[13:20:45.150]                 old_names <- names(...future.oldEnvVars)
[13:20:45.150]                 envs <- base::Sys.getenv()
[13:20:45.150]                 names <- names(envs)
[13:20:45.150]                 common <- intersect(names, old_names)
[13:20:45.150]                 added <- setdiff(names, old_names)
[13:20:45.150]                 removed <- setdiff(old_names, names)
[13:20:45.150]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.150]                   envs[common]]
[13:20:45.150]                 NAMES <- toupper(changed)
[13:20:45.150]                 args <- list()
[13:20:45.150]                 for (kk in seq_along(NAMES)) {
[13:20:45.150]                   name <- changed[[kk]]
[13:20:45.150]                   NAME <- NAMES[[kk]]
[13:20:45.150]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.150]                     next
[13:20:45.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.150]                 }
[13:20:45.150]                 NAMES <- toupper(added)
[13:20:45.150]                 for (kk in seq_along(NAMES)) {
[13:20:45.150]                   name <- added[[kk]]
[13:20:45.150]                   NAME <- NAMES[[kk]]
[13:20:45.150]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.150]                     next
[13:20:45.150]                   args[[name]] <- ""
[13:20:45.150]                 }
[13:20:45.150]                 NAMES <- toupper(removed)
[13:20:45.150]                 for (kk in seq_along(NAMES)) {
[13:20:45.150]                   name <- removed[[kk]]
[13:20:45.150]                   NAME <- NAMES[[kk]]
[13:20:45.150]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.150]                     next
[13:20:45.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.150]                 }
[13:20:45.150]                 if (length(args) > 0) 
[13:20:45.150]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.150]             }
[13:20:45.150]             else {
[13:20:45.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.150]             }
[13:20:45.150]             {
[13:20:45.150]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.150]                   0L) {
[13:20:45.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.150]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.150]                   base::options(opts)
[13:20:45.150]                 }
[13:20:45.150]                 {
[13:20:45.150]                   {
[13:20:45.150]                     NULL
[13:20:45.150]                     RNGkind("Mersenne-Twister")
[13:20:45.150]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.150]                       inherits = FALSE)
[13:20:45.150]                   }
[13:20:45.150]                   options(future.plan = NULL)
[13:20:45.150]                   if (is.na(NA_character_)) 
[13:20:45.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.150]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.150]                   {
[13:20:45.150]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.150]                     if (!future$lazy) 
[13:20:45.150]                       future <- run(future)
[13:20:45.150]                     invisible(future)
[13:20:45.150]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.150]                 }
[13:20:45.150]             }
[13:20:45.150]         }
[13:20:45.150]     })
[13:20:45.150]     if (TRUE) {
[13:20:45.150]         base::sink(type = "output", split = FALSE)
[13:20:45.150]         if (TRUE) {
[13:20:45.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.150]         }
[13:20:45.150]         else {
[13:20:45.150]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.150]         }
[13:20:45.150]         base::close(...future.stdout)
[13:20:45.150]         ...future.stdout <- NULL
[13:20:45.150]     }
[13:20:45.150]     ...future.result$conditions <- ...future.conditions
[13:20:45.150]     ...future.result$finished <- base::Sys.time()
[13:20:45.150]     ...future.result
[13:20:45.150] }
[13:20:45.152] assign_globals() ...
[13:20:45.152] List of 1
[13:20:45.152]  $ x: list()
[13:20:45.152]  - attr(*, "where")=List of 1
[13:20:45.152]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.152]  - attr(*, "resolved")= logi TRUE
[13:20:45.152]  - attr(*, "total_size")= num 0
[13:20:45.152]  - attr(*, "already-done")= logi TRUE
[13:20:45.155] - copied ‘x’ to environment
[13:20:45.155] assign_globals() ... done
[13:20:45.155] plan(): Setting new future strategy stack:
[13:20:45.155] List of future strategies:
[13:20:45.155] 1. sequential:
[13:20:45.155]    - args: function (..., envir = parent.frame())
[13:20:45.155]    - tweaked: FALSE
[13:20:45.155]    - call: NULL
[13:20:45.155] plan(): nbrOfWorkers() = 1
[13:20:45.156] plan(): Setting new future strategy stack:
[13:20:45.156] List of future strategies:
[13:20:45.156] 1. sequential:
[13:20:45.156]    - args: function (..., envir = parent.frame())
[13:20:45.156]    - tweaked: FALSE
[13:20:45.156]    - call: plan(strategy)
[13:20:45.157] plan(): nbrOfWorkers() = 1
[13:20:45.157] SequentialFuture started (and completed)
[13:20:45.157] - Launch lazy future ... done
[13:20:45.157] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.157] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.158] Searching for globals...
[13:20:45.160] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.160] Searching for globals ... DONE
[13:20:45.160] Resolving globals: TRUE
[13:20:45.160] Resolving any globals that are futures ...
[13:20:45.160] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.160] Resolving any globals that are futures ... DONE
[13:20:45.161] Resolving futures part of globals (recursively) ...
[13:20:45.161] resolve() on list ...
[13:20:45.161]  recursive: 99
[13:20:45.161]  length: 1
[13:20:45.161]  elements: ‘x’
[13:20:45.161]  length: 0 (resolved future 1)
[13:20:45.161] resolve() on list ... DONE
[13:20:45.161] - globals: [1] ‘x’
[13:20:45.161] Resolving futures part of globals (recursively) ... DONE
[13:20:45.162] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.162] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.162] - globals: [1] ‘x’
[13:20:45.162] 
[13:20:45.162] getGlobalsAndPackages() ... DONE
[13:20:45.163] run() for ‘Future’ ...
[13:20:45.163] - state: ‘created’
[13:20:45.163] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.163] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.163] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.163]   - Field: ‘label’
[13:20:45.163]   - Field: ‘local’
[13:20:45.163]   - Field: ‘owner’
[13:20:45.163]   - Field: ‘envir’
[13:20:45.164]   - Field: ‘packages’
[13:20:45.164]   - Field: ‘gc’
[13:20:45.164]   - Field: ‘conditions’
[13:20:45.164]   - Field: ‘expr’
[13:20:45.164]   - Field: ‘uuid’
[13:20:45.164]   - Field: ‘seed’
[13:20:45.164]   - Field: ‘version’
[13:20:45.164]   - Field: ‘result’
[13:20:45.164]   - Field: ‘asynchronous’
[13:20:45.164]   - Field: ‘calls’
[13:20:45.165]   - Field: ‘globals’
[13:20:45.165]   - Field: ‘stdout’
[13:20:45.165]   - Field: ‘earlySignal’
[13:20:45.165]   - Field: ‘lazy’
[13:20:45.165]   - Field: ‘state’
[13:20:45.165] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.165] - Launch lazy future ...
[13:20:45.165] Packages needed by the future expression (n = 0): <none>
[13:20:45.165] Packages needed by future strategies (n = 0): <none>
[13:20:45.166] {
[13:20:45.166]     {
[13:20:45.166]         {
[13:20:45.166]             ...future.startTime <- base::Sys.time()
[13:20:45.166]             {
[13:20:45.166]                 {
[13:20:45.166]                   {
[13:20:45.166]                     base::local({
[13:20:45.166]                       has_future <- base::requireNamespace("future", 
[13:20:45.166]                         quietly = TRUE)
[13:20:45.166]                       if (has_future) {
[13:20:45.166]                         ns <- base::getNamespace("future")
[13:20:45.166]                         version <- ns[[".package"]][["version"]]
[13:20:45.166]                         if (is.null(version)) 
[13:20:45.166]                           version <- utils::packageVersion("future")
[13:20:45.166]                       }
[13:20:45.166]                       else {
[13:20:45.166]                         version <- NULL
[13:20:45.166]                       }
[13:20:45.166]                       if (!has_future || version < "1.8.0") {
[13:20:45.166]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.166]                           "", base::R.version$version.string), 
[13:20:45.166]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.166]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.166]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.166]                             "release", "version")], collapse = " "), 
[13:20:45.166]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.166]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.166]                           info)
[13:20:45.166]                         info <- base::paste(info, collapse = "; ")
[13:20:45.166]                         if (!has_future) {
[13:20:45.166]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.166]                             info)
[13:20:45.166]                         }
[13:20:45.166]                         else {
[13:20:45.166]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.166]                             info, version)
[13:20:45.166]                         }
[13:20:45.166]                         base::stop(msg)
[13:20:45.166]                       }
[13:20:45.166]                     })
[13:20:45.166]                   }
[13:20:45.166]                   options(future.plan = NULL)
[13:20:45.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.166]                 }
[13:20:45.166]                 ...future.workdir <- getwd()
[13:20:45.166]             }
[13:20:45.166]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.166]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.166]         }
[13:20:45.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.166]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.166]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.166]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.166]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.166]             base::names(...future.oldOptions))
[13:20:45.166]     }
[13:20:45.166]     if (FALSE) {
[13:20:45.166]     }
[13:20:45.166]     else {
[13:20:45.166]         if (TRUE) {
[13:20:45.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.166]                 open = "w")
[13:20:45.166]         }
[13:20:45.166]         else {
[13:20:45.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.166]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.166]         }
[13:20:45.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.166]             base::sink(type = "output", split = FALSE)
[13:20:45.166]             base::close(...future.stdout)
[13:20:45.166]         }, add = TRUE)
[13:20:45.166]     }
[13:20:45.166]     ...future.frame <- base::sys.nframe()
[13:20:45.166]     ...future.conditions <- base::list()
[13:20:45.166]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.166]     if (FALSE) {
[13:20:45.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.166]     }
[13:20:45.166]     ...future.result <- base::tryCatch({
[13:20:45.166]         base::withCallingHandlers({
[13:20:45.166]             ...future.value <- base::withVisible(base::local({
[13:20:45.166]                 x["a"] <- list(1)
[13:20:45.166]                 x
[13:20:45.166]             }))
[13:20:45.166]             future::FutureResult(value = ...future.value$value, 
[13:20:45.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.166]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.166]                     ...future.globalenv.names))
[13:20:45.166]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.166]         }, condition = base::local({
[13:20:45.166]             c <- base::c
[13:20:45.166]             inherits <- base::inherits
[13:20:45.166]             invokeRestart <- base::invokeRestart
[13:20:45.166]             length <- base::length
[13:20:45.166]             list <- base::list
[13:20:45.166]             seq.int <- base::seq.int
[13:20:45.166]             signalCondition <- base::signalCondition
[13:20:45.166]             sys.calls <- base::sys.calls
[13:20:45.166]             `[[` <- base::`[[`
[13:20:45.166]             `+` <- base::`+`
[13:20:45.166]             `<<-` <- base::`<<-`
[13:20:45.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.166]                   3L)]
[13:20:45.166]             }
[13:20:45.166]             function(cond) {
[13:20:45.166]                 is_error <- inherits(cond, "error")
[13:20:45.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.166]                   NULL)
[13:20:45.166]                 if (is_error) {
[13:20:45.166]                   sessionInformation <- function() {
[13:20:45.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.166]                       search = base::search(), system = base::Sys.info())
[13:20:45.166]                   }
[13:20:45.166]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.166]                     cond$call), session = sessionInformation(), 
[13:20:45.166]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.166]                   signalCondition(cond)
[13:20:45.166]                 }
[13:20:45.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.166]                 "immediateCondition"))) {
[13:20:45.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.166]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.166]                   if (TRUE && !signal) {
[13:20:45.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.166]                     {
[13:20:45.166]                       inherits <- base::inherits
[13:20:45.166]                       invokeRestart <- base::invokeRestart
[13:20:45.166]                       is.null <- base::is.null
[13:20:45.166]                       muffled <- FALSE
[13:20:45.166]                       if (inherits(cond, "message")) {
[13:20:45.166]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.166]                         if (muffled) 
[13:20:45.166]                           invokeRestart("muffleMessage")
[13:20:45.166]                       }
[13:20:45.166]                       else if (inherits(cond, "warning")) {
[13:20:45.166]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.166]                         if (muffled) 
[13:20:45.166]                           invokeRestart("muffleWarning")
[13:20:45.166]                       }
[13:20:45.166]                       else if (inherits(cond, "condition")) {
[13:20:45.166]                         if (!is.null(pattern)) {
[13:20:45.166]                           computeRestarts <- base::computeRestarts
[13:20:45.166]                           grepl <- base::grepl
[13:20:45.166]                           restarts <- computeRestarts(cond)
[13:20:45.166]                           for (restart in restarts) {
[13:20:45.166]                             name <- restart$name
[13:20:45.166]                             if (is.null(name)) 
[13:20:45.166]                               next
[13:20:45.166]                             if (!grepl(pattern, name)) 
[13:20:45.166]                               next
[13:20:45.166]                             invokeRestart(restart)
[13:20:45.166]                             muffled <- TRUE
[13:20:45.166]                             break
[13:20:45.166]                           }
[13:20:45.166]                         }
[13:20:45.166]                       }
[13:20:45.166]                       invisible(muffled)
[13:20:45.166]                     }
[13:20:45.166]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.166]                   }
[13:20:45.166]                 }
[13:20:45.166]                 else {
[13:20:45.166]                   if (TRUE) {
[13:20:45.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.166]                     {
[13:20:45.166]                       inherits <- base::inherits
[13:20:45.166]                       invokeRestart <- base::invokeRestart
[13:20:45.166]                       is.null <- base::is.null
[13:20:45.166]                       muffled <- FALSE
[13:20:45.166]                       if (inherits(cond, "message")) {
[13:20:45.166]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.166]                         if (muffled) 
[13:20:45.166]                           invokeRestart("muffleMessage")
[13:20:45.166]                       }
[13:20:45.166]                       else if (inherits(cond, "warning")) {
[13:20:45.166]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.166]                         if (muffled) 
[13:20:45.166]                           invokeRestart("muffleWarning")
[13:20:45.166]                       }
[13:20:45.166]                       else if (inherits(cond, "condition")) {
[13:20:45.166]                         if (!is.null(pattern)) {
[13:20:45.166]                           computeRestarts <- base::computeRestarts
[13:20:45.166]                           grepl <- base::grepl
[13:20:45.166]                           restarts <- computeRestarts(cond)
[13:20:45.166]                           for (restart in restarts) {
[13:20:45.166]                             name <- restart$name
[13:20:45.166]                             if (is.null(name)) 
[13:20:45.166]                               next
[13:20:45.166]                             if (!grepl(pattern, name)) 
[13:20:45.166]                               next
[13:20:45.166]                             invokeRestart(restart)
[13:20:45.166]                             muffled <- TRUE
[13:20:45.166]                             break
[13:20:45.166]                           }
[13:20:45.166]                         }
[13:20:45.166]                       }
[13:20:45.166]                       invisible(muffled)
[13:20:45.166]                     }
[13:20:45.166]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.166]                   }
[13:20:45.166]                 }
[13:20:45.166]             }
[13:20:45.166]         }))
[13:20:45.166]     }, error = function(ex) {
[13:20:45.166]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.166]                 ...future.rng), started = ...future.startTime, 
[13:20:45.166]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.166]             version = "1.8"), class = "FutureResult")
[13:20:45.166]     }, finally = {
[13:20:45.166]         if (!identical(...future.workdir, getwd())) 
[13:20:45.166]             setwd(...future.workdir)
[13:20:45.166]         {
[13:20:45.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.166]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.166]             }
[13:20:45.166]             base::options(...future.oldOptions)
[13:20:45.166]             if (.Platform$OS.type == "windows") {
[13:20:45.166]                 old_names <- names(...future.oldEnvVars)
[13:20:45.166]                 envs <- base::Sys.getenv()
[13:20:45.166]                 names <- names(envs)
[13:20:45.166]                 common <- intersect(names, old_names)
[13:20:45.166]                 added <- setdiff(names, old_names)
[13:20:45.166]                 removed <- setdiff(old_names, names)
[13:20:45.166]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.166]                   envs[common]]
[13:20:45.166]                 NAMES <- toupper(changed)
[13:20:45.166]                 args <- list()
[13:20:45.166]                 for (kk in seq_along(NAMES)) {
[13:20:45.166]                   name <- changed[[kk]]
[13:20:45.166]                   NAME <- NAMES[[kk]]
[13:20:45.166]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.166]                     next
[13:20:45.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.166]                 }
[13:20:45.166]                 NAMES <- toupper(added)
[13:20:45.166]                 for (kk in seq_along(NAMES)) {
[13:20:45.166]                   name <- added[[kk]]
[13:20:45.166]                   NAME <- NAMES[[kk]]
[13:20:45.166]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.166]                     next
[13:20:45.166]                   args[[name]] <- ""
[13:20:45.166]                 }
[13:20:45.166]                 NAMES <- toupper(removed)
[13:20:45.166]                 for (kk in seq_along(NAMES)) {
[13:20:45.166]                   name <- removed[[kk]]
[13:20:45.166]                   NAME <- NAMES[[kk]]
[13:20:45.166]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.166]                     next
[13:20:45.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.166]                 }
[13:20:45.166]                 if (length(args) > 0) 
[13:20:45.166]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.166]             }
[13:20:45.166]             else {
[13:20:45.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.166]             }
[13:20:45.166]             {
[13:20:45.166]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.166]                   0L) {
[13:20:45.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.166]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.166]                   base::options(opts)
[13:20:45.166]                 }
[13:20:45.166]                 {
[13:20:45.166]                   {
[13:20:45.166]                     NULL
[13:20:45.166]                     RNGkind("Mersenne-Twister")
[13:20:45.166]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.166]                       inherits = FALSE)
[13:20:45.166]                   }
[13:20:45.166]                   options(future.plan = NULL)
[13:20:45.166]                   if (is.na(NA_character_)) 
[13:20:45.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.166]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.166]                   {
[13:20:45.166]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.166]                     if (!future$lazy) 
[13:20:45.166]                       future <- run(future)
[13:20:45.166]                     invisible(future)
[13:20:45.166]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.166]                 }
[13:20:45.166]             }
[13:20:45.166]         }
[13:20:45.166]     })
[13:20:45.166]     if (TRUE) {
[13:20:45.166]         base::sink(type = "output", split = FALSE)
[13:20:45.166]         if (TRUE) {
[13:20:45.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.166]         }
[13:20:45.166]         else {
[13:20:45.166]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.166]         }
[13:20:45.166]         base::close(...future.stdout)
[13:20:45.166]         ...future.stdout <- NULL
[13:20:45.166]     }
[13:20:45.166]     ...future.result$conditions <- ...future.conditions
[13:20:45.166]     ...future.result$finished <- base::Sys.time()
[13:20:45.166]     ...future.result
[13:20:45.166] }
[13:20:45.167] assign_globals() ...
[13:20:45.168] List of 1
[13:20:45.168]  $ x: list()
[13:20:45.168]  - attr(*, "where")=List of 1
[13:20:45.168]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.168]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.168]  - attr(*, "resolved")= logi TRUE
[13:20:45.168]  - attr(*, "total_size")= num 0
[13:20:45.168]  - attr(*, "already-done")= logi TRUE
[13:20:45.170] - copied ‘x’ to environment
[13:20:45.170] assign_globals() ... done
[13:20:45.170] plan(): Setting new future strategy stack:
[13:20:45.170] List of future strategies:
[13:20:45.170] 1. sequential:
[13:20:45.170]    - args: function (..., envir = parent.frame())
[13:20:45.170]    - tweaked: FALSE
[13:20:45.170]    - call: NULL
[13:20:45.171] plan(): nbrOfWorkers() = 1
[13:20:45.172] plan(): Setting new future strategy stack:
[13:20:45.172] List of future strategies:
[13:20:45.172] 1. sequential:
[13:20:45.172]    - args: function (..., envir = parent.frame())
[13:20:45.172]    - tweaked: FALSE
[13:20:45.172]    - call: plan(strategy)
[13:20:45.172] plan(): nbrOfWorkers() = 1
[13:20:45.172] SequentialFuture started (and completed)
[13:20:45.172] - Launch lazy future ... done
[13:20:45.172] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.173] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.173] Searching for globals...
[13:20:45.177] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.177] Searching for globals ... DONE
[13:20:45.177] Resolving globals: TRUE
[13:20:45.177] Resolving any globals that are futures ...
[13:20:45.177] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.177] Resolving any globals that are futures ... DONE
[13:20:45.178] Resolving futures part of globals (recursively) ...
[13:20:45.178] resolve() on list ...
[13:20:45.178]  recursive: 99
[13:20:45.178]  length: 1
[13:20:45.178]  elements: ‘x’
[13:20:45.178]  length: 0 (resolved future 1)
[13:20:45.179] resolve() on list ... DONE
[13:20:45.179] - globals: [1] ‘x’
[13:20:45.179] Resolving futures part of globals (recursively) ... DONE
[13:20:45.179] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.179] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.179] - globals: [1] ‘x’
[13:20:45.179] 
[13:20:45.180] getGlobalsAndPackages() ... DONE
[13:20:45.180] run() for ‘Future’ ...
[13:20:45.180] - state: ‘created’
[13:20:45.180] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.180] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.181]   - Field: ‘label’
[13:20:45.181]   - Field: ‘local’
[13:20:45.181]   - Field: ‘owner’
[13:20:45.181]   - Field: ‘envir’
[13:20:45.181]   - Field: ‘packages’
[13:20:45.181]   - Field: ‘gc’
[13:20:45.181]   - Field: ‘conditions’
[13:20:45.181]   - Field: ‘expr’
[13:20:45.181]   - Field: ‘uuid’
[13:20:45.181]   - Field: ‘seed’
[13:20:45.182]   - Field: ‘version’
[13:20:45.182]   - Field: ‘result’
[13:20:45.182]   - Field: ‘asynchronous’
[13:20:45.182]   - Field: ‘calls’
[13:20:45.182]   - Field: ‘globals’
[13:20:45.182]   - Field: ‘stdout’
[13:20:45.182]   - Field: ‘earlySignal’
[13:20:45.182]   - Field: ‘lazy’
[13:20:45.182]   - Field: ‘state’
[13:20:45.182] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.183] - Launch lazy future ...
[13:20:45.183] Packages needed by the future expression (n = 0): <none>
[13:20:45.183] Packages needed by future strategies (n = 0): <none>
[13:20:45.183] {
[13:20:45.183]     {
[13:20:45.183]         {
[13:20:45.183]             ...future.startTime <- base::Sys.time()
[13:20:45.183]             {
[13:20:45.183]                 {
[13:20:45.183]                   {
[13:20:45.183]                     base::local({
[13:20:45.183]                       has_future <- base::requireNamespace("future", 
[13:20:45.183]                         quietly = TRUE)
[13:20:45.183]                       if (has_future) {
[13:20:45.183]                         ns <- base::getNamespace("future")
[13:20:45.183]                         version <- ns[[".package"]][["version"]]
[13:20:45.183]                         if (is.null(version)) 
[13:20:45.183]                           version <- utils::packageVersion("future")
[13:20:45.183]                       }
[13:20:45.183]                       else {
[13:20:45.183]                         version <- NULL
[13:20:45.183]                       }
[13:20:45.183]                       if (!has_future || version < "1.8.0") {
[13:20:45.183]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.183]                           "", base::R.version$version.string), 
[13:20:45.183]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.183]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.183]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.183]                             "release", "version")], collapse = " "), 
[13:20:45.183]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.183]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.183]                           info)
[13:20:45.183]                         info <- base::paste(info, collapse = "; ")
[13:20:45.183]                         if (!has_future) {
[13:20:45.183]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.183]                             info)
[13:20:45.183]                         }
[13:20:45.183]                         else {
[13:20:45.183]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.183]                             info, version)
[13:20:45.183]                         }
[13:20:45.183]                         base::stop(msg)
[13:20:45.183]                       }
[13:20:45.183]                     })
[13:20:45.183]                   }
[13:20:45.183]                   options(future.plan = NULL)
[13:20:45.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.183]                 }
[13:20:45.183]                 ...future.workdir <- getwd()
[13:20:45.183]             }
[13:20:45.183]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.183]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.183]         }
[13:20:45.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.183]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.183]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.183]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.183]             base::names(...future.oldOptions))
[13:20:45.183]     }
[13:20:45.183]     if (FALSE) {
[13:20:45.183]     }
[13:20:45.183]     else {
[13:20:45.183]         if (TRUE) {
[13:20:45.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.183]                 open = "w")
[13:20:45.183]         }
[13:20:45.183]         else {
[13:20:45.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.183]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.183]         }
[13:20:45.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.183]             base::sink(type = "output", split = FALSE)
[13:20:45.183]             base::close(...future.stdout)
[13:20:45.183]         }, add = TRUE)
[13:20:45.183]     }
[13:20:45.183]     ...future.frame <- base::sys.nframe()
[13:20:45.183]     ...future.conditions <- base::list()
[13:20:45.183]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.183]     if (FALSE) {
[13:20:45.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.183]     }
[13:20:45.183]     ...future.result <- base::tryCatch({
[13:20:45.183]         base::withCallingHandlers({
[13:20:45.183]             ...future.value <- base::withVisible(base::local({
[13:20:45.183]                 x["a"] <- list(1)
[13:20:45.183]                 x
[13:20:45.183]             }))
[13:20:45.183]             future::FutureResult(value = ...future.value$value, 
[13:20:45.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.183]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.183]                     ...future.globalenv.names))
[13:20:45.183]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.183]         }, condition = base::local({
[13:20:45.183]             c <- base::c
[13:20:45.183]             inherits <- base::inherits
[13:20:45.183]             invokeRestart <- base::invokeRestart
[13:20:45.183]             length <- base::length
[13:20:45.183]             list <- base::list
[13:20:45.183]             seq.int <- base::seq.int
[13:20:45.183]             signalCondition <- base::signalCondition
[13:20:45.183]             sys.calls <- base::sys.calls
[13:20:45.183]             `[[` <- base::`[[`
[13:20:45.183]             `+` <- base::`+`
[13:20:45.183]             `<<-` <- base::`<<-`
[13:20:45.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.183]                   3L)]
[13:20:45.183]             }
[13:20:45.183]             function(cond) {
[13:20:45.183]                 is_error <- inherits(cond, "error")
[13:20:45.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.183]                   NULL)
[13:20:45.183]                 if (is_error) {
[13:20:45.183]                   sessionInformation <- function() {
[13:20:45.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.183]                       search = base::search(), system = base::Sys.info())
[13:20:45.183]                   }
[13:20:45.183]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.183]                     cond$call), session = sessionInformation(), 
[13:20:45.183]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.183]                   signalCondition(cond)
[13:20:45.183]                 }
[13:20:45.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.183]                 "immediateCondition"))) {
[13:20:45.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.183]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.183]                   if (TRUE && !signal) {
[13:20:45.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.183]                     {
[13:20:45.183]                       inherits <- base::inherits
[13:20:45.183]                       invokeRestart <- base::invokeRestart
[13:20:45.183]                       is.null <- base::is.null
[13:20:45.183]                       muffled <- FALSE
[13:20:45.183]                       if (inherits(cond, "message")) {
[13:20:45.183]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.183]                         if (muffled) 
[13:20:45.183]                           invokeRestart("muffleMessage")
[13:20:45.183]                       }
[13:20:45.183]                       else if (inherits(cond, "warning")) {
[13:20:45.183]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.183]                         if (muffled) 
[13:20:45.183]                           invokeRestart("muffleWarning")
[13:20:45.183]                       }
[13:20:45.183]                       else if (inherits(cond, "condition")) {
[13:20:45.183]                         if (!is.null(pattern)) {
[13:20:45.183]                           computeRestarts <- base::computeRestarts
[13:20:45.183]                           grepl <- base::grepl
[13:20:45.183]                           restarts <- computeRestarts(cond)
[13:20:45.183]                           for (restart in restarts) {
[13:20:45.183]                             name <- restart$name
[13:20:45.183]                             if (is.null(name)) 
[13:20:45.183]                               next
[13:20:45.183]                             if (!grepl(pattern, name)) 
[13:20:45.183]                               next
[13:20:45.183]                             invokeRestart(restart)
[13:20:45.183]                             muffled <- TRUE
[13:20:45.183]                             break
[13:20:45.183]                           }
[13:20:45.183]                         }
[13:20:45.183]                       }
[13:20:45.183]                       invisible(muffled)
[13:20:45.183]                     }
[13:20:45.183]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.183]                   }
[13:20:45.183]                 }
[13:20:45.183]                 else {
[13:20:45.183]                   if (TRUE) {
[13:20:45.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.183]                     {
[13:20:45.183]                       inherits <- base::inherits
[13:20:45.183]                       invokeRestart <- base::invokeRestart
[13:20:45.183]                       is.null <- base::is.null
[13:20:45.183]                       muffled <- FALSE
[13:20:45.183]                       if (inherits(cond, "message")) {
[13:20:45.183]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.183]                         if (muffled) 
[13:20:45.183]                           invokeRestart("muffleMessage")
[13:20:45.183]                       }
[13:20:45.183]                       else if (inherits(cond, "warning")) {
[13:20:45.183]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.183]                         if (muffled) 
[13:20:45.183]                           invokeRestart("muffleWarning")
[13:20:45.183]                       }
[13:20:45.183]                       else if (inherits(cond, "condition")) {
[13:20:45.183]                         if (!is.null(pattern)) {
[13:20:45.183]                           computeRestarts <- base::computeRestarts
[13:20:45.183]                           grepl <- base::grepl
[13:20:45.183]                           restarts <- computeRestarts(cond)
[13:20:45.183]                           for (restart in restarts) {
[13:20:45.183]                             name <- restart$name
[13:20:45.183]                             if (is.null(name)) 
[13:20:45.183]                               next
[13:20:45.183]                             if (!grepl(pattern, name)) 
[13:20:45.183]                               next
[13:20:45.183]                             invokeRestart(restart)
[13:20:45.183]                             muffled <- TRUE
[13:20:45.183]                             break
[13:20:45.183]                           }
[13:20:45.183]                         }
[13:20:45.183]                       }
[13:20:45.183]                       invisible(muffled)
[13:20:45.183]                     }
[13:20:45.183]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.183]                   }
[13:20:45.183]                 }
[13:20:45.183]             }
[13:20:45.183]         }))
[13:20:45.183]     }, error = function(ex) {
[13:20:45.183]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.183]                 ...future.rng), started = ...future.startTime, 
[13:20:45.183]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.183]             version = "1.8"), class = "FutureResult")
[13:20:45.183]     }, finally = {
[13:20:45.183]         if (!identical(...future.workdir, getwd())) 
[13:20:45.183]             setwd(...future.workdir)
[13:20:45.183]         {
[13:20:45.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.183]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.183]             }
[13:20:45.183]             base::options(...future.oldOptions)
[13:20:45.183]             if (.Platform$OS.type == "windows") {
[13:20:45.183]                 old_names <- names(...future.oldEnvVars)
[13:20:45.183]                 envs <- base::Sys.getenv()
[13:20:45.183]                 names <- names(envs)
[13:20:45.183]                 common <- intersect(names, old_names)
[13:20:45.183]                 added <- setdiff(names, old_names)
[13:20:45.183]                 removed <- setdiff(old_names, names)
[13:20:45.183]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.183]                   envs[common]]
[13:20:45.183]                 NAMES <- toupper(changed)
[13:20:45.183]                 args <- list()
[13:20:45.183]                 for (kk in seq_along(NAMES)) {
[13:20:45.183]                   name <- changed[[kk]]
[13:20:45.183]                   NAME <- NAMES[[kk]]
[13:20:45.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.183]                     next
[13:20:45.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.183]                 }
[13:20:45.183]                 NAMES <- toupper(added)
[13:20:45.183]                 for (kk in seq_along(NAMES)) {
[13:20:45.183]                   name <- added[[kk]]
[13:20:45.183]                   NAME <- NAMES[[kk]]
[13:20:45.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.183]                     next
[13:20:45.183]                   args[[name]] <- ""
[13:20:45.183]                 }
[13:20:45.183]                 NAMES <- toupper(removed)
[13:20:45.183]                 for (kk in seq_along(NAMES)) {
[13:20:45.183]                   name <- removed[[kk]]
[13:20:45.183]                   NAME <- NAMES[[kk]]
[13:20:45.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.183]                     next
[13:20:45.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.183]                 }
[13:20:45.183]                 if (length(args) > 0) 
[13:20:45.183]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.183]             }
[13:20:45.183]             else {
[13:20:45.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.183]             }
[13:20:45.183]             {
[13:20:45.183]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.183]                   0L) {
[13:20:45.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.183]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.183]                   base::options(opts)
[13:20:45.183]                 }
[13:20:45.183]                 {
[13:20:45.183]                   {
[13:20:45.183]                     NULL
[13:20:45.183]                     RNGkind("Mersenne-Twister")
[13:20:45.183]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.183]                       inherits = FALSE)
[13:20:45.183]                   }
[13:20:45.183]                   options(future.plan = NULL)
[13:20:45.183]                   if (is.na(NA_character_)) 
[13:20:45.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.183]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.183]                   {
[13:20:45.183]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.183]                     if (!future$lazy) 
[13:20:45.183]                       future <- run(future)
[13:20:45.183]                     invisible(future)
[13:20:45.183]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.183]                 }
[13:20:45.183]             }
[13:20:45.183]         }
[13:20:45.183]     })
[13:20:45.183]     if (TRUE) {
[13:20:45.183]         base::sink(type = "output", split = FALSE)
[13:20:45.183]         if (TRUE) {
[13:20:45.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.183]         }
[13:20:45.183]         else {
[13:20:45.183]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.183]         }
[13:20:45.183]         base::close(...future.stdout)
[13:20:45.183]         ...future.stdout <- NULL
[13:20:45.183]     }
[13:20:45.183]     ...future.result$conditions <- ...future.conditions
[13:20:45.183]     ...future.result$finished <- base::Sys.time()
[13:20:45.183]     ...future.result
[13:20:45.183] }
[13:20:45.185] assign_globals() ...
[13:20:45.185] List of 1
[13:20:45.185]  $ x: list()
[13:20:45.185]  - attr(*, "where")=List of 1
[13:20:45.185]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.185]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.185]  - attr(*, "resolved")= logi TRUE
[13:20:45.185]  - attr(*, "total_size")= num 0
[13:20:45.185]  - attr(*, "already-done")= logi TRUE
[13:20:45.187] - copied ‘x’ to environment
[13:20:45.188] assign_globals() ... done
[13:20:45.188] plan(): Setting new future strategy stack:
[13:20:45.188] List of future strategies:
[13:20:45.188] 1. sequential:
[13:20:45.188]    - args: function (..., envir = parent.frame())
[13:20:45.188]    - tweaked: FALSE
[13:20:45.188]    - call: NULL
[13:20:45.188] plan(): nbrOfWorkers() = 1
[13:20:45.189] plan(): Setting new future strategy stack:
[13:20:45.189] List of future strategies:
[13:20:45.189] 1. sequential:
[13:20:45.189]    - args: function (..., envir = parent.frame())
[13:20:45.189]    - tweaked: FALSE
[13:20:45.189]    - call: plan(strategy)
[13:20:45.190] plan(): nbrOfWorkers() = 1
[13:20:45.190] SequentialFuture started (and completed)
[13:20:45.190] - Launch lazy future ... done
[13:20:45.190] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.190] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.191] Searching for globals...
[13:20:45.193] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.193] Searching for globals ... DONE
[13:20:45.193] Resolving globals: TRUE
[13:20:45.193] Resolving any globals that are futures ...
[13:20:45.193] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.193] Resolving any globals that are futures ... DONE
[13:20:45.194] Resolving futures part of globals (recursively) ...
[13:20:45.194] resolve() on list ...
[13:20:45.194]  recursive: 99
[13:20:45.194]  length: 1
[13:20:45.194]  elements: ‘x’
[13:20:45.194]  length: 0 (resolved future 1)
[13:20:45.194] resolve() on list ... DONE
[13:20:45.194] - globals: [1] ‘x’
[13:20:45.194] Resolving futures part of globals (recursively) ... DONE
[13:20:45.195] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.195] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.195] - globals: [1] ‘x’
[13:20:45.195] 
[13:20:45.195] getGlobalsAndPackages() ... DONE
[13:20:45.195] run() for ‘Future’ ...
[13:20:45.196] - state: ‘created’
[13:20:45.196] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.196] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.196] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.196]   - Field: ‘label’
[13:20:45.196]   - Field: ‘local’
[13:20:45.196]   - Field: ‘owner’
[13:20:45.196]   - Field: ‘envir’
[13:20:45.197]   - Field: ‘packages’
[13:20:45.197]   - Field: ‘gc’
[13:20:45.197]   - Field: ‘conditions’
[13:20:45.197]   - Field: ‘expr’
[13:20:45.197]   - Field: ‘uuid’
[13:20:45.197]   - Field: ‘seed’
[13:20:45.197]   - Field: ‘version’
[13:20:45.197]   - Field: ‘result’
[13:20:45.197]   - Field: ‘asynchronous’
[13:20:45.197]   - Field: ‘calls’
[13:20:45.198]   - Field: ‘globals’
[13:20:45.198]   - Field: ‘stdout’
[13:20:45.198]   - Field: ‘earlySignal’
[13:20:45.198]   - Field: ‘lazy’
[13:20:45.198]   - Field: ‘state’
[13:20:45.198] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.198] - Launch lazy future ...
[13:20:45.198] Packages needed by the future expression (n = 0): <none>
[13:20:45.198] Packages needed by future strategies (n = 0): <none>
[13:20:45.199] {
[13:20:45.199]     {
[13:20:45.199]         {
[13:20:45.199]             ...future.startTime <- base::Sys.time()
[13:20:45.199]             {
[13:20:45.199]                 {
[13:20:45.199]                   {
[13:20:45.199]                     base::local({
[13:20:45.199]                       has_future <- base::requireNamespace("future", 
[13:20:45.199]                         quietly = TRUE)
[13:20:45.199]                       if (has_future) {
[13:20:45.199]                         ns <- base::getNamespace("future")
[13:20:45.199]                         version <- ns[[".package"]][["version"]]
[13:20:45.199]                         if (is.null(version)) 
[13:20:45.199]                           version <- utils::packageVersion("future")
[13:20:45.199]                       }
[13:20:45.199]                       else {
[13:20:45.199]                         version <- NULL
[13:20:45.199]                       }
[13:20:45.199]                       if (!has_future || version < "1.8.0") {
[13:20:45.199]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.199]                           "", base::R.version$version.string), 
[13:20:45.199]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.199]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.199]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.199]                             "release", "version")], collapse = " "), 
[13:20:45.199]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.199]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.199]                           info)
[13:20:45.199]                         info <- base::paste(info, collapse = "; ")
[13:20:45.199]                         if (!has_future) {
[13:20:45.199]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.199]                             info)
[13:20:45.199]                         }
[13:20:45.199]                         else {
[13:20:45.199]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.199]                             info, version)
[13:20:45.199]                         }
[13:20:45.199]                         base::stop(msg)
[13:20:45.199]                       }
[13:20:45.199]                     })
[13:20:45.199]                   }
[13:20:45.199]                   options(future.plan = NULL)
[13:20:45.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.199]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.199]                 }
[13:20:45.199]                 ...future.workdir <- getwd()
[13:20:45.199]             }
[13:20:45.199]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.199]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.199]         }
[13:20:45.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.199]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.199]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.199]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.199]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.199]             base::names(...future.oldOptions))
[13:20:45.199]     }
[13:20:45.199]     if (FALSE) {
[13:20:45.199]     }
[13:20:45.199]     else {
[13:20:45.199]         if (TRUE) {
[13:20:45.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.199]                 open = "w")
[13:20:45.199]         }
[13:20:45.199]         else {
[13:20:45.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.199]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.199]         }
[13:20:45.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.199]             base::sink(type = "output", split = FALSE)
[13:20:45.199]             base::close(...future.stdout)
[13:20:45.199]         }, add = TRUE)
[13:20:45.199]     }
[13:20:45.199]     ...future.frame <- base::sys.nframe()
[13:20:45.199]     ...future.conditions <- base::list()
[13:20:45.199]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.199]     if (FALSE) {
[13:20:45.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.199]     }
[13:20:45.199]     ...future.result <- base::tryCatch({
[13:20:45.199]         base::withCallingHandlers({
[13:20:45.199]             ...future.value <- base::withVisible(base::local({
[13:20:45.199]                 x["a"] <- list(1)
[13:20:45.199]                 x
[13:20:45.199]             }))
[13:20:45.199]             future::FutureResult(value = ...future.value$value, 
[13:20:45.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.199]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.199]                     ...future.globalenv.names))
[13:20:45.199]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.199]         }, condition = base::local({
[13:20:45.199]             c <- base::c
[13:20:45.199]             inherits <- base::inherits
[13:20:45.199]             invokeRestart <- base::invokeRestart
[13:20:45.199]             length <- base::length
[13:20:45.199]             list <- base::list
[13:20:45.199]             seq.int <- base::seq.int
[13:20:45.199]             signalCondition <- base::signalCondition
[13:20:45.199]             sys.calls <- base::sys.calls
[13:20:45.199]             `[[` <- base::`[[`
[13:20:45.199]             `+` <- base::`+`
[13:20:45.199]             `<<-` <- base::`<<-`
[13:20:45.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.199]                   3L)]
[13:20:45.199]             }
[13:20:45.199]             function(cond) {
[13:20:45.199]                 is_error <- inherits(cond, "error")
[13:20:45.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.199]                   NULL)
[13:20:45.199]                 if (is_error) {
[13:20:45.199]                   sessionInformation <- function() {
[13:20:45.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.199]                       search = base::search(), system = base::Sys.info())
[13:20:45.199]                   }
[13:20:45.199]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.199]                     cond$call), session = sessionInformation(), 
[13:20:45.199]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.199]                   signalCondition(cond)
[13:20:45.199]                 }
[13:20:45.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.199]                 "immediateCondition"))) {
[13:20:45.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.199]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.199]                   if (TRUE && !signal) {
[13:20:45.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.199]                     {
[13:20:45.199]                       inherits <- base::inherits
[13:20:45.199]                       invokeRestart <- base::invokeRestart
[13:20:45.199]                       is.null <- base::is.null
[13:20:45.199]                       muffled <- FALSE
[13:20:45.199]                       if (inherits(cond, "message")) {
[13:20:45.199]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.199]                         if (muffled) 
[13:20:45.199]                           invokeRestart("muffleMessage")
[13:20:45.199]                       }
[13:20:45.199]                       else if (inherits(cond, "warning")) {
[13:20:45.199]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.199]                         if (muffled) 
[13:20:45.199]                           invokeRestart("muffleWarning")
[13:20:45.199]                       }
[13:20:45.199]                       else if (inherits(cond, "condition")) {
[13:20:45.199]                         if (!is.null(pattern)) {
[13:20:45.199]                           computeRestarts <- base::computeRestarts
[13:20:45.199]                           grepl <- base::grepl
[13:20:45.199]                           restarts <- computeRestarts(cond)
[13:20:45.199]                           for (restart in restarts) {
[13:20:45.199]                             name <- restart$name
[13:20:45.199]                             if (is.null(name)) 
[13:20:45.199]                               next
[13:20:45.199]                             if (!grepl(pattern, name)) 
[13:20:45.199]                               next
[13:20:45.199]                             invokeRestart(restart)
[13:20:45.199]                             muffled <- TRUE
[13:20:45.199]                             break
[13:20:45.199]                           }
[13:20:45.199]                         }
[13:20:45.199]                       }
[13:20:45.199]                       invisible(muffled)
[13:20:45.199]                     }
[13:20:45.199]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.199]                   }
[13:20:45.199]                 }
[13:20:45.199]                 else {
[13:20:45.199]                   if (TRUE) {
[13:20:45.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.199]                     {
[13:20:45.199]                       inherits <- base::inherits
[13:20:45.199]                       invokeRestart <- base::invokeRestart
[13:20:45.199]                       is.null <- base::is.null
[13:20:45.199]                       muffled <- FALSE
[13:20:45.199]                       if (inherits(cond, "message")) {
[13:20:45.199]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.199]                         if (muffled) 
[13:20:45.199]                           invokeRestart("muffleMessage")
[13:20:45.199]                       }
[13:20:45.199]                       else if (inherits(cond, "warning")) {
[13:20:45.199]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.199]                         if (muffled) 
[13:20:45.199]                           invokeRestart("muffleWarning")
[13:20:45.199]                       }
[13:20:45.199]                       else if (inherits(cond, "condition")) {
[13:20:45.199]                         if (!is.null(pattern)) {
[13:20:45.199]                           computeRestarts <- base::computeRestarts
[13:20:45.199]                           grepl <- base::grepl
[13:20:45.199]                           restarts <- computeRestarts(cond)
[13:20:45.199]                           for (restart in restarts) {
[13:20:45.199]                             name <- restart$name
[13:20:45.199]                             if (is.null(name)) 
[13:20:45.199]                               next
[13:20:45.199]                             if (!grepl(pattern, name)) 
[13:20:45.199]                               next
[13:20:45.199]                             invokeRestart(restart)
[13:20:45.199]                             muffled <- TRUE
[13:20:45.199]                             break
[13:20:45.199]                           }
[13:20:45.199]                         }
[13:20:45.199]                       }
[13:20:45.199]                       invisible(muffled)
[13:20:45.199]                     }
[13:20:45.199]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.199]                   }
[13:20:45.199]                 }
[13:20:45.199]             }
[13:20:45.199]         }))
[13:20:45.199]     }, error = function(ex) {
[13:20:45.199]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.199]                 ...future.rng), started = ...future.startTime, 
[13:20:45.199]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.199]             version = "1.8"), class = "FutureResult")
[13:20:45.199]     }, finally = {
[13:20:45.199]         if (!identical(...future.workdir, getwd())) 
[13:20:45.199]             setwd(...future.workdir)
[13:20:45.199]         {
[13:20:45.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.199]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.199]             }
[13:20:45.199]             base::options(...future.oldOptions)
[13:20:45.199]             if (.Platform$OS.type == "windows") {
[13:20:45.199]                 old_names <- names(...future.oldEnvVars)
[13:20:45.199]                 envs <- base::Sys.getenv()
[13:20:45.199]                 names <- names(envs)
[13:20:45.199]                 common <- intersect(names, old_names)
[13:20:45.199]                 added <- setdiff(names, old_names)
[13:20:45.199]                 removed <- setdiff(old_names, names)
[13:20:45.199]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.199]                   envs[common]]
[13:20:45.199]                 NAMES <- toupper(changed)
[13:20:45.199]                 args <- list()
[13:20:45.199]                 for (kk in seq_along(NAMES)) {
[13:20:45.199]                   name <- changed[[kk]]
[13:20:45.199]                   NAME <- NAMES[[kk]]
[13:20:45.199]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.199]                     next
[13:20:45.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.199]                 }
[13:20:45.199]                 NAMES <- toupper(added)
[13:20:45.199]                 for (kk in seq_along(NAMES)) {
[13:20:45.199]                   name <- added[[kk]]
[13:20:45.199]                   NAME <- NAMES[[kk]]
[13:20:45.199]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.199]                     next
[13:20:45.199]                   args[[name]] <- ""
[13:20:45.199]                 }
[13:20:45.199]                 NAMES <- toupper(removed)
[13:20:45.199]                 for (kk in seq_along(NAMES)) {
[13:20:45.199]                   name <- removed[[kk]]
[13:20:45.199]                   NAME <- NAMES[[kk]]
[13:20:45.199]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.199]                     next
[13:20:45.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.199]                 }
[13:20:45.199]                 if (length(args) > 0) 
[13:20:45.199]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.199]             }
[13:20:45.199]             else {
[13:20:45.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.199]             }
[13:20:45.199]             {
[13:20:45.199]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.199]                   0L) {
[13:20:45.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.199]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.199]                   base::options(opts)
[13:20:45.199]                 }
[13:20:45.199]                 {
[13:20:45.199]                   {
[13:20:45.199]                     NULL
[13:20:45.199]                     RNGkind("Mersenne-Twister")
[13:20:45.199]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.199]                       inherits = FALSE)
[13:20:45.199]                   }
[13:20:45.199]                   options(future.plan = NULL)
[13:20:45.199]                   if (is.na(NA_character_)) 
[13:20:45.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.199]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.199]                   {
[13:20:45.199]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.199]                     if (!future$lazy) 
[13:20:45.199]                       future <- run(future)
[13:20:45.199]                     invisible(future)
[13:20:45.199]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.199]                 }
[13:20:45.199]             }
[13:20:45.199]         }
[13:20:45.199]     })
[13:20:45.199]     if (TRUE) {
[13:20:45.199]         base::sink(type = "output", split = FALSE)
[13:20:45.199]         if (TRUE) {
[13:20:45.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.199]         }
[13:20:45.199]         else {
[13:20:45.199]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.199]         }
[13:20:45.199]         base::close(...future.stdout)
[13:20:45.199]         ...future.stdout <- NULL
[13:20:45.199]     }
[13:20:45.199]     ...future.result$conditions <- ...future.conditions
[13:20:45.199]     ...future.result$finished <- base::Sys.time()
[13:20:45.199]     ...future.result
[13:20:45.199] }
[13:20:45.200] assign_globals() ...
[13:20:45.201] List of 1
[13:20:45.201]  $ x: list()
[13:20:45.201]  - attr(*, "where")=List of 1
[13:20:45.201]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.201]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.201]  - attr(*, "resolved")= logi TRUE
[13:20:45.201]  - attr(*, "total_size")= num 0
[13:20:45.201]  - attr(*, "already-done")= logi TRUE
[13:20:45.205] - copied ‘x’ to environment
[13:20:45.205] assign_globals() ... done
[13:20:45.205] plan(): Setting new future strategy stack:
[13:20:45.205] List of future strategies:
[13:20:45.205] 1. sequential:
[13:20:45.205]    - args: function (..., envir = parent.frame())
[13:20:45.205]    - tweaked: FALSE
[13:20:45.205]    - call: NULL
[13:20:45.205] plan(): nbrOfWorkers() = 1
[13:20:45.206] plan(): Setting new future strategy stack:
[13:20:45.206] List of future strategies:
[13:20:45.206] 1. sequential:
[13:20:45.206]    - args: function (..., envir = parent.frame())
[13:20:45.206]    - tweaked: FALSE
[13:20:45.206]    - call: plan(strategy)
[13:20:45.207] plan(): nbrOfWorkers() = 1
[13:20:45.207] SequentialFuture started (and completed)
[13:20:45.207] - Launch lazy future ... done
[13:20:45.207] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.208] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.208] Searching for globals...
[13:20:45.210] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:20:45.210] Searching for globals ... DONE
[13:20:45.210] Resolving globals: TRUE
[13:20:45.210] Resolving any globals that are futures ...
[13:20:45.210] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:20:45.210] Resolving any globals that are futures ... DONE
[13:20:45.211] Resolving futures part of globals (recursively) ...
[13:20:45.211] resolve() on list ...
[13:20:45.211]  recursive: 99
[13:20:45.211]  length: 2
[13:20:45.211]  elements: ‘x’, ‘name’
[13:20:45.212]  length: 1 (resolved future 1)
[13:20:45.212]  length: 0 (resolved future 2)
[13:20:45.212] resolve() on list ... DONE
[13:20:45.212] - globals: [2] ‘x’, ‘name’
[13:20:45.212] Resolving futures part of globals (recursively) ... DONE
[13:20:45.212] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:45.213] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[13:20:45.213] - globals: [2] ‘x’, ‘name’
[13:20:45.213] 
[13:20:45.213] getGlobalsAndPackages() ... DONE
[13:20:45.213] run() for ‘Future’ ...
[13:20:45.213] - state: ‘created’
[13:20:45.214] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:45.214] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:45.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:45.214]   - Field: ‘label’
[13:20:45.214]   - Field: ‘local’
[13:20:45.214]   - Field: ‘owner’
[13:20:45.214]   - Field: ‘envir’
[13:20:45.214]   - Field: ‘packages’
[13:20:45.215]   - Field: ‘gc’
[13:20:45.215]   - Field: ‘conditions’
[13:20:45.215]   - Field: ‘expr’
[13:20:45.215]   - Field: ‘uuid’
[13:20:45.215]   - Field: ‘seed’
[13:20:45.215]   - Field: ‘version’
[13:20:45.215]   - Field: ‘result’
[13:20:45.215]   - Field: ‘asynchronous’
[13:20:45.215]   - Field: ‘calls’
[13:20:45.215]   - Field: ‘globals’
[13:20:45.215]   - Field: ‘stdout’
[13:20:45.216]   - Field: ‘earlySignal’
[13:20:45.216]   - Field: ‘lazy’
[13:20:45.216]   - Field: ‘state’
[13:20:45.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:45.216] - Launch lazy future ...
[13:20:45.216] Packages needed by the future expression (n = 0): <none>
[13:20:45.216] Packages needed by future strategies (n = 0): <none>
[13:20:45.217] {
[13:20:45.217]     {
[13:20:45.217]         {
[13:20:45.217]             ...future.startTime <- base::Sys.time()
[13:20:45.217]             {
[13:20:45.217]                 {
[13:20:45.217]                   {
[13:20:45.217]                     base::local({
[13:20:45.217]                       has_future <- base::requireNamespace("future", 
[13:20:45.217]                         quietly = TRUE)
[13:20:45.217]                       if (has_future) {
[13:20:45.217]                         ns <- base::getNamespace("future")
[13:20:45.217]                         version <- ns[[".package"]][["version"]]
[13:20:45.217]                         if (is.null(version)) 
[13:20:45.217]                           version <- utils::packageVersion("future")
[13:20:45.217]                       }
[13:20:45.217]                       else {
[13:20:45.217]                         version <- NULL
[13:20:45.217]                       }
[13:20:45.217]                       if (!has_future || version < "1.8.0") {
[13:20:45.217]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.217]                           "", base::R.version$version.string), 
[13:20:45.217]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:45.217]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.217]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.217]                             "release", "version")], collapse = " "), 
[13:20:45.217]                           hostname = base::Sys.info()[["nodename"]])
[13:20:45.217]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.217]                           info)
[13:20:45.217]                         info <- base::paste(info, collapse = "; ")
[13:20:45.217]                         if (!has_future) {
[13:20:45.217]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.217]                             info)
[13:20:45.217]                         }
[13:20:45.217]                         else {
[13:20:45.217]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.217]                             info, version)
[13:20:45.217]                         }
[13:20:45.217]                         base::stop(msg)
[13:20:45.217]                       }
[13:20:45.217]                     })
[13:20:45.217]                   }
[13:20:45.217]                   options(future.plan = NULL)
[13:20:45.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.217]                 }
[13:20:45.217]                 ...future.workdir <- getwd()
[13:20:45.217]             }
[13:20:45.217]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.217]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.217]         }
[13:20:45.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.217]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.217]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.217]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.217]             base::names(...future.oldOptions))
[13:20:45.217]     }
[13:20:45.217]     if (FALSE) {
[13:20:45.217]     }
[13:20:45.217]     else {
[13:20:45.217]         if (TRUE) {
[13:20:45.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.217]                 open = "w")
[13:20:45.217]         }
[13:20:45.217]         else {
[13:20:45.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.217]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.217]         }
[13:20:45.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.217]             base::sink(type = "output", split = FALSE)
[13:20:45.217]             base::close(...future.stdout)
[13:20:45.217]         }, add = TRUE)
[13:20:45.217]     }
[13:20:45.217]     ...future.frame <- base::sys.nframe()
[13:20:45.217]     ...future.conditions <- base::list()
[13:20:45.217]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.217]     if (FALSE) {
[13:20:45.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.217]     }
[13:20:45.217]     ...future.result <- base::tryCatch({
[13:20:45.217]         base::withCallingHandlers({
[13:20:45.217]             ...future.value <- base::withVisible(base::local({
[13:20:45.217]                 x[name] <- list(1)
[13:20:45.217]                 x
[13:20:45.217]             }))
[13:20:45.217]             future::FutureResult(value = ...future.value$value, 
[13:20:45.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.217]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.217]                     ...future.globalenv.names))
[13:20:45.217]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.217]         }, condition = base::local({
[13:20:45.217]             c <- base::c
[13:20:45.217]             inherits <- base::inherits
[13:20:45.217]             invokeRestart <- base::invokeRestart
[13:20:45.217]             length <- base::length
[13:20:45.217]             list <- base::list
[13:20:45.217]             seq.int <- base::seq.int
[13:20:45.217]             signalCondition <- base::signalCondition
[13:20:45.217]             sys.calls <- base::sys.calls
[13:20:45.217]             `[[` <- base::`[[`
[13:20:45.217]             `+` <- base::`+`
[13:20:45.217]             `<<-` <- base::`<<-`
[13:20:45.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.217]                   3L)]
[13:20:45.217]             }
[13:20:45.217]             function(cond) {
[13:20:45.217]                 is_error <- inherits(cond, "error")
[13:20:45.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.217]                   NULL)
[13:20:45.217]                 if (is_error) {
[13:20:45.217]                   sessionInformation <- function() {
[13:20:45.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.217]                       search = base::search(), system = base::Sys.info())
[13:20:45.217]                   }
[13:20:45.217]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.217]                     cond$call), session = sessionInformation(), 
[13:20:45.217]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.217]                   signalCondition(cond)
[13:20:45.217]                 }
[13:20:45.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.217]                 "immediateCondition"))) {
[13:20:45.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.217]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.217]                   if (TRUE && !signal) {
[13:20:45.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.217]                     {
[13:20:45.217]                       inherits <- base::inherits
[13:20:45.217]                       invokeRestart <- base::invokeRestart
[13:20:45.217]                       is.null <- base::is.null
[13:20:45.217]                       muffled <- FALSE
[13:20:45.217]                       if (inherits(cond, "message")) {
[13:20:45.217]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.217]                         if (muffled) 
[13:20:45.217]                           invokeRestart("muffleMessage")
[13:20:45.217]                       }
[13:20:45.217]                       else if (inherits(cond, "warning")) {
[13:20:45.217]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.217]                         if (muffled) 
[13:20:45.217]                           invokeRestart("muffleWarning")
[13:20:45.217]                       }
[13:20:45.217]                       else if (inherits(cond, "condition")) {
[13:20:45.217]                         if (!is.null(pattern)) {
[13:20:45.217]                           computeRestarts <- base::computeRestarts
[13:20:45.217]                           grepl <- base::grepl
[13:20:45.217]                           restarts <- computeRestarts(cond)
[13:20:45.217]                           for (restart in restarts) {
[13:20:45.217]                             name <- restart$name
[13:20:45.217]                             if (is.null(name)) 
[13:20:45.217]                               next
[13:20:45.217]                             if (!grepl(pattern, name)) 
[13:20:45.217]                               next
[13:20:45.217]                             invokeRestart(restart)
[13:20:45.217]                             muffled <- TRUE
[13:20:45.217]                             break
[13:20:45.217]                           }
[13:20:45.217]                         }
[13:20:45.217]                       }
[13:20:45.217]                       invisible(muffled)
[13:20:45.217]                     }
[13:20:45.217]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.217]                   }
[13:20:45.217]                 }
[13:20:45.217]                 else {
[13:20:45.217]                   if (TRUE) {
[13:20:45.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.217]                     {
[13:20:45.217]                       inherits <- base::inherits
[13:20:45.217]                       invokeRestart <- base::invokeRestart
[13:20:45.217]                       is.null <- base::is.null
[13:20:45.217]                       muffled <- FALSE
[13:20:45.217]                       if (inherits(cond, "message")) {
[13:20:45.217]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.217]                         if (muffled) 
[13:20:45.217]                           invokeRestart("muffleMessage")
[13:20:45.217]                       }
[13:20:45.217]                       else if (inherits(cond, "warning")) {
[13:20:45.217]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.217]                         if (muffled) 
[13:20:45.217]                           invokeRestart("muffleWarning")
[13:20:45.217]                       }
[13:20:45.217]                       else if (inherits(cond, "condition")) {
[13:20:45.217]                         if (!is.null(pattern)) {
[13:20:45.217]                           computeRestarts <- base::computeRestarts
[13:20:45.217]                           grepl <- base::grepl
[13:20:45.217]                           restarts <- computeRestarts(cond)
[13:20:45.217]                           for (restart in restarts) {
[13:20:45.217]                             name <- restart$name
[13:20:45.217]                             if (is.null(name)) 
[13:20:45.217]                               next
[13:20:45.217]                             if (!grepl(pattern, name)) 
[13:20:45.217]                               next
[13:20:45.217]                             invokeRestart(restart)
[13:20:45.217]                             muffled <- TRUE
[13:20:45.217]                             break
[13:20:45.217]                           }
[13:20:45.217]                         }
[13:20:45.217]                       }
[13:20:45.217]                       invisible(muffled)
[13:20:45.217]                     }
[13:20:45.217]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.217]                   }
[13:20:45.217]                 }
[13:20:45.217]             }
[13:20:45.217]         }))
[13:20:45.217]     }, error = function(ex) {
[13:20:45.217]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.217]                 ...future.rng), started = ...future.startTime, 
[13:20:45.217]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.217]             version = "1.8"), class = "FutureResult")
[13:20:45.217]     }, finally = {
[13:20:45.217]         if (!identical(...future.workdir, getwd())) 
[13:20:45.217]             setwd(...future.workdir)
[13:20:45.217]         {
[13:20:45.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.217]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.217]             }
[13:20:45.217]             base::options(...future.oldOptions)
[13:20:45.217]             if (.Platform$OS.type == "windows") {
[13:20:45.217]                 old_names <- names(...future.oldEnvVars)
[13:20:45.217]                 envs <- base::Sys.getenv()
[13:20:45.217]                 names <- names(envs)
[13:20:45.217]                 common <- intersect(names, old_names)
[13:20:45.217]                 added <- setdiff(names, old_names)
[13:20:45.217]                 removed <- setdiff(old_names, names)
[13:20:45.217]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.217]                   envs[common]]
[13:20:45.217]                 NAMES <- toupper(changed)
[13:20:45.217]                 args <- list()
[13:20:45.217]                 for (kk in seq_along(NAMES)) {
[13:20:45.217]                   name <- changed[[kk]]
[13:20:45.217]                   NAME <- NAMES[[kk]]
[13:20:45.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.217]                     next
[13:20:45.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.217]                 }
[13:20:45.217]                 NAMES <- toupper(added)
[13:20:45.217]                 for (kk in seq_along(NAMES)) {
[13:20:45.217]                   name <- added[[kk]]
[13:20:45.217]                   NAME <- NAMES[[kk]]
[13:20:45.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.217]                     next
[13:20:45.217]                   args[[name]] <- ""
[13:20:45.217]                 }
[13:20:45.217]                 NAMES <- toupper(removed)
[13:20:45.217]                 for (kk in seq_along(NAMES)) {
[13:20:45.217]                   name <- removed[[kk]]
[13:20:45.217]                   NAME <- NAMES[[kk]]
[13:20:45.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.217]                     next
[13:20:45.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.217]                 }
[13:20:45.217]                 if (length(args) > 0) 
[13:20:45.217]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.217]             }
[13:20:45.217]             else {
[13:20:45.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.217]             }
[13:20:45.217]             {
[13:20:45.217]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.217]                   0L) {
[13:20:45.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.217]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.217]                   base::options(opts)
[13:20:45.217]                 }
[13:20:45.217]                 {
[13:20:45.217]                   {
[13:20:45.217]                     NULL
[13:20:45.217]                     RNGkind("Mersenne-Twister")
[13:20:45.217]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:45.217]                       inherits = FALSE)
[13:20:45.217]                   }
[13:20:45.217]                   options(future.plan = NULL)
[13:20:45.217]                   if (is.na(NA_character_)) 
[13:20:45.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.217]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:45.217]                   {
[13:20:45.217]                     future <- SequentialFuture(..., envir = envir)
[13:20:45.217]                     if (!future$lazy) 
[13:20:45.217]                       future <- run(future)
[13:20:45.217]                     invisible(future)
[13:20:45.217]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.217]                 }
[13:20:45.217]             }
[13:20:45.217]         }
[13:20:45.217]     })
[13:20:45.217]     if (TRUE) {
[13:20:45.217]         base::sink(type = "output", split = FALSE)
[13:20:45.217]         if (TRUE) {
[13:20:45.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.217]         }
[13:20:45.217]         else {
[13:20:45.217]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.217]         }
[13:20:45.217]         base::close(...future.stdout)
[13:20:45.217]         ...future.stdout <- NULL
[13:20:45.217]     }
[13:20:45.217]     ...future.result$conditions <- ...future.conditions
[13:20:45.217]     ...future.result$finished <- base::Sys.time()
[13:20:45.217]     ...future.result
[13:20:45.217] }
[13:20:45.218] assign_globals() ...
[13:20:45.218] List of 2
[13:20:45.218]  $ x   : list()
[13:20:45.218]  $ name: chr "a"
[13:20:45.218]  - attr(*, "where")=List of 2
[13:20:45.218]   ..$ x   :<environment: R_EmptyEnv> 
[13:20:45.218]   ..$ name:<environment: R_EmptyEnv> 
[13:20:45.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.218]  - attr(*, "resolved")= logi TRUE
[13:20:45.218]  - attr(*, "total_size")= num 112
[13:20:45.218]  - attr(*, "already-done")= logi TRUE
[13:20:45.221] - copied ‘x’ to environment
[13:20:45.221] - copied ‘name’ to environment
[13:20:45.221] assign_globals() ... done
[13:20:45.222] plan(): Setting new future strategy stack:
[13:20:45.222] List of future strategies:
[13:20:45.222] 1. sequential:
[13:20:45.222]    - args: function (..., envir = parent.frame())
[13:20:45.222]    - tweaked: FALSE
[13:20:45.222]    - call: NULL
[13:20:45.222] plan(): nbrOfWorkers() = 1
[13:20:45.223] plan(): Setting new future strategy stack:
[13:20:45.223] List of future strategies:
[13:20:45.223] 1. sequential:
[13:20:45.223]    - args: function (..., envir = parent.frame())
[13:20:45.223]    - tweaked: FALSE
[13:20:45.223]    - call: plan(strategy)
[13:20:45.223] plan(): nbrOfWorkers() = 1
[13:20:45.223] SequentialFuture started (and completed)
[13:20:45.223] - Launch lazy future ... done
[13:20:45.224] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[13:20:45.235] plan(): Setting new future strategy stack:
[13:20:45.235] List of future strategies:
[13:20:45.235] 1. multicore:
[13:20:45.235]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.235]    - tweaked: FALSE
[13:20:45.235]    - call: plan(strategy)
[13:20:45.238] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.239] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.239] Searching for globals...
[13:20:45.241] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.241] Searching for globals ... DONE
[13:20:45.241] Resolving globals: TRUE
[13:20:45.241] Resolving any globals that are futures ...
[13:20:45.241] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.241] Resolving any globals that are futures ... DONE
[13:20:45.242] Resolving futures part of globals (recursively) ...
[13:20:45.242] resolve() on list ...
[13:20:45.242]  recursive: 99
[13:20:45.242]  length: 1
[13:20:45.242]  elements: ‘x’
[13:20:45.242]  length: 0 (resolved future 1)
[13:20:45.242] resolve() on list ... DONE
[13:20:45.242] - globals: [1] ‘x’
[13:20:45.243] Resolving futures part of globals (recursively) ... DONE
[13:20:45.243] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.243] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.243] - globals: [1] ‘x’
[13:20:45.243] 
[13:20:45.243] getGlobalsAndPackages() ... DONE
[13:20:45.244] run() for ‘Future’ ...
[13:20:45.244] - state: ‘created’
[13:20:45.244] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.247] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.248] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.248]   - Field: ‘label’
[13:20:45.248]   - Field: ‘local’
[13:20:45.248]   - Field: ‘owner’
[13:20:45.248]   - Field: ‘envir’
[13:20:45.248]   - Field: ‘workers’
[13:20:45.248]   - Field: ‘packages’
[13:20:45.248]   - Field: ‘gc’
[13:20:45.248]   - Field: ‘job’
[13:20:45.248]   - Field: ‘conditions’
[13:20:45.249]   - Field: ‘expr’
[13:20:45.249]   - Field: ‘uuid’
[13:20:45.249]   - Field: ‘seed’
[13:20:45.249]   - Field: ‘version’
[13:20:45.249]   - Field: ‘result’
[13:20:45.249]   - Field: ‘asynchronous’
[13:20:45.249]   - Field: ‘calls’
[13:20:45.249]   - Field: ‘globals’
[13:20:45.249]   - Field: ‘stdout’
[13:20:45.249]   - Field: ‘earlySignal’
[13:20:45.250]   - Field: ‘lazy’
[13:20:45.250]   - Field: ‘state’
[13:20:45.250] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.250] - Launch lazy future ...
[13:20:45.251] Packages needed by the future expression (n = 0): <none>
[13:20:45.251] Packages needed by future strategies (n = 0): <none>
[13:20:45.251] {
[13:20:45.251]     {
[13:20:45.251]         {
[13:20:45.251]             ...future.startTime <- base::Sys.time()
[13:20:45.251]             {
[13:20:45.251]                 {
[13:20:45.251]                   {
[13:20:45.251]                     {
[13:20:45.251]                       base::local({
[13:20:45.251]                         has_future <- base::requireNamespace("future", 
[13:20:45.251]                           quietly = TRUE)
[13:20:45.251]                         if (has_future) {
[13:20:45.251]                           ns <- base::getNamespace("future")
[13:20:45.251]                           version <- ns[[".package"]][["version"]]
[13:20:45.251]                           if (is.null(version)) 
[13:20:45.251]                             version <- utils::packageVersion("future")
[13:20:45.251]                         }
[13:20:45.251]                         else {
[13:20:45.251]                           version <- NULL
[13:20:45.251]                         }
[13:20:45.251]                         if (!has_future || version < "1.8.0") {
[13:20:45.251]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.251]                             "", base::R.version$version.string), 
[13:20:45.251]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.251]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.251]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.251]                               "release", "version")], collapse = " "), 
[13:20:45.251]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.251]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.251]                             info)
[13:20:45.251]                           info <- base::paste(info, collapse = "; ")
[13:20:45.251]                           if (!has_future) {
[13:20:45.251]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.251]                               info)
[13:20:45.251]                           }
[13:20:45.251]                           else {
[13:20:45.251]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.251]                               info, version)
[13:20:45.251]                           }
[13:20:45.251]                           base::stop(msg)
[13:20:45.251]                         }
[13:20:45.251]                       })
[13:20:45.251]                     }
[13:20:45.251]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.251]                     base::options(mc.cores = 1L)
[13:20:45.251]                   }
[13:20:45.251]                   options(future.plan = NULL)
[13:20:45.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.251]                 }
[13:20:45.251]                 ...future.workdir <- getwd()
[13:20:45.251]             }
[13:20:45.251]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.251]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.251]         }
[13:20:45.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.251]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.251]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.251]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.251]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.251]             base::names(...future.oldOptions))
[13:20:45.251]     }
[13:20:45.251]     if (FALSE) {
[13:20:45.251]     }
[13:20:45.251]     else {
[13:20:45.251]         if (TRUE) {
[13:20:45.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.251]                 open = "w")
[13:20:45.251]         }
[13:20:45.251]         else {
[13:20:45.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.251]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.251]         }
[13:20:45.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.251]             base::sink(type = "output", split = FALSE)
[13:20:45.251]             base::close(...future.stdout)
[13:20:45.251]         }, add = TRUE)
[13:20:45.251]     }
[13:20:45.251]     ...future.frame <- base::sys.nframe()
[13:20:45.251]     ...future.conditions <- base::list()
[13:20:45.251]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.251]     if (FALSE) {
[13:20:45.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.251]     }
[13:20:45.251]     ...future.result <- base::tryCatch({
[13:20:45.251]         base::withCallingHandlers({
[13:20:45.251]             ...future.value <- base::withVisible(base::local({
[13:20:45.251]                 withCallingHandlers({
[13:20:45.251]                   {
[13:20:45.251]                     x$a <- 1
[13:20:45.251]                     x
[13:20:45.251]                   }
[13:20:45.251]                 }, immediateCondition = function(cond) {
[13:20:45.251]                   save_rds <- function (object, pathname, ...) 
[13:20:45.251]                   {
[13:20:45.251]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.251]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.251]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.251]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.251]                         fi_tmp[["mtime"]])
[13:20:45.251]                     }
[13:20:45.251]                     tryCatch({
[13:20:45.251]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.251]                     }, error = function(ex) {
[13:20:45.251]                       msg <- conditionMessage(ex)
[13:20:45.251]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.251]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.251]                         fi_tmp[["mtime"]], msg)
[13:20:45.251]                       ex$message <- msg
[13:20:45.251]                       stop(ex)
[13:20:45.251]                     })
[13:20:45.251]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.251]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.251]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.251]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.251]                       fi <- file.info(pathname)
[13:20:45.251]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.251]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.251]                         fi[["size"]], fi[["mtime"]])
[13:20:45.251]                       stop(msg)
[13:20:45.251]                     }
[13:20:45.251]                     invisible(pathname)
[13:20:45.251]                   }
[13:20:45.251]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.251]                     rootPath = tempdir()) 
[13:20:45.251]                   {
[13:20:45.251]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.251]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.251]                       tmpdir = path, fileext = ".rds")
[13:20:45.251]                     save_rds(obj, file)
[13:20:45.251]                   }
[13:20:45.251]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.251]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.251]                   {
[13:20:45.251]                     inherits <- base::inherits
[13:20:45.251]                     invokeRestart <- base::invokeRestart
[13:20:45.251]                     is.null <- base::is.null
[13:20:45.251]                     muffled <- FALSE
[13:20:45.251]                     if (inherits(cond, "message")) {
[13:20:45.251]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.251]                       if (muffled) 
[13:20:45.251]                         invokeRestart("muffleMessage")
[13:20:45.251]                     }
[13:20:45.251]                     else if (inherits(cond, "warning")) {
[13:20:45.251]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.251]                       if (muffled) 
[13:20:45.251]                         invokeRestart("muffleWarning")
[13:20:45.251]                     }
[13:20:45.251]                     else if (inherits(cond, "condition")) {
[13:20:45.251]                       if (!is.null(pattern)) {
[13:20:45.251]                         computeRestarts <- base::computeRestarts
[13:20:45.251]                         grepl <- base::grepl
[13:20:45.251]                         restarts <- computeRestarts(cond)
[13:20:45.251]                         for (restart in restarts) {
[13:20:45.251]                           name <- restart$name
[13:20:45.251]                           if (is.null(name)) 
[13:20:45.251]                             next
[13:20:45.251]                           if (!grepl(pattern, name)) 
[13:20:45.251]                             next
[13:20:45.251]                           invokeRestart(restart)
[13:20:45.251]                           muffled <- TRUE
[13:20:45.251]                           break
[13:20:45.251]                         }
[13:20:45.251]                       }
[13:20:45.251]                     }
[13:20:45.251]                     invisible(muffled)
[13:20:45.251]                   }
[13:20:45.251]                   muffleCondition(cond)
[13:20:45.251]                 })
[13:20:45.251]             }))
[13:20:45.251]             future::FutureResult(value = ...future.value$value, 
[13:20:45.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.251]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.251]                     ...future.globalenv.names))
[13:20:45.251]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.251]         }, condition = base::local({
[13:20:45.251]             c <- base::c
[13:20:45.251]             inherits <- base::inherits
[13:20:45.251]             invokeRestart <- base::invokeRestart
[13:20:45.251]             length <- base::length
[13:20:45.251]             list <- base::list
[13:20:45.251]             seq.int <- base::seq.int
[13:20:45.251]             signalCondition <- base::signalCondition
[13:20:45.251]             sys.calls <- base::sys.calls
[13:20:45.251]             `[[` <- base::`[[`
[13:20:45.251]             `+` <- base::`+`
[13:20:45.251]             `<<-` <- base::`<<-`
[13:20:45.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.251]                   3L)]
[13:20:45.251]             }
[13:20:45.251]             function(cond) {
[13:20:45.251]                 is_error <- inherits(cond, "error")
[13:20:45.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.251]                   NULL)
[13:20:45.251]                 if (is_error) {
[13:20:45.251]                   sessionInformation <- function() {
[13:20:45.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.251]                       search = base::search(), system = base::Sys.info())
[13:20:45.251]                   }
[13:20:45.251]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.251]                     cond$call), session = sessionInformation(), 
[13:20:45.251]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.251]                   signalCondition(cond)
[13:20:45.251]                 }
[13:20:45.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.251]                 "immediateCondition"))) {
[13:20:45.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.251]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.251]                   if (TRUE && !signal) {
[13:20:45.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.251]                     {
[13:20:45.251]                       inherits <- base::inherits
[13:20:45.251]                       invokeRestart <- base::invokeRestart
[13:20:45.251]                       is.null <- base::is.null
[13:20:45.251]                       muffled <- FALSE
[13:20:45.251]                       if (inherits(cond, "message")) {
[13:20:45.251]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.251]                         if (muffled) 
[13:20:45.251]                           invokeRestart("muffleMessage")
[13:20:45.251]                       }
[13:20:45.251]                       else if (inherits(cond, "warning")) {
[13:20:45.251]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.251]                         if (muffled) 
[13:20:45.251]                           invokeRestart("muffleWarning")
[13:20:45.251]                       }
[13:20:45.251]                       else if (inherits(cond, "condition")) {
[13:20:45.251]                         if (!is.null(pattern)) {
[13:20:45.251]                           computeRestarts <- base::computeRestarts
[13:20:45.251]                           grepl <- base::grepl
[13:20:45.251]                           restarts <- computeRestarts(cond)
[13:20:45.251]                           for (restart in restarts) {
[13:20:45.251]                             name <- restart$name
[13:20:45.251]                             if (is.null(name)) 
[13:20:45.251]                               next
[13:20:45.251]                             if (!grepl(pattern, name)) 
[13:20:45.251]                               next
[13:20:45.251]                             invokeRestart(restart)
[13:20:45.251]                             muffled <- TRUE
[13:20:45.251]                             break
[13:20:45.251]                           }
[13:20:45.251]                         }
[13:20:45.251]                       }
[13:20:45.251]                       invisible(muffled)
[13:20:45.251]                     }
[13:20:45.251]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.251]                   }
[13:20:45.251]                 }
[13:20:45.251]                 else {
[13:20:45.251]                   if (TRUE) {
[13:20:45.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.251]                     {
[13:20:45.251]                       inherits <- base::inherits
[13:20:45.251]                       invokeRestart <- base::invokeRestart
[13:20:45.251]                       is.null <- base::is.null
[13:20:45.251]                       muffled <- FALSE
[13:20:45.251]                       if (inherits(cond, "message")) {
[13:20:45.251]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.251]                         if (muffled) 
[13:20:45.251]                           invokeRestart("muffleMessage")
[13:20:45.251]                       }
[13:20:45.251]                       else if (inherits(cond, "warning")) {
[13:20:45.251]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.251]                         if (muffled) 
[13:20:45.251]                           invokeRestart("muffleWarning")
[13:20:45.251]                       }
[13:20:45.251]                       else if (inherits(cond, "condition")) {
[13:20:45.251]                         if (!is.null(pattern)) {
[13:20:45.251]                           computeRestarts <- base::computeRestarts
[13:20:45.251]                           grepl <- base::grepl
[13:20:45.251]                           restarts <- computeRestarts(cond)
[13:20:45.251]                           for (restart in restarts) {
[13:20:45.251]                             name <- restart$name
[13:20:45.251]                             if (is.null(name)) 
[13:20:45.251]                               next
[13:20:45.251]                             if (!grepl(pattern, name)) 
[13:20:45.251]                               next
[13:20:45.251]                             invokeRestart(restart)
[13:20:45.251]                             muffled <- TRUE
[13:20:45.251]                             break
[13:20:45.251]                           }
[13:20:45.251]                         }
[13:20:45.251]                       }
[13:20:45.251]                       invisible(muffled)
[13:20:45.251]                     }
[13:20:45.251]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.251]                   }
[13:20:45.251]                 }
[13:20:45.251]             }
[13:20:45.251]         }))
[13:20:45.251]     }, error = function(ex) {
[13:20:45.251]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.251]                 ...future.rng), started = ...future.startTime, 
[13:20:45.251]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.251]             version = "1.8"), class = "FutureResult")
[13:20:45.251]     }, finally = {
[13:20:45.251]         if (!identical(...future.workdir, getwd())) 
[13:20:45.251]             setwd(...future.workdir)
[13:20:45.251]         {
[13:20:45.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.251]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.251]             }
[13:20:45.251]             base::options(...future.oldOptions)
[13:20:45.251]             if (.Platform$OS.type == "windows") {
[13:20:45.251]                 old_names <- names(...future.oldEnvVars)
[13:20:45.251]                 envs <- base::Sys.getenv()
[13:20:45.251]                 names <- names(envs)
[13:20:45.251]                 common <- intersect(names, old_names)
[13:20:45.251]                 added <- setdiff(names, old_names)
[13:20:45.251]                 removed <- setdiff(old_names, names)
[13:20:45.251]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.251]                   envs[common]]
[13:20:45.251]                 NAMES <- toupper(changed)
[13:20:45.251]                 args <- list()
[13:20:45.251]                 for (kk in seq_along(NAMES)) {
[13:20:45.251]                   name <- changed[[kk]]
[13:20:45.251]                   NAME <- NAMES[[kk]]
[13:20:45.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.251]                     next
[13:20:45.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.251]                 }
[13:20:45.251]                 NAMES <- toupper(added)
[13:20:45.251]                 for (kk in seq_along(NAMES)) {
[13:20:45.251]                   name <- added[[kk]]
[13:20:45.251]                   NAME <- NAMES[[kk]]
[13:20:45.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.251]                     next
[13:20:45.251]                   args[[name]] <- ""
[13:20:45.251]                 }
[13:20:45.251]                 NAMES <- toupper(removed)
[13:20:45.251]                 for (kk in seq_along(NAMES)) {
[13:20:45.251]                   name <- removed[[kk]]
[13:20:45.251]                   NAME <- NAMES[[kk]]
[13:20:45.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.251]                     next
[13:20:45.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.251]                 }
[13:20:45.251]                 if (length(args) > 0) 
[13:20:45.251]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.251]             }
[13:20:45.251]             else {
[13:20:45.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.251]             }
[13:20:45.251]             {
[13:20:45.251]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.251]                   0L) {
[13:20:45.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.251]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.251]                   base::options(opts)
[13:20:45.251]                 }
[13:20:45.251]                 {
[13:20:45.251]                   {
[13:20:45.251]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.251]                     NULL
[13:20:45.251]                   }
[13:20:45.251]                   options(future.plan = NULL)
[13:20:45.251]                   if (is.na(NA_character_)) 
[13:20:45.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.251]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.251]                     envir = parent.frame()) 
[13:20:45.251]                   {
[13:20:45.251]                     default_workers <- missing(workers)
[13:20:45.251]                     if (is.function(workers)) 
[13:20:45.251]                       workers <- workers()
[13:20:45.251]                     workers <- structure(as.integer(workers), 
[13:20:45.251]                       class = class(workers))
[13:20:45.251]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.251]                       1L)
[13:20:45.251]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.251]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.251]                       if (default_workers) 
[13:20:45.251]                         supportsMulticore(warn = TRUE)
[13:20:45.251]                       return(sequential(..., envir = envir))
[13:20:45.251]                     }
[13:20:45.251]                     oopts <- options(mc.cores = workers)
[13:20:45.251]                     on.exit(options(oopts))
[13:20:45.251]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.251]                       envir = envir)
[13:20:45.251]                     if (!future$lazy) 
[13:20:45.251]                       future <- run(future)
[13:20:45.251]                     invisible(future)
[13:20:45.251]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.251]                 }
[13:20:45.251]             }
[13:20:45.251]         }
[13:20:45.251]     })
[13:20:45.251]     if (TRUE) {
[13:20:45.251]         base::sink(type = "output", split = FALSE)
[13:20:45.251]         if (TRUE) {
[13:20:45.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.251]         }
[13:20:45.251]         else {
[13:20:45.251]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.251]         }
[13:20:45.251]         base::close(...future.stdout)
[13:20:45.251]         ...future.stdout <- NULL
[13:20:45.251]     }
[13:20:45.251]     ...future.result$conditions <- ...future.conditions
[13:20:45.251]     ...future.result$finished <- base::Sys.time()
[13:20:45.251]     ...future.result
[13:20:45.251] }
[13:20:45.254] assign_globals() ...
[13:20:45.254] List of 1
[13:20:45.254]  $ x: list()
[13:20:45.254]  - attr(*, "where")=List of 1
[13:20:45.254]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.254]  - attr(*, "resolved")= logi TRUE
[13:20:45.254]  - attr(*, "total_size")= num 0
[13:20:45.254]  - attr(*, "already-done")= logi TRUE
[13:20:45.256] - copied ‘x’ to environment
[13:20:45.257] assign_globals() ... done
[13:20:45.257] requestCore(): workers = 2
[13:20:45.259] MulticoreFuture started
[13:20:45.260] - Launch lazy future ... done
[13:20:45.260] run() for ‘MulticoreFuture’ ... done
[13:20:45.260] plan(): Setting new future strategy stack:
[13:20:45.260] List of future strategies:
[13:20:45.260] 1. sequential:
[13:20:45.260]    - args: function (..., envir = parent.frame())
[13:20:45.260]    - tweaked: FALSE
[13:20:45.260]    - call: NULL
[13:20:45.261] plan(): nbrOfWorkers() = 1
[13:20:45.263] plan(): Setting new future strategy stack:
[13:20:45.263] List of future strategies:
[13:20:45.263] 1. multicore:
[13:20:45.263]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.263]    - tweaked: FALSE
[13:20:45.263]    - call: plan(strategy)
[13:20:45.268] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.276] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.276] Searching for globals...
[13:20:45.279] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.279] Searching for globals ... DONE
[13:20:45.279] Resolving globals: TRUE
[13:20:45.280] Resolving any globals that are futures ...
[13:20:45.280] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.280] Resolving any globals that are futures ... DONE
[13:20:45.280] Resolving futures part of globals (recursively) ...
[13:20:45.281] resolve() on list ...
[13:20:45.281]  recursive: 99
[13:20:45.281]  length: 1
[13:20:45.281]  elements: ‘x’
[13:20:45.281]  length: 0 (resolved future 1)
[13:20:45.281] resolve() on list ... DONE
[13:20:45.282] - globals: [1] ‘x’
[13:20:45.282] Resolving futures part of globals (recursively) ... DONE
[13:20:45.282] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.282] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.282] - globals: [1] ‘x’
[13:20:45.283] 
[13:20:45.283] getGlobalsAndPackages() ... DONE
[13:20:45.283] run() for ‘Future’ ...
[13:20:45.283] - state: ‘created’
[13:20:45.283] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.287] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.287] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.288]   - Field: ‘label’
[13:20:45.288]   - Field: ‘local’
[13:20:45.288]   - Field: ‘owner’
[13:20:45.288]   - Field: ‘envir’
[13:20:45.288]   - Field: ‘workers’
[13:20:45.288]   - Field: ‘packages’
[13:20:45.288]   - Field: ‘gc’
[13:20:45.288]   - Field: ‘job’
[13:20:45.289]   - Field: ‘conditions’
[13:20:45.289]   - Field: ‘expr’
[13:20:45.289]   - Field: ‘uuid’
[13:20:45.289]   - Field: ‘seed’
[13:20:45.289]   - Field: ‘version’
[13:20:45.289]   - Field: ‘result’
[13:20:45.289]   - Field: ‘asynchronous’
[13:20:45.289]   - Field: ‘calls’
[13:20:45.290]   - Field: ‘globals’
[13:20:45.290]   - Field: ‘stdout’
[13:20:45.290]   - Field: ‘earlySignal’
[13:20:45.290]   - Field: ‘lazy’
[13:20:45.290]   - Field: ‘state’
[13:20:45.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.290] - Launch lazy future ...
[13:20:45.290] Packages needed by the future expression (n = 0): <none>
[13:20:45.291] Packages needed by future strategies (n = 0): <none>
[13:20:45.291] {
[13:20:45.291]     {
[13:20:45.291]         {
[13:20:45.291]             ...future.startTime <- base::Sys.time()
[13:20:45.291]             {
[13:20:45.291]                 {
[13:20:45.291]                   {
[13:20:45.291]                     {
[13:20:45.291]                       base::local({
[13:20:45.291]                         has_future <- base::requireNamespace("future", 
[13:20:45.291]                           quietly = TRUE)
[13:20:45.291]                         if (has_future) {
[13:20:45.291]                           ns <- base::getNamespace("future")
[13:20:45.291]                           version <- ns[[".package"]][["version"]]
[13:20:45.291]                           if (is.null(version)) 
[13:20:45.291]                             version <- utils::packageVersion("future")
[13:20:45.291]                         }
[13:20:45.291]                         else {
[13:20:45.291]                           version <- NULL
[13:20:45.291]                         }
[13:20:45.291]                         if (!has_future || version < "1.8.0") {
[13:20:45.291]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.291]                             "", base::R.version$version.string), 
[13:20:45.291]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.291]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.291]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.291]                               "release", "version")], collapse = " "), 
[13:20:45.291]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.291]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.291]                             info)
[13:20:45.291]                           info <- base::paste(info, collapse = "; ")
[13:20:45.291]                           if (!has_future) {
[13:20:45.291]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.291]                               info)
[13:20:45.291]                           }
[13:20:45.291]                           else {
[13:20:45.291]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.291]                               info, version)
[13:20:45.291]                           }
[13:20:45.291]                           base::stop(msg)
[13:20:45.291]                         }
[13:20:45.291]                       })
[13:20:45.291]                     }
[13:20:45.291]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.291]                     base::options(mc.cores = 1L)
[13:20:45.291]                   }
[13:20:45.291]                   options(future.plan = NULL)
[13:20:45.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.291]                 }
[13:20:45.291]                 ...future.workdir <- getwd()
[13:20:45.291]             }
[13:20:45.291]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.291]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.291]         }
[13:20:45.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.291]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.291]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.291]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.291]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.291]             base::names(...future.oldOptions))
[13:20:45.291]     }
[13:20:45.291]     if (FALSE) {
[13:20:45.291]     }
[13:20:45.291]     else {
[13:20:45.291]         if (TRUE) {
[13:20:45.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.291]                 open = "w")
[13:20:45.291]         }
[13:20:45.291]         else {
[13:20:45.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.291]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.291]         }
[13:20:45.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.291]             base::sink(type = "output", split = FALSE)
[13:20:45.291]             base::close(...future.stdout)
[13:20:45.291]         }, add = TRUE)
[13:20:45.291]     }
[13:20:45.291]     ...future.frame <- base::sys.nframe()
[13:20:45.291]     ...future.conditions <- base::list()
[13:20:45.291]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.291]     if (FALSE) {
[13:20:45.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.291]     }
[13:20:45.291]     ...future.result <- base::tryCatch({
[13:20:45.291]         base::withCallingHandlers({
[13:20:45.291]             ...future.value <- base::withVisible(base::local({
[13:20:45.291]                 withCallingHandlers({
[13:20:45.291]                   {
[13:20:45.291]                     x$a <- 1
[13:20:45.291]                     x
[13:20:45.291]                   }
[13:20:45.291]                 }, immediateCondition = function(cond) {
[13:20:45.291]                   save_rds <- function (object, pathname, ...) 
[13:20:45.291]                   {
[13:20:45.291]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.291]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.291]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.291]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.291]                         fi_tmp[["mtime"]])
[13:20:45.291]                     }
[13:20:45.291]                     tryCatch({
[13:20:45.291]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.291]                     }, error = function(ex) {
[13:20:45.291]                       msg <- conditionMessage(ex)
[13:20:45.291]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.291]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.291]                         fi_tmp[["mtime"]], msg)
[13:20:45.291]                       ex$message <- msg
[13:20:45.291]                       stop(ex)
[13:20:45.291]                     })
[13:20:45.291]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.291]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.291]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.291]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.291]                       fi <- file.info(pathname)
[13:20:45.291]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.291]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.291]                         fi[["size"]], fi[["mtime"]])
[13:20:45.291]                       stop(msg)
[13:20:45.291]                     }
[13:20:45.291]                     invisible(pathname)
[13:20:45.291]                   }
[13:20:45.291]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.291]                     rootPath = tempdir()) 
[13:20:45.291]                   {
[13:20:45.291]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.291]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.291]                       tmpdir = path, fileext = ".rds")
[13:20:45.291]                     save_rds(obj, file)
[13:20:45.291]                   }
[13:20:45.291]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.291]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.291]                   {
[13:20:45.291]                     inherits <- base::inherits
[13:20:45.291]                     invokeRestart <- base::invokeRestart
[13:20:45.291]                     is.null <- base::is.null
[13:20:45.291]                     muffled <- FALSE
[13:20:45.291]                     if (inherits(cond, "message")) {
[13:20:45.291]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.291]                       if (muffled) 
[13:20:45.291]                         invokeRestart("muffleMessage")
[13:20:45.291]                     }
[13:20:45.291]                     else if (inherits(cond, "warning")) {
[13:20:45.291]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.291]                       if (muffled) 
[13:20:45.291]                         invokeRestart("muffleWarning")
[13:20:45.291]                     }
[13:20:45.291]                     else if (inherits(cond, "condition")) {
[13:20:45.291]                       if (!is.null(pattern)) {
[13:20:45.291]                         computeRestarts <- base::computeRestarts
[13:20:45.291]                         grepl <- base::grepl
[13:20:45.291]                         restarts <- computeRestarts(cond)
[13:20:45.291]                         for (restart in restarts) {
[13:20:45.291]                           name <- restart$name
[13:20:45.291]                           if (is.null(name)) 
[13:20:45.291]                             next
[13:20:45.291]                           if (!grepl(pattern, name)) 
[13:20:45.291]                             next
[13:20:45.291]                           invokeRestart(restart)
[13:20:45.291]                           muffled <- TRUE
[13:20:45.291]                           break
[13:20:45.291]                         }
[13:20:45.291]                       }
[13:20:45.291]                     }
[13:20:45.291]                     invisible(muffled)
[13:20:45.291]                   }
[13:20:45.291]                   muffleCondition(cond)
[13:20:45.291]                 })
[13:20:45.291]             }))
[13:20:45.291]             future::FutureResult(value = ...future.value$value, 
[13:20:45.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.291]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.291]                     ...future.globalenv.names))
[13:20:45.291]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.291]         }, condition = base::local({
[13:20:45.291]             c <- base::c
[13:20:45.291]             inherits <- base::inherits
[13:20:45.291]             invokeRestart <- base::invokeRestart
[13:20:45.291]             length <- base::length
[13:20:45.291]             list <- base::list
[13:20:45.291]             seq.int <- base::seq.int
[13:20:45.291]             signalCondition <- base::signalCondition
[13:20:45.291]             sys.calls <- base::sys.calls
[13:20:45.291]             `[[` <- base::`[[`
[13:20:45.291]             `+` <- base::`+`
[13:20:45.291]             `<<-` <- base::`<<-`
[13:20:45.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.291]                   3L)]
[13:20:45.291]             }
[13:20:45.291]             function(cond) {
[13:20:45.291]                 is_error <- inherits(cond, "error")
[13:20:45.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.291]                   NULL)
[13:20:45.291]                 if (is_error) {
[13:20:45.291]                   sessionInformation <- function() {
[13:20:45.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.291]                       search = base::search(), system = base::Sys.info())
[13:20:45.291]                   }
[13:20:45.291]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.291]                     cond$call), session = sessionInformation(), 
[13:20:45.291]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.291]                   signalCondition(cond)
[13:20:45.291]                 }
[13:20:45.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.291]                 "immediateCondition"))) {
[13:20:45.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.291]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.291]                   if (TRUE && !signal) {
[13:20:45.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.291]                     {
[13:20:45.291]                       inherits <- base::inherits
[13:20:45.291]                       invokeRestart <- base::invokeRestart
[13:20:45.291]                       is.null <- base::is.null
[13:20:45.291]                       muffled <- FALSE
[13:20:45.291]                       if (inherits(cond, "message")) {
[13:20:45.291]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.291]                         if (muffled) 
[13:20:45.291]                           invokeRestart("muffleMessage")
[13:20:45.291]                       }
[13:20:45.291]                       else if (inherits(cond, "warning")) {
[13:20:45.291]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.291]                         if (muffled) 
[13:20:45.291]                           invokeRestart("muffleWarning")
[13:20:45.291]                       }
[13:20:45.291]                       else if (inherits(cond, "condition")) {
[13:20:45.291]                         if (!is.null(pattern)) {
[13:20:45.291]                           computeRestarts <- base::computeRestarts
[13:20:45.291]                           grepl <- base::grepl
[13:20:45.291]                           restarts <- computeRestarts(cond)
[13:20:45.291]                           for (restart in restarts) {
[13:20:45.291]                             name <- restart$name
[13:20:45.291]                             if (is.null(name)) 
[13:20:45.291]                               next
[13:20:45.291]                             if (!grepl(pattern, name)) 
[13:20:45.291]                               next
[13:20:45.291]                             invokeRestart(restart)
[13:20:45.291]                             muffled <- TRUE
[13:20:45.291]                             break
[13:20:45.291]                           }
[13:20:45.291]                         }
[13:20:45.291]                       }
[13:20:45.291]                       invisible(muffled)
[13:20:45.291]                     }
[13:20:45.291]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.291]                   }
[13:20:45.291]                 }
[13:20:45.291]                 else {
[13:20:45.291]                   if (TRUE) {
[13:20:45.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.291]                     {
[13:20:45.291]                       inherits <- base::inherits
[13:20:45.291]                       invokeRestart <- base::invokeRestart
[13:20:45.291]                       is.null <- base::is.null
[13:20:45.291]                       muffled <- FALSE
[13:20:45.291]                       if (inherits(cond, "message")) {
[13:20:45.291]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.291]                         if (muffled) 
[13:20:45.291]                           invokeRestart("muffleMessage")
[13:20:45.291]                       }
[13:20:45.291]                       else if (inherits(cond, "warning")) {
[13:20:45.291]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.291]                         if (muffled) 
[13:20:45.291]                           invokeRestart("muffleWarning")
[13:20:45.291]                       }
[13:20:45.291]                       else if (inherits(cond, "condition")) {
[13:20:45.291]                         if (!is.null(pattern)) {
[13:20:45.291]                           computeRestarts <- base::computeRestarts
[13:20:45.291]                           grepl <- base::grepl
[13:20:45.291]                           restarts <- computeRestarts(cond)
[13:20:45.291]                           for (restart in restarts) {
[13:20:45.291]                             name <- restart$name
[13:20:45.291]                             if (is.null(name)) 
[13:20:45.291]                               next
[13:20:45.291]                             if (!grepl(pattern, name)) 
[13:20:45.291]                               next
[13:20:45.291]                             invokeRestart(restart)
[13:20:45.291]                             muffled <- TRUE
[13:20:45.291]                             break
[13:20:45.291]                           }
[13:20:45.291]                         }
[13:20:45.291]                       }
[13:20:45.291]                       invisible(muffled)
[13:20:45.291]                     }
[13:20:45.291]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.291]                   }
[13:20:45.291]                 }
[13:20:45.291]             }
[13:20:45.291]         }))
[13:20:45.291]     }, error = function(ex) {
[13:20:45.291]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.291]                 ...future.rng), started = ...future.startTime, 
[13:20:45.291]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.291]             version = "1.8"), class = "FutureResult")
[13:20:45.291]     }, finally = {
[13:20:45.291]         if (!identical(...future.workdir, getwd())) 
[13:20:45.291]             setwd(...future.workdir)
[13:20:45.291]         {
[13:20:45.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.291]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.291]             }
[13:20:45.291]             base::options(...future.oldOptions)
[13:20:45.291]             if (.Platform$OS.type == "windows") {
[13:20:45.291]                 old_names <- names(...future.oldEnvVars)
[13:20:45.291]                 envs <- base::Sys.getenv()
[13:20:45.291]                 names <- names(envs)
[13:20:45.291]                 common <- intersect(names, old_names)
[13:20:45.291]                 added <- setdiff(names, old_names)
[13:20:45.291]                 removed <- setdiff(old_names, names)
[13:20:45.291]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.291]                   envs[common]]
[13:20:45.291]                 NAMES <- toupper(changed)
[13:20:45.291]                 args <- list()
[13:20:45.291]                 for (kk in seq_along(NAMES)) {
[13:20:45.291]                   name <- changed[[kk]]
[13:20:45.291]                   NAME <- NAMES[[kk]]
[13:20:45.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.291]                     next
[13:20:45.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.291]                 }
[13:20:45.291]                 NAMES <- toupper(added)
[13:20:45.291]                 for (kk in seq_along(NAMES)) {
[13:20:45.291]                   name <- added[[kk]]
[13:20:45.291]                   NAME <- NAMES[[kk]]
[13:20:45.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.291]                     next
[13:20:45.291]                   args[[name]] <- ""
[13:20:45.291]                 }
[13:20:45.291]                 NAMES <- toupper(removed)
[13:20:45.291]                 for (kk in seq_along(NAMES)) {
[13:20:45.291]                   name <- removed[[kk]]
[13:20:45.291]                   NAME <- NAMES[[kk]]
[13:20:45.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.291]                     next
[13:20:45.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.291]                 }
[13:20:45.291]                 if (length(args) > 0) 
[13:20:45.291]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.291]             }
[13:20:45.291]             else {
[13:20:45.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.291]             }
[13:20:45.291]             {
[13:20:45.291]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.291]                   0L) {
[13:20:45.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.291]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.291]                   base::options(opts)
[13:20:45.291]                 }
[13:20:45.291]                 {
[13:20:45.291]                   {
[13:20:45.291]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.291]                     NULL
[13:20:45.291]                   }
[13:20:45.291]                   options(future.plan = NULL)
[13:20:45.291]                   if (is.na(NA_character_)) 
[13:20:45.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.291]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.291]                     envir = parent.frame()) 
[13:20:45.291]                   {
[13:20:45.291]                     default_workers <- missing(workers)
[13:20:45.291]                     if (is.function(workers)) 
[13:20:45.291]                       workers <- workers()
[13:20:45.291]                     workers <- structure(as.integer(workers), 
[13:20:45.291]                       class = class(workers))
[13:20:45.291]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.291]                       1L)
[13:20:45.291]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.291]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.291]                       if (default_workers) 
[13:20:45.291]                         supportsMulticore(warn = TRUE)
[13:20:45.291]                       return(sequential(..., envir = envir))
[13:20:45.291]                     }
[13:20:45.291]                     oopts <- options(mc.cores = workers)
[13:20:45.291]                     on.exit(options(oopts))
[13:20:45.291]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.291]                       envir = envir)
[13:20:45.291]                     if (!future$lazy) 
[13:20:45.291]                       future <- run(future)
[13:20:45.291]                     invisible(future)
[13:20:45.291]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.291]                 }
[13:20:45.291]             }
[13:20:45.291]         }
[13:20:45.291]     })
[13:20:45.291]     if (TRUE) {
[13:20:45.291]         base::sink(type = "output", split = FALSE)
[13:20:45.291]         if (TRUE) {
[13:20:45.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.291]         }
[13:20:45.291]         else {
[13:20:45.291]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.291]         }
[13:20:45.291]         base::close(...future.stdout)
[13:20:45.291]         ...future.stdout <- NULL
[13:20:45.291]     }
[13:20:45.291]     ...future.result$conditions <- ...future.conditions
[13:20:45.291]     ...future.result$finished <- base::Sys.time()
[13:20:45.291]     ...future.result
[13:20:45.291] }
[13:20:45.294] assign_globals() ...
[13:20:45.294] List of 1
[13:20:45.294]  $ x: list()
[13:20:45.294]  - attr(*, "where")=List of 1
[13:20:45.294]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.294]  - attr(*, "resolved")= logi TRUE
[13:20:45.294]  - attr(*, "total_size")= num 0
[13:20:45.294]  - attr(*, "already-done")= logi TRUE
[13:20:45.296] - copied ‘x’ to environment
[13:20:45.297] assign_globals() ... done
[13:20:45.297] requestCore(): workers = 2
[13:20:45.299] MulticoreFuture started
[13:20:45.299] - Launch lazy future ... done
[13:20:45.299] run() for ‘MulticoreFuture’ ... done
[13:20:45.300] plan(): Setting new future strategy stack:
[13:20:45.300] List of future strategies:
[13:20:45.300] 1. sequential:
[13:20:45.300]    - args: function (..., envir = parent.frame())
[13:20:45.300]    - tweaked: FALSE
[13:20:45.300]    - call: NULL
[13:20:45.301] plan(): nbrOfWorkers() = 1
[13:20:45.303] plan(): Setting new future strategy stack:
[13:20:45.303] List of future strategies:
[13:20:45.303] 1. multicore:
[13:20:45.303]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.303]    - tweaked: FALSE
[13:20:45.303]    - call: plan(strategy)
[13:20:45.308] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.309] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.310] Searching for globals...
[13:20:45.312] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.312] Searching for globals ... DONE
[13:20:45.312] Resolving globals: TRUE
[13:20:45.313] Resolving any globals that are futures ...
[13:20:45.313] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.313] Resolving any globals that are futures ... DONE
[13:20:45.313] Resolving futures part of globals (recursively) ...
[13:20:45.314] resolve() on list ...
[13:20:45.314]  recursive: 99
[13:20:45.314]  length: 1
[13:20:45.314]  elements: ‘x’
[13:20:45.314]  length: 0 (resolved future 1)
[13:20:45.314] resolve() on list ... DONE
[13:20:45.314] - globals: [1] ‘x’
[13:20:45.315] Resolving futures part of globals (recursively) ... DONE
[13:20:45.315] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.315] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.315] - globals: [1] ‘x’
[13:20:45.315] 
[13:20:45.316] getGlobalsAndPackages() ... DONE
[13:20:45.316] run() for ‘Future’ ...
[13:20:45.316] - state: ‘created’
[13:20:45.316] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.320] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.320] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.320]   - Field: ‘label’
[13:20:45.320]   - Field: ‘local’
[13:20:45.321]   - Field: ‘owner’
[13:20:45.321]   - Field: ‘envir’
[13:20:45.321]   - Field: ‘workers’
[13:20:45.321]   - Field: ‘packages’
[13:20:45.321]   - Field: ‘gc’
[13:20:45.321]   - Field: ‘job’
[13:20:45.321]   - Field: ‘conditions’
[13:20:45.324]   - Field: ‘expr’
[13:20:45.324]   - Field: ‘uuid’
[13:20:45.324]   - Field: ‘seed’
[13:20:45.324]   - Field: ‘version’
[13:20:45.324]   - Field: ‘result’
[13:20:45.324]   - Field: ‘asynchronous’
[13:20:45.324]   - Field: ‘calls’
[13:20:45.324]   - Field: ‘globals’
[13:20:45.324]   - Field: ‘stdout’
[13:20:45.325]   - Field: ‘earlySignal’
[13:20:45.325]   - Field: ‘lazy’
[13:20:45.325]   - Field: ‘state’
[13:20:45.325] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.325] - Launch lazy future ...
[13:20:45.326] Packages needed by the future expression (n = 0): <none>
[13:20:45.326] Packages needed by future strategies (n = 0): <none>
[13:20:45.327] {
[13:20:45.327]     {
[13:20:45.327]         {
[13:20:45.327]             ...future.startTime <- base::Sys.time()
[13:20:45.327]             {
[13:20:45.327]                 {
[13:20:45.327]                   {
[13:20:45.327]                     {
[13:20:45.327]                       base::local({
[13:20:45.327]                         has_future <- base::requireNamespace("future", 
[13:20:45.327]                           quietly = TRUE)
[13:20:45.327]                         if (has_future) {
[13:20:45.327]                           ns <- base::getNamespace("future")
[13:20:45.327]                           version <- ns[[".package"]][["version"]]
[13:20:45.327]                           if (is.null(version)) 
[13:20:45.327]                             version <- utils::packageVersion("future")
[13:20:45.327]                         }
[13:20:45.327]                         else {
[13:20:45.327]                           version <- NULL
[13:20:45.327]                         }
[13:20:45.327]                         if (!has_future || version < "1.8.0") {
[13:20:45.327]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.327]                             "", base::R.version$version.string), 
[13:20:45.327]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.327]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.327]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.327]                               "release", "version")], collapse = " "), 
[13:20:45.327]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.327]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.327]                             info)
[13:20:45.327]                           info <- base::paste(info, collapse = "; ")
[13:20:45.327]                           if (!has_future) {
[13:20:45.327]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.327]                               info)
[13:20:45.327]                           }
[13:20:45.327]                           else {
[13:20:45.327]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.327]                               info, version)
[13:20:45.327]                           }
[13:20:45.327]                           base::stop(msg)
[13:20:45.327]                         }
[13:20:45.327]                       })
[13:20:45.327]                     }
[13:20:45.327]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.327]                     base::options(mc.cores = 1L)
[13:20:45.327]                   }
[13:20:45.327]                   options(future.plan = NULL)
[13:20:45.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.327]                 }
[13:20:45.327]                 ...future.workdir <- getwd()
[13:20:45.327]             }
[13:20:45.327]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.327]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.327]         }
[13:20:45.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.327]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.327]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.327]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.327]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.327]             base::names(...future.oldOptions))
[13:20:45.327]     }
[13:20:45.327]     if (FALSE) {
[13:20:45.327]     }
[13:20:45.327]     else {
[13:20:45.327]         if (TRUE) {
[13:20:45.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.327]                 open = "w")
[13:20:45.327]         }
[13:20:45.327]         else {
[13:20:45.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.327]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.327]         }
[13:20:45.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.327]             base::sink(type = "output", split = FALSE)
[13:20:45.327]             base::close(...future.stdout)
[13:20:45.327]         }, add = TRUE)
[13:20:45.327]     }
[13:20:45.327]     ...future.frame <- base::sys.nframe()
[13:20:45.327]     ...future.conditions <- base::list()
[13:20:45.327]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.327]     if (FALSE) {
[13:20:45.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.327]     }
[13:20:45.327]     ...future.result <- base::tryCatch({
[13:20:45.327]         base::withCallingHandlers({
[13:20:45.327]             ...future.value <- base::withVisible(base::local({
[13:20:45.327]                 withCallingHandlers({
[13:20:45.327]                   {
[13:20:45.327]                     x$a <- 1
[13:20:45.327]                     x
[13:20:45.327]                   }
[13:20:45.327]                 }, immediateCondition = function(cond) {
[13:20:45.327]                   save_rds <- function (object, pathname, ...) 
[13:20:45.327]                   {
[13:20:45.327]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.327]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.327]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.327]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.327]                         fi_tmp[["mtime"]])
[13:20:45.327]                     }
[13:20:45.327]                     tryCatch({
[13:20:45.327]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.327]                     }, error = function(ex) {
[13:20:45.327]                       msg <- conditionMessage(ex)
[13:20:45.327]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.327]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.327]                         fi_tmp[["mtime"]], msg)
[13:20:45.327]                       ex$message <- msg
[13:20:45.327]                       stop(ex)
[13:20:45.327]                     })
[13:20:45.327]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.327]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.327]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.327]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.327]                       fi <- file.info(pathname)
[13:20:45.327]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.327]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.327]                         fi[["size"]], fi[["mtime"]])
[13:20:45.327]                       stop(msg)
[13:20:45.327]                     }
[13:20:45.327]                     invisible(pathname)
[13:20:45.327]                   }
[13:20:45.327]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.327]                     rootPath = tempdir()) 
[13:20:45.327]                   {
[13:20:45.327]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.327]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.327]                       tmpdir = path, fileext = ".rds")
[13:20:45.327]                     save_rds(obj, file)
[13:20:45.327]                   }
[13:20:45.327]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.327]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.327]                   {
[13:20:45.327]                     inherits <- base::inherits
[13:20:45.327]                     invokeRestart <- base::invokeRestart
[13:20:45.327]                     is.null <- base::is.null
[13:20:45.327]                     muffled <- FALSE
[13:20:45.327]                     if (inherits(cond, "message")) {
[13:20:45.327]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.327]                       if (muffled) 
[13:20:45.327]                         invokeRestart("muffleMessage")
[13:20:45.327]                     }
[13:20:45.327]                     else if (inherits(cond, "warning")) {
[13:20:45.327]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.327]                       if (muffled) 
[13:20:45.327]                         invokeRestart("muffleWarning")
[13:20:45.327]                     }
[13:20:45.327]                     else if (inherits(cond, "condition")) {
[13:20:45.327]                       if (!is.null(pattern)) {
[13:20:45.327]                         computeRestarts <- base::computeRestarts
[13:20:45.327]                         grepl <- base::grepl
[13:20:45.327]                         restarts <- computeRestarts(cond)
[13:20:45.327]                         for (restart in restarts) {
[13:20:45.327]                           name <- restart$name
[13:20:45.327]                           if (is.null(name)) 
[13:20:45.327]                             next
[13:20:45.327]                           if (!grepl(pattern, name)) 
[13:20:45.327]                             next
[13:20:45.327]                           invokeRestart(restart)
[13:20:45.327]                           muffled <- TRUE
[13:20:45.327]                           break
[13:20:45.327]                         }
[13:20:45.327]                       }
[13:20:45.327]                     }
[13:20:45.327]                     invisible(muffled)
[13:20:45.327]                   }
[13:20:45.327]                   muffleCondition(cond)
[13:20:45.327]                 })
[13:20:45.327]             }))
[13:20:45.327]             future::FutureResult(value = ...future.value$value, 
[13:20:45.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.327]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.327]                     ...future.globalenv.names))
[13:20:45.327]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.327]         }, condition = base::local({
[13:20:45.327]             c <- base::c
[13:20:45.327]             inherits <- base::inherits
[13:20:45.327]             invokeRestart <- base::invokeRestart
[13:20:45.327]             length <- base::length
[13:20:45.327]             list <- base::list
[13:20:45.327]             seq.int <- base::seq.int
[13:20:45.327]             signalCondition <- base::signalCondition
[13:20:45.327]             sys.calls <- base::sys.calls
[13:20:45.327]             `[[` <- base::`[[`
[13:20:45.327]             `+` <- base::`+`
[13:20:45.327]             `<<-` <- base::`<<-`
[13:20:45.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.327]                   3L)]
[13:20:45.327]             }
[13:20:45.327]             function(cond) {
[13:20:45.327]                 is_error <- inherits(cond, "error")
[13:20:45.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.327]                   NULL)
[13:20:45.327]                 if (is_error) {
[13:20:45.327]                   sessionInformation <- function() {
[13:20:45.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.327]                       search = base::search(), system = base::Sys.info())
[13:20:45.327]                   }
[13:20:45.327]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.327]                     cond$call), session = sessionInformation(), 
[13:20:45.327]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.327]                   signalCondition(cond)
[13:20:45.327]                 }
[13:20:45.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.327]                 "immediateCondition"))) {
[13:20:45.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.327]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.327]                   if (TRUE && !signal) {
[13:20:45.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.327]                     {
[13:20:45.327]                       inherits <- base::inherits
[13:20:45.327]                       invokeRestart <- base::invokeRestart
[13:20:45.327]                       is.null <- base::is.null
[13:20:45.327]                       muffled <- FALSE
[13:20:45.327]                       if (inherits(cond, "message")) {
[13:20:45.327]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.327]                         if (muffled) 
[13:20:45.327]                           invokeRestart("muffleMessage")
[13:20:45.327]                       }
[13:20:45.327]                       else if (inherits(cond, "warning")) {
[13:20:45.327]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.327]                         if (muffled) 
[13:20:45.327]                           invokeRestart("muffleWarning")
[13:20:45.327]                       }
[13:20:45.327]                       else if (inherits(cond, "condition")) {
[13:20:45.327]                         if (!is.null(pattern)) {
[13:20:45.327]                           computeRestarts <- base::computeRestarts
[13:20:45.327]                           grepl <- base::grepl
[13:20:45.327]                           restarts <- computeRestarts(cond)
[13:20:45.327]                           for (restart in restarts) {
[13:20:45.327]                             name <- restart$name
[13:20:45.327]                             if (is.null(name)) 
[13:20:45.327]                               next
[13:20:45.327]                             if (!grepl(pattern, name)) 
[13:20:45.327]                               next
[13:20:45.327]                             invokeRestart(restart)
[13:20:45.327]                             muffled <- TRUE
[13:20:45.327]                             break
[13:20:45.327]                           }
[13:20:45.327]                         }
[13:20:45.327]                       }
[13:20:45.327]                       invisible(muffled)
[13:20:45.327]                     }
[13:20:45.327]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.327]                   }
[13:20:45.327]                 }
[13:20:45.327]                 else {
[13:20:45.327]                   if (TRUE) {
[13:20:45.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.327]                     {
[13:20:45.327]                       inherits <- base::inherits
[13:20:45.327]                       invokeRestart <- base::invokeRestart
[13:20:45.327]                       is.null <- base::is.null
[13:20:45.327]                       muffled <- FALSE
[13:20:45.327]                       if (inherits(cond, "message")) {
[13:20:45.327]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.327]                         if (muffled) 
[13:20:45.327]                           invokeRestart("muffleMessage")
[13:20:45.327]                       }
[13:20:45.327]                       else if (inherits(cond, "warning")) {
[13:20:45.327]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.327]                         if (muffled) 
[13:20:45.327]                           invokeRestart("muffleWarning")
[13:20:45.327]                       }
[13:20:45.327]                       else if (inherits(cond, "condition")) {
[13:20:45.327]                         if (!is.null(pattern)) {
[13:20:45.327]                           computeRestarts <- base::computeRestarts
[13:20:45.327]                           grepl <- base::grepl
[13:20:45.327]                           restarts <- computeRestarts(cond)
[13:20:45.327]                           for (restart in restarts) {
[13:20:45.327]                             name <- restart$name
[13:20:45.327]                             if (is.null(name)) 
[13:20:45.327]                               next
[13:20:45.327]                             if (!grepl(pattern, name)) 
[13:20:45.327]                               next
[13:20:45.327]                             invokeRestart(restart)
[13:20:45.327]                             muffled <- TRUE
[13:20:45.327]                             break
[13:20:45.327]                           }
[13:20:45.327]                         }
[13:20:45.327]                       }
[13:20:45.327]                       invisible(muffled)
[13:20:45.327]                     }
[13:20:45.327]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.327]                   }
[13:20:45.327]                 }
[13:20:45.327]             }
[13:20:45.327]         }))
[13:20:45.327]     }, error = function(ex) {
[13:20:45.327]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.327]                 ...future.rng), started = ...future.startTime, 
[13:20:45.327]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.327]             version = "1.8"), class = "FutureResult")
[13:20:45.327]     }, finally = {
[13:20:45.327]         if (!identical(...future.workdir, getwd())) 
[13:20:45.327]             setwd(...future.workdir)
[13:20:45.327]         {
[13:20:45.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.327]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.327]             }
[13:20:45.327]             base::options(...future.oldOptions)
[13:20:45.327]             if (.Platform$OS.type == "windows") {
[13:20:45.327]                 old_names <- names(...future.oldEnvVars)
[13:20:45.327]                 envs <- base::Sys.getenv()
[13:20:45.327]                 names <- names(envs)
[13:20:45.327]                 common <- intersect(names, old_names)
[13:20:45.327]                 added <- setdiff(names, old_names)
[13:20:45.327]                 removed <- setdiff(old_names, names)
[13:20:45.327]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.327]                   envs[common]]
[13:20:45.327]                 NAMES <- toupper(changed)
[13:20:45.327]                 args <- list()
[13:20:45.327]                 for (kk in seq_along(NAMES)) {
[13:20:45.327]                   name <- changed[[kk]]
[13:20:45.327]                   NAME <- NAMES[[kk]]
[13:20:45.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.327]                     next
[13:20:45.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.327]                 }
[13:20:45.327]                 NAMES <- toupper(added)
[13:20:45.327]                 for (kk in seq_along(NAMES)) {
[13:20:45.327]                   name <- added[[kk]]
[13:20:45.327]                   NAME <- NAMES[[kk]]
[13:20:45.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.327]                     next
[13:20:45.327]                   args[[name]] <- ""
[13:20:45.327]                 }
[13:20:45.327]                 NAMES <- toupper(removed)
[13:20:45.327]                 for (kk in seq_along(NAMES)) {
[13:20:45.327]                   name <- removed[[kk]]
[13:20:45.327]                   NAME <- NAMES[[kk]]
[13:20:45.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.327]                     next
[13:20:45.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.327]                 }
[13:20:45.327]                 if (length(args) > 0) 
[13:20:45.327]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.327]             }
[13:20:45.327]             else {
[13:20:45.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.327]             }
[13:20:45.327]             {
[13:20:45.327]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.327]                   0L) {
[13:20:45.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.327]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.327]                   base::options(opts)
[13:20:45.327]                 }
[13:20:45.327]                 {
[13:20:45.327]                   {
[13:20:45.327]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.327]                     NULL
[13:20:45.327]                   }
[13:20:45.327]                   options(future.plan = NULL)
[13:20:45.327]                   if (is.na(NA_character_)) 
[13:20:45.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.327]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.327]                     envir = parent.frame()) 
[13:20:45.327]                   {
[13:20:45.327]                     default_workers <- missing(workers)
[13:20:45.327]                     if (is.function(workers)) 
[13:20:45.327]                       workers <- workers()
[13:20:45.327]                     workers <- structure(as.integer(workers), 
[13:20:45.327]                       class = class(workers))
[13:20:45.327]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.327]                       1L)
[13:20:45.327]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.327]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.327]                       if (default_workers) 
[13:20:45.327]                         supportsMulticore(warn = TRUE)
[13:20:45.327]                       return(sequential(..., envir = envir))
[13:20:45.327]                     }
[13:20:45.327]                     oopts <- options(mc.cores = workers)
[13:20:45.327]                     on.exit(options(oopts))
[13:20:45.327]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.327]                       envir = envir)
[13:20:45.327]                     if (!future$lazy) 
[13:20:45.327]                       future <- run(future)
[13:20:45.327]                     invisible(future)
[13:20:45.327]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.327]                 }
[13:20:45.327]             }
[13:20:45.327]         }
[13:20:45.327]     })
[13:20:45.327]     if (TRUE) {
[13:20:45.327]         base::sink(type = "output", split = FALSE)
[13:20:45.327]         if (TRUE) {
[13:20:45.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.327]         }
[13:20:45.327]         else {
[13:20:45.327]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.327]         }
[13:20:45.327]         base::close(...future.stdout)
[13:20:45.327]         ...future.stdout <- NULL
[13:20:45.327]     }
[13:20:45.327]     ...future.result$conditions <- ...future.conditions
[13:20:45.327]     ...future.result$finished <- base::Sys.time()
[13:20:45.327]     ...future.result
[13:20:45.327] }
[13:20:45.329] assign_globals() ...
[13:20:45.329] List of 1
[13:20:45.329]  $ x: list()
[13:20:45.329]  - attr(*, "where")=List of 1
[13:20:45.329]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.329]  - attr(*, "resolved")= logi TRUE
[13:20:45.329]  - attr(*, "total_size")= num 0
[13:20:45.329]  - attr(*, "already-done")= logi TRUE
[13:20:45.332] - copied ‘x’ to environment
[13:20:45.332] assign_globals() ... done
[13:20:45.332] requestCore(): workers = 2
[13:20:45.334] MulticoreFuture started
[13:20:45.335] - Launch lazy future ... done
[13:20:45.335] run() for ‘MulticoreFuture’ ... done
[13:20:45.335] plan(): Setting new future strategy stack:
[13:20:45.335] List of future strategies:
[13:20:45.335] 1. sequential:
[13:20:45.335]    - args: function (..., envir = parent.frame())
[13:20:45.335]    - tweaked: FALSE
[13:20:45.335]    - call: NULL
[13:20:45.336] plan(): nbrOfWorkers() = 1
[13:20:45.338] plan(): Setting new future strategy stack:
[13:20:45.338] List of future strategies:
[13:20:45.338] 1. multicore:
[13:20:45.338]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.338]    - tweaked: FALSE
[13:20:45.338]    - call: plan(strategy)
[13:20:45.343] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.345] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.345] Searching for globals...
[13:20:45.348] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.348] Searching for globals ... DONE
[13:20:45.348] Resolving globals: TRUE
[13:20:45.348] Resolving any globals that are futures ...
[13:20:45.349] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:45.349] Resolving any globals that are futures ... DONE
[13:20:45.349] Resolving futures part of globals (recursively) ...
[13:20:45.350] resolve() on list ...
[13:20:45.350]  recursive: 99
[13:20:45.350]  length: 1
[13:20:45.350]  elements: ‘x’
[13:20:45.350]  length: 0 (resolved future 1)
[13:20:45.350] resolve() on list ... DONE
[13:20:45.350] - globals: [1] ‘x’
[13:20:45.351] Resolving futures part of globals (recursively) ... DONE
[13:20:45.351] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.351] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.351] - globals: [1] ‘x’
[13:20:45.351] 
[13:20:45.352] getGlobalsAndPackages() ... DONE
[13:20:45.352] run() for ‘Future’ ...
[13:20:45.352] - state: ‘created’
[13:20:45.352] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.356] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.356]   - Field: ‘label’
[13:20:45.357]   - Field: ‘local’
[13:20:45.357]   - Field: ‘owner’
[13:20:45.357]   - Field: ‘envir’
[13:20:45.357]   - Field: ‘workers’
[13:20:45.357]   - Field: ‘packages’
[13:20:45.357]   - Field: ‘gc’
[13:20:45.357]   - Field: ‘job’
[13:20:45.357]   - Field: ‘conditions’
[13:20:45.358]   - Field: ‘expr’
[13:20:45.358]   - Field: ‘uuid’
[13:20:45.358]   - Field: ‘seed’
[13:20:45.358]   - Field: ‘version’
[13:20:45.358]   - Field: ‘result’
[13:20:45.358]   - Field: ‘asynchronous’
[13:20:45.358]   - Field: ‘calls’
[13:20:45.358]   - Field: ‘globals’
[13:20:45.358]   - Field: ‘stdout’
[13:20:45.359]   - Field: ‘earlySignal’
[13:20:45.359]   - Field: ‘lazy’
[13:20:45.359]   - Field: ‘state’
[13:20:45.359] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.359] - Launch lazy future ...
[13:20:45.359] Packages needed by the future expression (n = 0): <none>
[13:20:45.359] Packages needed by future strategies (n = 0): <none>
[13:20:45.360] {
[13:20:45.360]     {
[13:20:45.360]         {
[13:20:45.360]             ...future.startTime <- base::Sys.time()
[13:20:45.360]             {
[13:20:45.360]                 {
[13:20:45.360]                   {
[13:20:45.360]                     {
[13:20:45.360]                       base::local({
[13:20:45.360]                         has_future <- base::requireNamespace("future", 
[13:20:45.360]                           quietly = TRUE)
[13:20:45.360]                         if (has_future) {
[13:20:45.360]                           ns <- base::getNamespace("future")
[13:20:45.360]                           version <- ns[[".package"]][["version"]]
[13:20:45.360]                           if (is.null(version)) 
[13:20:45.360]                             version <- utils::packageVersion("future")
[13:20:45.360]                         }
[13:20:45.360]                         else {
[13:20:45.360]                           version <- NULL
[13:20:45.360]                         }
[13:20:45.360]                         if (!has_future || version < "1.8.0") {
[13:20:45.360]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.360]                             "", base::R.version$version.string), 
[13:20:45.360]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.360]                               "release", "version")], collapse = " "), 
[13:20:45.360]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.360]                             info)
[13:20:45.360]                           info <- base::paste(info, collapse = "; ")
[13:20:45.360]                           if (!has_future) {
[13:20:45.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.360]                               info)
[13:20:45.360]                           }
[13:20:45.360]                           else {
[13:20:45.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.360]                               info, version)
[13:20:45.360]                           }
[13:20:45.360]                           base::stop(msg)
[13:20:45.360]                         }
[13:20:45.360]                       })
[13:20:45.360]                     }
[13:20:45.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.360]                     base::options(mc.cores = 1L)
[13:20:45.360]                   }
[13:20:45.360]                   options(future.plan = NULL)
[13:20:45.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.360]                 }
[13:20:45.360]                 ...future.workdir <- getwd()
[13:20:45.360]             }
[13:20:45.360]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.360]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.360]         }
[13:20:45.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.360]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.360]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.360]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.360]             base::names(...future.oldOptions))
[13:20:45.360]     }
[13:20:45.360]     if (FALSE) {
[13:20:45.360]     }
[13:20:45.360]     else {
[13:20:45.360]         if (TRUE) {
[13:20:45.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.360]                 open = "w")
[13:20:45.360]         }
[13:20:45.360]         else {
[13:20:45.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.360]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.360]         }
[13:20:45.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.360]             base::sink(type = "output", split = FALSE)
[13:20:45.360]             base::close(...future.stdout)
[13:20:45.360]         }, add = TRUE)
[13:20:45.360]     }
[13:20:45.360]     ...future.frame <- base::sys.nframe()
[13:20:45.360]     ...future.conditions <- base::list()
[13:20:45.360]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.360]     if (FALSE) {
[13:20:45.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.360]     }
[13:20:45.360]     ...future.result <- base::tryCatch({
[13:20:45.360]         base::withCallingHandlers({
[13:20:45.360]             ...future.value <- base::withVisible(base::local({
[13:20:45.360]                 withCallingHandlers({
[13:20:45.360]                   {
[13:20:45.360]                     x$a <- 1
[13:20:45.360]                     x
[13:20:45.360]                   }
[13:20:45.360]                 }, immediateCondition = function(cond) {
[13:20:45.360]                   save_rds <- function (object, pathname, ...) 
[13:20:45.360]                   {
[13:20:45.360]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.360]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.360]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.360]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.360]                         fi_tmp[["mtime"]])
[13:20:45.360]                     }
[13:20:45.360]                     tryCatch({
[13:20:45.360]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.360]                     }, error = function(ex) {
[13:20:45.360]                       msg <- conditionMessage(ex)
[13:20:45.360]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.360]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.360]                         fi_tmp[["mtime"]], msg)
[13:20:45.360]                       ex$message <- msg
[13:20:45.360]                       stop(ex)
[13:20:45.360]                     })
[13:20:45.360]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.360]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.360]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.360]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.360]                       fi <- file.info(pathname)
[13:20:45.360]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.360]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.360]                         fi[["size"]], fi[["mtime"]])
[13:20:45.360]                       stop(msg)
[13:20:45.360]                     }
[13:20:45.360]                     invisible(pathname)
[13:20:45.360]                   }
[13:20:45.360]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.360]                     rootPath = tempdir()) 
[13:20:45.360]                   {
[13:20:45.360]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.360]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.360]                       tmpdir = path, fileext = ".rds")
[13:20:45.360]                     save_rds(obj, file)
[13:20:45.360]                   }
[13:20:45.360]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.360]                   {
[13:20:45.360]                     inherits <- base::inherits
[13:20:45.360]                     invokeRestart <- base::invokeRestart
[13:20:45.360]                     is.null <- base::is.null
[13:20:45.360]                     muffled <- FALSE
[13:20:45.360]                     if (inherits(cond, "message")) {
[13:20:45.360]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.360]                       if (muffled) 
[13:20:45.360]                         invokeRestart("muffleMessage")
[13:20:45.360]                     }
[13:20:45.360]                     else if (inherits(cond, "warning")) {
[13:20:45.360]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.360]                       if (muffled) 
[13:20:45.360]                         invokeRestart("muffleWarning")
[13:20:45.360]                     }
[13:20:45.360]                     else if (inherits(cond, "condition")) {
[13:20:45.360]                       if (!is.null(pattern)) {
[13:20:45.360]                         computeRestarts <- base::computeRestarts
[13:20:45.360]                         grepl <- base::grepl
[13:20:45.360]                         restarts <- computeRestarts(cond)
[13:20:45.360]                         for (restart in restarts) {
[13:20:45.360]                           name <- restart$name
[13:20:45.360]                           if (is.null(name)) 
[13:20:45.360]                             next
[13:20:45.360]                           if (!grepl(pattern, name)) 
[13:20:45.360]                             next
[13:20:45.360]                           invokeRestart(restart)
[13:20:45.360]                           muffled <- TRUE
[13:20:45.360]                           break
[13:20:45.360]                         }
[13:20:45.360]                       }
[13:20:45.360]                     }
[13:20:45.360]                     invisible(muffled)
[13:20:45.360]                   }
[13:20:45.360]                   muffleCondition(cond)
[13:20:45.360]                 })
[13:20:45.360]             }))
[13:20:45.360]             future::FutureResult(value = ...future.value$value, 
[13:20:45.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.360]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.360]                     ...future.globalenv.names))
[13:20:45.360]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.360]         }, condition = base::local({
[13:20:45.360]             c <- base::c
[13:20:45.360]             inherits <- base::inherits
[13:20:45.360]             invokeRestart <- base::invokeRestart
[13:20:45.360]             length <- base::length
[13:20:45.360]             list <- base::list
[13:20:45.360]             seq.int <- base::seq.int
[13:20:45.360]             signalCondition <- base::signalCondition
[13:20:45.360]             sys.calls <- base::sys.calls
[13:20:45.360]             `[[` <- base::`[[`
[13:20:45.360]             `+` <- base::`+`
[13:20:45.360]             `<<-` <- base::`<<-`
[13:20:45.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.360]                   3L)]
[13:20:45.360]             }
[13:20:45.360]             function(cond) {
[13:20:45.360]                 is_error <- inherits(cond, "error")
[13:20:45.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.360]                   NULL)
[13:20:45.360]                 if (is_error) {
[13:20:45.360]                   sessionInformation <- function() {
[13:20:45.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.360]                       search = base::search(), system = base::Sys.info())
[13:20:45.360]                   }
[13:20:45.360]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.360]                     cond$call), session = sessionInformation(), 
[13:20:45.360]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.360]                   signalCondition(cond)
[13:20:45.360]                 }
[13:20:45.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.360]                 "immediateCondition"))) {
[13:20:45.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.360]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.360]                   if (TRUE && !signal) {
[13:20:45.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.360]                     {
[13:20:45.360]                       inherits <- base::inherits
[13:20:45.360]                       invokeRestart <- base::invokeRestart
[13:20:45.360]                       is.null <- base::is.null
[13:20:45.360]                       muffled <- FALSE
[13:20:45.360]                       if (inherits(cond, "message")) {
[13:20:45.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.360]                         if (muffled) 
[13:20:45.360]                           invokeRestart("muffleMessage")
[13:20:45.360]                       }
[13:20:45.360]                       else if (inherits(cond, "warning")) {
[13:20:45.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.360]                         if (muffled) 
[13:20:45.360]                           invokeRestart("muffleWarning")
[13:20:45.360]                       }
[13:20:45.360]                       else if (inherits(cond, "condition")) {
[13:20:45.360]                         if (!is.null(pattern)) {
[13:20:45.360]                           computeRestarts <- base::computeRestarts
[13:20:45.360]                           grepl <- base::grepl
[13:20:45.360]                           restarts <- computeRestarts(cond)
[13:20:45.360]                           for (restart in restarts) {
[13:20:45.360]                             name <- restart$name
[13:20:45.360]                             if (is.null(name)) 
[13:20:45.360]                               next
[13:20:45.360]                             if (!grepl(pattern, name)) 
[13:20:45.360]                               next
[13:20:45.360]                             invokeRestart(restart)
[13:20:45.360]                             muffled <- TRUE
[13:20:45.360]                             break
[13:20:45.360]                           }
[13:20:45.360]                         }
[13:20:45.360]                       }
[13:20:45.360]                       invisible(muffled)
[13:20:45.360]                     }
[13:20:45.360]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.360]                   }
[13:20:45.360]                 }
[13:20:45.360]                 else {
[13:20:45.360]                   if (TRUE) {
[13:20:45.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.360]                     {
[13:20:45.360]                       inherits <- base::inherits
[13:20:45.360]                       invokeRestart <- base::invokeRestart
[13:20:45.360]                       is.null <- base::is.null
[13:20:45.360]                       muffled <- FALSE
[13:20:45.360]                       if (inherits(cond, "message")) {
[13:20:45.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.360]                         if (muffled) 
[13:20:45.360]                           invokeRestart("muffleMessage")
[13:20:45.360]                       }
[13:20:45.360]                       else if (inherits(cond, "warning")) {
[13:20:45.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.360]                         if (muffled) 
[13:20:45.360]                           invokeRestart("muffleWarning")
[13:20:45.360]                       }
[13:20:45.360]                       else if (inherits(cond, "condition")) {
[13:20:45.360]                         if (!is.null(pattern)) {
[13:20:45.360]                           computeRestarts <- base::computeRestarts
[13:20:45.360]                           grepl <- base::grepl
[13:20:45.360]                           restarts <- computeRestarts(cond)
[13:20:45.360]                           for (restart in restarts) {
[13:20:45.360]                             name <- restart$name
[13:20:45.360]                             if (is.null(name)) 
[13:20:45.360]                               next
[13:20:45.360]                             if (!grepl(pattern, name)) 
[13:20:45.360]                               next
[13:20:45.360]                             invokeRestart(restart)
[13:20:45.360]                             muffled <- TRUE
[13:20:45.360]                             break
[13:20:45.360]                           }
[13:20:45.360]                         }
[13:20:45.360]                       }
[13:20:45.360]                       invisible(muffled)
[13:20:45.360]                     }
[13:20:45.360]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.360]                   }
[13:20:45.360]                 }
[13:20:45.360]             }
[13:20:45.360]         }))
[13:20:45.360]     }, error = function(ex) {
[13:20:45.360]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.360]                 ...future.rng), started = ...future.startTime, 
[13:20:45.360]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.360]             version = "1.8"), class = "FutureResult")
[13:20:45.360]     }, finally = {
[13:20:45.360]         if (!identical(...future.workdir, getwd())) 
[13:20:45.360]             setwd(...future.workdir)
[13:20:45.360]         {
[13:20:45.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.360]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.360]             }
[13:20:45.360]             base::options(...future.oldOptions)
[13:20:45.360]             if (.Platform$OS.type == "windows") {
[13:20:45.360]                 old_names <- names(...future.oldEnvVars)
[13:20:45.360]                 envs <- base::Sys.getenv()
[13:20:45.360]                 names <- names(envs)
[13:20:45.360]                 common <- intersect(names, old_names)
[13:20:45.360]                 added <- setdiff(names, old_names)
[13:20:45.360]                 removed <- setdiff(old_names, names)
[13:20:45.360]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.360]                   envs[common]]
[13:20:45.360]                 NAMES <- toupper(changed)
[13:20:45.360]                 args <- list()
[13:20:45.360]                 for (kk in seq_along(NAMES)) {
[13:20:45.360]                   name <- changed[[kk]]
[13:20:45.360]                   NAME <- NAMES[[kk]]
[13:20:45.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.360]                     next
[13:20:45.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.360]                 }
[13:20:45.360]                 NAMES <- toupper(added)
[13:20:45.360]                 for (kk in seq_along(NAMES)) {
[13:20:45.360]                   name <- added[[kk]]
[13:20:45.360]                   NAME <- NAMES[[kk]]
[13:20:45.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.360]                     next
[13:20:45.360]                   args[[name]] <- ""
[13:20:45.360]                 }
[13:20:45.360]                 NAMES <- toupper(removed)
[13:20:45.360]                 for (kk in seq_along(NAMES)) {
[13:20:45.360]                   name <- removed[[kk]]
[13:20:45.360]                   NAME <- NAMES[[kk]]
[13:20:45.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.360]                     next
[13:20:45.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.360]                 }
[13:20:45.360]                 if (length(args) > 0) 
[13:20:45.360]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.360]             }
[13:20:45.360]             else {
[13:20:45.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.360]             }
[13:20:45.360]             {
[13:20:45.360]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.360]                   0L) {
[13:20:45.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.360]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.360]                   base::options(opts)
[13:20:45.360]                 }
[13:20:45.360]                 {
[13:20:45.360]                   {
[13:20:45.360]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.360]                     NULL
[13:20:45.360]                   }
[13:20:45.360]                   options(future.plan = NULL)
[13:20:45.360]                   if (is.na(NA_character_)) 
[13:20:45.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.360]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.360]                     envir = parent.frame()) 
[13:20:45.360]                   {
[13:20:45.360]                     default_workers <- missing(workers)
[13:20:45.360]                     if (is.function(workers)) 
[13:20:45.360]                       workers <- workers()
[13:20:45.360]                     workers <- structure(as.integer(workers), 
[13:20:45.360]                       class = class(workers))
[13:20:45.360]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.360]                       1L)
[13:20:45.360]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.360]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.360]                       if (default_workers) 
[13:20:45.360]                         supportsMulticore(warn = TRUE)
[13:20:45.360]                       return(sequential(..., envir = envir))
[13:20:45.360]                     }
[13:20:45.360]                     oopts <- options(mc.cores = workers)
[13:20:45.360]                     on.exit(options(oopts))
[13:20:45.360]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.360]                       envir = envir)
[13:20:45.360]                     if (!future$lazy) 
[13:20:45.360]                       future <- run(future)
[13:20:45.360]                     invisible(future)
[13:20:45.360]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.360]                 }
[13:20:45.360]             }
[13:20:45.360]         }
[13:20:45.360]     })
[13:20:45.360]     if (TRUE) {
[13:20:45.360]         base::sink(type = "output", split = FALSE)
[13:20:45.360]         if (TRUE) {
[13:20:45.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.360]         }
[13:20:45.360]         else {
[13:20:45.360]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.360]         }
[13:20:45.360]         base::close(...future.stdout)
[13:20:45.360]         ...future.stdout <- NULL
[13:20:45.360]     }
[13:20:45.360]     ...future.result$conditions <- ...future.conditions
[13:20:45.360]     ...future.result$finished <- base::Sys.time()
[13:20:45.360]     ...future.result
[13:20:45.360] }
[13:20:45.363] assign_globals() ...
[13:20:45.363] List of 1
[13:20:45.363]  $ x: list()
[13:20:45.363]  - attr(*, "where")=List of 1
[13:20:45.363]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.363]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.363]  - attr(*, "resolved")= logi TRUE
[13:20:45.363]  - attr(*, "total_size")= num 0
[13:20:45.363]  - attr(*, "already-done")= logi TRUE
[13:20:45.366] - copied ‘x’ to environment
[13:20:45.366] assign_globals() ... done
[13:20:45.366] requestCore(): workers = 2
[13:20:45.368] MulticoreFuture started
[13:20:45.368] - Launch lazy future ... done
[13:20:45.368] run() for ‘MulticoreFuture’ ... done
[13:20:45.369] plan(): Setting new future strategy stack:
[13:20:45.369] List of future strategies:
[13:20:45.369] 1. sequential:
[13:20:45.369]    - args: function (..., envir = parent.frame())
[13:20:45.369]    - tweaked: FALSE
[13:20:45.369]    - call: NULL
[13:20:45.370] plan(): nbrOfWorkers() = 1
[13:20:45.372] plan(): Setting new future strategy stack:
[13:20:45.372] List of future strategies:
[13:20:45.372] 1. multicore:
[13:20:45.372]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.372]    - tweaked: FALSE
[13:20:45.372]    - call: plan(strategy)
[13:20:45.377] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.379] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.379] Searching for globals...
[13:20:45.386] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:20:45.386] Searching for globals ... DONE
[13:20:45.386] Resolving globals: TRUE
[13:20:45.386] Resolving any globals that are futures ...
[13:20:45.386] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:20:45.387] Resolving any globals that are futures ... DONE
[13:20:45.387] 
[13:20:45.387] 
[13:20:45.387] getGlobalsAndPackages() ... DONE
[13:20:45.388] run() for ‘Future’ ...
[13:20:45.388] - state: ‘created’
[13:20:45.388] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.392] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.392]   - Field: ‘label’
[13:20:45.392]   - Field: ‘local’
[13:20:45.393]   - Field: ‘owner’
[13:20:45.393]   - Field: ‘envir’
[13:20:45.393]   - Field: ‘workers’
[13:20:45.393]   - Field: ‘packages’
[13:20:45.393]   - Field: ‘gc’
[13:20:45.394]   - Field: ‘job’
[13:20:45.394]   - Field: ‘conditions’
[13:20:45.394]   - Field: ‘expr’
[13:20:45.394]   - Field: ‘uuid’
[13:20:45.394]   - Field: ‘seed’
[13:20:45.394]   - Field: ‘version’
[13:20:45.394]   - Field: ‘result’
[13:20:45.394]   - Field: ‘asynchronous’
[13:20:45.394]   - Field: ‘calls’
[13:20:45.395]   - Field: ‘globals’
[13:20:45.395]   - Field: ‘stdout’
[13:20:45.395]   - Field: ‘earlySignal’
[13:20:45.395]   - Field: ‘lazy’
[13:20:45.395]   - Field: ‘state’
[13:20:45.395] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.396] - Launch lazy future ...
[13:20:45.396] Packages needed by the future expression (n = 0): <none>
[13:20:45.396] Packages needed by future strategies (n = 0): <none>
[13:20:45.397] {
[13:20:45.397]     {
[13:20:45.397]         {
[13:20:45.397]             ...future.startTime <- base::Sys.time()
[13:20:45.397]             {
[13:20:45.397]                 {
[13:20:45.397]                   {
[13:20:45.397]                     {
[13:20:45.397]                       base::local({
[13:20:45.397]                         has_future <- base::requireNamespace("future", 
[13:20:45.397]                           quietly = TRUE)
[13:20:45.397]                         if (has_future) {
[13:20:45.397]                           ns <- base::getNamespace("future")
[13:20:45.397]                           version <- ns[[".package"]][["version"]]
[13:20:45.397]                           if (is.null(version)) 
[13:20:45.397]                             version <- utils::packageVersion("future")
[13:20:45.397]                         }
[13:20:45.397]                         else {
[13:20:45.397]                           version <- NULL
[13:20:45.397]                         }
[13:20:45.397]                         if (!has_future || version < "1.8.0") {
[13:20:45.397]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.397]                             "", base::R.version$version.string), 
[13:20:45.397]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.397]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.397]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.397]                               "release", "version")], collapse = " "), 
[13:20:45.397]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.397]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.397]                             info)
[13:20:45.397]                           info <- base::paste(info, collapse = "; ")
[13:20:45.397]                           if (!has_future) {
[13:20:45.397]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.397]                               info)
[13:20:45.397]                           }
[13:20:45.397]                           else {
[13:20:45.397]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.397]                               info, version)
[13:20:45.397]                           }
[13:20:45.397]                           base::stop(msg)
[13:20:45.397]                         }
[13:20:45.397]                       })
[13:20:45.397]                     }
[13:20:45.397]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.397]                     base::options(mc.cores = 1L)
[13:20:45.397]                   }
[13:20:45.397]                   options(future.plan = NULL)
[13:20:45.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.397]                 }
[13:20:45.397]                 ...future.workdir <- getwd()
[13:20:45.397]             }
[13:20:45.397]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.397]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.397]         }
[13:20:45.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.397]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.397]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.397]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.397]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.397]             base::names(...future.oldOptions))
[13:20:45.397]     }
[13:20:45.397]     if (FALSE) {
[13:20:45.397]     }
[13:20:45.397]     else {
[13:20:45.397]         if (TRUE) {
[13:20:45.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.397]                 open = "w")
[13:20:45.397]         }
[13:20:45.397]         else {
[13:20:45.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.397]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.397]         }
[13:20:45.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.397]             base::sink(type = "output", split = FALSE)
[13:20:45.397]             base::close(...future.stdout)
[13:20:45.397]         }, add = TRUE)
[13:20:45.397]     }
[13:20:45.397]     ...future.frame <- base::sys.nframe()
[13:20:45.397]     ...future.conditions <- base::list()
[13:20:45.397]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.397]     if (FALSE) {
[13:20:45.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.397]     }
[13:20:45.397]     ...future.result <- base::tryCatch({
[13:20:45.397]         base::withCallingHandlers({
[13:20:45.397]             ...future.value <- base::withVisible(base::local({
[13:20:45.397]                 withCallingHandlers({
[13:20:45.397]                   {
[13:20:45.397]                     x <- list(b = 2)
[13:20:45.397]                     x$a <- 1
[13:20:45.397]                     x
[13:20:45.397]                   }
[13:20:45.397]                 }, immediateCondition = function(cond) {
[13:20:45.397]                   save_rds <- function (object, pathname, ...) 
[13:20:45.397]                   {
[13:20:45.397]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.397]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.397]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.397]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.397]                         fi_tmp[["mtime"]])
[13:20:45.397]                     }
[13:20:45.397]                     tryCatch({
[13:20:45.397]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.397]                     }, error = function(ex) {
[13:20:45.397]                       msg <- conditionMessage(ex)
[13:20:45.397]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.397]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.397]                         fi_tmp[["mtime"]], msg)
[13:20:45.397]                       ex$message <- msg
[13:20:45.397]                       stop(ex)
[13:20:45.397]                     })
[13:20:45.397]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.397]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.397]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.397]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.397]                       fi <- file.info(pathname)
[13:20:45.397]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.397]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.397]                         fi[["size"]], fi[["mtime"]])
[13:20:45.397]                       stop(msg)
[13:20:45.397]                     }
[13:20:45.397]                     invisible(pathname)
[13:20:45.397]                   }
[13:20:45.397]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.397]                     rootPath = tempdir()) 
[13:20:45.397]                   {
[13:20:45.397]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.397]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.397]                       tmpdir = path, fileext = ".rds")
[13:20:45.397]                     save_rds(obj, file)
[13:20:45.397]                   }
[13:20:45.397]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.397]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.397]                   {
[13:20:45.397]                     inherits <- base::inherits
[13:20:45.397]                     invokeRestart <- base::invokeRestart
[13:20:45.397]                     is.null <- base::is.null
[13:20:45.397]                     muffled <- FALSE
[13:20:45.397]                     if (inherits(cond, "message")) {
[13:20:45.397]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.397]                       if (muffled) 
[13:20:45.397]                         invokeRestart("muffleMessage")
[13:20:45.397]                     }
[13:20:45.397]                     else if (inherits(cond, "warning")) {
[13:20:45.397]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.397]                       if (muffled) 
[13:20:45.397]                         invokeRestart("muffleWarning")
[13:20:45.397]                     }
[13:20:45.397]                     else if (inherits(cond, "condition")) {
[13:20:45.397]                       if (!is.null(pattern)) {
[13:20:45.397]                         computeRestarts <- base::computeRestarts
[13:20:45.397]                         grepl <- base::grepl
[13:20:45.397]                         restarts <- computeRestarts(cond)
[13:20:45.397]                         for (restart in restarts) {
[13:20:45.397]                           name <- restart$name
[13:20:45.397]                           if (is.null(name)) 
[13:20:45.397]                             next
[13:20:45.397]                           if (!grepl(pattern, name)) 
[13:20:45.397]                             next
[13:20:45.397]                           invokeRestart(restart)
[13:20:45.397]                           muffled <- TRUE
[13:20:45.397]                           break
[13:20:45.397]                         }
[13:20:45.397]                       }
[13:20:45.397]                     }
[13:20:45.397]                     invisible(muffled)
[13:20:45.397]                   }
[13:20:45.397]                   muffleCondition(cond)
[13:20:45.397]                 })
[13:20:45.397]             }))
[13:20:45.397]             future::FutureResult(value = ...future.value$value, 
[13:20:45.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.397]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.397]                     ...future.globalenv.names))
[13:20:45.397]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.397]         }, condition = base::local({
[13:20:45.397]             c <- base::c
[13:20:45.397]             inherits <- base::inherits
[13:20:45.397]             invokeRestart <- base::invokeRestart
[13:20:45.397]             length <- base::length
[13:20:45.397]             list <- base::list
[13:20:45.397]             seq.int <- base::seq.int
[13:20:45.397]             signalCondition <- base::signalCondition
[13:20:45.397]             sys.calls <- base::sys.calls
[13:20:45.397]             `[[` <- base::`[[`
[13:20:45.397]             `+` <- base::`+`
[13:20:45.397]             `<<-` <- base::`<<-`
[13:20:45.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.397]                   3L)]
[13:20:45.397]             }
[13:20:45.397]             function(cond) {
[13:20:45.397]                 is_error <- inherits(cond, "error")
[13:20:45.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.397]                   NULL)
[13:20:45.397]                 if (is_error) {
[13:20:45.397]                   sessionInformation <- function() {
[13:20:45.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.397]                       search = base::search(), system = base::Sys.info())
[13:20:45.397]                   }
[13:20:45.397]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.397]                     cond$call), session = sessionInformation(), 
[13:20:45.397]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.397]                   signalCondition(cond)
[13:20:45.397]                 }
[13:20:45.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.397]                 "immediateCondition"))) {
[13:20:45.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.397]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.397]                   if (TRUE && !signal) {
[13:20:45.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.397]                     {
[13:20:45.397]                       inherits <- base::inherits
[13:20:45.397]                       invokeRestart <- base::invokeRestart
[13:20:45.397]                       is.null <- base::is.null
[13:20:45.397]                       muffled <- FALSE
[13:20:45.397]                       if (inherits(cond, "message")) {
[13:20:45.397]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.397]                         if (muffled) 
[13:20:45.397]                           invokeRestart("muffleMessage")
[13:20:45.397]                       }
[13:20:45.397]                       else if (inherits(cond, "warning")) {
[13:20:45.397]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.397]                         if (muffled) 
[13:20:45.397]                           invokeRestart("muffleWarning")
[13:20:45.397]                       }
[13:20:45.397]                       else if (inherits(cond, "condition")) {
[13:20:45.397]                         if (!is.null(pattern)) {
[13:20:45.397]                           computeRestarts <- base::computeRestarts
[13:20:45.397]                           grepl <- base::grepl
[13:20:45.397]                           restarts <- computeRestarts(cond)
[13:20:45.397]                           for (restart in restarts) {
[13:20:45.397]                             name <- restart$name
[13:20:45.397]                             if (is.null(name)) 
[13:20:45.397]                               next
[13:20:45.397]                             if (!grepl(pattern, name)) 
[13:20:45.397]                               next
[13:20:45.397]                             invokeRestart(restart)
[13:20:45.397]                             muffled <- TRUE
[13:20:45.397]                             break
[13:20:45.397]                           }
[13:20:45.397]                         }
[13:20:45.397]                       }
[13:20:45.397]                       invisible(muffled)
[13:20:45.397]                     }
[13:20:45.397]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.397]                   }
[13:20:45.397]                 }
[13:20:45.397]                 else {
[13:20:45.397]                   if (TRUE) {
[13:20:45.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.397]                     {
[13:20:45.397]                       inherits <- base::inherits
[13:20:45.397]                       invokeRestart <- base::invokeRestart
[13:20:45.397]                       is.null <- base::is.null
[13:20:45.397]                       muffled <- FALSE
[13:20:45.397]                       if (inherits(cond, "message")) {
[13:20:45.397]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.397]                         if (muffled) 
[13:20:45.397]                           invokeRestart("muffleMessage")
[13:20:45.397]                       }
[13:20:45.397]                       else if (inherits(cond, "warning")) {
[13:20:45.397]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.397]                         if (muffled) 
[13:20:45.397]                           invokeRestart("muffleWarning")
[13:20:45.397]                       }
[13:20:45.397]                       else if (inherits(cond, "condition")) {
[13:20:45.397]                         if (!is.null(pattern)) {
[13:20:45.397]                           computeRestarts <- base::computeRestarts
[13:20:45.397]                           grepl <- base::grepl
[13:20:45.397]                           restarts <- computeRestarts(cond)
[13:20:45.397]                           for (restart in restarts) {
[13:20:45.397]                             name <- restart$name
[13:20:45.397]                             if (is.null(name)) 
[13:20:45.397]                               next
[13:20:45.397]                             if (!grepl(pattern, name)) 
[13:20:45.397]                               next
[13:20:45.397]                             invokeRestart(restart)
[13:20:45.397]                             muffled <- TRUE
[13:20:45.397]                             break
[13:20:45.397]                           }
[13:20:45.397]                         }
[13:20:45.397]                       }
[13:20:45.397]                       invisible(muffled)
[13:20:45.397]                     }
[13:20:45.397]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.397]                   }
[13:20:45.397]                 }
[13:20:45.397]             }
[13:20:45.397]         }))
[13:20:45.397]     }, error = function(ex) {
[13:20:45.397]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.397]                 ...future.rng), started = ...future.startTime, 
[13:20:45.397]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.397]             version = "1.8"), class = "FutureResult")
[13:20:45.397]     }, finally = {
[13:20:45.397]         if (!identical(...future.workdir, getwd())) 
[13:20:45.397]             setwd(...future.workdir)
[13:20:45.397]         {
[13:20:45.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.397]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.397]             }
[13:20:45.397]             base::options(...future.oldOptions)
[13:20:45.397]             if (.Platform$OS.type == "windows") {
[13:20:45.397]                 old_names <- names(...future.oldEnvVars)
[13:20:45.397]                 envs <- base::Sys.getenv()
[13:20:45.397]                 names <- names(envs)
[13:20:45.397]                 common <- intersect(names, old_names)
[13:20:45.397]                 added <- setdiff(names, old_names)
[13:20:45.397]                 removed <- setdiff(old_names, names)
[13:20:45.397]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.397]                   envs[common]]
[13:20:45.397]                 NAMES <- toupper(changed)
[13:20:45.397]                 args <- list()
[13:20:45.397]                 for (kk in seq_along(NAMES)) {
[13:20:45.397]                   name <- changed[[kk]]
[13:20:45.397]                   NAME <- NAMES[[kk]]
[13:20:45.397]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.397]                     next
[13:20:45.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.397]                 }
[13:20:45.397]                 NAMES <- toupper(added)
[13:20:45.397]                 for (kk in seq_along(NAMES)) {
[13:20:45.397]                   name <- added[[kk]]
[13:20:45.397]                   NAME <- NAMES[[kk]]
[13:20:45.397]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.397]                     next
[13:20:45.397]                   args[[name]] <- ""
[13:20:45.397]                 }
[13:20:45.397]                 NAMES <- toupper(removed)
[13:20:45.397]                 for (kk in seq_along(NAMES)) {
[13:20:45.397]                   name <- removed[[kk]]
[13:20:45.397]                   NAME <- NAMES[[kk]]
[13:20:45.397]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.397]                     next
[13:20:45.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.397]                 }
[13:20:45.397]                 if (length(args) > 0) 
[13:20:45.397]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.397]             }
[13:20:45.397]             else {
[13:20:45.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.397]             }
[13:20:45.397]             {
[13:20:45.397]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.397]                   0L) {
[13:20:45.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.397]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.397]                   base::options(opts)
[13:20:45.397]                 }
[13:20:45.397]                 {
[13:20:45.397]                   {
[13:20:45.397]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.397]                     NULL
[13:20:45.397]                   }
[13:20:45.397]                   options(future.plan = NULL)
[13:20:45.397]                   if (is.na(NA_character_)) 
[13:20:45.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.397]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.397]                     envir = parent.frame()) 
[13:20:45.397]                   {
[13:20:45.397]                     default_workers <- missing(workers)
[13:20:45.397]                     if (is.function(workers)) 
[13:20:45.397]                       workers <- workers()
[13:20:45.397]                     workers <- structure(as.integer(workers), 
[13:20:45.397]                       class = class(workers))
[13:20:45.397]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.397]                       1L)
[13:20:45.397]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.397]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.397]                       if (default_workers) 
[13:20:45.397]                         supportsMulticore(warn = TRUE)
[13:20:45.397]                       return(sequential(..., envir = envir))
[13:20:45.397]                     }
[13:20:45.397]                     oopts <- options(mc.cores = workers)
[13:20:45.397]                     on.exit(options(oopts))
[13:20:45.397]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.397]                       envir = envir)
[13:20:45.397]                     if (!future$lazy) 
[13:20:45.397]                       future <- run(future)
[13:20:45.397]                     invisible(future)
[13:20:45.397]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.397]                 }
[13:20:45.397]             }
[13:20:45.397]         }
[13:20:45.397]     })
[13:20:45.397]     if (TRUE) {
[13:20:45.397]         base::sink(type = "output", split = FALSE)
[13:20:45.397]         if (TRUE) {
[13:20:45.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.397]         }
[13:20:45.397]         else {
[13:20:45.397]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.397]         }
[13:20:45.397]         base::close(...future.stdout)
[13:20:45.397]         ...future.stdout <- NULL
[13:20:45.397]     }
[13:20:45.397]     ...future.result$conditions <- ...future.conditions
[13:20:45.397]     ...future.result$finished <- base::Sys.time()
[13:20:45.397]     ...future.result
[13:20:45.397] }
[13:20:45.400] requestCore(): workers = 2
[13:20:45.402] MulticoreFuture started
[13:20:45.402] - Launch lazy future ... done
[13:20:45.403] run() for ‘MulticoreFuture’ ... done
[13:20:45.403] plan(): Setting new future strategy stack:
[13:20:45.403] List of future strategies:
[13:20:45.403] 1. sequential:
[13:20:45.403]    - args: function (..., envir = parent.frame())
[13:20:45.403]    - tweaked: FALSE
[13:20:45.403]    - call: NULL
[13:20:45.404] plan(): nbrOfWorkers() = 1
[13:20:45.406] plan(): Setting new future strategy stack:
[13:20:45.406] List of future strategies:
[13:20:45.406] 1. multicore:
[13:20:45.406]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.406]    - tweaked: FALSE
[13:20:45.406]    - call: plan(strategy)
[13:20:45.412] plan(): nbrOfWorkers() = 2
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.413] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.414] Searching for globals...
[13:20:45.417] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.417] Searching for globals ... DONE
[13:20:45.417] Resolving globals: TRUE
[13:20:45.417] Resolving any globals that are futures ...
[13:20:45.417] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.417] Resolving any globals that are futures ... DONE
[13:20:45.418] Resolving futures part of globals (recursively) ...
[13:20:45.418] resolve() on list ...
[13:20:45.418]  recursive: 99
[13:20:45.418]  length: 1
[13:20:45.418]  elements: ‘x’
[13:20:45.419]  length: 0 (resolved future 1)
[13:20:45.419] resolve() on list ... DONE
[13:20:45.419] - globals: [1] ‘x’
[13:20:45.419] Resolving futures part of globals (recursively) ... DONE
[13:20:45.419] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.420] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.420] - globals: [1] ‘x’
[13:20:45.420] 
[13:20:45.420] getGlobalsAndPackages() ... DONE
[13:20:45.420] run() for ‘Future’ ...
[13:20:45.420] - state: ‘created’
[13:20:45.421] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.425] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.425] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.425]   - Field: ‘label’
[13:20:45.425]   - Field: ‘local’
[13:20:45.425]   - Field: ‘owner’
[13:20:45.425]   - Field: ‘envir’
[13:20:45.425]   - Field: ‘workers’
[13:20:45.426]   - Field: ‘packages’
[13:20:45.426]   - Field: ‘gc’
[13:20:45.426]   - Field: ‘job’
[13:20:45.426]   - Field: ‘conditions’
[13:20:45.426]   - Field: ‘expr’
[13:20:45.426]   - Field: ‘uuid’
[13:20:45.426]   - Field: ‘seed’
[13:20:45.426]   - Field: ‘version’
[13:20:45.426]   - Field: ‘result’
[13:20:45.427]   - Field: ‘asynchronous’
[13:20:45.427]   - Field: ‘calls’
[13:20:45.427]   - Field: ‘globals’
[13:20:45.427]   - Field: ‘stdout’
[13:20:45.427]   - Field: ‘earlySignal’
[13:20:45.427]   - Field: ‘lazy’
[13:20:45.427]   - Field: ‘state’
[13:20:45.427] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.427] - Launch lazy future ...
[13:20:45.428] Packages needed by the future expression (n = 0): <none>
[13:20:45.428] Packages needed by future strategies (n = 0): <none>
[13:20:45.428] {
[13:20:45.428]     {
[13:20:45.428]         {
[13:20:45.428]             ...future.startTime <- base::Sys.time()
[13:20:45.428]             {
[13:20:45.428]                 {
[13:20:45.428]                   {
[13:20:45.428]                     {
[13:20:45.428]                       base::local({
[13:20:45.428]                         has_future <- base::requireNamespace("future", 
[13:20:45.428]                           quietly = TRUE)
[13:20:45.428]                         if (has_future) {
[13:20:45.428]                           ns <- base::getNamespace("future")
[13:20:45.428]                           version <- ns[[".package"]][["version"]]
[13:20:45.428]                           if (is.null(version)) 
[13:20:45.428]                             version <- utils::packageVersion("future")
[13:20:45.428]                         }
[13:20:45.428]                         else {
[13:20:45.428]                           version <- NULL
[13:20:45.428]                         }
[13:20:45.428]                         if (!has_future || version < "1.8.0") {
[13:20:45.428]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.428]                             "", base::R.version$version.string), 
[13:20:45.428]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.428]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.428]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.428]                               "release", "version")], collapse = " "), 
[13:20:45.428]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.428]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.428]                             info)
[13:20:45.428]                           info <- base::paste(info, collapse = "; ")
[13:20:45.428]                           if (!has_future) {
[13:20:45.428]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.428]                               info)
[13:20:45.428]                           }
[13:20:45.428]                           else {
[13:20:45.428]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.428]                               info, version)
[13:20:45.428]                           }
[13:20:45.428]                           base::stop(msg)
[13:20:45.428]                         }
[13:20:45.428]                       })
[13:20:45.428]                     }
[13:20:45.428]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.428]                     base::options(mc.cores = 1L)
[13:20:45.428]                   }
[13:20:45.428]                   options(future.plan = NULL)
[13:20:45.428]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.428]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.428]                 }
[13:20:45.428]                 ...future.workdir <- getwd()
[13:20:45.428]             }
[13:20:45.428]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.428]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.428]         }
[13:20:45.428]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.428]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.428]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.428]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.428]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.428]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.428]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.428]             base::names(...future.oldOptions))
[13:20:45.428]     }
[13:20:45.428]     if (FALSE) {
[13:20:45.428]     }
[13:20:45.428]     else {
[13:20:45.428]         if (TRUE) {
[13:20:45.428]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.428]                 open = "w")
[13:20:45.428]         }
[13:20:45.428]         else {
[13:20:45.428]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.428]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.428]         }
[13:20:45.428]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.428]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.428]             base::sink(type = "output", split = FALSE)
[13:20:45.428]             base::close(...future.stdout)
[13:20:45.428]         }, add = TRUE)
[13:20:45.428]     }
[13:20:45.428]     ...future.frame <- base::sys.nframe()
[13:20:45.428]     ...future.conditions <- base::list()
[13:20:45.428]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.428]     if (FALSE) {
[13:20:45.428]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.428]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.428]     }
[13:20:45.428]     ...future.result <- base::tryCatch({
[13:20:45.428]         base::withCallingHandlers({
[13:20:45.428]             ...future.value <- base::withVisible(base::local({
[13:20:45.428]                 withCallingHandlers({
[13:20:45.428]                   {
[13:20:45.428]                     x[["a"]] <- 1
[13:20:45.428]                     x
[13:20:45.428]                   }
[13:20:45.428]                 }, immediateCondition = function(cond) {
[13:20:45.428]                   save_rds <- function (object, pathname, ...) 
[13:20:45.428]                   {
[13:20:45.428]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.428]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.428]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.428]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.428]                         fi_tmp[["mtime"]])
[13:20:45.428]                     }
[13:20:45.428]                     tryCatch({
[13:20:45.428]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.428]                     }, error = function(ex) {
[13:20:45.428]                       msg <- conditionMessage(ex)
[13:20:45.428]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.428]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.428]                         fi_tmp[["mtime"]], msg)
[13:20:45.428]                       ex$message <- msg
[13:20:45.428]                       stop(ex)
[13:20:45.428]                     })
[13:20:45.428]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.428]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.428]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.428]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.428]                       fi <- file.info(pathname)
[13:20:45.428]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.428]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.428]                         fi[["size"]], fi[["mtime"]])
[13:20:45.428]                       stop(msg)
[13:20:45.428]                     }
[13:20:45.428]                     invisible(pathname)
[13:20:45.428]                   }
[13:20:45.428]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.428]                     rootPath = tempdir()) 
[13:20:45.428]                   {
[13:20:45.428]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.428]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.428]                       tmpdir = path, fileext = ".rds")
[13:20:45.428]                     save_rds(obj, file)
[13:20:45.428]                   }
[13:20:45.428]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.428]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.428]                   {
[13:20:45.428]                     inherits <- base::inherits
[13:20:45.428]                     invokeRestart <- base::invokeRestart
[13:20:45.428]                     is.null <- base::is.null
[13:20:45.428]                     muffled <- FALSE
[13:20:45.428]                     if (inherits(cond, "message")) {
[13:20:45.428]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.428]                       if (muffled) 
[13:20:45.428]                         invokeRestart("muffleMessage")
[13:20:45.428]                     }
[13:20:45.428]                     else if (inherits(cond, "warning")) {
[13:20:45.428]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.428]                       if (muffled) 
[13:20:45.428]                         invokeRestart("muffleWarning")
[13:20:45.428]                     }
[13:20:45.428]                     else if (inherits(cond, "condition")) {
[13:20:45.428]                       if (!is.null(pattern)) {
[13:20:45.428]                         computeRestarts <- base::computeRestarts
[13:20:45.428]                         grepl <- base::grepl
[13:20:45.428]                         restarts <- computeRestarts(cond)
[13:20:45.428]                         for (restart in restarts) {
[13:20:45.428]                           name <- restart$name
[13:20:45.428]                           if (is.null(name)) 
[13:20:45.428]                             next
[13:20:45.428]                           if (!grepl(pattern, name)) 
[13:20:45.428]                             next
[13:20:45.428]                           invokeRestart(restart)
[13:20:45.428]                           muffled <- TRUE
[13:20:45.428]                           break
[13:20:45.428]                         }
[13:20:45.428]                       }
[13:20:45.428]                     }
[13:20:45.428]                     invisible(muffled)
[13:20:45.428]                   }
[13:20:45.428]                   muffleCondition(cond)
[13:20:45.428]                 })
[13:20:45.428]             }))
[13:20:45.428]             future::FutureResult(value = ...future.value$value, 
[13:20:45.428]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.428]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.428]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.428]                     ...future.globalenv.names))
[13:20:45.428]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.428]         }, condition = base::local({
[13:20:45.428]             c <- base::c
[13:20:45.428]             inherits <- base::inherits
[13:20:45.428]             invokeRestart <- base::invokeRestart
[13:20:45.428]             length <- base::length
[13:20:45.428]             list <- base::list
[13:20:45.428]             seq.int <- base::seq.int
[13:20:45.428]             signalCondition <- base::signalCondition
[13:20:45.428]             sys.calls <- base::sys.calls
[13:20:45.428]             `[[` <- base::`[[`
[13:20:45.428]             `+` <- base::`+`
[13:20:45.428]             `<<-` <- base::`<<-`
[13:20:45.428]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.428]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.428]                   3L)]
[13:20:45.428]             }
[13:20:45.428]             function(cond) {
[13:20:45.428]                 is_error <- inherits(cond, "error")
[13:20:45.428]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.428]                   NULL)
[13:20:45.428]                 if (is_error) {
[13:20:45.428]                   sessionInformation <- function() {
[13:20:45.428]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.428]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.428]                       search = base::search(), system = base::Sys.info())
[13:20:45.428]                   }
[13:20:45.428]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.428]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.428]                     cond$call), session = sessionInformation(), 
[13:20:45.428]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.428]                   signalCondition(cond)
[13:20:45.428]                 }
[13:20:45.428]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.428]                 "immediateCondition"))) {
[13:20:45.428]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.428]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.428]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.428]                   if (TRUE && !signal) {
[13:20:45.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.428]                     {
[13:20:45.428]                       inherits <- base::inherits
[13:20:45.428]                       invokeRestart <- base::invokeRestart
[13:20:45.428]                       is.null <- base::is.null
[13:20:45.428]                       muffled <- FALSE
[13:20:45.428]                       if (inherits(cond, "message")) {
[13:20:45.428]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.428]                         if (muffled) 
[13:20:45.428]                           invokeRestart("muffleMessage")
[13:20:45.428]                       }
[13:20:45.428]                       else if (inherits(cond, "warning")) {
[13:20:45.428]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.428]                         if (muffled) 
[13:20:45.428]                           invokeRestart("muffleWarning")
[13:20:45.428]                       }
[13:20:45.428]                       else if (inherits(cond, "condition")) {
[13:20:45.428]                         if (!is.null(pattern)) {
[13:20:45.428]                           computeRestarts <- base::computeRestarts
[13:20:45.428]                           grepl <- base::grepl
[13:20:45.428]                           restarts <- computeRestarts(cond)
[13:20:45.428]                           for (restart in restarts) {
[13:20:45.428]                             name <- restart$name
[13:20:45.428]                             if (is.null(name)) 
[13:20:45.428]                               next
[13:20:45.428]                             if (!grepl(pattern, name)) 
[13:20:45.428]                               next
[13:20:45.428]                             invokeRestart(restart)
[13:20:45.428]                             muffled <- TRUE
[13:20:45.428]                             break
[13:20:45.428]                           }
[13:20:45.428]                         }
[13:20:45.428]                       }
[13:20:45.428]                       invisible(muffled)
[13:20:45.428]                     }
[13:20:45.428]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.428]                   }
[13:20:45.428]                 }
[13:20:45.428]                 else {
[13:20:45.428]                   if (TRUE) {
[13:20:45.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.428]                     {
[13:20:45.428]                       inherits <- base::inherits
[13:20:45.428]                       invokeRestart <- base::invokeRestart
[13:20:45.428]                       is.null <- base::is.null
[13:20:45.428]                       muffled <- FALSE
[13:20:45.428]                       if (inherits(cond, "message")) {
[13:20:45.428]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.428]                         if (muffled) 
[13:20:45.428]                           invokeRestart("muffleMessage")
[13:20:45.428]                       }
[13:20:45.428]                       else if (inherits(cond, "warning")) {
[13:20:45.428]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.428]                         if (muffled) 
[13:20:45.428]                           invokeRestart("muffleWarning")
[13:20:45.428]                       }
[13:20:45.428]                       else if (inherits(cond, "condition")) {
[13:20:45.428]                         if (!is.null(pattern)) {
[13:20:45.428]                           computeRestarts <- base::computeRestarts
[13:20:45.428]                           grepl <- base::grepl
[13:20:45.428]                           restarts <- computeRestarts(cond)
[13:20:45.428]                           for (restart in restarts) {
[13:20:45.428]                             name <- restart$name
[13:20:45.428]                             if (is.null(name)) 
[13:20:45.428]                               next
[13:20:45.428]                             if (!grepl(pattern, name)) 
[13:20:45.428]                               next
[13:20:45.428]                             invokeRestart(restart)
[13:20:45.428]                             muffled <- TRUE
[13:20:45.428]                             break
[13:20:45.428]                           }
[13:20:45.428]                         }
[13:20:45.428]                       }
[13:20:45.428]                       invisible(muffled)
[13:20:45.428]                     }
[13:20:45.428]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.428]                   }
[13:20:45.428]                 }
[13:20:45.428]             }
[13:20:45.428]         }))
[13:20:45.428]     }, error = function(ex) {
[13:20:45.428]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.428]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.428]                 ...future.rng), started = ...future.startTime, 
[13:20:45.428]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.428]             version = "1.8"), class = "FutureResult")
[13:20:45.428]     }, finally = {
[13:20:45.428]         if (!identical(...future.workdir, getwd())) 
[13:20:45.428]             setwd(...future.workdir)
[13:20:45.428]         {
[13:20:45.428]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.428]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.428]             }
[13:20:45.428]             base::options(...future.oldOptions)
[13:20:45.428]             if (.Platform$OS.type == "windows") {
[13:20:45.428]                 old_names <- names(...future.oldEnvVars)
[13:20:45.428]                 envs <- base::Sys.getenv()
[13:20:45.428]                 names <- names(envs)
[13:20:45.428]                 common <- intersect(names, old_names)
[13:20:45.428]                 added <- setdiff(names, old_names)
[13:20:45.428]                 removed <- setdiff(old_names, names)
[13:20:45.428]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.428]                   envs[common]]
[13:20:45.428]                 NAMES <- toupper(changed)
[13:20:45.428]                 args <- list()
[13:20:45.428]                 for (kk in seq_along(NAMES)) {
[13:20:45.428]                   name <- changed[[kk]]
[13:20:45.428]                   NAME <- NAMES[[kk]]
[13:20:45.428]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.428]                     next
[13:20:45.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.428]                 }
[13:20:45.428]                 NAMES <- toupper(added)
[13:20:45.428]                 for (kk in seq_along(NAMES)) {
[13:20:45.428]                   name <- added[[kk]]
[13:20:45.428]                   NAME <- NAMES[[kk]]
[13:20:45.428]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.428]                     next
[13:20:45.428]                   args[[name]] <- ""
[13:20:45.428]                 }
[13:20:45.428]                 NAMES <- toupper(removed)
[13:20:45.428]                 for (kk in seq_along(NAMES)) {
[13:20:45.428]                   name <- removed[[kk]]
[13:20:45.428]                   NAME <- NAMES[[kk]]
[13:20:45.428]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.428]                     next
[13:20:45.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.428]                 }
[13:20:45.428]                 if (length(args) > 0) 
[13:20:45.428]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.428]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.428]             }
[13:20:45.428]             else {
[13:20:45.428]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.428]             }
[13:20:45.428]             {
[13:20:45.428]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.428]                   0L) {
[13:20:45.428]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.428]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.428]                   base::options(opts)
[13:20:45.428]                 }
[13:20:45.428]                 {
[13:20:45.428]                   {
[13:20:45.428]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.428]                     NULL
[13:20:45.428]                   }
[13:20:45.428]                   options(future.plan = NULL)
[13:20:45.428]                   if (is.na(NA_character_)) 
[13:20:45.428]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.428]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.428]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.428]                     envir = parent.frame()) 
[13:20:45.428]                   {
[13:20:45.428]                     default_workers <- missing(workers)
[13:20:45.428]                     if (is.function(workers)) 
[13:20:45.428]                       workers <- workers()
[13:20:45.428]                     workers <- structure(as.integer(workers), 
[13:20:45.428]                       class = class(workers))
[13:20:45.428]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.428]                       1L)
[13:20:45.428]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.428]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.428]                       if (default_workers) 
[13:20:45.428]                         supportsMulticore(warn = TRUE)
[13:20:45.428]                       return(sequential(..., envir = envir))
[13:20:45.428]                     }
[13:20:45.428]                     oopts <- options(mc.cores = workers)
[13:20:45.428]                     on.exit(options(oopts))
[13:20:45.428]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.428]                       envir = envir)
[13:20:45.428]                     if (!future$lazy) 
[13:20:45.428]                       future <- run(future)
[13:20:45.428]                     invisible(future)
[13:20:45.428]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.428]                 }
[13:20:45.428]             }
[13:20:45.428]         }
[13:20:45.428]     })
[13:20:45.428]     if (TRUE) {
[13:20:45.428]         base::sink(type = "output", split = FALSE)
[13:20:45.428]         if (TRUE) {
[13:20:45.428]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.428]         }
[13:20:45.428]         else {
[13:20:45.428]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.428]         }
[13:20:45.428]         base::close(...future.stdout)
[13:20:45.428]         ...future.stdout <- NULL
[13:20:45.428]     }
[13:20:45.428]     ...future.result$conditions <- ...future.conditions
[13:20:45.428]     ...future.result$finished <- base::Sys.time()
[13:20:45.428]     ...future.result
[13:20:45.428] }
[13:20:45.431] assign_globals() ...
[13:20:45.431] List of 1
[13:20:45.431]  $ x: list()
[13:20:45.431]  - attr(*, "where")=List of 1
[13:20:45.431]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.431]  - attr(*, "resolved")= logi TRUE
[13:20:45.431]  - attr(*, "total_size")= num 0
[13:20:45.431]  - attr(*, "already-done")= logi TRUE
[13:20:45.434] - copied ‘x’ to environment
[13:20:45.434] assign_globals() ... done
[13:20:45.435] requestCore(): workers = 2
[13:20:45.437] MulticoreFuture started
[13:20:45.441] - Launch lazy future ... done
[13:20:45.442] plan(): Setting new future strategy stack:
[13:20:45.442] run() for ‘MulticoreFuture’ ... done
[13:20:45.442] List of future strategies:
[13:20:45.442] 1. sequential:
[13:20:45.442]    - args: function (..., envir = parent.frame())
[13:20:45.442]    - tweaked: FALSE
[13:20:45.442]    - call: NULL
[13:20:45.443] plan(): nbrOfWorkers() = 1
[13:20:45.445] plan(): Setting new future strategy stack:
[13:20:45.445] List of future strategies:
[13:20:45.445] 1. multicore:
[13:20:45.445]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.445]    - tweaked: FALSE
[13:20:45.445]    - call: plan(strategy)
[13:20:45.451] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.452] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.453] Searching for globals...
[13:20:45.457] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.457] Searching for globals ... DONE
[13:20:45.457] Resolving globals: TRUE
[13:20:45.458] Resolving any globals that are futures ...
[13:20:45.458] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.458] Resolving any globals that are futures ... DONE
[13:20:45.458] Resolving futures part of globals (recursively) ...
[13:20:45.459] resolve() on list ...
[13:20:45.459]  recursive: 99
[13:20:45.459]  length: 1
[13:20:45.459]  elements: ‘x’
[13:20:45.459]  length: 0 (resolved future 1)
[13:20:45.459] resolve() on list ... DONE
[13:20:45.459] - globals: [1] ‘x’
[13:20:45.460] Resolving futures part of globals (recursively) ... DONE
[13:20:45.460] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.460] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.460] - globals: [1] ‘x’
[13:20:45.460] 
[13:20:45.461] getGlobalsAndPackages() ... DONE
[13:20:45.461] run() for ‘Future’ ...
[13:20:45.461] - state: ‘created’
[13:20:45.461] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.465] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.466] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.466]   - Field: ‘label’
[13:20:45.466]   - Field: ‘local’
[13:20:45.466]   - Field: ‘owner’
[13:20:45.466]   - Field: ‘envir’
[13:20:45.466]   - Field: ‘workers’
[13:20:45.466]   - Field: ‘packages’
[13:20:45.467]   - Field: ‘gc’
[13:20:45.467]   - Field: ‘job’
[13:20:45.467]   - Field: ‘conditions’
[13:20:45.467]   - Field: ‘expr’
[13:20:45.467]   - Field: ‘uuid’
[13:20:45.467]   - Field: ‘seed’
[13:20:45.467]   - Field: ‘version’
[13:20:45.467]   - Field: ‘result’
[13:20:45.467]   - Field: ‘asynchronous’
[13:20:45.468]   - Field: ‘calls’
[13:20:45.468]   - Field: ‘globals’
[13:20:45.468]   - Field: ‘stdout’
[13:20:45.468]   - Field: ‘earlySignal’
[13:20:45.468]   - Field: ‘lazy’
[13:20:45.468]   - Field: ‘state’
[13:20:45.468] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.468] - Launch lazy future ...
[13:20:45.469] Packages needed by the future expression (n = 0): <none>
[13:20:45.469] Packages needed by future strategies (n = 0): <none>
[13:20:45.469] {
[13:20:45.469]     {
[13:20:45.469]         {
[13:20:45.469]             ...future.startTime <- base::Sys.time()
[13:20:45.469]             {
[13:20:45.469]                 {
[13:20:45.469]                   {
[13:20:45.469]                     {
[13:20:45.469]                       base::local({
[13:20:45.469]                         has_future <- base::requireNamespace("future", 
[13:20:45.469]                           quietly = TRUE)
[13:20:45.469]                         if (has_future) {
[13:20:45.469]                           ns <- base::getNamespace("future")
[13:20:45.469]                           version <- ns[[".package"]][["version"]]
[13:20:45.469]                           if (is.null(version)) 
[13:20:45.469]                             version <- utils::packageVersion("future")
[13:20:45.469]                         }
[13:20:45.469]                         else {
[13:20:45.469]                           version <- NULL
[13:20:45.469]                         }
[13:20:45.469]                         if (!has_future || version < "1.8.0") {
[13:20:45.469]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.469]                             "", base::R.version$version.string), 
[13:20:45.469]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.469]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.469]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.469]                               "release", "version")], collapse = " "), 
[13:20:45.469]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.469]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.469]                             info)
[13:20:45.469]                           info <- base::paste(info, collapse = "; ")
[13:20:45.469]                           if (!has_future) {
[13:20:45.469]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.469]                               info)
[13:20:45.469]                           }
[13:20:45.469]                           else {
[13:20:45.469]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.469]                               info, version)
[13:20:45.469]                           }
[13:20:45.469]                           base::stop(msg)
[13:20:45.469]                         }
[13:20:45.469]                       })
[13:20:45.469]                     }
[13:20:45.469]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.469]                     base::options(mc.cores = 1L)
[13:20:45.469]                   }
[13:20:45.469]                   options(future.plan = NULL)
[13:20:45.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.469]                 }
[13:20:45.469]                 ...future.workdir <- getwd()
[13:20:45.469]             }
[13:20:45.469]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.469]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.469]         }
[13:20:45.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.469]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.469]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.469]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.469]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.469]             base::names(...future.oldOptions))
[13:20:45.469]     }
[13:20:45.469]     if (FALSE) {
[13:20:45.469]     }
[13:20:45.469]     else {
[13:20:45.469]         if (TRUE) {
[13:20:45.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.469]                 open = "w")
[13:20:45.469]         }
[13:20:45.469]         else {
[13:20:45.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.469]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.469]         }
[13:20:45.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.469]             base::sink(type = "output", split = FALSE)
[13:20:45.469]             base::close(...future.stdout)
[13:20:45.469]         }, add = TRUE)
[13:20:45.469]     }
[13:20:45.469]     ...future.frame <- base::sys.nframe()
[13:20:45.469]     ...future.conditions <- base::list()
[13:20:45.469]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.469]     if (FALSE) {
[13:20:45.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.469]     }
[13:20:45.469]     ...future.result <- base::tryCatch({
[13:20:45.469]         base::withCallingHandlers({
[13:20:45.469]             ...future.value <- base::withVisible(base::local({
[13:20:45.469]                 withCallingHandlers({
[13:20:45.469]                   {
[13:20:45.469]                     x[["a"]] <- 1
[13:20:45.469]                     x
[13:20:45.469]                   }
[13:20:45.469]                 }, immediateCondition = function(cond) {
[13:20:45.469]                   save_rds <- function (object, pathname, ...) 
[13:20:45.469]                   {
[13:20:45.469]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.469]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.469]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.469]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.469]                         fi_tmp[["mtime"]])
[13:20:45.469]                     }
[13:20:45.469]                     tryCatch({
[13:20:45.469]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.469]                     }, error = function(ex) {
[13:20:45.469]                       msg <- conditionMessage(ex)
[13:20:45.469]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.469]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.469]                         fi_tmp[["mtime"]], msg)
[13:20:45.469]                       ex$message <- msg
[13:20:45.469]                       stop(ex)
[13:20:45.469]                     })
[13:20:45.469]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.469]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.469]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.469]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.469]                       fi <- file.info(pathname)
[13:20:45.469]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.469]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.469]                         fi[["size"]], fi[["mtime"]])
[13:20:45.469]                       stop(msg)
[13:20:45.469]                     }
[13:20:45.469]                     invisible(pathname)
[13:20:45.469]                   }
[13:20:45.469]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.469]                     rootPath = tempdir()) 
[13:20:45.469]                   {
[13:20:45.469]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.469]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.469]                       tmpdir = path, fileext = ".rds")
[13:20:45.469]                     save_rds(obj, file)
[13:20:45.469]                   }
[13:20:45.469]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.469]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.469]                   {
[13:20:45.469]                     inherits <- base::inherits
[13:20:45.469]                     invokeRestart <- base::invokeRestart
[13:20:45.469]                     is.null <- base::is.null
[13:20:45.469]                     muffled <- FALSE
[13:20:45.469]                     if (inherits(cond, "message")) {
[13:20:45.469]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.469]                       if (muffled) 
[13:20:45.469]                         invokeRestart("muffleMessage")
[13:20:45.469]                     }
[13:20:45.469]                     else if (inherits(cond, "warning")) {
[13:20:45.469]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.469]                       if (muffled) 
[13:20:45.469]                         invokeRestart("muffleWarning")
[13:20:45.469]                     }
[13:20:45.469]                     else if (inherits(cond, "condition")) {
[13:20:45.469]                       if (!is.null(pattern)) {
[13:20:45.469]                         computeRestarts <- base::computeRestarts
[13:20:45.469]                         grepl <- base::grepl
[13:20:45.469]                         restarts <- computeRestarts(cond)
[13:20:45.469]                         for (restart in restarts) {
[13:20:45.469]                           name <- restart$name
[13:20:45.469]                           if (is.null(name)) 
[13:20:45.469]                             next
[13:20:45.469]                           if (!grepl(pattern, name)) 
[13:20:45.469]                             next
[13:20:45.469]                           invokeRestart(restart)
[13:20:45.469]                           muffled <- TRUE
[13:20:45.469]                           break
[13:20:45.469]                         }
[13:20:45.469]                       }
[13:20:45.469]                     }
[13:20:45.469]                     invisible(muffled)
[13:20:45.469]                   }
[13:20:45.469]                   muffleCondition(cond)
[13:20:45.469]                 })
[13:20:45.469]             }))
[13:20:45.469]             future::FutureResult(value = ...future.value$value, 
[13:20:45.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.469]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.469]                     ...future.globalenv.names))
[13:20:45.469]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.469]         }, condition = base::local({
[13:20:45.469]             c <- base::c
[13:20:45.469]             inherits <- base::inherits
[13:20:45.469]             invokeRestart <- base::invokeRestart
[13:20:45.469]             length <- base::length
[13:20:45.469]             list <- base::list
[13:20:45.469]             seq.int <- base::seq.int
[13:20:45.469]             signalCondition <- base::signalCondition
[13:20:45.469]             sys.calls <- base::sys.calls
[13:20:45.469]             `[[` <- base::`[[`
[13:20:45.469]             `+` <- base::`+`
[13:20:45.469]             `<<-` <- base::`<<-`
[13:20:45.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.469]                   3L)]
[13:20:45.469]             }
[13:20:45.469]             function(cond) {
[13:20:45.469]                 is_error <- inherits(cond, "error")
[13:20:45.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.469]                   NULL)
[13:20:45.469]                 if (is_error) {
[13:20:45.469]                   sessionInformation <- function() {
[13:20:45.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.469]                       search = base::search(), system = base::Sys.info())
[13:20:45.469]                   }
[13:20:45.469]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.469]                     cond$call), session = sessionInformation(), 
[13:20:45.469]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.469]                   signalCondition(cond)
[13:20:45.469]                 }
[13:20:45.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.469]                 "immediateCondition"))) {
[13:20:45.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.469]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.469]                   if (TRUE && !signal) {
[13:20:45.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.469]                     {
[13:20:45.469]                       inherits <- base::inherits
[13:20:45.469]                       invokeRestart <- base::invokeRestart
[13:20:45.469]                       is.null <- base::is.null
[13:20:45.469]                       muffled <- FALSE
[13:20:45.469]                       if (inherits(cond, "message")) {
[13:20:45.469]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.469]                         if (muffled) 
[13:20:45.469]                           invokeRestart("muffleMessage")
[13:20:45.469]                       }
[13:20:45.469]                       else if (inherits(cond, "warning")) {
[13:20:45.469]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.469]                         if (muffled) 
[13:20:45.469]                           invokeRestart("muffleWarning")
[13:20:45.469]                       }
[13:20:45.469]                       else if (inherits(cond, "condition")) {
[13:20:45.469]                         if (!is.null(pattern)) {
[13:20:45.469]                           computeRestarts <- base::computeRestarts
[13:20:45.469]                           grepl <- base::grepl
[13:20:45.469]                           restarts <- computeRestarts(cond)
[13:20:45.469]                           for (restart in restarts) {
[13:20:45.469]                             name <- restart$name
[13:20:45.469]                             if (is.null(name)) 
[13:20:45.469]                               next
[13:20:45.469]                             if (!grepl(pattern, name)) 
[13:20:45.469]                               next
[13:20:45.469]                             invokeRestart(restart)
[13:20:45.469]                             muffled <- TRUE
[13:20:45.469]                             break
[13:20:45.469]                           }
[13:20:45.469]                         }
[13:20:45.469]                       }
[13:20:45.469]                       invisible(muffled)
[13:20:45.469]                     }
[13:20:45.469]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.469]                   }
[13:20:45.469]                 }
[13:20:45.469]                 else {
[13:20:45.469]                   if (TRUE) {
[13:20:45.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.469]                     {
[13:20:45.469]                       inherits <- base::inherits
[13:20:45.469]                       invokeRestart <- base::invokeRestart
[13:20:45.469]                       is.null <- base::is.null
[13:20:45.469]                       muffled <- FALSE
[13:20:45.469]                       if (inherits(cond, "message")) {
[13:20:45.469]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.469]                         if (muffled) 
[13:20:45.469]                           invokeRestart("muffleMessage")
[13:20:45.469]                       }
[13:20:45.469]                       else if (inherits(cond, "warning")) {
[13:20:45.469]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.469]                         if (muffled) 
[13:20:45.469]                           invokeRestart("muffleWarning")
[13:20:45.469]                       }
[13:20:45.469]                       else if (inherits(cond, "condition")) {
[13:20:45.469]                         if (!is.null(pattern)) {
[13:20:45.469]                           computeRestarts <- base::computeRestarts
[13:20:45.469]                           grepl <- base::grepl
[13:20:45.469]                           restarts <- computeRestarts(cond)
[13:20:45.469]                           for (restart in restarts) {
[13:20:45.469]                             name <- restart$name
[13:20:45.469]                             if (is.null(name)) 
[13:20:45.469]                               next
[13:20:45.469]                             if (!grepl(pattern, name)) 
[13:20:45.469]                               next
[13:20:45.469]                             invokeRestart(restart)
[13:20:45.469]                             muffled <- TRUE
[13:20:45.469]                             break
[13:20:45.469]                           }
[13:20:45.469]                         }
[13:20:45.469]                       }
[13:20:45.469]                       invisible(muffled)
[13:20:45.469]                     }
[13:20:45.469]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.469]                   }
[13:20:45.469]                 }
[13:20:45.469]             }
[13:20:45.469]         }))
[13:20:45.469]     }, error = function(ex) {
[13:20:45.469]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.469]                 ...future.rng), started = ...future.startTime, 
[13:20:45.469]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.469]             version = "1.8"), class = "FutureResult")
[13:20:45.469]     }, finally = {
[13:20:45.469]         if (!identical(...future.workdir, getwd())) 
[13:20:45.469]             setwd(...future.workdir)
[13:20:45.469]         {
[13:20:45.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.469]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.469]             }
[13:20:45.469]             base::options(...future.oldOptions)
[13:20:45.469]             if (.Platform$OS.type == "windows") {
[13:20:45.469]                 old_names <- names(...future.oldEnvVars)
[13:20:45.469]                 envs <- base::Sys.getenv()
[13:20:45.469]                 names <- names(envs)
[13:20:45.469]                 common <- intersect(names, old_names)
[13:20:45.469]                 added <- setdiff(names, old_names)
[13:20:45.469]                 removed <- setdiff(old_names, names)
[13:20:45.469]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.469]                   envs[common]]
[13:20:45.469]                 NAMES <- toupper(changed)
[13:20:45.469]                 args <- list()
[13:20:45.469]                 for (kk in seq_along(NAMES)) {
[13:20:45.469]                   name <- changed[[kk]]
[13:20:45.469]                   NAME <- NAMES[[kk]]
[13:20:45.469]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.469]                     next
[13:20:45.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.469]                 }
[13:20:45.469]                 NAMES <- toupper(added)
[13:20:45.469]                 for (kk in seq_along(NAMES)) {
[13:20:45.469]                   name <- added[[kk]]
[13:20:45.469]                   NAME <- NAMES[[kk]]
[13:20:45.469]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.469]                     next
[13:20:45.469]                   args[[name]] <- ""
[13:20:45.469]                 }
[13:20:45.469]                 NAMES <- toupper(removed)
[13:20:45.469]                 for (kk in seq_along(NAMES)) {
[13:20:45.469]                   name <- removed[[kk]]
[13:20:45.469]                   NAME <- NAMES[[kk]]
[13:20:45.469]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.469]                     next
[13:20:45.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.469]                 }
[13:20:45.469]                 if (length(args) > 0) 
[13:20:45.469]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.469]             }
[13:20:45.469]             else {
[13:20:45.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.469]             }
[13:20:45.469]             {
[13:20:45.469]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.469]                   0L) {
[13:20:45.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.469]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.469]                   base::options(opts)
[13:20:45.469]                 }
[13:20:45.469]                 {
[13:20:45.469]                   {
[13:20:45.469]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.469]                     NULL
[13:20:45.469]                   }
[13:20:45.469]                   options(future.plan = NULL)
[13:20:45.469]                   if (is.na(NA_character_)) 
[13:20:45.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.469]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.469]                     envir = parent.frame()) 
[13:20:45.469]                   {
[13:20:45.469]                     default_workers <- missing(workers)
[13:20:45.469]                     if (is.function(workers)) 
[13:20:45.469]                       workers <- workers()
[13:20:45.469]                     workers <- structure(as.integer(workers), 
[13:20:45.469]                       class = class(workers))
[13:20:45.469]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.469]                       1L)
[13:20:45.469]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.469]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.469]                       if (default_workers) 
[13:20:45.469]                         supportsMulticore(warn = TRUE)
[13:20:45.469]                       return(sequential(..., envir = envir))
[13:20:45.469]                     }
[13:20:45.469]                     oopts <- options(mc.cores = workers)
[13:20:45.469]                     on.exit(options(oopts))
[13:20:45.469]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.469]                       envir = envir)
[13:20:45.469]                     if (!future$lazy) 
[13:20:45.469]                       future <- run(future)
[13:20:45.469]                     invisible(future)
[13:20:45.469]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.469]                 }
[13:20:45.469]             }
[13:20:45.469]         }
[13:20:45.469]     })
[13:20:45.469]     if (TRUE) {
[13:20:45.469]         base::sink(type = "output", split = FALSE)
[13:20:45.469]         if (TRUE) {
[13:20:45.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.469]         }
[13:20:45.469]         else {
[13:20:45.469]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.469]         }
[13:20:45.469]         base::close(...future.stdout)
[13:20:45.469]         ...future.stdout <- NULL
[13:20:45.469]     }
[13:20:45.469]     ...future.result$conditions <- ...future.conditions
[13:20:45.469]     ...future.result$finished <- base::Sys.time()
[13:20:45.469]     ...future.result
[13:20:45.469] }
[13:20:45.472] assign_globals() ...
[13:20:45.472] List of 1
[13:20:45.472]  $ x: list()
[13:20:45.472]  - attr(*, "where")=List of 1
[13:20:45.472]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.472]  - attr(*, "resolved")= logi TRUE
[13:20:45.472]  - attr(*, "total_size")= num 0
[13:20:45.472]  - attr(*, "already-done")= logi TRUE
[13:20:45.475] - copied ‘x’ to environment
[13:20:45.475] assign_globals() ... done
[13:20:45.475] requestCore(): workers = 2
[13:20:45.478] MulticoreFuture started
[13:20:45.478] - Launch lazy future ... done
[13:20:45.478] run() for ‘MulticoreFuture’ ... done
[13:20:45.479] plan(): Setting new future strategy stack:
[13:20:45.479] List of future strategies:
[13:20:45.479] 1. sequential:
[13:20:45.479]    - args: function (..., envir = parent.frame())
[13:20:45.479]    - tweaked: FALSE
[13:20:45.479]    - call: NULL
[13:20:45.480] plan(): nbrOfWorkers() = 1
[13:20:45.482] plan(): Setting new future strategy stack:
[13:20:45.482] List of future strategies:
[13:20:45.482] 1. multicore:
[13:20:45.482]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.482]    - tweaked: FALSE
[13:20:45.482]    - call: plan(strategy)
[13:20:45.487] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.489] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.490] Searching for globals...
[13:20:45.493] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.493] Searching for globals ... DONE
[13:20:45.493] Resolving globals: TRUE
[13:20:45.493] Resolving any globals that are futures ...
[13:20:45.493] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:45.493] Resolving any globals that are futures ... DONE
[13:20:45.494] Resolving futures part of globals (recursively) ...
[13:20:45.494] resolve() on list ...
[13:20:45.494]  recursive: 99
[13:20:45.494]  length: 1
[13:20:45.495]  elements: ‘x’
[13:20:45.495]  length: 0 (resolved future 1)
[13:20:45.495] resolve() on list ... DONE
[13:20:45.495] - globals: [1] ‘x’
[13:20:45.495] Resolving futures part of globals (recursively) ... DONE
[13:20:45.495] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.496] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.496] - globals: [1] ‘x’
[13:20:45.496] 
[13:20:45.496] getGlobalsAndPackages() ... DONE
[13:20:45.497] run() for ‘Future’ ...
[13:20:45.497] - state: ‘created’
[13:20:45.497] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.501] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.501] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.502]   - Field: ‘label’
[13:20:45.502]   - Field: ‘local’
[13:20:45.504]   - Field: ‘owner’
[13:20:45.505]   - Field: ‘envir’
[13:20:45.505]   - Field: ‘workers’
[13:20:45.505]   - Field: ‘packages’
[13:20:45.505]   - Field: ‘gc’
[13:20:45.505]   - Field: ‘job’
[13:20:45.505]   - Field: ‘conditions’
[13:20:45.505]   - Field: ‘expr’
[13:20:45.506]   - Field: ‘uuid’
[13:20:45.506]   - Field: ‘seed’
[13:20:45.506]   - Field: ‘version’
[13:20:45.506]   - Field: ‘result’
[13:20:45.506]   - Field: ‘asynchronous’
[13:20:45.506]   - Field: ‘calls’
[13:20:45.507]   - Field: ‘globals’
[13:20:45.507]   - Field: ‘stdout’
[13:20:45.507]   - Field: ‘earlySignal’
[13:20:45.507]   - Field: ‘lazy’
[13:20:45.507]   - Field: ‘state’
[13:20:45.507] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.507] - Launch lazy future ...
[13:20:45.508] Packages needed by the future expression (n = 0): <none>
[13:20:45.508] Packages needed by future strategies (n = 0): <none>
[13:20:45.509] {
[13:20:45.509]     {
[13:20:45.509]         {
[13:20:45.509]             ...future.startTime <- base::Sys.time()
[13:20:45.509]             {
[13:20:45.509]                 {
[13:20:45.509]                   {
[13:20:45.509]                     {
[13:20:45.509]                       base::local({
[13:20:45.509]                         has_future <- base::requireNamespace("future", 
[13:20:45.509]                           quietly = TRUE)
[13:20:45.509]                         if (has_future) {
[13:20:45.509]                           ns <- base::getNamespace("future")
[13:20:45.509]                           version <- ns[[".package"]][["version"]]
[13:20:45.509]                           if (is.null(version)) 
[13:20:45.509]                             version <- utils::packageVersion("future")
[13:20:45.509]                         }
[13:20:45.509]                         else {
[13:20:45.509]                           version <- NULL
[13:20:45.509]                         }
[13:20:45.509]                         if (!has_future || version < "1.8.0") {
[13:20:45.509]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.509]                             "", base::R.version$version.string), 
[13:20:45.509]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.509]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.509]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.509]                               "release", "version")], collapse = " "), 
[13:20:45.509]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.509]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.509]                             info)
[13:20:45.509]                           info <- base::paste(info, collapse = "; ")
[13:20:45.509]                           if (!has_future) {
[13:20:45.509]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.509]                               info)
[13:20:45.509]                           }
[13:20:45.509]                           else {
[13:20:45.509]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.509]                               info, version)
[13:20:45.509]                           }
[13:20:45.509]                           base::stop(msg)
[13:20:45.509]                         }
[13:20:45.509]                       })
[13:20:45.509]                     }
[13:20:45.509]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.509]                     base::options(mc.cores = 1L)
[13:20:45.509]                   }
[13:20:45.509]                   options(future.plan = NULL)
[13:20:45.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.509]                 }
[13:20:45.509]                 ...future.workdir <- getwd()
[13:20:45.509]             }
[13:20:45.509]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.509]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.509]         }
[13:20:45.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.509]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.509]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.509]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.509]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.509]             base::names(...future.oldOptions))
[13:20:45.509]     }
[13:20:45.509]     if (FALSE) {
[13:20:45.509]     }
[13:20:45.509]     else {
[13:20:45.509]         if (TRUE) {
[13:20:45.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.509]                 open = "w")
[13:20:45.509]         }
[13:20:45.509]         else {
[13:20:45.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.509]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.509]         }
[13:20:45.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.509]             base::sink(type = "output", split = FALSE)
[13:20:45.509]             base::close(...future.stdout)
[13:20:45.509]         }, add = TRUE)
[13:20:45.509]     }
[13:20:45.509]     ...future.frame <- base::sys.nframe()
[13:20:45.509]     ...future.conditions <- base::list()
[13:20:45.509]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.509]     if (FALSE) {
[13:20:45.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.509]     }
[13:20:45.509]     ...future.result <- base::tryCatch({
[13:20:45.509]         base::withCallingHandlers({
[13:20:45.509]             ...future.value <- base::withVisible(base::local({
[13:20:45.509]                 withCallingHandlers({
[13:20:45.509]                   {
[13:20:45.509]                     x[["a"]] <- 1
[13:20:45.509]                     x
[13:20:45.509]                   }
[13:20:45.509]                 }, immediateCondition = function(cond) {
[13:20:45.509]                   save_rds <- function (object, pathname, ...) 
[13:20:45.509]                   {
[13:20:45.509]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.509]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.509]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.509]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.509]                         fi_tmp[["mtime"]])
[13:20:45.509]                     }
[13:20:45.509]                     tryCatch({
[13:20:45.509]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.509]                     }, error = function(ex) {
[13:20:45.509]                       msg <- conditionMessage(ex)
[13:20:45.509]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.509]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.509]                         fi_tmp[["mtime"]], msg)
[13:20:45.509]                       ex$message <- msg
[13:20:45.509]                       stop(ex)
[13:20:45.509]                     })
[13:20:45.509]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.509]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.509]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.509]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.509]                       fi <- file.info(pathname)
[13:20:45.509]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.509]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.509]                         fi[["size"]], fi[["mtime"]])
[13:20:45.509]                       stop(msg)
[13:20:45.509]                     }
[13:20:45.509]                     invisible(pathname)
[13:20:45.509]                   }
[13:20:45.509]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.509]                     rootPath = tempdir()) 
[13:20:45.509]                   {
[13:20:45.509]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.509]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.509]                       tmpdir = path, fileext = ".rds")
[13:20:45.509]                     save_rds(obj, file)
[13:20:45.509]                   }
[13:20:45.509]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.509]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.509]                   {
[13:20:45.509]                     inherits <- base::inherits
[13:20:45.509]                     invokeRestart <- base::invokeRestart
[13:20:45.509]                     is.null <- base::is.null
[13:20:45.509]                     muffled <- FALSE
[13:20:45.509]                     if (inherits(cond, "message")) {
[13:20:45.509]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.509]                       if (muffled) 
[13:20:45.509]                         invokeRestart("muffleMessage")
[13:20:45.509]                     }
[13:20:45.509]                     else if (inherits(cond, "warning")) {
[13:20:45.509]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.509]                       if (muffled) 
[13:20:45.509]                         invokeRestart("muffleWarning")
[13:20:45.509]                     }
[13:20:45.509]                     else if (inherits(cond, "condition")) {
[13:20:45.509]                       if (!is.null(pattern)) {
[13:20:45.509]                         computeRestarts <- base::computeRestarts
[13:20:45.509]                         grepl <- base::grepl
[13:20:45.509]                         restarts <- computeRestarts(cond)
[13:20:45.509]                         for (restart in restarts) {
[13:20:45.509]                           name <- restart$name
[13:20:45.509]                           if (is.null(name)) 
[13:20:45.509]                             next
[13:20:45.509]                           if (!grepl(pattern, name)) 
[13:20:45.509]                             next
[13:20:45.509]                           invokeRestart(restart)
[13:20:45.509]                           muffled <- TRUE
[13:20:45.509]                           break
[13:20:45.509]                         }
[13:20:45.509]                       }
[13:20:45.509]                     }
[13:20:45.509]                     invisible(muffled)
[13:20:45.509]                   }
[13:20:45.509]                   muffleCondition(cond)
[13:20:45.509]                 })
[13:20:45.509]             }))
[13:20:45.509]             future::FutureResult(value = ...future.value$value, 
[13:20:45.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.509]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.509]                     ...future.globalenv.names))
[13:20:45.509]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.509]         }, condition = base::local({
[13:20:45.509]             c <- base::c
[13:20:45.509]             inherits <- base::inherits
[13:20:45.509]             invokeRestart <- base::invokeRestart
[13:20:45.509]             length <- base::length
[13:20:45.509]             list <- base::list
[13:20:45.509]             seq.int <- base::seq.int
[13:20:45.509]             signalCondition <- base::signalCondition
[13:20:45.509]             sys.calls <- base::sys.calls
[13:20:45.509]             `[[` <- base::`[[`
[13:20:45.509]             `+` <- base::`+`
[13:20:45.509]             `<<-` <- base::`<<-`
[13:20:45.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.509]                   3L)]
[13:20:45.509]             }
[13:20:45.509]             function(cond) {
[13:20:45.509]                 is_error <- inherits(cond, "error")
[13:20:45.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.509]                   NULL)
[13:20:45.509]                 if (is_error) {
[13:20:45.509]                   sessionInformation <- function() {
[13:20:45.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.509]                       search = base::search(), system = base::Sys.info())
[13:20:45.509]                   }
[13:20:45.509]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.509]                     cond$call), session = sessionInformation(), 
[13:20:45.509]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.509]                   signalCondition(cond)
[13:20:45.509]                 }
[13:20:45.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.509]                 "immediateCondition"))) {
[13:20:45.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.509]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.509]                   if (TRUE && !signal) {
[13:20:45.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.509]                     {
[13:20:45.509]                       inherits <- base::inherits
[13:20:45.509]                       invokeRestart <- base::invokeRestart
[13:20:45.509]                       is.null <- base::is.null
[13:20:45.509]                       muffled <- FALSE
[13:20:45.509]                       if (inherits(cond, "message")) {
[13:20:45.509]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.509]                         if (muffled) 
[13:20:45.509]                           invokeRestart("muffleMessage")
[13:20:45.509]                       }
[13:20:45.509]                       else if (inherits(cond, "warning")) {
[13:20:45.509]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.509]                         if (muffled) 
[13:20:45.509]                           invokeRestart("muffleWarning")
[13:20:45.509]                       }
[13:20:45.509]                       else if (inherits(cond, "condition")) {
[13:20:45.509]                         if (!is.null(pattern)) {
[13:20:45.509]                           computeRestarts <- base::computeRestarts
[13:20:45.509]                           grepl <- base::grepl
[13:20:45.509]                           restarts <- computeRestarts(cond)
[13:20:45.509]                           for (restart in restarts) {
[13:20:45.509]                             name <- restart$name
[13:20:45.509]                             if (is.null(name)) 
[13:20:45.509]                               next
[13:20:45.509]                             if (!grepl(pattern, name)) 
[13:20:45.509]                               next
[13:20:45.509]                             invokeRestart(restart)
[13:20:45.509]                             muffled <- TRUE
[13:20:45.509]                             break
[13:20:45.509]                           }
[13:20:45.509]                         }
[13:20:45.509]                       }
[13:20:45.509]                       invisible(muffled)
[13:20:45.509]                     }
[13:20:45.509]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.509]                   }
[13:20:45.509]                 }
[13:20:45.509]                 else {
[13:20:45.509]                   if (TRUE) {
[13:20:45.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.509]                     {
[13:20:45.509]                       inherits <- base::inherits
[13:20:45.509]                       invokeRestart <- base::invokeRestart
[13:20:45.509]                       is.null <- base::is.null
[13:20:45.509]                       muffled <- FALSE
[13:20:45.509]                       if (inherits(cond, "message")) {
[13:20:45.509]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.509]                         if (muffled) 
[13:20:45.509]                           invokeRestart("muffleMessage")
[13:20:45.509]                       }
[13:20:45.509]                       else if (inherits(cond, "warning")) {
[13:20:45.509]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.509]                         if (muffled) 
[13:20:45.509]                           invokeRestart("muffleWarning")
[13:20:45.509]                       }
[13:20:45.509]                       else if (inherits(cond, "condition")) {
[13:20:45.509]                         if (!is.null(pattern)) {
[13:20:45.509]                           computeRestarts <- base::computeRestarts
[13:20:45.509]                           grepl <- base::grepl
[13:20:45.509]                           restarts <- computeRestarts(cond)
[13:20:45.509]                           for (restart in restarts) {
[13:20:45.509]                             name <- restart$name
[13:20:45.509]                             if (is.null(name)) 
[13:20:45.509]                               next
[13:20:45.509]                             if (!grepl(pattern, name)) 
[13:20:45.509]                               next
[13:20:45.509]                             invokeRestart(restart)
[13:20:45.509]                             muffled <- TRUE
[13:20:45.509]                             break
[13:20:45.509]                           }
[13:20:45.509]                         }
[13:20:45.509]                       }
[13:20:45.509]                       invisible(muffled)
[13:20:45.509]                     }
[13:20:45.509]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.509]                   }
[13:20:45.509]                 }
[13:20:45.509]             }
[13:20:45.509]         }))
[13:20:45.509]     }, error = function(ex) {
[13:20:45.509]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.509]                 ...future.rng), started = ...future.startTime, 
[13:20:45.509]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.509]             version = "1.8"), class = "FutureResult")
[13:20:45.509]     }, finally = {
[13:20:45.509]         if (!identical(...future.workdir, getwd())) 
[13:20:45.509]             setwd(...future.workdir)
[13:20:45.509]         {
[13:20:45.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.509]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.509]             }
[13:20:45.509]             base::options(...future.oldOptions)
[13:20:45.509]             if (.Platform$OS.type == "windows") {
[13:20:45.509]                 old_names <- names(...future.oldEnvVars)
[13:20:45.509]                 envs <- base::Sys.getenv()
[13:20:45.509]                 names <- names(envs)
[13:20:45.509]                 common <- intersect(names, old_names)
[13:20:45.509]                 added <- setdiff(names, old_names)
[13:20:45.509]                 removed <- setdiff(old_names, names)
[13:20:45.509]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.509]                   envs[common]]
[13:20:45.509]                 NAMES <- toupper(changed)
[13:20:45.509]                 args <- list()
[13:20:45.509]                 for (kk in seq_along(NAMES)) {
[13:20:45.509]                   name <- changed[[kk]]
[13:20:45.509]                   NAME <- NAMES[[kk]]
[13:20:45.509]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.509]                     next
[13:20:45.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.509]                 }
[13:20:45.509]                 NAMES <- toupper(added)
[13:20:45.509]                 for (kk in seq_along(NAMES)) {
[13:20:45.509]                   name <- added[[kk]]
[13:20:45.509]                   NAME <- NAMES[[kk]]
[13:20:45.509]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.509]                     next
[13:20:45.509]                   args[[name]] <- ""
[13:20:45.509]                 }
[13:20:45.509]                 NAMES <- toupper(removed)
[13:20:45.509]                 for (kk in seq_along(NAMES)) {
[13:20:45.509]                   name <- removed[[kk]]
[13:20:45.509]                   NAME <- NAMES[[kk]]
[13:20:45.509]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.509]                     next
[13:20:45.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.509]                 }
[13:20:45.509]                 if (length(args) > 0) 
[13:20:45.509]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.509]             }
[13:20:45.509]             else {
[13:20:45.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.509]             }
[13:20:45.509]             {
[13:20:45.509]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.509]                   0L) {
[13:20:45.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.509]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.509]                   base::options(opts)
[13:20:45.509]                 }
[13:20:45.509]                 {
[13:20:45.509]                   {
[13:20:45.509]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.509]                     NULL
[13:20:45.509]                   }
[13:20:45.509]                   options(future.plan = NULL)
[13:20:45.509]                   if (is.na(NA_character_)) 
[13:20:45.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.509]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.509]                     envir = parent.frame()) 
[13:20:45.509]                   {
[13:20:45.509]                     default_workers <- missing(workers)
[13:20:45.509]                     if (is.function(workers)) 
[13:20:45.509]                       workers <- workers()
[13:20:45.509]                     workers <- structure(as.integer(workers), 
[13:20:45.509]                       class = class(workers))
[13:20:45.509]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.509]                       1L)
[13:20:45.509]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.509]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.509]                       if (default_workers) 
[13:20:45.509]                         supportsMulticore(warn = TRUE)
[13:20:45.509]                       return(sequential(..., envir = envir))
[13:20:45.509]                     }
[13:20:45.509]                     oopts <- options(mc.cores = workers)
[13:20:45.509]                     on.exit(options(oopts))
[13:20:45.509]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.509]                       envir = envir)
[13:20:45.509]                     if (!future$lazy) 
[13:20:45.509]                       future <- run(future)
[13:20:45.509]                     invisible(future)
[13:20:45.509]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.509]                 }
[13:20:45.509]             }
[13:20:45.509]         }
[13:20:45.509]     })
[13:20:45.509]     if (TRUE) {
[13:20:45.509]         base::sink(type = "output", split = FALSE)
[13:20:45.509]         if (TRUE) {
[13:20:45.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.509]         }
[13:20:45.509]         else {
[13:20:45.509]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.509]         }
[13:20:45.509]         base::close(...future.stdout)
[13:20:45.509]         ...future.stdout <- NULL
[13:20:45.509]     }
[13:20:45.509]     ...future.result$conditions <- ...future.conditions
[13:20:45.509]     ...future.result$finished <- base::Sys.time()
[13:20:45.509]     ...future.result
[13:20:45.509] }
[13:20:45.511] assign_globals() ...
[13:20:45.511] List of 1
[13:20:45.511]  $ x: list()
[13:20:45.511]  - attr(*, "where")=List of 1
[13:20:45.511]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.511]  - attr(*, "resolved")= logi TRUE
[13:20:45.511]  - attr(*, "total_size")= num 0
[13:20:45.511]  - attr(*, "already-done")= logi TRUE
[13:20:45.515] - copied ‘x’ to environment
[13:20:45.515] assign_globals() ... done
[13:20:45.515] requestCore(): workers = 2
[13:20:45.517] MulticoreFuture started
[13:20:45.517] - Launch lazy future ... done
[13:20:45.518] run() for ‘MulticoreFuture’ ... done
[13:20:45.518] plan(): Setting new future strategy stack:
[13:20:45.519] List of future strategies:
[13:20:45.519] 1. sequential:
[13:20:45.519]    - args: function (..., envir = parent.frame())
[13:20:45.519]    - tweaked: FALSE
[13:20:45.519]    - call: NULL
[13:20:45.520] plan(): nbrOfWorkers() = 1
[13:20:45.522] plan(): Setting new future strategy stack:
[13:20:45.522] List of future strategies:
[13:20:45.522] 1. multicore:
[13:20:45.522]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.522]    - tweaked: FALSE
[13:20:45.522]    - call: plan(strategy)
[13:20:45.528] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.529] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.529] Searching for globals...
[13:20:45.533] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.533] Searching for globals ... DONE
[13:20:45.533] Resolving globals: TRUE
[13:20:45.533] Resolving any globals that are futures ...
[13:20:45.533] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.533] Resolving any globals that are futures ... DONE
[13:20:45.534] Resolving futures part of globals (recursively) ...
[13:20:45.534] resolve() on list ...
[13:20:45.535]  recursive: 99
[13:20:45.535]  length: 1
[13:20:45.535]  elements: ‘x’
[13:20:45.535]  length: 0 (resolved future 1)
[13:20:45.535] resolve() on list ... DONE
[13:20:45.535] - globals: [1] ‘x’
[13:20:45.535] Resolving futures part of globals (recursively) ... DONE
[13:20:45.535] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.536] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.536] - globals: [1] ‘x’
[13:20:45.536] 
[13:20:45.536] getGlobalsAndPackages() ... DONE
[13:20:45.537] run() for ‘Future’ ...
[13:20:45.537] - state: ‘created’
[13:20:45.537] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.541] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.542]   - Field: ‘label’
[13:20:45.542]   - Field: ‘local’
[13:20:45.542]   - Field: ‘owner’
[13:20:45.542]   - Field: ‘envir’
[13:20:45.542]   - Field: ‘workers’
[13:20:45.542]   - Field: ‘packages’
[13:20:45.542]   - Field: ‘gc’
[13:20:45.542]   - Field: ‘job’
[13:20:45.543]   - Field: ‘conditions’
[13:20:45.543]   - Field: ‘expr’
[13:20:45.543]   - Field: ‘uuid’
[13:20:45.543]   - Field: ‘seed’
[13:20:45.543]   - Field: ‘version’
[13:20:45.543]   - Field: ‘result’
[13:20:45.543]   - Field: ‘asynchronous’
[13:20:45.543]   - Field: ‘calls’
[13:20:45.543]   - Field: ‘globals’
[13:20:45.544]   - Field: ‘stdout’
[13:20:45.544]   - Field: ‘earlySignal’
[13:20:45.544]   - Field: ‘lazy’
[13:20:45.544]   - Field: ‘state’
[13:20:45.544] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.544] - Launch lazy future ...
[13:20:45.545] Packages needed by the future expression (n = 0): <none>
[13:20:45.545] Packages needed by future strategies (n = 0): <none>
[13:20:45.545] {
[13:20:45.545]     {
[13:20:45.545]         {
[13:20:45.545]             ...future.startTime <- base::Sys.time()
[13:20:45.545]             {
[13:20:45.545]                 {
[13:20:45.545]                   {
[13:20:45.545]                     {
[13:20:45.545]                       base::local({
[13:20:45.545]                         has_future <- base::requireNamespace("future", 
[13:20:45.545]                           quietly = TRUE)
[13:20:45.545]                         if (has_future) {
[13:20:45.545]                           ns <- base::getNamespace("future")
[13:20:45.545]                           version <- ns[[".package"]][["version"]]
[13:20:45.545]                           if (is.null(version)) 
[13:20:45.545]                             version <- utils::packageVersion("future")
[13:20:45.545]                         }
[13:20:45.545]                         else {
[13:20:45.545]                           version <- NULL
[13:20:45.545]                         }
[13:20:45.545]                         if (!has_future || version < "1.8.0") {
[13:20:45.545]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.545]                             "", base::R.version$version.string), 
[13:20:45.545]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.545]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.545]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.545]                               "release", "version")], collapse = " "), 
[13:20:45.545]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.545]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.545]                             info)
[13:20:45.545]                           info <- base::paste(info, collapse = "; ")
[13:20:45.545]                           if (!has_future) {
[13:20:45.545]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.545]                               info)
[13:20:45.545]                           }
[13:20:45.545]                           else {
[13:20:45.545]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.545]                               info, version)
[13:20:45.545]                           }
[13:20:45.545]                           base::stop(msg)
[13:20:45.545]                         }
[13:20:45.545]                       })
[13:20:45.545]                     }
[13:20:45.545]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.545]                     base::options(mc.cores = 1L)
[13:20:45.545]                   }
[13:20:45.545]                   options(future.plan = NULL)
[13:20:45.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.545]                 }
[13:20:45.545]                 ...future.workdir <- getwd()
[13:20:45.545]             }
[13:20:45.545]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.545]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.545]         }
[13:20:45.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.545]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.545]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.545]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.545]             base::names(...future.oldOptions))
[13:20:45.545]     }
[13:20:45.545]     if (FALSE) {
[13:20:45.545]     }
[13:20:45.545]     else {
[13:20:45.545]         if (TRUE) {
[13:20:45.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.545]                 open = "w")
[13:20:45.545]         }
[13:20:45.545]         else {
[13:20:45.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.545]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.545]         }
[13:20:45.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.545]             base::sink(type = "output", split = FALSE)
[13:20:45.545]             base::close(...future.stdout)
[13:20:45.545]         }, add = TRUE)
[13:20:45.545]     }
[13:20:45.545]     ...future.frame <- base::sys.nframe()
[13:20:45.545]     ...future.conditions <- base::list()
[13:20:45.545]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.545]     if (FALSE) {
[13:20:45.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.545]     }
[13:20:45.545]     ...future.result <- base::tryCatch({
[13:20:45.545]         base::withCallingHandlers({
[13:20:45.545]             ...future.value <- base::withVisible(base::local({
[13:20:45.545]                 withCallingHandlers({
[13:20:45.545]                   {
[13:20:45.545]                     x["a"] <- list(1)
[13:20:45.545]                     x
[13:20:45.545]                   }
[13:20:45.545]                 }, immediateCondition = function(cond) {
[13:20:45.545]                   save_rds <- function (object, pathname, ...) 
[13:20:45.545]                   {
[13:20:45.545]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.545]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.545]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.545]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.545]                         fi_tmp[["mtime"]])
[13:20:45.545]                     }
[13:20:45.545]                     tryCatch({
[13:20:45.545]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.545]                     }, error = function(ex) {
[13:20:45.545]                       msg <- conditionMessage(ex)
[13:20:45.545]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.545]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.545]                         fi_tmp[["mtime"]], msg)
[13:20:45.545]                       ex$message <- msg
[13:20:45.545]                       stop(ex)
[13:20:45.545]                     })
[13:20:45.545]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.545]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.545]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.545]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.545]                       fi <- file.info(pathname)
[13:20:45.545]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.545]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.545]                         fi[["size"]], fi[["mtime"]])
[13:20:45.545]                       stop(msg)
[13:20:45.545]                     }
[13:20:45.545]                     invisible(pathname)
[13:20:45.545]                   }
[13:20:45.545]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.545]                     rootPath = tempdir()) 
[13:20:45.545]                   {
[13:20:45.545]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.545]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.545]                       tmpdir = path, fileext = ".rds")
[13:20:45.545]                     save_rds(obj, file)
[13:20:45.545]                   }
[13:20:45.545]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.545]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.545]                   {
[13:20:45.545]                     inherits <- base::inherits
[13:20:45.545]                     invokeRestart <- base::invokeRestart
[13:20:45.545]                     is.null <- base::is.null
[13:20:45.545]                     muffled <- FALSE
[13:20:45.545]                     if (inherits(cond, "message")) {
[13:20:45.545]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.545]                       if (muffled) 
[13:20:45.545]                         invokeRestart("muffleMessage")
[13:20:45.545]                     }
[13:20:45.545]                     else if (inherits(cond, "warning")) {
[13:20:45.545]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.545]                       if (muffled) 
[13:20:45.545]                         invokeRestart("muffleWarning")
[13:20:45.545]                     }
[13:20:45.545]                     else if (inherits(cond, "condition")) {
[13:20:45.545]                       if (!is.null(pattern)) {
[13:20:45.545]                         computeRestarts <- base::computeRestarts
[13:20:45.545]                         grepl <- base::grepl
[13:20:45.545]                         restarts <- computeRestarts(cond)
[13:20:45.545]                         for (restart in restarts) {
[13:20:45.545]                           name <- restart$name
[13:20:45.545]                           if (is.null(name)) 
[13:20:45.545]                             next
[13:20:45.545]                           if (!grepl(pattern, name)) 
[13:20:45.545]                             next
[13:20:45.545]                           invokeRestart(restart)
[13:20:45.545]                           muffled <- TRUE
[13:20:45.545]                           break
[13:20:45.545]                         }
[13:20:45.545]                       }
[13:20:45.545]                     }
[13:20:45.545]                     invisible(muffled)
[13:20:45.545]                   }
[13:20:45.545]                   muffleCondition(cond)
[13:20:45.545]                 })
[13:20:45.545]             }))
[13:20:45.545]             future::FutureResult(value = ...future.value$value, 
[13:20:45.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.545]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.545]                     ...future.globalenv.names))
[13:20:45.545]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.545]         }, condition = base::local({
[13:20:45.545]             c <- base::c
[13:20:45.545]             inherits <- base::inherits
[13:20:45.545]             invokeRestart <- base::invokeRestart
[13:20:45.545]             length <- base::length
[13:20:45.545]             list <- base::list
[13:20:45.545]             seq.int <- base::seq.int
[13:20:45.545]             signalCondition <- base::signalCondition
[13:20:45.545]             sys.calls <- base::sys.calls
[13:20:45.545]             `[[` <- base::`[[`
[13:20:45.545]             `+` <- base::`+`
[13:20:45.545]             `<<-` <- base::`<<-`
[13:20:45.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.545]                   3L)]
[13:20:45.545]             }
[13:20:45.545]             function(cond) {
[13:20:45.545]                 is_error <- inherits(cond, "error")
[13:20:45.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.545]                   NULL)
[13:20:45.545]                 if (is_error) {
[13:20:45.545]                   sessionInformation <- function() {
[13:20:45.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.545]                       search = base::search(), system = base::Sys.info())
[13:20:45.545]                   }
[13:20:45.545]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.545]                     cond$call), session = sessionInformation(), 
[13:20:45.545]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.545]                   signalCondition(cond)
[13:20:45.545]                 }
[13:20:45.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.545]                 "immediateCondition"))) {
[13:20:45.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.545]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.545]                   if (TRUE && !signal) {
[13:20:45.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.545]                     {
[13:20:45.545]                       inherits <- base::inherits
[13:20:45.545]                       invokeRestart <- base::invokeRestart
[13:20:45.545]                       is.null <- base::is.null
[13:20:45.545]                       muffled <- FALSE
[13:20:45.545]                       if (inherits(cond, "message")) {
[13:20:45.545]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.545]                         if (muffled) 
[13:20:45.545]                           invokeRestart("muffleMessage")
[13:20:45.545]                       }
[13:20:45.545]                       else if (inherits(cond, "warning")) {
[13:20:45.545]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.545]                         if (muffled) 
[13:20:45.545]                           invokeRestart("muffleWarning")
[13:20:45.545]                       }
[13:20:45.545]                       else if (inherits(cond, "condition")) {
[13:20:45.545]                         if (!is.null(pattern)) {
[13:20:45.545]                           computeRestarts <- base::computeRestarts
[13:20:45.545]                           grepl <- base::grepl
[13:20:45.545]                           restarts <- computeRestarts(cond)
[13:20:45.545]                           for (restart in restarts) {
[13:20:45.545]                             name <- restart$name
[13:20:45.545]                             if (is.null(name)) 
[13:20:45.545]                               next
[13:20:45.545]                             if (!grepl(pattern, name)) 
[13:20:45.545]                               next
[13:20:45.545]                             invokeRestart(restart)
[13:20:45.545]                             muffled <- TRUE
[13:20:45.545]                             break
[13:20:45.545]                           }
[13:20:45.545]                         }
[13:20:45.545]                       }
[13:20:45.545]                       invisible(muffled)
[13:20:45.545]                     }
[13:20:45.545]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.545]                   }
[13:20:45.545]                 }
[13:20:45.545]                 else {
[13:20:45.545]                   if (TRUE) {
[13:20:45.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.545]                     {
[13:20:45.545]                       inherits <- base::inherits
[13:20:45.545]                       invokeRestart <- base::invokeRestart
[13:20:45.545]                       is.null <- base::is.null
[13:20:45.545]                       muffled <- FALSE
[13:20:45.545]                       if (inherits(cond, "message")) {
[13:20:45.545]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.545]                         if (muffled) 
[13:20:45.545]                           invokeRestart("muffleMessage")
[13:20:45.545]                       }
[13:20:45.545]                       else if (inherits(cond, "warning")) {
[13:20:45.545]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.545]                         if (muffled) 
[13:20:45.545]                           invokeRestart("muffleWarning")
[13:20:45.545]                       }
[13:20:45.545]                       else if (inherits(cond, "condition")) {
[13:20:45.545]                         if (!is.null(pattern)) {
[13:20:45.545]                           computeRestarts <- base::computeRestarts
[13:20:45.545]                           grepl <- base::grepl
[13:20:45.545]                           restarts <- computeRestarts(cond)
[13:20:45.545]                           for (restart in restarts) {
[13:20:45.545]                             name <- restart$name
[13:20:45.545]                             if (is.null(name)) 
[13:20:45.545]                               next
[13:20:45.545]                             if (!grepl(pattern, name)) 
[13:20:45.545]                               next
[13:20:45.545]                             invokeRestart(restart)
[13:20:45.545]                             muffled <- TRUE
[13:20:45.545]                             break
[13:20:45.545]                           }
[13:20:45.545]                         }
[13:20:45.545]                       }
[13:20:45.545]                       invisible(muffled)
[13:20:45.545]                     }
[13:20:45.545]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.545]                   }
[13:20:45.545]                 }
[13:20:45.545]             }
[13:20:45.545]         }))
[13:20:45.545]     }, error = function(ex) {
[13:20:45.545]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.545]                 ...future.rng), started = ...future.startTime, 
[13:20:45.545]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.545]             version = "1.8"), class = "FutureResult")
[13:20:45.545]     }, finally = {
[13:20:45.545]         if (!identical(...future.workdir, getwd())) 
[13:20:45.545]             setwd(...future.workdir)
[13:20:45.545]         {
[13:20:45.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.545]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.545]             }
[13:20:45.545]             base::options(...future.oldOptions)
[13:20:45.545]             if (.Platform$OS.type == "windows") {
[13:20:45.545]                 old_names <- names(...future.oldEnvVars)
[13:20:45.545]                 envs <- base::Sys.getenv()
[13:20:45.545]                 names <- names(envs)
[13:20:45.545]                 common <- intersect(names, old_names)
[13:20:45.545]                 added <- setdiff(names, old_names)
[13:20:45.545]                 removed <- setdiff(old_names, names)
[13:20:45.545]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.545]                   envs[common]]
[13:20:45.545]                 NAMES <- toupper(changed)
[13:20:45.545]                 args <- list()
[13:20:45.545]                 for (kk in seq_along(NAMES)) {
[13:20:45.545]                   name <- changed[[kk]]
[13:20:45.545]                   NAME <- NAMES[[kk]]
[13:20:45.545]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.545]                     next
[13:20:45.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.545]                 }
[13:20:45.545]                 NAMES <- toupper(added)
[13:20:45.545]                 for (kk in seq_along(NAMES)) {
[13:20:45.545]                   name <- added[[kk]]
[13:20:45.545]                   NAME <- NAMES[[kk]]
[13:20:45.545]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.545]                     next
[13:20:45.545]                   args[[name]] <- ""
[13:20:45.545]                 }
[13:20:45.545]                 NAMES <- toupper(removed)
[13:20:45.545]                 for (kk in seq_along(NAMES)) {
[13:20:45.545]                   name <- removed[[kk]]
[13:20:45.545]                   NAME <- NAMES[[kk]]
[13:20:45.545]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.545]                     next
[13:20:45.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.545]                 }
[13:20:45.545]                 if (length(args) > 0) 
[13:20:45.545]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.545]             }
[13:20:45.545]             else {
[13:20:45.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.545]             }
[13:20:45.545]             {
[13:20:45.545]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.545]                   0L) {
[13:20:45.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.545]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.545]                   base::options(opts)
[13:20:45.545]                 }
[13:20:45.545]                 {
[13:20:45.545]                   {
[13:20:45.545]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.545]                     NULL
[13:20:45.545]                   }
[13:20:45.545]                   options(future.plan = NULL)
[13:20:45.545]                   if (is.na(NA_character_)) 
[13:20:45.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.545]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.545]                     envir = parent.frame()) 
[13:20:45.545]                   {
[13:20:45.545]                     default_workers <- missing(workers)
[13:20:45.545]                     if (is.function(workers)) 
[13:20:45.545]                       workers <- workers()
[13:20:45.545]                     workers <- structure(as.integer(workers), 
[13:20:45.545]                       class = class(workers))
[13:20:45.545]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.545]                       1L)
[13:20:45.545]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.545]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.545]                       if (default_workers) 
[13:20:45.545]                         supportsMulticore(warn = TRUE)
[13:20:45.545]                       return(sequential(..., envir = envir))
[13:20:45.545]                     }
[13:20:45.545]                     oopts <- options(mc.cores = workers)
[13:20:45.545]                     on.exit(options(oopts))
[13:20:45.545]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.545]                       envir = envir)
[13:20:45.545]                     if (!future$lazy) 
[13:20:45.545]                       future <- run(future)
[13:20:45.545]                     invisible(future)
[13:20:45.545]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.545]                 }
[13:20:45.545]             }
[13:20:45.545]         }
[13:20:45.545]     })
[13:20:45.545]     if (TRUE) {
[13:20:45.545]         base::sink(type = "output", split = FALSE)
[13:20:45.545]         if (TRUE) {
[13:20:45.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.545]         }
[13:20:45.545]         else {
[13:20:45.545]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.545]         }
[13:20:45.545]         base::close(...future.stdout)
[13:20:45.545]         ...future.stdout <- NULL
[13:20:45.545]     }
[13:20:45.545]     ...future.result$conditions <- ...future.conditions
[13:20:45.545]     ...future.result$finished <- base::Sys.time()
[13:20:45.545]     ...future.result
[13:20:45.545] }
[13:20:45.548] assign_globals() ...
[13:20:45.548] List of 1
[13:20:45.548]  $ x: list()
[13:20:45.548]  - attr(*, "where")=List of 1
[13:20:45.548]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.548]  - attr(*, "resolved")= logi TRUE
[13:20:45.548]  - attr(*, "total_size")= num 0
[13:20:45.548]  - attr(*, "already-done")= logi TRUE
[13:20:45.551] - copied ‘x’ to environment
[13:20:45.551] assign_globals() ... done
[13:20:45.552] requestCore(): workers = 2
[13:20:45.554] MulticoreFuture started
[13:20:45.554] - Launch lazy future ... done
[13:20:45.554] run() for ‘MulticoreFuture’ ... done
[13:20:45.555] plan(): Setting new future strategy stack:
[13:20:45.555] List of future strategies:
[13:20:45.555] 1. sequential:
[13:20:45.555]    - args: function (..., envir = parent.frame())
[13:20:45.555]    - tweaked: FALSE
[13:20:45.555]    - call: NULL
[13:20:45.556] plan(): nbrOfWorkers() = 1
[13:20:45.558] plan(): Setting new future strategy stack:
[13:20:45.558] List of future strategies:
[13:20:45.558] 1. multicore:
[13:20:45.558]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.558]    - tweaked: FALSE
[13:20:45.558]    - call: plan(strategy)
[13:20:45.568] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.570] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.570] Searching for globals...
[13:20:45.576] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.576] Searching for globals ... DONE
[13:20:45.577] Resolving globals: TRUE
[13:20:45.577] Resolving any globals that are futures ...
[13:20:45.577] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.577] Resolving any globals that are futures ... DONE
[13:20:45.578] Resolving futures part of globals (recursively) ...
[13:20:45.578] resolve() on list ...
[13:20:45.578]  recursive: 99
[13:20:45.578]  length: 1
[13:20:45.578]  elements: ‘x’
[13:20:45.578]  length: 0 (resolved future 1)
[13:20:45.579] resolve() on list ... DONE
[13:20:45.579] - globals: [1] ‘x’
[13:20:45.579] Resolving futures part of globals (recursively) ... DONE
[13:20:45.579] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.579] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.580] - globals: [1] ‘x’
[13:20:45.580] 
[13:20:45.580] getGlobalsAndPackages() ... DONE
[13:20:45.580] run() for ‘Future’ ...
[13:20:45.580] - state: ‘created’
[13:20:45.580] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.584] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.585] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.585]   - Field: ‘label’
[13:20:45.585]   - Field: ‘local’
[13:20:45.585]   - Field: ‘owner’
[13:20:45.585]   - Field: ‘envir’
[13:20:45.585]   - Field: ‘workers’
[13:20:45.585]   - Field: ‘packages’
[13:20:45.585]   - Field: ‘gc’
[13:20:45.586]   - Field: ‘job’
[13:20:45.586]   - Field: ‘conditions’
[13:20:45.586]   - Field: ‘expr’
[13:20:45.586]   - Field: ‘uuid’
[13:20:45.586]   - Field: ‘seed’
[13:20:45.586]   - Field: ‘version’
[13:20:45.586]   - Field: ‘result’
[13:20:45.586]   - Field: ‘asynchronous’
[13:20:45.586]   - Field: ‘calls’
[13:20:45.587]   - Field: ‘globals’
[13:20:45.587]   - Field: ‘stdout’
[13:20:45.587]   - Field: ‘earlySignal’
[13:20:45.587]   - Field: ‘lazy’
[13:20:45.587]   - Field: ‘state’
[13:20:45.587] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.587] - Launch lazy future ...
[13:20:45.588] Packages needed by the future expression (n = 0): <none>
[13:20:45.588] Packages needed by future strategies (n = 0): <none>
[13:20:45.588] {
[13:20:45.588]     {
[13:20:45.588]         {
[13:20:45.588]             ...future.startTime <- base::Sys.time()
[13:20:45.588]             {
[13:20:45.588]                 {
[13:20:45.588]                   {
[13:20:45.588]                     {
[13:20:45.588]                       base::local({
[13:20:45.588]                         has_future <- base::requireNamespace("future", 
[13:20:45.588]                           quietly = TRUE)
[13:20:45.588]                         if (has_future) {
[13:20:45.588]                           ns <- base::getNamespace("future")
[13:20:45.588]                           version <- ns[[".package"]][["version"]]
[13:20:45.588]                           if (is.null(version)) 
[13:20:45.588]                             version <- utils::packageVersion("future")
[13:20:45.588]                         }
[13:20:45.588]                         else {
[13:20:45.588]                           version <- NULL
[13:20:45.588]                         }
[13:20:45.588]                         if (!has_future || version < "1.8.0") {
[13:20:45.588]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.588]                             "", base::R.version$version.string), 
[13:20:45.588]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.588]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.588]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.588]                               "release", "version")], collapse = " "), 
[13:20:45.588]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.588]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.588]                             info)
[13:20:45.588]                           info <- base::paste(info, collapse = "; ")
[13:20:45.588]                           if (!has_future) {
[13:20:45.588]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.588]                               info)
[13:20:45.588]                           }
[13:20:45.588]                           else {
[13:20:45.588]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.588]                               info, version)
[13:20:45.588]                           }
[13:20:45.588]                           base::stop(msg)
[13:20:45.588]                         }
[13:20:45.588]                       })
[13:20:45.588]                     }
[13:20:45.588]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.588]                     base::options(mc.cores = 1L)
[13:20:45.588]                   }
[13:20:45.588]                   options(future.plan = NULL)
[13:20:45.588]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.588]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.588]                 }
[13:20:45.588]                 ...future.workdir <- getwd()
[13:20:45.588]             }
[13:20:45.588]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.588]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.588]         }
[13:20:45.588]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.588]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.588]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.588]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.588]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.588]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.588]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.588]             base::names(...future.oldOptions))
[13:20:45.588]     }
[13:20:45.588]     if (FALSE) {
[13:20:45.588]     }
[13:20:45.588]     else {
[13:20:45.588]         if (TRUE) {
[13:20:45.588]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.588]                 open = "w")
[13:20:45.588]         }
[13:20:45.588]         else {
[13:20:45.588]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.588]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.588]         }
[13:20:45.588]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.588]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.588]             base::sink(type = "output", split = FALSE)
[13:20:45.588]             base::close(...future.stdout)
[13:20:45.588]         }, add = TRUE)
[13:20:45.588]     }
[13:20:45.588]     ...future.frame <- base::sys.nframe()
[13:20:45.588]     ...future.conditions <- base::list()
[13:20:45.588]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.588]     if (FALSE) {
[13:20:45.588]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.588]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.588]     }
[13:20:45.588]     ...future.result <- base::tryCatch({
[13:20:45.588]         base::withCallingHandlers({
[13:20:45.588]             ...future.value <- base::withVisible(base::local({
[13:20:45.588]                 withCallingHandlers({
[13:20:45.588]                   {
[13:20:45.588]                     x["a"] <- list(1)
[13:20:45.588]                     x
[13:20:45.588]                   }
[13:20:45.588]                 }, immediateCondition = function(cond) {
[13:20:45.588]                   save_rds <- function (object, pathname, ...) 
[13:20:45.588]                   {
[13:20:45.588]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.588]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.588]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.588]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.588]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.588]                         fi_tmp[["mtime"]])
[13:20:45.588]                     }
[13:20:45.588]                     tryCatch({
[13:20:45.588]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.588]                     }, error = function(ex) {
[13:20:45.588]                       msg <- conditionMessage(ex)
[13:20:45.588]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.588]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.588]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.588]                         fi_tmp[["mtime"]], msg)
[13:20:45.588]                       ex$message <- msg
[13:20:45.588]                       stop(ex)
[13:20:45.588]                     })
[13:20:45.588]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.588]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.588]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.588]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.588]                       fi <- file.info(pathname)
[13:20:45.588]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.588]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.588]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.588]                         fi[["size"]], fi[["mtime"]])
[13:20:45.588]                       stop(msg)
[13:20:45.588]                     }
[13:20:45.588]                     invisible(pathname)
[13:20:45.588]                   }
[13:20:45.588]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.588]                     rootPath = tempdir()) 
[13:20:45.588]                   {
[13:20:45.588]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.588]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.588]                       tmpdir = path, fileext = ".rds")
[13:20:45.588]                     save_rds(obj, file)
[13:20:45.588]                   }
[13:20:45.588]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.588]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.588]                   {
[13:20:45.588]                     inherits <- base::inherits
[13:20:45.588]                     invokeRestart <- base::invokeRestart
[13:20:45.588]                     is.null <- base::is.null
[13:20:45.588]                     muffled <- FALSE
[13:20:45.588]                     if (inherits(cond, "message")) {
[13:20:45.588]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.588]                       if (muffled) 
[13:20:45.588]                         invokeRestart("muffleMessage")
[13:20:45.588]                     }
[13:20:45.588]                     else if (inherits(cond, "warning")) {
[13:20:45.588]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.588]                       if (muffled) 
[13:20:45.588]                         invokeRestart("muffleWarning")
[13:20:45.588]                     }
[13:20:45.588]                     else if (inherits(cond, "condition")) {
[13:20:45.588]                       if (!is.null(pattern)) {
[13:20:45.588]                         computeRestarts <- base::computeRestarts
[13:20:45.588]                         grepl <- base::grepl
[13:20:45.588]                         restarts <- computeRestarts(cond)
[13:20:45.588]                         for (restart in restarts) {
[13:20:45.588]                           name <- restart$name
[13:20:45.588]                           if (is.null(name)) 
[13:20:45.588]                             next
[13:20:45.588]                           if (!grepl(pattern, name)) 
[13:20:45.588]                             next
[13:20:45.588]                           invokeRestart(restart)
[13:20:45.588]                           muffled <- TRUE
[13:20:45.588]                           break
[13:20:45.588]                         }
[13:20:45.588]                       }
[13:20:45.588]                     }
[13:20:45.588]                     invisible(muffled)
[13:20:45.588]                   }
[13:20:45.588]                   muffleCondition(cond)
[13:20:45.588]                 })
[13:20:45.588]             }))
[13:20:45.588]             future::FutureResult(value = ...future.value$value, 
[13:20:45.588]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.588]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.588]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.588]                     ...future.globalenv.names))
[13:20:45.588]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.588]         }, condition = base::local({
[13:20:45.588]             c <- base::c
[13:20:45.588]             inherits <- base::inherits
[13:20:45.588]             invokeRestart <- base::invokeRestart
[13:20:45.588]             length <- base::length
[13:20:45.588]             list <- base::list
[13:20:45.588]             seq.int <- base::seq.int
[13:20:45.588]             signalCondition <- base::signalCondition
[13:20:45.588]             sys.calls <- base::sys.calls
[13:20:45.588]             `[[` <- base::`[[`
[13:20:45.588]             `+` <- base::`+`
[13:20:45.588]             `<<-` <- base::`<<-`
[13:20:45.588]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.588]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.588]                   3L)]
[13:20:45.588]             }
[13:20:45.588]             function(cond) {
[13:20:45.588]                 is_error <- inherits(cond, "error")
[13:20:45.588]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.588]                   NULL)
[13:20:45.588]                 if (is_error) {
[13:20:45.588]                   sessionInformation <- function() {
[13:20:45.588]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.588]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.588]                       search = base::search(), system = base::Sys.info())
[13:20:45.588]                   }
[13:20:45.588]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.588]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.588]                     cond$call), session = sessionInformation(), 
[13:20:45.588]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.588]                   signalCondition(cond)
[13:20:45.588]                 }
[13:20:45.588]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.588]                 "immediateCondition"))) {
[13:20:45.588]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.588]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.588]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.588]                   if (TRUE && !signal) {
[13:20:45.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.588]                     {
[13:20:45.588]                       inherits <- base::inherits
[13:20:45.588]                       invokeRestart <- base::invokeRestart
[13:20:45.588]                       is.null <- base::is.null
[13:20:45.588]                       muffled <- FALSE
[13:20:45.588]                       if (inherits(cond, "message")) {
[13:20:45.588]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.588]                         if (muffled) 
[13:20:45.588]                           invokeRestart("muffleMessage")
[13:20:45.588]                       }
[13:20:45.588]                       else if (inherits(cond, "warning")) {
[13:20:45.588]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.588]                         if (muffled) 
[13:20:45.588]                           invokeRestart("muffleWarning")
[13:20:45.588]                       }
[13:20:45.588]                       else if (inherits(cond, "condition")) {
[13:20:45.588]                         if (!is.null(pattern)) {
[13:20:45.588]                           computeRestarts <- base::computeRestarts
[13:20:45.588]                           grepl <- base::grepl
[13:20:45.588]                           restarts <- computeRestarts(cond)
[13:20:45.588]                           for (restart in restarts) {
[13:20:45.588]                             name <- restart$name
[13:20:45.588]                             if (is.null(name)) 
[13:20:45.588]                               next
[13:20:45.588]                             if (!grepl(pattern, name)) 
[13:20:45.588]                               next
[13:20:45.588]                             invokeRestart(restart)
[13:20:45.588]                             muffled <- TRUE
[13:20:45.588]                             break
[13:20:45.588]                           }
[13:20:45.588]                         }
[13:20:45.588]                       }
[13:20:45.588]                       invisible(muffled)
[13:20:45.588]                     }
[13:20:45.588]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.588]                   }
[13:20:45.588]                 }
[13:20:45.588]                 else {
[13:20:45.588]                   if (TRUE) {
[13:20:45.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.588]                     {
[13:20:45.588]                       inherits <- base::inherits
[13:20:45.588]                       invokeRestart <- base::invokeRestart
[13:20:45.588]                       is.null <- base::is.null
[13:20:45.588]                       muffled <- FALSE
[13:20:45.588]                       if (inherits(cond, "message")) {
[13:20:45.588]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.588]                         if (muffled) 
[13:20:45.588]                           invokeRestart("muffleMessage")
[13:20:45.588]                       }
[13:20:45.588]                       else if (inherits(cond, "warning")) {
[13:20:45.588]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.588]                         if (muffled) 
[13:20:45.588]                           invokeRestart("muffleWarning")
[13:20:45.588]                       }
[13:20:45.588]                       else if (inherits(cond, "condition")) {
[13:20:45.588]                         if (!is.null(pattern)) {
[13:20:45.588]                           computeRestarts <- base::computeRestarts
[13:20:45.588]                           grepl <- base::grepl
[13:20:45.588]                           restarts <- computeRestarts(cond)
[13:20:45.588]                           for (restart in restarts) {
[13:20:45.588]                             name <- restart$name
[13:20:45.588]                             if (is.null(name)) 
[13:20:45.588]                               next
[13:20:45.588]                             if (!grepl(pattern, name)) 
[13:20:45.588]                               next
[13:20:45.588]                             invokeRestart(restart)
[13:20:45.588]                             muffled <- TRUE
[13:20:45.588]                             break
[13:20:45.588]                           }
[13:20:45.588]                         }
[13:20:45.588]                       }
[13:20:45.588]                       invisible(muffled)
[13:20:45.588]                     }
[13:20:45.588]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.588]                   }
[13:20:45.588]                 }
[13:20:45.588]             }
[13:20:45.588]         }))
[13:20:45.588]     }, error = function(ex) {
[13:20:45.588]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.588]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.588]                 ...future.rng), started = ...future.startTime, 
[13:20:45.588]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.588]             version = "1.8"), class = "FutureResult")
[13:20:45.588]     }, finally = {
[13:20:45.588]         if (!identical(...future.workdir, getwd())) 
[13:20:45.588]             setwd(...future.workdir)
[13:20:45.588]         {
[13:20:45.588]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.588]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.588]             }
[13:20:45.588]             base::options(...future.oldOptions)
[13:20:45.588]             if (.Platform$OS.type == "windows") {
[13:20:45.588]                 old_names <- names(...future.oldEnvVars)
[13:20:45.588]                 envs <- base::Sys.getenv()
[13:20:45.588]                 names <- names(envs)
[13:20:45.588]                 common <- intersect(names, old_names)
[13:20:45.588]                 added <- setdiff(names, old_names)
[13:20:45.588]                 removed <- setdiff(old_names, names)
[13:20:45.588]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.588]                   envs[common]]
[13:20:45.588]                 NAMES <- toupper(changed)
[13:20:45.588]                 args <- list()
[13:20:45.588]                 for (kk in seq_along(NAMES)) {
[13:20:45.588]                   name <- changed[[kk]]
[13:20:45.588]                   NAME <- NAMES[[kk]]
[13:20:45.588]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.588]                     next
[13:20:45.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.588]                 }
[13:20:45.588]                 NAMES <- toupper(added)
[13:20:45.588]                 for (kk in seq_along(NAMES)) {
[13:20:45.588]                   name <- added[[kk]]
[13:20:45.588]                   NAME <- NAMES[[kk]]
[13:20:45.588]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.588]                     next
[13:20:45.588]                   args[[name]] <- ""
[13:20:45.588]                 }
[13:20:45.588]                 NAMES <- toupper(removed)
[13:20:45.588]                 for (kk in seq_along(NAMES)) {
[13:20:45.588]                   name <- removed[[kk]]
[13:20:45.588]                   NAME <- NAMES[[kk]]
[13:20:45.588]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.588]                     next
[13:20:45.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.588]                 }
[13:20:45.588]                 if (length(args) > 0) 
[13:20:45.588]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.588]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.588]             }
[13:20:45.588]             else {
[13:20:45.588]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.588]             }
[13:20:45.588]             {
[13:20:45.588]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.588]                   0L) {
[13:20:45.588]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.588]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.588]                   base::options(opts)
[13:20:45.588]                 }
[13:20:45.588]                 {
[13:20:45.588]                   {
[13:20:45.588]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.588]                     NULL
[13:20:45.588]                   }
[13:20:45.588]                   options(future.plan = NULL)
[13:20:45.588]                   if (is.na(NA_character_)) 
[13:20:45.588]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.588]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.588]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.588]                     envir = parent.frame()) 
[13:20:45.588]                   {
[13:20:45.588]                     default_workers <- missing(workers)
[13:20:45.588]                     if (is.function(workers)) 
[13:20:45.588]                       workers <- workers()
[13:20:45.588]                     workers <- structure(as.integer(workers), 
[13:20:45.588]                       class = class(workers))
[13:20:45.588]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.588]                       1L)
[13:20:45.588]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.588]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.588]                       if (default_workers) 
[13:20:45.588]                         supportsMulticore(warn = TRUE)
[13:20:45.588]                       return(sequential(..., envir = envir))
[13:20:45.588]                     }
[13:20:45.588]                     oopts <- options(mc.cores = workers)
[13:20:45.588]                     on.exit(options(oopts))
[13:20:45.588]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.588]                       envir = envir)
[13:20:45.588]                     if (!future$lazy) 
[13:20:45.588]                       future <- run(future)
[13:20:45.588]                     invisible(future)
[13:20:45.588]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.588]                 }
[13:20:45.588]             }
[13:20:45.588]         }
[13:20:45.588]     })
[13:20:45.588]     if (TRUE) {
[13:20:45.588]         base::sink(type = "output", split = FALSE)
[13:20:45.588]         if (TRUE) {
[13:20:45.588]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.588]         }
[13:20:45.588]         else {
[13:20:45.588]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.588]         }
[13:20:45.588]         base::close(...future.stdout)
[13:20:45.588]         ...future.stdout <- NULL
[13:20:45.588]     }
[13:20:45.588]     ...future.result$conditions <- ...future.conditions
[13:20:45.588]     ...future.result$finished <- base::Sys.time()
[13:20:45.588]     ...future.result
[13:20:45.588] }
[13:20:45.591] assign_globals() ...
[13:20:45.591] List of 1
[13:20:45.591]  $ x: list()
[13:20:45.591]  - attr(*, "where")=List of 1
[13:20:45.591]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.591]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.591]  - attr(*, "resolved")= logi TRUE
[13:20:45.591]  - attr(*, "total_size")= num 0
[13:20:45.591]  - attr(*, "already-done")= logi TRUE
[13:20:45.594] - copied ‘x’ to environment
[13:20:45.594] assign_globals() ... done
[13:20:45.594] requestCore(): workers = 2
[13:20:45.596] MulticoreFuture started
[13:20:45.596] - Launch lazy future ... done
[13:20:45.597] run() for ‘MulticoreFuture’ ... done
[13:20:45.597] plan(): Setting new future strategy stack:
[13:20:45.598] List of future strategies:
[13:20:45.598] 1. sequential:
[13:20:45.598]    - args: function (..., envir = parent.frame())
[13:20:45.598]    - tweaked: FALSE
[13:20:45.598]    - call: NULL
[13:20:45.598] plan(): nbrOfWorkers() = 1
[13:20:45.600] plan(): Setting new future strategy stack:
[13:20:45.601] List of future strategies:
[13:20:45.601] 1. multicore:
[13:20:45.601]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.601]    - tweaked: FALSE
[13:20:45.601]    - call: plan(strategy)
[13:20:45.606] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.608] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.608] Searching for globals...
[13:20:45.611] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.611] Searching for globals ... DONE
[13:20:45.611] Resolving globals: TRUE
[13:20:45.611] Resolving any globals that are futures ...
[13:20:45.611] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:45.612] Resolving any globals that are futures ... DONE
[13:20:45.612] Resolving futures part of globals (recursively) ...
[13:20:45.612] resolve() on list ...
[13:20:45.613]  recursive: 99
[13:20:45.613]  length: 1
[13:20:45.613]  elements: ‘x’
[13:20:45.613]  length: 0 (resolved future 1)
[13:20:45.613] resolve() on list ... DONE
[13:20:45.613] - globals: [1] ‘x’
[13:20:45.613] Resolving futures part of globals (recursively) ... DONE
[13:20:45.614] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:45.614] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:45.614] - globals: [1] ‘x’
[13:20:45.614] 
[13:20:45.614] getGlobalsAndPackages() ... DONE
[13:20:45.615] run() for ‘Future’ ...
[13:20:45.615] - state: ‘created’
[13:20:45.615] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.619] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.620] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.620]   - Field: ‘label’
[13:20:45.620]   - Field: ‘local’
[13:20:45.620]   - Field: ‘owner’
[13:20:45.620]   - Field: ‘envir’
[13:20:45.620]   - Field: ‘workers’
[13:20:45.620]   - Field: ‘packages’
[13:20:45.620]   - Field: ‘gc’
[13:20:45.623]   - Field: ‘job’
[13:20:45.623]   - Field: ‘conditions’
[13:20:45.623]   - Field: ‘expr’
[13:20:45.624]   - Field: ‘uuid’
[13:20:45.624]   - Field: ‘seed’
[13:20:45.624]   - Field: ‘version’
[13:20:45.624]   - Field: ‘result’
[13:20:45.624]   - Field: ‘asynchronous’
[13:20:45.624]   - Field: ‘calls’
[13:20:45.624]   - Field: ‘globals’
[13:20:45.624]   - Field: ‘stdout’
[13:20:45.625]   - Field: ‘earlySignal’
[13:20:45.625]   - Field: ‘lazy’
[13:20:45.625]   - Field: ‘state’
[13:20:45.625] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.625] - Launch lazy future ...
[13:20:45.626] Packages needed by the future expression (n = 0): <none>
[13:20:45.626] Packages needed by future strategies (n = 0): <none>
[13:20:45.626] {
[13:20:45.626]     {
[13:20:45.626]         {
[13:20:45.626]             ...future.startTime <- base::Sys.time()
[13:20:45.626]             {
[13:20:45.626]                 {
[13:20:45.626]                   {
[13:20:45.626]                     {
[13:20:45.626]                       base::local({
[13:20:45.626]                         has_future <- base::requireNamespace("future", 
[13:20:45.626]                           quietly = TRUE)
[13:20:45.626]                         if (has_future) {
[13:20:45.626]                           ns <- base::getNamespace("future")
[13:20:45.626]                           version <- ns[[".package"]][["version"]]
[13:20:45.626]                           if (is.null(version)) 
[13:20:45.626]                             version <- utils::packageVersion("future")
[13:20:45.626]                         }
[13:20:45.626]                         else {
[13:20:45.626]                           version <- NULL
[13:20:45.626]                         }
[13:20:45.626]                         if (!has_future || version < "1.8.0") {
[13:20:45.626]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.626]                             "", base::R.version$version.string), 
[13:20:45.626]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.626]                               "release", "version")], collapse = " "), 
[13:20:45.626]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.626]                             info)
[13:20:45.626]                           info <- base::paste(info, collapse = "; ")
[13:20:45.626]                           if (!has_future) {
[13:20:45.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.626]                               info)
[13:20:45.626]                           }
[13:20:45.626]                           else {
[13:20:45.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.626]                               info, version)
[13:20:45.626]                           }
[13:20:45.626]                           base::stop(msg)
[13:20:45.626]                         }
[13:20:45.626]                       })
[13:20:45.626]                     }
[13:20:45.626]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.626]                     base::options(mc.cores = 1L)
[13:20:45.626]                   }
[13:20:45.626]                   options(future.plan = NULL)
[13:20:45.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.626]                 }
[13:20:45.626]                 ...future.workdir <- getwd()
[13:20:45.626]             }
[13:20:45.626]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.626]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.626]         }
[13:20:45.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.626]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.626]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.626]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.626]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.626]             base::names(...future.oldOptions))
[13:20:45.626]     }
[13:20:45.626]     if (FALSE) {
[13:20:45.626]     }
[13:20:45.626]     else {
[13:20:45.626]         if (TRUE) {
[13:20:45.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.626]                 open = "w")
[13:20:45.626]         }
[13:20:45.626]         else {
[13:20:45.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.626]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.626]         }
[13:20:45.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.626]             base::sink(type = "output", split = FALSE)
[13:20:45.626]             base::close(...future.stdout)
[13:20:45.626]         }, add = TRUE)
[13:20:45.626]     }
[13:20:45.626]     ...future.frame <- base::sys.nframe()
[13:20:45.626]     ...future.conditions <- base::list()
[13:20:45.626]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.626]     if (FALSE) {
[13:20:45.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.626]     }
[13:20:45.626]     ...future.result <- base::tryCatch({
[13:20:45.626]         base::withCallingHandlers({
[13:20:45.626]             ...future.value <- base::withVisible(base::local({
[13:20:45.626]                 withCallingHandlers({
[13:20:45.626]                   {
[13:20:45.626]                     x["a"] <- list(1)
[13:20:45.626]                     x
[13:20:45.626]                   }
[13:20:45.626]                 }, immediateCondition = function(cond) {
[13:20:45.626]                   save_rds <- function (object, pathname, ...) 
[13:20:45.626]                   {
[13:20:45.626]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.626]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.626]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.626]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.626]                         fi_tmp[["mtime"]])
[13:20:45.626]                     }
[13:20:45.626]                     tryCatch({
[13:20:45.626]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.626]                     }, error = function(ex) {
[13:20:45.626]                       msg <- conditionMessage(ex)
[13:20:45.626]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.626]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.626]                         fi_tmp[["mtime"]], msg)
[13:20:45.626]                       ex$message <- msg
[13:20:45.626]                       stop(ex)
[13:20:45.626]                     })
[13:20:45.626]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.626]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.626]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.626]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.626]                       fi <- file.info(pathname)
[13:20:45.626]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.626]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.626]                         fi[["size"]], fi[["mtime"]])
[13:20:45.626]                       stop(msg)
[13:20:45.626]                     }
[13:20:45.626]                     invisible(pathname)
[13:20:45.626]                   }
[13:20:45.626]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.626]                     rootPath = tempdir()) 
[13:20:45.626]                   {
[13:20:45.626]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.626]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.626]                       tmpdir = path, fileext = ".rds")
[13:20:45.626]                     save_rds(obj, file)
[13:20:45.626]                   }
[13:20:45.626]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.626]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.626]                   {
[13:20:45.626]                     inherits <- base::inherits
[13:20:45.626]                     invokeRestart <- base::invokeRestart
[13:20:45.626]                     is.null <- base::is.null
[13:20:45.626]                     muffled <- FALSE
[13:20:45.626]                     if (inherits(cond, "message")) {
[13:20:45.626]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.626]                       if (muffled) 
[13:20:45.626]                         invokeRestart("muffleMessage")
[13:20:45.626]                     }
[13:20:45.626]                     else if (inherits(cond, "warning")) {
[13:20:45.626]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.626]                       if (muffled) 
[13:20:45.626]                         invokeRestart("muffleWarning")
[13:20:45.626]                     }
[13:20:45.626]                     else if (inherits(cond, "condition")) {
[13:20:45.626]                       if (!is.null(pattern)) {
[13:20:45.626]                         computeRestarts <- base::computeRestarts
[13:20:45.626]                         grepl <- base::grepl
[13:20:45.626]                         restarts <- computeRestarts(cond)
[13:20:45.626]                         for (restart in restarts) {
[13:20:45.626]                           name <- restart$name
[13:20:45.626]                           if (is.null(name)) 
[13:20:45.626]                             next
[13:20:45.626]                           if (!grepl(pattern, name)) 
[13:20:45.626]                             next
[13:20:45.626]                           invokeRestart(restart)
[13:20:45.626]                           muffled <- TRUE
[13:20:45.626]                           break
[13:20:45.626]                         }
[13:20:45.626]                       }
[13:20:45.626]                     }
[13:20:45.626]                     invisible(muffled)
[13:20:45.626]                   }
[13:20:45.626]                   muffleCondition(cond)
[13:20:45.626]                 })
[13:20:45.626]             }))
[13:20:45.626]             future::FutureResult(value = ...future.value$value, 
[13:20:45.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.626]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.626]                     ...future.globalenv.names))
[13:20:45.626]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.626]         }, condition = base::local({
[13:20:45.626]             c <- base::c
[13:20:45.626]             inherits <- base::inherits
[13:20:45.626]             invokeRestart <- base::invokeRestart
[13:20:45.626]             length <- base::length
[13:20:45.626]             list <- base::list
[13:20:45.626]             seq.int <- base::seq.int
[13:20:45.626]             signalCondition <- base::signalCondition
[13:20:45.626]             sys.calls <- base::sys.calls
[13:20:45.626]             `[[` <- base::`[[`
[13:20:45.626]             `+` <- base::`+`
[13:20:45.626]             `<<-` <- base::`<<-`
[13:20:45.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.626]                   3L)]
[13:20:45.626]             }
[13:20:45.626]             function(cond) {
[13:20:45.626]                 is_error <- inherits(cond, "error")
[13:20:45.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.626]                   NULL)
[13:20:45.626]                 if (is_error) {
[13:20:45.626]                   sessionInformation <- function() {
[13:20:45.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.626]                       search = base::search(), system = base::Sys.info())
[13:20:45.626]                   }
[13:20:45.626]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.626]                     cond$call), session = sessionInformation(), 
[13:20:45.626]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.626]                   signalCondition(cond)
[13:20:45.626]                 }
[13:20:45.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.626]                 "immediateCondition"))) {
[13:20:45.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.626]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.626]                   if (TRUE && !signal) {
[13:20:45.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.626]                     {
[13:20:45.626]                       inherits <- base::inherits
[13:20:45.626]                       invokeRestart <- base::invokeRestart
[13:20:45.626]                       is.null <- base::is.null
[13:20:45.626]                       muffled <- FALSE
[13:20:45.626]                       if (inherits(cond, "message")) {
[13:20:45.626]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.626]                         if (muffled) 
[13:20:45.626]                           invokeRestart("muffleMessage")
[13:20:45.626]                       }
[13:20:45.626]                       else if (inherits(cond, "warning")) {
[13:20:45.626]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.626]                         if (muffled) 
[13:20:45.626]                           invokeRestart("muffleWarning")
[13:20:45.626]                       }
[13:20:45.626]                       else if (inherits(cond, "condition")) {
[13:20:45.626]                         if (!is.null(pattern)) {
[13:20:45.626]                           computeRestarts <- base::computeRestarts
[13:20:45.626]                           grepl <- base::grepl
[13:20:45.626]                           restarts <- computeRestarts(cond)
[13:20:45.626]                           for (restart in restarts) {
[13:20:45.626]                             name <- restart$name
[13:20:45.626]                             if (is.null(name)) 
[13:20:45.626]                               next
[13:20:45.626]                             if (!grepl(pattern, name)) 
[13:20:45.626]                               next
[13:20:45.626]                             invokeRestart(restart)
[13:20:45.626]                             muffled <- TRUE
[13:20:45.626]                             break
[13:20:45.626]                           }
[13:20:45.626]                         }
[13:20:45.626]                       }
[13:20:45.626]                       invisible(muffled)
[13:20:45.626]                     }
[13:20:45.626]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.626]                   }
[13:20:45.626]                 }
[13:20:45.626]                 else {
[13:20:45.626]                   if (TRUE) {
[13:20:45.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.626]                     {
[13:20:45.626]                       inherits <- base::inherits
[13:20:45.626]                       invokeRestart <- base::invokeRestart
[13:20:45.626]                       is.null <- base::is.null
[13:20:45.626]                       muffled <- FALSE
[13:20:45.626]                       if (inherits(cond, "message")) {
[13:20:45.626]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.626]                         if (muffled) 
[13:20:45.626]                           invokeRestart("muffleMessage")
[13:20:45.626]                       }
[13:20:45.626]                       else if (inherits(cond, "warning")) {
[13:20:45.626]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.626]                         if (muffled) 
[13:20:45.626]                           invokeRestart("muffleWarning")
[13:20:45.626]                       }
[13:20:45.626]                       else if (inherits(cond, "condition")) {
[13:20:45.626]                         if (!is.null(pattern)) {
[13:20:45.626]                           computeRestarts <- base::computeRestarts
[13:20:45.626]                           grepl <- base::grepl
[13:20:45.626]                           restarts <- computeRestarts(cond)
[13:20:45.626]                           for (restart in restarts) {
[13:20:45.626]                             name <- restart$name
[13:20:45.626]                             if (is.null(name)) 
[13:20:45.626]                               next
[13:20:45.626]                             if (!grepl(pattern, name)) 
[13:20:45.626]                               next
[13:20:45.626]                             invokeRestart(restart)
[13:20:45.626]                             muffled <- TRUE
[13:20:45.626]                             break
[13:20:45.626]                           }
[13:20:45.626]                         }
[13:20:45.626]                       }
[13:20:45.626]                       invisible(muffled)
[13:20:45.626]                     }
[13:20:45.626]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.626]                   }
[13:20:45.626]                 }
[13:20:45.626]             }
[13:20:45.626]         }))
[13:20:45.626]     }, error = function(ex) {
[13:20:45.626]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.626]                 ...future.rng), started = ...future.startTime, 
[13:20:45.626]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.626]             version = "1.8"), class = "FutureResult")
[13:20:45.626]     }, finally = {
[13:20:45.626]         if (!identical(...future.workdir, getwd())) 
[13:20:45.626]             setwd(...future.workdir)
[13:20:45.626]         {
[13:20:45.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.626]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.626]             }
[13:20:45.626]             base::options(...future.oldOptions)
[13:20:45.626]             if (.Platform$OS.type == "windows") {
[13:20:45.626]                 old_names <- names(...future.oldEnvVars)
[13:20:45.626]                 envs <- base::Sys.getenv()
[13:20:45.626]                 names <- names(envs)
[13:20:45.626]                 common <- intersect(names, old_names)
[13:20:45.626]                 added <- setdiff(names, old_names)
[13:20:45.626]                 removed <- setdiff(old_names, names)
[13:20:45.626]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.626]                   envs[common]]
[13:20:45.626]                 NAMES <- toupper(changed)
[13:20:45.626]                 args <- list()
[13:20:45.626]                 for (kk in seq_along(NAMES)) {
[13:20:45.626]                   name <- changed[[kk]]
[13:20:45.626]                   NAME <- NAMES[[kk]]
[13:20:45.626]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.626]                     next
[13:20:45.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.626]                 }
[13:20:45.626]                 NAMES <- toupper(added)
[13:20:45.626]                 for (kk in seq_along(NAMES)) {
[13:20:45.626]                   name <- added[[kk]]
[13:20:45.626]                   NAME <- NAMES[[kk]]
[13:20:45.626]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.626]                     next
[13:20:45.626]                   args[[name]] <- ""
[13:20:45.626]                 }
[13:20:45.626]                 NAMES <- toupper(removed)
[13:20:45.626]                 for (kk in seq_along(NAMES)) {
[13:20:45.626]                   name <- removed[[kk]]
[13:20:45.626]                   NAME <- NAMES[[kk]]
[13:20:45.626]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.626]                     next
[13:20:45.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.626]                 }
[13:20:45.626]                 if (length(args) > 0) 
[13:20:45.626]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.626]             }
[13:20:45.626]             else {
[13:20:45.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.626]             }
[13:20:45.626]             {
[13:20:45.626]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.626]                   0L) {
[13:20:45.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.626]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.626]                   base::options(opts)
[13:20:45.626]                 }
[13:20:45.626]                 {
[13:20:45.626]                   {
[13:20:45.626]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.626]                     NULL
[13:20:45.626]                   }
[13:20:45.626]                   options(future.plan = NULL)
[13:20:45.626]                   if (is.na(NA_character_)) 
[13:20:45.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.626]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.626]                     envir = parent.frame()) 
[13:20:45.626]                   {
[13:20:45.626]                     default_workers <- missing(workers)
[13:20:45.626]                     if (is.function(workers)) 
[13:20:45.626]                       workers <- workers()
[13:20:45.626]                     workers <- structure(as.integer(workers), 
[13:20:45.626]                       class = class(workers))
[13:20:45.626]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.626]                       1L)
[13:20:45.626]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.626]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.626]                       if (default_workers) 
[13:20:45.626]                         supportsMulticore(warn = TRUE)
[13:20:45.626]                       return(sequential(..., envir = envir))
[13:20:45.626]                     }
[13:20:45.626]                     oopts <- options(mc.cores = workers)
[13:20:45.626]                     on.exit(options(oopts))
[13:20:45.626]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.626]                       envir = envir)
[13:20:45.626]                     if (!future$lazy) 
[13:20:45.626]                       future <- run(future)
[13:20:45.626]                     invisible(future)
[13:20:45.626]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.626]                 }
[13:20:45.626]             }
[13:20:45.626]         }
[13:20:45.626]     })
[13:20:45.626]     if (TRUE) {
[13:20:45.626]         base::sink(type = "output", split = FALSE)
[13:20:45.626]         if (TRUE) {
[13:20:45.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.626]         }
[13:20:45.626]         else {
[13:20:45.626]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.626]         }
[13:20:45.626]         base::close(...future.stdout)
[13:20:45.626]         ...future.stdout <- NULL
[13:20:45.626]     }
[13:20:45.626]     ...future.result$conditions <- ...future.conditions
[13:20:45.626]     ...future.result$finished <- base::Sys.time()
[13:20:45.626]     ...future.result
[13:20:45.626] }
[13:20:45.629] assign_globals() ...
[13:20:45.629] List of 1
[13:20:45.629]  $ x: list()
[13:20:45.629]  - attr(*, "where")=List of 1
[13:20:45.629]   ..$ x:<environment: R_EmptyEnv> 
[13:20:45.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.629]  - attr(*, "resolved")= logi TRUE
[13:20:45.629]  - attr(*, "total_size")= num 0
[13:20:45.629]  - attr(*, "already-done")= logi TRUE
[13:20:45.632] - copied ‘x’ to environment
[13:20:45.632] assign_globals() ... done
[13:20:45.632] requestCore(): workers = 2
[13:20:45.635] MulticoreFuture started
[13:20:45.635] - Launch lazy future ... done
[13:20:45.635] run() for ‘MulticoreFuture’ ... done
[13:20:45.636] plan(): Setting new future strategy stack:
[13:20:45.636] List of future strategies:
[13:20:45.636] 1. sequential:
[13:20:45.636]    - args: function (..., envir = parent.frame())
[13:20:45.636]    - tweaked: FALSE
[13:20:45.636]    - call: NULL
[13:20:45.637] plan(): nbrOfWorkers() = 1
[13:20:45.639] plan(): Setting new future strategy stack:
[13:20:45.639] List of future strategies:
[13:20:45.639] 1. multicore:
[13:20:45.639]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.639]    - tweaked: FALSE
[13:20:45.639]    - call: plan(strategy)
[13:20:45.644] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.646] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.646] Searching for globals...
[13:20:45.649] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:20:45.649] Searching for globals ... DONE
[13:20:45.650] Resolving globals: TRUE
[13:20:45.650] Resolving any globals that are futures ...
[13:20:45.650] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:20:45.650] Resolving any globals that are futures ... DONE
[13:20:45.651] Resolving futures part of globals (recursively) ...
[13:20:45.651] resolve() on list ...
[13:20:45.651]  recursive: 99
[13:20:45.651]  length: 2
[13:20:45.651]  elements: ‘x’, ‘name’
[13:20:45.651]  length: 1 (resolved future 1)
[13:20:45.652]  length: 0 (resolved future 2)
[13:20:45.652] resolve() on list ... DONE
[13:20:45.652] - globals: [2] ‘x’, ‘name’
[13:20:45.652] Resolving futures part of globals (recursively) ... DONE
[13:20:45.652] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:45.653] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[13:20:45.653] - globals: [2] ‘x’, ‘name’
[13:20:45.653] 
[13:20:45.653] getGlobalsAndPackages() ... DONE
[13:20:45.653] run() for ‘Future’ ...
[13:20:45.654] - state: ‘created’
[13:20:45.654] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:45.658] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:45.658] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:45.658]   - Field: ‘label’
[13:20:45.658]   - Field: ‘local’
[13:20:45.658]   - Field: ‘owner’
[13:20:45.658]   - Field: ‘envir’
[13:20:45.659]   - Field: ‘workers’
[13:20:45.659]   - Field: ‘packages’
[13:20:45.659]   - Field: ‘gc’
[13:20:45.659]   - Field: ‘job’
[13:20:45.659]   - Field: ‘conditions’
[13:20:45.659]   - Field: ‘expr’
[13:20:45.659]   - Field: ‘uuid’
[13:20:45.659]   - Field: ‘seed’
[13:20:45.660]   - Field: ‘version’
[13:20:45.660]   - Field: ‘result’
[13:20:45.660]   - Field: ‘asynchronous’
[13:20:45.660]   - Field: ‘calls’
[13:20:45.660]   - Field: ‘globals’
[13:20:45.660]   - Field: ‘stdout’
[13:20:45.660]   - Field: ‘earlySignal’
[13:20:45.660]   - Field: ‘lazy’
[13:20:45.660]   - Field: ‘state’
[13:20:45.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:45.661] - Launch lazy future ...
[13:20:45.661] Packages needed by the future expression (n = 0): <none>
[13:20:45.661] Packages needed by future strategies (n = 0): <none>
[13:20:45.662] {
[13:20:45.662]     {
[13:20:45.662]         {
[13:20:45.662]             ...future.startTime <- base::Sys.time()
[13:20:45.662]             {
[13:20:45.662]                 {
[13:20:45.662]                   {
[13:20:45.662]                     {
[13:20:45.662]                       base::local({
[13:20:45.662]                         has_future <- base::requireNamespace("future", 
[13:20:45.662]                           quietly = TRUE)
[13:20:45.662]                         if (has_future) {
[13:20:45.662]                           ns <- base::getNamespace("future")
[13:20:45.662]                           version <- ns[[".package"]][["version"]]
[13:20:45.662]                           if (is.null(version)) 
[13:20:45.662]                             version <- utils::packageVersion("future")
[13:20:45.662]                         }
[13:20:45.662]                         else {
[13:20:45.662]                           version <- NULL
[13:20:45.662]                         }
[13:20:45.662]                         if (!has_future || version < "1.8.0") {
[13:20:45.662]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:45.662]                             "", base::R.version$version.string), 
[13:20:45.662]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:45.662]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:45.662]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:45.662]                               "release", "version")], collapse = " "), 
[13:20:45.662]                             hostname = base::Sys.info()[["nodename"]])
[13:20:45.662]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:45.662]                             info)
[13:20:45.662]                           info <- base::paste(info, collapse = "; ")
[13:20:45.662]                           if (!has_future) {
[13:20:45.662]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:45.662]                               info)
[13:20:45.662]                           }
[13:20:45.662]                           else {
[13:20:45.662]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:45.662]                               info, version)
[13:20:45.662]                           }
[13:20:45.662]                           base::stop(msg)
[13:20:45.662]                         }
[13:20:45.662]                       })
[13:20:45.662]                     }
[13:20:45.662]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:45.662]                     base::options(mc.cores = 1L)
[13:20:45.662]                   }
[13:20:45.662]                   options(future.plan = NULL)
[13:20:45.662]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.662]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:45.662]                 }
[13:20:45.662]                 ...future.workdir <- getwd()
[13:20:45.662]             }
[13:20:45.662]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:45.662]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:45.662]         }
[13:20:45.662]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:45.662]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:45.662]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:45.662]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:45.662]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:45.662]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:45.662]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:45.662]             base::names(...future.oldOptions))
[13:20:45.662]     }
[13:20:45.662]     if (FALSE) {
[13:20:45.662]     }
[13:20:45.662]     else {
[13:20:45.662]         if (TRUE) {
[13:20:45.662]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:45.662]                 open = "w")
[13:20:45.662]         }
[13:20:45.662]         else {
[13:20:45.662]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:45.662]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:45.662]         }
[13:20:45.662]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:45.662]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:45.662]             base::sink(type = "output", split = FALSE)
[13:20:45.662]             base::close(...future.stdout)
[13:20:45.662]         }, add = TRUE)
[13:20:45.662]     }
[13:20:45.662]     ...future.frame <- base::sys.nframe()
[13:20:45.662]     ...future.conditions <- base::list()
[13:20:45.662]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:45.662]     if (FALSE) {
[13:20:45.662]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:45.662]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:45.662]     }
[13:20:45.662]     ...future.result <- base::tryCatch({
[13:20:45.662]         base::withCallingHandlers({
[13:20:45.662]             ...future.value <- base::withVisible(base::local({
[13:20:45.662]                 withCallingHandlers({
[13:20:45.662]                   {
[13:20:45.662]                     x[name] <- list(1)
[13:20:45.662]                     x
[13:20:45.662]                   }
[13:20:45.662]                 }, immediateCondition = function(cond) {
[13:20:45.662]                   save_rds <- function (object, pathname, ...) 
[13:20:45.662]                   {
[13:20:45.662]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:45.662]                     if (file_test("-f", pathname_tmp)) {
[13:20:45.662]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.662]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:45.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.662]                         fi_tmp[["mtime"]])
[13:20:45.662]                     }
[13:20:45.662]                     tryCatch({
[13:20:45.662]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:45.662]                     }, error = function(ex) {
[13:20:45.662]                       msg <- conditionMessage(ex)
[13:20:45.662]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.662]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:45.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.662]                         fi_tmp[["mtime"]], msg)
[13:20:45.662]                       ex$message <- msg
[13:20:45.662]                       stop(ex)
[13:20:45.662]                     })
[13:20:45.662]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:45.662]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:45.662]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:45.662]                       fi_tmp <- file.info(pathname_tmp)
[13:20:45.662]                       fi <- file.info(pathname)
[13:20:45.662]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:45.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:45.662]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:45.662]                         fi[["size"]], fi[["mtime"]])
[13:20:45.662]                       stop(msg)
[13:20:45.662]                     }
[13:20:45.662]                     invisible(pathname)
[13:20:45.662]                   }
[13:20:45.662]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:45.662]                     rootPath = tempdir()) 
[13:20:45.662]                   {
[13:20:45.662]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:45.662]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:45.662]                       tmpdir = path, fileext = ".rds")
[13:20:45.662]                     save_rds(obj, file)
[13:20:45.662]                   }
[13:20:45.662]                   saveImmediateCondition(cond, path = "/tmp/RtmpXJPnuZ/.future/immediateConditions")
[13:20:45.662]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.662]                   {
[13:20:45.662]                     inherits <- base::inherits
[13:20:45.662]                     invokeRestart <- base::invokeRestart
[13:20:45.662]                     is.null <- base::is.null
[13:20:45.662]                     muffled <- FALSE
[13:20:45.662]                     if (inherits(cond, "message")) {
[13:20:45.662]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:45.662]                       if (muffled) 
[13:20:45.662]                         invokeRestart("muffleMessage")
[13:20:45.662]                     }
[13:20:45.662]                     else if (inherits(cond, "warning")) {
[13:20:45.662]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:45.662]                       if (muffled) 
[13:20:45.662]                         invokeRestart("muffleWarning")
[13:20:45.662]                     }
[13:20:45.662]                     else if (inherits(cond, "condition")) {
[13:20:45.662]                       if (!is.null(pattern)) {
[13:20:45.662]                         computeRestarts <- base::computeRestarts
[13:20:45.662]                         grepl <- base::grepl
[13:20:45.662]                         restarts <- computeRestarts(cond)
[13:20:45.662]                         for (restart in restarts) {
[13:20:45.662]                           name <- restart$name
[13:20:45.662]                           if (is.null(name)) 
[13:20:45.662]                             next
[13:20:45.662]                           if (!grepl(pattern, name)) 
[13:20:45.662]                             next
[13:20:45.662]                           invokeRestart(restart)
[13:20:45.662]                           muffled <- TRUE
[13:20:45.662]                           break
[13:20:45.662]                         }
[13:20:45.662]                       }
[13:20:45.662]                     }
[13:20:45.662]                     invisible(muffled)
[13:20:45.662]                   }
[13:20:45.662]                   muffleCondition(cond)
[13:20:45.662]                 })
[13:20:45.662]             }))
[13:20:45.662]             future::FutureResult(value = ...future.value$value, 
[13:20:45.662]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.662]                   ...future.rng), globalenv = if (FALSE) 
[13:20:45.662]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:45.662]                     ...future.globalenv.names))
[13:20:45.662]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:45.662]         }, condition = base::local({
[13:20:45.662]             c <- base::c
[13:20:45.662]             inherits <- base::inherits
[13:20:45.662]             invokeRestart <- base::invokeRestart
[13:20:45.662]             length <- base::length
[13:20:45.662]             list <- base::list
[13:20:45.662]             seq.int <- base::seq.int
[13:20:45.662]             signalCondition <- base::signalCondition
[13:20:45.662]             sys.calls <- base::sys.calls
[13:20:45.662]             `[[` <- base::`[[`
[13:20:45.662]             `+` <- base::`+`
[13:20:45.662]             `<<-` <- base::`<<-`
[13:20:45.662]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:45.662]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:45.662]                   3L)]
[13:20:45.662]             }
[13:20:45.662]             function(cond) {
[13:20:45.662]                 is_error <- inherits(cond, "error")
[13:20:45.662]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:45.662]                   NULL)
[13:20:45.662]                 if (is_error) {
[13:20:45.662]                   sessionInformation <- function() {
[13:20:45.662]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:45.662]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:45.662]                       search = base::search(), system = base::Sys.info())
[13:20:45.662]                   }
[13:20:45.662]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.662]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:45.662]                     cond$call), session = sessionInformation(), 
[13:20:45.662]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:45.662]                   signalCondition(cond)
[13:20:45.662]                 }
[13:20:45.662]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:45.662]                 "immediateCondition"))) {
[13:20:45.662]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:45.662]                   ...future.conditions[[length(...future.conditions) + 
[13:20:45.662]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:45.662]                   if (TRUE && !signal) {
[13:20:45.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.662]                     {
[13:20:45.662]                       inherits <- base::inherits
[13:20:45.662]                       invokeRestart <- base::invokeRestart
[13:20:45.662]                       is.null <- base::is.null
[13:20:45.662]                       muffled <- FALSE
[13:20:45.662]                       if (inherits(cond, "message")) {
[13:20:45.662]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.662]                         if (muffled) 
[13:20:45.662]                           invokeRestart("muffleMessage")
[13:20:45.662]                       }
[13:20:45.662]                       else if (inherits(cond, "warning")) {
[13:20:45.662]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.662]                         if (muffled) 
[13:20:45.662]                           invokeRestart("muffleWarning")
[13:20:45.662]                       }
[13:20:45.662]                       else if (inherits(cond, "condition")) {
[13:20:45.662]                         if (!is.null(pattern)) {
[13:20:45.662]                           computeRestarts <- base::computeRestarts
[13:20:45.662]                           grepl <- base::grepl
[13:20:45.662]                           restarts <- computeRestarts(cond)
[13:20:45.662]                           for (restart in restarts) {
[13:20:45.662]                             name <- restart$name
[13:20:45.662]                             if (is.null(name)) 
[13:20:45.662]                               next
[13:20:45.662]                             if (!grepl(pattern, name)) 
[13:20:45.662]                               next
[13:20:45.662]                             invokeRestart(restart)
[13:20:45.662]                             muffled <- TRUE
[13:20:45.662]                             break
[13:20:45.662]                           }
[13:20:45.662]                         }
[13:20:45.662]                       }
[13:20:45.662]                       invisible(muffled)
[13:20:45.662]                     }
[13:20:45.662]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.662]                   }
[13:20:45.662]                 }
[13:20:45.662]                 else {
[13:20:45.662]                   if (TRUE) {
[13:20:45.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:45.662]                     {
[13:20:45.662]                       inherits <- base::inherits
[13:20:45.662]                       invokeRestart <- base::invokeRestart
[13:20:45.662]                       is.null <- base::is.null
[13:20:45.662]                       muffled <- FALSE
[13:20:45.662]                       if (inherits(cond, "message")) {
[13:20:45.662]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:45.662]                         if (muffled) 
[13:20:45.662]                           invokeRestart("muffleMessage")
[13:20:45.662]                       }
[13:20:45.662]                       else if (inherits(cond, "warning")) {
[13:20:45.662]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:45.662]                         if (muffled) 
[13:20:45.662]                           invokeRestart("muffleWarning")
[13:20:45.662]                       }
[13:20:45.662]                       else if (inherits(cond, "condition")) {
[13:20:45.662]                         if (!is.null(pattern)) {
[13:20:45.662]                           computeRestarts <- base::computeRestarts
[13:20:45.662]                           grepl <- base::grepl
[13:20:45.662]                           restarts <- computeRestarts(cond)
[13:20:45.662]                           for (restart in restarts) {
[13:20:45.662]                             name <- restart$name
[13:20:45.662]                             if (is.null(name)) 
[13:20:45.662]                               next
[13:20:45.662]                             if (!grepl(pattern, name)) 
[13:20:45.662]                               next
[13:20:45.662]                             invokeRestart(restart)
[13:20:45.662]                             muffled <- TRUE
[13:20:45.662]                             break
[13:20:45.662]                           }
[13:20:45.662]                         }
[13:20:45.662]                       }
[13:20:45.662]                       invisible(muffled)
[13:20:45.662]                     }
[13:20:45.662]                     muffleCondition(cond, pattern = "^muffle")
[13:20:45.662]                   }
[13:20:45.662]                 }
[13:20:45.662]             }
[13:20:45.662]         }))
[13:20:45.662]     }, error = function(ex) {
[13:20:45.662]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:45.662]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:45.662]                 ...future.rng), started = ...future.startTime, 
[13:20:45.662]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:45.662]             version = "1.8"), class = "FutureResult")
[13:20:45.662]     }, finally = {
[13:20:45.662]         if (!identical(...future.workdir, getwd())) 
[13:20:45.662]             setwd(...future.workdir)
[13:20:45.662]         {
[13:20:45.662]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:45.662]                 ...future.oldOptions$nwarnings <- NULL
[13:20:45.662]             }
[13:20:45.662]             base::options(...future.oldOptions)
[13:20:45.662]             if (.Platform$OS.type == "windows") {
[13:20:45.662]                 old_names <- names(...future.oldEnvVars)
[13:20:45.662]                 envs <- base::Sys.getenv()
[13:20:45.662]                 names <- names(envs)
[13:20:45.662]                 common <- intersect(names, old_names)
[13:20:45.662]                 added <- setdiff(names, old_names)
[13:20:45.662]                 removed <- setdiff(old_names, names)
[13:20:45.662]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:45.662]                   envs[common]]
[13:20:45.662]                 NAMES <- toupper(changed)
[13:20:45.662]                 args <- list()
[13:20:45.662]                 for (kk in seq_along(NAMES)) {
[13:20:45.662]                   name <- changed[[kk]]
[13:20:45.662]                   NAME <- NAMES[[kk]]
[13:20:45.662]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.662]                     next
[13:20:45.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.662]                 }
[13:20:45.662]                 NAMES <- toupper(added)
[13:20:45.662]                 for (kk in seq_along(NAMES)) {
[13:20:45.662]                   name <- added[[kk]]
[13:20:45.662]                   NAME <- NAMES[[kk]]
[13:20:45.662]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.662]                     next
[13:20:45.662]                   args[[name]] <- ""
[13:20:45.662]                 }
[13:20:45.662]                 NAMES <- toupper(removed)
[13:20:45.662]                 for (kk in seq_along(NAMES)) {
[13:20:45.662]                   name <- removed[[kk]]
[13:20:45.662]                   NAME <- NAMES[[kk]]
[13:20:45.662]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:45.662]                     next
[13:20:45.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:45.662]                 }
[13:20:45.662]                 if (length(args) > 0) 
[13:20:45.662]                   base::do.call(base::Sys.setenv, args = args)
[13:20:45.662]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:45.662]             }
[13:20:45.662]             else {
[13:20:45.662]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:45.662]             }
[13:20:45.662]             {
[13:20:45.662]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:45.662]                   0L) {
[13:20:45.662]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:45.662]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:45.662]                   base::options(opts)
[13:20:45.662]                 }
[13:20:45.662]                 {
[13:20:45.662]                   {
[13:20:45.662]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:45.662]                     NULL
[13:20:45.662]                   }
[13:20:45.662]                   options(future.plan = NULL)
[13:20:45.662]                   if (is.na(NA_character_)) 
[13:20:45.662]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:45.662]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:45.662]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:45.662]                     envir = parent.frame()) 
[13:20:45.662]                   {
[13:20:45.662]                     default_workers <- missing(workers)
[13:20:45.662]                     if (is.function(workers)) 
[13:20:45.662]                       workers <- workers()
[13:20:45.662]                     workers <- structure(as.integer(workers), 
[13:20:45.662]                       class = class(workers))
[13:20:45.662]                     stop_if_not(is.finite(workers), workers >= 
[13:20:45.662]                       1L)
[13:20:45.662]                     if ((workers == 1L && !inherits(workers, 
[13:20:45.662]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:45.662]                       if (default_workers) 
[13:20:45.662]                         supportsMulticore(warn = TRUE)
[13:20:45.662]                       return(sequential(..., envir = envir))
[13:20:45.662]                     }
[13:20:45.662]                     oopts <- options(mc.cores = workers)
[13:20:45.662]                     on.exit(options(oopts))
[13:20:45.662]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:45.662]                       envir = envir)
[13:20:45.662]                     if (!future$lazy) 
[13:20:45.662]                       future <- run(future)
[13:20:45.662]                     invisible(future)
[13:20:45.662]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:45.662]                 }
[13:20:45.662]             }
[13:20:45.662]         }
[13:20:45.662]     })
[13:20:45.662]     if (TRUE) {
[13:20:45.662]         base::sink(type = "output", split = FALSE)
[13:20:45.662]         if (TRUE) {
[13:20:45.662]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:45.662]         }
[13:20:45.662]         else {
[13:20:45.662]             ...future.result["stdout"] <- base::list(NULL)
[13:20:45.662]         }
[13:20:45.662]         base::close(...future.stdout)
[13:20:45.662]         ...future.stdout <- NULL
[13:20:45.662]     }
[13:20:45.662]     ...future.result$conditions <- ...future.conditions
[13:20:45.662]     ...future.result$finished <- base::Sys.time()
[13:20:45.662]     ...future.result
[13:20:45.662] }
[13:20:45.664] assign_globals() ...
[13:20:45.665] List of 2
[13:20:45.665]  $ x   : list()
[13:20:45.665]  $ name: chr "a"
[13:20:45.665]  - attr(*, "where")=List of 2
[13:20:45.665]   ..$ x   :<environment: R_EmptyEnv> 
[13:20:45.665]   ..$ name:<environment: R_EmptyEnv> 
[13:20:45.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:45.665]  - attr(*, "resolved")= logi TRUE
[13:20:45.665]  - attr(*, "total_size")= num 112
[13:20:45.665]  - attr(*, "already-done")= logi TRUE
[13:20:45.668] - copied ‘x’ to environment
[13:20:45.668] - copied ‘name’ to environment
[13:20:45.668] assign_globals() ... done
[13:20:45.668] requestCore(): workers = 2
[13:20:45.671] MulticoreFuture started
[13:20:45.671] - Launch lazy future ... done
[13:20:45.671] run() for ‘MulticoreFuture’ ... done
[13:20:45.672] plan(): Setting new future strategy stack:
[13:20:45.672] List of future strategies:
[13:20:45.672] 1. sequential:
[13:20:45.672]    - args: function (..., envir = parent.frame())
[13:20:45.672]    - tweaked: FALSE
[13:20:45.672]    - call: NULL
[13:20:45.678] plan(): nbrOfWorkers() = 1
[13:20:45.680] plan(): Setting new future strategy stack:
[13:20:45.680] List of future strategies:
[13:20:45.680] 1. multicore:
[13:20:45.680]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:45.680]    - tweaked: FALSE
[13:20:45.680]    - call: plan(strategy)
[13:20:45.686] plan(): nbrOfWorkers() = 2
$a
[1] 1

- plan('multisession') ...
[13:20:45.692] plan(): Setting new future strategy stack:
[13:20:45.692] List of future strategies:
[13:20:45.692] 1. multisession:
[13:20:45.692]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:45.692]    - tweaked: FALSE
[13:20:45.692]    - call: plan(strategy)
[13:20:45.693] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:20:45.693] multisession:
[13:20:45.693] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:45.693] - tweaked: FALSE
[13:20:45.693] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:45.700] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:45.700] Not searching for globals
[13:20:45.701] - globals: [0] <none>
[13:20:45.701] getGlobalsAndPackages() ... DONE
[13:20:45.701] [local output] makeClusterPSOCK() ...
[13:20:45.743] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:20:45.748] [local output] Base port: 11992
[13:20:45.748] [local output] Getting setup options for 2 cluster nodes ...
[13:20:45.749] [local output]  - Node 1 of 2 ...
[13:20:45.749] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:45.750] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpXJPnuZ/worker.rank=1.parallelly.parent=86694.152a64fbeb170.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpXJPnuZ/worker.rank=1.parallelly.parent=86694.152a64fbeb170.pid")'’
[13:20:45.942] - Possible to infer worker's PID: TRUE
[13:20:45.942] [local output] Rscript port: 11992

[13:20:45.942] [local output]  - Node 2 of 2 ...
[13:20:45.943] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:45.943] [local output] Rscript port: 11992

[13:20:45.944] [local output] Getting setup options for 2 cluster nodes ... done
[13:20:45.944] [local output]  - Parallel setup requested for some PSOCK nodes
[13:20:45.944] [local output] Setting up PSOCK nodes in parallel
[13:20:45.945] List of 36
[13:20:45.945]  $ worker          : chr "localhost"
[13:20:45.945]   ..- attr(*, "localhost")= logi TRUE
[13:20:45.945]  $ master          : chr "localhost"
[13:20:45.945]  $ port            : int 11992
[13:20:45.945]  $ connectTimeout  : num 120
[13:20:45.945]  $ timeout         : num 2592000
[13:20:45.945]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:20:45.945]  $ homogeneous     : logi TRUE
[13:20:45.945]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:20:45.945]  $ rscript_envs    : NULL
[13:20:45.945]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:45.945]  $ rscript_startup : NULL
[13:20:45.945]  $ rscript_sh      : chr "sh"
[13:20:45.945]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:45.945]  $ methods         : logi TRUE
[13:20:45.945]  $ socketOptions   : chr "no-delay"
[13:20:45.945]  $ useXDR          : logi FALSE
[13:20:45.945]  $ outfile         : chr "/dev/null"
[13:20:45.945]  $ renice          : int NA
[13:20:45.945]  $ rshcmd          : NULL
[13:20:45.945]  $ user            : chr(0) 
[13:20:45.945]  $ revtunnel       : logi FALSE
[13:20:45.945]  $ rshlogfile      : NULL
[13:20:45.945]  $ rshopts         : chr(0) 
[13:20:45.945]  $ rank            : int 1
[13:20:45.945]  $ manual          : logi FALSE
[13:20:45.945]  $ dryrun          : logi FALSE
[13:20:45.945]  $ quiet           : logi FALSE
[13:20:45.945]  $ setup_strategy  : chr "parallel"
[13:20:45.945]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:45.945]  $ pidfile         : chr "/tmp/RtmpXJPnuZ/worker.rank=1.parallelly.parent=86694.152a64fbeb170.pid"
[13:20:45.945]  $ rshcmd_label    : NULL
[13:20:45.945]  $ rsh_call        : NULL
[13:20:45.945]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:45.945]  $ localMachine    : logi TRUE
[13:20:45.945]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:20:45.945]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:20:45.945]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:20:45.945]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:20:45.945]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:20:45.945]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:20:45.945]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:20:45.945]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:20:45.945]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:20:45.945]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:20:45.945]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:20:45.945]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:20:45.945]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:20:45.945]  $ arguments       :List of 28
[13:20:45.945]   ..$ worker          : chr "localhost"
[13:20:45.945]   ..$ master          : NULL
[13:20:45.945]   ..$ port            : int 11992
[13:20:45.945]   ..$ connectTimeout  : num 120
[13:20:45.945]   ..$ timeout         : num 2592000
[13:20:45.945]   ..$ rscript         : NULL
[13:20:45.945]   ..$ homogeneous     : NULL
[13:20:45.945]   ..$ rscript_args    : NULL
[13:20:45.945]   ..$ rscript_envs    : NULL
[13:20:45.945]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:45.945]   ..$ rscript_startup : NULL
[13:20:45.945]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:20:45.945]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:45.945]   ..$ methods         : logi TRUE
[13:20:45.945]   ..$ socketOptions   : chr "no-delay"
[13:20:45.945]   ..$ useXDR          : logi FALSE
[13:20:45.945]   ..$ outfile         : chr "/dev/null"
[13:20:45.945]   ..$ renice          : int NA
[13:20:45.945]   ..$ rshcmd          : NULL
[13:20:45.945]   ..$ user            : NULL
[13:20:45.945]   ..$ revtunnel       : logi NA
[13:20:45.945]   ..$ rshlogfile      : NULL
[13:20:45.945]   ..$ rshopts         : NULL
[13:20:45.945]   ..$ rank            : int 1
[13:20:45.945]   ..$ manual          : logi FALSE
[13:20:45.945]   ..$ dryrun          : logi FALSE
[13:20:45.945]   ..$ quiet           : logi FALSE
[13:20:45.945]   ..$ setup_strategy  : chr "parallel"
[13:20:45.945]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:20:45.961] [local output] System call to launch all workers:
[13:20:45.962] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpXJPnuZ/worker.rank=1.parallelly.parent=86694.152a64fbeb170.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11992 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:20:45.962] [local output] Starting PSOCK main server
[13:20:45.963] [local output] Workers launched
[13:20:45.963] [local output] Waiting for workers to connect back
[13:20:45.963]  - [local output] 0 workers out of 2 ready
[13:20:46.206]  - [local output] 0 workers out of 2 ready
[13:20:46.207]  - [local output] 1 workers out of 2 ready
[13:20:46.212]  - [local output] 1 workers out of 2 ready
[13:20:46.212]  - [local output] 2 workers out of 2 ready
[13:20:46.212] [local output] Launching of workers completed
[13:20:46.212] [local output] Collecting session information from workers
[13:20:46.213] [local output]  - Worker #1 of 2
[13:20:46.214] [local output]  - Worker #2 of 2
[13:20:46.214] [local output] makeClusterPSOCK() ... done
[13:20:46.226] Packages needed by the future expression (n = 0): <none>
[13:20:46.226] Packages needed by future strategies (n = 0): <none>
[13:20:46.227] {
[13:20:46.227]     {
[13:20:46.227]         {
[13:20:46.227]             ...future.startTime <- base::Sys.time()
[13:20:46.227]             {
[13:20:46.227]                 {
[13:20:46.227]                   {
[13:20:46.227]                     {
[13:20:46.227]                       base::local({
[13:20:46.227]                         has_future <- base::requireNamespace("future", 
[13:20:46.227]                           quietly = TRUE)
[13:20:46.227]                         if (has_future) {
[13:20:46.227]                           ns <- base::getNamespace("future")
[13:20:46.227]                           version <- ns[[".package"]][["version"]]
[13:20:46.227]                           if (is.null(version)) 
[13:20:46.227]                             version <- utils::packageVersion("future")
[13:20:46.227]                         }
[13:20:46.227]                         else {
[13:20:46.227]                           version <- NULL
[13:20:46.227]                         }
[13:20:46.227]                         if (!has_future || version < "1.8.0") {
[13:20:46.227]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:46.227]                             "", base::R.version$version.string), 
[13:20:46.227]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:46.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:46.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:46.227]                               "release", "version")], collapse = " "), 
[13:20:46.227]                             hostname = base::Sys.info()[["nodename"]])
[13:20:46.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:46.227]                             info)
[13:20:46.227]                           info <- base::paste(info, collapse = "; ")
[13:20:46.227]                           if (!has_future) {
[13:20:46.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:46.227]                               info)
[13:20:46.227]                           }
[13:20:46.227]                           else {
[13:20:46.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:46.227]                               info, version)
[13:20:46.227]                           }
[13:20:46.227]                           base::stop(msg)
[13:20:46.227]                         }
[13:20:46.227]                       })
[13:20:46.227]                     }
[13:20:46.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:46.227]                     base::options(mc.cores = 1L)
[13:20:46.227]                   }
[13:20:46.227]                   options(future.plan = NULL)
[13:20:46.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:46.227]                 }
[13:20:46.227]                 ...future.workdir <- getwd()
[13:20:46.227]             }
[13:20:46.227]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:46.227]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:46.227]         }
[13:20:46.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:46.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:46.227]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:46.227]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:46.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:46.227]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:46.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:46.227]             base::names(...future.oldOptions))
[13:20:46.227]     }
[13:20:46.227]     if (FALSE) {
[13:20:46.227]     }
[13:20:46.227]     else {
[13:20:46.227]         if (TRUE) {
[13:20:46.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:46.227]                 open = "w")
[13:20:46.227]         }
[13:20:46.227]         else {
[13:20:46.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:46.227]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:46.227]         }
[13:20:46.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:46.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:46.227]             base::sink(type = "output", split = FALSE)
[13:20:46.227]             base::close(...future.stdout)
[13:20:46.227]         }, add = TRUE)
[13:20:46.227]     }
[13:20:46.227]     ...future.frame <- base::sys.nframe()
[13:20:46.227]     ...future.conditions <- base::list()
[13:20:46.227]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:46.227]     if (FALSE) {
[13:20:46.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:46.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:46.227]     }
[13:20:46.227]     ...future.result <- base::tryCatch({
[13:20:46.227]         base::withCallingHandlers({
[13:20:46.227]             ...future.value <- base::withVisible(base::local({
[13:20:46.227]                 ...future.makeSendCondition <- local({
[13:20:46.227]                   sendCondition <- NULL
[13:20:46.227]                   function(frame = 1L) {
[13:20:46.227]                     if (is.function(sendCondition)) 
[13:20:46.227]                       return(sendCondition)
[13:20:46.227]                     ns <- getNamespace("parallel")
[13:20:46.227]                     if (exists("sendData", mode = "function", 
[13:20:46.227]                       envir = ns)) {
[13:20:46.227]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:46.227]                         envir = ns)
[13:20:46.227]                       envir <- sys.frame(frame)
[13:20:46.227]                       master <- NULL
[13:20:46.227]                       while (!identical(envir, .GlobalEnv) && 
[13:20:46.227]                         !identical(envir, emptyenv())) {
[13:20:46.227]                         if (exists("master", mode = "list", envir = envir, 
[13:20:46.227]                           inherits = FALSE)) {
[13:20:46.227]                           master <- get("master", mode = "list", 
[13:20:46.227]                             envir = envir, inherits = FALSE)
[13:20:46.227]                           if (inherits(master, c("SOCKnode", 
[13:20:46.227]                             "SOCK0node"))) {
[13:20:46.227]                             sendCondition <<- function(cond) {
[13:20:46.227]                               data <- list(type = "VALUE", value = cond, 
[13:20:46.227]                                 success = TRUE)
[13:20:46.227]                               parallel_sendData(master, data)
[13:20:46.227]                             }
[13:20:46.227]                             return(sendCondition)
[13:20:46.227]                           }
[13:20:46.227]                         }
[13:20:46.227]                         frame <- frame + 1L
[13:20:46.227]                         envir <- sys.frame(frame)
[13:20:46.227]                       }
[13:20:46.227]                     }
[13:20:46.227]                     sendCondition <<- function(cond) NULL
[13:20:46.227]                   }
[13:20:46.227]                 })
[13:20:46.227]                 withCallingHandlers({
[13:20:46.227]                   NA
[13:20:46.227]                 }, immediateCondition = function(cond) {
[13:20:46.227]                   sendCondition <- ...future.makeSendCondition()
[13:20:46.227]                   sendCondition(cond)
[13:20:46.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.227]                   {
[13:20:46.227]                     inherits <- base::inherits
[13:20:46.227]                     invokeRestart <- base::invokeRestart
[13:20:46.227]                     is.null <- base::is.null
[13:20:46.227]                     muffled <- FALSE
[13:20:46.227]                     if (inherits(cond, "message")) {
[13:20:46.227]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:46.227]                       if (muffled) 
[13:20:46.227]                         invokeRestart("muffleMessage")
[13:20:46.227]                     }
[13:20:46.227]                     else if (inherits(cond, "warning")) {
[13:20:46.227]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:46.227]                       if (muffled) 
[13:20:46.227]                         invokeRestart("muffleWarning")
[13:20:46.227]                     }
[13:20:46.227]                     else if (inherits(cond, "condition")) {
[13:20:46.227]                       if (!is.null(pattern)) {
[13:20:46.227]                         computeRestarts <- base::computeRestarts
[13:20:46.227]                         grepl <- base::grepl
[13:20:46.227]                         restarts <- computeRestarts(cond)
[13:20:46.227]                         for (restart in restarts) {
[13:20:46.227]                           name <- restart$name
[13:20:46.227]                           if (is.null(name)) 
[13:20:46.227]                             next
[13:20:46.227]                           if (!grepl(pattern, name)) 
[13:20:46.227]                             next
[13:20:46.227]                           invokeRestart(restart)
[13:20:46.227]                           muffled <- TRUE
[13:20:46.227]                           break
[13:20:46.227]                         }
[13:20:46.227]                       }
[13:20:46.227]                     }
[13:20:46.227]                     invisible(muffled)
[13:20:46.227]                   }
[13:20:46.227]                   muffleCondition(cond)
[13:20:46.227]                 })
[13:20:46.227]             }))
[13:20:46.227]             future::FutureResult(value = ...future.value$value, 
[13:20:46.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.227]                   ...future.rng), globalenv = if (FALSE) 
[13:20:46.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:46.227]                     ...future.globalenv.names))
[13:20:46.227]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:46.227]         }, condition = base::local({
[13:20:46.227]             c <- base::c
[13:20:46.227]             inherits <- base::inherits
[13:20:46.227]             invokeRestart <- base::invokeRestart
[13:20:46.227]             length <- base::length
[13:20:46.227]             list <- base::list
[13:20:46.227]             seq.int <- base::seq.int
[13:20:46.227]             signalCondition <- base::signalCondition
[13:20:46.227]             sys.calls <- base::sys.calls
[13:20:46.227]             `[[` <- base::`[[`
[13:20:46.227]             `+` <- base::`+`
[13:20:46.227]             `<<-` <- base::`<<-`
[13:20:46.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:46.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:46.227]                   3L)]
[13:20:46.227]             }
[13:20:46.227]             function(cond) {
[13:20:46.227]                 is_error <- inherits(cond, "error")
[13:20:46.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:46.227]                   NULL)
[13:20:46.227]                 if (is_error) {
[13:20:46.227]                   sessionInformation <- function() {
[13:20:46.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:46.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:46.227]                       search = base::search(), system = base::Sys.info())
[13:20:46.227]                   }
[13:20:46.227]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:46.227]                     cond$call), session = sessionInformation(), 
[13:20:46.227]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:46.227]                   signalCondition(cond)
[13:20:46.227]                 }
[13:20:46.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:46.227]                 "immediateCondition"))) {
[13:20:46.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:46.227]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:46.227]                   if (TRUE && !signal) {
[13:20:46.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.227]                     {
[13:20:46.227]                       inherits <- base::inherits
[13:20:46.227]                       invokeRestart <- base::invokeRestart
[13:20:46.227]                       is.null <- base::is.null
[13:20:46.227]                       muffled <- FALSE
[13:20:46.227]                       if (inherits(cond, "message")) {
[13:20:46.227]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.227]                         if (muffled) 
[13:20:46.227]                           invokeRestart("muffleMessage")
[13:20:46.227]                       }
[13:20:46.227]                       else if (inherits(cond, "warning")) {
[13:20:46.227]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.227]                         if (muffled) 
[13:20:46.227]                           invokeRestart("muffleWarning")
[13:20:46.227]                       }
[13:20:46.227]                       else if (inherits(cond, "condition")) {
[13:20:46.227]                         if (!is.null(pattern)) {
[13:20:46.227]                           computeRestarts <- base::computeRestarts
[13:20:46.227]                           grepl <- base::grepl
[13:20:46.227]                           restarts <- computeRestarts(cond)
[13:20:46.227]                           for (restart in restarts) {
[13:20:46.227]                             name <- restart$name
[13:20:46.227]                             if (is.null(name)) 
[13:20:46.227]                               next
[13:20:46.227]                             if (!grepl(pattern, name)) 
[13:20:46.227]                               next
[13:20:46.227]                             invokeRestart(restart)
[13:20:46.227]                             muffled <- TRUE
[13:20:46.227]                             break
[13:20:46.227]                           }
[13:20:46.227]                         }
[13:20:46.227]                       }
[13:20:46.227]                       invisible(muffled)
[13:20:46.227]                     }
[13:20:46.227]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.227]                   }
[13:20:46.227]                 }
[13:20:46.227]                 else {
[13:20:46.227]                   if (TRUE) {
[13:20:46.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.227]                     {
[13:20:46.227]                       inherits <- base::inherits
[13:20:46.227]                       invokeRestart <- base::invokeRestart
[13:20:46.227]                       is.null <- base::is.null
[13:20:46.227]                       muffled <- FALSE
[13:20:46.227]                       if (inherits(cond, "message")) {
[13:20:46.227]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.227]                         if (muffled) 
[13:20:46.227]                           invokeRestart("muffleMessage")
[13:20:46.227]                       }
[13:20:46.227]                       else if (inherits(cond, "warning")) {
[13:20:46.227]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.227]                         if (muffled) 
[13:20:46.227]                           invokeRestart("muffleWarning")
[13:20:46.227]                       }
[13:20:46.227]                       else if (inherits(cond, "condition")) {
[13:20:46.227]                         if (!is.null(pattern)) {
[13:20:46.227]                           computeRestarts <- base::computeRestarts
[13:20:46.227]                           grepl <- base::grepl
[13:20:46.227]                           restarts <- computeRestarts(cond)
[13:20:46.227]                           for (restart in restarts) {
[13:20:46.227]                             name <- restart$name
[13:20:46.227]                             if (is.null(name)) 
[13:20:46.227]                               next
[13:20:46.227]                             if (!grepl(pattern, name)) 
[13:20:46.227]                               next
[13:20:46.227]                             invokeRestart(restart)
[13:20:46.227]                             muffled <- TRUE
[13:20:46.227]                             break
[13:20:46.227]                           }
[13:20:46.227]                         }
[13:20:46.227]                       }
[13:20:46.227]                       invisible(muffled)
[13:20:46.227]                     }
[13:20:46.227]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.227]                   }
[13:20:46.227]                 }
[13:20:46.227]             }
[13:20:46.227]         }))
[13:20:46.227]     }, error = function(ex) {
[13:20:46.227]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:46.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.227]                 ...future.rng), started = ...future.startTime, 
[13:20:46.227]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:46.227]             version = "1.8"), class = "FutureResult")
[13:20:46.227]     }, finally = {
[13:20:46.227]         if (!identical(...future.workdir, getwd())) 
[13:20:46.227]             setwd(...future.workdir)
[13:20:46.227]         {
[13:20:46.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:46.227]                 ...future.oldOptions$nwarnings <- NULL
[13:20:46.227]             }
[13:20:46.227]             base::options(...future.oldOptions)
[13:20:46.227]             if (.Platform$OS.type == "windows") {
[13:20:46.227]                 old_names <- names(...future.oldEnvVars)
[13:20:46.227]                 envs <- base::Sys.getenv()
[13:20:46.227]                 names <- names(envs)
[13:20:46.227]                 common <- intersect(names, old_names)
[13:20:46.227]                 added <- setdiff(names, old_names)
[13:20:46.227]                 removed <- setdiff(old_names, names)
[13:20:46.227]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:46.227]                   envs[common]]
[13:20:46.227]                 NAMES <- toupper(changed)
[13:20:46.227]                 args <- list()
[13:20:46.227]                 for (kk in seq_along(NAMES)) {
[13:20:46.227]                   name <- changed[[kk]]
[13:20:46.227]                   NAME <- NAMES[[kk]]
[13:20:46.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.227]                     next
[13:20:46.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.227]                 }
[13:20:46.227]                 NAMES <- toupper(added)
[13:20:46.227]                 for (kk in seq_along(NAMES)) {
[13:20:46.227]                   name <- added[[kk]]
[13:20:46.227]                   NAME <- NAMES[[kk]]
[13:20:46.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.227]                     next
[13:20:46.227]                   args[[name]] <- ""
[13:20:46.227]                 }
[13:20:46.227]                 NAMES <- toupper(removed)
[13:20:46.227]                 for (kk in seq_along(NAMES)) {
[13:20:46.227]                   name <- removed[[kk]]
[13:20:46.227]                   NAME <- NAMES[[kk]]
[13:20:46.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.227]                     next
[13:20:46.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.227]                 }
[13:20:46.227]                 if (length(args) > 0) 
[13:20:46.227]                   base::do.call(base::Sys.setenv, args = args)
[13:20:46.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:46.227]             }
[13:20:46.227]             else {
[13:20:46.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:46.227]             }
[13:20:46.227]             {
[13:20:46.227]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:46.227]                   0L) {
[13:20:46.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:46.227]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:46.227]                   base::options(opts)
[13:20:46.227]                 }
[13:20:46.227]                 {
[13:20:46.227]                   {
[13:20:46.227]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:46.227]                     NULL
[13:20:46.227]                   }
[13:20:46.227]                   options(future.plan = NULL)
[13:20:46.227]                   if (is.na(NA_character_)) 
[13:20:46.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:46.227]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:46.227]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:46.227]                     envir = parent.frame()) 
[13:20:46.227]                   {
[13:20:46.227]                     if (is.function(workers)) 
[13:20:46.227]                       workers <- workers()
[13:20:46.227]                     workers <- structure(as.integer(workers), 
[13:20:46.227]                       class = class(workers))
[13:20:46.227]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:46.227]                       workers >= 1)
[13:20:46.227]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:46.227]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:46.227]                     }
[13:20:46.227]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:46.227]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:46.227]                       envir = envir)
[13:20:46.227]                     if (!future$lazy) 
[13:20:46.227]                       future <- run(future)
[13:20:46.227]                     invisible(future)
[13:20:46.227]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:46.227]                 }
[13:20:46.227]             }
[13:20:46.227]         }
[13:20:46.227]     })
[13:20:46.227]     if (TRUE) {
[13:20:46.227]         base::sink(type = "output", split = FALSE)
[13:20:46.227]         if (TRUE) {
[13:20:46.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:46.227]         }
[13:20:46.227]         else {
[13:20:46.227]             ...future.result["stdout"] <- base::list(NULL)
[13:20:46.227]         }
[13:20:46.227]         base::close(...future.stdout)
[13:20:46.227]         ...future.stdout <- NULL
[13:20:46.227]     }
[13:20:46.227]     ...future.result$conditions <- ...future.conditions
[13:20:46.227]     ...future.result$finished <- base::Sys.time()
[13:20:46.227]     ...future.result
[13:20:46.227] }
[13:20:46.298] MultisessionFuture started
[13:20:46.298] result() for ClusterFuture ...
[13:20:46.299] receiveMessageFromWorker() for ClusterFuture ...
[13:20:46.299] - Validating connection of MultisessionFuture
[13:20:46.330] - received message: FutureResult
[13:20:46.331] - Received FutureResult
[13:20:46.331] - Erased future from FutureRegistry
[13:20:46.331] result() for ClusterFuture ...
[13:20:46.331] - result already collected: FutureResult
[13:20:46.331] result() for ClusterFuture ... done
[13:20:46.331] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:46.331] result() for ClusterFuture ... done
[13:20:46.332] result() for ClusterFuture ...
[13:20:46.332] - result already collected: FutureResult
[13:20:46.332] result() for ClusterFuture ... done
[13:20:46.332] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:20:46.336] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:46.336] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:46.336] Searching for globals...
[13:20:46.339] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:46.339] Searching for globals ... DONE
[13:20:46.339] Resolving globals: TRUE
[13:20:46.339] Resolving any globals that are futures ...
[13:20:46.339] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:46.339] Resolving any globals that are futures ... DONE
[13:20:46.340] Resolving futures part of globals (recursively) ...
[13:20:46.340] resolve() on list ...
[13:20:46.340]  recursive: 99
[13:20:46.340]  length: 1
[13:20:46.340]  elements: ‘x’
[13:20:46.341]  length: 0 (resolved future 1)
[13:20:46.341] resolve() on list ... DONE
[13:20:46.341] - globals: [1] ‘x’
[13:20:46.341] Resolving futures part of globals (recursively) ... DONE
[13:20:46.341] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:46.342] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:46.342] - globals: [1] ‘x’
[13:20:46.342] 
[13:20:46.342] getGlobalsAndPackages() ... DONE
[13:20:46.342] run() for ‘Future’ ...
[13:20:46.342] - state: ‘created’
[13:20:46.343] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:46.358] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:46.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:46.358]   - Field: ‘node’
[13:20:46.358]   - Field: ‘label’
[13:20:46.358]   - Field: ‘local’
[13:20:46.358]   - Field: ‘owner’
[13:20:46.358]   - Field: ‘envir’
[13:20:46.358]   - Field: ‘workers’
[13:20:46.359]   - Field: ‘packages’
[13:20:46.359]   - Field: ‘gc’
[13:20:46.359]   - Field: ‘conditions’
[13:20:46.359]   - Field: ‘persistent’
[13:20:46.359]   - Field: ‘expr’
[13:20:46.359]   - Field: ‘uuid’
[13:20:46.359]   - Field: ‘seed’
[13:20:46.359]   - Field: ‘version’
[13:20:46.359]   - Field: ‘result’
[13:20:46.360]   - Field: ‘asynchronous’
[13:20:46.360]   - Field: ‘calls’
[13:20:46.360]   - Field: ‘globals’
[13:20:46.360]   - Field: ‘stdout’
[13:20:46.360]   - Field: ‘earlySignal’
[13:20:46.360]   - Field: ‘lazy’
[13:20:46.360]   - Field: ‘state’
[13:20:46.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:46.360] - Launch lazy future ...
[13:20:46.361] Packages needed by the future expression (n = 0): <none>
[13:20:46.361] Packages needed by future strategies (n = 0): <none>
[13:20:46.362] {
[13:20:46.362]     {
[13:20:46.362]         {
[13:20:46.362]             ...future.startTime <- base::Sys.time()
[13:20:46.362]             {
[13:20:46.362]                 {
[13:20:46.362]                   {
[13:20:46.362]                     {
[13:20:46.362]                       base::local({
[13:20:46.362]                         has_future <- base::requireNamespace("future", 
[13:20:46.362]                           quietly = TRUE)
[13:20:46.362]                         if (has_future) {
[13:20:46.362]                           ns <- base::getNamespace("future")
[13:20:46.362]                           version <- ns[[".package"]][["version"]]
[13:20:46.362]                           if (is.null(version)) 
[13:20:46.362]                             version <- utils::packageVersion("future")
[13:20:46.362]                         }
[13:20:46.362]                         else {
[13:20:46.362]                           version <- NULL
[13:20:46.362]                         }
[13:20:46.362]                         if (!has_future || version < "1.8.0") {
[13:20:46.362]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:46.362]                             "", base::R.version$version.string), 
[13:20:46.362]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:46.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:46.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:46.362]                               "release", "version")], collapse = " "), 
[13:20:46.362]                             hostname = base::Sys.info()[["nodename"]])
[13:20:46.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:46.362]                             info)
[13:20:46.362]                           info <- base::paste(info, collapse = "; ")
[13:20:46.362]                           if (!has_future) {
[13:20:46.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:46.362]                               info)
[13:20:46.362]                           }
[13:20:46.362]                           else {
[13:20:46.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:46.362]                               info, version)
[13:20:46.362]                           }
[13:20:46.362]                           base::stop(msg)
[13:20:46.362]                         }
[13:20:46.362]                       })
[13:20:46.362]                     }
[13:20:46.362]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:46.362]                     base::options(mc.cores = 1L)
[13:20:46.362]                   }
[13:20:46.362]                   options(future.plan = NULL)
[13:20:46.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:46.362]                 }
[13:20:46.362]                 ...future.workdir <- getwd()
[13:20:46.362]             }
[13:20:46.362]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:46.362]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:46.362]         }
[13:20:46.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:46.362]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:46.362]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:46.362]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:46.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:46.362]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:46.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:46.362]             base::names(...future.oldOptions))
[13:20:46.362]     }
[13:20:46.362]     if (FALSE) {
[13:20:46.362]     }
[13:20:46.362]     else {
[13:20:46.362]         if (TRUE) {
[13:20:46.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:46.362]                 open = "w")
[13:20:46.362]         }
[13:20:46.362]         else {
[13:20:46.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:46.362]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:46.362]         }
[13:20:46.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:46.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:46.362]             base::sink(type = "output", split = FALSE)
[13:20:46.362]             base::close(...future.stdout)
[13:20:46.362]         }, add = TRUE)
[13:20:46.362]     }
[13:20:46.362]     ...future.frame <- base::sys.nframe()
[13:20:46.362]     ...future.conditions <- base::list()
[13:20:46.362]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:46.362]     if (FALSE) {
[13:20:46.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:46.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:46.362]     }
[13:20:46.362]     ...future.result <- base::tryCatch({
[13:20:46.362]         base::withCallingHandlers({
[13:20:46.362]             ...future.value <- base::withVisible(base::local({
[13:20:46.362]                 ...future.makeSendCondition <- local({
[13:20:46.362]                   sendCondition <- NULL
[13:20:46.362]                   function(frame = 1L) {
[13:20:46.362]                     if (is.function(sendCondition)) 
[13:20:46.362]                       return(sendCondition)
[13:20:46.362]                     ns <- getNamespace("parallel")
[13:20:46.362]                     if (exists("sendData", mode = "function", 
[13:20:46.362]                       envir = ns)) {
[13:20:46.362]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:46.362]                         envir = ns)
[13:20:46.362]                       envir <- sys.frame(frame)
[13:20:46.362]                       master <- NULL
[13:20:46.362]                       while (!identical(envir, .GlobalEnv) && 
[13:20:46.362]                         !identical(envir, emptyenv())) {
[13:20:46.362]                         if (exists("master", mode = "list", envir = envir, 
[13:20:46.362]                           inherits = FALSE)) {
[13:20:46.362]                           master <- get("master", mode = "list", 
[13:20:46.362]                             envir = envir, inherits = FALSE)
[13:20:46.362]                           if (inherits(master, c("SOCKnode", 
[13:20:46.362]                             "SOCK0node"))) {
[13:20:46.362]                             sendCondition <<- function(cond) {
[13:20:46.362]                               data <- list(type = "VALUE", value = cond, 
[13:20:46.362]                                 success = TRUE)
[13:20:46.362]                               parallel_sendData(master, data)
[13:20:46.362]                             }
[13:20:46.362]                             return(sendCondition)
[13:20:46.362]                           }
[13:20:46.362]                         }
[13:20:46.362]                         frame <- frame + 1L
[13:20:46.362]                         envir <- sys.frame(frame)
[13:20:46.362]                       }
[13:20:46.362]                     }
[13:20:46.362]                     sendCondition <<- function(cond) NULL
[13:20:46.362]                   }
[13:20:46.362]                 })
[13:20:46.362]                 withCallingHandlers({
[13:20:46.362]                   {
[13:20:46.362]                     x$a <- 1
[13:20:46.362]                     x
[13:20:46.362]                   }
[13:20:46.362]                 }, immediateCondition = function(cond) {
[13:20:46.362]                   sendCondition <- ...future.makeSendCondition()
[13:20:46.362]                   sendCondition(cond)
[13:20:46.362]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.362]                   {
[13:20:46.362]                     inherits <- base::inherits
[13:20:46.362]                     invokeRestart <- base::invokeRestart
[13:20:46.362]                     is.null <- base::is.null
[13:20:46.362]                     muffled <- FALSE
[13:20:46.362]                     if (inherits(cond, "message")) {
[13:20:46.362]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:46.362]                       if (muffled) 
[13:20:46.362]                         invokeRestart("muffleMessage")
[13:20:46.362]                     }
[13:20:46.362]                     else if (inherits(cond, "warning")) {
[13:20:46.362]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:46.362]                       if (muffled) 
[13:20:46.362]                         invokeRestart("muffleWarning")
[13:20:46.362]                     }
[13:20:46.362]                     else if (inherits(cond, "condition")) {
[13:20:46.362]                       if (!is.null(pattern)) {
[13:20:46.362]                         computeRestarts <- base::computeRestarts
[13:20:46.362]                         grepl <- base::grepl
[13:20:46.362]                         restarts <- computeRestarts(cond)
[13:20:46.362]                         for (restart in restarts) {
[13:20:46.362]                           name <- restart$name
[13:20:46.362]                           if (is.null(name)) 
[13:20:46.362]                             next
[13:20:46.362]                           if (!grepl(pattern, name)) 
[13:20:46.362]                             next
[13:20:46.362]                           invokeRestart(restart)
[13:20:46.362]                           muffled <- TRUE
[13:20:46.362]                           break
[13:20:46.362]                         }
[13:20:46.362]                       }
[13:20:46.362]                     }
[13:20:46.362]                     invisible(muffled)
[13:20:46.362]                   }
[13:20:46.362]                   muffleCondition(cond)
[13:20:46.362]                 })
[13:20:46.362]             }))
[13:20:46.362]             future::FutureResult(value = ...future.value$value, 
[13:20:46.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.362]                   ...future.rng), globalenv = if (FALSE) 
[13:20:46.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:46.362]                     ...future.globalenv.names))
[13:20:46.362]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:46.362]         }, condition = base::local({
[13:20:46.362]             c <- base::c
[13:20:46.362]             inherits <- base::inherits
[13:20:46.362]             invokeRestart <- base::invokeRestart
[13:20:46.362]             length <- base::length
[13:20:46.362]             list <- base::list
[13:20:46.362]             seq.int <- base::seq.int
[13:20:46.362]             signalCondition <- base::signalCondition
[13:20:46.362]             sys.calls <- base::sys.calls
[13:20:46.362]             `[[` <- base::`[[`
[13:20:46.362]             `+` <- base::`+`
[13:20:46.362]             `<<-` <- base::`<<-`
[13:20:46.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:46.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:46.362]                   3L)]
[13:20:46.362]             }
[13:20:46.362]             function(cond) {
[13:20:46.362]                 is_error <- inherits(cond, "error")
[13:20:46.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:46.362]                   NULL)
[13:20:46.362]                 if (is_error) {
[13:20:46.362]                   sessionInformation <- function() {
[13:20:46.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:46.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:46.362]                       search = base::search(), system = base::Sys.info())
[13:20:46.362]                   }
[13:20:46.362]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:46.362]                     cond$call), session = sessionInformation(), 
[13:20:46.362]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:46.362]                   signalCondition(cond)
[13:20:46.362]                 }
[13:20:46.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:46.362]                 "immediateCondition"))) {
[13:20:46.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:46.362]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:46.362]                   if (TRUE && !signal) {
[13:20:46.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.362]                     {
[13:20:46.362]                       inherits <- base::inherits
[13:20:46.362]                       invokeRestart <- base::invokeRestart
[13:20:46.362]                       is.null <- base::is.null
[13:20:46.362]                       muffled <- FALSE
[13:20:46.362]                       if (inherits(cond, "message")) {
[13:20:46.362]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.362]                         if (muffled) 
[13:20:46.362]                           invokeRestart("muffleMessage")
[13:20:46.362]                       }
[13:20:46.362]                       else if (inherits(cond, "warning")) {
[13:20:46.362]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.362]                         if (muffled) 
[13:20:46.362]                           invokeRestart("muffleWarning")
[13:20:46.362]                       }
[13:20:46.362]                       else if (inherits(cond, "condition")) {
[13:20:46.362]                         if (!is.null(pattern)) {
[13:20:46.362]                           computeRestarts <- base::computeRestarts
[13:20:46.362]                           grepl <- base::grepl
[13:20:46.362]                           restarts <- computeRestarts(cond)
[13:20:46.362]                           for (restart in restarts) {
[13:20:46.362]                             name <- restart$name
[13:20:46.362]                             if (is.null(name)) 
[13:20:46.362]                               next
[13:20:46.362]                             if (!grepl(pattern, name)) 
[13:20:46.362]                               next
[13:20:46.362]                             invokeRestart(restart)
[13:20:46.362]                             muffled <- TRUE
[13:20:46.362]                             break
[13:20:46.362]                           }
[13:20:46.362]                         }
[13:20:46.362]                       }
[13:20:46.362]                       invisible(muffled)
[13:20:46.362]                     }
[13:20:46.362]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.362]                   }
[13:20:46.362]                 }
[13:20:46.362]                 else {
[13:20:46.362]                   if (TRUE) {
[13:20:46.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.362]                     {
[13:20:46.362]                       inherits <- base::inherits
[13:20:46.362]                       invokeRestart <- base::invokeRestart
[13:20:46.362]                       is.null <- base::is.null
[13:20:46.362]                       muffled <- FALSE
[13:20:46.362]                       if (inherits(cond, "message")) {
[13:20:46.362]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.362]                         if (muffled) 
[13:20:46.362]                           invokeRestart("muffleMessage")
[13:20:46.362]                       }
[13:20:46.362]                       else if (inherits(cond, "warning")) {
[13:20:46.362]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.362]                         if (muffled) 
[13:20:46.362]                           invokeRestart("muffleWarning")
[13:20:46.362]                       }
[13:20:46.362]                       else if (inherits(cond, "condition")) {
[13:20:46.362]                         if (!is.null(pattern)) {
[13:20:46.362]                           computeRestarts <- base::computeRestarts
[13:20:46.362]                           grepl <- base::grepl
[13:20:46.362]                           restarts <- computeRestarts(cond)
[13:20:46.362]                           for (restart in restarts) {
[13:20:46.362]                             name <- restart$name
[13:20:46.362]                             if (is.null(name)) 
[13:20:46.362]                               next
[13:20:46.362]                             if (!grepl(pattern, name)) 
[13:20:46.362]                               next
[13:20:46.362]                             invokeRestart(restart)
[13:20:46.362]                             muffled <- TRUE
[13:20:46.362]                             break
[13:20:46.362]                           }
[13:20:46.362]                         }
[13:20:46.362]                       }
[13:20:46.362]                       invisible(muffled)
[13:20:46.362]                     }
[13:20:46.362]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.362]                   }
[13:20:46.362]                 }
[13:20:46.362]             }
[13:20:46.362]         }))
[13:20:46.362]     }, error = function(ex) {
[13:20:46.362]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:46.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.362]                 ...future.rng), started = ...future.startTime, 
[13:20:46.362]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:46.362]             version = "1.8"), class = "FutureResult")
[13:20:46.362]     }, finally = {
[13:20:46.362]         if (!identical(...future.workdir, getwd())) 
[13:20:46.362]             setwd(...future.workdir)
[13:20:46.362]         {
[13:20:46.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:46.362]                 ...future.oldOptions$nwarnings <- NULL
[13:20:46.362]             }
[13:20:46.362]             base::options(...future.oldOptions)
[13:20:46.362]             if (.Platform$OS.type == "windows") {
[13:20:46.362]                 old_names <- names(...future.oldEnvVars)
[13:20:46.362]                 envs <- base::Sys.getenv()
[13:20:46.362]                 names <- names(envs)
[13:20:46.362]                 common <- intersect(names, old_names)
[13:20:46.362]                 added <- setdiff(names, old_names)
[13:20:46.362]                 removed <- setdiff(old_names, names)
[13:20:46.362]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:46.362]                   envs[common]]
[13:20:46.362]                 NAMES <- toupper(changed)
[13:20:46.362]                 args <- list()
[13:20:46.362]                 for (kk in seq_along(NAMES)) {
[13:20:46.362]                   name <- changed[[kk]]
[13:20:46.362]                   NAME <- NAMES[[kk]]
[13:20:46.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.362]                     next
[13:20:46.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.362]                 }
[13:20:46.362]                 NAMES <- toupper(added)
[13:20:46.362]                 for (kk in seq_along(NAMES)) {
[13:20:46.362]                   name <- added[[kk]]
[13:20:46.362]                   NAME <- NAMES[[kk]]
[13:20:46.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.362]                     next
[13:20:46.362]                   args[[name]] <- ""
[13:20:46.362]                 }
[13:20:46.362]                 NAMES <- toupper(removed)
[13:20:46.362]                 for (kk in seq_along(NAMES)) {
[13:20:46.362]                   name <- removed[[kk]]
[13:20:46.362]                   NAME <- NAMES[[kk]]
[13:20:46.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.362]                     next
[13:20:46.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.362]                 }
[13:20:46.362]                 if (length(args) > 0) 
[13:20:46.362]                   base::do.call(base::Sys.setenv, args = args)
[13:20:46.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:46.362]             }
[13:20:46.362]             else {
[13:20:46.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:46.362]             }
[13:20:46.362]             {
[13:20:46.362]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:46.362]                   0L) {
[13:20:46.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:46.362]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:46.362]                   base::options(opts)
[13:20:46.362]                 }
[13:20:46.362]                 {
[13:20:46.362]                   {
[13:20:46.362]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:46.362]                     NULL
[13:20:46.362]                   }
[13:20:46.362]                   options(future.plan = NULL)
[13:20:46.362]                   if (is.na(NA_character_)) 
[13:20:46.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:46.362]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:46.362]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:46.362]                     envir = parent.frame()) 
[13:20:46.362]                   {
[13:20:46.362]                     if (is.function(workers)) 
[13:20:46.362]                       workers <- workers()
[13:20:46.362]                     workers <- structure(as.integer(workers), 
[13:20:46.362]                       class = class(workers))
[13:20:46.362]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:46.362]                       workers >= 1)
[13:20:46.362]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:46.362]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:46.362]                     }
[13:20:46.362]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:46.362]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:46.362]                       envir = envir)
[13:20:46.362]                     if (!future$lazy) 
[13:20:46.362]                       future <- run(future)
[13:20:46.362]                     invisible(future)
[13:20:46.362]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:46.362]                 }
[13:20:46.362]             }
[13:20:46.362]         }
[13:20:46.362]     })
[13:20:46.362]     if (TRUE) {
[13:20:46.362]         base::sink(type = "output", split = FALSE)
[13:20:46.362]         if (TRUE) {
[13:20:46.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:46.362]         }
[13:20:46.362]         else {
[13:20:46.362]             ...future.result["stdout"] <- base::list(NULL)
[13:20:46.362]         }
[13:20:46.362]         base::close(...future.stdout)
[13:20:46.362]         ...future.stdout <- NULL
[13:20:46.362]     }
[13:20:46.362]     ...future.result$conditions <- ...future.conditions
[13:20:46.362]     ...future.result$finished <- base::Sys.time()
[13:20:46.362]     ...future.result
[13:20:46.362] }
[13:20:46.365] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:20:46.365] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:20:46.365] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:20:46.365] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:20:46.366] MultisessionFuture started
[13:20:46.366] - Launch lazy future ... done
[13:20:46.366] run() for ‘MultisessionFuture’ ... done
[13:20:46.366] result() for ClusterFuture ...
[13:20:46.366] receiveMessageFromWorker() for ClusterFuture ...
[13:20:46.367] - Validating connection of MultisessionFuture
[13:20:46.413] - received message: FutureResult
[13:20:46.414] - Received FutureResult
[13:20:46.414] - Erased future from FutureRegistry
[13:20:46.414] result() for ClusterFuture ...
[13:20:46.414] - result already collected: FutureResult
[13:20:46.414] result() for ClusterFuture ... done
[13:20:46.414] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:46.414] result() for ClusterFuture ... done
[13:20:46.414] result() for ClusterFuture ...
[13:20:46.414] - result already collected: FutureResult
[13:20:46.415] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:46.415] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:46.415] Searching for globals...
[13:20:46.418] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:46.418] Searching for globals ... DONE
[13:20:46.418] Resolving globals: TRUE
[13:20:46.418] Resolving any globals that are futures ...
[13:20:46.418] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:46.418] Resolving any globals that are futures ... DONE
[13:20:46.419] Resolving futures part of globals (recursively) ...
[13:20:46.419] resolve() on list ...
[13:20:46.419]  recursive: 99
[13:20:46.419]  length: 1
[13:20:46.419]  elements: ‘x’
[13:20:46.420]  length: 0 (resolved future 1)
[13:20:46.420] resolve() on list ... DONE
[13:20:46.420] - globals: [1] ‘x’
[13:20:46.420] Resolving futures part of globals (recursively) ... DONE
[13:20:46.420] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:46.421] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:46.421] - globals: [1] ‘x’
[13:20:46.421] 
[13:20:46.421] getGlobalsAndPackages() ... DONE
[13:20:46.421] run() for ‘Future’ ...
[13:20:46.421] - state: ‘created’
[13:20:46.422] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:46.437] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:46.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:46.437]   - Field: ‘node’
[13:20:46.437]   - Field: ‘label’
[13:20:46.437]   - Field: ‘local’
[13:20:46.437]   - Field: ‘owner’
[13:20:46.437]   - Field: ‘envir’
[13:20:46.437]   - Field: ‘workers’
[13:20:46.438]   - Field: ‘packages’
[13:20:46.438]   - Field: ‘gc’
[13:20:46.438]   - Field: ‘conditions’
[13:20:46.438]   - Field: ‘persistent’
[13:20:46.438]   - Field: ‘expr’
[13:20:46.438]   - Field: ‘uuid’
[13:20:46.438]   - Field: ‘seed’
[13:20:46.438]   - Field: ‘version’
[13:20:46.438]   - Field: ‘result’
[13:20:46.439]   - Field: ‘asynchronous’
[13:20:46.439]   - Field: ‘calls’
[13:20:46.439]   - Field: ‘globals’
[13:20:46.439]   - Field: ‘stdout’
[13:20:46.439]   - Field: ‘earlySignal’
[13:20:46.439]   - Field: ‘lazy’
[13:20:46.439]   - Field: ‘state’
[13:20:46.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:46.439] - Launch lazy future ...
[13:20:46.440] Packages needed by the future expression (n = 0): <none>
[13:20:46.440] Packages needed by future strategies (n = 0): <none>
[13:20:46.440] {
[13:20:46.440]     {
[13:20:46.440]         {
[13:20:46.440]             ...future.startTime <- base::Sys.time()
[13:20:46.440]             {
[13:20:46.440]                 {
[13:20:46.440]                   {
[13:20:46.440]                     {
[13:20:46.440]                       base::local({
[13:20:46.440]                         has_future <- base::requireNamespace("future", 
[13:20:46.440]                           quietly = TRUE)
[13:20:46.440]                         if (has_future) {
[13:20:46.440]                           ns <- base::getNamespace("future")
[13:20:46.440]                           version <- ns[[".package"]][["version"]]
[13:20:46.440]                           if (is.null(version)) 
[13:20:46.440]                             version <- utils::packageVersion("future")
[13:20:46.440]                         }
[13:20:46.440]                         else {
[13:20:46.440]                           version <- NULL
[13:20:46.440]                         }
[13:20:46.440]                         if (!has_future || version < "1.8.0") {
[13:20:46.440]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:46.440]                             "", base::R.version$version.string), 
[13:20:46.440]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:46.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:46.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:46.440]                               "release", "version")], collapse = " "), 
[13:20:46.440]                             hostname = base::Sys.info()[["nodename"]])
[13:20:46.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:46.440]                             info)
[13:20:46.440]                           info <- base::paste(info, collapse = "; ")
[13:20:46.440]                           if (!has_future) {
[13:20:46.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:46.440]                               info)
[13:20:46.440]                           }
[13:20:46.440]                           else {
[13:20:46.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:46.440]                               info, version)
[13:20:46.440]                           }
[13:20:46.440]                           base::stop(msg)
[13:20:46.440]                         }
[13:20:46.440]                       })
[13:20:46.440]                     }
[13:20:46.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:46.440]                     base::options(mc.cores = 1L)
[13:20:46.440]                   }
[13:20:46.440]                   options(future.plan = NULL)
[13:20:46.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:46.440]                 }
[13:20:46.440]                 ...future.workdir <- getwd()
[13:20:46.440]             }
[13:20:46.440]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:46.440]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:46.440]         }
[13:20:46.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:46.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:46.440]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:46.440]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:46.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:46.440]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:46.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:46.440]             base::names(...future.oldOptions))
[13:20:46.440]     }
[13:20:46.440]     if (FALSE) {
[13:20:46.440]     }
[13:20:46.440]     else {
[13:20:46.440]         if (TRUE) {
[13:20:46.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:46.440]                 open = "w")
[13:20:46.440]         }
[13:20:46.440]         else {
[13:20:46.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:46.440]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:46.440]         }
[13:20:46.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:46.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:46.440]             base::sink(type = "output", split = FALSE)
[13:20:46.440]             base::close(...future.stdout)
[13:20:46.440]         }, add = TRUE)
[13:20:46.440]     }
[13:20:46.440]     ...future.frame <- base::sys.nframe()
[13:20:46.440]     ...future.conditions <- base::list()
[13:20:46.440]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:46.440]     if (FALSE) {
[13:20:46.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:46.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:46.440]     }
[13:20:46.440]     ...future.result <- base::tryCatch({
[13:20:46.440]         base::withCallingHandlers({
[13:20:46.440]             ...future.value <- base::withVisible(base::local({
[13:20:46.440]                 ...future.makeSendCondition <- local({
[13:20:46.440]                   sendCondition <- NULL
[13:20:46.440]                   function(frame = 1L) {
[13:20:46.440]                     if (is.function(sendCondition)) 
[13:20:46.440]                       return(sendCondition)
[13:20:46.440]                     ns <- getNamespace("parallel")
[13:20:46.440]                     if (exists("sendData", mode = "function", 
[13:20:46.440]                       envir = ns)) {
[13:20:46.440]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:46.440]                         envir = ns)
[13:20:46.440]                       envir <- sys.frame(frame)
[13:20:46.440]                       master <- NULL
[13:20:46.440]                       while (!identical(envir, .GlobalEnv) && 
[13:20:46.440]                         !identical(envir, emptyenv())) {
[13:20:46.440]                         if (exists("master", mode = "list", envir = envir, 
[13:20:46.440]                           inherits = FALSE)) {
[13:20:46.440]                           master <- get("master", mode = "list", 
[13:20:46.440]                             envir = envir, inherits = FALSE)
[13:20:46.440]                           if (inherits(master, c("SOCKnode", 
[13:20:46.440]                             "SOCK0node"))) {
[13:20:46.440]                             sendCondition <<- function(cond) {
[13:20:46.440]                               data <- list(type = "VALUE", value = cond, 
[13:20:46.440]                                 success = TRUE)
[13:20:46.440]                               parallel_sendData(master, data)
[13:20:46.440]                             }
[13:20:46.440]                             return(sendCondition)
[13:20:46.440]                           }
[13:20:46.440]                         }
[13:20:46.440]                         frame <- frame + 1L
[13:20:46.440]                         envir <- sys.frame(frame)
[13:20:46.440]                       }
[13:20:46.440]                     }
[13:20:46.440]                     sendCondition <<- function(cond) NULL
[13:20:46.440]                   }
[13:20:46.440]                 })
[13:20:46.440]                 withCallingHandlers({
[13:20:46.440]                   {
[13:20:46.440]                     x$a <- 1
[13:20:46.440]                     x
[13:20:46.440]                   }
[13:20:46.440]                 }, immediateCondition = function(cond) {
[13:20:46.440]                   sendCondition <- ...future.makeSendCondition()
[13:20:46.440]                   sendCondition(cond)
[13:20:46.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.440]                   {
[13:20:46.440]                     inherits <- base::inherits
[13:20:46.440]                     invokeRestart <- base::invokeRestart
[13:20:46.440]                     is.null <- base::is.null
[13:20:46.440]                     muffled <- FALSE
[13:20:46.440]                     if (inherits(cond, "message")) {
[13:20:46.440]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:46.440]                       if (muffled) 
[13:20:46.440]                         invokeRestart("muffleMessage")
[13:20:46.440]                     }
[13:20:46.440]                     else if (inherits(cond, "warning")) {
[13:20:46.440]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:46.440]                       if (muffled) 
[13:20:46.440]                         invokeRestart("muffleWarning")
[13:20:46.440]                     }
[13:20:46.440]                     else if (inherits(cond, "condition")) {
[13:20:46.440]                       if (!is.null(pattern)) {
[13:20:46.440]                         computeRestarts <- base::computeRestarts
[13:20:46.440]                         grepl <- base::grepl
[13:20:46.440]                         restarts <- computeRestarts(cond)
[13:20:46.440]                         for (restart in restarts) {
[13:20:46.440]                           name <- restart$name
[13:20:46.440]                           if (is.null(name)) 
[13:20:46.440]                             next
[13:20:46.440]                           if (!grepl(pattern, name)) 
[13:20:46.440]                             next
[13:20:46.440]                           invokeRestart(restart)
[13:20:46.440]                           muffled <- TRUE
[13:20:46.440]                           break
[13:20:46.440]                         }
[13:20:46.440]                       }
[13:20:46.440]                     }
[13:20:46.440]                     invisible(muffled)
[13:20:46.440]                   }
[13:20:46.440]                   muffleCondition(cond)
[13:20:46.440]                 })
[13:20:46.440]             }))
[13:20:46.440]             future::FutureResult(value = ...future.value$value, 
[13:20:46.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.440]                   ...future.rng), globalenv = if (FALSE) 
[13:20:46.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:46.440]                     ...future.globalenv.names))
[13:20:46.440]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:46.440]         }, condition = base::local({
[13:20:46.440]             c <- base::c
[13:20:46.440]             inherits <- base::inherits
[13:20:46.440]             invokeRestart <- base::invokeRestart
[13:20:46.440]             length <- base::length
[13:20:46.440]             list <- base::list
[13:20:46.440]             seq.int <- base::seq.int
[13:20:46.440]             signalCondition <- base::signalCondition
[13:20:46.440]             sys.calls <- base::sys.calls
[13:20:46.440]             `[[` <- base::`[[`
[13:20:46.440]             `+` <- base::`+`
[13:20:46.440]             `<<-` <- base::`<<-`
[13:20:46.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:46.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:46.440]                   3L)]
[13:20:46.440]             }
[13:20:46.440]             function(cond) {
[13:20:46.440]                 is_error <- inherits(cond, "error")
[13:20:46.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:46.440]                   NULL)
[13:20:46.440]                 if (is_error) {
[13:20:46.440]                   sessionInformation <- function() {
[13:20:46.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:46.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:46.440]                       search = base::search(), system = base::Sys.info())
[13:20:46.440]                   }
[13:20:46.440]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:46.440]                     cond$call), session = sessionInformation(), 
[13:20:46.440]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:46.440]                   signalCondition(cond)
[13:20:46.440]                 }
[13:20:46.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:46.440]                 "immediateCondition"))) {
[13:20:46.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:46.440]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:46.440]                   if (TRUE && !signal) {
[13:20:46.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.440]                     {
[13:20:46.440]                       inherits <- base::inherits
[13:20:46.440]                       invokeRestart <- base::invokeRestart
[13:20:46.440]                       is.null <- base::is.null
[13:20:46.440]                       muffled <- FALSE
[13:20:46.440]                       if (inherits(cond, "message")) {
[13:20:46.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.440]                         if (muffled) 
[13:20:46.440]                           invokeRestart("muffleMessage")
[13:20:46.440]                       }
[13:20:46.440]                       else if (inherits(cond, "warning")) {
[13:20:46.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.440]                         if (muffled) 
[13:20:46.440]                           invokeRestart("muffleWarning")
[13:20:46.440]                       }
[13:20:46.440]                       else if (inherits(cond, "condition")) {
[13:20:46.440]                         if (!is.null(pattern)) {
[13:20:46.440]                           computeRestarts <- base::computeRestarts
[13:20:46.440]                           grepl <- base::grepl
[13:20:46.440]                           restarts <- computeRestarts(cond)
[13:20:46.440]                           for (restart in restarts) {
[13:20:46.440]                             name <- restart$name
[13:20:46.440]                             if (is.null(name)) 
[13:20:46.440]                               next
[13:20:46.440]                             if (!grepl(pattern, name)) 
[13:20:46.440]                               next
[13:20:46.440]                             invokeRestart(restart)
[13:20:46.440]                             muffled <- TRUE
[13:20:46.440]                             break
[13:20:46.440]                           }
[13:20:46.440]                         }
[13:20:46.440]                       }
[13:20:46.440]                       invisible(muffled)
[13:20:46.440]                     }
[13:20:46.440]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.440]                   }
[13:20:46.440]                 }
[13:20:46.440]                 else {
[13:20:46.440]                   if (TRUE) {
[13:20:46.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.440]                     {
[13:20:46.440]                       inherits <- base::inherits
[13:20:46.440]                       invokeRestart <- base::invokeRestart
[13:20:46.440]                       is.null <- base::is.null
[13:20:46.440]                       muffled <- FALSE
[13:20:46.440]                       if (inherits(cond, "message")) {
[13:20:46.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.440]                         if (muffled) 
[13:20:46.440]                           invokeRestart("muffleMessage")
[13:20:46.440]                       }
[13:20:46.440]                       else if (inherits(cond, "warning")) {
[13:20:46.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.440]                         if (muffled) 
[13:20:46.440]                           invokeRestart("muffleWarning")
[13:20:46.440]                       }
[13:20:46.440]                       else if (inherits(cond, "condition")) {
[13:20:46.440]                         if (!is.null(pattern)) {
[13:20:46.440]                           computeRestarts <- base::computeRestarts
[13:20:46.440]                           grepl <- base::grepl
[13:20:46.440]                           restarts <- computeRestarts(cond)
[13:20:46.440]                           for (restart in restarts) {
[13:20:46.440]                             name <- restart$name
[13:20:46.440]                             if (is.null(name)) 
[13:20:46.440]                               next
[13:20:46.440]                             if (!grepl(pattern, name)) 
[13:20:46.440]                               next
[13:20:46.440]                             invokeRestart(restart)
[13:20:46.440]                             muffled <- TRUE
[13:20:46.440]                             break
[13:20:46.440]                           }
[13:20:46.440]                         }
[13:20:46.440]                       }
[13:20:46.440]                       invisible(muffled)
[13:20:46.440]                     }
[13:20:46.440]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.440]                   }
[13:20:46.440]                 }
[13:20:46.440]             }
[13:20:46.440]         }))
[13:20:46.440]     }, error = function(ex) {
[13:20:46.440]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:46.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.440]                 ...future.rng), started = ...future.startTime, 
[13:20:46.440]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:46.440]             version = "1.8"), class = "FutureResult")
[13:20:46.440]     }, finally = {
[13:20:46.440]         if (!identical(...future.workdir, getwd())) 
[13:20:46.440]             setwd(...future.workdir)
[13:20:46.440]         {
[13:20:46.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:46.440]                 ...future.oldOptions$nwarnings <- NULL
[13:20:46.440]             }
[13:20:46.440]             base::options(...future.oldOptions)
[13:20:46.440]             if (.Platform$OS.type == "windows") {
[13:20:46.440]                 old_names <- names(...future.oldEnvVars)
[13:20:46.440]                 envs <- base::Sys.getenv()
[13:20:46.440]                 names <- names(envs)
[13:20:46.440]                 common <- intersect(names, old_names)
[13:20:46.440]                 added <- setdiff(names, old_names)
[13:20:46.440]                 removed <- setdiff(old_names, names)
[13:20:46.440]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:46.440]                   envs[common]]
[13:20:46.440]                 NAMES <- toupper(changed)
[13:20:46.440]                 args <- list()
[13:20:46.440]                 for (kk in seq_along(NAMES)) {
[13:20:46.440]                   name <- changed[[kk]]
[13:20:46.440]                   NAME <- NAMES[[kk]]
[13:20:46.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.440]                     next
[13:20:46.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.440]                 }
[13:20:46.440]                 NAMES <- toupper(added)
[13:20:46.440]                 for (kk in seq_along(NAMES)) {
[13:20:46.440]                   name <- added[[kk]]
[13:20:46.440]                   NAME <- NAMES[[kk]]
[13:20:46.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.440]                     next
[13:20:46.440]                   args[[name]] <- ""
[13:20:46.440]                 }
[13:20:46.440]                 NAMES <- toupper(removed)
[13:20:46.440]                 for (kk in seq_along(NAMES)) {
[13:20:46.440]                   name <- removed[[kk]]
[13:20:46.440]                   NAME <- NAMES[[kk]]
[13:20:46.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.440]                     next
[13:20:46.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.440]                 }
[13:20:46.440]                 if (length(args) > 0) 
[13:20:46.440]                   base::do.call(base::Sys.setenv, args = args)
[13:20:46.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:46.440]             }
[13:20:46.440]             else {
[13:20:46.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:46.440]             }
[13:20:46.440]             {
[13:20:46.440]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:46.440]                   0L) {
[13:20:46.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:46.440]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:46.440]                   base::options(opts)
[13:20:46.440]                 }
[13:20:46.440]                 {
[13:20:46.440]                   {
[13:20:46.440]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:46.440]                     NULL
[13:20:46.440]                   }
[13:20:46.440]                   options(future.plan = NULL)
[13:20:46.440]                   if (is.na(NA_character_)) 
[13:20:46.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:46.440]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:46.440]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:46.440]                     envir = parent.frame()) 
[13:20:46.440]                   {
[13:20:46.440]                     if (is.function(workers)) 
[13:20:46.440]                       workers <- workers()
[13:20:46.440]                     workers <- structure(as.integer(workers), 
[13:20:46.440]                       class = class(workers))
[13:20:46.440]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:46.440]                       workers >= 1)
[13:20:46.440]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:46.440]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:46.440]                     }
[13:20:46.440]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:46.440]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:46.440]                       envir = envir)
[13:20:46.440]                     if (!future$lazy) 
[13:20:46.440]                       future <- run(future)
[13:20:46.440]                     invisible(future)
[13:20:46.440]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:46.440]                 }
[13:20:46.440]             }
[13:20:46.440]         }
[13:20:46.440]     })
[13:20:46.440]     if (TRUE) {
[13:20:46.440]         base::sink(type = "output", split = FALSE)
[13:20:46.440]         if (TRUE) {
[13:20:46.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:46.440]         }
[13:20:46.440]         else {
[13:20:46.440]             ...future.result["stdout"] <- base::list(NULL)
[13:20:46.440]         }
[13:20:46.440]         base::close(...future.stdout)
[13:20:46.440]         ...future.stdout <- NULL
[13:20:46.440]     }
[13:20:46.440]     ...future.result$conditions <- ...future.conditions
[13:20:46.440]     ...future.result$finished <- base::Sys.time()
[13:20:46.440]     ...future.result
[13:20:46.440] }
[13:20:46.444] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:20:46.444] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:20:46.444] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:20:46.444] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:20:46.445] MultisessionFuture started
[13:20:46.445] - Launch lazy future ... done
[13:20:46.445] run() for ‘MultisessionFuture’ ... done
[13:20:46.445] result() for ClusterFuture ...
[13:20:46.445] receiveMessageFromWorker() for ClusterFuture ...
[13:20:46.446] - Validating connection of MultisessionFuture
[13:20:46.494] - received message: FutureResult
[13:20:46.494] - Received FutureResult
[13:20:46.494] - Erased future from FutureRegistry
[13:20:46.494] result() for ClusterFuture ...
[13:20:46.494] - result already collected: FutureResult
[13:20:46.494] result() for ClusterFuture ... done
[13:20:46.494] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:46.495] result() for ClusterFuture ... done
[13:20:46.495] result() for ClusterFuture ...
[13:20:46.495] - result already collected: FutureResult
[13:20:46.495] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:46.495] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:46.496] Searching for globals...
[13:20:46.498] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:46.498] Searching for globals ... DONE
[13:20:46.499] Resolving globals: TRUE
[13:20:46.499] Resolving any globals that are futures ...
[13:20:46.499] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:46.499] Resolving any globals that are futures ... DONE
[13:20:46.499] Resolving futures part of globals (recursively) ...
[13:20:46.500] resolve() on list ...
[13:20:46.500]  recursive: 99
[13:20:46.500]  length: 1
[13:20:46.500]  elements: ‘x’
[13:20:46.500]  length: 0 (resolved future 1)
[13:20:46.500] resolve() on list ... DONE
[13:20:46.500] - globals: [1] ‘x’
[13:20:46.501] Resolving futures part of globals (recursively) ... DONE
[13:20:46.501] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:46.501] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:46.501] - globals: [1] ‘x’
[13:20:46.501] 
[13:20:46.502] getGlobalsAndPackages() ... DONE
[13:20:46.502] run() for ‘Future’ ...
[13:20:46.502] - state: ‘created’
[13:20:46.502] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:46.521] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:46.521] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:46.521]   - Field: ‘node’
[13:20:46.521]   - Field: ‘label’
[13:20:46.521]   - Field: ‘local’
[13:20:46.521]   - Field: ‘owner’
[13:20:46.521]   - Field: ‘envir’
[13:20:46.521]   - Field: ‘workers’
[13:20:46.522]   - Field: ‘packages’
[13:20:46.522]   - Field: ‘gc’
[13:20:46.522]   - Field: ‘conditions’
[13:20:46.522]   - Field: ‘persistent’
[13:20:46.522]   - Field: ‘expr’
[13:20:46.522]   - Field: ‘uuid’
[13:20:46.522]   - Field: ‘seed’
[13:20:46.522]   - Field: ‘version’
[13:20:46.522]   - Field: ‘result’
[13:20:46.522]   - Field: ‘asynchronous’
[13:20:46.522]   - Field: ‘calls’
[13:20:46.523]   - Field: ‘globals’
[13:20:46.523]   - Field: ‘stdout’
[13:20:46.523]   - Field: ‘earlySignal’
[13:20:46.523]   - Field: ‘lazy’
[13:20:46.523]   - Field: ‘state’
[13:20:46.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:46.523] - Launch lazy future ...
[13:20:46.523] Packages needed by the future expression (n = 0): <none>
[13:20:46.524] Packages needed by future strategies (n = 0): <none>
[13:20:46.524] {
[13:20:46.524]     {
[13:20:46.524]         {
[13:20:46.524]             ...future.startTime <- base::Sys.time()
[13:20:46.524]             {
[13:20:46.524]                 {
[13:20:46.524]                   {
[13:20:46.524]                     {
[13:20:46.524]                       base::local({
[13:20:46.524]                         has_future <- base::requireNamespace("future", 
[13:20:46.524]                           quietly = TRUE)
[13:20:46.524]                         if (has_future) {
[13:20:46.524]                           ns <- base::getNamespace("future")
[13:20:46.524]                           version <- ns[[".package"]][["version"]]
[13:20:46.524]                           if (is.null(version)) 
[13:20:46.524]                             version <- utils::packageVersion("future")
[13:20:46.524]                         }
[13:20:46.524]                         else {
[13:20:46.524]                           version <- NULL
[13:20:46.524]                         }
[13:20:46.524]                         if (!has_future || version < "1.8.0") {
[13:20:46.524]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:46.524]                             "", base::R.version$version.string), 
[13:20:46.524]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:46.524]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:46.524]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:46.524]                               "release", "version")], collapse = " "), 
[13:20:46.524]                             hostname = base::Sys.info()[["nodename"]])
[13:20:46.524]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:46.524]                             info)
[13:20:46.524]                           info <- base::paste(info, collapse = "; ")
[13:20:46.524]                           if (!has_future) {
[13:20:46.524]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:46.524]                               info)
[13:20:46.524]                           }
[13:20:46.524]                           else {
[13:20:46.524]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:46.524]                               info, version)
[13:20:46.524]                           }
[13:20:46.524]                           base::stop(msg)
[13:20:46.524]                         }
[13:20:46.524]                       })
[13:20:46.524]                     }
[13:20:46.524]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:46.524]                     base::options(mc.cores = 1L)
[13:20:46.524]                   }
[13:20:46.524]                   options(future.plan = NULL)
[13:20:46.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:46.524]                 }
[13:20:46.524]                 ...future.workdir <- getwd()
[13:20:46.524]             }
[13:20:46.524]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:46.524]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:46.524]         }
[13:20:46.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:46.524]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:46.524]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:46.524]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:46.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:46.524]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:46.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:46.524]             base::names(...future.oldOptions))
[13:20:46.524]     }
[13:20:46.524]     if (FALSE) {
[13:20:46.524]     }
[13:20:46.524]     else {
[13:20:46.524]         if (TRUE) {
[13:20:46.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:46.524]                 open = "w")
[13:20:46.524]         }
[13:20:46.524]         else {
[13:20:46.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:46.524]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:46.524]         }
[13:20:46.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:46.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:46.524]             base::sink(type = "output", split = FALSE)
[13:20:46.524]             base::close(...future.stdout)
[13:20:46.524]         }, add = TRUE)
[13:20:46.524]     }
[13:20:46.524]     ...future.frame <- base::sys.nframe()
[13:20:46.524]     ...future.conditions <- base::list()
[13:20:46.524]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:46.524]     if (FALSE) {
[13:20:46.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:46.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:46.524]     }
[13:20:46.524]     ...future.result <- base::tryCatch({
[13:20:46.524]         base::withCallingHandlers({
[13:20:46.524]             ...future.value <- base::withVisible(base::local({
[13:20:46.524]                 ...future.makeSendCondition <- local({
[13:20:46.524]                   sendCondition <- NULL
[13:20:46.524]                   function(frame = 1L) {
[13:20:46.524]                     if (is.function(sendCondition)) 
[13:20:46.524]                       return(sendCondition)
[13:20:46.524]                     ns <- getNamespace("parallel")
[13:20:46.524]                     if (exists("sendData", mode = "function", 
[13:20:46.524]                       envir = ns)) {
[13:20:46.524]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:46.524]                         envir = ns)
[13:20:46.524]                       envir <- sys.frame(frame)
[13:20:46.524]                       master <- NULL
[13:20:46.524]                       while (!identical(envir, .GlobalEnv) && 
[13:20:46.524]                         !identical(envir, emptyenv())) {
[13:20:46.524]                         if (exists("master", mode = "list", envir = envir, 
[13:20:46.524]                           inherits = FALSE)) {
[13:20:46.524]                           master <- get("master", mode = "list", 
[13:20:46.524]                             envir = envir, inherits = FALSE)
[13:20:46.524]                           if (inherits(master, c("SOCKnode", 
[13:20:46.524]                             "SOCK0node"))) {
[13:20:46.524]                             sendCondition <<- function(cond) {
[13:20:46.524]                               data <- list(type = "VALUE", value = cond, 
[13:20:46.524]                                 success = TRUE)
[13:20:46.524]                               parallel_sendData(master, data)
[13:20:46.524]                             }
[13:20:46.524]                             return(sendCondition)
[13:20:46.524]                           }
[13:20:46.524]                         }
[13:20:46.524]                         frame <- frame + 1L
[13:20:46.524]                         envir <- sys.frame(frame)
[13:20:46.524]                       }
[13:20:46.524]                     }
[13:20:46.524]                     sendCondition <<- function(cond) NULL
[13:20:46.524]                   }
[13:20:46.524]                 })
[13:20:46.524]                 withCallingHandlers({
[13:20:46.524]                   {
[13:20:46.524]                     x$a <- 1
[13:20:46.524]                     x
[13:20:46.524]                   }
[13:20:46.524]                 }, immediateCondition = function(cond) {
[13:20:46.524]                   sendCondition <- ...future.makeSendCondition()
[13:20:46.524]                   sendCondition(cond)
[13:20:46.524]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.524]                   {
[13:20:46.524]                     inherits <- base::inherits
[13:20:46.524]                     invokeRestart <- base::invokeRestart
[13:20:46.524]                     is.null <- base::is.null
[13:20:46.524]                     muffled <- FALSE
[13:20:46.524]                     if (inherits(cond, "message")) {
[13:20:46.524]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:46.524]                       if (muffled) 
[13:20:46.524]                         invokeRestart("muffleMessage")
[13:20:46.524]                     }
[13:20:46.524]                     else if (inherits(cond, "warning")) {
[13:20:46.524]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:46.524]                       if (muffled) 
[13:20:46.524]                         invokeRestart("muffleWarning")
[13:20:46.524]                     }
[13:20:46.524]                     else if (inherits(cond, "condition")) {
[13:20:46.524]                       if (!is.null(pattern)) {
[13:20:46.524]                         computeRestarts <- base::computeRestarts
[13:20:46.524]                         grepl <- base::grepl
[13:20:46.524]                         restarts <- computeRestarts(cond)
[13:20:46.524]                         for (restart in restarts) {
[13:20:46.524]                           name <- restart$name
[13:20:46.524]                           if (is.null(name)) 
[13:20:46.524]                             next
[13:20:46.524]                           if (!grepl(pattern, name)) 
[13:20:46.524]                             next
[13:20:46.524]                           invokeRestart(restart)
[13:20:46.524]                           muffled <- TRUE
[13:20:46.524]                           break
[13:20:46.524]                         }
[13:20:46.524]                       }
[13:20:46.524]                     }
[13:20:46.524]                     invisible(muffled)
[13:20:46.524]                   }
[13:20:46.524]                   muffleCondition(cond)
[13:20:46.524]                 })
[13:20:46.524]             }))
[13:20:46.524]             future::FutureResult(value = ...future.value$value, 
[13:20:46.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.524]                   ...future.rng), globalenv = if (FALSE) 
[13:20:46.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:46.524]                     ...future.globalenv.names))
[13:20:46.524]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:46.524]         }, condition = base::local({
[13:20:46.524]             c <- base::c
[13:20:46.524]             inherits <- base::inherits
[13:20:46.524]             invokeRestart <- base::invokeRestart
[13:20:46.524]             length <- base::length
[13:20:46.524]             list <- base::list
[13:20:46.524]             seq.int <- base::seq.int
[13:20:46.524]             signalCondition <- base::signalCondition
[13:20:46.524]             sys.calls <- base::sys.calls
[13:20:46.524]             `[[` <- base::`[[`
[13:20:46.524]             `+` <- base::`+`
[13:20:46.524]             `<<-` <- base::`<<-`
[13:20:46.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:46.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:46.524]                   3L)]
[13:20:46.524]             }
[13:20:46.524]             function(cond) {
[13:20:46.524]                 is_error <- inherits(cond, "error")
[13:20:46.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:46.524]                   NULL)
[13:20:46.524]                 if (is_error) {
[13:20:46.524]                   sessionInformation <- function() {
[13:20:46.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:46.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:46.524]                       search = base::search(), system = base::Sys.info())
[13:20:46.524]                   }
[13:20:46.524]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:46.524]                     cond$call), session = sessionInformation(), 
[13:20:46.524]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:46.524]                   signalCondition(cond)
[13:20:46.524]                 }
[13:20:46.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:46.524]                 "immediateCondition"))) {
[13:20:46.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:46.524]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:46.524]                   if (TRUE && !signal) {
[13:20:46.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.524]                     {
[13:20:46.524]                       inherits <- base::inherits
[13:20:46.524]                       invokeRestart <- base::invokeRestart
[13:20:46.524]                       is.null <- base::is.null
[13:20:46.524]                       muffled <- FALSE
[13:20:46.524]                       if (inherits(cond, "message")) {
[13:20:46.524]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.524]                         if (muffled) 
[13:20:46.524]                           invokeRestart("muffleMessage")
[13:20:46.524]                       }
[13:20:46.524]                       else if (inherits(cond, "warning")) {
[13:20:46.524]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.524]                         if (muffled) 
[13:20:46.524]                           invokeRestart("muffleWarning")
[13:20:46.524]                       }
[13:20:46.524]                       else if (inherits(cond, "condition")) {
[13:20:46.524]                         if (!is.null(pattern)) {
[13:20:46.524]                           computeRestarts <- base::computeRestarts
[13:20:46.524]                           grepl <- base::grepl
[13:20:46.524]                           restarts <- computeRestarts(cond)
[13:20:46.524]                           for (restart in restarts) {
[13:20:46.524]                             name <- restart$name
[13:20:46.524]                             if (is.null(name)) 
[13:20:46.524]                               next
[13:20:46.524]                             if (!grepl(pattern, name)) 
[13:20:46.524]                               next
[13:20:46.524]                             invokeRestart(restart)
[13:20:46.524]                             muffled <- TRUE
[13:20:46.524]                             break
[13:20:46.524]                           }
[13:20:46.524]                         }
[13:20:46.524]                       }
[13:20:46.524]                       invisible(muffled)
[13:20:46.524]                     }
[13:20:46.524]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.524]                   }
[13:20:46.524]                 }
[13:20:46.524]                 else {
[13:20:46.524]                   if (TRUE) {
[13:20:46.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.524]                     {
[13:20:46.524]                       inherits <- base::inherits
[13:20:46.524]                       invokeRestart <- base::invokeRestart
[13:20:46.524]                       is.null <- base::is.null
[13:20:46.524]                       muffled <- FALSE
[13:20:46.524]                       if (inherits(cond, "message")) {
[13:20:46.524]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.524]                         if (muffled) 
[13:20:46.524]                           invokeRestart("muffleMessage")
[13:20:46.524]                       }
[13:20:46.524]                       else if (inherits(cond, "warning")) {
[13:20:46.524]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.524]                         if (muffled) 
[13:20:46.524]                           invokeRestart("muffleWarning")
[13:20:46.524]                       }
[13:20:46.524]                       else if (inherits(cond, "condition")) {
[13:20:46.524]                         if (!is.null(pattern)) {
[13:20:46.524]                           computeRestarts <- base::computeRestarts
[13:20:46.524]                           grepl <- base::grepl
[13:20:46.524]                           restarts <- computeRestarts(cond)
[13:20:46.524]                           for (restart in restarts) {
[13:20:46.524]                             name <- restart$name
[13:20:46.524]                             if (is.null(name)) 
[13:20:46.524]                               next
[13:20:46.524]                             if (!grepl(pattern, name)) 
[13:20:46.524]                               next
[13:20:46.524]                             invokeRestart(restart)
[13:20:46.524]                             muffled <- TRUE
[13:20:46.524]                             break
[13:20:46.524]                           }
[13:20:46.524]                         }
[13:20:46.524]                       }
[13:20:46.524]                       invisible(muffled)
[13:20:46.524]                     }
[13:20:46.524]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.524]                   }
[13:20:46.524]                 }
[13:20:46.524]             }
[13:20:46.524]         }))
[13:20:46.524]     }, error = function(ex) {
[13:20:46.524]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:46.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.524]                 ...future.rng), started = ...future.startTime, 
[13:20:46.524]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:46.524]             version = "1.8"), class = "FutureResult")
[13:20:46.524]     }, finally = {
[13:20:46.524]         if (!identical(...future.workdir, getwd())) 
[13:20:46.524]             setwd(...future.workdir)
[13:20:46.524]         {
[13:20:46.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:46.524]                 ...future.oldOptions$nwarnings <- NULL
[13:20:46.524]             }
[13:20:46.524]             base::options(...future.oldOptions)
[13:20:46.524]             if (.Platform$OS.type == "windows") {
[13:20:46.524]                 old_names <- names(...future.oldEnvVars)
[13:20:46.524]                 envs <- base::Sys.getenv()
[13:20:46.524]                 names <- names(envs)
[13:20:46.524]                 common <- intersect(names, old_names)
[13:20:46.524]                 added <- setdiff(names, old_names)
[13:20:46.524]                 removed <- setdiff(old_names, names)
[13:20:46.524]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:46.524]                   envs[common]]
[13:20:46.524]                 NAMES <- toupper(changed)
[13:20:46.524]                 args <- list()
[13:20:46.524]                 for (kk in seq_along(NAMES)) {
[13:20:46.524]                   name <- changed[[kk]]
[13:20:46.524]                   NAME <- NAMES[[kk]]
[13:20:46.524]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.524]                     next
[13:20:46.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.524]                 }
[13:20:46.524]                 NAMES <- toupper(added)
[13:20:46.524]                 for (kk in seq_along(NAMES)) {
[13:20:46.524]                   name <- added[[kk]]
[13:20:46.524]                   NAME <- NAMES[[kk]]
[13:20:46.524]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.524]                     next
[13:20:46.524]                   args[[name]] <- ""
[13:20:46.524]                 }
[13:20:46.524]                 NAMES <- toupper(removed)
[13:20:46.524]                 for (kk in seq_along(NAMES)) {
[13:20:46.524]                   name <- removed[[kk]]
[13:20:46.524]                   NAME <- NAMES[[kk]]
[13:20:46.524]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.524]                     next
[13:20:46.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.524]                 }
[13:20:46.524]                 if (length(args) > 0) 
[13:20:46.524]                   base::do.call(base::Sys.setenv, args = args)
[13:20:46.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:46.524]             }
[13:20:46.524]             else {
[13:20:46.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:46.524]             }
[13:20:46.524]             {
[13:20:46.524]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:46.524]                   0L) {
[13:20:46.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:46.524]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:46.524]                   base::options(opts)
[13:20:46.524]                 }
[13:20:46.524]                 {
[13:20:46.524]                   {
[13:20:46.524]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:46.524]                     NULL
[13:20:46.524]                   }
[13:20:46.524]                   options(future.plan = NULL)
[13:20:46.524]                   if (is.na(NA_character_)) 
[13:20:46.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:46.524]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:46.524]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:46.524]                     envir = parent.frame()) 
[13:20:46.524]                   {
[13:20:46.524]                     if (is.function(workers)) 
[13:20:46.524]                       workers <- workers()
[13:20:46.524]                     workers <- structure(as.integer(workers), 
[13:20:46.524]                       class = class(workers))
[13:20:46.524]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:46.524]                       workers >= 1)
[13:20:46.524]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:46.524]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:46.524]                     }
[13:20:46.524]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:46.524]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:46.524]                       envir = envir)
[13:20:46.524]                     if (!future$lazy) 
[13:20:46.524]                       future <- run(future)
[13:20:46.524]                     invisible(future)
[13:20:46.524]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:46.524]                 }
[13:20:46.524]             }
[13:20:46.524]         }
[13:20:46.524]     })
[13:20:46.524]     if (TRUE) {
[13:20:46.524]         base::sink(type = "output", split = FALSE)
[13:20:46.524]         if (TRUE) {
[13:20:46.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:46.524]         }
[13:20:46.524]         else {
[13:20:46.524]             ...future.result["stdout"] <- base::list(NULL)
[13:20:46.524]         }
[13:20:46.524]         base::close(...future.stdout)
[13:20:46.524]         ...future.stdout <- NULL
[13:20:46.524]     }
[13:20:46.524]     ...future.result$conditions <- ...future.conditions
[13:20:46.524]     ...future.result$finished <- base::Sys.time()
[13:20:46.524]     ...future.result
[13:20:46.524] }
[13:20:46.527] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:20:46.527] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:20:46.527] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:20:46.527] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:20:46.528] MultisessionFuture started
[13:20:46.528] - Launch lazy future ... done
[13:20:46.528] run() for ‘MultisessionFuture’ ... done
[13:20:46.528] result() for ClusterFuture ...
[13:20:46.528] receiveMessageFromWorker() for ClusterFuture ...
[13:20:46.528] - Validating connection of MultisessionFuture
[13:20:46.574] - received message: FutureResult
[13:20:46.574] - Received FutureResult
[13:20:46.574] - Erased future from FutureRegistry
[13:20:46.574] result() for ClusterFuture ...
[13:20:46.574] - result already collected: FutureResult
[13:20:46.574] result() for ClusterFuture ... done
[13:20:46.574] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:46.574] result() for ClusterFuture ... done
[13:20:46.575] result() for ClusterFuture ...
[13:20:46.575] - result already collected: FutureResult
[13:20:46.575] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:46.575] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:46.575] Searching for globals...
[13:20:46.577] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:46.577] Searching for globals ... DONE
[13:20:46.578] Resolving globals: TRUE
[13:20:46.578] Resolving any globals that are futures ...
[13:20:46.578] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[13:20:46.578] Resolving any globals that are futures ... DONE
[13:20:46.578] Resolving futures part of globals (recursively) ...
[13:20:46.579] resolve() on list ...
[13:20:46.579]  recursive: 99
[13:20:46.579]  length: 1
[13:20:46.579]  elements: ‘x’
[13:20:46.579]  length: 0 (resolved future 1)
[13:20:46.579] resolve() on list ... DONE
[13:20:46.579] - globals: [1] ‘x’
[13:20:46.579] Resolving futures part of globals (recursively) ... DONE
[13:20:46.579] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:46.580] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:46.580] - globals: [1] ‘x’
[13:20:46.580] 
[13:20:46.580] getGlobalsAndPackages() ... DONE
[13:20:46.580] run() for ‘Future’ ...
[13:20:46.580] - state: ‘created’
[13:20:46.581] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:46.596] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:46.596] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:46.596]   - Field: ‘node’
[13:20:46.596]   - Field: ‘label’
[13:20:46.596]   - Field: ‘local’
[13:20:46.596]   - Field: ‘owner’
[13:20:46.596]   - Field: ‘envir’
[13:20:46.596]   - Field: ‘workers’
[13:20:46.596]   - Field: ‘packages’
[13:20:46.597]   - Field: ‘gc’
[13:20:46.597]   - Field: ‘conditions’
[13:20:46.597]   - Field: ‘persistent’
[13:20:46.597]   - Field: ‘expr’
[13:20:46.597]   - Field: ‘uuid’
[13:20:46.597]   - Field: ‘seed’
[13:20:46.597]   - Field: ‘version’
[13:20:46.597]   - Field: ‘result’
[13:20:46.597]   - Field: ‘asynchronous’
[13:20:46.597]   - Field: ‘calls’
[13:20:46.597]   - Field: ‘globals’
[13:20:46.598]   - Field: ‘stdout’
[13:20:46.598]   - Field: ‘earlySignal’
[13:20:46.598]   - Field: ‘lazy’
[13:20:46.598]   - Field: ‘state’
[13:20:46.598] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:46.598] - Launch lazy future ...
[13:20:46.598] Packages needed by the future expression (n = 0): <none>
[13:20:46.598] Packages needed by future strategies (n = 0): <none>
[13:20:46.599] {
[13:20:46.599]     {
[13:20:46.599]         {
[13:20:46.599]             ...future.startTime <- base::Sys.time()
[13:20:46.599]             {
[13:20:46.599]                 {
[13:20:46.599]                   {
[13:20:46.599]                     {
[13:20:46.599]                       base::local({
[13:20:46.599]                         has_future <- base::requireNamespace("future", 
[13:20:46.599]                           quietly = TRUE)
[13:20:46.599]                         if (has_future) {
[13:20:46.599]                           ns <- base::getNamespace("future")
[13:20:46.599]                           version <- ns[[".package"]][["version"]]
[13:20:46.599]                           if (is.null(version)) 
[13:20:46.599]                             version <- utils::packageVersion("future")
[13:20:46.599]                         }
[13:20:46.599]                         else {
[13:20:46.599]                           version <- NULL
[13:20:46.599]                         }
[13:20:46.599]                         if (!has_future || version < "1.8.0") {
[13:20:46.599]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:46.599]                             "", base::R.version$version.string), 
[13:20:46.599]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:46.599]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:46.599]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:46.599]                               "release", "version")], collapse = " "), 
[13:20:46.599]                             hostname = base::Sys.info()[["nodename"]])
[13:20:46.599]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:46.599]                             info)
[13:20:46.599]                           info <- base::paste(info, collapse = "; ")
[13:20:46.599]                           if (!has_future) {
[13:20:46.599]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:46.599]                               info)
[13:20:46.599]                           }
[13:20:46.599]                           else {
[13:20:46.599]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:46.599]                               info, version)
[13:20:46.599]                           }
[13:20:46.599]                           base::stop(msg)
[13:20:46.599]                         }
[13:20:46.599]                       })
[13:20:46.599]                     }
[13:20:46.599]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:46.599]                     base::options(mc.cores = 1L)
[13:20:46.599]                   }
[13:20:46.599]                   options(future.plan = NULL)
[13:20:46.599]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.599]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:46.599]                 }
[13:20:46.599]                 ...future.workdir <- getwd()
[13:20:46.599]             }
[13:20:46.599]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:46.599]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:46.599]         }
[13:20:46.599]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:46.599]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:46.599]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:46.599]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:46.599]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:46.599]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:46.599]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:46.599]             base::names(...future.oldOptions))
[13:20:46.599]     }
[13:20:46.599]     if (FALSE) {
[13:20:46.599]     }
[13:20:46.599]     else {
[13:20:46.599]         if (TRUE) {
[13:20:46.599]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:46.599]                 open = "w")
[13:20:46.599]         }
[13:20:46.599]         else {
[13:20:46.599]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:46.599]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:46.599]         }
[13:20:46.599]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:46.599]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:46.599]             base::sink(type = "output", split = FALSE)
[13:20:46.599]             base::close(...future.stdout)
[13:20:46.599]         }, add = TRUE)
[13:20:46.599]     }
[13:20:46.599]     ...future.frame <- base::sys.nframe()
[13:20:46.599]     ...future.conditions <- base::list()
[13:20:46.599]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:46.599]     if (FALSE) {
[13:20:46.599]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:46.599]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:46.599]     }
[13:20:46.599]     ...future.result <- base::tryCatch({
[13:20:46.599]         base::withCallingHandlers({
[13:20:46.599]             ...future.value <- base::withVisible(base::local({
[13:20:46.599]                 ...future.makeSendCondition <- local({
[13:20:46.599]                   sendCondition <- NULL
[13:20:46.599]                   function(frame = 1L) {
[13:20:46.599]                     if (is.function(sendCondition)) 
[13:20:46.599]                       return(sendCondition)
[13:20:46.599]                     ns <- getNamespace("parallel")
[13:20:46.599]                     if (exists("sendData", mode = "function", 
[13:20:46.599]                       envir = ns)) {
[13:20:46.599]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:46.599]                         envir = ns)
[13:20:46.599]                       envir <- sys.frame(frame)
[13:20:46.599]                       master <- NULL
[13:20:46.599]                       while (!identical(envir, .GlobalEnv) && 
[13:20:46.599]                         !identical(envir, emptyenv())) {
[13:20:46.599]                         if (exists("master", mode = "list", envir = envir, 
[13:20:46.599]                           inherits = FALSE)) {
[13:20:46.599]                           master <- get("master", mode = "list", 
[13:20:46.599]                             envir = envir, inherits = FALSE)
[13:20:46.599]                           if (inherits(master, c("SOCKnode", 
[13:20:46.599]                             "SOCK0node"))) {
[13:20:46.599]                             sendCondition <<- function(cond) {
[13:20:46.599]                               data <- list(type = "VALUE", value = cond, 
[13:20:46.599]                                 success = TRUE)
[13:20:46.599]                               parallel_sendData(master, data)
[13:20:46.599]                             }
[13:20:46.599]                             return(sendCondition)
[13:20:46.599]                           }
[13:20:46.599]                         }
[13:20:46.599]                         frame <- frame + 1L
[13:20:46.599]                         envir <- sys.frame(frame)
[13:20:46.599]                       }
[13:20:46.599]                     }
[13:20:46.599]                     sendCondition <<- function(cond) NULL
[13:20:46.599]                   }
[13:20:46.599]                 })
[13:20:46.599]                 withCallingHandlers({
[13:20:46.599]                   {
[13:20:46.599]                     x$a <- 1
[13:20:46.599]                     x
[13:20:46.599]                   }
[13:20:46.599]                 }, immediateCondition = function(cond) {
[13:20:46.599]                   sendCondition <- ...future.makeSendCondition()
[13:20:46.599]                   sendCondition(cond)
[13:20:46.599]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.599]                   {
[13:20:46.599]                     inherits <- base::inherits
[13:20:46.599]                     invokeRestart <- base::invokeRestart
[13:20:46.599]                     is.null <- base::is.null
[13:20:46.599]                     muffled <- FALSE
[13:20:46.599]                     if (inherits(cond, "message")) {
[13:20:46.599]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:46.599]                       if (muffled) 
[13:20:46.599]                         invokeRestart("muffleMessage")
[13:20:46.599]                     }
[13:20:46.599]                     else if (inherits(cond, "warning")) {
[13:20:46.599]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:46.599]                       if (muffled) 
[13:20:46.599]                         invokeRestart("muffleWarning")
[13:20:46.599]                     }
[13:20:46.599]                     else if (inherits(cond, "condition")) {
[13:20:46.599]                       if (!is.null(pattern)) {
[13:20:46.599]                         computeRestarts <- base::computeRestarts
[13:20:46.599]                         grepl <- base::grepl
[13:20:46.599]                         restarts <- computeRestarts(cond)
[13:20:46.599]                         for (restart in restarts) {
[13:20:46.599]                           name <- restart$name
[13:20:46.599]                           if (is.null(name)) 
[13:20:46.599]                             next
[13:20:46.599]                           if (!grepl(pattern, name)) 
[13:20:46.599]                             next
[13:20:46.599]                           invokeRestart(restart)
[13:20:46.599]                           muffled <- TRUE
[13:20:46.599]                           break
[13:20:46.599]                         }
[13:20:46.599]                       }
[13:20:46.599]                     }
[13:20:46.599]                     invisible(muffled)
[13:20:46.599]                   }
[13:20:46.599]                   muffleCondition(cond)
[13:20:46.599]                 })
[13:20:46.599]             }))
[13:20:46.599]             future::FutureResult(value = ...future.value$value, 
[13:20:46.599]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.599]                   ...future.rng), globalenv = if (FALSE) 
[13:20:46.599]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:46.599]                     ...future.globalenv.names))
[13:20:46.599]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:46.599]         }, condition = base::local({
[13:20:46.599]             c <- base::c
[13:20:46.599]             inherits <- base::inherits
[13:20:46.599]             invokeRestart <- base::invokeRestart
[13:20:46.599]             length <- base::length
[13:20:46.599]             list <- base::list
[13:20:46.599]             seq.int <- base::seq.int
[13:20:46.599]             signalCondition <- base::signalCondition
[13:20:46.599]             sys.calls <- base::sys.calls
[13:20:46.599]             `[[` <- base::`[[`
[13:20:46.599]             `+` <- base::`+`
[13:20:46.599]             `<<-` <- base::`<<-`
[13:20:46.599]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:46.599]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:46.599]                   3L)]
[13:20:46.599]             }
[13:20:46.599]             function(cond) {
[13:20:46.599]                 is_error <- inherits(cond, "error")
[13:20:46.599]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:46.599]                   NULL)
[13:20:46.599]                 if (is_error) {
[13:20:46.599]                   sessionInformation <- function() {
[13:20:46.599]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:46.599]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:46.599]                       search = base::search(), system = base::Sys.info())
[13:20:46.599]                   }
[13:20:46.599]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.599]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:46.599]                     cond$call), session = sessionInformation(), 
[13:20:46.599]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:46.599]                   signalCondition(cond)
[13:20:46.599]                 }
[13:20:46.599]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:46.599]                 "immediateCondition"))) {
[13:20:46.599]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:46.599]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.599]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:46.599]                   if (TRUE && !signal) {
[13:20:46.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.599]                     {
[13:20:46.599]                       inherits <- base::inherits
[13:20:46.599]                       invokeRestart <- base::invokeRestart
[13:20:46.599]                       is.null <- base::is.null
[13:20:46.599]                       muffled <- FALSE
[13:20:46.599]                       if (inherits(cond, "message")) {
[13:20:46.599]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.599]                         if (muffled) 
[13:20:46.599]                           invokeRestart("muffleMessage")
[13:20:46.599]                       }
[13:20:46.599]                       else if (inherits(cond, "warning")) {
[13:20:46.599]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.599]                         if (muffled) 
[13:20:46.599]                           invokeRestart("muffleWarning")
[13:20:46.599]                       }
[13:20:46.599]                       else if (inherits(cond, "condition")) {
[13:20:46.599]                         if (!is.null(pattern)) {
[13:20:46.599]                           computeRestarts <- base::computeRestarts
[13:20:46.599]                           grepl <- base::grepl
[13:20:46.599]                           restarts <- computeRestarts(cond)
[13:20:46.599]                           for (restart in restarts) {
[13:20:46.599]                             name <- restart$name
[13:20:46.599]                             if (is.null(name)) 
[13:20:46.599]                               next
[13:20:46.599]                             if (!grepl(pattern, name)) 
[13:20:46.599]                               next
[13:20:46.599]                             invokeRestart(restart)
[13:20:46.599]                             muffled <- TRUE
[13:20:46.599]                             break
[13:20:46.599]                           }
[13:20:46.599]                         }
[13:20:46.599]                       }
[13:20:46.599]                       invisible(muffled)
[13:20:46.599]                     }
[13:20:46.599]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.599]                   }
[13:20:46.599]                 }
[13:20:46.599]                 else {
[13:20:46.599]                   if (TRUE) {
[13:20:46.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.599]                     {
[13:20:46.599]                       inherits <- base::inherits
[13:20:46.599]                       invokeRestart <- base::invokeRestart
[13:20:46.599]                       is.null <- base::is.null
[13:20:46.599]                       muffled <- FALSE
[13:20:46.599]                       if (inherits(cond, "message")) {
[13:20:46.599]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.599]                         if (muffled) 
[13:20:46.599]                           invokeRestart("muffleMessage")
[13:20:46.599]                       }
[13:20:46.599]                       else if (inherits(cond, "warning")) {
[13:20:46.599]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.599]                         if (muffled) 
[13:20:46.599]                           invokeRestart("muffleWarning")
[13:20:46.599]                       }
[13:20:46.599]                       else if (inherits(cond, "condition")) {
[13:20:46.599]                         if (!is.null(pattern)) {
[13:20:46.599]                           computeRestarts <- base::computeRestarts
[13:20:46.599]                           grepl <- base::grepl
[13:20:46.599]                           restarts <- computeRestarts(cond)
[13:20:46.599]                           for (restart in restarts) {
[13:20:46.599]                             name <- restart$name
[13:20:46.599]                             if (is.null(name)) 
[13:20:46.599]                               next
[13:20:46.599]                             if (!grepl(pattern, name)) 
[13:20:46.599]                               next
[13:20:46.599]                             invokeRestart(restart)
[13:20:46.599]                             muffled <- TRUE
[13:20:46.599]                             break
[13:20:46.599]                           }
[13:20:46.599]                         }
[13:20:46.599]                       }
[13:20:46.599]                       invisible(muffled)
[13:20:46.599]                     }
[13:20:46.599]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.599]                   }
[13:20:46.599]                 }
[13:20:46.599]             }
[13:20:46.599]         }))
[13:20:46.599]     }, error = function(ex) {
[13:20:46.599]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:46.599]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.599]                 ...future.rng), started = ...future.startTime, 
[13:20:46.599]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:46.599]             version = "1.8"), class = "FutureResult")
[13:20:46.599]     }, finally = {
[13:20:46.599]         if (!identical(...future.workdir, getwd())) 
[13:20:46.599]             setwd(...future.workdir)
[13:20:46.599]         {
[13:20:46.599]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:46.599]                 ...future.oldOptions$nwarnings <- NULL
[13:20:46.599]             }
[13:20:46.599]             base::options(...future.oldOptions)
[13:20:46.599]             if (.Platform$OS.type == "windows") {
[13:20:46.599]                 old_names <- names(...future.oldEnvVars)
[13:20:46.599]                 envs <- base::Sys.getenv()
[13:20:46.599]                 names <- names(envs)
[13:20:46.599]                 common <- intersect(names, old_names)
[13:20:46.599]                 added <- setdiff(names, old_names)
[13:20:46.599]                 removed <- setdiff(old_names, names)
[13:20:46.599]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:46.599]                   envs[common]]
[13:20:46.599]                 NAMES <- toupper(changed)
[13:20:46.599]                 args <- list()
[13:20:46.599]                 for (kk in seq_along(NAMES)) {
[13:20:46.599]                   name <- changed[[kk]]
[13:20:46.599]                   NAME <- NAMES[[kk]]
[13:20:46.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.599]                     next
[13:20:46.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.599]                 }
[13:20:46.599]                 NAMES <- toupper(added)
[13:20:46.599]                 for (kk in seq_along(NAMES)) {
[13:20:46.599]                   name <- added[[kk]]
[13:20:46.599]                   NAME <- NAMES[[kk]]
[13:20:46.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.599]                     next
[13:20:46.599]                   args[[name]] <- ""
[13:20:46.599]                 }
[13:20:46.599]                 NAMES <- toupper(removed)
[13:20:46.599]                 for (kk in seq_along(NAMES)) {
[13:20:46.599]                   name <- removed[[kk]]
[13:20:46.599]                   NAME <- NAMES[[kk]]
[13:20:46.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.599]                     next
[13:20:46.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.599]                 }
[13:20:46.599]                 if (length(args) > 0) 
[13:20:46.599]                   base::do.call(base::Sys.setenv, args = args)
[13:20:46.599]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:46.599]             }
[13:20:46.599]             else {
[13:20:46.599]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:46.599]             }
[13:20:46.599]             {
[13:20:46.599]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:46.599]                   0L) {
[13:20:46.599]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:46.599]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:46.599]                   base::options(opts)
[13:20:46.599]                 }
[13:20:46.599]                 {
[13:20:46.599]                   {
[13:20:46.599]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:46.599]                     NULL
[13:20:46.599]                   }
[13:20:46.599]                   options(future.plan = NULL)
[13:20:46.599]                   if (is.na(NA_character_)) 
[13:20:46.599]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.599]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:46.599]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:46.599]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:46.599]                     envir = parent.frame()) 
[13:20:46.599]                   {
[13:20:46.599]                     if (is.function(workers)) 
[13:20:46.599]                       workers <- workers()
[13:20:46.599]                     workers <- structure(as.integer(workers), 
[13:20:46.599]                       class = class(workers))
[13:20:46.599]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:46.599]                       workers >= 1)
[13:20:46.599]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:46.599]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:46.599]                     }
[13:20:46.599]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:46.599]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:46.599]                       envir = envir)
[13:20:46.599]                     if (!future$lazy) 
[13:20:46.599]                       future <- run(future)
[13:20:46.599]                     invisible(future)
[13:20:46.599]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:46.599]                 }
[13:20:46.599]             }
[13:20:46.599]         }
[13:20:46.599]     })
[13:20:46.599]     if (TRUE) {
[13:20:46.599]         base::sink(type = "output", split = FALSE)
[13:20:46.599]         if (TRUE) {
[13:20:46.599]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:46.599]         }
[13:20:46.599]         else {
[13:20:46.599]             ...future.result["stdout"] <- base::list(NULL)
[13:20:46.599]         }
[13:20:46.599]         base::close(...future.stdout)
[13:20:46.599]         ...future.stdout <- NULL
[13:20:46.599]     }
[13:20:46.599]     ...future.result$conditions <- ...future.conditions
[13:20:46.599]     ...future.result$finished <- base::Sys.time()
[13:20:46.599]     ...future.result
[13:20:46.599] }
[13:20:46.602] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:20:46.602] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:20:46.602] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:20:46.602] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:20:46.603] MultisessionFuture started
[13:20:46.603] - Launch lazy future ... done
[13:20:46.603] run() for ‘MultisessionFuture’ ... done
[13:20:46.603] result() for ClusterFuture ...
[13:20:46.603] receiveMessageFromWorker() for ClusterFuture ...
[13:20:46.603] - Validating connection of MultisessionFuture
[13:20:46.650] - received message: FutureResult
[13:20:46.650] - Received FutureResult
[13:20:46.650] - Erased future from FutureRegistry
[13:20:46.650] result() for ClusterFuture ...
[13:20:46.650] - result already collected: FutureResult
[13:20:46.650] result() for ClusterFuture ... done
[13:20:46.651] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:46.651] result() for ClusterFuture ... done
[13:20:46.651] result() for ClusterFuture ...
[13:20:46.651] - result already collected: FutureResult
[13:20:46.651] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:46.651] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:46.652] Searching for globals...
[13:20:46.654] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:20:46.654] Searching for globals ... DONE
[13:20:46.655] Resolving globals: TRUE
[13:20:46.655] Resolving any globals that are futures ...
[13:20:46.655] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[13:20:46.655] Resolving any globals that are futures ... DONE
[13:20:46.655] 
[13:20:46.655] 
[13:20:46.655] getGlobalsAndPackages() ... DONE
[13:20:46.656] run() for ‘Future’ ...
[13:20:46.656] - state: ‘created’
[13:20:46.656] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:46.671] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:46.671] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:46.671]   - Field: ‘node’
[13:20:46.671]   - Field: ‘label’
[13:20:46.672]   - Field: ‘local’
[13:20:46.672]   - Field: ‘owner’
[13:20:46.672]   - Field: ‘envir’
[13:20:46.672]   - Field: ‘workers’
[13:20:46.672]   - Field: ‘packages’
[13:20:46.672]   - Field: ‘gc’
[13:20:46.672]   - Field: ‘conditions’
[13:20:46.672]   - Field: ‘persistent’
[13:20:46.672]   - Field: ‘expr’
[13:20:46.672]   - Field: ‘uuid’
[13:20:46.672]   - Field: ‘seed’
[13:20:46.673]   - Field: ‘version’
[13:20:46.673]   - Field: ‘result’
[13:20:46.673]   - Field: ‘asynchronous’
[13:20:46.673]   - Field: ‘calls’
[13:20:46.673]   - Field: ‘globals’
[13:20:46.673]   - Field: ‘stdout’
[13:20:46.673]   - Field: ‘earlySignal’
[13:20:46.673]   - Field: ‘lazy’
[13:20:46.673]   - Field: ‘state’
[13:20:46.673] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:46.674] - Launch lazy future ...
[13:20:46.674] Packages needed by the future expression (n = 0): <none>
[13:20:46.674] Packages needed by future strategies (n = 0): <none>
[13:20:46.674] {
[13:20:46.674]     {
[13:20:46.674]         {
[13:20:46.674]             ...future.startTime <- base::Sys.time()
[13:20:46.674]             {
[13:20:46.674]                 {
[13:20:46.674]                   {
[13:20:46.674]                     {
[13:20:46.674]                       base::local({
[13:20:46.674]                         has_future <- base::requireNamespace("future", 
[13:20:46.674]                           quietly = TRUE)
[13:20:46.674]                         if (has_future) {
[13:20:46.674]                           ns <- base::getNamespace("future")
[13:20:46.674]                           version <- ns[[".package"]][["version"]]
[13:20:46.674]                           if (is.null(version)) 
[13:20:46.674]                             version <- utils::packageVersion("future")
[13:20:46.674]                         }
[13:20:46.674]                         else {
[13:20:46.674]                           version <- NULL
[13:20:46.674]                         }
[13:20:46.674]                         if (!has_future || version < "1.8.0") {
[13:20:46.674]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:46.674]                             "", base::R.version$version.string), 
[13:20:46.674]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:46.674]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:46.674]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:46.674]                               "release", "version")], collapse = " "), 
[13:20:46.674]                             hostname = base::Sys.info()[["nodename"]])
[13:20:46.674]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:46.674]                             info)
[13:20:46.674]                           info <- base::paste(info, collapse = "; ")
[13:20:46.674]                           if (!has_future) {
[13:20:46.674]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:46.674]                               info)
[13:20:46.674]                           }
[13:20:46.674]                           else {
[13:20:46.674]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:46.674]                               info, version)
[13:20:46.674]                           }
[13:20:46.674]                           base::stop(msg)
[13:20:46.674]                         }
[13:20:46.674]                       })
[13:20:46.674]                     }
[13:20:46.674]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:46.674]                     base::options(mc.cores = 1L)
[13:20:46.674]                   }
[13:20:46.674]                   options(future.plan = NULL)
[13:20:46.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:46.674]                 }
[13:20:46.674]                 ...future.workdir <- getwd()
[13:20:46.674]             }
[13:20:46.674]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:46.674]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:46.674]         }
[13:20:46.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:46.674]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:46.674]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:46.674]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:46.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:46.674]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:46.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:46.674]             base::names(...future.oldOptions))
[13:20:46.674]     }
[13:20:46.674]     if (FALSE) {
[13:20:46.674]     }
[13:20:46.674]     else {
[13:20:46.674]         if (TRUE) {
[13:20:46.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:46.674]                 open = "w")
[13:20:46.674]         }
[13:20:46.674]         else {
[13:20:46.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:46.674]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:46.674]         }
[13:20:46.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:46.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:46.674]             base::sink(type = "output", split = FALSE)
[13:20:46.674]             base::close(...future.stdout)
[13:20:46.674]         }, add = TRUE)
[13:20:46.674]     }
[13:20:46.674]     ...future.frame <- base::sys.nframe()
[13:20:46.674]     ...future.conditions <- base::list()
[13:20:46.674]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:46.674]     if (FALSE) {
[13:20:46.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:46.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:46.674]     }
[13:20:46.674]     ...future.result <- base::tryCatch({
[13:20:46.674]         base::withCallingHandlers({
[13:20:46.674]             ...future.value <- base::withVisible(base::local({
[13:20:46.674]                 ...future.makeSendCondition <- local({
[13:20:46.674]                   sendCondition <- NULL
[13:20:46.674]                   function(frame = 1L) {
[13:20:46.674]                     if (is.function(sendCondition)) 
[13:20:46.674]                       return(sendCondition)
[13:20:46.674]                     ns <- getNamespace("parallel")
[13:20:46.674]                     if (exists("sendData", mode = "function", 
[13:20:46.674]                       envir = ns)) {
[13:20:46.674]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:46.674]                         envir = ns)
[13:20:46.674]                       envir <- sys.frame(frame)
[13:20:46.674]                       master <- NULL
[13:20:46.674]                       while (!identical(envir, .GlobalEnv) && 
[13:20:46.674]                         !identical(envir, emptyenv())) {
[13:20:46.674]                         if (exists("master", mode = "list", envir = envir, 
[13:20:46.674]                           inherits = FALSE)) {
[13:20:46.674]                           master <- get("master", mode = "list", 
[13:20:46.674]                             envir = envir, inherits = FALSE)
[13:20:46.674]                           if (inherits(master, c("SOCKnode", 
[13:20:46.674]                             "SOCK0node"))) {
[13:20:46.674]                             sendCondition <<- function(cond) {
[13:20:46.674]                               data <- list(type = "VALUE", value = cond, 
[13:20:46.674]                                 success = TRUE)
[13:20:46.674]                               parallel_sendData(master, data)
[13:20:46.674]                             }
[13:20:46.674]                             return(sendCondition)
[13:20:46.674]                           }
[13:20:46.674]                         }
[13:20:46.674]                         frame <- frame + 1L
[13:20:46.674]                         envir <- sys.frame(frame)
[13:20:46.674]                       }
[13:20:46.674]                     }
[13:20:46.674]                     sendCondition <<- function(cond) NULL
[13:20:46.674]                   }
[13:20:46.674]                 })
[13:20:46.674]                 withCallingHandlers({
[13:20:46.674]                   {
[13:20:46.674]                     x <- list(b = 2)
[13:20:46.674]                     x$a <- 1
[13:20:46.674]                     x
[13:20:46.674]                   }
[13:20:46.674]                 }, immediateCondition = function(cond) {
[13:20:46.674]                   sendCondition <- ...future.makeSendCondition()
[13:20:46.674]                   sendCondition(cond)
[13:20:46.674]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.674]                   {
[13:20:46.674]                     inherits <- base::inherits
[13:20:46.674]                     invokeRestart <- base::invokeRestart
[13:20:46.674]                     is.null <- base::is.null
[13:20:46.674]                     muffled <- FALSE
[13:20:46.674]                     if (inherits(cond, "message")) {
[13:20:46.674]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:46.674]                       if (muffled) 
[13:20:46.674]                         invokeRestart("muffleMessage")
[13:20:46.674]                     }
[13:20:46.674]                     else if (inherits(cond, "warning")) {
[13:20:46.674]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:46.674]                       if (muffled) 
[13:20:46.674]                         invokeRestart("muffleWarning")
[13:20:46.674]                     }
[13:20:46.674]                     else if (inherits(cond, "condition")) {
[13:20:46.674]                       if (!is.null(pattern)) {
[13:20:46.674]                         computeRestarts <- base::computeRestarts
[13:20:46.674]                         grepl <- base::grepl
[13:20:46.674]                         restarts <- computeRestarts(cond)
[13:20:46.674]                         for (restart in restarts) {
[13:20:46.674]                           name <- restart$name
[13:20:46.674]                           if (is.null(name)) 
[13:20:46.674]                             next
[13:20:46.674]                           if (!grepl(pattern, name)) 
[13:20:46.674]                             next
[13:20:46.674]                           invokeRestart(restart)
[13:20:46.674]                           muffled <- TRUE
[13:20:46.674]                           break
[13:20:46.674]                         }
[13:20:46.674]                       }
[13:20:46.674]                     }
[13:20:46.674]                     invisible(muffled)
[13:20:46.674]                   }
[13:20:46.674]                   muffleCondition(cond)
[13:20:46.674]                 })
[13:20:46.674]             }))
[13:20:46.674]             future::FutureResult(value = ...future.value$value, 
[13:20:46.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.674]                   ...future.rng), globalenv = if (FALSE) 
[13:20:46.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:46.674]                     ...future.globalenv.names))
[13:20:46.674]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:46.674]         }, condition = base::local({
[13:20:46.674]             c <- base::c
[13:20:46.674]             inherits <- base::inherits
[13:20:46.674]             invokeRestart <- base::invokeRestart
[13:20:46.674]             length <- base::length
[13:20:46.674]             list <- base::list
[13:20:46.674]             seq.int <- base::seq.int
[13:20:46.674]             signalCondition <- base::signalCondition
[13:20:46.674]             sys.calls <- base::sys.calls
[13:20:46.674]             `[[` <- base::`[[`
[13:20:46.674]             `+` <- base::`+`
[13:20:46.674]             `<<-` <- base::`<<-`
[13:20:46.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:46.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:46.674]                   3L)]
[13:20:46.674]             }
[13:20:46.674]             function(cond) {
[13:20:46.674]                 is_error <- inherits(cond, "error")
[13:20:46.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:46.674]                   NULL)
[13:20:46.674]                 if (is_error) {
[13:20:46.674]                   sessionInformation <- function() {
[13:20:46.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:46.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:46.674]                       search = base::search(), system = base::Sys.info())
[13:20:46.674]                   }
[13:20:46.674]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:46.674]                     cond$call), session = sessionInformation(), 
[13:20:46.674]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:46.674]                   signalCondition(cond)
[13:20:46.674]                 }
[13:20:46.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:46.674]                 "immediateCondition"))) {
[13:20:46.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:46.674]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:46.674]                   if (TRUE && !signal) {
[13:20:46.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.674]                     {
[13:20:46.674]                       inherits <- base::inherits
[13:20:46.674]                       invokeRestart <- base::invokeRestart
[13:20:46.674]                       is.null <- base::is.null
[13:20:46.674]                       muffled <- FALSE
[13:20:46.674]                       if (inherits(cond, "message")) {
[13:20:46.674]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.674]                         if (muffled) 
[13:20:46.674]                           invokeRestart("muffleMessage")
[13:20:46.674]                       }
[13:20:46.674]                       else if (inherits(cond, "warning")) {
[13:20:46.674]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.674]                         if (muffled) 
[13:20:46.674]                           invokeRestart("muffleWarning")
[13:20:46.674]                       }
[13:20:46.674]                       else if (inherits(cond, "condition")) {
[13:20:46.674]                         if (!is.null(pattern)) {
[13:20:46.674]                           computeRestarts <- base::computeRestarts
[13:20:46.674]                           grepl <- base::grepl
[13:20:46.674]                           restarts <- computeRestarts(cond)
[13:20:46.674]                           for (restart in restarts) {
[13:20:46.674]                             name <- restart$name
[13:20:46.674]                             if (is.null(name)) 
[13:20:46.674]                               next
[13:20:46.674]                             if (!grepl(pattern, name)) 
[13:20:46.674]                               next
[13:20:46.674]                             invokeRestart(restart)
[13:20:46.674]                             muffled <- TRUE
[13:20:46.674]                             break
[13:20:46.674]                           }
[13:20:46.674]                         }
[13:20:46.674]                       }
[13:20:46.674]                       invisible(muffled)
[13:20:46.674]                     }
[13:20:46.674]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.674]                   }
[13:20:46.674]                 }
[13:20:46.674]                 else {
[13:20:46.674]                   if (TRUE) {
[13:20:46.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.674]                     {
[13:20:46.674]                       inherits <- base::inherits
[13:20:46.674]                       invokeRestart <- base::invokeRestart
[13:20:46.674]                       is.null <- base::is.null
[13:20:46.674]                       muffled <- FALSE
[13:20:46.674]                       if (inherits(cond, "message")) {
[13:20:46.674]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.674]                         if (muffled) 
[13:20:46.674]                           invokeRestart("muffleMessage")
[13:20:46.674]                       }
[13:20:46.674]                       else if (inherits(cond, "warning")) {
[13:20:46.674]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.674]                         if (muffled) 
[13:20:46.674]                           invokeRestart("muffleWarning")
[13:20:46.674]                       }
[13:20:46.674]                       else if (inherits(cond, "condition")) {
[13:20:46.674]                         if (!is.null(pattern)) {
[13:20:46.674]                           computeRestarts <- base::computeRestarts
[13:20:46.674]                           grepl <- base::grepl
[13:20:46.674]                           restarts <- computeRestarts(cond)
[13:20:46.674]                           for (restart in restarts) {
[13:20:46.674]                             name <- restart$name
[13:20:46.674]                             if (is.null(name)) 
[13:20:46.674]                               next
[13:20:46.674]                             if (!grepl(pattern, name)) 
[13:20:46.674]                               next
[13:20:46.674]                             invokeRestart(restart)
[13:20:46.674]                             muffled <- TRUE
[13:20:46.674]                             break
[13:20:46.674]                           }
[13:20:46.674]                         }
[13:20:46.674]                       }
[13:20:46.674]                       invisible(muffled)
[13:20:46.674]                     }
[13:20:46.674]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.674]                   }
[13:20:46.674]                 }
[13:20:46.674]             }
[13:20:46.674]         }))
[13:20:46.674]     }, error = function(ex) {
[13:20:46.674]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:46.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.674]                 ...future.rng), started = ...future.startTime, 
[13:20:46.674]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:46.674]             version = "1.8"), class = "FutureResult")
[13:20:46.674]     }, finally = {
[13:20:46.674]         if (!identical(...future.workdir, getwd())) 
[13:20:46.674]             setwd(...future.workdir)
[13:20:46.674]         {
[13:20:46.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:46.674]                 ...future.oldOptions$nwarnings <- NULL
[13:20:46.674]             }
[13:20:46.674]             base::options(...future.oldOptions)
[13:20:46.674]             if (.Platform$OS.type == "windows") {
[13:20:46.674]                 old_names <- names(...future.oldEnvVars)
[13:20:46.674]                 envs <- base::Sys.getenv()
[13:20:46.674]                 names <- names(envs)
[13:20:46.674]                 common <- intersect(names, old_names)
[13:20:46.674]                 added <- setdiff(names, old_names)
[13:20:46.674]                 removed <- setdiff(old_names, names)
[13:20:46.674]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:46.674]                   envs[common]]
[13:20:46.674]                 NAMES <- toupper(changed)
[13:20:46.674]                 args <- list()
[13:20:46.674]                 for (kk in seq_along(NAMES)) {
[13:20:46.674]                   name <- changed[[kk]]
[13:20:46.674]                   NAME <- NAMES[[kk]]
[13:20:46.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.674]                     next
[13:20:46.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.674]                 }
[13:20:46.674]                 NAMES <- toupper(added)
[13:20:46.674]                 for (kk in seq_along(NAMES)) {
[13:20:46.674]                   name <- added[[kk]]
[13:20:46.674]                   NAME <- NAMES[[kk]]
[13:20:46.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.674]                     next
[13:20:46.674]                   args[[name]] <- ""
[13:20:46.674]                 }
[13:20:46.674]                 NAMES <- toupper(removed)
[13:20:46.674]                 for (kk in seq_along(NAMES)) {
[13:20:46.674]                   name <- removed[[kk]]
[13:20:46.674]                   NAME <- NAMES[[kk]]
[13:20:46.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.674]                     next
[13:20:46.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.674]                 }
[13:20:46.674]                 if (length(args) > 0) 
[13:20:46.674]                   base::do.call(base::Sys.setenv, args = args)
[13:20:46.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:46.674]             }
[13:20:46.674]             else {
[13:20:46.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:46.674]             }
[13:20:46.674]             {
[13:20:46.674]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:46.674]                   0L) {
[13:20:46.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:46.674]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:46.674]                   base::options(opts)
[13:20:46.674]                 }
[13:20:46.674]                 {
[13:20:46.674]                   {
[13:20:46.674]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:46.674]                     NULL
[13:20:46.674]                   }
[13:20:46.674]                   options(future.plan = NULL)
[13:20:46.674]                   if (is.na(NA_character_)) 
[13:20:46.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:46.674]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:46.674]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:46.674]                     envir = parent.frame()) 
[13:20:46.674]                   {
[13:20:46.674]                     if (is.function(workers)) 
[13:20:46.674]                       workers <- workers()
[13:20:46.674]                     workers <- structure(as.integer(workers), 
[13:20:46.674]                       class = class(workers))
[13:20:46.674]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:46.674]                       workers >= 1)
[13:20:46.674]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:46.674]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:46.674]                     }
[13:20:46.674]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:46.674]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:46.674]                       envir = envir)
[13:20:46.674]                     if (!future$lazy) 
[13:20:46.674]                       future <- run(future)
[13:20:46.674]                     invisible(future)
[13:20:46.674]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:46.674]                 }
[13:20:46.674]             }
[13:20:46.674]         }
[13:20:46.674]     })
[13:20:46.674]     if (TRUE) {
[13:20:46.674]         base::sink(type = "output", split = FALSE)
[13:20:46.674]         if (TRUE) {
[13:20:46.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:46.674]         }
[13:20:46.674]         else {
[13:20:46.674]             ...future.result["stdout"] <- base::list(NULL)
[13:20:46.674]         }
[13:20:46.674]         base::close(...future.stdout)
[13:20:46.674]         ...future.stdout <- NULL
[13:20:46.674]     }
[13:20:46.674]     ...future.result$conditions <- ...future.conditions
[13:20:46.674]     ...future.result$finished <- base::Sys.time()
[13:20:46.674]     ...future.result
[13:20:46.674] }
[13:20:46.678] MultisessionFuture started
[13:20:46.678] - Launch lazy future ... done
[13:20:46.678] run() for ‘MultisessionFuture’ ... done
[13:20:46.678] result() for ClusterFuture ...
[13:20:46.678] receiveMessageFromWorker() for ClusterFuture ...
[13:20:46.678] - Validating connection of MultisessionFuture
[13:20:46.726] - received message: FutureResult
[13:20:46.726] - Received FutureResult
[13:20:46.726] - Erased future from FutureRegistry
[13:20:46.726] result() for ClusterFuture ...
[13:20:46.726] - result already collected: FutureResult
[13:20:46.726] result() for ClusterFuture ... done
[13:20:46.726] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:46.726] result() for ClusterFuture ... done
[13:20:46.727] result() for ClusterFuture ...
[13:20:46.727] - result already collected: FutureResult
[13:20:46.727] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:46.727] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:46.727] Searching for globals...
[13:20:46.729] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:46.729] Searching for globals ... DONE
[13:20:46.730] Resolving globals: TRUE
[13:20:46.730] Resolving any globals that are futures ...
[13:20:46.730] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:46.730] Resolving any globals that are futures ... DONE
[13:20:46.730] Resolving futures part of globals (recursively) ...
[13:20:46.731] resolve() on list ...
[13:20:46.731]  recursive: 99
[13:20:46.731]  length: 1
[13:20:46.731]  elements: ‘x’
[13:20:46.731]  length: 0 (resolved future 1)
[13:20:46.731] resolve() on list ... DONE
[13:20:46.731] - globals: [1] ‘x’
[13:20:46.731] Resolving futures part of globals (recursively) ... DONE
[13:20:46.731] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:46.732] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:46.732] - globals: [1] ‘x’
[13:20:46.732] 
[13:20:46.732] getGlobalsAndPackages() ... DONE
[13:20:46.732] run() for ‘Future’ ...
[13:20:46.732] - state: ‘created’
[13:20:46.733] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:46.747] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:46.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:46.747]   - Field: ‘node’
[13:20:46.747]   - Field: ‘label’
[13:20:46.747]   - Field: ‘local’
[13:20:46.747]   - Field: ‘owner’
[13:20:46.748]   - Field: ‘envir’
[13:20:46.748]   - Field: ‘workers’
[13:20:46.748]   - Field: ‘packages’
[13:20:46.748]   - Field: ‘gc’
[13:20:46.748]   - Field: ‘conditions’
[13:20:46.748]   - Field: ‘persistent’
[13:20:46.748]   - Field: ‘expr’
[13:20:46.748]   - Field: ‘uuid’
[13:20:46.748]   - Field: ‘seed’
[13:20:46.748]   - Field: ‘version’
[13:20:46.748]   - Field: ‘result’
[13:20:46.749]   - Field: ‘asynchronous’
[13:20:46.749]   - Field: ‘calls’
[13:20:46.749]   - Field: ‘globals’
[13:20:46.749]   - Field: ‘stdout’
[13:20:46.749]   - Field: ‘earlySignal’
[13:20:46.749]   - Field: ‘lazy’
[13:20:46.749]   - Field: ‘state’
[13:20:46.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:46.749] - Launch lazy future ...
[13:20:46.750] Packages needed by the future expression (n = 0): <none>
[13:20:46.750] Packages needed by future strategies (n = 0): <none>
[13:20:46.750] {
[13:20:46.750]     {
[13:20:46.750]         {
[13:20:46.750]             ...future.startTime <- base::Sys.time()
[13:20:46.750]             {
[13:20:46.750]                 {
[13:20:46.750]                   {
[13:20:46.750]                     {
[13:20:46.750]                       base::local({
[13:20:46.750]                         has_future <- base::requireNamespace("future", 
[13:20:46.750]                           quietly = TRUE)
[13:20:46.750]                         if (has_future) {
[13:20:46.750]                           ns <- base::getNamespace("future")
[13:20:46.750]                           version <- ns[[".package"]][["version"]]
[13:20:46.750]                           if (is.null(version)) 
[13:20:46.750]                             version <- utils::packageVersion("future")
[13:20:46.750]                         }
[13:20:46.750]                         else {
[13:20:46.750]                           version <- NULL
[13:20:46.750]                         }
[13:20:46.750]                         if (!has_future || version < "1.8.0") {
[13:20:46.750]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:46.750]                             "", base::R.version$version.string), 
[13:20:46.750]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:46.750]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:46.750]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:46.750]                               "release", "version")], collapse = " "), 
[13:20:46.750]                             hostname = base::Sys.info()[["nodename"]])
[13:20:46.750]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:46.750]                             info)
[13:20:46.750]                           info <- base::paste(info, collapse = "; ")
[13:20:46.750]                           if (!has_future) {
[13:20:46.750]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:46.750]                               info)
[13:20:46.750]                           }
[13:20:46.750]                           else {
[13:20:46.750]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:46.750]                               info, version)
[13:20:46.750]                           }
[13:20:46.750]                           base::stop(msg)
[13:20:46.750]                         }
[13:20:46.750]                       })
[13:20:46.750]                     }
[13:20:46.750]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:46.750]                     base::options(mc.cores = 1L)
[13:20:46.750]                   }
[13:20:46.750]                   options(future.plan = NULL)
[13:20:46.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:46.750]                 }
[13:20:46.750]                 ...future.workdir <- getwd()
[13:20:46.750]             }
[13:20:46.750]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:46.750]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:46.750]         }
[13:20:46.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:46.750]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:46.750]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:46.750]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:46.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:46.750]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:46.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:46.750]             base::names(...future.oldOptions))
[13:20:46.750]     }
[13:20:46.750]     if (FALSE) {
[13:20:46.750]     }
[13:20:46.750]     else {
[13:20:46.750]         if (TRUE) {
[13:20:46.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:46.750]                 open = "w")
[13:20:46.750]         }
[13:20:46.750]         else {
[13:20:46.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:46.750]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:46.750]         }
[13:20:46.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:46.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:46.750]             base::sink(type = "output", split = FALSE)
[13:20:46.750]             base::close(...future.stdout)
[13:20:46.750]         }, add = TRUE)
[13:20:46.750]     }
[13:20:46.750]     ...future.frame <- base::sys.nframe()
[13:20:46.750]     ...future.conditions <- base::list()
[13:20:46.750]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:46.750]     if (FALSE) {
[13:20:46.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:46.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:46.750]     }
[13:20:46.750]     ...future.result <- base::tryCatch({
[13:20:46.750]         base::withCallingHandlers({
[13:20:46.750]             ...future.value <- base::withVisible(base::local({
[13:20:46.750]                 ...future.makeSendCondition <- local({
[13:20:46.750]                   sendCondition <- NULL
[13:20:46.750]                   function(frame = 1L) {
[13:20:46.750]                     if (is.function(sendCondition)) 
[13:20:46.750]                       return(sendCondition)
[13:20:46.750]                     ns <- getNamespace("parallel")
[13:20:46.750]                     if (exists("sendData", mode = "function", 
[13:20:46.750]                       envir = ns)) {
[13:20:46.750]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:46.750]                         envir = ns)
[13:20:46.750]                       envir <- sys.frame(frame)
[13:20:46.750]                       master <- NULL
[13:20:46.750]                       while (!identical(envir, .GlobalEnv) && 
[13:20:46.750]                         !identical(envir, emptyenv())) {
[13:20:46.750]                         if (exists("master", mode = "list", envir = envir, 
[13:20:46.750]                           inherits = FALSE)) {
[13:20:46.750]                           master <- get("master", mode = "list", 
[13:20:46.750]                             envir = envir, inherits = FALSE)
[13:20:46.750]                           if (inherits(master, c("SOCKnode", 
[13:20:46.750]                             "SOCK0node"))) {
[13:20:46.750]                             sendCondition <<- function(cond) {
[13:20:46.750]                               data <- list(type = "VALUE", value = cond, 
[13:20:46.750]                                 success = TRUE)
[13:20:46.750]                               parallel_sendData(master, data)
[13:20:46.750]                             }
[13:20:46.750]                             return(sendCondition)
[13:20:46.750]                           }
[13:20:46.750]                         }
[13:20:46.750]                         frame <- frame + 1L
[13:20:46.750]                         envir <- sys.frame(frame)
[13:20:46.750]                       }
[13:20:46.750]                     }
[13:20:46.750]                     sendCondition <<- function(cond) NULL
[13:20:46.750]                   }
[13:20:46.750]                 })
[13:20:46.750]                 withCallingHandlers({
[13:20:46.750]                   {
[13:20:46.750]                     x[["a"]] <- 1
[13:20:46.750]                     x
[13:20:46.750]                   }
[13:20:46.750]                 }, immediateCondition = function(cond) {
[13:20:46.750]                   sendCondition <- ...future.makeSendCondition()
[13:20:46.750]                   sendCondition(cond)
[13:20:46.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.750]                   {
[13:20:46.750]                     inherits <- base::inherits
[13:20:46.750]                     invokeRestart <- base::invokeRestart
[13:20:46.750]                     is.null <- base::is.null
[13:20:46.750]                     muffled <- FALSE
[13:20:46.750]                     if (inherits(cond, "message")) {
[13:20:46.750]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:46.750]                       if (muffled) 
[13:20:46.750]                         invokeRestart("muffleMessage")
[13:20:46.750]                     }
[13:20:46.750]                     else if (inherits(cond, "warning")) {
[13:20:46.750]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:46.750]                       if (muffled) 
[13:20:46.750]                         invokeRestart("muffleWarning")
[13:20:46.750]                     }
[13:20:46.750]                     else if (inherits(cond, "condition")) {
[13:20:46.750]                       if (!is.null(pattern)) {
[13:20:46.750]                         computeRestarts <- base::computeRestarts
[13:20:46.750]                         grepl <- base::grepl
[13:20:46.750]                         restarts <- computeRestarts(cond)
[13:20:46.750]                         for (restart in restarts) {
[13:20:46.750]                           name <- restart$name
[13:20:46.750]                           if (is.null(name)) 
[13:20:46.750]                             next
[13:20:46.750]                           if (!grepl(pattern, name)) 
[13:20:46.750]                             next
[13:20:46.750]                           invokeRestart(restart)
[13:20:46.750]                           muffled <- TRUE
[13:20:46.750]                           break
[13:20:46.750]                         }
[13:20:46.750]                       }
[13:20:46.750]                     }
[13:20:46.750]                     invisible(muffled)
[13:20:46.750]                   }
[13:20:46.750]                   muffleCondition(cond)
[13:20:46.750]                 })
[13:20:46.750]             }))
[13:20:46.750]             future::FutureResult(value = ...future.value$value, 
[13:20:46.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.750]                   ...future.rng), globalenv = if (FALSE) 
[13:20:46.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:46.750]                     ...future.globalenv.names))
[13:20:46.750]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:46.750]         }, condition = base::local({
[13:20:46.750]             c <- base::c
[13:20:46.750]             inherits <- base::inherits
[13:20:46.750]             invokeRestart <- base::invokeRestart
[13:20:46.750]             length <- base::length
[13:20:46.750]             list <- base::list
[13:20:46.750]             seq.int <- base::seq.int
[13:20:46.750]             signalCondition <- base::signalCondition
[13:20:46.750]             sys.calls <- base::sys.calls
[13:20:46.750]             `[[` <- base::`[[`
[13:20:46.750]             `+` <- base::`+`
[13:20:46.750]             `<<-` <- base::`<<-`
[13:20:46.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:46.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:46.750]                   3L)]
[13:20:46.750]             }
[13:20:46.750]             function(cond) {
[13:20:46.750]                 is_error <- inherits(cond, "error")
[13:20:46.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:46.750]                   NULL)
[13:20:46.750]                 if (is_error) {
[13:20:46.750]                   sessionInformation <- function() {
[13:20:46.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:46.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:46.750]                       search = base::search(), system = base::Sys.info())
[13:20:46.750]                   }
[13:20:46.750]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:46.750]                     cond$call), session = sessionInformation(), 
[13:20:46.750]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:46.750]                   signalCondition(cond)
[13:20:46.750]                 }
[13:20:46.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:46.750]                 "immediateCondition"))) {
[13:20:46.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:46.750]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:46.750]                   if (TRUE && !signal) {
[13:20:46.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.750]                     {
[13:20:46.750]                       inherits <- base::inherits
[13:20:46.750]                       invokeRestart <- base::invokeRestart
[13:20:46.750]                       is.null <- base::is.null
[13:20:46.750]                       muffled <- FALSE
[13:20:46.750]                       if (inherits(cond, "message")) {
[13:20:46.750]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.750]                         if (muffled) 
[13:20:46.750]                           invokeRestart("muffleMessage")
[13:20:46.750]                       }
[13:20:46.750]                       else if (inherits(cond, "warning")) {
[13:20:46.750]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.750]                         if (muffled) 
[13:20:46.750]                           invokeRestart("muffleWarning")
[13:20:46.750]                       }
[13:20:46.750]                       else if (inherits(cond, "condition")) {
[13:20:46.750]                         if (!is.null(pattern)) {
[13:20:46.750]                           computeRestarts <- base::computeRestarts
[13:20:46.750]                           grepl <- base::grepl
[13:20:46.750]                           restarts <- computeRestarts(cond)
[13:20:46.750]                           for (restart in restarts) {
[13:20:46.750]                             name <- restart$name
[13:20:46.750]                             if (is.null(name)) 
[13:20:46.750]                               next
[13:20:46.750]                             if (!grepl(pattern, name)) 
[13:20:46.750]                               next
[13:20:46.750]                             invokeRestart(restart)
[13:20:46.750]                             muffled <- TRUE
[13:20:46.750]                             break
[13:20:46.750]                           }
[13:20:46.750]                         }
[13:20:46.750]                       }
[13:20:46.750]                       invisible(muffled)
[13:20:46.750]                     }
[13:20:46.750]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.750]                   }
[13:20:46.750]                 }
[13:20:46.750]                 else {
[13:20:46.750]                   if (TRUE) {
[13:20:46.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.750]                     {
[13:20:46.750]                       inherits <- base::inherits
[13:20:46.750]                       invokeRestart <- base::invokeRestart
[13:20:46.750]                       is.null <- base::is.null
[13:20:46.750]                       muffled <- FALSE
[13:20:46.750]                       if (inherits(cond, "message")) {
[13:20:46.750]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.750]                         if (muffled) 
[13:20:46.750]                           invokeRestart("muffleMessage")
[13:20:46.750]                       }
[13:20:46.750]                       else if (inherits(cond, "warning")) {
[13:20:46.750]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.750]                         if (muffled) 
[13:20:46.750]                           invokeRestart("muffleWarning")
[13:20:46.750]                       }
[13:20:46.750]                       else if (inherits(cond, "condition")) {
[13:20:46.750]                         if (!is.null(pattern)) {
[13:20:46.750]                           computeRestarts <- base::computeRestarts
[13:20:46.750]                           grepl <- base::grepl
[13:20:46.750]                           restarts <- computeRestarts(cond)
[13:20:46.750]                           for (restart in restarts) {
[13:20:46.750]                             name <- restart$name
[13:20:46.750]                             if (is.null(name)) 
[13:20:46.750]                               next
[13:20:46.750]                             if (!grepl(pattern, name)) 
[13:20:46.750]                               next
[13:20:46.750]                             invokeRestart(restart)
[13:20:46.750]                             muffled <- TRUE
[13:20:46.750]                             break
[13:20:46.750]                           }
[13:20:46.750]                         }
[13:20:46.750]                       }
[13:20:46.750]                       invisible(muffled)
[13:20:46.750]                     }
[13:20:46.750]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.750]                   }
[13:20:46.750]                 }
[13:20:46.750]             }
[13:20:46.750]         }))
[13:20:46.750]     }, error = function(ex) {
[13:20:46.750]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:46.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.750]                 ...future.rng), started = ...future.startTime, 
[13:20:46.750]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:46.750]             version = "1.8"), class = "FutureResult")
[13:20:46.750]     }, finally = {
[13:20:46.750]         if (!identical(...future.workdir, getwd())) 
[13:20:46.750]             setwd(...future.workdir)
[13:20:46.750]         {
[13:20:46.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:46.750]                 ...future.oldOptions$nwarnings <- NULL
[13:20:46.750]             }
[13:20:46.750]             base::options(...future.oldOptions)
[13:20:46.750]             if (.Platform$OS.type == "windows") {
[13:20:46.750]                 old_names <- names(...future.oldEnvVars)
[13:20:46.750]                 envs <- base::Sys.getenv()
[13:20:46.750]                 names <- names(envs)
[13:20:46.750]                 common <- intersect(names, old_names)
[13:20:46.750]                 added <- setdiff(names, old_names)
[13:20:46.750]                 removed <- setdiff(old_names, names)
[13:20:46.750]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:46.750]                   envs[common]]
[13:20:46.750]                 NAMES <- toupper(changed)
[13:20:46.750]                 args <- list()
[13:20:46.750]                 for (kk in seq_along(NAMES)) {
[13:20:46.750]                   name <- changed[[kk]]
[13:20:46.750]                   NAME <- NAMES[[kk]]
[13:20:46.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.750]                     next
[13:20:46.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.750]                 }
[13:20:46.750]                 NAMES <- toupper(added)
[13:20:46.750]                 for (kk in seq_along(NAMES)) {
[13:20:46.750]                   name <- added[[kk]]
[13:20:46.750]                   NAME <- NAMES[[kk]]
[13:20:46.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.750]                     next
[13:20:46.750]                   args[[name]] <- ""
[13:20:46.750]                 }
[13:20:46.750]                 NAMES <- toupper(removed)
[13:20:46.750]                 for (kk in seq_along(NAMES)) {
[13:20:46.750]                   name <- removed[[kk]]
[13:20:46.750]                   NAME <- NAMES[[kk]]
[13:20:46.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.750]                     next
[13:20:46.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.750]                 }
[13:20:46.750]                 if (length(args) > 0) 
[13:20:46.750]                   base::do.call(base::Sys.setenv, args = args)
[13:20:46.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:46.750]             }
[13:20:46.750]             else {
[13:20:46.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:46.750]             }
[13:20:46.750]             {
[13:20:46.750]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:46.750]                   0L) {
[13:20:46.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:46.750]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:46.750]                   base::options(opts)
[13:20:46.750]                 }
[13:20:46.750]                 {
[13:20:46.750]                   {
[13:20:46.750]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:46.750]                     NULL
[13:20:46.750]                   }
[13:20:46.750]                   options(future.plan = NULL)
[13:20:46.750]                   if (is.na(NA_character_)) 
[13:20:46.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:46.750]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:46.750]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:46.750]                     envir = parent.frame()) 
[13:20:46.750]                   {
[13:20:46.750]                     if (is.function(workers)) 
[13:20:46.750]                       workers <- workers()
[13:20:46.750]                     workers <- structure(as.integer(workers), 
[13:20:46.750]                       class = class(workers))
[13:20:46.750]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:46.750]                       workers >= 1)
[13:20:46.750]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:46.750]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:46.750]                     }
[13:20:46.750]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:46.750]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:46.750]                       envir = envir)
[13:20:46.750]                     if (!future$lazy) 
[13:20:46.750]                       future <- run(future)
[13:20:46.750]                     invisible(future)
[13:20:46.750]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:46.750]                 }
[13:20:46.750]             }
[13:20:46.750]         }
[13:20:46.750]     })
[13:20:46.750]     if (TRUE) {
[13:20:46.750]         base::sink(type = "output", split = FALSE)
[13:20:46.750]         if (TRUE) {
[13:20:46.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:46.750]         }
[13:20:46.750]         else {
[13:20:46.750]             ...future.result["stdout"] <- base::list(NULL)
[13:20:46.750]         }
[13:20:46.750]         base::close(...future.stdout)
[13:20:46.750]         ...future.stdout <- NULL
[13:20:46.750]     }
[13:20:46.750]     ...future.result$conditions <- ...future.conditions
[13:20:46.750]     ...future.result$finished <- base::Sys.time()
[13:20:46.750]     ...future.result
[13:20:46.750] }
[13:20:46.753] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:20:46.753] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:20:46.753] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:20:46.753] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:20:46.754] MultisessionFuture started
[13:20:46.754] - Launch lazy future ... done
[13:20:46.754] run() for ‘MultisessionFuture’ ... done
[13:20:46.754] result() for ClusterFuture ...
[13:20:46.754] receiveMessageFromWorker() for ClusterFuture ...
[13:20:46.755] - Validating connection of MultisessionFuture
[13:20:46.802] - received message: FutureResult
[13:20:46.802] - Received FutureResult
[13:20:46.802] - Erased future from FutureRegistry
[13:20:46.802] result() for ClusterFuture ...
[13:20:46.802] - result already collected: FutureResult
[13:20:46.802] result() for ClusterFuture ... done
[13:20:46.802] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:46.803] result() for ClusterFuture ... done
[13:20:46.803] result() for ClusterFuture ...
[13:20:46.803] - result already collected: FutureResult
[13:20:46.803] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:46.803] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:46.803] Searching for globals...
[13:20:46.805] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:46.806] Searching for globals ... DONE
[13:20:46.806] Resolving globals: TRUE
[13:20:46.806] Resolving any globals that are futures ...
[13:20:46.806] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:46.806] Resolving any globals that are futures ... DONE
[13:20:46.806] Resolving futures part of globals (recursively) ...
[13:20:46.807] resolve() on list ...
[13:20:46.807]  recursive: 99
[13:20:46.807]  length: 1
[13:20:46.807]  elements: ‘x’
[13:20:46.807]  length: 0 (resolved future 1)
[13:20:46.807] resolve() on list ... DONE
[13:20:46.807] - globals: [1] ‘x’
[13:20:46.807] Resolving futures part of globals (recursively) ... DONE
[13:20:46.807] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:46.808] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:46.808] - globals: [1] ‘x’
[13:20:46.808] 
[13:20:46.808] getGlobalsAndPackages() ... DONE
[13:20:46.808] run() for ‘Future’ ...
[13:20:46.808] - state: ‘created’
[13:20:46.809] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:46.823] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:46.823] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:46.823]   - Field: ‘node’
[13:20:46.823]   - Field: ‘label’
[13:20:46.823]   - Field: ‘local’
[13:20:46.823]   - Field: ‘owner’
[13:20:46.824]   - Field: ‘envir’
[13:20:46.824]   - Field: ‘workers’
[13:20:46.824]   - Field: ‘packages’
[13:20:46.824]   - Field: ‘gc’
[13:20:46.824]   - Field: ‘conditions’
[13:20:46.824]   - Field: ‘persistent’
[13:20:46.824]   - Field: ‘expr’
[13:20:46.824]   - Field: ‘uuid’
[13:20:46.824]   - Field: ‘seed’
[13:20:46.824]   - Field: ‘version’
[13:20:46.825]   - Field: ‘result’
[13:20:46.825]   - Field: ‘asynchronous’
[13:20:46.825]   - Field: ‘calls’
[13:20:46.825]   - Field: ‘globals’
[13:20:46.825]   - Field: ‘stdout’
[13:20:46.825]   - Field: ‘earlySignal’
[13:20:46.825]   - Field: ‘lazy’
[13:20:46.825]   - Field: ‘state’
[13:20:46.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:46.825] - Launch lazy future ...
[13:20:46.826] Packages needed by the future expression (n = 0): <none>
[13:20:46.826] Packages needed by future strategies (n = 0): <none>
[13:20:46.826] {
[13:20:46.826]     {
[13:20:46.826]         {
[13:20:46.826]             ...future.startTime <- base::Sys.time()
[13:20:46.826]             {
[13:20:46.826]                 {
[13:20:46.826]                   {
[13:20:46.826]                     {
[13:20:46.826]                       base::local({
[13:20:46.826]                         has_future <- base::requireNamespace("future", 
[13:20:46.826]                           quietly = TRUE)
[13:20:46.826]                         if (has_future) {
[13:20:46.826]                           ns <- base::getNamespace("future")
[13:20:46.826]                           version <- ns[[".package"]][["version"]]
[13:20:46.826]                           if (is.null(version)) 
[13:20:46.826]                             version <- utils::packageVersion("future")
[13:20:46.826]                         }
[13:20:46.826]                         else {
[13:20:46.826]                           version <- NULL
[13:20:46.826]                         }
[13:20:46.826]                         if (!has_future || version < "1.8.0") {
[13:20:46.826]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:46.826]                             "", base::R.version$version.string), 
[13:20:46.826]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:46.826]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:46.826]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:46.826]                               "release", "version")], collapse = " "), 
[13:20:46.826]                             hostname = base::Sys.info()[["nodename"]])
[13:20:46.826]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:46.826]                             info)
[13:20:46.826]                           info <- base::paste(info, collapse = "; ")
[13:20:46.826]                           if (!has_future) {
[13:20:46.826]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:46.826]                               info)
[13:20:46.826]                           }
[13:20:46.826]                           else {
[13:20:46.826]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:46.826]                               info, version)
[13:20:46.826]                           }
[13:20:46.826]                           base::stop(msg)
[13:20:46.826]                         }
[13:20:46.826]                       })
[13:20:46.826]                     }
[13:20:46.826]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:46.826]                     base::options(mc.cores = 1L)
[13:20:46.826]                   }
[13:20:46.826]                   options(future.plan = NULL)
[13:20:46.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:46.826]                 }
[13:20:46.826]                 ...future.workdir <- getwd()
[13:20:46.826]             }
[13:20:46.826]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:46.826]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:46.826]         }
[13:20:46.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:46.826]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:46.826]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:46.826]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:46.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:46.826]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:46.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:46.826]             base::names(...future.oldOptions))
[13:20:46.826]     }
[13:20:46.826]     if (FALSE) {
[13:20:46.826]     }
[13:20:46.826]     else {
[13:20:46.826]         if (TRUE) {
[13:20:46.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:46.826]                 open = "w")
[13:20:46.826]         }
[13:20:46.826]         else {
[13:20:46.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:46.826]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:46.826]         }
[13:20:46.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:46.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:46.826]             base::sink(type = "output", split = FALSE)
[13:20:46.826]             base::close(...future.stdout)
[13:20:46.826]         }, add = TRUE)
[13:20:46.826]     }
[13:20:46.826]     ...future.frame <- base::sys.nframe()
[13:20:46.826]     ...future.conditions <- base::list()
[13:20:46.826]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:46.826]     if (FALSE) {
[13:20:46.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:46.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:46.826]     }
[13:20:46.826]     ...future.result <- base::tryCatch({
[13:20:46.826]         base::withCallingHandlers({
[13:20:46.826]             ...future.value <- base::withVisible(base::local({
[13:20:46.826]                 ...future.makeSendCondition <- local({
[13:20:46.826]                   sendCondition <- NULL
[13:20:46.826]                   function(frame = 1L) {
[13:20:46.826]                     if (is.function(sendCondition)) 
[13:20:46.826]                       return(sendCondition)
[13:20:46.826]                     ns <- getNamespace("parallel")
[13:20:46.826]                     if (exists("sendData", mode = "function", 
[13:20:46.826]                       envir = ns)) {
[13:20:46.826]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:46.826]                         envir = ns)
[13:20:46.826]                       envir <- sys.frame(frame)
[13:20:46.826]                       master <- NULL
[13:20:46.826]                       while (!identical(envir, .GlobalEnv) && 
[13:20:46.826]                         !identical(envir, emptyenv())) {
[13:20:46.826]                         if (exists("master", mode = "list", envir = envir, 
[13:20:46.826]                           inherits = FALSE)) {
[13:20:46.826]                           master <- get("master", mode = "list", 
[13:20:46.826]                             envir = envir, inherits = FALSE)
[13:20:46.826]                           if (inherits(master, c("SOCKnode", 
[13:20:46.826]                             "SOCK0node"))) {
[13:20:46.826]                             sendCondition <<- function(cond) {
[13:20:46.826]                               data <- list(type = "VALUE", value = cond, 
[13:20:46.826]                                 success = TRUE)
[13:20:46.826]                               parallel_sendData(master, data)
[13:20:46.826]                             }
[13:20:46.826]                             return(sendCondition)
[13:20:46.826]                           }
[13:20:46.826]                         }
[13:20:46.826]                         frame <- frame + 1L
[13:20:46.826]                         envir <- sys.frame(frame)
[13:20:46.826]                       }
[13:20:46.826]                     }
[13:20:46.826]                     sendCondition <<- function(cond) NULL
[13:20:46.826]                   }
[13:20:46.826]                 })
[13:20:46.826]                 withCallingHandlers({
[13:20:46.826]                   {
[13:20:46.826]                     x[["a"]] <- 1
[13:20:46.826]                     x
[13:20:46.826]                   }
[13:20:46.826]                 }, immediateCondition = function(cond) {
[13:20:46.826]                   sendCondition <- ...future.makeSendCondition()
[13:20:46.826]                   sendCondition(cond)
[13:20:46.826]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.826]                   {
[13:20:46.826]                     inherits <- base::inherits
[13:20:46.826]                     invokeRestart <- base::invokeRestart
[13:20:46.826]                     is.null <- base::is.null
[13:20:46.826]                     muffled <- FALSE
[13:20:46.826]                     if (inherits(cond, "message")) {
[13:20:46.826]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:46.826]                       if (muffled) 
[13:20:46.826]                         invokeRestart("muffleMessage")
[13:20:46.826]                     }
[13:20:46.826]                     else if (inherits(cond, "warning")) {
[13:20:46.826]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:46.826]                       if (muffled) 
[13:20:46.826]                         invokeRestart("muffleWarning")
[13:20:46.826]                     }
[13:20:46.826]                     else if (inherits(cond, "condition")) {
[13:20:46.826]                       if (!is.null(pattern)) {
[13:20:46.826]                         computeRestarts <- base::computeRestarts
[13:20:46.826]                         grepl <- base::grepl
[13:20:46.826]                         restarts <- computeRestarts(cond)
[13:20:46.826]                         for (restart in restarts) {
[13:20:46.826]                           name <- restart$name
[13:20:46.826]                           if (is.null(name)) 
[13:20:46.826]                             next
[13:20:46.826]                           if (!grepl(pattern, name)) 
[13:20:46.826]                             next
[13:20:46.826]                           invokeRestart(restart)
[13:20:46.826]                           muffled <- TRUE
[13:20:46.826]                           break
[13:20:46.826]                         }
[13:20:46.826]                       }
[13:20:46.826]                     }
[13:20:46.826]                     invisible(muffled)
[13:20:46.826]                   }
[13:20:46.826]                   muffleCondition(cond)
[13:20:46.826]                 })
[13:20:46.826]             }))
[13:20:46.826]             future::FutureResult(value = ...future.value$value, 
[13:20:46.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.826]                   ...future.rng), globalenv = if (FALSE) 
[13:20:46.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:46.826]                     ...future.globalenv.names))
[13:20:46.826]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:46.826]         }, condition = base::local({
[13:20:46.826]             c <- base::c
[13:20:46.826]             inherits <- base::inherits
[13:20:46.826]             invokeRestart <- base::invokeRestart
[13:20:46.826]             length <- base::length
[13:20:46.826]             list <- base::list
[13:20:46.826]             seq.int <- base::seq.int
[13:20:46.826]             signalCondition <- base::signalCondition
[13:20:46.826]             sys.calls <- base::sys.calls
[13:20:46.826]             `[[` <- base::`[[`
[13:20:46.826]             `+` <- base::`+`
[13:20:46.826]             `<<-` <- base::`<<-`
[13:20:46.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:46.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:46.826]                   3L)]
[13:20:46.826]             }
[13:20:46.826]             function(cond) {
[13:20:46.826]                 is_error <- inherits(cond, "error")
[13:20:46.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:46.826]                   NULL)
[13:20:46.826]                 if (is_error) {
[13:20:46.826]                   sessionInformation <- function() {
[13:20:46.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:46.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:46.826]                       search = base::search(), system = base::Sys.info())
[13:20:46.826]                   }
[13:20:46.826]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:46.826]                     cond$call), session = sessionInformation(), 
[13:20:46.826]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:46.826]                   signalCondition(cond)
[13:20:46.826]                 }
[13:20:46.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:46.826]                 "immediateCondition"))) {
[13:20:46.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:46.826]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:46.826]                   if (TRUE && !signal) {
[13:20:46.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.826]                     {
[13:20:46.826]                       inherits <- base::inherits
[13:20:46.826]                       invokeRestart <- base::invokeRestart
[13:20:46.826]                       is.null <- base::is.null
[13:20:46.826]                       muffled <- FALSE
[13:20:46.826]                       if (inherits(cond, "message")) {
[13:20:46.826]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.826]                         if (muffled) 
[13:20:46.826]                           invokeRestart("muffleMessage")
[13:20:46.826]                       }
[13:20:46.826]                       else if (inherits(cond, "warning")) {
[13:20:46.826]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.826]                         if (muffled) 
[13:20:46.826]                           invokeRestart("muffleWarning")
[13:20:46.826]                       }
[13:20:46.826]                       else if (inherits(cond, "condition")) {
[13:20:46.826]                         if (!is.null(pattern)) {
[13:20:46.826]                           computeRestarts <- base::computeRestarts
[13:20:46.826]                           grepl <- base::grepl
[13:20:46.826]                           restarts <- computeRestarts(cond)
[13:20:46.826]                           for (restart in restarts) {
[13:20:46.826]                             name <- restart$name
[13:20:46.826]                             if (is.null(name)) 
[13:20:46.826]                               next
[13:20:46.826]                             if (!grepl(pattern, name)) 
[13:20:46.826]                               next
[13:20:46.826]                             invokeRestart(restart)
[13:20:46.826]                             muffled <- TRUE
[13:20:46.826]                             break
[13:20:46.826]                           }
[13:20:46.826]                         }
[13:20:46.826]                       }
[13:20:46.826]                       invisible(muffled)
[13:20:46.826]                     }
[13:20:46.826]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.826]                   }
[13:20:46.826]                 }
[13:20:46.826]                 else {
[13:20:46.826]                   if (TRUE) {
[13:20:46.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.826]                     {
[13:20:46.826]                       inherits <- base::inherits
[13:20:46.826]                       invokeRestart <- base::invokeRestart
[13:20:46.826]                       is.null <- base::is.null
[13:20:46.826]                       muffled <- FALSE
[13:20:46.826]                       if (inherits(cond, "message")) {
[13:20:46.826]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.826]                         if (muffled) 
[13:20:46.826]                           invokeRestart("muffleMessage")
[13:20:46.826]                       }
[13:20:46.826]                       else if (inherits(cond, "warning")) {
[13:20:46.826]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.826]                         if (muffled) 
[13:20:46.826]                           invokeRestart("muffleWarning")
[13:20:46.826]                       }
[13:20:46.826]                       else if (inherits(cond, "condition")) {
[13:20:46.826]                         if (!is.null(pattern)) {
[13:20:46.826]                           computeRestarts <- base::computeRestarts
[13:20:46.826]                           grepl <- base::grepl
[13:20:46.826]                           restarts <- computeRestarts(cond)
[13:20:46.826]                           for (restart in restarts) {
[13:20:46.826]                             name <- restart$name
[13:20:46.826]                             if (is.null(name)) 
[13:20:46.826]                               next
[13:20:46.826]                             if (!grepl(pattern, name)) 
[13:20:46.826]                               next
[13:20:46.826]                             invokeRestart(restart)
[13:20:46.826]                             muffled <- TRUE
[13:20:46.826]                             break
[13:20:46.826]                           }
[13:20:46.826]                         }
[13:20:46.826]                       }
[13:20:46.826]                       invisible(muffled)
[13:20:46.826]                     }
[13:20:46.826]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.826]                   }
[13:20:46.826]                 }
[13:20:46.826]             }
[13:20:46.826]         }))
[13:20:46.826]     }, error = function(ex) {
[13:20:46.826]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:46.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.826]                 ...future.rng), started = ...future.startTime, 
[13:20:46.826]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:46.826]             version = "1.8"), class = "FutureResult")
[13:20:46.826]     }, finally = {
[13:20:46.826]         if (!identical(...future.workdir, getwd())) 
[13:20:46.826]             setwd(...future.workdir)
[13:20:46.826]         {
[13:20:46.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:46.826]                 ...future.oldOptions$nwarnings <- NULL
[13:20:46.826]             }
[13:20:46.826]             base::options(...future.oldOptions)
[13:20:46.826]             if (.Platform$OS.type == "windows") {
[13:20:46.826]                 old_names <- names(...future.oldEnvVars)
[13:20:46.826]                 envs <- base::Sys.getenv()
[13:20:46.826]                 names <- names(envs)
[13:20:46.826]                 common <- intersect(names, old_names)
[13:20:46.826]                 added <- setdiff(names, old_names)
[13:20:46.826]                 removed <- setdiff(old_names, names)
[13:20:46.826]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:46.826]                   envs[common]]
[13:20:46.826]                 NAMES <- toupper(changed)
[13:20:46.826]                 args <- list()
[13:20:46.826]                 for (kk in seq_along(NAMES)) {
[13:20:46.826]                   name <- changed[[kk]]
[13:20:46.826]                   NAME <- NAMES[[kk]]
[13:20:46.826]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.826]                     next
[13:20:46.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.826]                 }
[13:20:46.826]                 NAMES <- toupper(added)
[13:20:46.826]                 for (kk in seq_along(NAMES)) {
[13:20:46.826]                   name <- added[[kk]]
[13:20:46.826]                   NAME <- NAMES[[kk]]
[13:20:46.826]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.826]                     next
[13:20:46.826]                   args[[name]] <- ""
[13:20:46.826]                 }
[13:20:46.826]                 NAMES <- toupper(removed)
[13:20:46.826]                 for (kk in seq_along(NAMES)) {
[13:20:46.826]                   name <- removed[[kk]]
[13:20:46.826]                   NAME <- NAMES[[kk]]
[13:20:46.826]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.826]                     next
[13:20:46.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.826]                 }
[13:20:46.826]                 if (length(args) > 0) 
[13:20:46.826]                   base::do.call(base::Sys.setenv, args = args)
[13:20:46.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:46.826]             }
[13:20:46.826]             else {
[13:20:46.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:46.826]             }
[13:20:46.826]             {
[13:20:46.826]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:46.826]                   0L) {
[13:20:46.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:46.826]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:46.826]                   base::options(opts)
[13:20:46.826]                 }
[13:20:46.826]                 {
[13:20:46.826]                   {
[13:20:46.826]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:46.826]                     NULL
[13:20:46.826]                   }
[13:20:46.826]                   options(future.plan = NULL)
[13:20:46.826]                   if (is.na(NA_character_)) 
[13:20:46.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:46.826]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:46.826]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:46.826]                     envir = parent.frame()) 
[13:20:46.826]                   {
[13:20:46.826]                     if (is.function(workers)) 
[13:20:46.826]                       workers <- workers()
[13:20:46.826]                     workers <- structure(as.integer(workers), 
[13:20:46.826]                       class = class(workers))
[13:20:46.826]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:46.826]                       workers >= 1)
[13:20:46.826]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:46.826]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:46.826]                     }
[13:20:46.826]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:46.826]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:46.826]                       envir = envir)
[13:20:46.826]                     if (!future$lazy) 
[13:20:46.826]                       future <- run(future)
[13:20:46.826]                     invisible(future)
[13:20:46.826]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:46.826]                 }
[13:20:46.826]             }
[13:20:46.826]         }
[13:20:46.826]     })
[13:20:46.826]     if (TRUE) {
[13:20:46.826]         base::sink(type = "output", split = FALSE)
[13:20:46.826]         if (TRUE) {
[13:20:46.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:46.826]         }
[13:20:46.826]         else {
[13:20:46.826]             ...future.result["stdout"] <- base::list(NULL)
[13:20:46.826]         }
[13:20:46.826]         base::close(...future.stdout)
[13:20:46.826]         ...future.stdout <- NULL
[13:20:46.826]     }
[13:20:46.826]     ...future.result$conditions <- ...future.conditions
[13:20:46.826]     ...future.result$finished <- base::Sys.time()
[13:20:46.826]     ...future.result
[13:20:46.826] }
[13:20:46.829] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:20:46.829] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:20:46.830] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:20:46.830] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:20:46.830] MultisessionFuture started
[13:20:46.830] - Launch lazy future ... done
[13:20:46.830] run() for ‘MultisessionFuture’ ... done
[13:20:46.830] result() for ClusterFuture ...
[13:20:46.831] receiveMessageFromWorker() for ClusterFuture ...
[13:20:46.831] - Validating connection of MultisessionFuture
[13:20:46.878] - received message: FutureResult
[13:20:46.878] - Received FutureResult
[13:20:46.878] - Erased future from FutureRegistry
[13:20:46.878] result() for ClusterFuture ...
[13:20:46.878] - result already collected: FutureResult
[13:20:46.878] result() for ClusterFuture ... done
[13:20:46.879] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:46.879] result() for ClusterFuture ... done
[13:20:46.879] result() for ClusterFuture ...
[13:20:46.879] - result already collected: FutureResult
[13:20:46.879] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:46.879] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:46.880] Searching for globals...
[13:20:46.882] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:46.882] Searching for globals ... DONE
[13:20:46.882] Resolving globals: TRUE
[13:20:46.882] Resolving any globals that are futures ...
[13:20:46.883] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[13:20:46.883] Resolving any globals that are futures ... DONE
[13:20:46.883] Resolving futures part of globals (recursively) ...
[13:20:46.883] resolve() on list ...
[13:20:46.884]  recursive: 99
[13:20:46.886]  length: 1
[13:20:46.886]  elements: ‘x’
[13:20:46.886]  length: 0 (resolved future 1)
[13:20:46.886] resolve() on list ... DONE
[13:20:46.886] - globals: [1] ‘x’
[13:20:46.886] Resolving futures part of globals (recursively) ... DONE
[13:20:46.886] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:46.887] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:46.887] - globals: [1] ‘x’
[13:20:46.887] 
[13:20:46.887] getGlobalsAndPackages() ... DONE
[13:20:46.887] run() for ‘Future’ ...
[13:20:46.887] - state: ‘created’
[13:20:46.888] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:46.902] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:46.903] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:46.903]   - Field: ‘node’
[13:20:46.903]   - Field: ‘label’
[13:20:46.903]   - Field: ‘local’
[13:20:46.903]   - Field: ‘owner’
[13:20:46.903]   - Field: ‘envir’
[13:20:46.903]   - Field: ‘workers’
[13:20:46.903]   - Field: ‘packages’
[13:20:46.903]   - Field: ‘gc’
[13:20:46.903]   - Field: ‘conditions’
[13:20:46.904]   - Field: ‘persistent’
[13:20:46.904]   - Field: ‘expr’
[13:20:46.904]   - Field: ‘uuid’
[13:20:46.904]   - Field: ‘seed’
[13:20:46.904]   - Field: ‘version’
[13:20:46.904]   - Field: ‘result’
[13:20:46.904]   - Field: ‘asynchronous’
[13:20:46.904]   - Field: ‘calls’
[13:20:46.904]   - Field: ‘globals’
[13:20:46.904]   - Field: ‘stdout’
[13:20:46.904]   - Field: ‘earlySignal’
[13:20:46.905]   - Field: ‘lazy’
[13:20:46.905]   - Field: ‘state’
[13:20:46.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:46.905] - Launch lazy future ...
[13:20:46.905] Packages needed by the future expression (n = 0): <none>
[13:20:46.905] Packages needed by future strategies (n = 0): <none>
[13:20:46.906] {
[13:20:46.906]     {
[13:20:46.906]         {
[13:20:46.906]             ...future.startTime <- base::Sys.time()
[13:20:46.906]             {
[13:20:46.906]                 {
[13:20:46.906]                   {
[13:20:46.906]                     {
[13:20:46.906]                       base::local({
[13:20:46.906]                         has_future <- base::requireNamespace("future", 
[13:20:46.906]                           quietly = TRUE)
[13:20:46.906]                         if (has_future) {
[13:20:46.906]                           ns <- base::getNamespace("future")
[13:20:46.906]                           version <- ns[[".package"]][["version"]]
[13:20:46.906]                           if (is.null(version)) 
[13:20:46.906]                             version <- utils::packageVersion("future")
[13:20:46.906]                         }
[13:20:46.906]                         else {
[13:20:46.906]                           version <- NULL
[13:20:46.906]                         }
[13:20:46.906]                         if (!has_future || version < "1.8.0") {
[13:20:46.906]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:46.906]                             "", base::R.version$version.string), 
[13:20:46.906]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:46.906]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:46.906]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:46.906]                               "release", "version")], collapse = " "), 
[13:20:46.906]                             hostname = base::Sys.info()[["nodename"]])
[13:20:46.906]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:46.906]                             info)
[13:20:46.906]                           info <- base::paste(info, collapse = "; ")
[13:20:46.906]                           if (!has_future) {
[13:20:46.906]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:46.906]                               info)
[13:20:46.906]                           }
[13:20:46.906]                           else {
[13:20:46.906]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:46.906]                               info, version)
[13:20:46.906]                           }
[13:20:46.906]                           base::stop(msg)
[13:20:46.906]                         }
[13:20:46.906]                       })
[13:20:46.906]                     }
[13:20:46.906]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:46.906]                     base::options(mc.cores = 1L)
[13:20:46.906]                   }
[13:20:46.906]                   options(future.plan = NULL)
[13:20:46.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:46.906]                 }
[13:20:46.906]                 ...future.workdir <- getwd()
[13:20:46.906]             }
[13:20:46.906]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:46.906]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:46.906]         }
[13:20:46.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:46.906]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:46.906]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:46.906]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:46.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:46.906]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:46.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:46.906]             base::names(...future.oldOptions))
[13:20:46.906]     }
[13:20:46.906]     if (FALSE) {
[13:20:46.906]     }
[13:20:46.906]     else {
[13:20:46.906]         if (TRUE) {
[13:20:46.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:46.906]                 open = "w")
[13:20:46.906]         }
[13:20:46.906]         else {
[13:20:46.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:46.906]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:46.906]         }
[13:20:46.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:46.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:46.906]             base::sink(type = "output", split = FALSE)
[13:20:46.906]             base::close(...future.stdout)
[13:20:46.906]         }, add = TRUE)
[13:20:46.906]     }
[13:20:46.906]     ...future.frame <- base::sys.nframe()
[13:20:46.906]     ...future.conditions <- base::list()
[13:20:46.906]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:46.906]     if (FALSE) {
[13:20:46.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:46.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:46.906]     }
[13:20:46.906]     ...future.result <- base::tryCatch({
[13:20:46.906]         base::withCallingHandlers({
[13:20:46.906]             ...future.value <- base::withVisible(base::local({
[13:20:46.906]                 ...future.makeSendCondition <- local({
[13:20:46.906]                   sendCondition <- NULL
[13:20:46.906]                   function(frame = 1L) {
[13:20:46.906]                     if (is.function(sendCondition)) 
[13:20:46.906]                       return(sendCondition)
[13:20:46.906]                     ns <- getNamespace("parallel")
[13:20:46.906]                     if (exists("sendData", mode = "function", 
[13:20:46.906]                       envir = ns)) {
[13:20:46.906]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:46.906]                         envir = ns)
[13:20:46.906]                       envir <- sys.frame(frame)
[13:20:46.906]                       master <- NULL
[13:20:46.906]                       while (!identical(envir, .GlobalEnv) && 
[13:20:46.906]                         !identical(envir, emptyenv())) {
[13:20:46.906]                         if (exists("master", mode = "list", envir = envir, 
[13:20:46.906]                           inherits = FALSE)) {
[13:20:46.906]                           master <- get("master", mode = "list", 
[13:20:46.906]                             envir = envir, inherits = FALSE)
[13:20:46.906]                           if (inherits(master, c("SOCKnode", 
[13:20:46.906]                             "SOCK0node"))) {
[13:20:46.906]                             sendCondition <<- function(cond) {
[13:20:46.906]                               data <- list(type = "VALUE", value = cond, 
[13:20:46.906]                                 success = TRUE)
[13:20:46.906]                               parallel_sendData(master, data)
[13:20:46.906]                             }
[13:20:46.906]                             return(sendCondition)
[13:20:46.906]                           }
[13:20:46.906]                         }
[13:20:46.906]                         frame <- frame + 1L
[13:20:46.906]                         envir <- sys.frame(frame)
[13:20:46.906]                       }
[13:20:46.906]                     }
[13:20:46.906]                     sendCondition <<- function(cond) NULL
[13:20:46.906]                   }
[13:20:46.906]                 })
[13:20:46.906]                 withCallingHandlers({
[13:20:46.906]                   {
[13:20:46.906]                     x[["a"]] <- 1
[13:20:46.906]                     x
[13:20:46.906]                   }
[13:20:46.906]                 }, immediateCondition = function(cond) {
[13:20:46.906]                   sendCondition <- ...future.makeSendCondition()
[13:20:46.906]                   sendCondition(cond)
[13:20:46.906]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.906]                   {
[13:20:46.906]                     inherits <- base::inherits
[13:20:46.906]                     invokeRestart <- base::invokeRestart
[13:20:46.906]                     is.null <- base::is.null
[13:20:46.906]                     muffled <- FALSE
[13:20:46.906]                     if (inherits(cond, "message")) {
[13:20:46.906]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:46.906]                       if (muffled) 
[13:20:46.906]                         invokeRestart("muffleMessage")
[13:20:46.906]                     }
[13:20:46.906]                     else if (inherits(cond, "warning")) {
[13:20:46.906]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:46.906]                       if (muffled) 
[13:20:46.906]                         invokeRestart("muffleWarning")
[13:20:46.906]                     }
[13:20:46.906]                     else if (inherits(cond, "condition")) {
[13:20:46.906]                       if (!is.null(pattern)) {
[13:20:46.906]                         computeRestarts <- base::computeRestarts
[13:20:46.906]                         grepl <- base::grepl
[13:20:46.906]                         restarts <- computeRestarts(cond)
[13:20:46.906]                         for (restart in restarts) {
[13:20:46.906]                           name <- restart$name
[13:20:46.906]                           if (is.null(name)) 
[13:20:46.906]                             next
[13:20:46.906]                           if (!grepl(pattern, name)) 
[13:20:46.906]                             next
[13:20:46.906]                           invokeRestart(restart)
[13:20:46.906]                           muffled <- TRUE
[13:20:46.906]                           break
[13:20:46.906]                         }
[13:20:46.906]                       }
[13:20:46.906]                     }
[13:20:46.906]                     invisible(muffled)
[13:20:46.906]                   }
[13:20:46.906]                   muffleCondition(cond)
[13:20:46.906]                 })
[13:20:46.906]             }))
[13:20:46.906]             future::FutureResult(value = ...future.value$value, 
[13:20:46.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.906]                   ...future.rng), globalenv = if (FALSE) 
[13:20:46.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:46.906]                     ...future.globalenv.names))
[13:20:46.906]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:46.906]         }, condition = base::local({
[13:20:46.906]             c <- base::c
[13:20:46.906]             inherits <- base::inherits
[13:20:46.906]             invokeRestart <- base::invokeRestart
[13:20:46.906]             length <- base::length
[13:20:46.906]             list <- base::list
[13:20:46.906]             seq.int <- base::seq.int
[13:20:46.906]             signalCondition <- base::signalCondition
[13:20:46.906]             sys.calls <- base::sys.calls
[13:20:46.906]             `[[` <- base::`[[`
[13:20:46.906]             `+` <- base::`+`
[13:20:46.906]             `<<-` <- base::`<<-`
[13:20:46.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:46.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:46.906]                   3L)]
[13:20:46.906]             }
[13:20:46.906]             function(cond) {
[13:20:46.906]                 is_error <- inherits(cond, "error")
[13:20:46.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:46.906]                   NULL)
[13:20:46.906]                 if (is_error) {
[13:20:46.906]                   sessionInformation <- function() {
[13:20:46.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:46.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:46.906]                       search = base::search(), system = base::Sys.info())
[13:20:46.906]                   }
[13:20:46.906]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:46.906]                     cond$call), session = sessionInformation(), 
[13:20:46.906]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:46.906]                   signalCondition(cond)
[13:20:46.906]                 }
[13:20:46.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:46.906]                 "immediateCondition"))) {
[13:20:46.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:46.906]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:46.906]                   if (TRUE && !signal) {
[13:20:46.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.906]                     {
[13:20:46.906]                       inherits <- base::inherits
[13:20:46.906]                       invokeRestart <- base::invokeRestart
[13:20:46.906]                       is.null <- base::is.null
[13:20:46.906]                       muffled <- FALSE
[13:20:46.906]                       if (inherits(cond, "message")) {
[13:20:46.906]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.906]                         if (muffled) 
[13:20:46.906]                           invokeRestart("muffleMessage")
[13:20:46.906]                       }
[13:20:46.906]                       else if (inherits(cond, "warning")) {
[13:20:46.906]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.906]                         if (muffled) 
[13:20:46.906]                           invokeRestart("muffleWarning")
[13:20:46.906]                       }
[13:20:46.906]                       else if (inherits(cond, "condition")) {
[13:20:46.906]                         if (!is.null(pattern)) {
[13:20:46.906]                           computeRestarts <- base::computeRestarts
[13:20:46.906]                           grepl <- base::grepl
[13:20:46.906]                           restarts <- computeRestarts(cond)
[13:20:46.906]                           for (restart in restarts) {
[13:20:46.906]                             name <- restart$name
[13:20:46.906]                             if (is.null(name)) 
[13:20:46.906]                               next
[13:20:46.906]                             if (!grepl(pattern, name)) 
[13:20:46.906]                               next
[13:20:46.906]                             invokeRestart(restart)
[13:20:46.906]                             muffled <- TRUE
[13:20:46.906]                             break
[13:20:46.906]                           }
[13:20:46.906]                         }
[13:20:46.906]                       }
[13:20:46.906]                       invisible(muffled)
[13:20:46.906]                     }
[13:20:46.906]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.906]                   }
[13:20:46.906]                 }
[13:20:46.906]                 else {
[13:20:46.906]                   if (TRUE) {
[13:20:46.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.906]                     {
[13:20:46.906]                       inherits <- base::inherits
[13:20:46.906]                       invokeRestart <- base::invokeRestart
[13:20:46.906]                       is.null <- base::is.null
[13:20:46.906]                       muffled <- FALSE
[13:20:46.906]                       if (inherits(cond, "message")) {
[13:20:46.906]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.906]                         if (muffled) 
[13:20:46.906]                           invokeRestart("muffleMessage")
[13:20:46.906]                       }
[13:20:46.906]                       else if (inherits(cond, "warning")) {
[13:20:46.906]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.906]                         if (muffled) 
[13:20:46.906]                           invokeRestart("muffleWarning")
[13:20:46.906]                       }
[13:20:46.906]                       else if (inherits(cond, "condition")) {
[13:20:46.906]                         if (!is.null(pattern)) {
[13:20:46.906]                           computeRestarts <- base::computeRestarts
[13:20:46.906]                           grepl <- base::grepl
[13:20:46.906]                           restarts <- computeRestarts(cond)
[13:20:46.906]                           for (restart in restarts) {
[13:20:46.906]                             name <- restart$name
[13:20:46.906]                             if (is.null(name)) 
[13:20:46.906]                               next
[13:20:46.906]                             if (!grepl(pattern, name)) 
[13:20:46.906]                               next
[13:20:46.906]                             invokeRestart(restart)
[13:20:46.906]                             muffled <- TRUE
[13:20:46.906]                             break
[13:20:46.906]                           }
[13:20:46.906]                         }
[13:20:46.906]                       }
[13:20:46.906]                       invisible(muffled)
[13:20:46.906]                     }
[13:20:46.906]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.906]                   }
[13:20:46.906]                 }
[13:20:46.906]             }
[13:20:46.906]         }))
[13:20:46.906]     }, error = function(ex) {
[13:20:46.906]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:46.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.906]                 ...future.rng), started = ...future.startTime, 
[13:20:46.906]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:46.906]             version = "1.8"), class = "FutureResult")
[13:20:46.906]     }, finally = {
[13:20:46.906]         if (!identical(...future.workdir, getwd())) 
[13:20:46.906]             setwd(...future.workdir)
[13:20:46.906]         {
[13:20:46.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:46.906]                 ...future.oldOptions$nwarnings <- NULL
[13:20:46.906]             }
[13:20:46.906]             base::options(...future.oldOptions)
[13:20:46.906]             if (.Platform$OS.type == "windows") {
[13:20:46.906]                 old_names <- names(...future.oldEnvVars)
[13:20:46.906]                 envs <- base::Sys.getenv()
[13:20:46.906]                 names <- names(envs)
[13:20:46.906]                 common <- intersect(names, old_names)
[13:20:46.906]                 added <- setdiff(names, old_names)
[13:20:46.906]                 removed <- setdiff(old_names, names)
[13:20:46.906]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:46.906]                   envs[common]]
[13:20:46.906]                 NAMES <- toupper(changed)
[13:20:46.906]                 args <- list()
[13:20:46.906]                 for (kk in seq_along(NAMES)) {
[13:20:46.906]                   name <- changed[[kk]]
[13:20:46.906]                   NAME <- NAMES[[kk]]
[13:20:46.906]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.906]                     next
[13:20:46.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.906]                 }
[13:20:46.906]                 NAMES <- toupper(added)
[13:20:46.906]                 for (kk in seq_along(NAMES)) {
[13:20:46.906]                   name <- added[[kk]]
[13:20:46.906]                   NAME <- NAMES[[kk]]
[13:20:46.906]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.906]                     next
[13:20:46.906]                   args[[name]] <- ""
[13:20:46.906]                 }
[13:20:46.906]                 NAMES <- toupper(removed)
[13:20:46.906]                 for (kk in seq_along(NAMES)) {
[13:20:46.906]                   name <- removed[[kk]]
[13:20:46.906]                   NAME <- NAMES[[kk]]
[13:20:46.906]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.906]                     next
[13:20:46.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.906]                 }
[13:20:46.906]                 if (length(args) > 0) 
[13:20:46.906]                   base::do.call(base::Sys.setenv, args = args)
[13:20:46.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:46.906]             }
[13:20:46.906]             else {
[13:20:46.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:46.906]             }
[13:20:46.906]             {
[13:20:46.906]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:46.906]                   0L) {
[13:20:46.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:46.906]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:46.906]                   base::options(opts)
[13:20:46.906]                 }
[13:20:46.906]                 {
[13:20:46.906]                   {
[13:20:46.906]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:46.906]                     NULL
[13:20:46.906]                   }
[13:20:46.906]                   options(future.plan = NULL)
[13:20:46.906]                   if (is.na(NA_character_)) 
[13:20:46.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:46.906]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:46.906]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:46.906]                     envir = parent.frame()) 
[13:20:46.906]                   {
[13:20:46.906]                     if (is.function(workers)) 
[13:20:46.906]                       workers <- workers()
[13:20:46.906]                     workers <- structure(as.integer(workers), 
[13:20:46.906]                       class = class(workers))
[13:20:46.906]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:46.906]                       workers >= 1)
[13:20:46.906]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:46.906]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:46.906]                     }
[13:20:46.906]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:46.906]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:46.906]                       envir = envir)
[13:20:46.906]                     if (!future$lazy) 
[13:20:46.906]                       future <- run(future)
[13:20:46.906]                     invisible(future)
[13:20:46.906]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:46.906]                 }
[13:20:46.906]             }
[13:20:46.906]         }
[13:20:46.906]     })
[13:20:46.906]     if (TRUE) {
[13:20:46.906]         base::sink(type = "output", split = FALSE)
[13:20:46.906]         if (TRUE) {
[13:20:46.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:46.906]         }
[13:20:46.906]         else {
[13:20:46.906]             ...future.result["stdout"] <- base::list(NULL)
[13:20:46.906]         }
[13:20:46.906]         base::close(...future.stdout)
[13:20:46.906]         ...future.stdout <- NULL
[13:20:46.906]     }
[13:20:46.906]     ...future.result$conditions <- ...future.conditions
[13:20:46.906]     ...future.result$finished <- base::Sys.time()
[13:20:46.906]     ...future.result
[13:20:46.906] }
[13:20:46.908] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:20:46.908] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:20:46.909] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:20:46.909] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:20:46.909] MultisessionFuture started
[13:20:46.910] - Launch lazy future ... done
[13:20:46.910] run() for ‘MultisessionFuture’ ... done
[13:20:46.910] result() for ClusterFuture ...
[13:20:46.910] receiveMessageFromWorker() for ClusterFuture ...
[13:20:46.910] - Validating connection of MultisessionFuture
[13:20:46.958] - received message: FutureResult
[13:20:46.958] - Received FutureResult
[13:20:46.958] - Erased future from FutureRegistry
[13:20:46.958] result() for ClusterFuture ...
[13:20:46.958] - result already collected: FutureResult
[13:20:46.958] result() for ClusterFuture ... done
[13:20:46.958] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:46.959] result() for ClusterFuture ... done
[13:20:46.959] result() for ClusterFuture ...
[13:20:46.959] - result already collected: FutureResult
[13:20:46.959] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:46.959] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:46.959] Searching for globals...
[13:20:46.961] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:46.962] Searching for globals ... DONE
[13:20:46.962] Resolving globals: TRUE
[13:20:46.962] Resolving any globals that are futures ...
[13:20:46.962] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:46.962] Resolving any globals that are futures ... DONE
[13:20:46.962] Resolving futures part of globals (recursively) ...
[13:20:46.963] resolve() on list ...
[13:20:46.963]  recursive: 99
[13:20:46.963]  length: 1
[13:20:46.963]  elements: ‘x’
[13:20:46.963]  length: 0 (resolved future 1)
[13:20:46.963] resolve() on list ... DONE
[13:20:46.963] - globals: [1] ‘x’
[13:20:46.963] Resolving futures part of globals (recursively) ... DONE
[13:20:46.964] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:46.964] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:46.964] - globals: [1] ‘x’
[13:20:46.964] 
[13:20:46.964] getGlobalsAndPackages() ... DONE
[13:20:46.965] run() for ‘Future’ ...
[13:20:46.965] - state: ‘created’
[13:20:46.965] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:46.979] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:46.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:46.979]   - Field: ‘node’
[13:20:46.980]   - Field: ‘label’
[13:20:46.980]   - Field: ‘local’
[13:20:46.980]   - Field: ‘owner’
[13:20:46.980]   - Field: ‘envir’
[13:20:46.980]   - Field: ‘workers’
[13:20:46.980]   - Field: ‘packages’
[13:20:46.980]   - Field: ‘gc’
[13:20:46.980]   - Field: ‘conditions’
[13:20:46.980]   - Field: ‘persistent’
[13:20:46.980]   - Field: ‘expr’
[13:20:46.981]   - Field: ‘uuid’
[13:20:46.981]   - Field: ‘seed’
[13:20:46.981]   - Field: ‘version’
[13:20:46.981]   - Field: ‘result’
[13:20:46.981]   - Field: ‘asynchronous’
[13:20:46.981]   - Field: ‘calls’
[13:20:46.981]   - Field: ‘globals’
[13:20:46.981]   - Field: ‘stdout’
[13:20:46.981]   - Field: ‘earlySignal’
[13:20:46.981]   - Field: ‘lazy’
[13:20:46.981]   - Field: ‘state’
[13:20:46.982] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:46.982] - Launch lazy future ...
[13:20:46.982] Packages needed by the future expression (n = 0): <none>
[13:20:46.982] Packages needed by future strategies (n = 0): <none>
[13:20:46.983] {
[13:20:46.983]     {
[13:20:46.983]         {
[13:20:46.983]             ...future.startTime <- base::Sys.time()
[13:20:46.983]             {
[13:20:46.983]                 {
[13:20:46.983]                   {
[13:20:46.983]                     {
[13:20:46.983]                       base::local({
[13:20:46.983]                         has_future <- base::requireNamespace("future", 
[13:20:46.983]                           quietly = TRUE)
[13:20:46.983]                         if (has_future) {
[13:20:46.983]                           ns <- base::getNamespace("future")
[13:20:46.983]                           version <- ns[[".package"]][["version"]]
[13:20:46.983]                           if (is.null(version)) 
[13:20:46.983]                             version <- utils::packageVersion("future")
[13:20:46.983]                         }
[13:20:46.983]                         else {
[13:20:46.983]                           version <- NULL
[13:20:46.983]                         }
[13:20:46.983]                         if (!has_future || version < "1.8.0") {
[13:20:46.983]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:46.983]                             "", base::R.version$version.string), 
[13:20:46.983]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:46.983]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:46.983]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:46.983]                               "release", "version")], collapse = " "), 
[13:20:46.983]                             hostname = base::Sys.info()[["nodename"]])
[13:20:46.983]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:46.983]                             info)
[13:20:46.983]                           info <- base::paste(info, collapse = "; ")
[13:20:46.983]                           if (!has_future) {
[13:20:46.983]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:46.983]                               info)
[13:20:46.983]                           }
[13:20:46.983]                           else {
[13:20:46.983]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:46.983]                               info, version)
[13:20:46.983]                           }
[13:20:46.983]                           base::stop(msg)
[13:20:46.983]                         }
[13:20:46.983]                       })
[13:20:46.983]                     }
[13:20:46.983]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:46.983]                     base::options(mc.cores = 1L)
[13:20:46.983]                   }
[13:20:46.983]                   options(future.plan = NULL)
[13:20:46.983]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.983]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:46.983]                 }
[13:20:46.983]                 ...future.workdir <- getwd()
[13:20:46.983]             }
[13:20:46.983]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:46.983]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:46.983]         }
[13:20:46.983]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:46.983]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:46.983]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:46.983]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:46.983]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:46.983]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:46.983]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:46.983]             base::names(...future.oldOptions))
[13:20:46.983]     }
[13:20:46.983]     if (FALSE) {
[13:20:46.983]     }
[13:20:46.983]     else {
[13:20:46.983]         if (TRUE) {
[13:20:46.983]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:46.983]                 open = "w")
[13:20:46.983]         }
[13:20:46.983]         else {
[13:20:46.983]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:46.983]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:46.983]         }
[13:20:46.983]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:46.983]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:46.983]             base::sink(type = "output", split = FALSE)
[13:20:46.983]             base::close(...future.stdout)
[13:20:46.983]         }, add = TRUE)
[13:20:46.983]     }
[13:20:46.983]     ...future.frame <- base::sys.nframe()
[13:20:46.983]     ...future.conditions <- base::list()
[13:20:46.983]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:46.983]     if (FALSE) {
[13:20:46.983]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:46.983]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:46.983]     }
[13:20:46.983]     ...future.result <- base::tryCatch({
[13:20:46.983]         base::withCallingHandlers({
[13:20:46.983]             ...future.value <- base::withVisible(base::local({
[13:20:46.983]                 ...future.makeSendCondition <- local({
[13:20:46.983]                   sendCondition <- NULL
[13:20:46.983]                   function(frame = 1L) {
[13:20:46.983]                     if (is.function(sendCondition)) 
[13:20:46.983]                       return(sendCondition)
[13:20:46.983]                     ns <- getNamespace("parallel")
[13:20:46.983]                     if (exists("sendData", mode = "function", 
[13:20:46.983]                       envir = ns)) {
[13:20:46.983]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:46.983]                         envir = ns)
[13:20:46.983]                       envir <- sys.frame(frame)
[13:20:46.983]                       master <- NULL
[13:20:46.983]                       while (!identical(envir, .GlobalEnv) && 
[13:20:46.983]                         !identical(envir, emptyenv())) {
[13:20:46.983]                         if (exists("master", mode = "list", envir = envir, 
[13:20:46.983]                           inherits = FALSE)) {
[13:20:46.983]                           master <- get("master", mode = "list", 
[13:20:46.983]                             envir = envir, inherits = FALSE)
[13:20:46.983]                           if (inherits(master, c("SOCKnode", 
[13:20:46.983]                             "SOCK0node"))) {
[13:20:46.983]                             sendCondition <<- function(cond) {
[13:20:46.983]                               data <- list(type = "VALUE", value = cond, 
[13:20:46.983]                                 success = TRUE)
[13:20:46.983]                               parallel_sendData(master, data)
[13:20:46.983]                             }
[13:20:46.983]                             return(sendCondition)
[13:20:46.983]                           }
[13:20:46.983]                         }
[13:20:46.983]                         frame <- frame + 1L
[13:20:46.983]                         envir <- sys.frame(frame)
[13:20:46.983]                       }
[13:20:46.983]                     }
[13:20:46.983]                     sendCondition <<- function(cond) NULL
[13:20:46.983]                   }
[13:20:46.983]                 })
[13:20:46.983]                 withCallingHandlers({
[13:20:46.983]                   {
[13:20:46.983]                     x["a"] <- list(1)
[13:20:46.983]                     x
[13:20:46.983]                   }
[13:20:46.983]                 }, immediateCondition = function(cond) {
[13:20:46.983]                   sendCondition <- ...future.makeSendCondition()
[13:20:46.983]                   sendCondition(cond)
[13:20:46.983]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.983]                   {
[13:20:46.983]                     inherits <- base::inherits
[13:20:46.983]                     invokeRestart <- base::invokeRestart
[13:20:46.983]                     is.null <- base::is.null
[13:20:46.983]                     muffled <- FALSE
[13:20:46.983]                     if (inherits(cond, "message")) {
[13:20:46.983]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:46.983]                       if (muffled) 
[13:20:46.983]                         invokeRestart("muffleMessage")
[13:20:46.983]                     }
[13:20:46.983]                     else if (inherits(cond, "warning")) {
[13:20:46.983]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:46.983]                       if (muffled) 
[13:20:46.983]                         invokeRestart("muffleWarning")
[13:20:46.983]                     }
[13:20:46.983]                     else if (inherits(cond, "condition")) {
[13:20:46.983]                       if (!is.null(pattern)) {
[13:20:46.983]                         computeRestarts <- base::computeRestarts
[13:20:46.983]                         grepl <- base::grepl
[13:20:46.983]                         restarts <- computeRestarts(cond)
[13:20:46.983]                         for (restart in restarts) {
[13:20:46.983]                           name <- restart$name
[13:20:46.983]                           if (is.null(name)) 
[13:20:46.983]                             next
[13:20:46.983]                           if (!grepl(pattern, name)) 
[13:20:46.983]                             next
[13:20:46.983]                           invokeRestart(restart)
[13:20:46.983]                           muffled <- TRUE
[13:20:46.983]                           break
[13:20:46.983]                         }
[13:20:46.983]                       }
[13:20:46.983]                     }
[13:20:46.983]                     invisible(muffled)
[13:20:46.983]                   }
[13:20:46.983]                   muffleCondition(cond)
[13:20:46.983]                 })
[13:20:46.983]             }))
[13:20:46.983]             future::FutureResult(value = ...future.value$value, 
[13:20:46.983]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.983]                   ...future.rng), globalenv = if (FALSE) 
[13:20:46.983]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:46.983]                     ...future.globalenv.names))
[13:20:46.983]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:46.983]         }, condition = base::local({
[13:20:46.983]             c <- base::c
[13:20:46.983]             inherits <- base::inherits
[13:20:46.983]             invokeRestart <- base::invokeRestart
[13:20:46.983]             length <- base::length
[13:20:46.983]             list <- base::list
[13:20:46.983]             seq.int <- base::seq.int
[13:20:46.983]             signalCondition <- base::signalCondition
[13:20:46.983]             sys.calls <- base::sys.calls
[13:20:46.983]             `[[` <- base::`[[`
[13:20:46.983]             `+` <- base::`+`
[13:20:46.983]             `<<-` <- base::`<<-`
[13:20:46.983]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:46.983]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:46.983]                   3L)]
[13:20:46.983]             }
[13:20:46.983]             function(cond) {
[13:20:46.983]                 is_error <- inherits(cond, "error")
[13:20:46.983]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:46.983]                   NULL)
[13:20:46.983]                 if (is_error) {
[13:20:46.983]                   sessionInformation <- function() {
[13:20:46.983]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:46.983]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:46.983]                       search = base::search(), system = base::Sys.info())
[13:20:46.983]                   }
[13:20:46.983]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.983]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:46.983]                     cond$call), session = sessionInformation(), 
[13:20:46.983]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:46.983]                   signalCondition(cond)
[13:20:46.983]                 }
[13:20:46.983]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:46.983]                 "immediateCondition"))) {
[13:20:46.983]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:46.983]                   ...future.conditions[[length(...future.conditions) + 
[13:20:46.983]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:46.983]                   if (TRUE && !signal) {
[13:20:46.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.983]                     {
[13:20:46.983]                       inherits <- base::inherits
[13:20:46.983]                       invokeRestart <- base::invokeRestart
[13:20:46.983]                       is.null <- base::is.null
[13:20:46.983]                       muffled <- FALSE
[13:20:46.983]                       if (inherits(cond, "message")) {
[13:20:46.983]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.983]                         if (muffled) 
[13:20:46.983]                           invokeRestart("muffleMessage")
[13:20:46.983]                       }
[13:20:46.983]                       else if (inherits(cond, "warning")) {
[13:20:46.983]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.983]                         if (muffled) 
[13:20:46.983]                           invokeRestart("muffleWarning")
[13:20:46.983]                       }
[13:20:46.983]                       else if (inherits(cond, "condition")) {
[13:20:46.983]                         if (!is.null(pattern)) {
[13:20:46.983]                           computeRestarts <- base::computeRestarts
[13:20:46.983]                           grepl <- base::grepl
[13:20:46.983]                           restarts <- computeRestarts(cond)
[13:20:46.983]                           for (restart in restarts) {
[13:20:46.983]                             name <- restart$name
[13:20:46.983]                             if (is.null(name)) 
[13:20:46.983]                               next
[13:20:46.983]                             if (!grepl(pattern, name)) 
[13:20:46.983]                               next
[13:20:46.983]                             invokeRestart(restart)
[13:20:46.983]                             muffled <- TRUE
[13:20:46.983]                             break
[13:20:46.983]                           }
[13:20:46.983]                         }
[13:20:46.983]                       }
[13:20:46.983]                       invisible(muffled)
[13:20:46.983]                     }
[13:20:46.983]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.983]                   }
[13:20:46.983]                 }
[13:20:46.983]                 else {
[13:20:46.983]                   if (TRUE) {
[13:20:46.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:46.983]                     {
[13:20:46.983]                       inherits <- base::inherits
[13:20:46.983]                       invokeRestart <- base::invokeRestart
[13:20:46.983]                       is.null <- base::is.null
[13:20:46.983]                       muffled <- FALSE
[13:20:46.983]                       if (inherits(cond, "message")) {
[13:20:46.983]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:46.983]                         if (muffled) 
[13:20:46.983]                           invokeRestart("muffleMessage")
[13:20:46.983]                       }
[13:20:46.983]                       else if (inherits(cond, "warning")) {
[13:20:46.983]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:46.983]                         if (muffled) 
[13:20:46.983]                           invokeRestart("muffleWarning")
[13:20:46.983]                       }
[13:20:46.983]                       else if (inherits(cond, "condition")) {
[13:20:46.983]                         if (!is.null(pattern)) {
[13:20:46.983]                           computeRestarts <- base::computeRestarts
[13:20:46.983]                           grepl <- base::grepl
[13:20:46.983]                           restarts <- computeRestarts(cond)
[13:20:46.983]                           for (restart in restarts) {
[13:20:46.983]                             name <- restart$name
[13:20:46.983]                             if (is.null(name)) 
[13:20:46.983]                               next
[13:20:46.983]                             if (!grepl(pattern, name)) 
[13:20:46.983]                               next
[13:20:46.983]                             invokeRestart(restart)
[13:20:46.983]                             muffled <- TRUE
[13:20:46.983]                             break
[13:20:46.983]                           }
[13:20:46.983]                         }
[13:20:46.983]                       }
[13:20:46.983]                       invisible(muffled)
[13:20:46.983]                     }
[13:20:46.983]                     muffleCondition(cond, pattern = "^muffle")
[13:20:46.983]                   }
[13:20:46.983]                 }
[13:20:46.983]             }
[13:20:46.983]         }))
[13:20:46.983]     }, error = function(ex) {
[13:20:46.983]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:46.983]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:46.983]                 ...future.rng), started = ...future.startTime, 
[13:20:46.983]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:46.983]             version = "1.8"), class = "FutureResult")
[13:20:46.983]     }, finally = {
[13:20:46.983]         if (!identical(...future.workdir, getwd())) 
[13:20:46.983]             setwd(...future.workdir)
[13:20:46.983]         {
[13:20:46.983]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:46.983]                 ...future.oldOptions$nwarnings <- NULL
[13:20:46.983]             }
[13:20:46.983]             base::options(...future.oldOptions)
[13:20:46.983]             if (.Platform$OS.type == "windows") {
[13:20:46.983]                 old_names <- names(...future.oldEnvVars)
[13:20:46.983]                 envs <- base::Sys.getenv()
[13:20:46.983]                 names <- names(envs)
[13:20:46.983]                 common <- intersect(names, old_names)
[13:20:46.983]                 added <- setdiff(names, old_names)
[13:20:46.983]                 removed <- setdiff(old_names, names)
[13:20:46.983]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:46.983]                   envs[common]]
[13:20:46.983]                 NAMES <- toupper(changed)
[13:20:46.983]                 args <- list()
[13:20:46.983]                 for (kk in seq_along(NAMES)) {
[13:20:46.983]                   name <- changed[[kk]]
[13:20:46.983]                   NAME <- NAMES[[kk]]
[13:20:46.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.983]                     next
[13:20:46.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.983]                 }
[13:20:46.983]                 NAMES <- toupper(added)
[13:20:46.983]                 for (kk in seq_along(NAMES)) {
[13:20:46.983]                   name <- added[[kk]]
[13:20:46.983]                   NAME <- NAMES[[kk]]
[13:20:46.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.983]                     next
[13:20:46.983]                   args[[name]] <- ""
[13:20:46.983]                 }
[13:20:46.983]                 NAMES <- toupper(removed)
[13:20:46.983]                 for (kk in seq_along(NAMES)) {
[13:20:46.983]                   name <- removed[[kk]]
[13:20:46.983]                   NAME <- NAMES[[kk]]
[13:20:46.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:46.983]                     next
[13:20:46.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:46.983]                 }
[13:20:46.983]                 if (length(args) > 0) 
[13:20:46.983]                   base::do.call(base::Sys.setenv, args = args)
[13:20:46.983]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:46.983]             }
[13:20:46.983]             else {
[13:20:46.983]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:46.983]             }
[13:20:46.983]             {
[13:20:46.983]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:46.983]                   0L) {
[13:20:46.983]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:46.983]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:46.983]                   base::options(opts)
[13:20:46.983]                 }
[13:20:46.983]                 {
[13:20:46.983]                   {
[13:20:46.983]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:46.983]                     NULL
[13:20:46.983]                   }
[13:20:46.983]                   options(future.plan = NULL)
[13:20:46.983]                   if (is.na(NA_character_)) 
[13:20:46.983]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:46.983]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:46.983]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:46.983]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:46.983]                     envir = parent.frame()) 
[13:20:46.983]                   {
[13:20:46.983]                     if (is.function(workers)) 
[13:20:46.983]                       workers <- workers()
[13:20:46.983]                     workers <- structure(as.integer(workers), 
[13:20:46.983]                       class = class(workers))
[13:20:46.983]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:46.983]                       workers >= 1)
[13:20:46.983]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:46.983]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:46.983]                     }
[13:20:46.983]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:46.983]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:46.983]                       envir = envir)
[13:20:46.983]                     if (!future$lazy) 
[13:20:46.983]                       future <- run(future)
[13:20:46.983]                     invisible(future)
[13:20:46.983]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:46.983]                 }
[13:20:46.983]             }
[13:20:46.983]         }
[13:20:46.983]     })
[13:20:46.983]     if (TRUE) {
[13:20:46.983]         base::sink(type = "output", split = FALSE)
[13:20:46.983]         if (TRUE) {
[13:20:46.983]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:46.983]         }
[13:20:46.983]         else {
[13:20:46.983]             ...future.result["stdout"] <- base::list(NULL)
[13:20:46.983]         }
[13:20:46.983]         base::close(...future.stdout)
[13:20:46.983]         ...future.stdout <- NULL
[13:20:46.983]     }
[13:20:46.983]     ...future.result$conditions <- ...future.conditions
[13:20:46.983]     ...future.result$finished <- base::Sys.time()
[13:20:46.983]     ...future.result
[13:20:46.983] }
[13:20:46.985] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:20:46.985] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:20:46.986] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:20:46.986] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:20:46.986] MultisessionFuture started
[13:20:46.986] - Launch lazy future ... done
[13:20:46.987] run() for ‘MultisessionFuture’ ... done
[13:20:46.987] result() for ClusterFuture ...
[13:20:46.987] receiveMessageFromWorker() for ClusterFuture ...
[13:20:46.987] - Validating connection of MultisessionFuture
[13:20:47.033] - received message: FutureResult
[13:20:47.034] - Received FutureResult
[13:20:47.034] - Erased future from FutureRegistry
[13:20:47.034] result() for ClusterFuture ...
[13:20:47.034] - result already collected: FutureResult
[13:20:47.034] result() for ClusterFuture ... done
[13:20:47.034] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:47.034] result() for ClusterFuture ... done
[13:20:47.034] result() for ClusterFuture ...
[13:20:47.034] - result already collected: FutureResult
[13:20:47.034] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:47.035] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:47.035] Searching for globals...
[13:20:47.037] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:47.037] Searching for globals ... DONE
[13:20:47.037] Resolving globals: TRUE
[13:20:47.037] Resolving any globals that are futures ...
[13:20:47.038] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:47.038] Resolving any globals that are futures ... DONE
[13:20:47.038] Resolving futures part of globals (recursively) ...
[13:20:47.038] resolve() on list ...
[13:20:47.038]  recursive: 99
[13:20:47.038]  length: 1
[13:20:47.039]  elements: ‘x’
[13:20:47.039]  length: 0 (resolved future 1)
[13:20:47.039] resolve() on list ... DONE
[13:20:47.039] - globals: [1] ‘x’
[13:20:47.039] Resolving futures part of globals (recursively) ... DONE
[13:20:47.039] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:47.039] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:47.040] - globals: [1] ‘x’
[13:20:47.040] 
[13:20:47.040] getGlobalsAndPackages() ... DONE
[13:20:47.040] run() for ‘Future’ ...
[13:20:47.040] - state: ‘created’
[13:20:47.040] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:47.054] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:47.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:47.055]   - Field: ‘node’
[13:20:47.055]   - Field: ‘label’
[13:20:47.055]   - Field: ‘local’
[13:20:47.055]   - Field: ‘owner’
[13:20:47.055]   - Field: ‘envir’
[13:20:47.055]   - Field: ‘workers’
[13:20:47.055]   - Field: ‘packages’
[13:20:47.055]   - Field: ‘gc’
[13:20:47.055]   - Field: ‘conditions’
[13:20:47.055]   - Field: ‘persistent’
[13:20:47.056]   - Field: ‘expr’
[13:20:47.056]   - Field: ‘uuid’
[13:20:47.056]   - Field: ‘seed’
[13:20:47.056]   - Field: ‘version’
[13:20:47.056]   - Field: ‘result’
[13:20:47.056]   - Field: ‘asynchronous’
[13:20:47.056]   - Field: ‘calls’
[13:20:47.056]   - Field: ‘globals’
[13:20:47.056]   - Field: ‘stdout’
[13:20:47.056]   - Field: ‘earlySignal’
[13:20:47.056]   - Field: ‘lazy’
[13:20:47.057]   - Field: ‘state’
[13:20:47.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:47.057] - Launch lazy future ...
[13:20:47.057] Packages needed by the future expression (n = 0): <none>
[13:20:47.057] Packages needed by future strategies (n = 0): <none>
[13:20:47.058] {
[13:20:47.058]     {
[13:20:47.058]         {
[13:20:47.058]             ...future.startTime <- base::Sys.time()
[13:20:47.058]             {
[13:20:47.058]                 {
[13:20:47.058]                   {
[13:20:47.058]                     {
[13:20:47.058]                       base::local({
[13:20:47.058]                         has_future <- base::requireNamespace("future", 
[13:20:47.058]                           quietly = TRUE)
[13:20:47.058]                         if (has_future) {
[13:20:47.058]                           ns <- base::getNamespace("future")
[13:20:47.058]                           version <- ns[[".package"]][["version"]]
[13:20:47.058]                           if (is.null(version)) 
[13:20:47.058]                             version <- utils::packageVersion("future")
[13:20:47.058]                         }
[13:20:47.058]                         else {
[13:20:47.058]                           version <- NULL
[13:20:47.058]                         }
[13:20:47.058]                         if (!has_future || version < "1.8.0") {
[13:20:47.058]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:47.058]                             "", base::R.version$version.string), 
[13:20:47.058]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:47.058]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:47.058]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:47.058]                               "release", "version")], collapse = " "), 
[13:20:47.058]                             hostname = base::Sys.info()[["nodename"]])
[13:20:47.058]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:47.058]                             info)
[13:20:47.058]                           info <- base::paste(info, collapse = "; ")
[13:20:47.058]                           if (!has_future) {
[13:20:47.058]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:47.058]                               info)
[13:20:47.058]                           }
[13:20:47.058]                           else {
[13:20:47.058]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:47.058]                               info, version)
[13:20:47.058]                           }
[13:20:47.058]                           base::stop(msg)
[13:20:47.058]                         }
[13:20:47.058]                       })
[13:20:47.058]                     }
[13:20:47.058]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:47.058]                     base::options(mc.cores = 1L)
[13:20:47.058]                   }
[13:20:47.058]                   options(future.plan = NULL)
[13:20:47.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:47.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:47.058]                 }
[13:20:47.058]                 ...future.workdir <- getwd()
[13:20:47.058]             }
[13:20:47.058]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:47.058]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:47.058]         }
[13:20:47.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:47.058]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:47.058]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:47.058]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:47.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:47.058]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:47.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:47.058]             base::names(...future.oldOptions))
[13:20:47.058]     }
[13:20:47.058]     if (FALSE) {
[13:20:47.058]     }
[13:20:47.058]     else {
[13:20:47.058]         if (TRUE) {
[13:20:47.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:47.058]                 open = "w")
[13:20:47.058]         }
[13:20:47.058]         else {
[13:20:47.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:47.058]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:47.058]         }
[13:20:47.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:47.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:47.058]             base::sink(type = "output", split = FALSE)
[13:20:47.058]             base::close(...future.stdout)
[13:20:47.058]         }, add = TRUE)
[13:20:47.058]     }
[13:20:47.058]     ...future.frame <- base::sys.nframe()
[13:20:47.058]     ...future.conditions <- base::list()
[13:20:47.058]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:47.058]     if (FALSE) {
[13:20:47.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:47.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:47.058]     }
[13:20:47.058]     ...future.result <- base::tryCatch({
[13:20:47.058]         base::withCallingHandlers({
[13:20:47.058]             ...future.value <- base::withVisible(base::local({
[13:20:47.058]                 ...future.makeSendCondition <- local({
[13:20:47.058]                   sendCondition <- NULL
[13:20:47.058]                   function(frame = 1L) {
[13:20:47.058]                     if (is.function(sendCondition)) 
[13:20:47.058]                       return(sendCondition)
[13:20:47.058]                     ns <- getNamespace("parallel")
[13:20:47.058]                     if (exists("sendData", mode = "function", 
[13:20:47.058]                       envir = ns)) {
[13:20:47.058]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:47.058]                         envir = ns)
[13:20:47.058]                       envir <- sys.frame(frame)
[13:20:47.058]                       master <- NULL
[13:20:47.058]                       while (!identical(envir, .GlobalEnv) && 
[13:20:47.058]                         !identical(envir, emptyenv())) {
[13:20:47.058]                         if (exists("master", mode = "list", envir = envir, 
[13:20:47.058]                           inherits = FALSE)) {
[13:20:47.058]                           master <- get("master", mode = "list", 
[13:20:47.058]                             envir = envir, inherits = FALSE)
[13:20:47.058]                           if (inherits(master, c("SOCKnode", 
[13:20:47.058]                             "SOCK0node"))) {
[13:20:47.058]                             sendCondition <<- function(cond) {
[13:20:47.058]                               data <- list(type = "VALUE", value = cond, 
[13:20:47.058]                                 success = TRUE)
[13:20:47.058]                               parallel_sendData(master, data)
[13:20:47.058]                             }
[13:20:47.058]                             return(sendCondition)
[13:20:47.058]                           }
[13:20:47.058]                         }
[13:20:47.058]                         frame <- frame + 1L
[13:20:47.058]                         envir <- sys.frame(frame)
[13:20:47.058]                       }
[13:20:47.058]                     }
[13:20:47.058]                     sendCondition <<- function(cond) NULL
[13:20:47.058]                   }
[13:20:47.058]                 })
[13:20:47.058]                 withCallingHandlers({
[13:20:47.058]                   {
[13:20:47.058]                     x["a"] <- list(1)
[13:20:47.058]                     x
[13:20:47.058]                   }
[13:20:47.058]                 }, immediateCondition = function(cond) {
[13:20:47.058]                   sendCondition <- ...future.makeSendCondition()
[13:20:47.058]                   sendCondition(cond)
[13:20:47.058]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:47.058]                   {
[13:20:47.058]                     inherits <- base::inherits
[13:20:47.058]                     invokeRestart <- base::invokeRestart
[13:20:47.058]                     is.null <- base::is.null
[13:20:47.058]                     muffled <- FALSE
[13:20:47.058]                     if (inherits(cond, "message")) {
[13:20:47.058]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:47.058]                       if (muffled) 
[13:20:47.058]                         invokeRestart("muffleMessage")
[13:20:47.058]                     }
[13:20:47.058]                     else if (inherits(cond, "warning")) {
[13:20:47.058]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:47.058]                       if (muffled) 
[13:20:47.058]                         invokeRestart("muffleWarning")
[13:20:47.058]                     }
[13:20:47.058]                     else if (inherits(cond, "condition")) {
[13:20:47.058]                       if (!is.null(pattern)) {
[13:20:47.058]                         computeRestarts <- base::computeRestarts
[13:20:47.058]                         grepl <- base::grepl
[13:20:47.058]                         restarts <- computeRestarts(cond)
[13:20:47.058]                         for (restart in restarts) {
[13:20:47.058]                           name <- restart$name
[13:20:47.058]                           if (is.null(name)) 
[13:20:47.058]                             next
[13:20:47.058]                           if (!grepl(pattern, name)) 
[13:20:47.058]                             next
[13:20:47.058]                           invokeRestart(restart)
[13:20:47.058]                           muffled <- TRUE
[13:20:47.058]                           break
[13:20:47.058]                         }
[13:20:47.058]                       }
[13:20:47.058]                     }
[13:20:47.058]                     invisible(muffled)
[13:20:47.058]                   }
[13:20:47.058]                   muffleCondition(cond)
[13:20:47.058]                 })
[13:20:47.058]             }))
[13:20:47.058]             future::FutureResult(value = ...future.value$value, 
[13:20:47.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:47.058]                   ...future.rng), globalenv = if (FALSE) 
[13:20:47.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:47.058]                     ...future.globalenv.names))
[13:20:47.058]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:47.058]         }, condition = base::local({
[13:20:47.058]             c <- base::c
[13:20:47.058]             inherits <- base::inherits
[13:20:47.058]             invokeRestart <- base::invokeRestart
[13:20:47.058]             length <- base::length
[13:20:47.058]             list <- base::list
[13:20:47.058]             seq.int <- base::seq.int
[13:20:47.058]             signalCondition <- base::signalCondition
[13:20:47.058]             sys.calls <- base::sys.calls
[13:20:47.058]             `[[` <- base::`[[`
[13:20:47.058]             `+` <- base::`+`
[13:20:47.058]             `<<-` <- base::`<<-`
[13:20:47.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:47.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:47.058]                   3L)]
[13:20:47.058]             }
[13:20:47.058]             function(cond) {
[13:20:47.058]                 is_error <- inherits(cond, "error")
[13:20:47.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:47.058]                   NULL)
[13:20:47.058]                 if (is_error) {
[13:20:47.058]                   sessionInformation <- function() {
[13:20:47.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:47.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:47.058]                       search = base::search(), system = base::Sys.info())
[13:20:47.058]                   }
[13:20:47.058]                   ...future.conditions[[length(...future.conditions) + 
[13:20:47.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:47.058]                     cond$call), session = sessionInformation(), 
[13:20:47.058]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:47.058]                   signalCondition(cond)
[13:20:47.058]                 }
[13:20:47.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:47.058]                 "immediateCondition"))) {
[13:20:47.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:47.058]                   ...future.conditions[[length(...future.conditions) + 
[13:20:47.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:47.058]                   if (TRUE && !signal) {
[13:20:47.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:47.058]                     {
[13:20:47.058]                       inherits <- base::inherits
[13:20:47.058]                       invokeRestart <- base::invokeRestart
[13:20:47.058]                       is.null <- base::is.null
[13:20:47.058]                       muffled <- FALSE
[13:20:47.058]                       if (inherits(cond, "message")) {
[13:20:47.058]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:47.058]                         if (muffled) 
[13:20:47.058]                           invokeRestart("muffleMessage")
[13:20:47.058]                       }
[13:20:47.058]                       else if (inherits(cond, "warning")) {
[13:20:47.058]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:47.058]                         if (muffled) 
[13:20:47.058]                           invokeRestart("muffleWarning")
[13:20:47.058]                       }
[13:20:47.058]                       else if (inherits(cond, "condition")) {
[13:20:47.058]                         if (!is.null(pattern)) {
[13:20:47.058]                           computeRestarts <- base::computeRestarts
[13:20:47.058]                           grepl <- base::grepl
[13:20:47.058]                           restarts <- computeRestarts(cond)
[13:20:47.058]                           for (restart in restarts) {
[13:20:47.058]                             name <- restart$name
[13:20:47.058]                             if (is.null(name)) 
[13:20:47.058]                               next
[13:20:47.058]                             if (!grepl(pattern, name)) 
[13:20:47.058]                               next
[13:20:47.058]                             invokeRestart(restart)
[13:20:47.058]                             muffled <- TRUE
[13:20:47.058]                             break
[13:20:47.058]                           }
[13:20:47.058]                         }
[13:20:47.058]                       }
[13:20:47.058]                       invisible(muffled)
[13:20:47.058]                     }
[13:20:47.058]                     muffleCondition(cond, pattern = "^muffle")
[13:20:47.058]                   }
[13:20:47.058]                 }
[13:20:47.058]                 else {
[13:20:47.058]                   if (TRUE) {
[13:20:47.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:47.058]                     {
[13:20:47.058]                       inherits <- base::inherits
[13:20:47.058]                       invokeRestart <- base::invokeRestart
[13:20:47.058]                       is.null <- base::is.null
[13:20:47.058]                       muffled <- FALSE
[13:20:47.058]                       if (inherits(cond, "message")) {
[13:20:47.058]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:47.058]                         if (muffled) 
[13:20:47.058]                           invokeRestart("muffleMessage")
[13:20:47.058]                       }
[13:20:47.058]                       else if (inherits(cond, "warning")) {
[13:20:47.058]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:47.058]                         if (muffled) 
[13:20:47.058]                           invokeRestart("muffleWarning")
[13:20:47.058]                       }
[13:20:47.058]                       else if (inherits(cond, "condition")) {
[13:20:47.058]                         if (!is.null(pattern)) {
[13:20:47.058]                           computeRestarts <- base::computeRestarts
[13:20:47.058]                           grepl <- base::grepl
[13:20:47.058]                           restarts <- computeRestarts(cond)
[13:20:47.058]                           for (restart in restarts) {
[13:20:47.058]                             name <- restart$name
[13:20:47.058]                             if (is.null(name)) 
[13:20:47.058]                               next
[13:20:47.058]                             if (!grepl(pattern, name)) 
[13:20:47.058]                               next
[13:20:47.058]                             invokeRestart(restart)
[13:20:47.058]                             muffled <- TRUE
[13:20:47.058]                             break
[13:20:47.058]                           }
[13:20:47.058]                         }
[13:20:47.058]                       }
[13:20:47.058]                       invisible(muffled)
[13:20:47.058]                     }
[13:20:47.058]                     muffleCondition(cond, pattern = "^muffle")
[13:20:47.058]                   }
[13:20:47.058]                 }
[13:20:47.058]             }
[13:20:47.058]         }))
[13:20:47.058]     }, error = function(ex) {
[13:20:47.058]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:47.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:47.058]                 ...future.rng), started = ...future.startTime, 
[13:20:47.058]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:47.058]             version = "1.8"), class = "FutureResult")
[13:20:47.058]     }, finally = {
[13:20:47.058]         if (!identical(...future.workdir, getwd())) 
[13:20:47.058]             setwd(...future.workdir)
[13:20:47.058]         {
[13:20:47.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:47.058]                 ...future.oldOptions$nwarnings <- NULL
[13:20:47.058]             }
[13:20:47.058]             base::options(...future.oldOptions)
[13:20:47.058]             if (.Platform$OS.type == "windows") {
[13:20:47.058]                 old_names <- names(...future.oldEnvVars)
[13:20:47.058]                 envs <- base::Sys.getenv()
[13:20:47.058]                 names <- names(envs)
[13:20:47.058]                 common <- intersect(names, old_names)
[13:20:47.058]                 added <- setdiff(names, old_names)
[13:20:47.058]                 removed <- setdiff(old_names, names)
[13:20:47.058]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:47.058]                   envs[common]]
[13:20:47.058]                 NAMES <- toupper(changed)
[13:20:47.058]                 args <- list()
[13:20:47.058]                 for (kk in seq_along(NAMES)) {
[13:20:47.058]                   name <- changed[[kk]]
[13:20:47.058]                   NAME <- NAMES[[kk]]
[13:20:47.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:47.058]                     next
[13:20:47.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:47.058]                 }
[13:20:47.058]                 NAMES <- toupper(added)
[13:20:47.058]                 for (kk in seq_along(NAMES)) {
[13:20:47.058]                   name <- added[[kk]]
[13:20:47.058]                   NAME <- NAMES[[kk]]
[13:20:47.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:47.058]                     next
[13:20:47.058]                   args[[name]] <- ""
[13:20:47.058]                 }
[13:20:47.058]                 NAMES <- toupper(removed)
[13:20:47.058]                 for (kk in seq_along(NAMES)) {
[13:20:47.058]                   name <- removed[[kk]]
[13:20:47.058]                   NAME <- NAMES[[kk]]
[13:20:47.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:47.058]                     next
[13:20:47.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:47.058]                 }
[13:20:47.058]                 if (length(args) > 0) 
[13:20:47.058]                   base::do.call(base::Sys.setenv, args = args)
[13:20:47.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:47.058]             }
[13:20:47.058]             else {
[13:20:47.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:47.058]             }
[13:20:47.058]             {
[13:20:47.058]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:47.058]                   0L) {
[13:20:47.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:47.058]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:47.058]                   base::options(opts)
[13:20:47.058]                 }
[13:20:47.058]                 {
[13:20:47.058]                   {
[13:20:47.058]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:47.058]                     NULL
[13:20:47.058]                   }
[13:20:47.058]                   options(future.plan = NULL)
[13:20:47.058]                   if (is.na(NA_character_)) 
[13:20:47.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:47.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:47.058]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:47.058]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:47.058]                     envir = parent.frame()) 
[13:20:47.058]                   {
[13:20:47.058]                     if (is.function(workers)) 
[13:20:47.058]                       workers <- workers()
[13:20:47.058]                     workers <- structure(as.integer(workers), 
[13:20:47.058]                       class = class(workers))
[13:20:47.058]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:47.058]                       workers >= 1)
[13:20:47.058]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:47.058]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:47.058]                     }
[13:20:47.058]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:47.058]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:47.058]                       envir = envir)
[13:20:47.058]                     if (!future$lazy) 
[13:20:47.058]                       future <- run(future)
[13:20:47.058]                     invisible(future)
[13:20:47.058]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:47.058]                 }
[13:20:47.058]             }
[13:20:47.058]         }
[13:20:47.058]     })
[13:20:47.058]     if (TRUE) {
[13:20:47.058]         base::sink(type = "output", split = FALSE)
[13:20:47.058]         if (TRUE) {
[13:20:47.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:47.058]         }
[13:20:47.058]         else {
[13:20:47.058]             ...future.result["stdout"] <- base::list(NULL)
[13:20:47.058]         }
[13:20:47.058]         base::close(...future.stdout)
[13:20:47.058]         ...future.stdout <- NULL
[13:20:47.058]     }
[13:20:47.058]     ...future.result$conditions <- ...future.conditions
[13:20:47.058]     ...future.result$finished <- base::Sys.time()
[13:20:47.058]     ...future.result
[13:20:47.058] }
[13:20:47.060] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:20:47.061] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:20:47.061] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:20:47.061] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:20:47.062] MultisessionFuture started
[13:20:47.062] - Launch lazy future ... done
[13:20:47.062] run() for ‘MultisessionFuture’ ... done
[13:20:47.062] result() for ClusterFuture ...
[13:20:47.062] receiveMessageFromWorker() for ClusterFuture ...
[13:20:47.062] - Validating connection of MultisessionFuture
[13:20:47.110] - received message: FutureResult
[13:20:47.110] - Received FutureResult
[13:20:47.110] - Erased future from FutureRegistry
[13:20:47.110] result() for ClusterFuture ...
[13:20:47.110] - result already collected: FutureResult
[13:20:47.110] result() for ClusterFuture ... done
[13:20:47.111] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:47.111] result() for ClusterFuture ... done
[13:20:47.111] result() for ClusterFuture ...
[13:20:47.111] - result already collected: FutureResult
[13:20:47.111] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:47.112] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:47.112] Searching for globals...
[13:20:47.114] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:47.114] Searching for globals ... DONE
[13:20:47.114] Resolving globals: TRUE
[13:20:47.115] Resolving any globals that are futures ...
[13:20:47.115] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[13:20:47.115] Resolving any globals that are futures ... DONE
[13:20:47.115] Resolving futures part of globals (recursively) ...
[13:20:47.115] resolve() on list ...
[13:20:47.116]  recursive: 99
[13:20:47.116]  length: 1
[13:20:47.116]  elements: ‘x’
[13:20:47.116]  length: 0 (resolved future 1)
[13:20:47.116] resolve() on list ... DONE
[13:20:47.116] - globals: [1] ‘x’
[13:20:47.116] Resolving futures part of globals (recursively) ... DONE
[13:20:47.116] The total size of the 1 globals is 0 bytes (0 bytes)
[13:20:47.117] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[13:20:47.117] - globals: [1] ‘x’
[13:20:47.117] 
[13:20:47.117] getGlobalsAndPackages() ... DONE
[13:20:47.117] run() for ‘Future’ ...
[13:20:47.117] - state: ‘created’
[13:20:47.118] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:47.132] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:47.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:47.132]   - Field: ‘node’
[13:20:47.132]   - Field: ‘label’
[13:20:47.132]   - Field: ‘local’
[13:20:47.132]   - Field: ‘owner’
[13:20:47.133]   - Field: ‘envir’
[13:20:47.133]   - Field: ‘workers’
[13:20:47.133]   - Field: ‘packages’
[13:20:47.133]   - Field: ‘gc’
[13:20:47.133]   - Field: ‘conditions’
[13:20:47.133]   - Field: ‘persistent’
[13:20:47.133]   - Field: ‘expr’
[13:20:47.133]   - Field: ‘uuid’
[13:20:47.133]   - Field: ‘seed’
[13:20:47.133]   - Field: ‘version’
[13:20:47.134]   - Field: ‘result’
[13:20:47.134]   - Field: ‘asynchronous’
[13:20:47.134]   - Field: ‘calls’
[13:20:47.134]   - Field: ‘globals’
[13:20:47.134]   - Field: ‘stdout’
[13:20:47.134]   - Field: ‘earlySignal’
[13:20:47.134]   - Field: ‘lazy’
[13:20:47.134]   - Field: ‘state’
[13:20:47.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:47.134] - Launch lazy future ...
[13:20:47.135] Packages needed by the future expression (n = 0): <none>
[13:20:47.135] Packages needed by future strategies (n = 0): <none>
[13:20:47.135] {
[13:20:47.135]     {
[13:20:47.135]         {
[13:20:47.135]             ...future.startTime <- base::Sys.time()
[13:20:47.135]             {
[13:20:47.135]                 {
[13:20:47.135]                   {
[13:20:47.135]                     {
[13:20:47.135]                       base::local({
[13:20:47.135]                         has_future <- base::requireNamespace("future", 
[13:20:47.135]                           quietly = TRUE)
[13:20:47.135]                         if (has_future) {
[13:20:47.135]                           ns <- base::getNamespace("future")
[13:20:47.135]                           version <- ns[[".package"]][["version"]]
[13:20:47.135]                           if (is.null(version)) 
[13:20:47.135]                             version <- utils::packageVersion("future")
[13:20:47.135]                         }
[13:20:47.135]                         else {
[13:20:47.135]                           version <- NULL
[13:20:47.135]                         }
[13:20:47.135]                         if (!has_future || version < "1.8.0") {
[13:20:47.135]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:47.135]                             "", base::R.version$version.string), 
[13:20:47.135]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:47.135]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:47.135]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:47.135]                               "release", "version")], collapse = " "), 
[13:20:47.135]                             hostname = base::Sys.info()[["nodename"]])
[13:20:47.135]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:47.135]                             info)
[13:20:47.135]                           info <- base::paste(info, collapse = "; ")
[13:20:47.135]                           if (!has_future) {
[13:20:47.135]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:47.135]                               info)
[13:20:47.135]                           }
[13:20:47.135]                           else {
[13:20:47.135]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:47.135]                               info, version)
[13:20:47.135]                           }
[13:20:47.135]                           base::stop(msg)
[13:20:47.135]                         }
[13:20:47.135]                       })
[13:20:47.135]                     }
[13:20:47.135]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:47.135]                     base::options(mc.cores = 1L)
[13:20:47.135]                   }
[13:20:47.135]                   options(future.plan = NULL)
[13:20:47.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:47.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:47.135]                 }
[13:20:47.135]                 ...future.workdir <- getwd()
[13:20:47.135]             }
[13:20:47.135]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:47.135]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:47.135]         }
[13:20:47.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:47.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:47.135]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:47.135]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:47.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:47.135]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:47.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:47.135]             base::names(...future.oldOptions))
[13:20:47.135]     }
[13:20:47.135]     if (FALSE) {
[13:20:47.135]     }
[13:20:47.135]     else {
[13:20:47.135]         if (TRUE) {
[13:20:47.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:47.135]                 open = "w")
[13:20:47.135]         }
[13:20:47.135]         else {
[13:20:47.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:47.135]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:47.135]         }
[13:20:47.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:47.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:47.135]             base::sink(type = "output", split = FALSE)
[13:20:47.135]             base::close(...future.stdout)
[13:20:47.135]         }, add = TRUE)
[13:20:47.135]     }
[13:20:47.135]     ...future.frame <- base::sys.nframe()
[13:20:47.135]     ...future.conditions <- base::list()
[13:20:47.135]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:47.135]     if (FALSE) {
[13:20:47.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:47.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:47.135]     }
[13:20:47.135]     ...future.result <- base::tryCatch({
[13:20:47.135]         base::withCallingHandlers({
[13:20:47.135]             ...future.value <- base::withVisible(base::local({
[13:20:47.135]                 ...future.makeSendCondition <- local({
[13:20:47.135]                   sendCondition <- NULL
[13:20:47.135]                   function(frame = 1L) {
[13:20:47.135]                     if (is.function(sendCondition)) 
[13:20:47.135]                       return(sendCondition)
[13:20:47.135]                     ns <- getNamespace("parallel")
[13:20:47.135]                     if (exists("sendData", mode = "function", 
[13:20:47.135]                       envir = ns)) {
[13:20:47.135]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:47.135]                         envir = ns)
[13:20:47.135]                       envir <- sys.frame(frame)
[13:20:47.135]                       master <- NULL
[13:20:47.135]                       while (!identical(envir, .GlobalEnv) && 
[13:20:47.135]                         !identical(envir, emptyenv())) {
[13:20:47.135]                         if (exists("master", mode = "list", envir = envir, 
[13:20:47.135]                           inherits = FALSE)) {
[13:20:47.135]                           master <- get("master", mode = "list", 
[13:20:47.135]                             envir = envir, inherits = FALSE)
[13:20:47.135]                           if (inherits(master, c("SOCKnode", 
[13:20:47.135]                             "SOCK0node"))) {
[13:20:47.135]                             sendCondition <<- function(cond) {
[13:20:47.135]                               data <- list(type = "VALUE", value = cond, 
[13:20:47.135]                                 success = TRUE)
[13:20:47.135]                               parallel_sendData(master, data)
[13:20:47.135]                             }
[13:20:47.135]                             return(sendCondition)
[13:20:47.135]                           }
[13:20:47.135]                         }
[13:20:47.135]                         frame <- frame + 1L
[13:20:47.135]                         envir <- sys.frame(frame)
[13:20:47.135]                       }
[13:20:47.135]                     }
[13:20:47.135]                     sendCondition <<- function(cond) NULL
[13:20:47.135]                   }
[13:20:47.135]                 })
[13:20:47.135]                 withCallingHandlers({
[13:20:47.135]                   {
[13:20:47.135]                     x["a"] <- list(1)
[13:20:47.135]                     x
[13:20:47.135]                   }
[13:20:47.135]                 }, immediateCondition = function(cond) {
[13:20:47.135]                   sendCondition <- ...future.makeSendCondition()
[13:20:47.135]                   sendCondition(cond)
[13:20:47.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:47.135]                   {
[13:20:47.135]                     inherits <- base::inherits
[13:20:47.135]                     invokeRestart <- base::invokeRestart
[13:20:47.135]                     is.null <- base::is.null
[13:20:47.135]                     muffled <- FALSE
[13:20:47.135]                     if (inherits(cond, "message")) {
[13:20:47.135]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:47.135]                       if (muffled) 
[13:20:47.135]                         invokeRestart("muffleMessage")
[13:20:47.135]                     }
[13:20:47.135]                     else if (inherits(cond, "warning")) {
[13:20:47.135]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:47.135]                       if (muffled) 
[13:20:47.135]                         invokeRestart("muffleWarning")
[13:20:47.135]                     }
[13:20:47.135]                     else if (inherits(cond, "condition")) {
[13:20:47.135]                       if (!is.null(pattern)) {
[13:20:47.135]                         computeRestarts <- base::computeRestarts
[13:20:47.135]                         grepl <- base::grepl
[13:20:47.135]                         restarts <- computeRestarts(cond)
[13:20:47.135]                         for (restart in restarts) {
[13:20:47.135]                           name <- restart$name
[13:20:47.135]                           if (is.null(name)) 
[13:20:47.135]                             next
[13:20:47.135]                           if (!grepl(pattern, name)) 
[13:20:47.135]                             next
[13:20:47.135]                           invokeRestart(restart)
[13:20:47.135]                           muffled <- TRUE
[13:20:47.135]                           break
[13:20:47.135]                         }
[13:20:47.135]                       }
[13:20:47.135]                     }
[13:20:47.135]                     invisible(muffled)
[13:20:47.135]                   }
[13:20:47.135]                   muffleCondition(cond)
[13:20:47.135]                 })
[13:20:47.135]             }))
[13:20:47.135]             future::FutureResult(value = ...future.value$value, 
[13:20:47.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:47.135]                   ...future.rng), globalenv = if (FALSE) 
[13:20:47.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:47.135]                     ...future.globalenv.names))
[13:20:47.135]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:47.135]         }, condition = base::local({
[13:20:47.135]             c <- base::c
[13:20:47.135]             inherits <- base::inherits
[13:20:47.135]             invokeRestart <- base::invokeRestart
[13:20:47.135]             length <- base::length
[13:20:47.135]             list <- base::list
[13:20:47.135]             seq.int <- base::seq.int
[13:20:47.135]             signalCondition <- base::signalCondition
[13:20:47.135]             sys.calls <- base::sys.calls
[13:20:47.135]             `[[` <- base::`[[`
[13:20:47.135]             `+` <- base::`+`
[13:20:47.135]             `<<-` <- base::`<<-`
[13:20:47.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:47.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:47.135]                   3L)]
[13:20:47.135]             }
[13:20:47.135]             function(cond) {
[13:20:47.135]                 is_error <- inherits(cond, "error")
[13:20:47.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:47.135]                   NULL)
[13:20:47.135]                 if (is_error) {
[13:20:47.135]                   sessionInformation <- function() {
[13:20:47.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:47.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:47.135]                       search = base::search(), system = base::Sys.info())
[13:20:47.135]                   }
[13:20:47.135]                   ...future.conditions[[length(...future.conditions) + 
[13:20:47.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:47.135]                     cond$call), session = sessionInformation(), 
[13:20:47.135]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:47.135]                   signalCondition(cond)
[13:20:47.135]                 }
[13:20:47.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:47.135]                 "immediateCondition"))) {
[13:20:47.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:47.135]                   ...future.conditions[[length(...future.conditions) + 
[13:20:47.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:47.135]                   if (TRUE && !signal) {
[13:20:47.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:47.135]                     {
[13:20:47.135]                       inherits <- base::inherits
[13:20:47.135]                       invokeRestart <- base::invokeRestart
[13:20:47.135]                       is.null <- base::is.null
[13:20:47.135]                       muffled <- FALSE
[13:20:47.135]                       if (inherits(cond, "message")) {
[13:20:47.135]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:47.135]                         if (muffled) 
[13:20:47.135]                           invokeRestart("muffleMessage")
[13:20:47.135]                       }
[13:20:47.135]                       else if (inherits(cond, "warning")) {
[13:20:47.135]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:47.135]                         if (muffled) 
[13:20:47.135]                           invokeRestart("muffleWarning")
[13:20:47.135]                       }
[13:20:47.135]                       else if (inherits(cond, "condition")) {
[13:20:47.135]                         if (!is.null(pattern)) {
[13:20:47.135]                           computeRestarts <- base::computeRestarts
[13:20:47.135]                           grepl <- base::grepl
[13:20:47.135]                           restarts <- computeRestarts(cond)
[13:20:47.135]                           for (restart in restarts) {
[13:20:47.135]                             name <- restart$name
[13:20:47.135]                             if (is.null(name)) 
[13:20:47.135]                               next
[13:20:47.135]                             if (!grepl(pattern, name)) 
[13:20:47.135]                               next
[13:20:47.135]                             invokeRestart(restart)
[13:20:47.135]                             muffled <- TRUE
[13:20:47.135]                             break
[13:20:47.135]                           }
[13:20:47.135]                         }
[13:20:47.135]                       }
[13:20:47.135]                       invisible(muffled)
[13:20:47.135]                     }
[13:20:47.135]                     muffleCondition(cond, pattern = "^muffle")
[13:20:47.135]                   }
[13:20:47.135]                 }
[13:20:47.135]                 else {
[13:20:47.135]                   if (TRUE) {
[13:20:47.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:47.135]                     {
[13:20:47.135]                       inherits <- base::inherits
[13:20:47.135]                       invokeRestart <- base::invokeRestart
[13:20:47.135]                       is.null <- base::is.null
[13:20:47.135]                       muffled <- FALSE
[13:20:47.135]                       if (inherits(cond, "message")) {
[13:20:47.135]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:47.135]                         if (muffled) 
[13:20:47.135]                           invokeRestart("muffleMessage")
[13:20:47.135]                       }
[13:20:47.135]                       else if (inherits(cond, "warning")) {
[13:20:47.135]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:47.135]                         if (muffled) 
[13:20:47.135]                           invokeRestart("muffleWarning")
[13:20:47.135]                       }
[13:20:47.135]                       else if (inherits(cond, "condition")) {
[13:20:47.135]                         if (!is.null(pattern)) {
[13:20:47.135]                           computeRestarts <- base::computeRestarts
[13:20:47.135]                           grepl <- base::grepl
[13:20:47.135]                           restarts <- computeRestarts(cond)
[13:20:47.135]                           for (restart in restarts) {
[13:20:47.135]                             name <- restart$name
[13:20:47.135]                             if (is.null(name)) 
[13:20:47.135]                               next
[13:20:47.135]                             if (!grepl(pattern, name)) 
[13:20:47.135]                               next
[13:20:47.135]                             invokeRestart(restart)
[13:20:47.135]                             muffled <- TRUE
[13:20:47.135]                             break
[13:20:47.135]                           }
[13:20:47.135]                         }
[13:20:47.135]                       }
[13:20:47.135]                       invisible(muffled)
[13:20:47.135]                     }
[13:20:47.135]                     muffleCondition(cond, pattern = "^muffle")
[13:20:47.135]                   }
[13:20:47.135]                 }
[13:20:47.135]             }
[13:20:47.135]         }))
[13:20:47.135]     }, error = function(ex) {
[13:20:47.135]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:47.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:47.135]                 ...future.rng), started = ...future.startTime, 
[13:20:47.135]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:47.135]             version = "1.8"), class = "FutureResult")
[13:20:47.135]     }, finally = {
[13:20:47.135]         if (!identical(...future.workdir, getwd())) 
[13:20:47.135]             setwd(...future.workdir)
[13:20:47.135]         {
[13:20:47.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:47.135]                 ...future.oldOptions$nwarnings <- NULL
[13:20:47.135]             }
[13:20:47.135]             base::options(...future.oldOptions)
[13:20:47.135]             if (.Platform$OS.type == "windows") {
[13:20:47.135]                 old_names <- names(...future.oldEnvVars)
[13:20:47.135]                 envs <- base::Sys.getenv()
[13:20:47.135]                 names <- names(envs)
[13:20:47.135]                 common <- intersect(names, old_names)
[13:20:47.135]                 added <- setdiff(names, old_names)
[13:20:47.135]                 removed <- setdiff(old_names, names)
[13:20:47.135]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:47.135]                   envs[common]]
[13:20:47.135]                 NAMES <- toupper(changed)
[13:20:47.135]                 args <- list()
[13:20:47.135]                 for (kk in seq_along(NAMES)) {
[13:20:47.135]                   name <- changed[[kk]]
[13:20:47.135]                   NAME <- NAMES[[kk]]
[13:20:47.135]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:47.135]                     next
[13:20:47.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:47.135]                 }
[13:20:47.135]                 NAMES <- toupper(added)
[13:20:47.135]                 for (kk in seq_along(NAMES)) {
[13:20:47.135]                   name <- added[[kk]]
[13:20:47.135]                   NAME <- NAMES[[kk]]
[13:20:47.135]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:47.135]                     next
[13:20:47.135]                   args[[name]] <- ""
[13:20:47.135]                 }
[13:20:47.135]                 NAMES <- toupper(removed)
[13:20:47.135]                 for (kk in seq_along(NAMES)) {
[13:20:47.135]                   name <- removed[[kk]]
[13:20:47.135]                   NAME <- NAMES[[kk]]
[13:20:47.135]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:47.135]                     next
[13:20:47.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:47.135]                 }
[13:20:47.135]                 if (length(args) > 0) 
[13:20:47.135]                   base::do.call(base::Sys.setenv, args = args)
[13:20:47.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:47.135]             }
[13:20:47.135]             else {
[13:20:47.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:47.135]             }
[13:20:47.135]             {
[13:20:47.135]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:47.135]                   0L) {
[13:20:47.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:47.135]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:47.135]                   base::options(opts)
[13:20:47.135]                 }
[13:20:47.135]                 {
[13:20:47.135]                   {
[13:20:47.135]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:47.135]                     NULL
[13:20:47.135]                   }
[13:20:47.135]                   options(future.plan = NULL)
[13:20:47.135]                   if (is.na(NA_character_)) 
[13:20:47.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:47.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:47.135]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:47.135]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:47.135]                     envir = parent.frame()) 
[13:20:47.135]                   {
[13:20:47.135]                     if (is.function(workers)) 
[13:20:47.135]                       workers <- workers()
[13:20:47.135]                     workers <- structure(as.integer(workers), 
[13:20:47.135]                       class = class(workers))
[13:20:47.135]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:47.135]                       workers >= 1)
[13:20:47.135]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:47.135]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:47.135]                     }
[13:20:47.135]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:47.135]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:47.135]                       envir = envir)
[13:20:47.135]                     if (!future$lazy) 
[13:20:47.135]                       future <- run(future)
[13:20:47.135]                     invisible(future)
[13:20:47.135]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:47.135]                 }
[13:20:47.135]             }
[13:20:47.135]         }
[13:20:47.135]     })
[13:20:47.135]     if (TRUE) {
[13:20:47.135]         base::sink(type = "output", split = FALSE)
[13:20:47.135]         if (TRUE) {
[13:20:47.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:47.135]         }
[13:20:47.135]         else {
[13:20:47.135]             ...future.result["stdout"] <- base::list(NULL)
[13:20:47.135]         }
[13:20:47.135]         base::close(...future.stdout)
[13:20:47.135]         ...future.stdout <- NULL
[13:20:47.135]     }
[13:20:47.135]     ...future.result$conditions <- ...future.conditions
[13:20:47.135]     ...future.result$finished <- base::Sys.time()
[13:20:47.135]     ...future.result
[13:20:47.135] }
[13:20:47.138] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[13:20:47.138] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:20:47.138] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:20:47.139] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[13:20:47.139] MultisessionFuture started
[13:20:47.139] - Launch lazy future ... done
[13:20:47.139] run() for ‘MultisessionFuture’ ... done
[13:20:47.140] result() for ClusterFuture ...
[13:20:47.140] receiveMessageFromWorker() for ClusterFuture ...
[13:20:47.140] - Validating connection of MultisessionFuture
[13:20:47.186] - received message: FutureResult
[13:20:47.186] - Received FutureResult
[13:20:47.186] - Erased future from FutureRegistry
[13:20:47.186] result() for ClusterFuture ...
[13:20:47.186] - result already collected: FutureResult
[13:20:47.186] result() for ClusterFuture ... done
[13:20:47.186] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:47.186] result() for ClusterFuture ... done
[13:20:47.187] result() for ClusterFuture ...
[13:20:47.187] - result already collected: FutureResult
[13:20:47.187] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:47.187] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:47.187] Searching for globals...
[13:20:47.190] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:20:47.190] Searching for globals ... DONE
[13:20:47.190] Resolving globals: TRUE
[13:20:47.190] Resolving any globals that are futures ...
[13:20:47.190] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[13:20:47.190] Resolving any globals that are futures ... DONE
[13:20:47.191] Resolving futures part of globals (recursively) ...
[13:20:47.191] resolve() on list ...
[13:20:47.191]  recursive: 99
[13:20:47.191]  length: 2
[13:20:47.191]  elements: ‘x’, ‘name’
[13:20:47.191]  length: 1 (resolved future 1)
[13:20:47.191]  length: 0 (resolved future 2)
[13:20:47.191] resolve() on list ... DONE
[13:20:47.192] - globals: [2] ‘x’, ‘name’
[13:20:47.192] Resolving futures part of globals (recursively) ... DONE
[13:20:47.192] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:47.192] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[13:20:47.192] - globals: [2] ‘x’, ‘name’
[13:20:47.192] 
[13:20:47.193] getGlobalsAndPackages() ... DONE
[13:20:47.193] run() for ‘Future’ ...
[13:20:47.193] - state: ‘created’
[13:20:47.193] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:47.207] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:47.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:47.207]   - Field: ‘node’
[13:20:47.207]   - Field: ‘label’
[13:20:47.208]   - Field: ‘local’
[13:20:47.208]   - Field: ‘owner’
[13:20:47.208]   - Field: ‘envir’
[13:20:47.208]   - Field: ‘workers’
[13:20:47.208]   - Field: ‘packages’
[13:20:47.208]   - Field: ‘gc’
[13:20:47.208]   - Field: ‘conditions’
[13:20:47.208]   - Field: ‘persistent’
[13:20:47.208]   - Field: ‘expr’
[13:20:47.208]   - Field: ‘uuid’
[13:20:47.208]   - Field: ‘seed’
[13:20:47.209]   - Field: ‘version’
[13:20:47.209]   - Field: ‘result’
[13:20:47.209]   - Field: ‘asynchronous’
[13:20:47.209]   - Field: ‘calls’
[13:20:47.209]   - Field: ‘globals’
[13:20:47.209]   - Field: ‘stdout’
[13:20:47.209]   - Field: ‘earlySignal’
[13:20:47.209]   - Field: ‘lazy’
[13:20:47.209]   - Field: ‘state’
[13:20:47.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:47.210] - Launch lazy future ...
[13:20:47.210] Packages needed by the future expression (n = 0): <none>
[13:20:47.210] Packages needed by future strategies (n = 0): <none>
[13:20:47.210] {
[13:20:47.210]     {
[13:20:47.210]         {
[13:20:47.210]             ...future.startTime <- base::Sys.time()
[13:20:47.210]             {
[13:20:47.210]                 {
[13:20:47.210]                   {
[13:20:47.210]                     {
[13:20:47.210]                       base::local({
[13:20:47.210]                         has_future <- base::requireNamespace("future", 
[13:20:47.210]                           quietly = TRUE)
[13:20:47.210]                         if (has_future) {
[13:20:47.210]                           ns <- base::getNamespace("future")
[13:20:47.210]                           version <- ns[[".package"]][["version"]]
[13:20:47.210]                           if (is.null(version)) 
[13:20:47.210]                             version <- utils::packageVersion("future")
[13:20:47.210]                         }
[13:20:47.210]                         else {
[13:20:47.210]                           version <- NULL
[13:20:47.210]                         }
[13:20:47.210]                         if (!has_future || version < "1.8.0") {
[13:20:47.210]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:47.210]                             "", base::R.version$version.string), 
[13:20:47.210]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:47.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:47.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:47.210]                               "release", "version")], collapse = " "), 
[13:20:47.210]                             hostname = base::Sys.info()[["nodename"]])
[13:20:47.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:47.210]                             info)
[13:20:47.210]                           info <- base::paste(info, collapse = "; ")
[13:20:47.210]                           if (!has_future) {
[13:20:47.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:47.210]                               info)
[13:20:47.210]                           }
[13:20:47.210]                           else {
[13:20:47.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:47.210]                               info, version)
[13:20:47.210]                           }
[13:20:47.210]                           base::stop(msg)
[13:20:47.210]                         }
[13:20:47.210]                       })
[13:20:47.210]                     }
[13:20:47.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:47.210]                     base::options(mc.cores = 1L)
[13:20:47.210]                   }
[13:20:47.210]                   options(future.plan = NULL)
[13:20:47.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:47.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:47.210]                 }
[13:20:47.210]                 ...future.workdir <- getwd()
[13:20:47.210]             }
[13:20:47.210]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:47.210]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:47.210]         }
[13:20:47.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:47.210]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:47.210]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:47.210]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:47.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:47.210]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:47.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:47.210]             base::names(...future.oldOptions))
[13:20:47.210]     }
[13:20:47.210]     if (FALSE) {
[13:20:47.210]     }
[13:20:47.210]     else {
[13:20:47.210]         if (TRUE) {
[13:20:47.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:47.210]                 open = "w")
[13:20:47.210]         }
[13:20:47.210]         else {
[13:20:47.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:47.210]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:47.210]         }
[13:20:47.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:47.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:47.210]             base::sink(type = "output", split = FALSE)
[13:20:47.210]             base::close(...future.stdout)
[13:20:47.210]         }, add = TRUE)
[13:20:47.210]     }
[13:20:47.210]     ...future.frame <- base::sys.nframe()
[13:20:47.210]     ...future.conditions <- base::list()
[13:20:47.210]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:47.210]     if (FALSE) {
[13:20:47.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:47.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:47.210]     }
[13:20:47.210]     ...future.result <- base::tryCatch({
[13:20:47.210]         base::withCallingHandlers({
[13:20:47.210]             ...future.value <- base::withVisible(base::local({
[13:20:47.210]                 ...future.makeSendCondition <- local({
[13:20:47.210]                   sendCondition <- NULL
[13:20:47.210]                   function(frame = 1L) {
[13:20:47.210]                     if (is.function(sendCondition)) 
[13:20:47.210]                       return(sendCondition)
[13:20:47.210]                     ns <- getNamespace("parallel")
[13:20:47.210]                     if (exists("sendData", mode = "function", 
[13:20:47.210]                       envir = ns)) {
[13:20:47.210]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:47.210]                         envir = ns)
[13:20:47.210]                       envir <- sys.frame(frame)
[13:20:47.210]                       master <- NULL
[13:20:47.210]                       while (!identical(envir, .GlobalEnv) && 
[13:20:47.210]                         !identical(envir, emptyenv())) {
[13:20:47.210]                         if (exists("master", mode = "list", envir = envir, 
[13:20:47.210]                           inherits = FALSE)) {
[13:20:47.210]                           master <- get("master", mode = "list", 
[13:20:47.210]                             envir = envir, inherits = FALSE)
[13:20:47.210]                           if (inherits(master, c("SOCKnode", 
[13:20:47.210]                             "SOCK0node"))) {
[13:20:47.210]                             sendCondition <<- function(cond) {
[13:20:47.210]                               data <- list(type = "VALUE", value = cond, 
[13:20:47.210]                                 success = TRUE)
[13:20:47.210]                               parallel_sendData(master, data)
[13:20:47.210]                             }
[13:20:47.210]                             return(sendCondition)
[13:20:47.210]                           }
[13:20:47.210]                         }
[13:20:47.210]                         frame <- frame + 1L
[13:20:47.210]                         envir <- sys.frame(frame)
[13:20:47.210]                       }
[13:20:47.210]                     }
[13:20:47.210]                     sendCondition <<- function(cond) NULL
[13:20:47.210]                   }
[13:20:47.210]                 })
[13:20:47.210]                 withCallingHandlers({
[13:20:47.210]                   {
[13:20:47.210]                     x[name] <- list(1)
[13:20:47.210]                     x
[13:20:47.210]                   }
[13:20:47.210]                 }, immediateCondition = function(cond) {
[13:20:47.210]                   sendCondition <- ...future.makeSendCondition()
[13:20:47.210]                   sendCondition(cond)
[13:20:47.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:47.210]                   {
[13:20:47.210]                     inherits <- base::inherits
[13:20:47.210]                     invokeRestart <- base::invokeRestart
[13:20:47.210]                     is.null <- base::is.null
[13:20:47.210]                     muffled <- FALSE
[13:20:47.210]                     if (inherits(cond, "message")) {
[13:20:47.210]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:47.210]                       if (muffled) 
[13:20:47.210]                         invokeRestart("muffleMessage")
[13:20:47.210]                     }
[13:20:47.210]                     else if (inherits(cond, "warning")) {
[13:20:47.210]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:47.210]                       if (muffled) 
[13:20:47.210]                         invokeRestart("muffleWarning")
[13:20:47.210]                     }
[13:20:47.210]                     else if (inherits(cond, "condition")) {
[13:20:47.210]                       if (!is.null(pattern)) {
[13:20:47.210]                         computeRestarts <- base::computeRestarts
[13:20:47.210]                         grepl <- base::grepl
[13:20:47.210]                         restarts <- computeRestarts(cond)
[13:20:47.210]                         for (restart in restarts) {
[13:20:47.210]                           name <- restart$name
[13:20:47.210]                           if (is.null(name)) 
[13:20:47.210]                             next
[13:20:47.210]                           if (!grepl(pattern, name)) 
[13:20:47.210]                             next
[13:20:47.210]                           invokeRestart(restart)
[13:20:47.210]                           muffled <- TRUE
[13:20:47.210]                           break
[13:20:47.210]                         }
[13:20:47.210]                       }
[13:20:47.210]                     }
[13:20:47.210]                     invisible(muffled)
[13:20:47.210]                   }
[13:20:47.210]                   muffleCondition(cond)
[13:20:47.210]                 })
[13:20:47.210]             }))
[13:20:47.210]             future::FutureResult(value = ...future.value$value, 
[13:20:47.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:47.210]                   ...future.rng), globalenv = if (FALSE) 
[13:20:47.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:47.210]                     ...future.globalenv.names))
[13:20:47.210]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:47.210]         }, condition = base::local({
[13:20:47.210]             c <- base::c
[13:20:47.210]             inherits <- base::inherits
[13:20:47.210]             invokeRestart <- base::invokeRestart
[13:20:47.210]             length <- base::length
[13:20:47.210]             list <- base::list
[13:20:47.210]             seq.int <- base::seq.int
[13:20:47.210]             signalCondition <- base::signalCondition
[13:20:47.210]             sys.calls <- base::sys.calls
[13:20:47.210]             `[[` <- base::`[[`
[13:20:47.210]             `+` <- base::`+`
[13:20:47.210]             `<<-` <- base::`<<-`
[13:20:47.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:47.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:47.210]                   3L)]
[13:20:47.210]             }
[13:20:47.210]             function(cond) {
[13:20:47.210]                 is_error <- inherits(cond, "error")
[13:20:47.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:47.210]                   NULL)
[13:20:47.210]                 if (is_error) {
[13:20:47.210]                   sessionInformation <- function() {
[13:20:47.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:47.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:47.210]                       search = base::search(), system = base::Sys.info())
[13:20:47.210]                   }
[13:20:47.210]                   ...future.conditions[[length(...future.conditions) + 
[13:20:47.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:47.210]                     cond$call), session = sessionInformation(), 
[13:20:47.210]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:47.210]                   signalCondition(cond)
[13:20:47.210]                 }
[13:20:47.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:47.210]                 "immediateCondition"))) {
[13:20:47.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:47.210]                   ...future.conditions[[length(...future.conditions) + 
[13:20:47.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:47.210]                   if (TRUE && !signal) {
[13:20:47.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:47.210]                     {
[13:20:47.210]                       inherits <- base::inherits
[13:20:47.210]                       invokeRestart <- base::invokeRestart
[13:20:47.210]                       is.null <- base::is.null
[13:20:47.210]                       muffled <- FALSE
[13:20:47.210]                       if (inherits(cond, "message")) {
[13:20:47.210]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:47.210]                         if (muffled) 
[13:20:47.210]                           invokeRestart("muffleMessage")
[13:20:47.210]                       }
[13:20:47.210]                       else if (inherits(cond, "warning")) {
[13:20:47.210]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:47.210]                         if (muffled) 
[13:20:47.210]                           invokeRestart("muffleWarning")
[13:20:47.210]                       }
[13:20:47.210]                       else if (inherits(cond, "condition")) {
[13:20:47.210]                         if (!is.null(pattern)) {
[13:20:47.210]                           computeRestarts <- base::computeRestarts
[13:20:47.210]                           grepl <- base::grepl
[13:20:47.210]                           restarts <- computeRestarts(cond)
[13:20:47.210]                           for (restart in restarts) {
[13:20:47.210]                             name <- restart$name
[13:20:47.210]                             if (is.null(name)) 
[13:20:47.210]                               next
[13:20:47.210]                             if (!grepl(pattern, name)) 
[13:20:47.210]                               next
[13:20:47.210]                             invokeRestart(restart)
[13:20:47.210]                             muffled <- TRUE
[13:20:47.210]                             break
[13:20:47.210]                           }
[13:20:47.210]                         }
[13:20:47.210]                       }
[13:20:47.210]                       invisible(muffled)
[13:20:47.210]                     }
[13:20:47.210]                     muffleCondition(cond, pattern = "^muffle")
[13:20:47.210]                   }
[13:20:47.210]                 }
[13:20:47.210]                 else {
[13:20:47.210]                   if (TRUE) {
[13:20:47.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:47.210]                     {
[13:20:47.210]                       inherits <- base::inherits
[13:20:47.210]                       invokeRestart <- base::invokeRestart
[13:20:47.210]                       is.null <- base::is.null
[13:20:47.210]                       muffled <- FALSE
[13:20:47.210]                       if (inherits(cond, "message")) {
[13:20:47.210]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:47.210]                         if (muffled) 
[13:20:47.210]                           invokeRestart("muffleMessage")
[13:20:47.210]                       }
[13:20:47.210]                       else if (inherits(cond, "warning")) {
[13:20:47.210]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:47.210]                         if (muffled) 
[13:20:47.210]                           invokeRestart("muffleWarning")
[13:20:47.210]                       }
[13:20:47.210]                       else if (inherits(cond, "condition")) {
[13:20:47.210]                         if (!is.null(pattern)) {
[13:20:47.210]                           computeRestarts <- base::computeRestarts
[13:20:47.210]                           grepl <- base::grepl
[13:20:47.210]                           restarts <- computeRestarts(cond)
[13:20:47.210]                           for (restart in restarts) {
[13:20:47.210]                             name <- restart$name
[13:20:47.210]                             if (is.null(name)) 
[13:20:47.210]                               next
[13:20:47.210]                             if (!grepl(pattern, name)) 
[13:20:47.210]                               next
[13:20:47.210]                             invokeRestart(restart)
[13:20:47.210]                             muffled <- TRUE
[13:20:47.210]                             break
[13:20:47.210]                           }
[13:20:47.210]                         }
[13:20:47.210]                       }
[13:20:47.210]                       invisible(muffled)
[13:20:47.210]                     }
[13:20:47.210]                     muffleCondition(cond, pattern = "^muffle")
[13:20:47.210]                   }
[13:20:47.210]                 }
[13:20:47.210]             }
[13:20:47.210]         }))
[13:20:47.210]     }, error = function(ex) {
[13:20:47.210]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:47.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:47.210]                 ...future.rng), started = ...future.startTime, 
[13:20:47.210]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:47.210]             version = "1.8"), class = "FutureResult")
[13:20:47.210]     }, finally = {
[13:20:47.210]         if (!identical(...future.workdir, getwd())) 
[13:20:47.210]             setwd(...future.workdir)
[13:20:47.210]         {
[13:20:47.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:47.210]                 ...future.oldOptions$nwarnings <- NULL
[13:20:47.210]             }
[13:20:47.210]             base::options(...future.oldOptions)
[13:20:47.210]             if (.Platform$OS.type == "windows") {
[13:20:47.210]                 old_names <- names(...future.oldEnvVars)
[13:20:47.210]                 envs <- base::Sys.getenv()
[13:20:47.210]                 names <- names(envs)
[13:20:47.210]                 common <- intersect(names, old_names)
[13:20:47.210]                 added <- setdiff(names, old_names)
[13:20:47.210]                 removed <- setdiff(old_names, names)
[13:20:47.210]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:47.210]                   envs[common]]
[13:20:47.210]                 NAMES <- toupper(changed)
[13:20:47.210]                 args <- list()
[13:20:47.210]                 for (kk in seq_along(NAMES)) {
[13:20:47.210]                   name <- changed[[kk]]
[13:20:47.210]                   NAME <- NAMES[[kk]]
[13:20:47.210]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:47.210]                     next
[13:20:47.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:47.210]                 }
[13:20:47.210]                 NAMES <- toupper(added)
[13:20:47.210]                 for (kk in seq_along(NAMES)) {
[13:20:47.210]                   name <- added[[kk]]
[13:20:47.210]                   NAME <- NAMES[[kk]]
[13:20:47.210]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:47.210]                     next
[13:20:47.210]                   args[[name]] <- ""
[13:20:47.210]                 }
[13:20:47.210]                 NAMES <- toupper(removed)
[13:20:47.210]                 for (kk in seq_along(NAMES)) {
[13:20:47.210]                   name <- removed[[kk]]
[13:20:47.210]                   NAME <- NAMES[[kk]]
[13:20:47.210]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:47.210]                     next
[13:20:47.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:47.210]                 }
[13:20:47.210]                 if (length(args) > 0) 
[13:20:47.210]                   base::do.call(base::Sys.setenv, args = args)
[13:20:47.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:47.210]             }
[13:20:47.210]             else {
[13:20:47.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:47.210]             }
[13:20:47.210]             {
[13:20:47.210]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:47.210]                   0L) {
[13:20:47.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:47.210]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:47.210]                   base::options(opts)
[13:20:47.210]                 }
[13:20:47.210]                 {
[13:20:47.210]                   {
[13:20:47.210]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:47.210]                     NULL
[13:20:47.210]                   }
[13:20:47.210]                   options(future.plan = NULL)
[13:20:47.210]                   if (is.na(NA_character_)) 
[13:20:47.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:47.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:47.210]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:47.210]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:47.210]                     envir = parent.frame()) 
[13:20:47.210]                   {
[13:20:47.210]                     if (is.function(workers)) 
[13:20:47.210]                       workers <- workers()
[13:20:47.210]                     workers <- structure(as.integer(workers), 
[13:20:47.210]                       class = class(workers))
[13:20:47.210]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:47.210]                       workers >= 1)
[13:20:47.210]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:47.210]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:47.210]                     }
[13:20:47.210]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:47.210]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:47.210]                       envir = envir)
[13:20:47.210]                     if (!future$lazy) 
[13:20:47.210]                       future <- run(future)
[13:20:47.210]                     invisible(future)
[13:20:47.210]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:47.210]                 }
[13:20:47.210]             }
[13:20:47.210]         }
[13:20:47.210]     })
[13:20:47.210]     if (TRUE) {
[13:20:47.210]         base::sink(type = "output", split = FALSE)
[13:20:47.210]         if (TRUE) {
[13:20:47.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:47.210]         }
[13:20:47.210]         else {
[13:20:47.210]             ...future.result["stdout"] <- base::list(NULL)
[13:20:47.210]         }
[13:20:47.210]         base::close(...future.stdout)
[13:20:47.210]         ...future.stdout <- NULL
[13:20:47.210]     }
[13:20:47.210]     ...future.result$conditions <- ...future.conditions
[13:20:47.210]     ...future.result$finished <- base::Sys.time()
[13:20:47.210]     ...future.result
[13:20:47.210] }
[13:20:47.213] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:20:47.215] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[13:20:47.215] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[13:20:47.216] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[13:20:47.216] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[13:20:47.216] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:20:47.217] MultisessionFuture started
[13:20:47.217] - Launch lazy future ... done
[13:20:47.217] run() for ‘MultisessionFuture’ ... done
[13:20:47.217] result() for ClusterFuture ...
[13:20:47.217] receiveMessageFromWorker() for ClusterFuture ...
[13:20:47.217] - Validating connection of MultisessionFuture
[13:20:47.265] - received message: FutureResult
[13:20:47.266] - Received FutureResult
[13:20:47.266] - Erased future from FutureRegistry
[13:20:47.266] result() for ClusterFuture ...
[13:20:47.266] - result already collected: FutureResult
[13:20:47.266] result() for ClusterFuture ... done
[13:20:47.266] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:47.266] result() for ClusterFuture ... done
[13:20:47.266] result() for ClusterFuture ...
[13:20:47.266] - result already collected: FutureResult
[13:20:47.266] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[13:20:47.267] plan(): Setting new future strategy stack:
[13:20:47.267] List of future strategies:
[13:20:47.267] 1. FutureStrategy:
[13:20:47.267]    - args: function (..., envir = parent.frame())
[13:20:47.267]    - tweaked: FALSE
[13:20:47.267]    - call: future::plan(oplan)
[13:20:47.268] plan(): nbrOfWorkers() = 1
> 
