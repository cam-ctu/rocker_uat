
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:12:45.698] plan(): Setting new future strategy stack:
[16:12:45.698] List of future strategies:
[16:12:45.698] 1. sequential:
[16:12:45.698]    - args: function (..., envir = parent.frame())
[16:12:45.698]    - tweaked: FALSE
[16:12:45.698]    - call: future::plan("sequential")
[16:12:45.711] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[16:12:45.778] plan(): Setting new future strategy stack:
[16:12:45.779] List of future strategies:
[16:12:45.779] 1. sequential:
[16:12:45.779]    - args: function (..., envir = parent.frame())
[16:12:45.779]    - tweaked: FALSE
[16:12:45.779]    - call: plan(strategy)
[16:12:45.790] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.791] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.791] Searching for globals...
[16:12:45.801] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:45.802] Searching for globals ... DONE
[16:12:45.802] Resolving globals: TRUE
[16:12:45.802] Resolving any globals that are futures ...
[16:12:45.802] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:45.802] Resolving any globals that are futures ... DONE
[16:12:45.803] Resolving futures part of globals (recursively) ...
[16:12:45.803] resolve() on list ...
[16:12:45.804]  recursive: 99
[16:12:45.804]  length: 1
[16:12:45.804]  elements: ‘x’
[16:12:45.804]  length: 0 (resolved future 1)
[16:12:45.804] resolve() on list ... DONE
[16:12:45.804] - globals: [1] ‘x’
[16:12:45.805] Resolving futures part of globals (recursively) ... DONE
[16:12:45.805] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:45.805] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:45.806] - globals: [1] ‘x’
[16:12:45.806] 
[16:12:45.806] getGlobalsAndPackages() ... DONE
[16:12:45.807] run() for ‘Future’ ...
[16:12:45.807] - state: ‘created’
[16:12:45.807] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.807] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.807] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.807]   - Field: ‘label’
[16:12:45.808]   - Field: ‘local’
[16:12:45.808]   - Field: ‘owner’
[16:12:45.808]   - Field: ‘envir’
[16:12:45.808]   - Field: ‘packages’
[16:12:45.808]   - Field: ‘gc’
[16:12:45.808]   - Field: ‘conditions’
[16:12:45.808]   - Field: ‘expr’
[16:12:45.808]   - Field: ‘uuid’
[16:12:45.808]   - Field: ‘seed’
[16:12:45.808]   - Field: ‘version’
[16:12:45.809]   - Field: ‘result’
[16:12:45.809]   - Field: ‘asynchronous’
[16:12:45.809]   - Field: ‘calls’
[16:12:45.809]   - Field: ‘globals’
[16:12:45.809]   - Field: ‘stdout’
[16:12:45.809]   - Field: ‘earlySignal’
[16:12:45.809]   - Field: ‘lazy’
[16:12:45.809]   - Field: ‘state’
[16:12:45.809] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.809] - Launch lazy future ...
[16:12:45.810] Packages needed by the future expression (n = 0): <none>
[16:12:45.810] Packages needed by future strategies (n = 0): <none>
[16:12:45.811] {
[16:12:45.811]     {
[16:12:45.811]         {
[16:12:45.811]             ...future.startTime <- base::Sys.time()
[16:12:45.811]             {
[16:12:45.811]                 {
[16:12:45.811]                   {
[16:12:45.811]                     base::local({
[16:12:45.811]                       has_future <- base::requireNamespace("future", 
[16:12:45.811]                         quietly = TRUE)
[16:12:45.811]                       if (has_future) {
[16:12:45.811]                         ns <- base::getNamespace("future")
[16:12:45.811]                         version <- ns[[".package"]][["version"]]
[16:12:45.811]                         if (is.null(version)) 
[16:12:45.811]                           version <- utils::packageVersion("future")
[16:12:45.811]                       }
[16:12:45.811]                       else {
[16:12:45.811]                         version <- NULL
[16:12:45.811]                       }
[16:12:45.811]                       if (!has_future || version < "1.8.0") {
[16:12:45.811]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.811]                           "", base::R.version$version.string), 
[16:12:45.811]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.811]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.811]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.811]                             "release", "version")], collapse = " "), 
[16:12:45.811]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.811]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.811]                           info)
[16:12:45.811]                         info <- base::paste(info, collapse = "; ")
[16:12:45.811]                         if (!has_future) {
[16:12:45.811]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.811]                             info)
[16:12:45.811]                         }
[16:12:45.811]                         else {
[16:12:45.811]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.811]                             info, version)
[16:12:45.811]                         }
[16:12:45.811]                         base::stop(msg)
[16:12:45.811]                       }
[16:12:45.811]                     })
[16:12:45.811]                   }
[16:12:45.811]                   options(future.plan = NULL)
[16:12:45.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.811]                 }
[16:12:45.811]                 ...future.workdir <- getwd()
[16:12:45.811]             }
[16:12:45.811]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.811]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.811]         }
[16:12:45.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.811]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.811]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.811]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.811]             base::names(...future.oldOptions))
[16:12:45.811]     }
[16:12:45.811]     if (FALSE) {
[16:12:45.811]     }
[16:12:45.811]     else {
[16:12:45.811]         if (TRUE) {
[16:12:45.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.811]                 open = "w")
[16:12:45.811]         }
[16:12:45.811]         else {
[16:12:45.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.811]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.811]         }
[16:12:45.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.811]             base::sink(type = "output", split = FALSE)
[16:12:45.811]             base::close(...future.stdout)
[16:12:45.811]         }, add = TRUE)
[16:12:45.811]     }
[16:12:45.811]     ...future.frame <- base::sys.nframe()
[16:12:45.811]     ...future.conditions <- base::list()
[16:12:45.811]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.811]     if (FALSE) {
[16:12:45.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.811]     }
[16:12:45.811]     ...future.result <- base::tryCatch({
[16:12:45.811]         base::withCallingHandlers({
[16:12:45.811]             ...future.value <- base::withVisible(base::local({
[16:12:45.811]                 x$a <- 1
[16:12:45.811]                 x
[16:12:45.811]             }))
[16:12:45.811]             future::FutureResult(value = ...future.value$value, 
[16:12:45.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.811]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.811]                     ...future.globalenv.names))
[16:12:45.811]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.811]         }, condition = base::local({
[16:12:45.811]             c <- base::c
[16:12:45.811]             inherits <- base::inherits
[16:12:45.811]             invokeRestart <- base::invokeRestart
[16:12:45.811]             length <- base::length
[16:12:45.811]             list <- base::list
[16:12:45.811]             seq.int <- base::seq.int
[16:12:45.811]             signalCondition <- base::signalCondition
[16:12:45.811]             sys.calls <- base::sys.calls
[16:12:45.811]             `[[` <- base::`[[`
[16:12:45.811]             `+` <- base::`+`
[16:12:45.811]             `<<-` <- base::`<<-`
[16:12:45.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.811]                   3L)]
[16:12:45.811]             }
[16:12:45.811]             function(cond) {
[16:12:45.811]                 is_error <- inherits(cond, "error")
[16:12:45.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.811]                   NULL)
[16:12:45.811]                 if (is_error) {
[16:12:45.811]                   sessionInformation <- function() {
[16:12:45.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.811]                       search = base::search(), system = base::Sys.info())
[16:12:45.811]                   }
[16:12:45.811]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.811]                     cond$call), session = sessionInformation(), 
[16:12:45.811]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.811]                   signalCondition(cond)
[16:12:45.811]                 }
[16:12:45.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.811]                 "immediateCondition"))) {
[16:12:45.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.811]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.811]                   if (TRUE && !signal) {
[16:12:45.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.811]                     {
[16:12:45.811]                       inherits <- base::inherits
[16:12:45.811]                       invokeRestart <- base::invokeRestart
[16:12:45.811]                       is.null <- base::is.null
[16:12:45.811]                       muffled <- FALSE
[16:12:45.811]                       if (inherits(cond, "message")) {
[16:12:45.811]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.811]                         if (muffled) 
[16:12:45.811]                           invokeRestart("muffleMessage")
[16:12:45.811]                       }
[16:12:45.811]                       else if (inherits(cond, "warning")) {
[16:12:45.811]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.811]                         if (muffled) 
[16:12:45.811]                           invokeRestart("muffleWarning")
[16:12:45.811]                       }
[16:12:45.811]                       else if (inherits(cond, "condition")) {
[16:12:45.811]                         if (!is.null(pattern)) {
[16:12:45.811]                           computeRestarts <- base::computeRestarts
[16:12:45.811]                           grepl <- base::grepl
[16:12:45.811]                           restarts <- computeRestarts(cond)
[16:12:45.811]                           for (restart in restarts) {
[16:12:45.811]                             name <- restart$name
[16:12:45.811]                             if (is.null(name)) 
[16:12:45.811]                               next
[16:12:45.811]                             if (!grepl(pattern, name)) 
[16:12:45.811]                               next
[16:12:45.811]                             invokeRestart(restart)
[16:12:45.811]                             muffled <- TRUE
[16:12:45.811]                             break
[16:12:45.811]                           }
[16:12:45.811]                         }
[16:12:45.811]                       }
[16:12:45.811]                       invisible(muffled)
[16:12:45.811]                     }
[16:12:45.811]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.811]                   }
[16:12:45.811]                 }
[16:12:45.811]                 else {
[16:12:45.811]                   if (TRUE) {
[16:12:45.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.811]                     {
[16:12:45.811]                       inherits <- base::inherits
[16:12:45.811]                       invokeRestart <- base::invokeRestart
[16:12:45.811]                       is.null <- base::is.null
[16:12:45.811]                       muffled <- FALSE
[16:12:45.811]                       if (inherits(cond, "message")) {
[16:12:45.811]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.811]                         if (muffled) 
[16:12:45.811]                           invokeRestart("muffleMessage")
[16:12:45.811]                       }
[16:12:45.811]                       else if (inherits(cond, "warning")) {
[16:12:45.811]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.811]                         if (muffled) 
[16:12:45.811]                           invokeRestart("muffleWarning")
[16:12:45.811]                       }
[16:12:45.811]                       else if (inherits(cond, "condition")) {
[16:12:45.811]                         if (!is.null(pattern)) {
[16:12:45.811]                           computeRestarts <- base::computeRestarts
[16:12:45.811]                           grepl <- base::grepl
[16:12:45.811]                           restarts <- computeRestarts(cond)
[16:12:45.811]                           for (restart in restarts) {
[16:12:45.811]                             name <- restart$name
[16:12:45.811]                             if (is.null(name)) 
[16:12:45.811]                               next
[16:12:45.811]                             if (!grepl(pattern, name)) 
[16:12:45.811]                               next
[16:12:45.811]                             invokeRestart(restart)
[16:12:45.811]                             muffled <- TRUE
[16:12:45.811]                             break
[16:12:45.811]                           }
[16:12:45.811]                         }
[16:12:45.811]                       }
[16:12:45.811]                       invisible(muffled)
[16:12:45.811]                     }
[16:12:45.811]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.811]                   }
[16:12:45.811]                 }
[16:12:45.811]             }
[16:12:45.811]         }))
[16:12:45.811]     }, error = function(ex) {
[16:12:45.811]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.811]                 ...future.rng), started = ...future.startTime, 
[16:12:45.811]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.811]             version = "1.8"), class = "FutureResult")
[16:12:45.811]     }, finally = {
[16:12:45.811]         if (!identical(...future.workdir, getwd())) 
[16:12:45.811]             setwd(...future.workdir)
[16:12:45.811]         {
[16:12:45.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.811]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.811]             }
[16:12:45.811]             base::options(...future.oldOptions)
[16:12:45.811]             if (.Platform$OS.type == "windows") {
[16:12:45.811]                 old_names <- names(...future.oldEnvVars)
[16:12:45.811]                 envs <- base::Sys.getenv()
[16:12:45.811]                 names <- names(envs)
[16:12:45.811]                 common <- intersect(names, old_names)
[16:12:45.811]                 added <- setdiff(names, old_names)
[16:12:45.811]                 removed <- setdiff(old_names, names)
[16:12:45.811]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.811]                   envs[common]]
[16:12:45.811]                 NAMES <- toupper(changed)
[16:12:45.811]                 args <- list()
[16:12:45.811]                 for (kk in seq_along(NAMES)) {
[16:12:45.811]                   name <- changed[[kk]]
[16:12:45.811]                   NAME <- NAMES[[kk]]
[16:12:45.811]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.811]                     next
[16:12:45.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.811]                 }
[16:12:45.811]                 NAMES <- toupper(added)
[16:12:45.811]                 for (kk in seq_along(NAMES)) {
[16:12:45.811]                   name <- added[[kk]]
[16:12:45.811]                   NAME <- NAMES[[kk]]
[16:12:45.811]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.811]                     next
[16:12:45.811]                   args[[name]] <- ""
[16:12:45.811]                 }
[16:12:45.811]                 NAMES <- toupper(removed)
[16:12:45.811]                 for (kk in seq_along(NAMES)) {
[16:12:45.811]                   name <- removed[[kk]]
[16:12:45.811]                   NAME <- NAMES[[kk]]
[16:12:45.811]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.811]                     next
[16:12:45.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.811]                 }
[16:12:45.811]                 if (length(args) > 0) 
[16:12:45.811]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.811]             }
[16:12:45.811]             else {
[16:12:45.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.811]             }
[16:12:45.811]             {
[16:12:45.811]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.811]                   0L) {
[16:12:45.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.811]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.811]                   base::options(opts)
[16:12:45.811]                 }
[16:12:45.811]                 {
[16:12:45.811]                   {
[16:12:45.811]                     NULL
[16:12:45.811]                     RNGkind("Mersenne-Twister")
[16:12:45.811]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.811]                       inherits = FALSE)
[16:12:45.811]                   }
[16:12:45.811]                   options(future.plan = NULL)
[16:12:45.811]                   if (is.na(NA_character_)) 
[16:12:45.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.811]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.811]                   {
[16:12:45.811]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.811]                     if (!future$lazy) 
[16:12:45.811]                       future <- run(future)
[16:12:45.811]                     invisible(future)
[16:12:45.811]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.811]                 }
[16:12:45.811]             }
[16:12:45.811]         }
[16:12:45.811]     })
[16:12:45.811]     if (TRUE) {
[16:12:45.811]         base::sink(type = "output", split = FALSE)
[16:12:45.811]         if (TRUE) {
[16:12:45.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.811]         }
[16:12:45.811]         else {
[16:12:45.811]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.811]         }
[16:12:45.811]         base::close(...future.stdout)
[16:12:45.811]         ...future.stdout <- NULL
[16:12:45.811]     }
[16:12:45.811]     ...future.result$conditions <- ...future.conditions
[16:12:45.811]     ...future.result$finished <- base::Sys.time()
[16:12:45.811]     ...future.result
[16:12:45.811] }
[16:12:45.813] assign_globals() ...
[16:12:45.813] List of 1
[16:12:45.813]  $ x: list()
[16:12:45.813]  - attr(*, "where")=List of 1
[16:12:45.813]   ..$ x:<environment: R_EmptyEnv> 
[16:12:45.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:45.813]  - attr(*, "resolved")= logi TRUE
[16:12:45.813]  - attr(*, "total_size")= num 0
[16:12:45.813]  - attr(*, "already-done")= logi TRUE
[16:12:45.816] - copied ‘x’ to environment
[16:12:45.816] assign_globals() ... done
[16:12:45.816] plan(): Setting new future strategy stack:
[16:12:45.816] List of future strategies:
[16:12:45.816] 1. sequential:
[16:12:45.816]    - args: function (..., envir = parent.frame())
[16:12:45.816]    - tweaked: FALSE
[16:12:45.816]    - call: NULL
[16:12:45.817] plan(): nbrOfWorkers() = 1
[16:12:45.818] plan(): Setting new future strategy stack:
[16:12:45.818] List of future strategies:
[16:12:45.818] 1. sequential:
[16:12:45.818]    - args: function (..., envir = parent.frame())
[16:12:45.818]    - tweaked: FALSE
[16:12:45.818]    - call: plan(strategy)
[16:12:45.819] plan(): nbrOfWorkers() = 1
[16:12:45.819] SequentialFuture started (and completed)
[16:12:45.819] - Launch lazy future ... done
[16:12:45.819] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.820] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.820] Searching for globals...
[16:12:45.822] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:45.822] Searching for globals ... DONE
[16:12:45.822] Resolving globals: TRUE
[16:12:45.822] Resolving any globals that are futures ...
[16:12:45.823] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:45.823] Resolving any globals that are futures ... DONE
[16:12:45.823] Resolving futures part of globals (recursively) ...
[16:12:45.823] resolve() on list ...
[16:12:45.823]  recursive: 99
[16:12:45.823]  length: 1
[16:12:45.824]  elements: ‘x’
[16:12:45.824]  length: 0 (resolved future 1)
[16:12:45.824] resolve() on list ... DONE
[16:12:45.824] - globals: [1] ‘x’
[16:12:45.824] Resolving futures part of globals (recursively) ... DONE
[16:12:45.824] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:45.824] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:45.825] - globals: [1] ‘x’
[16:12:45.825] 
[16:12:45.825] getGlobalsAndPackages() ... DONE
[16:12:45.825] run() for ‘Future’ ...
[16:12:45.825] - state: ‘created’
[16:12:45.825] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.826] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.826] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.826]   - Field: ‘label’
[16:12:45.826]   - Field: ‘local’
[16:12:45.826]   - Field: ‘owner’
[16:12:45.826]   - Field: ‘envir’
[16:12:45.826]   - Field: ‘packages’
[16:12:45.826]   - Field: ‘gc’
[16:12:45.826]   - Field: ‘conditions’
[16:12:45.826]   - Field: ‘expr’
[16:12:45.827]   - Field: ‘uuid’
[16:12:45.827]   - Field: ‘seed’
[16:12:45.827]   - Field: ‘version’
[16:12:45.827]   - Field: ‘result’
[16:12:45.827]   - Field: ‘asynchronous’
[16:12:45.827]   - Field: ‘calls’
[16:12:45.827]   - Field: ‘globals’
[16:12:45.827]   - Field: ‘stdout’
[16:12:45.827]   - Field: ‘earlySignal’
[16:12:45.827]   - Field: ‘lazy’
[16:12:45.827]   - Field: ‘state’
[16:12:45.828] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.828] - Launch lazy future ...
[16:12:45.828] Packages needed by the future expression (n = 0): <none>
[16:12:45.828] Packages needed by future strategies (n = 0): <none>
[16:12:45.828] {
[16:12:45.828]     {
[16:12:45.828]         {
[16:12:45.828]             ...future.startTime <- base::Sys.time()
[16:12:45.828]             {
[16:12:45.828]                 {
[16:12:45.828]                   {
[16:12:45.828]                     base::local({
[16:12:45.828]                       has_future <- base::requireNamespace("future", 
[16:12:45.828]                         quietly = TRUE)
[16:12:45.828]                       if (has_future) {
[16:12:45.828]                         ns <- base::getNamespace("future")
[16:12:45.828]                         version <- ns[[".package"]][["version"]]
[16:12:45.828]                         if (is.null(version)) 
[16:12:45.828]                           version <- utils::packageVersion("future")
[16:12:45.828]                       }
[16:12:45.828]                       else {
[16:12:45.828]                         version <- NULL
[16:12:45.828]                       }
[16:12:45.828]                       if (!has_future || version < "1.8.0") {
[16:12:45.828]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.828]                           "", base::R.version$version.string), 
[16:12:45.828]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.828]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.828]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.828]                             "release", "version")], collapse = " "), 
[16:12:45.828]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.828]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.828]                           info)
[16:12:45.828]                         info <- base::paste(info, collapse = "; ")
[16:12:45.828]                         if (!has_future) {
[16:12:45.828]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.828]                             info)
[16:12:45.828]                         }
[16:12:45.828]                         else {
[16:12:45.828]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.828]                             info, version)
[16:12:45.828]                         }
[16:12:45.828]                         base::stop(msg)
[16:12:45.828]                       }
[16:12:45.828]                     })
[16:12:45.828]                   }
[16:12:45.828]                   options(future.plan = NULL)
[16:12:45.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.828]                 }
[16:12:45.828]                 ...future.workdir <- getwd()
[16:12:45.828]             }
[16:12:45.828]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.828]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.828]         }
[16:12:45.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.828]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.828]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.828]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.828]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.828]             base::names(...future.oldOptions))
[16:12:45.828]     }
[16:12:45.828]     if (FALSE) {
[16:12:45.828]     }
[16:12:45.828]     else {
[16:12:45.828]         if (TRUE) {
[16:12:45.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.828]                 open = "w")
[16:12:45.828]         }
[16:12:45.828]         else {
[16:12:45.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.828]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.828]         }
[16:12:45.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.828]             base::sink(type = "output", split = FALSE)
[16:12:45.828]             base::close(...future.stdout)
[16:12:45.828]         }, add = TRUE)
[16:12:45.828]     }
[16:12:45.828]     ...future.frame <- base::sys.nframe()
[16:12:45.828]     ...future.conditions <- base::list()
[16:12:45.828]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.828]     if (FALSE) {
[16:12:45.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.828]     }
[16:12:45.828]     ...future.result <- base::tryCatch({
[16:12:45.828]         base::withCallingHandlers({
[16:12:45.828]             ...future.value <- base::withVisible(base::local({
[16:12:45.828]                 x$a <- 1
[16:12:45.828]                 x
[16:12:45.828]             }))
[16:12:45.828]             future::FutureResult(value = ...future.value$value, 
[16:12:45.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.828]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.828]                     ...future.globalenv.names))
[16:12:45.828]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.828]         }, condition = base::local({
[16:12:45.828]             c <- base::c
[16:12:45.828]             inherits <- base::inherits
[16:12:45.828]             invokeRestart <- base::invokeRestart
[16:12:45.828]             length <- base::length
[16:12:45.828]             list <- base::list
[16:12:45.828]             seq.int <- base::seq.int
[16:12:45.828]             signalCondition <- base::signalCondition
[16:12:45.828]             sys.calls <- base::sys.calls
[16:12:45.828]             `[[` <- base::`[[`
[16:12:45.828]             `+` <- base::`+`
[16:12:45.828]             `<<-` <- base::`<<-`
[16:12:45.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.828]                   3L)]
[16:12:45.828]             }
[16:12:45.828]             function(cond) {
[16:12:45.828]                 is_error <- inherits(cond, "error")
[16:12:45.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.828]                   NULL)
[16:12:45.828]                 if (is_error) {
[16:12:45.828]                   sessionInformation <- function() {
[16:12:45.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.828]                       search = base::search(), system = base::Sys.info())
[16:12:45.828]                   }
[16:12:45.828]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.828]                     cond$call), session = sessionInformation(), 
[16:12:45.828]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.828]                   signalCondition(cond)
[16:12:45.828]                 }
[16:12:45.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.828]                 "immediateCondition"))) {
[16:12:45.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.828]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.828]                   if (TRUE && !signal) {
[16:12:45.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.828]                     {
[16:12:45.828]                       inherits <- base::inherits
[16:12:45.828]                       invokeRestart <- base::invokeRestart
[16:12:45.828]                       is.null <- base::is.null
[16:12:45.828]                       muffled <- FALSE
[16:12:45.828]                       if (inherits(cond, "message")) {
[16:12:45.828]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.828]                         if (muffled) 
[16:12:45.828]                           invokeRestart("muffleMessage")
[16:12:45.828]                       }
[16:12:45.828]                       else if (inherits(cond, "warning")) {
[16:12:45.828]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.828]                         if (muffled) 
[16:12:45.828]                           invokeRestart("muffleWarning")
[16:12:45.828]                       }
[16:12:45.828]                       else if (inherits(cond, "condition")) {
[16:12:45.828]                         if (!is.null(pattern)) {
[16:12:45.828]                           computeRestarts <- base::computeRestarts
[16:12:45.828]                           grepl <- base::grepl
[16:12:45.828]                           restarts <- computeRestarts(cond)
[16:12:45.828]                           for (restart in restarts) {
[16:12:45.828]                             name <- restart$name
[16:12:45.828]                             if (is.null(name)) 
[16:12:45.828]                               next
[16:12:45.828]                             if (!grepl(pattern, name)) 
[16:12:45.828]                               next
[16:12:45.828]                             invokeRestart(restart)
[16:12:45.828]                             muffled <- TRUE
[16:12:45.828]                             break
[16:12:45.828]                           }
[16:12:45.828]                         }
[16:12:45.828]                       }
[16:12:45.828]                       invisible(muffled)
[16:12:45.828]                     }
[16:12:45.828]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.828]                   }
[16:12:45.828]                 }
[16:12:45.828]                 else {
[16:12:45.828]                   if (TRUE) {
[16:12:45.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.828]                     {
[16:12:45.828]                       inherits <- base::inherits
[16:12:45.828]                       invokeRestart <- base::invokeRestart
[16:12:45.828]                       is.null <- base::is.null
[16:12:45.828]                       muffled <- FALSE
[16:12:45.828]                       if (inherits(cond, "message")) {
[16:12:45.828]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.828]                         if (muffled) 
[16:12:45.828]                           invokeRestart("muffleMessage")
[16:12:45.828]                       }
[16:12:45.828]                       else if (inherits(cond, "warning")) {
[16:12:45.828]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.828]                         if (muffled) 
[16:12:45.828]                           invokeRestart("muffleWarning")
[16:12:45.828]                       }
[16:12:45.828]                       else if (inherits(cond, "condition")) {
[16:12:45.828]                         if (!is.null(pattern)) {
[16:12:45.828]                           computeRestarts <- base::computeRestarts
[16:12:45.828]                           grepl <- base::grepl
[16:12:45.828]                           restarts <- computeRestarts(cond)
[16:12:45.828]                           for (restart in restarts) {
[16:12:45.828]                             name <- restart$name
[16:12:45.828]                             if (is.null(name)) 
[16:12:45.828]                               next
[16:12:45.828]                             if (!grepl(pattern, name)) 
[16:12:45.828]                               next
[16:12:45.828]                             invokeRestart(restart)
[16:12:45.828]                             muffled <- TRUE
[16:12:45.828]                             break
[16:12:45.828]                           }
[16:12:45.828]                         }
[16:12:45.828]                       }
[16:12:45.828]                       invisible(muffled)
[16:12:45.828]                     }
[16:12:45.828]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.828]                   }
[16:12:45.828]                 }
[16:12:45.828]             }
[16:12:45.828]         }))
[16:12:45.828]     }, error = function(ex) {
[16:12:45.828]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.828]                 ...future.rng), started = ...future.startTime, 
[16:12:45.828]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.828]             version = "1.8"), class = "FutureResult")
[16:12:45.828]     }, finally = {
[16:12:45.828]         if (!identical(...future.workdir, getwd())) 
[16:12:45.828]             setwd(...future.workdir)
[16:12:45.828]         {
[16:12:45.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.828]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.828]             }
[16:12:45.828]             base::options(...future.oldOptions)
[16:12:45.828]             if (.Platform$OS.type == "windows") {
[16:12:45.828]                 old_names <- names(...future.oldEnvVars)
[16:12:45.828]                 envs <- base::Sys.getenv()
[16:12:45.828]                 names <- names(envs)
[16:12:45.828]                 common <- intersect(names, old_names)
[16:12:45.828]                 added <- setdiff(names, old_names)
[16:12:45.828]                 removed <- setdiff(old_names, names)
[16:12:45.828]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.828]                   envs[common]]
[16:12:45.828]                 NAMES <- toupper(changed)
[16:12:45.828]                 args <- list()
[16:12:45.828]                 for (kk in seq_along(NAMES)) {
[16:12:45.828]                   name <- changed[[kk]]
[16:12:45.828]                   NAME <- NAMES[[kk]]
[16:12:45.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.828]                     next
[16:12:45.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.828]                 }
[16:12:45.828]                 NAMES <- toupper(added)
[16:12:45.828]                 for (kk in seq_along(NAMES)) {
[16:12:45.828]                   name <- added[[kk]]
[16:12:45.828]                   NAME <- NAMES[[kk]]
[16:12:45.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.828]                     next
[16:12:45.828]                   args[[name]] <- ""
[16:12:45.828]                 }
[16:12:45.828]                 NAMES <- toupper(removed)
[16:12:45.828]                 for (kk in seq_along(NAMES)) {
[16:12:45.828]                   name <- removed[[kk]]
[16:12:45.828]                   NAME <- NAMES[[kk]]
[16:12:45.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.828]                     next
[16:12:45.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.828]                 }
[16:12:45.828]                 if (length(args) > 0) 
[16:12:45.828]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.828]             }
[16:12:45.828]             else {
[16:12:45.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.828]             }
[16:12:45.828]             {
[16:12:45.828]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.828]                   0L) {
[16:12:45.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.828]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.828]                   base::options(opts)
[16:12:45.828]                 }
[16:12:45.828]                 {
[16:12:45.828]                   {
[16:12:45.828]                     NULL
[16:12:45.828]                     RNGkind("Mersenne-Twister")
[16:12:45.828]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.828]                       inherits = FALSE)
[16:12:45.828]                   }
[16:12:45.828]                   options(future.plan = NULL)
[16:12:45.828]                   if (is.na(NA_character_)) 
[16:12:45.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.828]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.828]                   {
[16:12:45.828]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.828]                     if (!future$lazy) 
[16:12:45.828]                       future <- run(future)
[16:12:45.828]                     invisible(future)
[16:12:45.828]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.828]                 }
[16:12:45.828]             }
[16:12:45.828]         }
[16:12:45.828]     })
[16:12:45.828]     if (TRUE) {
[16:12:45.828]         base::sink(type = "output", split = FALSE)
[16:12:45.828]         if (TRUE) {
[16:12:45.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.828]         }
[16:12:45.828]         else {
[16:12:45.828]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.828]         }
[16:12:45.828]         base::close(...future.stdout)
[16:12:45.828]         ...future.stdout <- NULL
[16:12:45.828]     }
[16:12:45.828]     ...future.result$conditions <- ...future.conditions
[16:12:45.828]     ...future.result$finished <- base::Sys.time()
[16:12:45.828]     ...future.result
[16:12:45.828] }
[16:12:45.830] assign_globals() ...
[16:12:45.830] List of 1
[16:12:45.830]  $ x: list()
[16:12:45.830]  - attr(*, "where")=List of 1
[16:12:45.830]   ..$ x:<environment: R_EmptyEnv> 
[16:12:45.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:45.830]  - attr(*, "resolved")= logi TRUE
[16:12:45.830]  - attr(*, "total_size")= num 0
[16:12:45.830]  - attr(*, "already-done")= logi TRUE
[16:12:45.833] - copied ‘x’ to environment
[16:12:45.833] assign_globals() ... done
[16:12:45.833] plan(): Setting new future strategy stack:
[16:12:45.836] List of future strategies:
[16:12:45.836] 1. sequential:
[16:12:45.836]    - args: function (..., envir = parent.frame())
[16:12:45.836]    - tweaked: FALSE
[16:12:45.836]    - call: NULL
[16:12:45.836] plan(): nbrOfWorkers() = 1
[16:12:45.837] plan(): Setting new future strategy stack:
[16:12:45.837] List of future strategies:
[16:12:45.837] 1. sequential:
[16:12:45.837]    - args: function (..., envir = parent.frame())
[16:12:45.837]    - tweaked: FALSE
[16:12:45.837]    - call: plan(strategy)
[16:12:45.837] plan(): nbrOfWorkers() = 1
[16:12:45.837] SequentialFuture started (and completed)
[16:12:45.838] - Launch lazy future ... done
[16:12:45.838] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.839] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.839] Searching for globals...
[16:12:45.841] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:45.841] Searching for globals ... DONE
[16:12:45.841] Resolving globals: TRUE
[16:12:45.842] Resolving any globals that are futures ...
[16:12:45.842] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:45.842] Resolving any globals that are futures ... DONE
[16:12:45.842] Resolving futures part of globals (recursively) ...
[16:12:45.842] resolve() on list ...
[16:12:45.842]  recursive: 99
[16:12:45.843]  length: 1
[16:12:45.843]  elements: ‘x’
[16:12:45.843]  length: 0 (resolved future 1)
[16:12:45.843] resolve() on list ... DONE
[16:12:45.843] - globals: [1] ‘x’
[16:12:45.843] Resolving futures part of globals (recursively) ... DONE
[16:12:45.843] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:45.844] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:45.844] - globals: [1] ‘x’
[16:12:45.844] 
[16:12:45.844] getGlobalsAndPackages() ... DONE
[16:12:45.844] run() for ‘Future’ ...
[16:12:45.844] - state: ‘created’
[16:12:45.844] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.845] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.845] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.845]   - Field: ‘label’
[16:12:45.845]   - Field: ‘local’
[16:12:45.845]   - Field: ‘owner’
[16:12:45.845]   - Field: ‘envir’
[16:12:45.845]   - Field: ‘packages’
[16:12:45.845]   - Field: ‘gc’
[16:12:45.845]   - Field: ‘conditions’
[16:12:45.845]   - Field: ‘expr’
[16:12:45.846]   - Field: ‘uuid’
[16:12:45.846]   - Field: ‘seed’
[16:12:45.846]   - Field: ‘version’
[16:12:45.846]   - Field: ‘result’
[16:12:45.846]   - Field: ‘asynchronous’
[16:12:45.846]   - Field: ‘calls’
[16:12:45.846]   - Field: ‘globals’
[16:12:45.846]   - Field: ‘stdout’
[16:12:45.846]   - Field: ‘earlySignal’
[16:12:45.846]   - Field: ‘lazy’
[16:12:45.846]   - Field: ‘state’
[16:12:45.847] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.847] - Launch lazy future ...
[16:12:45.847] Packages needed by the future expression (n = 0): <none>
[16:12:45.847] Packages needed by future strategies (n = 0): <none>
[16:12:45.847] {
[16:12:45.847]     {
[16:12:45.847]         {
[16:12:45.847]             ...future.startTime <- base::Sys.time()
[16:12:45.847]             {
[16:12:45.847]                 {
[16:12:45.847]                   {
[16:12:45.847]                     base::local({
[16:12:45.847]                       has_future <- base::requireNamespace("future", 
[16:12:45.847]                         quietly = TRUE)
[16:12:45.847]                       if (has_future) {
[16:12:45.847]                         ns <- base::getNamespace("future")
[16:12:45.847]                         version <- ns[[".package"]][["version"]]
[16:12:45.847]                         if (is.null(version)) 
[16:12:45.847]                           version <- utils::packageVersion("future")
[16:12:45.847]                       }
[16:12:45.847]                       else {
[16:12:45.847]                         version <- NULL
[16:12:45.847]                       }
[16:12:45.847]                       if (!has_future || version < "1.8.0") {
[16:12:45.847]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.847]                           "", base::R.version$version.string), 
[16:12:45.847]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.847]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.847]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.847]                             "release", "version")], collapse = " "), 
[16:12:45.847]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.847]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.847]                           info)
[16:12:45.847]                         info <- base::paste(info, collapse = "; ")
[16:12:45.847]                         if (!has_future) {
[16:12:45.847]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.847]                             info)
[16:12:45.847]                         }
[16:12:45.847]                         else {
[16:12:45.847]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.847]                             info, version)
[16:12:45.847]                         }
[16:12:45.847]                         base::stop(msg)
[16:12:45.847]                       }
[16:12:45.847]                     })
[16:12:45.847]                   }
[16:12:45.847]                   options(future.plan = NULL)
[16:12:45.847]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.847]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.847]                 }
[16:12:45.847]                 ...future.workdir <- getwd()
[16:12:45.847]             }
[16:12:45.847]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.847]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.847]         }
[16:12:45.847]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.847]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.847]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.847]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.847]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.847]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.847]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.847]             base::names(...future.oldOptions))
[16:12:45.847]     }
[16:12:45.847]     if (FALSE) {
[16:12:45.847]     }
[16:12:45.847]     else {
[16:12:45.847]         if (TRUE) {
[16:12:45.847]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.847]                 open = "w")
[16:12:45.847]         }
[16:12:45.847]         else {
[16:12:45.847]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.847]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.847]         }
[16:12:45.847]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.847]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.847]             base::sink(type = "output", split = FALSE)
[16:12:45.847]             base::close(...future.stdout)
[16:12:45.847]         }, add = TRUE)
[16:12:45.847]     }
[16:12:45.847]     ...future.frame <- base::sys.nframe()
[16:12:45.847]     ...future.conditions <- base::list()
[16:12:45.847]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.847]     if (FALSE) {
[16:12:45.847]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.847]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.847]     }
[16:12:45.847]     ...future.result <- base::tryCatch({
[16:12:45.847]         base::withCallingHandlers({
[16:12:45.847]             ...future.value <- base::withVisible(base::local({
[16:12:45.847]                 x$a <- 1
[16:12:45.847]                 x
[16:12:45.847]             }))
[16:12:45.847]             future::FutureResult(value = ...future.value$value, 
[16:12:45.847]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.847]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.847]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.847]                     ...future.globalenv.names))
[16:12:45.847]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.847]         }, condition = base::local({
[16:12:45.847]             c <- base::c
[16:12:45.847]             inherits <- base::inherits
[16:12:45.847]             invokeRestart <- base::invokeRestart
[16:12:45.847]             length <- base::length
[16:12:45.847]             list <- base::list
[16:12:45.847]             seq.int <- base::seq.int
[16:12:45.847]             signalCondition <- base::signalCondition
[16:12:45.847]             sys.calls <- base::sys.calls
[16:12:45.847]             `[[` <- base::`[[`
[16:12:45.847]             `+` <- base::`+`
[16:12:45.847]             `<<-` <- base::`<<-`
[16:12:45.847]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.847]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.847]                   3L)]
[16:12:45.847]             }
[16:12:45.847]             function(cond) {
[16:12:45.847]                 is_error <- inherits(cond, "error")
[16:12:45.847]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.847]                   NULL)
[16:12:45.847]                 if (is_error) {
[16:12:45.847]                   sessionInformation <- function() {
[16:12:45.847]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.847]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.847]                       search = base::search(), system = base::Sys.info())
[16:12:45.847]                   }
[16:12:45.847]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.847]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.847]                     cond$call), session = sessionInformation(), 
[16:12:45.847]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.847]                   signalCondition(cond)
[16:12:45.847]                 }
[16:12:45.847]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.847]                 "immediateCondition"))) {
[16:12:45.847]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.847]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.847]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.847]                   if (TRUE && !signal) {
[16:12:45.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.847]                     {
[16:12:45.847]                       inherits <- base::inherits
[16:12:45.847]                       invokeRestart <- base::invokeRestart
[16:12:45.847]                       is.null <- base::is.null
[16:12:45.847]                       muffled <- FALSE
[16:12:45.847]                       if (inherits(cond, "message")) {
[16:12:45.847]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.847]                         if (muffled) 
[16:12:45.847]                           invokeRestart("muffleMessage")
[16:12:45.847]                       }
[16:12:45.847]                       else if (inherits(cond, "warning")) {
[16:12:45.847]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.847]                         if (muffled) 
[16:12:45.847]                           invokeRestart("muffleWarning")
[16:12:45.847]                       }
[16:12:45.847]                       else if (inherits(cond, "condition")) {
[16:12:45.847]                         if (!is.null(pattern)) {
[16:12:45.847]                           computeRestarts <- base::computeRestarts
[16:12:45.847]                           grepl <- base::grepl
[16:12:45.847]                           restarts <- computeRestarts(cond)
[16:12:45.847]                           for (restart in restarts) {
[16:12:45.847]                             name <- restart$name
[16:12:45.847]                             if (is.null(name)) 
[16:12:45.847]                               next
[16:12:45.847]                             if (!grepl(pattern, name)) 
[16:12:45.847]                               next
[16:12:45.847]                             invokeRestart(restart)
[16:12:45.847]                             muffled <- TRUE
[16:12:45.847]                             break
[16:12:45.847]                           }
[16:12:45.847]                         }
[16:12:45.847]                       }
[16:12:45.847]                       invisible(muffled)
[16:12:45.847]                     }
[16:12:45.847]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.847]                   }
[16:12:45.847]                 }
[16:12:45.847]                 else {
[16:12:45.847]                   if (TRUE) {
[16:12:45.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.847]                     {
[16:12:45.847]                       inherits <- base::inherits
[16:12:45.847]                       invokeRestart <- base::invokeRestart
[16:12:45.847]                       is.null <- base::is.null
[16:12:45.847]                       muffled <- FALSE
[16:12:45.847]                       if (inherits(cond, "message")) {
[16:12:45.847]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.847]                         if (muffled) 
[16:12:45.847]                           invokeRestart("muffleMessage")
[16:12:45.847]                       }
[16:12:45.847]                       else if (inherits(cond, "warning")) {
[16:12:45.847]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.847]                         if (muffled) 
[16:12:45.847]                           invokeRestart("muffleWarning")
[16:12:45.847]                       }
[16:12:45.847]                       else if (inherits(cond, "condition")) {
[16:12:45.847]                         if (!is.null(pattern)) {
[16:12:45.847]                           computeRestarts <- base::computeRestarts
[16:12:45.847]                           grepl <- base::grepl
[16:12:45.847]                           restarts <- computeRestarts(cond)
[16:12:45.847]                           for (restart in restarts) {
[16:12:45.847]                             name <- restart$name
[16:12:45.847]                             if (is.null(name)) 
[16:12:45.847]                               next
[16:12:45.847]                             if (!grepl(pattern, name)) 
[16:12:45.847]                               next
[16:12:45.847]                             invokeRestart(restart)
[16:12:45.847]                             muffled <- TRUE
[16:12:45.847]                             break
[16:12:45.847]                           }
[16:12:45.847]                         }
[16:12:45.847]                       }
[16:12:45.847]                       invisible(muffled)
[16:12:45.847]                     }
[16:12:45.847]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.847]                   }
[16:12:45.847]                 }
[16:12:45.847]             }
[16:12:45.847]         }))
[16:12:45.847]     }, error = function(ex) {
[16:12:45.847]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.847]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.847]                 ...future.rng), started = ...future.startTime, 
[16:12:45.847]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.847]             version = "1.8"), class = "FutureResult")
[16:12:45.847]     }, finally = {
[16:12:45.847]         if (!identical(...future.workdir, getwd())) 
[16:12:45.847]             setwd(...future.workdir)
[16:12:45.847]         {
[16:12:45.847]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.847]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.847]             }
[16:12:45.847]             base::options(...future.oldOptions)
[16:12:45.847]             if (.Platform$OS.type == "windows") {
[16:12:45.847]                 old_names <- names(...future.oldEnvVars)
[16:12:45.847]                 envs <- base::Sys.getenv()
[16:12:45.847]                 names <- names(envs)
[16:12:45.847]                 common <- intersect(names, old_names)
[16:12:45.847]                 added <- setdiff(names, old_names)
[16:12:45.847]                 removed <- setdiff(old_names, names)
[16:12:45.847]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.847]                   envs[common]]
[16:12:45.847]                 NAMES <- toupper(changed)
[16:12:45.847]                 args <- list()
[16:12:45.847]                 for (kk in seq_along(NAMES)) {
[16:12:45.847]                   name <- changed[[kk]]
[16:12:45.847]                   NAME <- NAMES[[kk]]
[16:12:45.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.847]                     next
[16:12:45.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.847]                 }
[16:12:45.847]                 NAMES <- toupper(added)
[16:12:45.847]                 for (kk in seq_along(NAMES)) {
[16:12:45.847]                   name <- added[[kk]]
[16:12:45.847]                   NAME <- NAMES[[kk]]
[16:12:45.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.847]                     next
[16:12:45.847]                   args[[name]] <- ""
[16:12:45.847]                 }
[16:12:45.847]                 NAMES <- toupper(removed)
[16:12:45.847]                 for (kk in seq_along(NAMES)) {
[16:12:45.847]                   name <- removed[[kk]]
[16:12:45.847]                   NAME <- NAMES[[kk]]
[16:12:45.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.847]                     next
[16:12:45.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.847]                 }
[16:12:45.847]                 if (length(args) > 0) 
[16:12:45.847]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.847]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.847]             }
[16:12:45.847]             else {
[16:12:45.847]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.847]             }
[16:12:45.847]             {
[16:12:45.847]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.847]                   0L) {
[16:12:45.847]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.847]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.847]                   base::options(opts)
[16:12:45.847]                 }
[16:12:45.847]                 {
[16:12:45.847]                   {
[16:12:45.847]                     NULL
[16:12:45.847]                     RNGkind("Mersenne-Twister")
[16:12:45.847]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.847]                       inherits = FALSE)
[16:12:45.847]                   }
[16:12:45.847]                   options(future.plan = NULL)
[16:12:45.847]                   if (is.na(NA_character_)) 
[16:12:45.847]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.847]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.847]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.847]                   {
[16:12:45.847]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.847]                     if (!future$lazy) 
[16:12:45.847]                       future <- run(future)
[16:12:45.847]                     invisible(future)
[16:12:45.847]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.847]                 }
[16:12:45.847]             }
[16:12:45.847]         }
[16:12:45.847]     })
[16:12:45.847]     if (TRUE) {
[16:12:45.847]         base::sink(type = "output", split = FALSE)
[16:12:45.847]         if (TRUE) {
[16:12:45.847]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.847]         }
[16:12:45.847]         else {
[16:12:45.847]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.847]         }
[16:12:45.847]         base::close(...future.stdout)
[16:12:45.847]         ...future.stdout <- NULL
[16:12:45.847]     }
[16:12:45.847]     ...future.result$conditions <- ...future.conditions
[16:12:45.847]     ...future.result$finished <- base::Sys.time()
[16:12:45.847]     ...future.result
[16:12:45.847] }
[16:12:45.849] assign_globals() ...
[16:12:45.849] List of 1
[16:12:45.849]  $ x: list()
[16:12:45.849]  - attr(*, "where")=List of 1
[16:12:45.849]   ..$ x:<environment: R_EmptyEnv> 
[16:12:45.849]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:45.849]  - attr(*, "resolved")= logi TRUE
[16:12:45.849]  - attr(*, "total_size")= num 0
[16:12:45.849]  - attr(*, "already-done")= logi TRUE
[16:12:45.852] - copied ‘x’ to environment
[16:12:45.852] assign_globals() ... done
[16:12:45.852] plan(): Setting new future strategy stack:
[16:12:45.852] List of future strategies:
[16:12:45.852] 1. sequential:
[16:12:45.852]    - args: function (..., envir = parent.frame())
[16:12:45.852]    - tweaked: FALSE
[16:12:45.852]    - call: NULL
[16:12:45.853] plan(): nbrOfWorkers() = 1
[16:12:45.853] plan(): Setting new future strategy stack:
[16:12:45.853] List of future strategies:
[16:12:45.853] 1. sequential:
[16:12:45.853]    - args: function (..., envir = parent.frame())
[16:12:45.853]    - tweaked: FALSE
[16:12:45.853]    - call: plan(strategy)
[16:12:45.854] plan(): nbrOfWorkers() = 1
[16:12:45.854] SequentialFuture started (and completed)
[16:12:45.854] - Launch lazy future ... done
[16:12:45.854] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.855] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.855] Searching for globals...
[16:12:45.857] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:45.857] Searching for globals ... DONE
[16:12:45.857] Resolving globals: TRUE
[16:12:45.857] Resolving any globals that are futures ...
[16:12:45.857] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:45.857] Resolving any globals that are futures ... DONE
[16:12:45.858] Resolving futures part of globals (recursively) ...
[16:12:45.858] resolve() on list ...
[16:12:45.858]  recursive: 99
[16:12:45.858]  length: 1
[16:12:45.858]  elements: ‘x’
[16:12:45.858]  length: 0 (resolved future 1)
[16:12:45.859] resolve() on list ... DONE
[16:12:45.859] - globals: [1] ‘x’
[16:12:45.859] Resolving futures part of globals (recursively) ... DONE
[16:12:45.859] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:45.859] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:45.859] - globals: [1] ‘x’
[16:12:45.859] 
[16:12:45.859] getGlobalsAndPackages() ... DONE
[16:12:45.860] run() for ‘Future’ ...
[16:12:45.860] - state: ‘created’
[16:12:45.860] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.860] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.860] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.861]   - Field: ‘label’
[16:12:45.861]   - Field: ‘local’
[16:12:45.861]   - Field: ‘owner’
[16:12:45.861]   - Field: ‘envir’
[16:12:45.861]   - Field: ‘packages’
[16:12:45.861]   - Field: ‘gc’
[16:12:45.861]   - Field: ‘conditions’
[16:12:45.861]   - Field: ‘expr’
[16:12:45.861]   - Field: ‘uuid’
[16:12:45.861]   - Field: ‘seed’
[16:12:45.862]   - Field: ‘version’
[16:12:45.862]   - Field: ‘result’
[16:12:45.862]   - Field: ‘asynchronous’
[16:12:45.862]   - Field: ‘calls’
[16:12:45.862]   - Field: ‘globals’
[16:12:45.862]   - Field: ‘stdout’
[16:12:45.862]   - Field: ‘earlySignal’
[16:12:45.862]   - Field: ‘lazy’
[16:12:45.862]   - Field: ‘state’
[16:12:45.862] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.862] - Launch lazy future ...
[16:12:45.865] Packages needed by the future expression (n = 0): <none>
[16:12:45.865] Packages needed by future strategies (n = 0): <none>
[16:12:45.865] {
[16:12:45.865]     {
[16:12:45.865]         {
[16:12:45.865]             ...future.startTime <- base::Sys.time()
[16:12:45.865]             {
[16:12:45.865]                 {
[16:12:45.865]                   {
[16:12:45.865]                     base::local({
[16:12:45.865]                       has_future <- base::requireNamespace("future", 
[16:12:45.865]                         quietly = TRUE)
[16:12:45.865]                       if (has_future) {
[16:12:45.865]                         ns <- base::getNamespace("future")
[16:12:45.865]                         version <- ns[[".package"]][["version"]]
[16:12:45.865]                         if (is.null(version)) 
[16:12:45.865]                           version <- utils::packageVersion("future")
[16:12:45.865]                       }
[16:12:45.865]                       else {
[16:12:45.865]                         version <- NULL
[16:12:45.865]                       }
[16:12:45.865]                       if (!has_future || version < "1.8.0") {
[16:12:45.865]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.865]                           "", base::R.version$version.string), 
[16:12:45.865]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.865]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.865]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.865]                             "release", "version")], collapse = " "), 
[16:12:45.865]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.865]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.865]                           info)
[16:12:45.865]                         info <- base::paste(info, collapse = "; ")
[16:12:45.865]                         if (!has_future) {
[16:12:45.865]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.865]                             info)
[16:12:45.865]                         }
[16:12:45.865]                         else {
[16:12:45.865]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.865]                             info, version)
[16:12:45.865]                         }
[16:12:45.865]                         base::stop(msg)
[16:12:45.865]                       }
[16:12:45.865]                     })
[16:12:45.865]                   }
[16:12:45.865]                   options(future.plan = NULL)
[16:12:45.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.865]                 }
[16:12:45.865]                 ...future.workdir <- getwd()
[16:12:45.865]             }
[16:12:45.865]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.865]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.865]         }
[16:12:45.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.865]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.865]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.865]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.865]             base::names(...future.oldOptions))
[16:12:45.865]     }
[16:12:45.865]     if (FALSE) {
[16:12:45.865]     }
[16:12:45.865]     else {
[16:12:45.865]         if (TRUE) {
[16:12:45.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.865]                 open = "w")
[16:12:45.865]         }
[16:12:45.865]         else {
[16:12:45.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.865]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.865]         }
[16:12:45.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.865]             base::sink(type = "output", split = FALSE)
[16:12:45.865]             base::close(...future.stdout)
[16:12:45.865]         }, add = TRUE)
[16:12:45.865]     }
[16:12:45.865]     ...future.frame <- base::sys.nframe()
[16:12:45.865]     ...future.conditions <- base::list()
[16:12:45.865]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.865]     if (FALSE) {
[16:12:45.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.865]     }
[16:12:45.865]     ...future.result <- base::tryCatch({
[16:12:45.865]         base::withCallingHandlers({
[16:12:45.865]             ...future.value <- base::withVisible(base::local({
[16:12:45.865]                 x$a <- 1
[16:12:45.865]                 x
[16:12:45.865]             }))
[16:12:45.865]             future::FutureResult(value = ...future.value$value, 
[16:12:45.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.865]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.865]                     ...future.globalenv.names))
[16:12:45.865]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.865]         }, condition = base::local({
[16:12:45.865]             c <- base::c
[16:12:45.865]             inherits <- base::inherits
[16:12:45.865]             invokeRestart <- base::invokeRestart
[16:12:45.865]             length <- base::length
[16:12:45.865]             list <- base::list
[16:12:45.865]             seq.int <- base::seq.int
[16:12:45.865]             signalCondition <- base::signalCondition
[16:12:45.865]             sys.calls <- base::sys.calls
[16:12:45.865]             `[[` <- base::`[[`
[16:12:45.865]             `+` <- base::`+`
[16:12:45.865]             `<<-` <- base::`<<-`
[16:12:45.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.865]                   3L)]
[16:12:45.865]             }
[16:12:45.865]             function(cond) {
[16:12:45.865]                 is_error <- inherits(cond, "error")
[16:12:45.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.865]                   NULL)
[16:12:45.865]                 if (is_error) {
[16:12:45.865]                   sessionInformation <- function() {
[16:12:45.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.865]                       search = base::search(), system = base::Sys.info())
[16:12:45.865]                   }
[16:12:45.865]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.865]                     cond$call), session = sessionInformation(), 
[16:12:45.865]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.865]                   signalCondition(cond)
[16:12:45.865]                 }
[16:12:45.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.865]                 "immediateCondition"))) {
[16:12:45.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.865]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.865]                   if (TRUE && !signal) {
[16:12:45.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.865]                     {
[16:12:45.865]                       inherits <- base::inherits
[16:12:45.865]                       invokeRestart <- base::invokeRestart
[16:12:45.865]                       is.null <- base::is.null
[16:12:45.865]                       muffled <- FALSE
[16:12:45.865]                       if (inherits(cond, "message")) {
[16:12:45.865]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.865]                         if (muffled) 
[16:12:45.865]                           invokeRestart("muffleMessage")
[16:12:45.865]                       }
[16:12:45.865]                       else if (inherits(cond, "warning")) {
[16:12:45.865]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.865]                         if (muffled) 
[16:12:45.865]                           invokeRestart("muffleWarning")
[16:12:45.865]                       }
[16:12:45.865]                       else if (inherits(cond, "condition")) {
[16:12:45.865]                         if (!is.null(pattern)) {
[16:12:45.865]                           computeRestarts <- base::computeRestarts
[16:12:45.865]                           grepl <- base::grepl
[16:12:45.865]                           restarts <- computeRestarts(cond)
[16:12:45.865]                           for (restart in restarts) {
[16:12:45.865]                             name <- restart$name
[16:12:45.865]                             if (is.null(name)) 
[16:12:45.865]                               next
[16:12:45.865]                             if (!grepl(pattern, name)) 
[16:12:45.865]                               next
[16:12:45.865]                             invokeRestart(restart)
[16:12:45.865]                             muffled <- TRUE
[16:12:45.865]                             break
[16:12:45.865]                           }
[16:12:45.865]                         }
[16:12:45.865]                       }
[16:12:45.865]                       invisible(muffled)
[16:12:45.865]                     }
[16:12:45.865]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.865]                   }
[16:12:45.865]                 }
[16:12:45.865]                 else {
[16:12:45.865]                   if (TRUE) {
[16:12:45.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.865]                     {
[16:12:45.865]                       inherits <- base::inherits
[16:12:45.865]                       invokeRestart <- base::invokeRestart
[16:12:45.865]                       is.null <- base::is.null
[16:12:45.865]                       muffled <- FALSE
[16:12:45.865]                       if (inherits(cond, "message")) {
[16:12:45.865]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.865]                         if (muffled) 
[16:12:45.865]                           invokeRestart("muffleMessage")
[16:12:45.865]                       }
[16:12:45.865]                       else if (inherits(cond, "warning")) {
[16:12:45.865]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.865]                         if (muffled) 
[16:12:45.865]                           invokeRestart("muffleWarning")
[16:12:45.865]                       }
[16:12:45.865]                       else if (inherits(cond, "condition")) {
[16:12:45.865]                         if (!is.null(pattern)) {
[16:12:45.865]                           computeRestarts <- base::computeRestarts
[16:12:45.865]                           grepl <- base::grepl
[16:12:45.865]                           restarts <- computeRestarts(cond)
[16:12:45.865]                           for (restart in restarts) {
[16:12:45.865]                             name <- restart$name
[16:12:45.865]                             if (is.null(name)) 
[16:12:45.865]                               next
[16:12:45.865]                             if (!grepl(pattern, name)) 
[16:12:45.865]                               next
[16:12:45.865]                             invokeRestart(restart)
[16:12:45.865]                             muffled <- TRUE
[16:12:45.865]                             break
[16:12:45.865]                           }
[16:12:45.865]                         }
[16:12:45.865]                       }
[16:12:45.865]                       invisible(muffled)
[16:12:45.865]                     }
[16:12:45.865]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.865]                   }
[16:12:45.865]                 }
[16:12:45.865]             }
[16:12:45.865]         }))
[16:12:45.865]     }, error = function(ex) {
[16:12:45.865]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.865]                 ...future.rng), started = ...future.startTime, 
[16:12:45.865]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.865]             version = "1.8"), class = "FutureResult")
[16:12:45.865]     }, finally = {
[16:12:45.865]         if (!identical(...future.workdir, getwd())) 
[16:12:45.865]             setwd(...future.workdir)
[16:12:45.865]         {
[16:12:45.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.865]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.865]             }
[16:12:45.865]             base::options(...future.oldOptions)
[16:12:45.865]             if (.Platform$OS.type == "windows") {
[16:12:45.865]                 old_names <- names(...future.oldEnvVars)
[16:12:45.865]                 envs <- base::Sys.getenv()
[16:12:45.865]                 names <- names(envs)
[16:12:45.865]                 common <- intersect(names, old_names)
[16:12:45.865]                 added <- setdiff(names, old_names)
[16:12:45.865]                 removed <- setdiff(old_names, names)
[16:12:45.865]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.865]                   envs[common]]
[16:12:45.865]                 NAMES <- toupper(changed)
[16:12:45.865]                 args <- list()
[16:12:45.865]                 for (kk in seq_along(NAMES)) {
[16:12:45.865]                   name <- changed[[kk]]
[16:12:45.865]                   NAME <- NAMES[[kk]]
[16:12:45.865]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.865]                     next
[16:12:45.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.865]                 }
[16:12:45.865]                 NAMES <- toupper(added)
[16:12:45.865]                 for (kk in seq_along(NAMES)) {
[16:12:45.865]                   name <- added[[kk]]
[16:12:45.865]                   NAME <- NAMES[[kk]]
[16:12:45.865]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.865]                     next
[16:12:45.865]                   args[[name]] <- ""
[16:12:45.865]                 }
[16:12:45.865]                 NAMES <- toupper(removed)
[16:12:45.865]                 for (kk in seq_along(NAMES)) {
[16:12:45.865]                   name <- removed[[kk]]
[16:12:45.865]                   NAME <- NAMES[[kk]]
[16:12:45.865]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.865]                     next
[16:12:45.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.865]                 }
[16:12:45.865]                 if (length(args) > 0) 
[16:12:45.865]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.865]             }
[16:12:45.865]             else {
[16:12:45.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.865]             }
[16:12:45.865]             {
[16:12:45.865]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.865]                   0L) {
[16:12:45.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.865]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.865]                   base::options(opts)
[16:12:45.865]                 }
[16:12:45.865]                 {
[16:12:45.865]                   {
[16:12:45.865]                     NULL
[16:12:45.865]                     RNGkind("Mersenne-Twister")
[16:12:45.865]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.865]                       inherits = FALSE)
[16:12:45.865]                   }
[16:12:45.865]                   options(future.plan = NULL)
[16:12:45.865]                   if (is.na(NA_character_)) 
[16:12:45.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.865]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.865]                   {
[16:12:45.865]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.865]                     if (!future$lazy) 
[16:12:45.865]                       future <- run(future)
[16:12:45.865]                     invisible(future)
[16:12:45.865]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.865]                 }
[16:12:45.865]             }
[16:12:45.865]         }
[16:12:45.865]     })
[16:12:45.865]     if (TRUE) {
[16:12:45.865]         base::sink(type = "output", split = FALSE)
[16:12:45.865]         if (TRUE) {
[16:12:45.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.865]         }
[16:12:45.865]         else {
[16:12:45.865]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.865]         }
[16:12:45.865]         base::close(...future.stdout)
[16:12:45.865]         ...future.stdout <- NULL
[16:12:45.865]     }
[16:12:45.865]     ...future.result$conditions <- ...future.conditions
[16:12:45.865]     ...future.result$finished <- base::Sys.time()
[16:12:45.865]     ...future.result
[16:12:45.865] }
[16:12:45.867] assign_globals() ...
[16:12:45.867] List of 1
[16:12:45.867]  $ x: list()
[16:12:45.867]  - attr(*, "where")=List of 1
[16:12:45.867]   ..$ x:<environment: R_EmptyEnv> 
[16:12:45.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:45.867]  - attr(*, "resolved")= logi TRUE
[16:12:45.867]  - attr(*, "total_size")= num 0
[16:12:45.867]  - attr(*, "already-done")= logi TRUE
[16:12:45.869] - copied ‘x’ to environment
[16:12:45.870] assign_globals() ... done
[16:12:45.870] plan(): Setting new future strategy stack:
[16:12:45.870] List of future strategies:
[16:12:45.870] 1. sequential:
[16:12:45.870]    - args: function (..., envir = parent.frame())
[16:12:45.870]    - tweaked: FALSE
[16:12:45.870]    - call: NULL
[16:12:45.870] plan(): nbrOfWorkers() = 1
[16:12:45.871] plan(): Setting new future strategy stack:
[16:12:45.871] List of future strategies:
[16:12:45.871] 1. sequential:
[16:12:45.871]    - args: function (..., envir = parent.frame())
[16:12:45.871]    - tweaked: FALSE
[16:12:45.871]    - call: plan(strategy)
[16:12:45.872] plan(): nbrOfWorkers() = 1
[16:12:45.872] SequentialFuture started (and completed)
[16:12:45.872] - Launch lazy future ... done
[16:12:45.872] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.872] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.873] Searching for globals...
[16:12:45.875] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:12:45.875] Searching for globals ... DONE
[16:12:45.875] Resolving globals: TRUE
[16:12:45.875] Resolving any globals that are futures ...
[16:12:45.876] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:12:45.876] Resolving any globals that are futures ... DONE
[16:12:45.876] 
[16:12:45.876] 
[16:12:45.876] getGlobalsAndPackages() ... DONE
[16:12:45.876] run() for ‘Future’ ...
[16:12:45.877] - state: ‘created’
[16:12:45.877] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.877] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.877] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.877]   - Field: ‘label’
[16:12:45.877]   - Field: ‘local’
[16:12:45.877]   - Field: ‘owner’
[16:12:45.878]   - Field: ‘envir’
[16:12:45.878]   - Field: ‘packages’
[16:12:45.878]   - Field: ‘gc’
[16:12:45.878]   - Field: ‘conditions’
[16:12:45.878]   - Field: ‘expr’
[16:12:45.878]   - Field: ‘uuid’
[16:12:45.878]   - Field: ‘seed’
[16:12:45.878]   - Field: ‘version’
[16:12:45.878]   - Field: ‘result’
[16:12:45.878]   - Field: ‘asynchronous’
[16:12:45.879]   - Field: ‘calls’
[16:12:45.879]   - Field: ‘globals’
[16:12:45.879]   - Field: ‘stdout’
[16:12:45.879]   - Field: ‘earlySignal’
[16:12:45.879]   - Field: ‘lazy’
[16:12:45.879]   - Field: ‘state’
[16:12:45.879] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.879] - Launch lazy future ...
[16:12:45.879] Packages needed by the future expression (n = 0): <none>
[16:12:45.879] Packages needed by future strategies (n = 0): <none>
[16:12:45.880] {
[16:12:45.880]     {
[16:12:45.880]         {
[16:12:45.880]             ...future.startTime <- base::Sys.time()
[16:12:45.880]             {
[16:12:45.880]                 {
[16:12:45.880]                   {
[16:12:45.880]                     base::local({
[16:12:45.880]                       has_future <- base::requireNamespace("future", 
[16:12:45.880]                         quietly = TRUE)
[16:12:45.880]                       if (has_future) {
[16:12:45.880]                         ns <- base::getNamespace("future")
[16:12:45.880]                         version <- ns[[".package"]][["version"]]
[16:12:45.880]                         if (is.null(version)) 
[16:12:45.880]                           version <- utils::packageVersion("future")
[16:12:45.880]                       }
[16:12:45.880]                       else {
[16:12:45.880]                         version <- NULL
[16:12:45.880]                       }
[16:12:45.880]                       if (!has_future || version < "1.8.0") {
[16:12:45.880]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.880]                           "", base::R.version$version.string), 
[16:12:45.880]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.880]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.880]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.880]                             "release", "version")], collapse = " "), 
[16:12:45.880]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.880]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.880]                           info)
[16:12:45.880]                         info <- base::paste(info, collapse = "; ")
[16:12:45.880]                         if (!has_future) {
[16:12:45.880]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.880]                             info)
[16:12:45.880]                         }
[16:12:45.880]                         else {
[16:12:45.880]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.880]                             info, version)
[16:12:45.880]                         }
[16:12:45.880]                         base::stop(msg)
[16:12:45.880]                       }
[16:12:45.880]                     })
[16:12:45.880]                   }
[16:12:45.880]                   options(future.plan = NULL)
[16:12:45.880]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.880]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.880]                 }
[16:12:45.880]                 ...future.workdir <- getwd()
[16:12:45.880]             }
[16:12:45.880]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.880]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.880]         }
[16:12:45.880]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.880]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.880]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.880]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.880]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.880]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.880]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.880]             base::names(...future.oldOptions))
[16:12:45.880]     }
[16:12:45.880]     if (FALSE) {
[16:12:45.880]     }
[16:12:45.880]     else {
[16:12:45.880]         if (TRUE) {
[16:12:45.880]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.880]                 open = "w")
[16:12:45.880]         }
[16:12:45.880]         else {
[16:12:45.880]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.880]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.880]         }
[16:12:45.880]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.880]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.880]             base::sink(type = "output", split = FALSE)
[16:12:45.880]             base::close(...future.stdout)
[16:12:45.880]         }, add = TRUE)
[16:12:45.880]     }
[16:12:45.880]     ...future.frame <- base::sys.nframe()
[16:12:45.880]     ...future.conditions <- base::list()
[16:12:45.880]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.880]     if (FALSE) {
[16:12:45.880]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.880]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.880]     }
[16:12:45.880]     ...future.result <- base::tryCatch({
[16:12:45.880]         base::withCallingHandlers({
[16:12:45.880]             ...future.value <- base::withVisible(base::local({
[16:12:45.880]                 x <- list(b = 2)
[16:12:45.880]                 x$a <- 1
[16:12:45.880]                 x
[16:12:45.880]             }))
[16:12:45.880]             future::FutureResult(value = ...future.value$value, 
[16:12:45.880]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.880]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.880]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.880]                     ...future.globalenv.names))
[16:12:45.880]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.880]         }, condition = base::local({
[16:12:45.880]             c <- base::c
[16:12:45.880]             inherits <- base::inherits
[16:12:45.880]             invokeRestart <- base::invokeRestart
[16:12:45.880]             length <- base::length
[16:12:45.880]             list <- base::list
[16:12:45.880]             seq.int <- base::seq.int
[16:12:45.880]             signalCondition <- base::signalCondition
[16:12:45.880]             sys.calls <- base::sys.calls
[16:12:45.880]             `[[` <- base::`[[`
[16:12:45.880]             `+` <- base::`+`
[16:12:45.880]             `<<-` <- base::`<<-`
[16:12:45.880]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.880]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.880]                   3L)]
[16:12:45.880]             }
[16:12:45.880]             function(cond) {
[16:12:45.880]                 is_error <- inherits(cond, "error")
[16:12:45.880]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.880]                   NULL)
[16:12:45.880]                 if (is_error) {
[16:12:45.880]                   sessionInformation <- function() {
[16:12:45.880]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.880]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.880]                       search = base::search(), system = base::Sys.info())
[16:12:45.880]                   }
[16:12:45.880]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.880]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.880]                     cond$call), session = sessionInformation(), 
[16:12:45.880]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.880]                   signalCondition(cond)
[16:12:45.880]                 }
[16:12:45.880]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.880]                 "immediateCondition"))) {
[16:12:45.880]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.880]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.880]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.880]                   if (TRUE && !signal) {
[16:12:45.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.880]                     {
[16:12:45.880]                       inherits <- base::inherits
[16:12:45.880]                       invokeRestart <- base::invokeRestart
[16:12:45.880]                       is.null <- base::is.null
[16:12:45.880]                       muffled <- FALSE
[16:12:45.880]                       if (inherits(cond, "message")) {
[16:12:45.880]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.880]                         if (muffled) 
[16:12:45.880]                           invokeRestart("muffleMessage")
[16:12:45.880]                       }
[16:12:45.880]                       else if (inherits(cond, "warning")) {
[16:12:45.880]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.880]                         if (muffled) 
[16:12:45.880]                           invokeRestart("muffleWarning")
[16:12:45.880]                       }
[16:12:45.880]                       else if (inherits(cond, "condition")) {
[16:12:45.880]                         if (!is.null(pattern)) {
[16:12:45.880]                           computeRestarts <- base::computeRestarts
[16:12:45.880]                           grepl <- base::grepl
[16:12:45.880]                           restarts <- computeRestarts(cond)
[16:12:45.880]                           for (restart in restarts) {
[16:12:45.880]                             name <- restart$name
[16:12:45.880]                             if (is.null(name)) 
[16:12:45.880]                               next
[16:12:45.880]                             if (!grepl(pattern, name)) 
[16:12:45.880]                               next
[16:12:45.880]                             invokeRestart(restart)
[16:12:45.880]                             muffled <- TRUE
[16:12:45.880]                             break
[16:12:45.880]                           }
[16:12:45.880]                         }
[16:12:45.880]                       }
[16:12:45.880]                       invisible(muffled)
[16:12:45.880]                     }
[16:12:45.880]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.880]                   }
[16:12:45.880]                 }
[16:12:45.880]                 else {
[16:12:45.880]                   if (TRUE) {
[16:12:45.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.880]                     {
[16:12:45.880]                       inherits <- base::inherits
[16:12:45.880]                       invokeRestart <- base::invokeRestart
[16:12:45.880]                       is.null <- base::is.null
[16:12:45.880]                       muffled <- FALSE
[16:12:45.880]                       if (inherits(cond, "message")) {
[16:12:45.880]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.880]                         if (muffled) 
[16:12:45.880]                           invokeRestart("muffleMessage")
[16:12:45.880]                       }
[16:12:45.880]                       else if (inherits(cond, "warning")) {
[16:12:45.880]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.880]                         if (muffled) 
[16:12:45.880]                           invokeRestart("muffleWarning")
[16:12:45.880]                       }
[16:12:45.880]                       else if (inherits(cond, "condition")) {
[16:12:45.880]                         if (!is.null(pattern)) {
[16:12:45.880]                           computeRestarts <- base::computeRestarts
[16:12:45.880]                           grepl <- base::grepl
[16:12:45.880]                           restarts <- computeRestarts(cond)
[16:12:45.880]                           for (restart in restarts) {
[16:12:45.880]                             name <- restart$name
[16:12:45.880]                             if (is.null(name)) 
[16:12:45.880]                               next
[16:12:45.880]                             if (!grepl(pattern, name)) 
[16:12:45.880]                               next
[16:12:45.880]                             invokeRestart(restart)
[16:12:45.880]                             muffled <- TRUE
[16:12:45.880]                             break
[16:12:45.880]                           }
[16:12:45.880]                         }
[16:12:45.880]                       }
[16:12:45.880]                       invisible(muffled)
[16:12:45.880]                     }
[16:12:45.880]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.880]                   }
[16:12:45.880]                 }
[16:12:45.880]             }
[16:12:45.880]         }))
[16:12:45.880]     }, error = function(ex) {
[16:12:45.880]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.880]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.880]                 ...future.rng), started = ...future.startTime, 
[16:12:45.880]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.880]             version = "1.8"), class = "FutureResult")
[16:12:45.880]     }, finally = {
[16:12:45.880]         if (!identical(...future.workdir, getwd())) 
[16:12:45.880]             setwd(...future.workdir)
[16:12:45.880]         {
[16:12:45.880]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.880]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.880]             }
[16:12:45.880]             base::options(...future.oldOptions)
[16:12:45.880]             if (.Platform$OS.type == "windows") {
[16:12:45.880]                 old_names <- names(...future.oldEnvVars)
[16:12:45.880]                 envs <- base::Sys.getenv()
[16:12:45.880]                 names <- names(envs)
[16:12:45.880]                 common <- intersect(names, old_names)
[16:12:45.880]                 added <- setdiff(names, old_names)
[16:12:45.880]                 removed <- setdiff(old_names, names)
[16:12:45.880]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.880]                   envs[common]]
[16:12:45.880]                 NAMES <- toupper(changed)
[16:12:45.880]                 args <- list()
[16:12:45.880]                 for (kk in seq_along(NAMES)) {
[16:12:45.880]                   name <- changed[[kk]]
[16:12:45.880]                   NAME <- NAMES[[kk]]
[16:12:45.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.880]                     next
[16:12:45.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.880]                 }
[16:12:45.880]                 NAMES <- toupper(added)
[16:12:45.880]                 for (kk in seq_along(NAMES)) {
[16:12:45.880]                   name <- added[[kk]]
[16:12:45.880]                   NAME <- NAMES[[kk]]
[16:12:45.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.880]                     next
[16:12:45.880]                   args[[name]] <- ""
[16:12:45.880]                 }
[16:12:45.880]                 NAMES <- toupper(removed)
[16:12:45.880]                 for (kk in seq_along(NAMES)) {
[16:12:45.880]                   name <- removed[[kk]]
[16:12:45.880]                   NAME <- NAMES[[kk]]
[16:12:45.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.880]                     next
[16:12:45.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.880]                 }
[16:12:45.880]                 if (length(args) > 0) 
[16:12:45.880]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.880]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.880]             }
[16:12:45.880]             else {
[16:12:45.880]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.880]             }
[16:12:45.880]             {
[16:12:45.880]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.880]                   0L) {
[16:12:45.880]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.880]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.880]                   base::options(opts)
[16:12:45.880]                 }
[16:12:45.880]                 {
[16:12:45.880]                   {
[16:12:45.880]                     NULL
[16:12:45.880]                     RNGkind("Mersenne-Twister")
[16:12:45.880]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.880]                       inherits = FALSE)
[16:12:45.880]                   }
[16:12:45.880]                   options(future.plan = NULL)
[16:12:45.880]                   if (is.na(NA_character_)) 
[16:12:45.880]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.880]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.880]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.880]                   {
[16:12:45.880]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.880]                     if (!future$lazy) 
[16:12:45.880]                       future <- run(future)
[16:12:45.880]                     invisible(future)
[16:12:45.880]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.880]                 }
[16:12:45.880]             }
[16:12:45.880]         }
[16:12:45.880]     })
[16:12:45.880]     if (TRUE) {
[16:12:45.880]         base::sink(type = "output", split = FALSE)
[16:12:45.880]         if (TRUE) {
[16:12:45.880]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.880]         }
[16:12:45.880]         else {
[16:12:45.880]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.880]         }
[16:12:45.880]         base::close(...future.stdout)
[16:12:45.880]         ...future.stdout <- NULL
[16:12:45.880]     }
[16:12:45.880]     ...future.result$conditions <- ...future.conditions
[16:12:45.880]     ...future.result$finished <- base::Sys.time()
[16:12:45.880]     ...future.result
[16:12:45.880] }
[16:12:45.882] plan(): Setting new future strategy stack:
[16:12:45.882] List of future strategies:
[16:12:45.882] 1. sequential:
[16:12:45.882]    - args: function (..., envir = parent.frame())
[16:12:45.882]    - tweaked: FALSE
[16:12:45.882]    - call: NULL
[16:12:45.882] plan(): nbrOfWorkers() = 1
[16:12:45.883] plan(): Setting new future strategy stack:
[16:12:45.883] List of future strategies:
[16:12:45.883] 1. sequential:
[16:12:45.883]    - args: function (..., envir = parent.frame())
[16:12:45.883]    - tweaked: FALSE
[16:12:45.883]    - call: plan(strategy)
[16:12:45.883] plan(): nbrOfWorkers() = 1
[16:12:45.884] SequentialFuture started (and completed)
[16:12:45.884] - Launch lazy future ... done
[16:12:45.884] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.884] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.884] Searching for globals...
[16:12:45.886] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:45.886] Searching for globals ... DONE
[16:12:45.887] Resolving globals: TRUE
[16:12:45.887] Resolving any globals that are futures ...
[16:12:45.887] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:45.887] Resolving any globals that are futures ... DONE
[16:12:45.887] Resolving futures part of globals (recursively) ...
[16:12:45.887] resolve() on list ...
[16:12:45.888]  recursive: 99
[16:12:45.888]  length: 1
[16:12:45.888]  elements: ‘x’
[16:12:45.888]  length: 0 (resolved future 1)
[16:12:45.888] resolve() on list ... DONE
[16:12:45.888] - globals: [1] ‘x’
[16:12:45.888] Resolving futures part of globals (recursively) ... DONE
[16:12:45.888] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:45.889] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:45.889] - globals: [1] ‘x’
[16:12:45.889] 
[16:12:45.889] getGlobalsAndPackages() ... DONE
[16:12:45.889] run() for ‘Future’ ...
[16:12:45.889] - state: ‘created’
[16:12:45.889] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.890] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.890] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.890]   - Field: ‘label’
[16:12:45.890]   - Field: ‘local’
[16:12:45.890]   - Field: ‘owner’
[16:12:45.890]   - Field: ‘envir’
[16:12:45.890]   - Field: ‘packages’
[16:12:45.890]   - Field: ‘gc’
[16:12:45.891]   - Field: ‘conditions’
[16:12:45.891]   - Field: ‘expr’
[16:12:45.891]   - Field: ‘uuid’
[16:12:45.891]   - Field: ‘seed’
[16:12:45.891]   - Field: ‘version’
[16:12:45.891]   - Field: ‘result’
[16:12:45.891]   - Field: ‘asynchronous’
[16:12:45.891]   - Field: ‘calls’
[16:12:45.891]   - Field: ‘globals’
[16:12:45.891]   - Field: ‘stdout’
[16:12:45.891]   - Field: ‘earlySignal’
[16:12:45.892]   - Field: ‘lazy’
[16:12:45.892]   - Field: ‘state’
[16:12:45.892] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.894] - Launch lazy future ...
[16:12:45.894] Packages needed by the future expression (n = 0): <none>
[16:12:45.894] Packages needed by future strategies (n = 0): <none>
[16:12:45.895] {
[16:12:45.895]     {
[16:12:45.895]         {
[16:12:45.895]             ...future.startTime <- base::Sys.time()
[16:12:45.895]             {
[16:12:45.895]                 {
[16:12:45.895]                   {
[16:12:45.895]                     base::local({
[16:12:45.895]                       has_future <- base::requireNamespace("future", 
[16:12:45.895]                         quietly = TRUE)
[16:12:45.895]                       if (has_future) {
[16:12:45.895]                         ns <- base::getNamespace("future")
[16:12:45.895]                         version <- ns[[".package"]][["version"]]
[16:12:45.895]                         if (is.null(version)) 
[16:12:45.895]                           version <- utils::packageVersion("future")
[16:12:45.895]                       }
[16:12:45.895]                       else {
[16:12:45.895]                         version <- NULL
[16:12:45.895]                       }
[16:12:45.895]                       if (!has_future || version < "1.8.0") {
[16:12:45.895]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.895]                           "", base::R.version$version.string), 
[16:12:45.895]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.895]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.895]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.895]                             "release", "version")], collapse = " "), 
[16:12:45.895]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.895]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.895]                           info)
[16:12:45.895]                         info <- base::paste(info, collapse = "; ")
[16:12:45.895]                         if (!has_future) {
[16:12:45.895]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.895]                             info)
[16:12:45.895]                         }
[16:12:45.895]                         else {
[16:12:45.895]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.895]                             info, version)
[16:12:45.895]                         }
[16:12:45.895]                         base::stop(msg)
[16:12:45.895]                       }
[16:12:45.895]                     })
[16:12:45.895]                   }
[16:12:45.895]                   options(future.plan = NULL)
[16:12:45.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.895]                 }
[16:12:45.895]                 ...future.workdir <- getwd()
[16:12:45.895]             }
[16:12:45.895]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.895]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.895]         }
[16:12:45.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.895]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.895]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.895]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.895]             base::names(...future.oldOptions))
[16:12:45.895]     }
[16:12:45.895]     if (FALSE) {
[16:12:45.895]     }
[16:12:45.895]     else {
[16:12:45.895]         if (TRUE) {
[16:12:45.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.895]                 open = "w")
[16:12:45.895]         }
[16:12:45.895]         else {
[16:12:45.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.895]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.895]         }
[16:12:45.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.895]             base::sink(type = "output", split = FALSE)
[16:12:45.895]             base::close(...future.stdout)
[16:12:45.895]         }, add = TRUE)
[16:12:45.895]     }
[16:12:45.895]     ...future.frame <- base::sys.nframe()
[16:12:45.895]     ...future.conditions <- base::list()
[16:12:45.895]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.895]     if (FALSE) {
[16:12:45.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.895]     }
[16:12:45.895]     ...future.result <- base::tryCatch({
[16:12:45.895]         base::withCallingHandlers({
[16:12:45.895]             ...future.value <- base::withVisible(base::local({
[16:12:45.895]                 x[["a"]] <- 1
[16:12:45.895]                 x
[16:12:45.895]             }))
[16:12:45.895]             future::FutureResult(value = ...future.value$value, 
[16:12:45.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.895]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.895]                     ...future.globalenv.names))
[16:12:45.895]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.895]         }, condition = base::local({
[16:12:45.895]             c <- base::c
[16:12:45.895]             inherits <- base::inherits
[16:12:45.895]             invokeRestart <- base::invokeRestart
[16:12:45.895]             length <- base::length
[16:12:45.895]             list <- base::list
[16:12:45.895]             seq.int <- base::seq.int
[16:12:45.895]             signalCondition <- base::signalCondition
[16:12:45.895]             sys.calls <- base::sys.calls
[16:12:45.895]             `[[` <- base::`[[`
[16:12:45.895]             `+` <- base::`+`
[16:12:45.895]             `<<-` <- base::`<<-`
[16:12:45.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.895]                   3L)]
[16:12:45.895]             }
[16:12:45.895]             function(cond) {
[16:12:45.895]                 is_error <- inherits(cond, "error")
[16:12:45.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.895]                   NULL)
[16:12:45.895]                 if (is_error) {
[16:12:45.895]                   sessionInformation <- function() {
[16:12:45.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.895]                       search = base::search(), system = base::Sys.info())
[16:12:45.895]                   }
[16:12:45.895]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.895]                     cond$call), session = sessionInformation(), 
[16:12:45.895]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.895]                   signalCondition(cond)
[16:12:45.895]                 }
[16:12:45.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.895]                 "immediateCondition"))) {
[16:12:45.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.895]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.895]                   if (TRUE && !signal) {
[16:12:45.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.895]                     {
[16:12:45.895]                       inherits <- base::inherits
[16:12:45.895]                       invokeRestart <- base::invokeRestart
[16:12:45.895]                       is.null <- base::is.null
[16:12:45.895]                       muffled <- FALSE
[16:12:45.895]                       if (inherits(cond, "message")) {
[16:12:45.895]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.895]                         if (muffled) 
[16:12:45.895]                           invokeRestart("muffleMessage")
[16:12:45.895]                       }
[16:12:45.895]                       else if (inherits(cond, "warning")) {
[16:12:45.895]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.895]                         if (muffled) 
[16:12:45.895]                           invokeRestart("muffleWarning")
[16:12:45.895]                       }
[16:12:45.895]                       else if (inherits(cond, "condition")) {
[16:12:45.895]                         if (!is.null(pattern)) {
[16:12:45.895]                           computeRestarts <- base::computeRestarts
[16:12:45.895]                           grepl <- base::grepl
[16:12:45.895]                           restarts <- computeRestarts(cond)
[16:12:45.895]                           for (restart in restarts) {
[16:12:45.895]                             name <- restart$name
[16:12:45.895]                             if (is.null(name)) 
[16:12:45.895]                               next
[16:12:45.895]                             if (!grepl(pattern, name)) 
[16:12:45.895]                               next
[16:12:45.895]                             invokeRestart(restart)
[16:12:45.895]                             muffled <- TRUE
[16:12:45.895]                             break
[16:12:45.895]                           }
[16:12:45.895]                         }
[16:12:45.895]                       }
[16:12:45.895]                       invisible(muffled)
[16:12:45.895]                     }
[16:12:45.895]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.895]                   }
[16:12:45.895]                 }
[16:12:45.895]                 else {
[16:12:45.895]                   if (TRUE) {
[16:12:45.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.895]                     {
[16:12:45.895]                       inherits <- base::inherits
[16:12:45.895]                       invokeRestart <- base::invokeRestart
[16:12:45.895]                       is.null <- base::is.null
[16:12:45.895]                       muffled <- FALSE
[16:12:45.895]                       if (inherits(cond, "message")) {
[16:12:45.895]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.895]                         if (muffled) 
[16:12:45.895]                           invokeRestart("muffleMessage")
[16:12:45.895]                       }
[16:12:45.895]                       else if (inherits(cond, "warning")) {
[16:12:45.895]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.895]                         if (muffled) 
[16:12:45.895]                           invokeRestart("muffleWarning")
[16:12:45.895]                       }
[16:12:45.895]                       else if (inherits(cond, "condition")) {
[16:12:45.895]                         if (!is.null(pattern)) {
[16:12:45.895]                           computeRestarts <- base::computeRestarts
[16:12:45.895]                           grepl <- base::grepl
[16:12:45.895]                           restarts <- computeRestarts(cond)
[16:12:45.895]                           for (restart in restarts) {
[16:12:45.895]                             name <- restart$name
[16:12:45.895]                             if (is.null(name)) 
[16:12:45.895]                               next
[16:12:45.895]                             if (!grepl(pattern, name)) 
[16:12:45.895]                               next
[16:12:45.895]                             invokeRestart(restart)
[16:12:45.895]                             muffled <- TRUE
[16:12:45.895]                             break
[16:12:45.895]                           }
[16:12:45.895]                         }
[16:12:45.895]                       }
[16:12:45.895]                       invisible(muffled)
[16:12:45.895]                     }
[16:12:45.895]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.895]                   }
[16:12:45.895]                 }
[16:12:45.895]             }
[16:12:45.895]         }))
[16:12:45.895]     }, error = function(ex) {
[16:12:45.895]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.895]                 ...future.rng), started = ...future.startTime, 
[16:12:45.895]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.895]             version = "1.8"), class = "FutureResult")
[16:12:45.895]     }, finally = {
[16:12:45.895]         if (!identical(...future.workdir, getwd())) 
[16:12:45.895]             setwd(...future.workdir)
[16:12:45.895]         {
[16:12:45.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.895]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.895]             }
[16:12:45.895]             base::options(...future.oldOptions)
[16:12:45.895]             if (.Platform$OS.type == "windows") {
[16:12:45.895]                 old_names <- names(...future.oldEnvVars)
[16:12:45.895]                 envs <- base::Sys.getenv()
[16:12:45.895]                 names <- names(envs)
[16:12:45.895]                 common <- intersect(names, old_names)
[16:12:45.895]                 added <- setdiff(names, old_names)
[16:12:45.895]                 removed <- setdiff(old_names, names)
[16:12:45.895]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.895]                   envs[common]]
[16:12:45.895]                 NAMES <- toupper(changed)
[16:12:45.895]                 args <- list()
[16:12:45.895]                 for (kk in seq_along(NAMES)) {
[16:12:45.895]                   name <- changed[[kk]]
[16:12:45.895]                   NAME <- NAMES[[kk]]
[16:12:45.895]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.895]                     next
[16:12:45.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.895]                 }
[16:12:45.895]                 NAMES <- toupper(added)
[16:12:45.895]                 for (kk in seq_along(NAMES)) {
[16:12:45.895]                   name <- added[[kk]]
[16:12:45.895]                   NAME <- NAMES[[kk]]
[16:12:45.895]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.895]                     next
[16:12:45.895]                   args[[name]] <- ""
[16:12:45.895]                 }
[16:12:45.895]                 NAMES <- toupper(removed)
[16:12:45.895]                 for (kk in seq_along(NAMES)) {
[16:12:45.895]                   name <- removed[[kk]]
[16:12:45.895]                   NAME <- NAMES[[kk]]
[16:12:45.895]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.895]                     next
[16:12:45.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.895]                 }
[16:12:45.895]                 if (length(args) > 0) 
[16:12:45.895]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.895]             }
[16:12:45.895]             else {
[16:12:45.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.895]             }
[16:12:45.895]             {
[16:12:45.895]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.895]                   0L) {
[16:12:45.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.895]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.895]                   base::options(opts)
[16:12:45.895]                 }
[16:12:45.895]                 {
[16:12:45.895]                   {
[16:12:45.895]                     NULL
[16:12:45.895]                     RNGkind("Mersenne-Twister")
[16:12:45.895]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.895]                       inherits = FALSE)
[16:12:45.895]                   }
[16:12:45.895]                   options(future.plan = NULL)
[16:12:45.895]                   if (is.na(NA_character_)) 
[16:12:45.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.895]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.895]                   {
[16:12:45.895]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.895]                     if (!future$lazy) 
[16:12:45.895]                       future <- run(future)
[16:12:45.895]                     invisible(future)
[16:12:45.895]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.895]                 }
[16:12:45.895]             }
[16:12:45.895]         }
[16:12:45.895]     })
[16:12:45.895]     if (TRUE) {
[16:12:45.895]         base::sink(type = "output", split = FALSE)
[16:12:45.895]         if (TRUE) {
[16:12:45.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.895]         }
[16:12:45.895]         else {
[16:12:45.895]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.895]         }
[16:12:45.895]         base::close(...future.stdout)
[16:12:45.895]         ...future.stdout <- NULL
[16:12:45.895]     }
[16:12:45.895]     ...future.result$conditions <- ...future.conditions
[16:12:45.895]     ...future.result$finished <- base::Sys.time()
[16:12:45.895]     ...future.result
[16:12:45.895] }
[16:12:45.896] assign_globals() ...
[16:12:45.896] List of 1
[16:12:45.896]  $ x: list()
[16:12:45.896]  - attr(*, "where")=List of 1
[16:12:45.896]   ..$ x:<environment: R_EmptyEnv> 
[16:12:45.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:45.896]  - attr(*, "resolved")= logi TRUE
[16:12:45.896]  - attr(*, "total_size")= num 0
[16:12:45.896]  - attr(*, "already-done")= logi TRUE
[16:12:45.899] - copied ‘x’ to environment
[16:12:45.899] assign_globals() ... done
[16:12:45.899] plan(): Setting new future strategy stack:
[16:12:45.899] List of future strategies:
[16:12:45.899] 1. sequential:
[16:12:45.899]    - args: function (..., envir = parent.frame())
[16:12:45.899]    - tweaked: FALSE
[16:12:45.899]    - call: NULL
[16:12:45.900] plan(): nbrOfWorkers() = 1
[16:12:45.901] plan(): Setting new future strategy stack:
[16:12:45.901] List of future strategies:
[16:12:45.901] 1. sequential:
[16:12:45.901]    - args: function (..., envir = parent.frame())
[16:12:45.901]    - tweaked: FALSE
[16:12:45.901]    - call: plan(strategy)
[16:12:45.901] plan(): nbrOfWorkers() = 1
[16:12:45.901] SequentialFuture started (and completed)
[16:12:45.901] - Launch lazy future ... done
[16:12:45.902] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.902] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.902] Searching for globals...
[16:12:45.904] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:45.904] Searching for globals ... DONE
[16:12:45.904] Resolving globals: TRUE
[16:12:45.904] Resolving any globals that are futures ...
[16:12:45.904] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:45.905] Resolving any globals that are futures ... DONE
[16:12:45.905] Resolving futures part of globals (recursively) ...
[16:12:45.905] resolve() on list ...
[16:12:45.905]  recursive: 99
[16:12:45.905]  length: 1
[16:12:45.905]  elements: ‘x’
[16:12:45.906]  length: 0 (resolved future 1)
[16:12:45.906] resolve() on list ... DONE
[16:12:45.906] - globals: [1] ‘x’
[16:12:45.906] Resolving futures part of globals (recursively) ... DONE
[16:12:45.906] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:45.906] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:45.907] - globals: [1] ‘x’
[16:12:45.907] 
[16:12:45.907] getGlobalsAndPackages() ... DONE
[16:12:45.907] run() for ‘Future’ ...
[16:12:45.907] - state: ‘created’
[16:12:45.907] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.908] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.908] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.908]   - Field: ‘label’
[16:12:45.908]   - Field: ‘local’
[16:12:45.908]   - Field: ‘owner’
[16:12:45.908]   - Field: ‘envir’
[16:12:45.908]   - Field: ‘packages’
[16:12:45.908]   - Field: ‘gc’
[16:12:45.908]   - Field: ‘conditions’
[16:12:45.908]   - Field: ‘expr’
[16:12:45.909]   - Field: ‘uuid’
[16:12:45.909]   - Field: ‘seed’
[16:12:45.909]   - Field: ‘version’
[16:12:45.909]   - Field: ‘result’
[16:12:45.909]   - Field: ‘asynchronous’
[16:12:45.909]   - Field: ‘calls’
[16:12:45.909]   - Field: ‘globals’
[16:12:45.909]   - Field: ‘stdout’
[16:12:45.909]   - Field: ‘earlySignal’
[16:12:45.909]   - Field: ‘lazy’
[16:12:45.909]   - Field: ‘state’
[16:12:45.910] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.910] - Launch lazy future ...
[16:12:45.910] Packages needed by the future expression (n = 0): <none>
[16:12:45.910] Packages needed by future strategies (n = 0): <none>
[16:12:45.910] {
[16:12:45.910]     {
[16:12:45.910]         {
[16:12:45.910]             ...future.startTime <- base::Sys.time()
[16:12:45.910]             {
[16:12:45.910]                 {
[16:12:45.910]                   {
[16:12:45.910]                     base::local({
[16:12:45.910]                       has_future <- base::requireNamespace("future", 
[16:12:45.910]                         quietly = TRUE)
[16:12:45.910]                       if (has_future) {
[16:12:45.910]                         ns <- base::getNamespace("future")
[16:12:45.910]                         version <- ns[[".package"]][["version"]]
[16:12:45.910]                         if (is.null(version)) 
[16:12:45.910]                           version <- utils::packageVersion("future")
[16:12:45.910]                       }
[16:12:45.910]                       else {
[16:12:45.910]                         version <- NULL
[16:12:45.910]                       }
[16:12:45.910]                       if (!has_future || version < "1.8.0") {
[16:12:45.910]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.910]                           "", base::R.version$version.string), 
[16:12:45.910]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.910]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.910]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.910]                             "release", "version")], collapse = " "), 
[16:12:45.910]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.910]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.910]                           info)
[16:12:45.910]                         info <- base::paste(info, collapse = "; ")
[16:12:45.910]                         if (!has_future) {
[16:12:45.910]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.910]                             info)
[16:12:45.910]                         }
[16:12:45.910]                         else {
[16:12:45.910]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.910]                             info, version)
[16:12:45.910]                         }
[16:12:45.910]                         base::stop(msg)
[16:12:45.910]                       }
[16:12:45.910]                     })
[16:12:45.910]                   }
[16:12:45.910]                   options(future.plan = NULL)
[16:12:45.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.910]                 }
[16:12:45.910]                 ...future.workdir <- getwd()
[16:12:45.910]             }
[16:12:45.910]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.910]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.910]         }
[16:12:45.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.910]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.910]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.910]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.910]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.910]             base::names(...future.oldOptions))
[16:12:45.910]     }
[16:12:45.910]     if (FALSE) {
[16:12:45.910]     }
[16:12:45.910]     else {
[16:12:45.910]         if (TRUE) {
[16:12:45.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.910]                 open = "w")
[16:12:45.910]         }
[16:12:45.910]         else {
[16:12:45.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.910]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.910]         }
[16:12:45.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.910]             base::sink(type = "output", split = FALSE)
[16:12:45.910]             base::close(...future.stdout)
[16:12:45.910]         }, add = TRUE)
[16:12:45.910]     }
[16:12:45.910]     ...future.frame <- base::sys.nframe()
[16:12:45.910]     ...future.conditions <- base::list()
[16:12:45.910]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.910]     if (FALSE) {
[16:12:45.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.910]     }
[16:12:45.910]     ...future.result <- base::tryCatch({
[16:12:45.910]         base::withCallingHandlers({
[16:12:45.910]             ...future.value <- base::withVisible(base::local({
[16:12:45.910]                 x[["a"]] <- 1
[16:12:45.910]                 x
[16:12:45.910]             }))
[16:12:45.910]             future::FutureResult(value = ...future.value$value, 
[16:12:45.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.910]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.910]                     ...future.globalenv.names))
[16:12:45.910]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.910]         }, condition = base::local({
[16:12:45.910]             c <- base::c
[16:12:45.910]             inherits <- base::inherits
[16:12:45.910]             invokeRestart <- base::invokeRestart
[16:12:45.910]             length <- base::length
[16:12:45.910]             list <- base::list
[16:12:45.910]             seq.int <- base::seq.int
[16:12:45.910]             signalCondition <- base::signalCondition
[16:12:45.910]             sys.calls <- base::sys.calls
[16:12:45.910]             `[[` <- base::`[[`
[16:12:45.910]             `+` <- base::`+`
[16:12:45.910]             `<<-` <- base::`<<-`
[16:12:45.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.910]                   3L)]
[16:12:45.910]             }
[16:12:45.910]             function(cond) {
[16:12:45.910]                 is_error <- inherits(cond, "error")
[16:12:45.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.910]                   NULL)
[16:12:45.910]                 if (is_error) {
[16:12:45.910]                   sessionInformation <- function() {
[16:12:45.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.910]                       search = base::search(), system = base::Sys.info())
[16:12:45.910]                   }
[16:12:45.910]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.910]                     cond$call), session = sessionInformation(), 
[16:12:45.910]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.910]                   signalCondition(cond)
[16:12:45.910]                 }
[16:12:45.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.910]                 "immediateCondition"))) {
[16:12:45.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.910]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.910]                   if (TRUE && !signal) {
[16:12:45.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.910]                     {
[16:12:45.910]                       inherits <- base::inherits
[16:12:45.910]                       invokeRestart <- base::invokeRestart
[16:12:45.910]                       is.null <- base::is.null
[16:12:45.910]                       muffled <- FALSE
[16:12:45.910]                       if (inherits(cond, "message")) {
[16:12:45.910]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.910]                         if (muffled) 
[16:12:45.910]                           invokeRestart("muffleMessage")
[16:12:45.910]                       }
[16:12:45.910]                       else if (inherits(cond, "warning")) {
[16:12:45.910]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.910]                         if (muffled) 
[16:12:45.910]                           invokeRestart("muffleWarning")
[16:12:45.910]                       }
[16:12:45.910]                       else if (inherits(cond, "condition")) {
[16:12:45.910]                         if (!is.null(pattern)) {
[16:12:45.910]                           computeRestarts <- base::computeRestarts
[16:12:45.910]                           grepl <- base::grepl
[16:12:45.910]                           restarts <- computeRestarts(cond)
[16:12:45.910]                           for (restart in restarts) {
[16:12:45.910]                             name <- restart$name
[16:12:45.910]                             if (is.null(name)) 
[16:12:45.910]                               next
[16:12:45.910]                             if (!grepl(pattern, name)) 
[16:12:45.910]                               next
[16:12:45.910]                             invokeRestart(restart)
[16:12:45.910]                             muffled <- TRUE
[16:12:45.910]                             break
[16:12:45.910]                           }
[16:12:45.910]                         }
[16:12:45.910]                       }
[16:12:45.910]                       invisible(muffled)
[16:12:45.910]                     }
[16:12:45.910]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.910]                   }
[16:12:45.910]                 }
[16:12:45.910]                 else {
[16:12:45.910]                   if (TRUE) {
[16:12:45.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.910]                     {
[16:12:45.910]                       inherits <- base::inherits
[16:12:45.910]                       invokeRestart <- base::invokeRestart
[16:12:45.910]                       is.null <- base::is.null
[16:12:45.910]                       muffled <- FALSE
[16:12:45.910]                       if (inherits(cond, "message")) {
[16:12:45.910]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.910]                         if (muffled) 
[16:12:45.910]                           invokeRestart("muffleMessage")
[16:12:45.910]                       }
[16:12:45.910]                       else if (inherits(cond, "warning")) {
[16:12:45.910]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.910]                         if (muffled) 
[16:12:45.910]                           invokeRestart("muffleWarning")
[16:12:45.910]                       }
[16:12:45.910]                       else if (inherits(cond, "condition")) {
[16:12:45.910]                         if (!is.null(pattern)) {
[16:12:45.910]                           computeRestarts <- base::computeRestarts
[16:12:45.910]                           grepl <- base::grepl
[16:12:45.910]                           restarts <- computeRestarts(cond)
[16:12:45.910]                           for (restart in restarts) {
[16:12:45.910]                             name <- restart$name
[16:12:45.910]                             if (is.null(name)) 
[16:12:45.910]                               next
[16:12:45.910]                             if (!grepl(pattern, name)) 
[16:12:45.910]                               next
[16:12:45.910]                             invokeRestart(restart)
[16:12:45.910]                             muffled <- TRUE
[16:12:45.910]                             break
[16:12:45.910]                           }
[16:12:45.910]                         }
[16:12:45.910]                       }
[16:12:45.910]                       invisible(muffled)
[16:12:45.910]                     }
[16:12:45.910]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.910]                   }
[16:12:45.910]                 }
[16:12:45.910]             }
[16:12:45.910]         }))
[16:12:45.910]     }, error = function(ex) {
[16:12:45.910]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.910]                 ...future.rng), started = ...future.startTime, 
[16:12:45.910]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.910]             version = "1.8"), class = "FutureResult")
[16:12:45.910]     }, finally = {
[16:12:45.910]         if (!identical(...future.workdir, getwd())) 
[16:12:45.910]             setwd(...future.workdir)
[16:12:45.910]         {
[16:12:45.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.910]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.910]             }
[16:12:45.910]             base::options(...future.oldOptions)
[16:12:45.910]             if (.Platform$OS.type == "windows") {
[16:12:45.910]                 old_names <- names(...future.oldEnvVars)
[16:12:45.910]                 envs <- base::Sys.getenv()
[16:12:45.910]                 names <- names(envs)
[16:12:45.910]                 common <- intersect(names, old_names)
[16:12:45.910]                 added <- setdiff(names, old_names)
[16:12:45.910]                 removed <- setdiff(old_names, names)
[16:12:45.910]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.910]                   envs[common]]
[16:12:45.910]                 NAMES <- toupper(changed)
[16:12:45.910]                 args <- list()
[16:12:45.910]                 for (kk in seq_along(NAMES)) {
[16:12:45.910]                   name <- changed[[kk]]
[16:12:45.910]                   NAME <- NAMES[[kk]]
[16:12:45.910]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.910]                     next
[16:12:45.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.910]                 }
[16:12:45.910]                 NAMES <- toupper(added)
[16:12:45.910]                 for (kk in seq_along(NAMES)) {
[16:12:45.910]                   name <- added[[kk]]
[16:12:45.910]                   NAME <- NAMES[[kk]]
[16:12:45.910]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.910]                     next
[16:12:45.910]                   args[[name]] <- ""
[16:12:45.910]                 }
[16:12:45.910]                 NAMES <- toupper(removed)
[16:12:45.910]                 for (kk in seq_along(NAMES)) {
[16:12:45.910]                   name <- removed[[kk]]
[16:12:45.910]                   NAME <- NAMES[[kk]]
[16:12:45.910]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.910]                     next
[16:12:45.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.910]                 }
[16:12:45.910]                 if (length(args) > 0) 
[16:12:45.910]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.910]             }
[16:12:45.910]             else {
[16:12:45.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.910]             }
[16:12:45.910]             {
[16:12:45.910]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.910]                   0L) {
[16:12:45.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.910]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.910]                   base::options(opts)
[16:12:45.910]                 }
[16:12:45.910]                 {
[16:12:45.910]                   {
[16:12:45.910]                     NULL
[16:12:45.910]                     RNGkind("Mersenne-Twister")
[16:12:45.910]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.910]                       inherits = FALSE)
[16:12:45.910]                   }
[16:12:45.910]                   options(future.plan = NULL)
[16:12:45.910]                   if (is.na(NA_character_)) 
[16:12:45.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.910]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.910]                   {
[16:12:45.910]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.910]                     if (!future$lazy) 
[16:12:45.910]                       future <- run(future)
[16:12:45.910]                     invisible(future)
[16:12:45.910]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.910]                 }
[16:12:45.910]             }
[16:12:45.910]         }
[16:12:45.910]     })
[16:12:45.910]     if (TRUE) {
[16:12:45.910]         base::sink(type = "output", split = FALSE)
[16:12:45.910]         if (TRUE) {
[16:12:45.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.910]         }
[16:12:45.910]         else {
[16:12:45.910]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.910]         }
[16:12:45.910]         base::close(...future.stdout)
[16:12:45.910]         ...future.stdout <- NULL
[16:12:45.910]     }
[16:12:45.910]     ...future.result$conditions <- ...future.conditions
[16:12:45.910]     ...future.result$finished <- base::Sys.time()
[16:12:45.910]     ...future.result
[16:12:45.910] }
[16:12:45.912] assign_globals() ...
[16:12:45.912] List of 1
[16:12:45.912]  $ x: list()
[16:12:45.912]  - attr(*, "where")=List of 1
[16:12:45.912]   ..$ x:<environment: R_EmptyEnv> 
[16:12:45.912]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:45.912]  - attr(*, "resolved")= logi TRUE
[16:12:45.912]  - attr(*, "total_size")= num 0
[16:12:45.912]  - attr(*, "already-done")= logi TRUE
[16:12:45.915] - copied ‘x’ to environment
[16:12:45.915] assign_globals() ... done
[16:12:45.915] plan(): Setting new future strategy stack:
[16:12:45.915] List of future strategies:
[16:12:45.915] 1. sequential:
[16:12:45.915]    - args: function (..., envir = parent.frame())
[16:12:45.915]    - tweaked: FALSE
[16:12:45.915]    - call: NULL
[16:12:45.915] plan(): nbrOfWorkers() = 1
[16:12:45.916] plan(): Setting new future strategy stack:
[16:12:45.916] List of future strategies:
[16:12:45.916] 1. sequential:
[16:12:45.916]    - args: function (..., envir = parent.frame())
[16:12:45.916]    - tweaked: FALSE
[16:12:45.916]    - call: plan(strategy)
[16:12:45.917] plan(): nbrOfWorkers() = 1
[16:12:45.917] SequentialFuture started (and completed)
[16:12:45.917] - Launch lazy future ... done
[16:12:45.917] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.918] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.918] Searching for globals...
[16:12:45.920] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:45.920] Searching for globals ... DONE
[16:12:45.920] Resolving globals: TRUE
[16:12:45.920] Resolving any globals that are futures ...
[16:12:45.920] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:45.920] Resolving any globals that are futures ... DONE
[16:12:45.921] Resolving futures part of globals (recursively) ...
[16:12:45.921] resolve() on list ...
[16:12:45.921]  recursive: 99
[16:12:45.921]  length: 1
[16:12:45.921]  elements: ‘x’
[16:12:45.921]  length: 0 (resolved future 1)
[16:12:45.921] resolve() on list ... DONE
[16:12:45.921] - globals: [1] ‘x’
[16:12:45.923] Resolving futures part of globals (recursively) ... DONE
[16:12:45.924] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:45.924] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:45.924] - globals: [1] ‘x’
[16:12:45.924] 
[16:12:45.924] getGlobalsAndPackages() ... DONE
[16:12:45.925] run() for ‘Future’ ...
[16:12:45.925] - state: ‘created’
[16:12:45.925] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.925] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.925] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.925]   - Field: ‘label’
[16:12:45.925]   - Field: ‘local’
[16:12:45.926]   - Field: ‘owner’
[16:12:45.926]   - Field: ‘envir’
[16:12:45.926]   - Field: ‘packages’
[16:12:45.926]   - Field: ‘gc’
[16:12:45.926]   - Field: ‘conditions’
[16:12:45.926]   - Field: ‘expr’
[16:12:45.926]   - Field: ‘uuid’
[16:12:45.926]   - Field: ‘seed’
[16:12:45.926]   - Field: ‘version’
[16:12:45.926]   - Field: ‘result’
[16:12:45.926]   - Field: ‘asynchronous’
[16:12:45.927]   - Field: ‘calls’
[16:12:45.927]   - Field: ‘globals’
[16:12:45.927]   - Field: ‘stdout’
[16:12:45.927]   - Field: ‘earlySignal’
[16:12:45.927]   - Field: ‘lazy’
[16:12:45.927]   - Field: ‘state’
[16:12:45.927] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.927] - Launch lazy future ...
[16:12:45.927] Packages needed by the future expression (n = 0): <none>
[16:12:45.928] Packages needed by future strategies (n = 0): <none>
[16:12:45.928] {
[16:12:45.928]     {
[16:12:45.928]         {
[16:12:45.928]             ...future.startTime <- base::Sys.time()
[16:12:45.928]             {
[16:12:45.928]                 {
[16:12:45.928]                   {
[16:12:45.928]                     base::local({
[16:12:45.928]                       has_future <- base::requireNamespace("future", 
[16:12:45.928]                         quietly = TRUE)
[16:12:45.928]                       if (has_future) {
[16:12:45.928]                         ns <- base::getNamespace("future")
[16:12:45.928]                         version <- ns[[".package"]][["version"]]
[16:12:45.928]                         if (is.null(version)) 
[16:12:45.928]                           version <- utils::packageVersion("future")
[16:12:45.928]                       }
[16:12:45.928]                       else {
[16:12:45.928]                         version <- NULL
[16:12:45.928]                       }
[16:12:45.928]                       if (!has_future || version < "1.8.0") {
[16:12:45.928]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.928]                           "", base::R.version$version.string), 
[16:12:45.928]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.928]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.928]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.928]                             "release", "version")], collapse = " "), 
[16:12:45.928]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.928]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.928]                           info)
[16:12:45.928]                         info <- base::paste(info, collapse = "; ")
[16:12:45.928]                         if (!has_future) {
[16:12:45.928]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.928]                             info)
[16:12:45.928]                         }
[16:12:45.928]                         else {
[16:12:45.928]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.928]                             info, version)
[16:12:45.928]                         }
[16:12:45.928]                         base::stop(msg)
[16:12:45.928]                       }
[16:12:45.928]                     })
[16:12:45.928]                   }
[16:12:45.928]                   options(future.plan = NULL)
[16:12:45.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.928]                 }
[16:12:45.928]                 ...future.workdir <- getwd()
[16:12:45.928]             }
[16:12:45.928]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.928]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.928]         }
[16:12:45.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.928]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.928]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.928]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.928]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.928]             base::names(...future.oldOptions))
[16:12:45.928]     }
[16:12:45.928]     if (FALSE) {
[16:12:45.928]     }
[16:12:45.928]     else {
[16:12:45.928]         if (TRUE) {
[16:12:45.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.928]                 open = "w")
[16:12:45.928]         }
[16:12:45.928]         else {
[16:12:45.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.928]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.928]         }
[16:12:45.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.928]             base::sink(type = "output", split = FALSE)
[16:12:45.928]             base::close(...future.stdout)
[16:12:45.928]         }, add = TRUE)
[16:12:45.928]     }
[16:12:45.928]     ...future.frame <- base::sys.nframe()
[16:12:45.928]     ...future.conditions <- base::list()
[16:12:45.928]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.928]     if (FALSE) {
[16:12:45.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.928]     }
[16:12:45.928]     ...future.result <- base::tryCatch({
[16:12:45.928]         base::withCallingHandlers({
[16:12:45.928]             ...future.value <- base::withVisible(base::local({
[16:12:45.928]                 x[["a"]] <- 1
[16:12:45.928]                 x
[16:12:45.928]             }))
[16:12:45.928]             future::FutureResult(value = ...future.value$value, 
[16:12:45.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.928]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.928]                     ...future.globalenv.names))
[16:12:45.928]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.928]         }, condition = base::local({
[16:12:45.928]             c <- base::c
[16:12:45.928]             inherits <- base::inherits
[16:12:45.928]             invokeRestart <- base::invokeRestart
[16:12:45.928]             length <- base::length
[16:12:45.928]             list <- base::list
[16:12:45.928]             seq.int <- base::seq.int
[16:12:45.928]             signalCondition <- base::signalCondition
[16:12:45.928]             sys.calls <- base::sys.calls
[16:12:45.928]             `[[` <- base::`[[`
[16:12:45.928]             `+` <- base::`+`
[16:12:45.928]             `<<-` <- base::`<<-`
[16:12:45.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.928]                   3L)]
[16:12:45.928]             }
[16:12:45.928]             function(cond) {
[16:12:45.928]                 is_error <- inherits(cond, "error")
[16:12:45.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.928]                   NULL)
[16:12:45.928]                 if (is_error) {
[16:12:45.928]                   sessionInformation <- function() {
[16:12:45.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.928]                       search = base::search(), system = base::Sys.info())
[16:12:45.928]                   }
[16:12:45.928]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.928]                     cond$call), session = sessionInformation(), 
[16:12:45.928]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.928]                   signalCondition(cond)
[16:12:45.928]                 }
[16:12:45.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.928]                 "immediateCondition"))) {
[16:12:45.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.928]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.928]                   if (TRUE && !signal) {
[16:12:45.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.928]                     {
[16:12:45.928]                       inherits <- base::inherits
[16:12:45.928]                       invokeRestart <- base::invokeRestart
[16:12:45.928]                       is.null <- base::is.null
[16:12:45.928]                       muffled <- FALSE
[16:12:45.928]                       if (inherits(cond, "message")) {
[16:12:45.928]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.928]                         if (muffled) 
[16:12:45.928]                           invokeRestart("muffleMessage")
[16:12:45.928]                       }
[16:12:45.928]                       else if (inherits(cond, "warning")) {
[16:12:45.928]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.928]                         if (muffled) 
[16:12:45.928]                           invokeRestart("muffleWarning")
[16:12:45.928]                       }
[16:12:45.928]                       else if (inherits(cond, "condition")) {
[16:12:45.928]                         if (!is.null(pattern)) {
[16:12:45.928]                           computeRestarts <- base::computeRestarts
[16:12:45.928]                           grepl <- base::grepl
[16:12:45.928]                           restarts <- computeRestarts(cond)
[16:12:45.928]                           for (restart in restarts) {
[16:12:45.928]                             name <- restart$name
[16:12:45.928]                             if (is.null(name)) 
[16:12:45.928]                               next
[16:12:45.928]                             if (!grepl(pattern, name)) 
[16:12:45.928]                               next
[16:12:45.928]                             invokeRestart(restart)
[16:12:45.928]                             muffled <- TRUE
[16:12:45.928]                             break
[16:12:45.928]                           }
[16:12:45.928]                         }
[16:12:45.928]                       }
[16:12:45.928]                       invisible(muffled)
[16:12:45.928]                     }
[16:12:45.928]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.928]                   }
[16:12:45.928]                 }
[16:12:45.928]                 else {
[16:12:45.928]                   if (TRUE) {
[16:12:45.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.928]                     {
[16:12:45.928]                       inherits <- base::inherits
[16:12:45.928]                       invokeRestart <- base::invokeRestart
[16:12:45.928]                       is.null <- base::is.null
[16:12:45.928]                       muffled <- FALSE
[16:12:45.928]                       if (inherits(cond, "message")) {
[16:12:45.928]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.928]                         if (muffled) 
[16:12:45.928]                           invokeRestart("muffleMessage")
[16:12:45.928]                       }
[16:12:45.928]                       else if (inherits(cond, "warning")) {
[16:12:45.928]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.928]                         if (muffled) 
[16:12:45.928]                           invokeRestart("muffleWarning")
[16:12:45.928]                       }
[16:12:45.928]                       else if (inherits(cond, "condition")) {
[16:12:45.928]                         if (!is.null(pattern)) {
[16:12:45.928]                           computeRestarts <- base::computeRestarts
[16:12:45.928]                           grepl <- base::grepl
[16:12:45.928]                           restarts <- computeRestarts(cond)
[16:12:45.928]                           for (restart in restarts) {
[16:12:45.928]                             name <- restart$name
[16:12:45.928]                             if (is.null(name)) 
[16:12:45.928]                               next
[16:12:45.928]                             if (!grepl(pattern, name)) 
[16:12:45.928]                               next
[16:12:45.928]                             invokeRestart(restart)
[16:12:45.928]                             muffled <- TRUE
[16:12:45.928]                             break
[16:12:45.928]                           }
[16:12:45.928]                         }
[16:12:45.928]                       }
[16:12:45.928]                       invisible(muffled)
[16:12:45.928]                     }
[16:12:45.928]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.928]                   }
[16:12:45.928]                 }
[16:12:45.928]             }
[16:12:45.928]         }))
[16:12:45.928]     }, error = function(ex) {
[16:12:45.928]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.928]                 ...future.rng), started = ...future.startTime, 
[16:12:45.928]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.928]             version = "1.8"), class = "FutureResult")
[16:12:45.928]     }, finally = {
[16:12:45.928]         if (!identical(...future.workdir, getwd())) 
[16:12:45.928]             setwd(...future.workdir)
[16:12:45.928]         {
[16:12:45.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.928]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.928]             }
[16:12:45.928]             base::options(...future.oldOptions)
[16:12:45.928]             if (.Platform$OS.type == "windows") {
[16:12:45.928]                 old_names <- names(...future.oldEnvVars)
[16:12:45.928]                 envs <- base::Sys.getenv()
[16:12:45.928]                 names <- names(envs)
[16:12:45.928]                 common <- intersect(names, old_names)
[16:12:45.928]                 added <- setdiff(names, old_names)
[16:12:45.928]                 removed <- setdiff(old_names, names)
[16:12:45.928]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.928]                   envs[common]]
[16:12:45.928]                 NAMES <- toupper(changed)
[16:12:45.928]                 args <- list()
[16:12:45.928]                 for (kk in seq_along(NAMES)) {
[16:12:45.928]                   name <- changed[[kk]]
[16:12:45.928]                   NAME <- NAMES[[kk]]
[16:12:45.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.928]                     next
[16:12:45.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.928]                 }
[16:12:45.928]                 NAMES <- toupper(added)
[16:12:45.928]                 for (kk in seq_along(NAMES)) {
[16:12:45.928]                   name <- added[[kk]]
[16:12:45.928]                   NAME <- NAMES[[kk]]
[16:12:45.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.928]                     next
[16:12:45.928]                   args[[name]] <- ""
[16:12:45.928]                 }
[16:12:45.928]                 NAMES <- toupper(removed)
[16:12:45.928]                 for (kk in seq_along(NAMES)) {
[16:12:45.928]                   name <- removed[[kk]]
[16:12:45.928]                   NAME <- NAMES[[kk]]
[16:12:45.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.928]                     next
[16:12:45.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.928]                 }
[16:12:45.928]                 if (length(args) > 0) 
[16:12:45.928]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.928]             }
[16:12:45.928]             else {
[16:12:45.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.928]             }
[16:12:45.928]             {
[16:12:45.928]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.928]                   0L) {
[16:12:45.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.928]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.928]                   base::options(opts)
[16:12:45.928]                 }
[16:12:45.928]                 {
[16:12:45.928]                   {
[16:12:45.928]                     NULL
[16:12:45.928]                     RNGkind("Mersenne-Twister")
[16:12:45.928]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.928]                       inherits = FALSE)
[16:12:45.928]                   }
[16:12:45.928]                   options(future.plan = NULL)
[16:12:45.928]                   if (is.na(NA_character_)) 
[16:12:45.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.928]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.928]                   {
[16:12:45.928]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.928]                     if (!future$lazy) 
[16:12:45.928]                       future <- run(future)
[16:12:45.928]                     invisible(future)
[16:12:45.928]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.928]                 }
[16:12:45.928]             }
[16:12:45.928]         }
[16:12:45.928]     })
[16:12:45.928]     if (TRUE) {
[16:12:45.928]         base::sink(type = "output", split = FALSE)
[16:12:45.928]         if (TRUE) {
[16:12:45.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.928]         }
[16:12:45.928]         else {
[16:12:45.928]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.928]         }
[16:12:45.928]         base::close(...future.stdout)
[16:12:45.928]         ...future.stdout <- NULL
[16:12:45.928]     }
[16:12:45.928]     ...future.result$conditions <- ...future.conditions
[16:12:45.928]     ...future.result$finished <- base::Sys.time()
[16:12:45.928]     ...future.result
[16:12:45.928] }
[16:12:45.930] assign_globals() ...
[16:12:45.930] List of 1
[16:12:45.930]  $ x: list()
[16:12:45.930]  - attr(*, "where")=List of 1
[16:12:45.930]   ..$ x:<environment: R_EmptyEnv> 
[16:12:45.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:45.930]  - attr(*, "resolved")= logi TRUE
[16:12:45.930]  - attr(*, "total_size")= num 0
[16:12:45.930]  - attr(*, "already-done")= logi TRUE
[16:12:45.932] - copied ‘x’ to environment
[16:12:45.932] assign_globals() ... done
[16:12:45.932] plan(): Setting new future strategy stack:
[16:12:45.933] List of future strategies:
[16:12:45.933] 1. sequential:
[16:12:45.933]    - args: function (..., envir = parent.frame())
[16:12:45.933]    - tweaked: FALSE
[16:12:45.933]    - call: NULL
[16:12:45.933] plan(): nbrOfWorkers() = 1
[16:12:45.934] plan(): Setting new future strategy stack:
[16:12:45.934] List of future strategies:
[16:12:45.934] 1. sequential:
[16:12:45.934]    - args: function (..., envir = parent.frame())
[16:12:45.934]    - tweaked: FALSE
[16:12:45.934]    - call: plan(strategy)
[16:12:45.934] plan(): nbrOfWorkers() = 1
[16:12:45.934] SequentialFuture started (and completed)
[16:12:45.934] - Launch lazy future ... done
[16:12:45.935] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.935] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.935] Searching for globals...
[16:12:45.937] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:45.937] Searching for globals ... DONE
[16:12:45.937] Resolving globals: TRUE
[16:12:45.937] Resolving any globals that are futures ...
[16:12:45.938] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:45.938] Resolving any globals that are futures ... DONE
[16:12:45.938] Resolving futures part of globals (recursively) ...
[16:12:45.938] resolve() on list ...
[16:12:45.938]  recursive: 99
[16:12:45.938]  length: 1
[16:12:45.938]  elements: ‘x’
[16:12:45.939]  length: 0 (resolved future 1)
[16:12:45.939] resolve() on list ... DONE
[16:12:45.939] - globals: [1] ‘x’
[16:12:45.939] Resolving futures part of globals (recursively) ... DONE
[16:12:45.939] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:45.939] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:45.939] - globals: [1] ‘x’
[16:12:45.940] 
[16:12:45.940] getGlobalsAndPackages() ... DONE
[16:12:45.940] run() for ‘Future’ ...
[16:12:45.940] - state: ‘created’
[16:12:45.940] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.940] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.941]   - Field: ‘label’
[16:12:45.941]   - Field: ‘local’
[16:12:45.941]   - Field: ‘owner’
[16:12:45.941]   - Field: ‘envir’
[16:12:45.941]   - Field: ‘packages’
[16:12:45.941]   - Field: ‘gc’
[16:12:45.941]   - Field: ‘conditions’
[16:12:45.941]   - Field: ‘expr’
[16:12:45.941]   - Field: ‘uuid’
[16:12:45.941]   - Field: ‘seed’
[16:12:45.942]   - Field: ‘version’
[16:12:45.942]   - Field: ‘result’
[16:12:45.942]   - Field: ‘asynchronous’
[16:12:45.942]   - Field: ‘calls’
[16:12:45.942]   - Field: ‘globals’
[16:12:45.942]   - Field: ‘stdout’
[16:12:45.942]   - Field: ‘earlySignal’
[16:12:45.942]   - Field: ‘lazy’
[16:12:45.942]   - Field: ‘state’
[16:12:45.942] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.942] - Launch lazy future ...
[16:12:45.943] Packages needed by the future expression (n = 0): <none>
[16:12:45.943] Packages needed by future strategies (n = 0): <none>
[16:12:45.943] {
[16:12:45.943]     {
[16:12:45.943]         {
[16:12:45.943]             ...future.startTime <- base::Sys.time()
[16:12:45.943]             {
[16:12:45.943]                 {
[16:12:45.943]                   {
[16:12:45.943]                     base::local({
[16:12:45.943]                       has_future <- base::requireNamespace("future", 
[16:12:45.943]                         quietly = TRUE)
[16:12:45.943]                       if (has_future) {
[16:12:45.943]                         ns <- base::getNamespace("future")
[16:12:45.943]                         version <- ns[[".package"]][["version"]]
[16:12:45.943]                         if (is.null(version)) 
[16:12:45.943]                           version <- utils::packageVersion("future")
[16:12:45.943]                       }
[16:12:45.943]                       else {
[16:12:45.943]                         version <- NULL
[16:12:45.943]                       }
[16:12:45.943]                       if (!has_future || version < "1.8.0") {
[16:12:45.943]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.943]                           "", base::R.version$version.string), 
[16:12:45.943]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.943]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.943]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.943]                             "release", "version")], collapse = " "), 
[16:12:45.943]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.943]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.943]                           info)
[16:12:45.943]                         info <- base::paste(info, collapse = "; ")
[16:12:45.943]                         if (!has_future) {
[16:12:45.943]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.943]                             info)
[16:12:45.943]                         }
[16:12:45.943]                         else {
[16:12:45.943]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.943]                             info, version)
[16:12:45.943]                         }
[16:12:45.943]                         base::stop(msg)
[16:12:45.943]                       }
[16:12:45.943]                     })
[16:12:45.943]                   }
[16:12:45.943]                   options(future.plan = NULL)
[16:12:45.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.943]                 }
[16:12:45.943]                 ...future.workdir <- getwd()
[16:12:45.943]             }
[16:12:45.943]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.943]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.943]         }
[16:12:45.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.943]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.943]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.943]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.943]             base::names(...future.oldOptions))
[16:12:45.943]     }
[16:12:45.943]     if (FALSE) {
[16:12:45.943]     }
[16:12:45.943]     else {
[16:12:45.943]         if (TRUE) {
[16:12:45.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.943]                 open = "w")
[16:12:45.943]         }
[16:12:45.943]         else {
[16:12:45.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.943]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.943]         }
[16:12:45.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.943]             base::sink(type = "output", split = FALSE)
[16:12:45.943]             base::close(...future.stdout)
[16:12:45.943]         }, add = TRUE)
[16:12:45.943]     }
[16:12:45.943]     ...future.frame <- base::sys.nframe()
[16:12:45.943]     ...future.conditions <- base::list()
[16:12:45.943]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.943]     if (FALSE) {
[16:12:45.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.943]     }
[16:12:45.943]     ...future.result <- base::tryCatch({
[16:12:45.943]         base::withCallingHandlers({
[16:12:45.943]             ...future.value <- base::withVisible(base::local({
[16:12:45.943]                 x["a"] <- list(1)
[16:12:45.943]                 x
[16:12:45.943]             }))
[16:12:45.943]             future::FutureResult(value = ...future.value$value, 
[16:12:45.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.943]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.943]                     ...future.globalenv.names))
[16:12:45.943]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.943]         }, condition = base::local({
[16:12:45.943]             c <- base::c
[16:12:45.943]             inherits <- base::inherits
[16:12:45.943]             invokeRestart <- base::invokeRestart
[16:12:45.943]             length <- base::length
[16:12:45.943]             list <- base::list
[16:12:45.943]             seq.int <- base::seq.int
[16:12:45.943]             signalCondition <- base::signalCondition
[16:12:45.943]             sys.calls <- base::sys.calls
[16:12:45.943]             `[[` <- base::`[[`
[16:12:45.943]             `+` <- base::`+`
[16:12:45.943]             `<<-` <- base::`<<-`
[16:12:45.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.943]                   3L)]
[16:12:45.943]             }
[16:12:45.943]             function(cond) {
[16:12:45.943]                 is_error <- inherits(cond, "error")
[16:12:45.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.943]                   NULL)
[16:12:45.943]                 if (is_error) {
[16:12:45.943]                   sessionInformation <- function() {
[16:12:45.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.943]                       search = base::search(), system = base::Sys.info())
[16:12:45.943]                   }
[16:12:45.943]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.943]                     cond$call), session = sessionInformation(), 
[16:12:45.943]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.943]                   signalCondition(cond)
[16:12:45.943]                 }
[16:12:45.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.943]                 "immediateCondition"))) {
[16:12:45.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.943]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.943]                   if (TRUE && !signal) {
[16:12:45.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.943]                     {
[16:12:45.943]                       inherits <- base::inherits
[16:12:45.943]                       invokeRestart <- base::invokeRestart
[16:12:45.943]                       is.null <- base::is.null
[16:12:45.943]                       muffled <- FALSE
[16:12:45.943]                       if (inherits(cond, "message")) {
[16:12:45.943]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.943]                         if (muffled) 
[16:12:45.943]                           invokeRestart("muffleMessage")
[16:12:45.943]                       }
[16:12:45.943]                       else if (inherits(cond, "warning")) {
[16:12:45.943]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.943]                         if (muffled) 
[16:12:45.943]                           invokeRestart("muffleWarning")
[16:12:45.943]                       }
[16:12:45.943]                       else if (inherits(cond, "condition")) {
[16:12:45.943]                         if (!is.null(pattern)) {
[16:12:45.943]                           computeRestarts <- base::computeRestarts
[16:12:45.943]                           grepl <- base::grepl
[16:12:45.943]                           restarts <- computeRestarts(cond)
[16:12:45.943]                           for (restart in restarts) {
[16:12:45.943]                             name <- restart$name
[16:12:45.943]                             if (is.null(name)) 
[16:12:45.943]                               next
[16:12:45.943]                             if (!grepl(pattern, name)) 
[16:12:45.943]                               next
[16:12:45.943]                             invokeRestart(restart)
[16:12:45.943]                             muffled <- TRUE
[16:12:45.943]                             break
[16:12:45.943]                           }
[16:12:45.943]                         }
[16:12:45.943]                       }
[16:12:45.943]                       invisible(muffled)
[16:12:45.943]                     }
[16:12:45.943]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.943]                   }
[16:12:45.943]                 }
[16:12:45.943]                 else {
[16:12:45.943]                   if (TRUE) {
[16:12:45.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.943]                     {
[16:12:45.943]                       inherits <- base::inherits
[16:12:45.943]                       invokeRestart <- base::invokeRestart
[16:12:45.943]                       is.null <- base::is.null
[16:12:45.943]                       muffled <- FALSE
[16:12:45.943]                       if (inherits(cond, "message")) {
[16:12:45.943]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.943]                         if (muffled) 
[16:12:45.943]                           invokeRestart("muffleMessage")
[16:12:45.943]                       }
[16:12:45.943]                       else if (inherits(cond, "warning")) {
[16:12:45.943]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.943]                         if (muffled) 
[16:12:45.943]                           invokeRestart("muffleWarning")
[16:12:45.943]                       }
[16:12:45.943]                       else if (inherits(cond, "condition")) {
[16:12:45.943]                         if (!is.null(pattern)) {
[16:12:45.943]                           computeRestarts <- base::computeRestarts
[16:12:45.943]                           grepl <- base::grepl
[16:12:45.943]                           restarts <- computeRestarts(cond)
[16:12:45.943]                           for (restart in restarts) {
[16:12:45.943]                             name <- restart$name
[16:12:45.943]                             if (is.null(name)) 
[16:12:45.943]                               next
[16:12:45.943]                             if (!grepl(pattern, name)) 
[16:12:45.943]                               next
[16:12:45.943]                             invokeRestart(restart)
[16:12:45.943]                             muffled <- TRUE
[16:12:45.943]                             break
[16:12:45.943]                           }
[16:12:45.943]                         }
[16:12:45.943]                       }
[16:12:45.943]                       invisible(muffled)
[16:12:45.943]                     }
[16:12:45.943]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.943]                   }
[16:12:45.943]                 }
[16:12:45.943]             }
[16:12:45.943]         }))
[16:12:45.943]     }, error = function(ex) {
[16:12:45.943]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.943]                 ...future.rng), started = ...future.startTime, 
[16:12:45.943]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.943]             version = "1.8"), class = "FutureResult")
[16:12:45.943]     }, finally = {
[16:12:45.943]         if (!identical(...future.workdir, getwd())) 
[16:12:45.943]             setwd(...future.workdir)
[16:12:45.943]         {
[16:12:45.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.943]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.943]             }
[16:12:45.943]             base::options(...future.oldOptions)
[16:12:45.943]             if (.Platform$OS.type == "windows") {
[16:12:45.943]                 old_names <- names(...future.oldEnvVars)
[16:12:45.943]                 envs <- base::Sys.getenv()
[16:12:45.943]                 names <- names(envs)
[16:12:45.943]                 common <- intersect(names, old_names)
[16:12:45.943]                 added <- setdiff(names, old_names)
[16:12:45.943]                 removed <- setdiff(old_names, names)
[16:12:45.943]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.943]                   envs[common]]
[16:12:45.943]                 NAMES <- toupper(changed)
[16:12:45.943]                 args <- list()
[16:12:45.943]                 for (kk in seq_along(NAMES)) {
[16:12:45.943]                   name <- changed[[kk]]
[16:12:45.943]                   NAME <- NAMES[[kk]]
[16:12:45.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.943]                     next
[16:12:45.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.943]                 }
[16:12:45.943]                 NAMES <- toupper(added)
[16:12:45.943]                 for (kk in seq_along(NAMES)) {
[16:12:45.943]                   name <- added[[kk]]
[16:12:45.943]                   NAME <- NAMES[[kk]]
[16:12:45.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.943]                     next
[16:12:45.943]                   args[[name]] <- ""
[16:12:45.943]                 }
[16:12:45.943]                 NAMES <- toupper(removed)
[16:12:45.943]                 for (kk in seq_along(NAMES)) {
[16:12:45.943]                   name <- removed[[kk]]
[16:12:45.943]                   NAME <- NAMES[[kk]]
[16:12:45.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.943]                     next
[16:12:45.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.943]                 }
[16:12:45.943]                 if (length(args) > 0) 
[16:12:45.943]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.943]             }
[16:12:45.943]             else {
[16:12:45.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.943]             }
[16:12:45.943]             {
[16:12:45.943]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.943]                   0L) {
[16:12:45.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.943]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.943]                   base::options(opts)
[16:12:45.943]                 }
[16:12:45.943]                 {
[16:12:45.943]                   {
[16:12:45.943]                     NULL
[16:12:45.943]                     RNGkind("Mersenne-Twister")
[16:12:45.943]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.943]                       inherits = FALSE)
[16:12:45.943]                   }
[16:12:45.943]                   options(future.plan = NULL)
[16:12:45.943]                   if (is.na(NA_character_)) 
[16:12:45.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.943]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.943]                   {
[16:12:45.943]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.943]                     if (!future$lazy) 
[16:12:45.943]                       future <- run(future)
[16:12:45.943]                     invisible(future)
[16:12:45.943]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.943]                 }
[16:12:45.943]             }
[16:12:45.943]         }
[16:12:45.943]     })
[16:12:45.943]     if (TRUE) {
[16:12:45.943]         base::sink(type = "output", split = FALSE)
[16:12:45.943]         if (TRUE) {
[16:12:45.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.943]         }
[16:12:45.943]         else {
[16:12:45.943]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.943]         }
[16:12:45.943]         base::close(...future.stdout)
[16:12:45.943]         ...future.stdout <- NULL
[16:12:45.943]     }
[16:12:45.943]     ...future.result$conditions <- ...future.conditions
[16:12:45.943]     ...future.result$finished <- base::Sys.time()
[16:12:45.943]     ...future.result
[16:12:45.943] }
[16:12:45.945] assign_globals() ...
[16:12:45.945] List of 1
[16:12:45.945]  $ x: list()
[16:12:45.945]  - attr(*, "where")=List of 1
[16:12:45.945]   ..$ x:<environment: R_EmptyEnv> 
[16:12:45.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:45.945]  - attr(*, "resolved")= logi TRUE
[16:12:45.945]  - attr(*, "total_size")= num 0
[16:12:45.945]  - attr(*, "already-done")= logi TRUE
[16:12:45.947] - copied ‘x’ to environment
[16:12:45.947] assign_globals() ... done
[16:12:45.947] plan(): Setting new future strategy stack:
[16:12:45.948] List of future strategies:
[16:12:45.948] 1. sequential:
[16:12:45.948]    - args: function (..., envir = parent.frame())
[16:12:45.948]    - tweaked: FALSE
[16:12:45.948]    - call: NULL
[16:12:45.948] plan(): nbrOfWorkers() = 1
[16:12:45.949] plan(): Setting new future strategy stack:
[16:12:45.949] List of future strategies:
[16:12:45.949] 1. sequential:
[16:12:45.949]    - args: function (..., envir = parent.frame())
[16:12:45.949]    - tweaked: FALSE
[16:12:45.949]    - call: plan(strategy)
[16:12:45.949] plan(): nbrOfWorkers() = 1
[16:12:45.949] SequentialFuture started (and completed)
[16:12:45.949] - Launch lazy future ... done
[16:12:45.949] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.950] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.950] Searching for globals...
[16:12:45.954] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:45.954] Searching for globals ... DONE
[16:12:45.954] Resolving globals: TRUE
[16:12:45.954] Resolving any globals that are futures ...
[16:12:45.954] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:45.954] Resolving any globals that are futures ... DONE
[16:12:45.955] Resolving futures part of globals (recursively) ...
[16:12:45.955] resolve() on list ...
[16:12:45.955]  recursive: 99
[16:12:45.955]  length: 1
[16:12:45.955]  elements: ‘x’
[16:12:45.955]  length: 0 (resolved future 1)
[16:12:45.955] resolve() on list ... DONE
[16:12:45.955] - globals: [1] ‘x’
[16:12:45.956] Resolving futures part of globals (recursively) ... DONE
[16:12:45.956] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:45.956] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:45.956] - globals: [1] ‘x’
[16:12:45.956] 
[16:12:45.956] getGlobalsAndPackages() ... DONE
[16:12:45.957] run() for ‘Future’ ...
[16:12:45.957] - state: ‘created’
[16:12:45.957] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.957] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.957] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.957]   - Field: ‘label’
[16:12:45.957]   - Field: ‘local’
[16:12:45.958]   - Field: ‘owner’
[16:12:45.958]   - Field: ‘envir’
[16:12:45.958]   - Field: ‘packages’
[16:12:45.958]   - Field: ‘gc’
[16:12:45.958]   - Field: ‘conditions’
[16:12:45.958]   - Field: ‘expr’
[16:12:45.958]   - Field: ‘uuid’
[16:12:45.958]   - Field: ‘seed’
[16:12:45.958]   - Field: ‘version’
[16:12:45.958]   - Field: ‘result’
[16:12:45.958]   - Field: ‘asynchronous’
[16:12:45.959]   - Field: ‘calls’
[16:12:45.959]   - Field: ‘globals’
[16:12:45.959]   - Field: ‘stdout’
[16:12:45.959]   - Field: ‘earlySignal’
[16:12:45.959]   - Field: ‘lazy’
[16:12:45.959]   - Field: ‘state’
[16:12:45.959] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.959] - Launch lazy future ...
[16:12:45.959] Packages needed by the future expression (n = 0): <none>
[16:12:45.959] Packages needed by future strategies (n = 0): <none>
[16:12:45.960] {
[16:12:45.960]     {
[16:12:45.960]         {
[16:12:45.960]             ...future.startTime <- base::Sys.time()
[16:12:45.960]             {
[16:12:45.960]                 {
[16:12:45.960]                   {
[16:12:45.960]                     base::local({
[16:12:45.960]                       has_future <- base::requireNamespace("future", 
[16:12:45.960]                         quietly = TRUE)
[16:12:45.960]                       if (has_future) {
[16:12:45.960]                         ns <- base::getNamespace("future")
[16:12:45.960]                         version <- ns[[".package"]][["version"]]
[16:12:45.960]                         if (is.null(version)) 
[16:12:45.960]                           version <- utils::packageVersion("future")
[16:12:45.960]                       }
[16:12:45.960]                       else {
[16:12:45.960]                         version <- NULL
[16:12:45.960]                       }
[16:12:45.960]                       if (!has_future || version < "1.8.0") {
[16:12:45.960]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.960]                           "", base::R.version$version.string), 
[16:12:45.960]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.960]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.960]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.960]                             "release", "version")], collapse = " "), 
[16:12:45.960]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.960]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.960]                           info)
[16:12:45.960]                         info <- base::paste(info, collapse = "; ")
[16:12:45.960]                         if (!has_future) {
[16:12:45.960]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.960]                             info)
[16:12:45.960]                         }
[16:12:45.960]                         else {
[16:12:45.960]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.960]                             info, version)
[16:12:45.960]                         }
[16:12:45.960]                         base::stop(msg)
[16:12:45.960]                       }
[16:12:45.960]                     })
[16:12:45.960]                   }
[16:12:45.960]                   options(future.plan = NULL)
[16:12:45.960]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.960]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.960]                 }
[16:12:45.960]                 ...future.workdir <- getwd()
[16:12:45.960]             }
[16:12:45.960]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.960]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.960]         }
[16:12:45.960]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.960]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.960]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.960]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.960]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.960]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.960]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.960]             base::names(...future.oldOptions))
[16:12:45.960]     }
[16:12:45.960]     if (FALSE) {
[16:12:45.960]     }
[16:12:45.960]     else {
[16:12:45.960]         if (TRUE) {
[16:12:45.960]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.960]                 open = "w")
[16:12:45.960]         }
[16:12:45.960]         else {
[16:12:45.960]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.960]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.960]         }
[16:12:45.960]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.960]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.960]             base::sink(type = "output", split = FALSE)
[16:12:45.960]             base::close(...future.stdout)
[16:12:45.960]         }, add = TRUE)
[16:12:45.960]     }
[16:12:45.960]     ...future.frame <- base::sys.nframe()
[16:12:45.960]     ...future.conditions <- base::list()
[16:12:45.960]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.960]     if (FALSE) {
[16:12:45.960]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.960]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.960]     }
[16:12:45.960]     ...future.result <- base::tryCatch({
[16:12:45.960]         base::withCallingHandlers({
[16:12:45.960]             ...future.value <- base::withVisible(base::local({
[16:12:45.960]                 x["a"] <- list(1)
[16:12:45.960]                 x
[16:12:45.960]             }))
[16:12:45.960]             future::FutureResult(value = ...future.value$value, 
[16:12:45.960]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.960]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.960]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.960]                     ...future.globalenv.names))
[16:12:45.960]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.960]         }, condition = base::local({
[16:12:45.960]             c <- base::c
[16:12:45.960]             inherits <- base::inherits
[16:12:45.960]             invokeRestart <- base::invokeRestart
[16:12:45.960]             length <- base::length
[16:12:45.960]             list <- base::list
[16:12:45.960]             seq.int <- base::seq.int
[16:12:45.960]             signalCondition <- base::signalCondition
[16:12:45.960]             sys.calls <- base::sys.calls
[16:12:45.960]             `[[` <- base::`[[`
[16:12:45.960]             `+` <- base::`+`
[16:12:45.960]             `<<-` <- base::`<<-`
[16:12:45.960]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.960]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.960]                   3L)]
[16:12:45.960]             }
[16:12:45.960]             function(cond) {
[16:12:45.960]                 is_error <- inherits(cond, "error")
[16:12:45.960]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.960]                   NULL)
[16:12:45.960]                 if (is_error) {
[16:12:45.960]                   sessionInformation <- function() {
[16:12:45.960]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.960]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.960]                       search = base::search(), system = base::Sys.info())
[16:12:45.960]                   }
[16:12:45.960]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.960]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.960]                     cond$call), session = sessionInformation(), 
[16:12:45.960]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.960]                   signalCondition(cond)
[16:12:45.960]                 }
[16:12:45.960]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.960]                 "immediateCondition"))) {
[16:12:45.960]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.960]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.960]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.960]                   if (TRUE && !signal) {
[16:12:45.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.960]                     {
[16:12:45.960]                       inherits <- base::inherits
[16:12:45.960]                       invokeRestart <- base::invokeRestart
[16:12:45.960]                       is.null <- base::is.null
[16:12:45.960]                       muffled <- FALSE
[16:12:45.960]                       if (inherits(cond, "message")) {
[16:12:45.960]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.960]                         if (muffled) 
[16:12:45.960]                           invokeRestart("muffleMessage")
[16:12:45.960]                       }
[16:12:45.960]                       else if (inherits(cond, "warning")) {
[16:12:45.960]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.960]                         if (muffled) 
[16:12:45.960]                           invokeRestart("muffleWarning")
[16:12:45.960]                       }
[16:12:45.960]                       else if (inherits(cond, "condition")) {
[16:12:45.960]                         if (!is.null(pattern)) {
[16:12:45.960]                           computeRestarts <- base::computeRestarts
[16:12:45.960]                           grepl <- base::grepl
[16:12:45.960]                           restarts <- computeRestarts(cond)
[16:12:45.960]                           for (restart in restarts) {
[16:12:45.960]                             name <- restart$name
[16:12:45.960]                             if (is.null(name)) 
[16:12:45.960]                               next
[16:12:45.960]                             if (!grepl(pattern, name)) 
[16:12:45.960]                               next
[16:12:45.960]                             invokeRestart(restart)
[16:12:45.960]                             muffled <- TRUE
[16:12:45.960]                             break
[16:12:45.960]                           }
[16:12:45.960]                         }
[16:12:45.960]                       }
[16:12:45.960]                       invisible(muffled)
[16:12:45.960]                     }
[16:12:45.960]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.960]                   }
[16:12:45.960]                 }
[16:12:45.960]                 else {
[16:12:45.960]                   if (TRUE) {
[16:12:45.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.960]                     {
[16:12:45.960]                       inherits <- base::inherits
[16:12:45.960]                       invokeRestart <- base::invokeRestart
[16:12:45.960]                       is.null <- base::is.null
[16:12:45.960]                       muffled <- FALSE
[16:12:45.960]                       if (inherits(cond, "message")) {
[16:12:45.960]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.960]                         if (muffled) 
[16:12:45.960]                           invokeRestart("muffleMessage")
[16:12:45.960]                       }
[16:12:45.960]                       else if (inherits(cond, "warning")) {
[16:12:45.960]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.960]                         if (muffled) 
[16:12:45.960]                           invokeRestart("muffleWarning")
[16:12:45.960]                       }
[16:12:45.960]                       else if (inherits(cond, "condition")) {
[16:12:45.960]                         if (!is.null(pattern)) {
[16:12:45.960]                           computeRestarts <- base::computeRestarts
[16:12:45.960]                           grepl <- base::grepl
[16:12:45.960]                           restarts <- computeRestarts(cond)
[16:12:45.960]                           for (restart in restarts) {
[16:12:45.960]                             name <- restart$name
[16:12:45.960]                             if (is.null(name)) 
[16:12:45.960]                               next
[16:12:45.960]                             if (!grepl(pattern, name)) 
[16:12:45.960]                               next
[16:12:45.960]                             invokeRestart(restart)
[16:12:45.960]                             muffled <- TRUE
[16:12:45.960]                             break
[16:12:45.960]                           }
[16:12:45.960]                         }
[16:12:45.960]                       }
[16:12:45.960]                       invisible(muffled)
[16:12:45.960]                     }
[16:12:45.960]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.960]                   }
[16:12:45.960]                 }
[16:12:45.960]             }
[16:12:45.960]         }))
[16:12:45.960]     }, error = function(ex) {
[16:12:45.960]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.960]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.960]                 ...future.rng), started = ...future.startTime, 
[16:12:45.960]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.960]             version = "1.8"), class = "FutureResult")
[16:12:45.960]     }, finally = {
[16:12:45.960]         if (!identical(...future.workdir, getwd())) 
[16:12:45.960]             setwd(...future.workdir)
[16:12:45.960]         {
[16:12:45.960]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.960]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.960]             }
[16:12:45.960]             base::options(...future.oldOptions)
[16:12:45.960]             if (.Platform$OS.type == "windows") {
[16:12:45.960]                 old_names <- names(...future.oldEnvVars)
[16:12:45.960]                 envs <- base::Sys.getenv()
[16:12:45.960]                 names <- names(envs)
[16:12:45.960]                 common <- intersect(names, old_names)
[16:12:45.960]                 added <- setdiff(names, old_names)
[16:12:45.960]                 removed <- setdiff(old_names, names)
[16:12:45.960]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.960]                   envs[common]]
[16:12:45.960]                 NAMES <- toupper(changed)
[16:12:45.960]                 args <- list()
[16:12:45.960]                 for (kk in seq_along(NAMES)) {
[16:12:45.960]                   name <- changed[[kk]]
[16:12:45.960]                   NAME <- NAMES[[kk]]
[16:12:45.960]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.960]                     next
[16:12:45.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.960]                 }
[16:12:45.960]                 NAMES <- toupper(added)
[16:12:45.960]                 for (kk in seq_along(NAMES)) {
[16:12:45.960]                   name <- added[[kk]]
[16:12:45.960]                   NAME <- NAMES[[kk]]
[16:12:45.960]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.960]                     next
[16:12:45.960]                   args[[name]] <- ""
[16:12:45.960]                 }
[16:12:45.960]                 NAMES <- toupper(removed)
[16:12:45.960]                 for (kk in seq_along(NAMES)) {
[16:12:45.960]                   name <- removed[[kk]]
[16:12:45.960]                   NAME <- NAMES[[kk]]
[16:12:45.960]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.960]                     next
[16:12:45.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.960]                 }
[16:12:45.960]                 if (length(args) > 0) 
[16:12:45.960]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.960]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.960]             }
[16:12:45.960]             else {
[16:12:45.960]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.960]             }
[16:12:45.960]             {
[16:12:45.960]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.960]                   0L) {
[16:12:45.960]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.960]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.960]                   base::options(opts)
[16:12:45.960]                 }
[16:12:45.960]                 {
[16:12:45.960]                   {
[16:12:45.960]                     NULL
[16:12:45.960]                     RNGkind("Mersenne-Twister")
[16:12:45.960]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.960]                       inherits = FALSE)
[16:12:45.960]                   }
[16:12:45.960]                   options(future.plan = NULL)
[16:12:45.960]                   if (is.na(NA_character_)) 
[16:12:45.960]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.960]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.960]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.960]                   {
[16:12:45.960]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.960]                     if (!future$lazy) 
[16:12:45.960]                       future <- run(future)
[16:12:45.960]                     invisible(future)
[16:12:45.960]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.960]                 }
[16:12:45.960]             }
[16:12:45.960]         }
[16:12:45.960]     })
[16:12:45.960]     if (TRUE) {
[16:12:45.960]         base::sink(type = "output", split = FALSE)
[16:12:45.960]         if (TRUE) {
[16:12:45.960]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.960]         }
[16:12:45.960]         else {
[16:12:45.960]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.960]         }
[16:12:45.960]         base::close(...future.stdout)
[16:12:45.960]         ...future.stdout <- NULL
[16:12:45.960]     }
[16:12:45.960]     ...future.result$conditions <- ...future.conditions
[16:12:45.960]     ...future.result$finished <- base::Sys.time()
[16:12:45.960]     ...future.result
[16:12:45.960] }
[16:12:45.961] assign_globals() ...
[16:12:45.962] List of 1
[16:12:45.962]  $ x: list()
[16:12:45.962]  - attr(*, "where")=List of 1
[16:12:45.962]   ..$ x:<environment: R_EmptyEnv> 
[16:12:45.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:45.962]  - attr(*, "resolved")= logi TRUE
[16:12:45.962]  - attr(*, "total_size")= num 0
[16:12:45.962]  - attr(*, "already-done")= logi TRUE
[16:12:45.964] - copied ‘x’ to environment
[16:12:45.964] assign_globals() ... done
[16:12:45.964] plan(): Setting new future strategy stack:
[16:12:45.964] List of future strategies:
[16:12:45.964] 1. sequential:
[16:12:45.964]    - args: function (..., envir = parent.frame())
[16:12:45.964]    - tweaked: FALSE
[16:12:45.964]    - call: NULL
[16:12:45.965] plan(): nbrOfWorkers() = 1
[16:12:45.965] plan(): Setting new future strategy stack:
[16:12:45.965] List of future strategies:
[16:12:45.965] 1. sequential:
[16:12:45.965]    - args: function (..., envir = parent.frame())
[16:12:45.965]    - tweaked: FALSE
[16:12:45.965]    - call: plan(strategy)
[16:12:45.966] plan(): nbrOfWorkers() = 1
[16:12:45.966] SequentialFuture started (and completed)
[16:12:45.966] - Launch lazy future ... done
[16:12:45.966] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.967] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.967] Searching for globals...
[16:12:45.969] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:45.969] Searching for globals ... DONE
[16:12:45.969] Resolving globals: TRUE
[16:12:45.969] Resolving any globals that are futures ...
[16:12:45.969] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:45.969] Resolving any globals that are futures ... DONE
[16:12:45.970] Resolving futures part of globals (recursively) ...
[16:12:45.970] resolve() on list ...
[16:12:45.970]  recursive: 99
[16:12:45.970]  length: 1
[16:12:45.970]  elements: ‘x’
[16:12:45.970]  length: 0 (resolved future 1)
[16:12:45.970] resolve() on list ... DONE
[16:12:45.970] - globals: [1] ‘x’
[16:12:45.970] Resolving futures part of globals (recursively) ... DONE
[16:12:45.971] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:45.971] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:45.971] - globals: [1] ‘x’
[16:12:45.971] 
[16:12:45.971] getGlobalsAndPackages() ... DONE
[16:12:45.971] run() for ‘Future’ ...
[16:12:45.972] - state: ‘created’
[16:12:45.972] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.972] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.972] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.972]   - Field: ‘label’
[16:12:45.972]   - Field: ‘local’
[16:12:45.972]   - Field: ‘owner’
[16:12:45.972]   - Field: ‘envir’
[16:12:45.973]   - Field: ‘packages’
[16:12:45.973]   - Field: ‘gc’
[16:12:45.973]   - Field: ‘conditions’
[16:12:45.973]   - Field: ‘expr’
[16:12:45.973]   - Field: ‘uuid’
[16:12:45.973]   - Field: ‘seed’
[16:12:45.973]   - Field: ‘version’
[16:12:45.973]   - Field: ‘result’
[16:12:45.973]   - Field: ‘asynchronous’
[16:12:45.973]   - Field: ‘calls’
[16:12:45.973]   - Field: ‘globals’
[16:12:45.974]   - Field: ‘stdout’
[16:12:45.974]   - Field: ‘earlySignal’
[16:12:45.974]   - Field: ‘lazy’
[16:12:45.974]   - Field: ‘state’
[16:12:45.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.974] - Launch lazy future ...
[16:12:45.974] Packages needed by the future expression (n = 0): <none>
[16:12:45.974] Packages needed by future strategies (n = 0): <none>
[16:12:45.975] {
[16:12:45.975]     {
[16:12:45.975]         {
[16:12:45.975]             ...future.startTime <- base::Sys.time()
[16:12:45.975]             {
[16:12:45.975]                 {
[16:12:45.975]                   {
[16:12:45.975]                     base::local({
[16:12:45.975]                       has_future <- base::requireNamespace("future", 
[16:12:45.975]                         quietly = TRUE)
[16:12:45.975]                       if (has_future) {
[16:12:45.975]                         ns <- base::getNamespace("future")
[16:12:45.975]                         version <- ns[[".package"]][["version"]]
[16:12:45.975]                         if (is.null(version)) 
[16:12:45.975]                           version <- utils::packageVersion("future")
[16:12:45.975]                       }
[16:12:45.975]                       else {
[16:12:45.975]                         version <- NULL
[16:12:45.975]                       }
[16:12:45.975]                       if (!has_future || version < "1.8.0") {
[16:12:45.975]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.975]                           "", base::R.version$version.string), 
[16:12:45.975]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.975]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.975]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.975]                             "release", "version")], collapse = " "), 
[16:12:45.975]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.975]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.975]                           info)
[16:12:45.975]                         info <- base::paste(info, collapse = "; ")
[16:12:45.975]                         if (!has_future) {
[16:12:45.975]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.975]                             info)
[16:12:45.975]                         }
[16:12:45.975]                         else {
[16:12:45.975]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.975]                             info, version)
[16:12:45.975]                         }
[16:12:45.975]                         base::stop(msg)
[16:12:45.975]                       }
[16:12:45.975]                     })
[16:12:45.975]                   }
[16:12:45.975]                   options(future.plan = NULL)
[16:12:45.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.975]                 }
[16:12:45.975]                 ...future.workdir <- getwd()
[16:12:45.975]             }
[16:12:45.975]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.975]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.975]         }
[16:12:45.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.975]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.975]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.975]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.975]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.975]             base::names(...future.oldOptions))
[16:12:45.975]     }
[16:12:45.975]     if (FALSE) {
[16:12:45.975]     }
[16:12:45.975]     else {
[16:12:45.975]         if (TRUE) {
[16:12:45.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.975]                 open = "w")
[16:12:45.975]         }
[16:12:45.975]         else {
[16:12:45.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.975]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.975]         }
[16:12:45.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.975]             base::sink(type = "output", split = FALSE)
[16:12:45.975]             base::close(...future.stdout)
[16:12:45.975]         }, add = TRUE)
[16:12:45.975]     }
[16:12:45.975]     ...future.frame <- base::sys.nframe()
[16:12:45.975]     ...future.conditions <- base::list()
[16:12:45.975]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.975]     if (FALSE) {
[16:12:45.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.975]     }
[16:12:45.975]     ...future.result <- base::tryCatch({
[16:12:45.975]         base::withCallingHandlers({
[16:12:45.975]             ...future.value <- base::withVisible(base::local({
[16:12:45.975]                 x["a"] <- list(1)
[16:12:45.975]                 x
[16:12:45.975]             }))
[16:12:45.975]             future::FutureResult(value = ...future.value$value, 
[16:12:45.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.975]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.975]                     ...future.globalenv.names))
[16:12:45.975]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.975]         }, condition = base::local({
[16:12:45.975]             c <- base::c
[16:12:45.975]             inherits <- base::inherits
[16:12:45.975]             invokeRestart <- base::invokeRestart
[16:12:45.975]             length <- base::length
[16:12:45.975]             list <- base::list
[16:12:45.975]             seq.int <- base::seq.int
[16:12:45.975]             signalCondition <- base::signalCondition
[16:12:45.975]             sys.calls <- base::sys.calls
[16:12:45.975]             `[[` <- base::`[[`
[16:12:45.975]             `+` <- base::`+`
[16:12:45.975]             `<<-` <- base::`<<-`
[16:12:45.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.975]                   3L)]
[16:12:45.975]             }
[16:12:45.975]             function(cond) {
[16:12:45.975]                 is_error <- inherits(cond, "error")
[16:12:45.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.975]                   NULL)
[16:12:45.975]                 if (is_error) {
[16:12:45.975]                   sessionInformation <- function() {
[16:12:45.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.975]                       search = base::search(), system = base::Sys.info())
[16:12:45.975]                   }
[16:12:45.975]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.975]                     cond$call), session = sessionInformation(), 
[16:12:45.975]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.975]                   signalCondition(cond)
[16:12:45.975]                 }
[16:12:45.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.975]                 "immediateCondition"))) {
[16:12:45.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.975]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.975]                   if (TRUE && !signal) {
[16:12:45.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.975]                     {
[16:12:45.975]                       inherits <- base::inherits
[16:12:45.975]                       invokeRestart <- base::invokeRestart
[16:12:45.975]                       is.null <- base::is.null
[16:12:45.975]                       muffled <- FALSE
[16:12:45.975]                       if (inherits(cond, "message")) {
[16:12:45.975]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.975]                         if (muffled) 
[16:12:45.975]                           invokeRestart("muffleMessage")
[16:12:45.975]                       }
[16:12:45.975]                       else if (inherits(cond, "warning")) {
[16:12:45.975]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.975]                         if (muffled) 
[16:12:45.975]                           invokeRestart("muffleWarning")
[16:12:45.975]                       }
[16:12:45.975]                       else if (inherits(cond, "condition")) {
[16:12:45.975]                         if (!is.null(pattern)) {
[16:12:45.975]                           computeRestarts <- base::computeRestarts
[16:12:45.975]                           grepl <- base::grepl
[16:12:45.975]                           restarts <- computeRestarts(cond)
[16:12:45.975]                           for (restart in restarts) {
[16:12:45.975]                             name <- restart$name
[16:12:45.975]                             if (is.null(name)) 
[16:12:45.975]                               next
[16:12:45.975]                             if (!grepl(pattern, name)) 
[16:12:45.975]                               next
[16:12:45.975]                             invokeRestart(restart)
[16:12:45.975]                             muffled <- TRUE
[16:12:45.975]                             break
[16:12:45.975]                           }
[16:12:45.975]                         }
[16:12:45.975]                       }
[16:12:45.975]                       invisible(muffled)
[16:12:45.975]                     }
[16:12:45.975]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.975]                   }
[16:12:45.975]                 }
[16:12:45.975]                 else {
[16:12:45.975]                   if (TRUE) {
[16:12:45.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.975]                     {
[16:12:45.975]                       inherits <- base::inherits
[16:12:45.975]                       invokeRestart <- base::invokeRestart
[16:12:45.975]                       is.null <- base::is.null
[16:12:45.975]                       muffled <- FALSE
[16:12:45.975]                       if (inherits(cond, "message")) {
[16:12:45.975]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.975]                         if (muffled) 
[16:12:45.975]                           invokeRestart("muffleMessage")
[16:12:45.975]                       }
[16:12:45.975]                       else if (inherits(cond, "warning")) {
[16:12:45.975]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.975]                         if (muffled) 
[16:12:45.975]                           invokeRestart("muffleWarning")
[16:12:45.975]                       }
[16:12:45.975]                       else if (inherits(cond, "condition")) {
[16:12:45.975]                         if (!is.null(pattern)) {
[16:12:45.975]                           computeRestarts <- base::computeRestarts
[16:12:45.975]                           grepl <- base::grepl
[16:12:45.975]                           restarts <- computeRestarts(cond)
[16:12:45.975]                           for (restart in restarts) {
[16:12:45.975]                             name <- restart$name
[16:12:45.975]                             if (is.null(name)) 
[16:12:45.975]                               next
[16:12:45.975]                             if (!grepl(pattern, name)) 
[16:12:45.975]                               next
[16:12:45.975]                             invokeRestart(restart)
[16:12:45.975]                             muffled <- TRUE
[16:12:45.975]                             break
[16:12:45.975]                           }
[16:12:45.975]                         }
[16:12:45.975]                       }
[16:12:45.975]                       invisible(muffled)
[16:12:45.975]                     }
[16:12:45.975]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.975]                   }
[16:12:45.975]                 }
[16:12:45.975]             }
[16:12:45.975]         }))
[16:12:45.975]     }, error = function(ex) {
[16:12:45.975]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.975]                 ...future.rng), started = ...future.startTime, 
[16:12:45.975]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.975]             version = "1.8"), class = "FutureResult")
[16:12:45.975]     }, finally = {
[16:12:45.975]         if (!identical(...future.workdir, getwd())) 
[16:12:45.975]             setwd(...future.workdir)
[16:12:45.975]         {
[16:12:45.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.975]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.975]             }
[16:12:45.975]             base::options(...future.oldOptions)
[16:12:45.975]             if (.Platform$OS.type == "windows") {
[16:12:45.975]                 old_names <- names(...future.oldEnvVars)
[16:12:45.975]                 envs <- base::Sys.getenv()
[16:12:45.975]                 names <- names(envs)
[16:12:45.975]                 common <- intersect(names, old_names)
[16:12:45.975]                 added <- setdiff(names, old_names)
[16:12:45.975]                 removed <- setdiff(old_names, names)
[16:12:45.975]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.975]                   envs[common]]
[16:12:45.975]                 NAMES <- toupper(changed)
[16:12:45.975]                 args <- list()
[16:12:45.975]                 for (kk in seq_along(NAMES)) {
[16:12:45.975]                   name <- changed[[kk]]
[16:12:45.975]                   NAME <- NAMES[[kk]]
[16:12:45.975]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.975]                     next
[16:12:45.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.975]                 }
[16:12:45.975]                 NAMES <- toupper(added)
[16:12:45.975]                 for (kk in seq_along(NAMES)) {
[16:12:45.975]                   name <- added[[kk]]
[16:12:45.975]                   NAME <- NAMES[[kk]]
[16:12:45.975]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.975]                     next
[16:12:45.975]                   args[[name]] <- ""
[16:12:45.975]                 }
[16:12:45.975]                 NAMES <- toupper(removed)
[16:12:45.975]                 for (kk in seq_along(NAMES)) {
[16:12:45.975]                   name <- removed[[kk]]
[16:12:45.975]                   NAME <- NAMES[[kk]]
[16:12:45.975]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.975]                     next
[16:12:45.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.975]                 }
[16:12:45.975]                 if (length(args) > 0) 
[16:12:45.975]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.975]             }
[16:12:45.975]             else {
[16:12:45.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.975]             }
[16:12:45.975]             {
[16:12:45.975]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.975]                   0L) {
[16:12:45.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.975]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.975]                   base::options(opts)
[16:12:45.975]                 }
[16:12:45.975]                 {
[16:12:45.975]                   {
[16:12:45.975]                     NULL
[16:12:45.975]                     RNGkind("Mersenne-Twister")
[16:12:45.975]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.975]                       inherits = FALSE)
[16:12:45.975]                   }
[16:12:45.975]                   options(future.plan = NULL)
[16:12:45.975]                   if (is.na(NA_character_)) 
[16:12:45.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.975]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.975]                   {
[16:12:45.975]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.975]                     if (!future$lazy) 
[16:12:45.975]                       future <- run(future)
[16:12:45.975]                     invisible(future)
[16:12:45.975]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.975]                 }
[16:12:45.975]             }
[16:12:45.975]         }
[16:12:45.975]     })
[16:12:45.975]     if (TRUE) {
[16:12:45.975]         base::sink(type = "output", split = FALSE)
[16:12:45.975]         if (TRUE) {
[16:12:45.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.975]         }
[16:12:45.975]         else {
[16:12:45.975]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.975]         }
[16:12:45.975]         base::close(...future.stdout)
[16:12:45.975]         ...future.stdout <- NULL
[16:12:45.975]     }
[16:12:45.975]     ...future.result$conditions <- ...future.conditions
[16:12:45.975]     ...future.result$finished <- base::Sys.time()
[16:12:45.975]     ...future.result
[16:12:45.975] }
[16:12:45.976] assign_globals() ...
[16:12:45.976] List of 1
[16:12:45.976]  $ x: list()
[16:12:45.976]  - attr(*, "where")=List of 1
[16:12:45.976]   ..$ x:<environment: R_EmptyEnv> 
[16:12:45.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:45.976]  - attr(*, "resolved")= logi TRUE
[16:12:45.976]  - attr(*, "total_size")= num 0
[16:12:45.976]  - attr(*, "already-done")= logi TRUE
[16:12:45.980] - copied ‘x’ to environment
[16:12:45.980] assign_globals() ... done
[16:12:45.981] plan(): Setting new future strategy stack:
[16:12:45.981] List of future strategies:
[16:12:45.981] 1. sequential:
[16:12:45.981]    - args: function (..., envir = parent.frame())
[16:12:45.981]    - tweaked: FALSE
[16:12:45.981]    - call: NULL
[16:12:45.981] plan(): nbrOfWorkers() = 1
[16:12:45.982] plan(): Setting new future strategy stack:
[16:12:45.982] List of future strategies:
[16:12:45.982] 1. sequential:
[16:12:45.982]    - args: function (..., envir = parent.frame())
[16:12:45.982]    - tweaked: FALSE
[16:12:45.982]    - call: plan(strategy)
[16:12:45.982] plan(): nbrOfWorkers() = 1
[16:12:45.982] SequentialFuture started (and completed)
[16:12:45.983] - Launch lazy future ... done
[16:12:45.983] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:45.983] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:45.983] Searching for globals...
[16:12:45.985] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:12:45.985] Searching for globals ... DONE
[16:12:45.986] Resolving globals: TRUE
[16:12:45.986] Resolving any globals that are futures ...
[16:12:45.986] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:12:45.986] Resolving any globals that are futures ... DONE
[16:12:45.986] Resolving futures part of globals (recursively) ...
[16:12:45.986] resolve() on list ...
[16:12:45.987]  recursive: 99
[16:12:45.987]  length: 2
[16:12:45.987]  elements: ‘x’, ‘name’
[16:12:45.987]  length: 1 (resolved future 1)
[16:12:45.987]  length: 0 (resolved future 2)
[16:12:45.987] resolve() on list ... DONE
[16:12:45.987] - globals: [2] ‘x’, ‘name’
[16:12:45.987] Resolving futures part of globals (recursively) ... DONE
[16:12:45.987] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:45.988] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[16:12:45.988] - globals: [2] ‘x’, ‘name’
[16:12:45.988] 
[16:12:45.988] getGlobalsAndPackages() ... DONE
[16:12:45.988] run() for ‘Future’ ...
[16:12:45.988] - state: ‘created’
[16:12:45.989] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:45.989] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:45.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:45.989]   - Field: ‘label’
[16:12:45.989]   - Field: ‘local’
[16:12:45.989]   - Field: ‘owner’
[16:12:45.989]   - Field: ‘envir’
[16:12:45.989]   - Field: ‘packages’
[16:12:45.990]   - Field: ‘gc’
[16:12:45.990]   - Field: ‘conditions’
[16:12:45.990]   - Field: ‘expr’
[16:12:45.990]   - Field: ‘uuid’
[16:12:45.990]   - Field: ‘seed’
[16:12:45.990]   - Field: ‘version’
[16:12:45.990]   - Field: ‘result’
[16:12:45.990]   - Field: ‘asynchronous’
[16:12:45.990]   - Field: ‘calls’
[16:12:45.990]   - Field: ‘globals’
[16:12:45.990]   - Field: ‘stdout’
[16:12:45.991]   - Field: ‘earlySignal’
[16:12:45.991]   - Field: ‘lazy’
[16:12:45.991]   - Field: ‘state’
[16:12:45.991] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:45.991] - Launch lazy future ...
[16:12:45.991] Packages needed by the future expression (n = 0): <none>
[16:12:45.991] Packages needed by future strategies (n = 0): <none>
[16:12:45.992] {
[16:12:45.992]     {
[16:12:45.992]         {
[16:12:45.992]             ...future.startTime <- base::Sys.time()
[16:12:45.992]             {
[16:12:45.992]                 {
[16:12:45.992]                   {
[16:12:45.992]                     base::local({
[16:12:45.992]                       has_future <- base::requireNamespace("future", 
[16:12:45.992]                         quietly = TRUE)
[16:12:45.992]                       if (has_future) {
[16:12:45.992]                         ns <- base::getNamespace("future")
[16:12:45.992]                         version <- ns[[".package"]][["version"]]
[16:12:45.992]                         if (is.null(version)) 
[16:12:45.992]                           version <- utils::packageVersion("future")
[16:12:45.992]                       }
[16:12:45.992]                       else {
[16:12:45.992]                         version <- NULL
[16:12:45.992]                       }
[16:12:45.992]                       if (!has_future || version < "1.8.0") {
[16:12:45.992]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:45.992]                           "", base::R.version$version.string), 
[16:12:45.992]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:45.992]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:45.992]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:45.992]                             "release", "version")], collapse = " "), 
[16:12:45.992]                           hostname = base::Sys.info()[["nodename"]])
[16:12:45.992]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:45.992]                           info)
[16:12:45.992]                         info <- base::paste(info, collapse = "; ")
[16:12:45.992]                         if (!has_future) {
[16:12:45.992]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:45.992]                             info)
[16:12:45.992]                         }
[16:12:45.992]                         else {
[16:12:45.992]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:45.992]                             info, version)
[16:12:45.992]                         }
[16:12:45.992]                         base::stop(msg)
[16:12:45.992]                       }
[16:12:45.992]                     })
[16:12:45.992]                   }
[16:12:45.992]                   options(future.plan = NULL)
[16:12:45.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:45.992]                 }
[16:12:45.992]                 ...future.workdir <- getwd()
[16:12:45.992]             }
[16:12:45.992]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:45.992]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:45.992]         }
[16:12:45.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:45.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:45.992]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:45.992]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:45.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:45.992]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:45.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:45.992]             base::names(...future.oldOptions))
[16:12:45.992]     }
[16:12:45.992]     if (FALSE) {
[16:12:45.992]     }
[16:12:45.992]     else {
[16:12:45.992]         if (TRUE) {
[16:12:45.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:45.992]                 open = "w")
[16:12:45.992]         }
[16:12:45.992]         else {
[16:12:45.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:45.992]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:45.992]         }
[16:12:45.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:45.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:45.992]             base::sink(type = "output", split = FALSE)
[16:12:45.992]             base::close(...future.stdout)
[16:12:45.992]         }, add = TRUE)
[16:12:45.992]     }
[16:12:45.992]     ...future.frame <- base::sys.nframe()
[16:12:45.992]     ...future.conditions <- base::list()
[16:12:45.992]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:45.992]     if (FALSE) {
[16:12:45.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:45.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:45.992]     }
[16:12:45.992]     ...future.result <- base::tryCatch({
[16:12:45.992]         base::withCallingHandlers({
[16:12:45.992]             ...future.value <- base::withVisible(base::local({
[16:12:45.992]                 x[name] <- list(1)
[16:12:45.992]                 x
[16:12:45.992]             }))
[16:12:45.992]             future::FutureResult(value = ...future.value$value, 
[16:12:45.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.992]                   ...future.rng), globalenv = if (FALSE) 
[16:12:45.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:45.992]                     ...future.globalenv.names))
[16:12:45.992]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:45.992]         }, condition = base::local({
[16:12:45.992]             c <- base::c
[16:12:45.992]             inherits <- base::inherits
[16:12:45.992]             invokeRestart <- base::invokeRestart
[16:12:45.992]             length <- base::length
[16:12:45.992]             list <- base::list
[16:12:45.992]             seq.int <- base::seq.int
[16:12:45.992]             signalCondition <- base::signalCondition
[16:12:45.992]             sys.calls <- base::sys.calls
[16:12:45.992]             `[[` <- base::`[[`
[16:12:45.992]             `+` <- base::`+`
[16:12:45.992]             `<<-` <- base::`<<-`
[16:12:45.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:45.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:45.992]                   3L)]
[16:12:45.992]             }
[16:12:45.992]             function(cond) {
[16:12:45.992]                 is_error <- inherits(cond, "error")
[16:12:45.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:45.992]                   NULL)
[16:12:45.992]                 if (is_error) {
[16:12:45.992]                   sessionInformation <- function() {
[16:12:45.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:45.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:45.992]                       search = base::search(), system = base::Sys.info())
[16:12:45.992]                   }
[16:12:45.992]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:45.992]                     cond$call), session = sessionInformation(), 
[16:12:45.992]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:45.992]                   signalCondition(cond)
[16:12:45.992]                 }
[16:12:45.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:45.992]                 "immediateCondition"))) {
[16:12:45.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:45.992]                   ...future.conditions[[length(...future.conditions) + 
[16:12:45.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:45.992]                   if (TRUE && !signal) {
[16:12:45.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.992]                     {
[16:12:45.992]                       inherits <- base::inherits
[16:12:45.992]                       invokeRestart <- base::invokeRestart
[16:12:45.992]                       is.null <- base::is.null
[16:12:45.992]                       muffled <- FALSE
[16:12:45.992]                       if (inherits(cond, "message")) {
[16:12:45.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.992]                         if (muffled) 
[16:12:45.992]                           invokeRestart("muffleMessage")
[16:12:45.992]                       }
[16:12:45.992]                       else if (inherits(cond, "warning")) {
[16:12:45.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.992]                         if (muffled) 
[16:12:45.992]                           invokeRestart("muffleWarning")
[16:12:45.992]                       }
[16:12:45.992]                       else if (inherits(cond, "condition")) {
[16:12:45.992]                         if (!is.null(pattern)) {
[16:12:45.992]                           computeRestarts <- base::computeRestarts
[16:12:45.992]                           grepl <- base::grepl
[16:12:45.992]                           restarts <- computeRestarts(cond)
[16:12:45.992]                           for (restart in restarts) {
[16:12:45.992]                             name <- restart$name
[16:12:45.992]                             if (is.null(name)) 
[16:12:45.992]                               next
[16:12:45.992]                             if (!grepl(pattern, name)) 
[16:12:45.992]                               next
[16:12:45.992]                             invokeRestart(restart)
[16:12:45.992]                             muffled <- TRUE
[16:12:45.992]                             break
[16:12:45.992]                           }
[16:12:45.992]                         }
[16:12:45.992]                       }
[16:12:45.992]                       invisible(muffled)
[16:12:45.992]                     }
[16:12:45.992]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.992]                   }
[16:12:45.992]                 }
[16:12:45.992]                 else {
[16:12:45.992]                   if (TRUE) {
[16:12:45.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:45.992]                     {
[16:12:45.992]                       inherits <- base::inherits
[16:12:45.992]                       invokeRestart <- base::invokeRestart
[16:12:45.992]                       is.null <- base::is.null
[16:12:45.992]                       muffled <- FALSE
[16:12:45.992]                       if (inherits(cond, "message")) {
[16:12:45.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:45.992]                         if (muffled) 
[16:12:45.992]                           invokeRestart("muffleMessage")
[16:12:45.992]                       }
[16:12:45.992]                       else if (inherits(cond, "warning")) {
[16:12:45.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:45.992]                         if (muffled) 
[16:12:45.992]                           invokeRestart("muffleWarning")
[16:12:45.992]                       }
[16:12:45.992]                       else if (inherits(cond, "condition")) {
[16:12:45.992]                         if (!is.null(pattern)) {
[16:12:45.992]                           computeRestarts <- base::computeRestarts
[16:12:45.992]                           grepl <- base::grepl
[16:12:45.992]                           restarts <- computeRestarts(cond)
[16:12:45.992]                           for (restart in restarts) {
[16:12:45.992]                             name <- restart$name
[16:12:45.992]                             if (is.null(name)) 
[16:12:45.992]                               next
[16:12:45.992]                             if (!grepl(pattern, name)) 
[16:12:45.992]                               next
[16:12:45.992]                             invokeRestart(restart)
[16:12:45.992]                             muffled <- TRUE
[16:12:45.992]                             break
[16:12:45.992]                           }
[16:12:45.992]                         }
[16:12:45.992]                       }
[16:12:45.992]                       invisible(muffled)
[16:12:45.992]                     }
[16:12:45.992]                     muffleCondition(cond, pattern = "^muffle")
[16:12:45.992]                   }
[16:12:45.992]                 }
[16:12:45.992]             }
[16:12:45.992]         }))
[16:12:45.992]     }, error = function(ex) {
[16:12:45.992]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:45.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:45.992]                 ...future.rng), started = ...future.startTime, 
[16:12:45.992]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:45.992]             version = "1.8"), class = "FutureResult")
[16:12:45.992]     }, finally = {
[16:12:45.992]         if (!identical(...future.workdir, getwd())) 
[16:12:45.992]             setwd(...future.workdir)
[16:12:45.992]         {
[16:12:45.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:45.992]                 ...future.oldOptions$nwarnings <- NULL
[16:12:45.992]             }
[16:12:45.992]             base::options(...future.oldOptions)
[16:12:45.992]             if (.Platform$OS.type == "windows") {
[16:12:45.992]                 old_names <- names(...future.oldEnvVars)
[16:12:45.992]                 envs <- base::Sys.getenv()
[16:12:45.992]                 names <- names(envs)
[16:12:45.992]                 common <- intersect(names, old_names)
[16:12:45.992]                 added <- setdiff(names, old_names)
[16:12:45.992]                 removed <- setdiff(old_names, names)
[16:12:45.992]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:45.992]                   envs[common]]
[16:12:45.992]                 NAMES <- toupper(changed)
[16:12:45.992]                 args <- list()
[16:12:45.992]                 for (kk in seq_along(NAMES)) {
[16:12:45.992]                   name <- changed[[kk]]
[16:12:45.992]                   NAME <- NAMES[[kk]]
[16:12:45.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.992]                     next
[16:12:45.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.992]                 }
[16:12:45.992]                 NAMES <- toupper(added)
[16:12:45.992]                 for (kk in seq_along(NAMES)) {
[16:12:45.992]                   name <- added[[kk]]
[16:12:45.992]                   NAME <- NAMES[[kk]]
[16:12:45.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.992]                     next
[16:12:45.992]                   args[[name]] <- ""
[16:12:45.992]                 }
[16:12:45.992]                 NAMES <- toupper(removed)
[16:12:45.992]                 for (kk in seq_along(NAMES)) {
[16:12:45.992]                   name <- removed[[kk]]
[16:12:45.992]                   NAME <- NAMES[[kk]]
[16:12:45.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:45.992]                     next
[16:12:45.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:45.992]                 }
[16:12:45.992]                 if (length(args) > 0) 
[16:12:45.992]                   base::do.call(base::Sys.setenv, args = args)
[16:12:45.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:45.992]             }
[16:12:45.992]             else {
[16:12:45.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:45.992]             }
[16:12:45.992]             {
[16:12:45.992]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:45.992]                   0L) {
[16:12:45.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:45.992]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:45.992]                   base::options(opts)
[16:12:45.992]                 }
[16:12:45.992]                 {
[16:12:45.992]                   {
[16:12:45.992]                     NULL
[16:12:45.992]                     RNGkind("Mersenne-Twister")
[16:12:45.992]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:45.992]                       inherits = FALSE)
[16:12:45.992]                   }
[16:12:45.992]                   options(future.plan = NULL)
[16:12:45.992]                   if (is.na(NA_character_)) 
[16:12:45.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:45.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:45.992]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:45.992]                   {
[16:12:45.992]                     future <- SequentialFuture(..., envir = envir)
[16:12:45.992]                     if (!future$lazy) 
[16:12:45.992]                       future <- run(future)
[16:12:45.992]                     invisible(future)
[16:12:45.992]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:45.992]                 }
[16:12:45.992]             }
[16:12:45.992]         }
[16:12:45.992]     })
[16:12:45.992]     if (TRUE) {
[16:12:45.992]         base::sink(type = "output", split = FALSE)
[16:12:45.992]         if (TRUE) {
[16:12:45.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:45.992]         }
[16:12:45.992]         else {
[16:12:45.992]             ...future.result["stdout"] <- base::list(NULL)
[16:12:45.992]         }
[16:12:45.992]         base::close(...future.stdout)
[16:12:45.992]         ...future.stdout <- NULL
[16:12:45.992]     }
[16:12:45.992]     ...future.result$conditions <- ...future.conditions
[16:12:45.992]     ...future.result$finished <- base::Sys.time()
[16:12:45.992]     ...future.result
[16:12:45.992] }
[16:12:45.993] assign_globals() ...
[16:12:45.993] List of 2
[16:12:45.993]  $ x   : list()
[16:12:45.993]  $ name: chr "a"
[16:12:45.993]  - attr(*, "where")=List of 2
[16:12:45.993]   ..$ x   :<environment: R_EmptyEnv> 
[16:12:45.993]   ..$ name:<environment: R_EmptyEnv> 
[16:12:45.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:45.993]  - attr(*, "resolved")= logi TRUE
[16:12:45.993]  - attr(*, "total_size")= num 112
[16:12:45.993]  - attr(*, "already-done")= logi TRUE
[16:12:45.996] - copied ‘x’ to environment
[16:12:45.996] - copied ‘name’ to environment
[16:12:45.996] assign_globals() ... done
[16:12:45.997] plan(): Setting new future strategy stack:
[16:12:45.997] List of future strategies:
[16:12:45.997] 1. sequential:
[16:12:45.997]    - args: function (..., envir = parent.frame())
[16:12:45.997]    - tweaked: FALSE
[16:12:45.997]    - call: NULL
[16:12:45.997] plan(): nbrOfWorkers() = 1
[16:12:45.998] plan(): Setting new future strategy stack:
[16:12:45.998] List of future strategies:
[16:12:45.998] 1. sequential:
[16:12:45.998]    - args: function (..., envir = parent.frame())
[16:12:45.998]    - tweaked: FALSE
[16:12:45.998]    - call: plan(strategy)
[16:12:45.998] plan(): nbrOfWorkers() = 1
[16:12:45.998] SequentialFuture started (and completed)
[16:12:45.998] - Launch lazy future ... done
[16:12:45.998] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[16:12:46.010] plan(): Setting new future strategy stack:
[16:12:46.010] List of future strategies:
[16:12:46.010] 1. multicore:
[16:12:46.010]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.010]    - tweaked: FALSE
[16:12:46.010]    - call: plan(strategy)
[16:12:46.014] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.014] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.014] Searching for globals...
[16:12:46.016] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:46.016] Searching for globals ... DONE
[16:12:46.017] Resolving globals: TRUE
[16:12:46.017] Resolving any globals that are futures ...
[16:12:46.017] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:46.017] Resolving any globals that are futures ... DONE
[16:12:46.017] Resolving futures part of globals (recursively) ...
[16:12:46.017] resolve() on list ...
[16:12:46.018]  recursive: 99
[16:12:46.018]  length: 1
[16:12:46.018]  elements: ‘x’
[16:12:46.018]  length: 0 (resolved future 1)
[16:12:46.018] resolve() on list ... DONE
[16:12:46.018] - globals: [1] ‘x’
[16:12:46.018] Resolving futures part of globals (recursively) ... DONE
[16:12:46.018] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:46.019] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:46.019] - globals: [1] ‘x’
[16:12:46.019] 
[16:12:46.019] getGlobalsAndPackages() ... DONE
[16:12:46.019] run() for ‘Future’ ...
[16:12:46.019] - state: ‘created’
[16:12:46.019] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.023] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.023] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.023]   - Field: ‘label’
[16:12:46.023]   - Field: ‘local’
[16:12:46.023]   - Field: ‘owner’
[16:12:46.023]   - Field: ‘envir’
[16:12:46.024]   - Field: ‘workers’
[16:12:46.024]   - Field: ‘packages’
[16:12:46.024]   - Field: ‘gc’
[16:12:46.024]   - Field: ‘job’
[16:12:46.024]   - Field: ‘conditions’
[16:12:46.024]   - Field: ‘expr’
[16:12:46.024]   - Field: ‘uuid’
[16:12:46.024]   - Field: ‘seed’
[16:12:46.024]   - Field: ‘version’
[16:12:46.024]   - Field: ‘result’
[16:12:46.025]   - Field: ‘asynchronous’
[16:12:46.025]   - Field: ‘calls’
[16:12:46.025]   - Field: ‘globals’
[16:12:46.025]   - Field: ‘stdout’
[16:12:46.025]   - Field: ‘earlySignal’
[16:12:46.025]   - Field: ‘lazy’
[16:12:46.025]   - Field: ‘state’
[16:12:46.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.025] - Launch lazy future ...
[16:12:46.026] Packages needed by the future expression (n = 0): <none>
[16:12:46.026] Packages needed by future strategies (n = 0): <none>
[16:12:46.027] {
[16:12:46.027]     {
[16:12:46.027]         {
[16:12:46.027]             ...future.startTime <- base::Sys.time()
[16:12:46.027]             {
[16:12:46.027]                 {
[16:12:46.027]                   {
[16:12:46.027]                     {
[16:12:46.027]                       base::local({
[16:12:46.027]                         has_future <- base::requireNamespace("future", 
[16:12:46.027]                           quietly = TRUE)
[16:12:46.027]                         if (has_future) {
[16:12:46.027]                           ns <- base::getNamespace("future")
[16:12:46.027]                           version <- ns[[".package"]][["version"]]
[16:12:46.027]                           if (is.null(version)) 
[16:12:46.027]                             version <- utils::packageVersion("future")
[16:12:46.027]                         }
[16:12:46.027]                         else {
[16:12:46.027]                           version <- NULL
[16:12:46.027]                         }
[16:12:46.027]                         if (!has_future || version < "1.8.0") {
[16:12:46.027]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.027]                             "", base::R.version$version.string), 
[16:12:46.027]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.027]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.027]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.027]                               "release", "version")], collapse = " "), 
[16:12:46.027]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.027]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.027]                             info)
[16:12:46.027]                           info <- base::paste(info, collapse = "; ")
[16:12:46.027]                           if (!has_future) {
[16:12:46.027]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.027]                               info)
[16:12:46.027]                           }
[16:12:46.027]                           else {
[16:12:46.027]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.027]                               info, version)
[16:12:46.027]                           }
[16:12:46.027]                           base::stop(msg)
[16:12:46.027]                         }
[16:12:46.027]                       })
[16:12:46.027]                     }
[16:12:46.027]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.027]                     base::options(mc.cores = 1L)
[16:12:46.027]                   }
[16:12:46.027]                   options(future.plan = NULL)
[16:12:46.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.027]                 }
[16:12:46.027]                 ...future.workdir <- getwd()
[16:12:46.027]             }
[16:12:46.027]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.027]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.027]         }
[16:12:46.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.027]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.027]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.027]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.027]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.027]             base::names(...future.oldOptions))
[16:12:46.027]     }
[16:12:46.027]     if (FALSE) {
[16:12:46.027]     }
[16:12:46.027]     else {
[16:12:46.027]         if (TRUE) {
[16:12:46.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.027]                 open = "w")
[16:12:46.027]         }
[16:12:46.027]         else {
[16:12:46.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.027]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.027]         }
[16:12:46.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.027]             base::sink(type = "output", split = FALSE)
[16:12:46.027]             base::close(...future.stdout)
[16:12:46.027]         }, add = TRUE)
[16:12:46.027]     }
[16:12:46.027]     ...future.frame <- base::sys.nframe()
[16:12:46.027]     ...future.conditions <- base::list()
[16:12:46.027]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.027]     if (FALSE) {
[16:12:46.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.027]     }
[16:12:46.027]     ...future.result <- base::tryCatch({
[16:12:46.027]         base::withCallingHandlers({
[16:12:46.027]             ...future.value <- base::withVisible(base::local({
[16:12:46.027]                 withCallingHandlers({
[16:12:46.027]                   {
[16:12:46.027]                     x$a <- 1
[16:12:46.027]                     x
[16:12:46.027]                   }
[16:12:46.027]                 }, immediateCondition = function(cond) {
[16:12:46.027]                   save_rds <- function (object, pathname, ...) 
[16:12:46.027]                   {
[16:12:46.027]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.027]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.027]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.027]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.027]                         fi_tmp[["mtime"]])
[16:12:46.027]                     }
[16:12:46.027]                     tryCatch({
[16:12:46.027]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.027]                     }, error = function(ex) {
[16:12:46.027]                       msg <- conditionMessage(ex)
[16:12:46.027]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.027]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.027]                         fi_tmp[["mtime"]], msg)
[16:12:46.027]                       ex$message <- msg
[16:12:46.027]                       stop(ex)
[16:12:46.027]                     })
[16:12:46.027]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.027]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.027]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.027]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.027]                       fi <- file.info(pathname)
[16:12:46.027]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.027]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.027]                         fi[["size"]], fi[["mtime"]])
[16:12:46.027]                       stop(msg)
[16:12:46.027]                     }
[16:12:46.027]                     invisible(pathname)
[16:12:46.027]                   }
[16:12:46.027]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.027]                     rootPath = tempdir()) 
[16:12:46.027]                   {
[16:12:46.027]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.027]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.027]                       tmpdir = path, fileext = ".rds")
[16:12:46.027]                     save_rds(obj, file)
[16:12:46.027]                   }
[16:12:46.027]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.027]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.027]                   {
[16:12:46.027]                     inherits <- base::inherits
[16:12:46.027]                     invokeRestart <- base::invokeRestart
[16:12:46.027]                     is.null <- base::is.null
[16:12:46.027]                     muffled <- FALSE
[16:12:46.027]                     if (inherits(cond, "message")) {
[16:12:46.027]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.027]                       if (muffled) 
[16:12:46.027]                         invokeRestart("muffleMessage")
[16:12:46.027]                     }
[16:12:46.027]                     else if (inherits(cond, "warning")) {
[16:12:46.027]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.027]                       if (muffled) 
[16:12:46.027]                         invokeRestart("muffleWarning")
[16:12:46.027]                     }
[16:12:46.027]                     else if (inherits(cond, "condition")) {
[16:12:46.027]                       if (!is.null(pattern)) {
[16:12:46.027]                         computeRestarts <- base::computeRestarts
[16:12:46.027]                         grepl <- base::grepl
[16:12:46.027]                         restarts <- computeRestarts(cond)
[16:12:46.027]                         for (restart in restarts) {
[16:12:46.027]                           name <- restart$name
[16:12:46.027]                           if (is.null(name)) 
[16:12:46.027]                             next
[16:12:46.027]                           if (!grepl(pattern, name)) 
[16:12:46.027]                             next
[16:12:46.027]                           invokeRestart(restart)
[16:12:46.027]                           muffled <- TRUE
[16:12:46.027]                           break
[16:12:46.027]                         }
[16:12:46.027]                       }
[16:12:46.027]                     }
[16:12:46.027]                     invisible(muffled)
[16:12:46.027]                   }
[16:12:46.027]                   muffleCondition(cond)
[16:12:46.027]                 })
[16:12:46.027]             }))
[16:12:46.027]             future::FutureResult(value = ...future.value$value, 
[16:12:46.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.027]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.027]                     ...future.globalenv.names))
[16:12:46.027]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.027]         }, condition = base::local({
[16:12:46.027]             c <- base::c
[16:12:46.027]             inherits <- base::inherits
[16:12:46.027]             invokeRestart <- base::invokeRestart
[16:12:46.027]             length <- base::length
[16:12:46.027]             list <- base::list
[16:12:46.027]             seq.int <- base::seq.int
[16:12:46.027]             signalCondition <- base::signalCondition
[16:12:46.027]             sys.calls <- base::sys.calls
[16:12:46.027]             `[[` <- base::`[[`
[16:12:46.027]             `+` <- base::`+`
[16:12:46.027]             `<<-` <- base::`<<-`
[16:12:46.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.027]                   3L)]
[16:12:46.027]             }
[16:12:46.027]             function(cond) {
[16:12:46.027]                 is_error <- inherits(cond, "error")
[16:12:46.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.027]                   NULL)
[16:12:46.027]                 if (is_error) {
[16:12:46.027]                   sessionInformation <- function() {
[16:12:46.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.027]                       search = base::search(), system = base::Sys.info())
[16:12:46.027]                   }
[16:12:46.027]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.027]                     cond$call), session = sessionInformation(), 
[16:12:46.027]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.027]                   signalCondition(cond)
[16:12:46.027]                 }
[16:12:46.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.027]                 "immediateCondition"))) {
[16:12:46.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.027]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.027]                   if (TRUE && !signal) {
[16:12:46.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.027]                     {
[16:12:46.027]                       inherits <- base::inherits
[16:12:46.027]                       invokeRestart <- base::invokeRestart
[16:12:46.027]                       is.null <- base::is.null
[16:12:46.027]                       muffled <- FALSE
[16:12:46.027]                       if (inherits(cond, "message")) {
[16:12:46.027]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.027]                         if (muffled) 
[16:12:46.027]                           invokeRestart("muffleMessage")
[16:12:46.027]                       }
[16:12:46.027]                       else if (inherits(cond, "warning")) {
[16:12:46.027]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.027]                         if (muffled) 
[16:12:46.027]                           invokeRestart("muffleWarning")
[16:12:46.027]                       }
[16:12:46.027]                       else if (inherits(cond, "condition")) {
[16:12:46.027]                         if (!is.null(pattern)) {
[16:12:46.027]                           computeRestarts <- base::computeRestarts
[16:12:46.027]                           grepl <- base::grepl
[16:12:46.027]                           restarts <- computeRestarts(cond)
[16:12:46.027]                           for (restart in restarts) {
[16:12:46.027]                             name <- restart$name
[16:12:46.027]                             if (is.null(name)) 
[16:12:46.027]                               next
[16:12:46.027]                             if (!grepl(pattern, name)) 
[16:12:46.027]                               next
[16:12:46.027]                             invokeRestart(restart)
[16:12:46.027]                             muffled <- TRUE
[16:12:46.027]                             break
[16:12:46.027]                           }
[16:12:46.027]                         }
[16:12:46.027]                       }
[16:12:46.027]                       invisible(muffled)
[16:12:46.027]                     }
[16:12:46.027]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.027]                   }
[16:12:46.027]                 }
[16:12:46.027]                 else {
[16:12:46.027]                   if (TRUE) {
[16:12:46.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.027]                     {
[16:12:46.027]                       inherits <- base::inherits
[16:12:46.027]                       invokeRestart <- base::invokeRestart
[16:12:46.027]                       is.null <- base::is.null
[16:12:46.027]                       muffled <- FALSE
[16:12:46.027]                       if (inherits(cond, "message")) {
[16:12:46.027]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.027]                         if (muffled) 
[16:12:46.027]                           invokeRestart("muffleMessage")
[16:12:46.027]                       }
[16:12:46.027]                       else if (inherits(cond, "warning")) {
[16:12:46.027]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.027]                         if (muffled) 
[16:12:46.027]                           invokeRestart("muffleWarning")
[16:12:46.027]                       }
[16:12:46.027]                       else if (inherits(cond, "condition")) {
[16:12:46.027]                         if (!is.null(pattern)) {
[16:12:46.027]                           computeRestarts <- base::computeRestarts
[16:12:46.027]                           grepl <- base::grepl
[16:12:46.027]                           restarts <- computeRestarts(cond)
[16:12:46.027]                           for (restart in restarts) {
[16:12:46.027]                             name <- restart$name
[16:12:46.027]                             if (is.null(name)) 
[16:12:46.027]                               next
[16:12:46.027]                             if (!grepl(pattern, name)) 
[16:12:46.027]                               next
[16:12:46.027]                             invokeRestart(restart)
[16:12:46.027]                             muffled <- TRUE
[16:12:46.027]                             break
[16:12:46.027]                           }
[16:12:46.027]                         }
[16:12:46.027]                       }
[16:12:46.027]                       invisible(muffled)
[16:12:46.027]                     }
[16:12:46.027]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.027]                   }
[16:12:46.027]                 }
[16:12:46.027]             }
[16:12:46.027]         }))
[16:12:46.027]     }, error = function(ex) {
[16:12:46.027]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.027]                 ...future.rng), started = ...future.startTime, 
[16:12:46.027]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.027]             version = "1.8"), class = "FutureResult")
[16:12:46.027]     }, finally = {
[16:12:46.027]         if (!identical(...future.workdir, getwd())) 
[16:12:46.027]             setwd(...future.workdir)
[16:12:46.027]         {
[16:12:46.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.027]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.027]             }
[16:12:46.027]             base::options(...future.oldOptions)
[16:12:46.027]             if (.Platform$OS.type == "windows") {
[16:12:46.027]                 old_names <- names(...future.oldEnvVars)
[16:12:46.027]                 envs <- base::Sys.getenv()
[16:12:46.027]                 names <- names(envs)
[16:12:46.027]                 common <- intersect(names, old_names)
[16:12:46.027]                 added <- setdiff(names, old_names)
[16:12:46.027]                 removed <- setdiff(old_names, names)
[16:12:46.027]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.027]                   envs[common]]
[16:12:46.027]                 NAMES <- toupper(changed)
[16:12:46.027]                 args <- list()
[16:12:46.027]                 for (kk in seq_along(NAMES)) {
[16:12:46.027]                   name <- changed[[kk]]
[16:12:46.027]                   NAME <- NAMES[[kk]]
[16:12:46.027]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.027]                     next
[16:12:46.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.027]                 }
[16:12:46.027]                 NAMES <- toupper(added)
[16:12:46.027]                 for (kk in seq_along(NAMES)) {
[16:12:46.027]                   name <- added[[kk]]
[16:12:46.027]                   NAME <- NAMES[[kk]]
[16:12:46.027]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.027]                     next
[16:12:46.027]                   args[[name]] <- ""
[16:12:46.027]                 }
[16:12:46.027]                 NAMES <- toupper(removed)
[16:12:46.027]                 for (kk in seq_along(NAMES)) {
[16:12:46.027]                   name <- removed[[kk]]
[16:12:46.027]                   NAME <- NAMES[[kk]]
[16:12:46.027]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.027]                     next
[16:12:46.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.027]                 }
[16:12:46.027]                 if (length(args) > 0) 
[16:12:46.027]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.027]             }
[16:12:46.027]             else {
[16:12:46.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.027]             }
[16:12:46.027]             {
[16:12:46.027]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.027]                   0L) {
[16:12:46.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.027]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.027]                   base::options(opts)
[16:12:46.027]                 }
[16:12:46.027]                 {
[16:12:46.027]                   {
[16:12:46.027]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.027]                     NULL
[16:12:46.027]                   }
[16:12:46.027]                   options(future.plan = NULL)
[16:12:46.027]                   if (is.na(NA_character_)) 
[16:12:46.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.027]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.027]                     envir = parent.frame()) 
[16:12:46.027]                   {
[16:12:46.027]                     default_workers <- missing(workers)
[16:12:46.027]                     if (is.function(workers)) 
[16:12:46.027]                       workers <- workers()
[16:12:46.027]                     workers <- structure(as.integer(workers), 
[16:12:46.027]                       class = class(workers))
[16:12:46.027]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.027]                       1L)
[16:12:46.027]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.027]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.027]                       if (default_workers) 
[16:12:46.027]                         supportsMulticore(warn = TRUE)
[16:12:46.027]                       return(sequential(..., envir = envir))
[16:12:46.027]                     }
[16:12:46.027]                     oopts <- options(mc.cores = workers)
[16:12:46.027]                     on.exit(options(oopts))
[16:12:46.027]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.027]                       envir = envir)
[16:12:46.027]                     if (!future$lazy) 
[16:12:46.027]                       future <- run(future)
[16:12:46.027]                     invisible(future)
[16:12:46.027]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.027]                 }
[16:12:46.027]             }
[16:12:46.027]         }
[16:12:46.027]     })
[16:12:46.027]     if (TRUE) {
[16:12:46.027]         base::sink(type = "output", split = FALSE)
[16:12:46.027]         if (TRUE) {
[16:12:46.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.027]         }
[16:12:46.027]         else {
[16:12:46.027]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.027]         }
[16:12:46.027]         base::close(...future.stdout)
[16:12:46.027]         ...future.stdout <- NULL
[16:12:46.027]     }
[16:12:46.027]     ...future.result$conditions <- ...future.conditions
[16:12:46.027]     ...future.result$finished <- base::Sys.time()
[16:12:46.027]     ...future.result
[16:12:46.027] }
[16:12:46.029] assign_globals() ...
[16:12:46.029] List of 1
[16:12:46.029]  $ x: list()
[16:12:46.029]  - attr(*, "where")=List of 1
[16:12:46.029]   ..$ x:<environment: R_EmptyEnv> 
[16:12:46.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:46.029]  - attr(*, "resolved")= logi TRUE
[16:12:46.029]  - attr(*, "total_size")= num 0
[16:12:46.029]  - attr(*, "already-done")= logi TRUE
[16:12:46.032] - copied ‘x’ to environment
[16:12:46.032] assign_globals() ... done
[16:12:46.032] requestCore(): workers = 2
[16:12:46.035] MulticoreFuture started
[16:12:46.035] - Launch lazy future ... done
[16:12:46.035] run() for ‘MulticoreFuture’ ... done
[16:12:46.035] plan(): Setting new future strategy stack:
[16:12:46.036] List of future strategies:
[16:12:46.036] 1. sequential:
[16:12:46.036]    - args: function (..., envir = parent.frame())
[16:12:46.036]    - tweaked: FALSE
[16:12:46.036]    - call: NULL
[16:12:46.037] plan(): nbrOfWorkers() = 1
[16:12:46.038] plan(): Setting new future strategy stack:
[16:12:46.038] List of future strategies:
[16:12:46.038] 1. multicore:
[16:12:46.038]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.038]    - tweaked: FALSE
[16:12:46.038]    - call: plan(strategy)
[16:12:46.043] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.051] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.051] Searching for globals...
[16:12:46.054] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:46.054] Searching for globals ... DONE
[16:12:46.055] Resolving globals: TRUE
[16:12:46.055] Resolving any globals that are futures ...
[16:12:46.055] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:46.055] Resolving any globals that are futures ... DONE
[16:12:46.055] Resolving futures part of globals (recursively) ...
[16:12:46.056] resolve() on list ...
[16:12:46.056]  recursive: 99
[16:12:46.056]  length: 1
[16:12:46.056]  elements: ‘x’
[16:12:46.056]  length: 0 (resolved future 1)
[16:12:46.056] resolve() on list ... DONE
[16:12:46.056] - globals: [1] ‘x’
[16:12:46.057] Resolving futures part of globals (recursively) ... DONE
[16:12:46.057] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:46.057] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:46.057] - globals: [1] ‘x’
[16:12:46.057] 
[16:12:46.057] getGlobalsAndPackages() ... DONE
[16:12:46.058] run() for ‘Future’ ...
[16:12:46.058] - state: ‘created’
[16:12:46.058] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.062] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.062] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.062]   - Field: ‘label’
[16:12:46.062]   - Field: ‘local’
[16:12:46.063]   - Field: ‘owner’
[16:12:46.063]   - Field: ‘envir’
[16:12:46.063]   - Field: ‘workers’
[16:12:46.063]   - Field: ‘packages’
[16:12:46.063]   - Field: ‘gc’
[16:12:46.063]   - Field: ‘job’
[16:12:46.063]   - Field: ‘conditions’
[16:12:46.063]   - Field: ‘expr’
[16:12:46.063]   - Field: ‘uuid’
[16:12:46.064]   - Field: ‘seed’
[16:12:46.064]   - Field: ‘version’
[16:12:46.064]   - Field: ‘result’
[16:12:46.064]   - Field: ‘asynchronous’
[16:12:46.064]   - Field: ‘calls’
[16:12:46.064]   - Field: ‘globals’
[16:12:46.064]   - Field: ‘stdout’
[16:12:46.064]   - Field: ‘earlySignal’
[16:12:46.064]   - Field: ‘lazy’
[16:12:46.065]   - Field: ‘state’
[16:12:46.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.065] - Launch lazy future ...
[16:12:46.065] Packages needed by the future expression (n = 0): <none>
[16:12:46.065] Packages needed by future strategies (n = 0): <none>
[16:12:46.066] {
[16:12:46.066]     {
[16:12:46.066]         {
[16:12:46.066]             ...future.startTime <- base::Sys.time()
[16:12:46.066]             {
[16:12:46.066]                 {
[16:12:46.066]                   {
[16:12:46.066]                     {
[16:12:46.066]                       base::local({
[16:12:46.066]                         has_future <- base::requireNamespace("future", 
[16:12:46.066]                           quietly = TRUE)
[16:12:46.066]                         if (has_future) {
[16:12:46.066]                           ns <- base::getNamespace("future")
[16:12:46.066]                           version <- ns[[".package"]][["version"]]
[16:12:46.066]                           if (is.null(version)) 
[16:12:46.066]                             version <- utils::packageVersion("future")
[16:12:46.066]                         }
[16:12:46.066]                         else {
[16:12:46.066]                           version <- NULL
[16:12:46.066]                         }
[16:12:46.066]                         if (!has_future || version < "1.8.0") {
[16:12:46.066]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.066]                             "", base::R.version$version.string), 
[16:12:46.066]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.066]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.066]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.066]                               "release", "version")], collapse = " "), 
[16:12:46.066]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.066]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.066]                             info)
[16:12:46.066]                           info <- base::paste(info, collapse = "; ")
[16:12:46.066]                           if (!has_future) {
[16:12:46.066]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.066]                               info)
[16:12:46.066]                           }
[16:12:46.066]                           else {
[16:12:46.066]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.066]                               info, version)
[16:12:46.066]                           }
[16:12:46.066]                           base::stop(msg)
[16:12:46.066]                         }
[16:12:46.066]                       })
[16:12:46.066]                     }
[16:12:46.066]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.066]                     base::options(mc.cores = 1L)
[16:12:46.066]                   }
[16:12:46.066]                   options(future.plan = NULL)
[16:12:46.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.066]                 }
[16:12:46.066]                 ...future.workdir <- getwd()
[16:12:46.066]             }
[16:12:46.066]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.066]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.066]         }
[16:12:46.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.066]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.066]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.066]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.066]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.066]             base::names(...future.oldOptions))
[16:12:46.066]     }
[16:12:46.066]     if (FALSE) {
[16:12:46.066]     }
[16:12:46.066]     else {
[16:12:46.066]         if (TRUE) {
[16:12:46.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.066]                 open = "w")
[16:12:46.066]         }
[16:12:46.066]         else {
[16:12:46.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.066]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.066]         }
[16:12:46.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.066]             base::sink(type = "output", split = FALSE)
[16:12:46.066]             base::close(...future.stdout)
[16:12:46.066]         }, add = TRUE)
[16:12:46.066]     }
[16:12:46.066]     ...future.frame <- base::sys.nframe()
[16:12:46.066]     ...future.conditions <- base::list()
[16:12:46.066]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.066]     if (FALSE) {
[16:12:46.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.066]     }
[16:12:46.066]     ...future.result <- base::tryCatch({
[16:12:46.066]         base::withCallingHandlers({
[16:12:46.066]             ...future.value <- base::withVisible(base::local({
[16:12:46.066]                 withCallingHandlers({
[16:12:46.066]                   {
[16:12:46.066]                     x$a <- 1
[16:12:46.066]                     x
[16:12:46.066]                   }
[16:12:46.066]                 }, immediateCondition = function(cond) {
[16:12:46.066]                   save_rds <- function (object, pathname, ...) 
[16:12:46.066]                   {
[16:12:46.066]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.066]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.066]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.066]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.066]                         fi_tmp[["mtime"]])
[16:12:46.066]                     }
[16:12:46.066]                     tryCatch({
[16:12:46.066]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.066]                     }, error = function(ex) {
[16:12:46.066]                       msg <- conditionMessage(ex)
[16:12:46.066]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.066]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.066]                         fi_tmp[["mtime"]], msg)
[16:12:46.066]                       ex$message <- msg
[16:12:46.066]                       stop(ex)
[16:12:46.066]                     })
[16:12:46.066]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.066]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.066]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.066]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.066]                       fi <- file.info(pathname)
[16:12:46.066]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.066]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.066]                         fi[["size"]], fi[["mtime"]])
[16:12:46.066]                       stop(msg)
[16:12:46.066]                     }
[16:12:46.066]                     invisible(pathname)
[16:12:46.066]                   }
[16:12:46.066]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.066]                     rootPath = tempdir()) 
[16:12:46.066]                   {
[16:12:46.066]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.066]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.066]                       tmpdir = path, fileext = ".rds")
[16:12:46.066]                     save_rds(obj, file)
[16:12:46.066]                   }
[16:12:46.066]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.066]                   {
[16:12:46.066]                     inherits <- base::inherits
[16:12:46.066]                     invokeRestart <- base::invokeRestart
[16:12:46.066]                     is.null <- base::is.null
[16:12:46.066]                     muffled <- FALSE
[16:12:46.066]                     if (inherits(cond, "message")) {
[16:12:46.066]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.066]                       if (muffled) 
[16:12:46.066]                         invokeRestart("muffleMessage")
[16:12:46.066]                     }
[16:12:46.066]                     else if (inherits(cond, "warning")) {
[16:12:46.066]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.066]                       if (muffled) 
[16:12:46.066]                         invokeRestart("muffleWarning")
[16:12:46.066]                     }
[16:12:46.066]                     else if (inherits(cond, "condition")) {
[16:12:46.066]                       if (!is.null(pattern)) {
[16:12:46.066]                         computeRestarts <- base::computeRestarts
[16:12:46.066]                         grepl <- base::grepl
[16:12:46.066]                         restarts <- computeRestarts(cond)
[16:12:46.066]                         for (restart in restarts) {
[16:12:46.066]                           name <- restart$name
[16:12:46.066]                           if (is.null(name)) 
[16:12:46.066]                             next
[16:12:46.066]                           if (!grepl(pattern, name)) 
[16:12:46.066]                             next
[16:12:46.066]                           invokeRestart(restart)
[16:12:46.066]                           muffled <- TRUE
[16:12:46.066]                           break
[16:12:46.066]                         }
[16:12:46.066]                       }
[16:12:46.066]                     }
[16:12:46.066]                     invisible(muffled)
[16:12:46.066]                   }
[16:12:46.066]                   muffleCondition(cond)
[16:12:46.066]                 })
[16:12:46.066]             }))
[16:12:46.066]             future::FutureResult(value = ...future.value$value, 
[16:12:46.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.066]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.066]                     ...future.globalenv.names))
[16:12:46.066]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.066]         }, condition = base::local({
[16:12:46.066]             c <- base::c
[16:12:46.066]             inherits <- base::inherits
[16:12:46.066]             invokeRestart <- base::invokeRestart
[16:12:46.066]             length <- base::length
[16:12:46.066]             list <- base::list
[16:12:46.066]             seq.int <- base::seq.int
[16:12:46.066]             signalCondition <- base::signalCondition
[16:12:46.066]             sys.calls <- base::sys.calls
[16:12:46.066]             `[[` <- base::`[[`
[16:12:46.066]             `+` <- base::`+`
[16:12:46.066]             `<<-` <- base::`<<-`
[16:12:46.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.066]                   3L)]
[16:12:46.066]             }
[16:12:46.066]             function(cond) {
[16:12:46.066]                 is_error <- inherits(cond, "error")
[16:12:46.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.066]                   NULL)
[16:12:46.066]                 if (is_error) {
[16:12:46.066]                   sessionInformation <- function() {
[16:12:46.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.066]                       search = base::search(), system = base::Sys.info())
[16:12:46.066]                   }
[16:12:46.066]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.066]                     cond$call), session = sessionInformation(), 
[16:12:46.066]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.066]                   signalCondition(cond)
[16:12:46.066]                 }
[16:12:46.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.066]                 "immediateCondition"))) {
[16:12:46.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.066]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.066]                   if (TRUE && !signal) {
[16:12:46.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.066]                     {
[16:12:46.066]                       inherits <- base::inherits
[16:12:46.066]                       invokeRestart <- base::invokeRestart
[16:12:46.066]                       is.null <- base::is.null
[16:12:46.066]                       muffled <- FALSE
[16:12:46.066]                       if (inherits(cond, "message")) {
[16:12:46.066]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.066]                         if (muffled) 
[16:12:46.066]                           invokeRestart("muffleMessage")
[16:12:46.066]                       }
[16:12:46.066]                       else if (inherits(cond, "warning")) {
[16:12:46.066]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.066]                         if (muffled) 
[16:12:46.066]                           invokeRestart("muffleWarning")
[16:12:46.066]                       }
[16:12:46.066]                       else if (inherits(cond, "condition")) {
[16:12:46.066]                         if (!is.null(pattern)) {
[16:12:46.066]                           computeRestarts <- base::computeRestarts
[16:12:46.066]                           grepl <- base::grepl
[16:12:46.066]                           restarts <- computeRestarts(cond)
[16:12:46.066]                           for (restart in restarts) {
[16:12:46.066]                             name <- restart$name
[16:12:46.066]                             if (is.null(name)) 
[16:12:46.066]                               next
[16:12:46.066]                             if (!grepl(pattern, name)) 
[16:12:46.066]                               next
[16:12:46.066]                             invokeRestart(restart)
[16:12:46.066]                             muffled <- TRUE
[16:12:46.066]                             break
[16:12:46.066]                           }
[16:12:46.066]                         }
[16:12:46.066]                       }
[16:12:46.066]                       invisible(muffled)
[16:12:46.066]                     }
[16:12:46.066]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.066]                   }
[16:12:46.066]                 }
[16:12:46.066]                 else {
[16:12:46.066]                   if (TRUE) {
[16:12:46.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.066]                     {
[16:12:46.066]                       inherits <- base::inherits
[16:12:46.066]                       invokeRestart <- base::invokeRestart
[16:12:46.066]                       is.null <- base::is.null
[16:12:46.066]                       muffled <- FALSE
[16:12:46.066]                       if (inherits(cond, "message")) {
[16:12:46.066]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.066]                         if (muffled) 
[16:12:46.066]                           invokeRestart("muffleMessage")
[16:12:46.066]                       }
[16:12:46.066]                       else if (inherits(cond, "warning")) {
[16:12:46.066]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.066]                         if (muffled) 
[16:12:46.066]                           invokeRestart("muffleWarning")
[16:12:46.066]                       }
[16:12:46.066]                       else if (inherits(cond, "condition")) {
[16:12:46.066]                         if (!is.null(pattern)) {
[16:12:46.066]                           computeRestarts <- base::computeRestarts
[16:12:46.066]                           grepl <- base::grepl
[16:12:46.066]                           restarts <- computeRestarts(cond)
[16:12:46.066]                           for (restart in restarts) {
[16:12:46.066]                             name <- restart$name
[16:12:46.066]                             if (is.null(name)) 
[16:12:46.066]                               next
[16:12:46.066]                             if (!grepl(pattern, name)) 
[16:12:46.066]                               next
[16:12:46.066]                             invokeRestart(restart)
[16:12:46.066]                             muffled <- TRUE
[16:12:46.066]                             break
[16:12:46.066]                           }
[16:12:46.066]                         }
[16:12:46.066]                       }
[16:12:46.066]                       invisible(muffled)
[16:12:46.066]                     }
[16:12:46.066]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.066]                   }
[16:12:46.066]                 }
[16:12:46.066]             }
[16:12:46.066]         }))
[16:12:46.066]     }, error = function(ex) {
[16:12:46.066]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.066]                 ...future.rng), started = ...future.startTime, 
[16:12:46.066]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.066]             version = "1.8"), class = "FutureResult")
[16:12:46.066]     }, finally = {
[16:12:46.066]         if (!identical(...future.workdir, getwd())) 
[16:12:46.066]             setwd(...future.workdir)
[16:12:46.066]         {
[16:12:46.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.066]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.066]             }
[16:12:46.066]             base::options(...future.oldOptions)
[16:12:46.066]             if (.Platform$OS.type == "windows") {
[16:12:46.066]                 old_names <- names(...future.oldEnvVars)
[16:12:46.066]                 envs <- base::Sys.getenv()
[16:12:46.066]                 names <- names(envs)
[16:12:46.066]                 common <- intersect(names, old_names)
[16:12:46.066]                 added <- setdiff(names, old_names)
[16:12:46.066]                 removed <- setdiff(old_names, names)
[16:12:46.066]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.066]                   envs[common]]
[16:12:46.066]                 NAMES <- toupper(changed)
[16:12:46.066]                 args <- list()
[16:12:46.066]                 for (kk in seq_along(NAMES)) {
[16:12:46.066]                   name <- changed[[kk]]
[16:12:46.066]                   NAME <- NAMES[[kk]]
[16:12:46.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.066]                     next
[16:12:46.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.066]                 }
[16:12:46.066]                 NAMES <- toupper(added)
[16:12:46.066]                 for (kk in seq_along(NAMES)) {
[16:12:46.066]                   name <- added[[kk]]
[16:12:46.066]                   NAME <- NAMES[[kk]]
[16:12:46.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.066]                     next
[16:12:46.066]                   args[[name]] <- ""
[16:12:46.066]                 }
[16:12:46.066]                 NAMES <- toupper(removed)
[16:12:46.066]                 for (kk in seq_along(NAMES)) {
[16:12:46.066]                   name <- removed[[kk]]
[16:12:46.066]                   NAME <- NAMES[[kk]]
[16:12:46.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.066]                     next
[16:12:46.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.066]                 }
[16:12:46.066]                 if (length(args) > 0) 
[16:12:46.066]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.066]             }
[16:12:46.066]             else {
[16:12:46.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.066]             }
[16:12:46.066]             {
[16:12:46.066]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.066]                   0L) {
[16:12:46.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.066]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.066]                   base::options(opts)
[16:12:46.066]                 }
[16:12:46.066]                 {
[16:12:46.066]                   {
[16:12:46.066]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.066]                     NULL
[16:12:46.066]                   }
[16:12:46.066]                   options(future.plan = NULL)
[16:12:46.066]                   if (is.na(NA_character_)) 
[16:12:46.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.066]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.066]                     envir = parent.frame()) 
[16:12:46.066]                   {
[16:12:46.066]                     default_workers <- missing(workers)
[16:12:46.066]                     if (is.function(workers)) 
[16:12:46.066]                       workers <- workers()
[16:12:46.066]                     workers <- structure(as.integer(workers), 
[16:12:46.066]                       class = class(workers))
[16:12:46.066]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.066]                       1L)
[16:12:46.066]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.066]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.066]                       if (default_workers) 
[16:12:46.066]                         supportsMulticore(warn = TRUE)
[16:12:46.066]                       return(sequential(..., envir = envir))
[16:12:46.066]                     }
[16:12:46.066]                     oopts <- options(mc.cores = workers)
[16:12:46.066]                     on.exit(options(oopts))
[16:12:46.066]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.066]                       envir = envir)
[16:12:46.066]                     if (!future$lazy) 
[16:12:46.066]                       future <- run(future)
[16:12:46.066]                     invisible(future)
[16:12:46.066]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.066]                 }
[16:12:46.066]             }
[16:12:46.066]         }
[16:12:46.066]     })
[16:12:46.066]     if (TRUE) {
[16:12:46.066]         base::sink(type = "output", split = FALSE)
[16:12:46.066]         if (TRUE) {
[16:12:46.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.066]         }
[16:12:46.066]         else {
[16:12:46.066]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.066]         }
[16:12:46.066]         base::close(...future.stdout)
[16:12:46.066]         ...future.stdout <- NULL
[16:12:46.066]     }
[16:12:46.066]     ...future.result$conditions <- ...future.conditions
[16:12:46.066]     ...future.result$finished <- base::Sys.time()
[16:12:46.066]     ...future.result
[16:12:46.066] }
[16:12:46.068] assign_globals() ...
[16:12:46.068] List of 1
[16:12:46.068]  $ x: list()
[16:12:46.068]  - attr(*, "where")=List of 1
[16:12:46.068]   ..$ x:<environment: R_EmptyEnv> 
[16:12:46.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:46.068]  - attr(*, "resolved")= logi TRUE
[16:12:46.068]  - attr(*, "total_size")= num 0
[16:12:46.068]  - attr(*, "already-done")= logi TRUE
[16:12:46.071] - copied ‘x’ to environment
[16:12:46.071] assign_globals() ... done
[16:12:46.071] requestCore(): workers = 2
[16:12:46.073] MulticoreFuture started
[16:12:46.073] - Launch lazy future ... done
[16:12:46.074] run() for ‘MulticoreFuture’ ... done
[16:12:46.074] plan(): Setting new future strategy stack:
[16:12:46.075] List of future strategies:
[16:12:46.075] 1. sequential:
[16:12:46.075]    - args: function (..., envir = parent.frame())
[16:12:46.075]    - tweaked: FALSE
[16:12:46.075]    - call: NULL
[16:12:46.075] plan(): nbrOfWorkers() = 1
[16:12:46.077] plan(): Setting new future strategy stack:
[16:12:46.077] List of future strategies:
[16:12:46.077] 1. multicore:
[16:12:46.077]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.077]    - tweaked: FALSE
[16:12:46.077]    - call: plan(strategy)
[16:12:46.082] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.084] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.084] Searching for globals...
[16:12:46.087] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:46.087] Searching for globals ... DONE
[16:12:46.087] Resolving globals: TRUE
[16:12:46.087] Resolving any globals that are futures ...
[16:12:46.087] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:46.087] Resolving any globals that are futures ... DONE
[16:12:46.088] Resolving futures part of globals (recursively) ...
[16:12:46.088] resolve() on list ...
[16:12:46.088]  recursive: 99
[16:12:46.089]  length: 1
[16:12:46.089]  elements: ‘x’
[16:12:46.089]  length: 0 (resolved future 1)
[16:12:46.089] resolve() on list ... DONE
[16:12:46.089] - globals: [1] ‘x’
[16:12:46.089] Resolving futures part of globals (recursively) ... DONE
[16:12:46.089] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:46.090] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:46.090] - globals: [1] ‘x’
[16:12:46.090] 
[16:12:46.090] getGlobalsAndPackages() ... DONE
[16:12:46.090] run() for ‘Future’ ...
[16:12:46.091] - state: ‘created’
[16:12:46.091] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.095] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.095] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.095]   - Field: ‘label’
[16:12:46.095]   - Field: ‘local’
[16:12:46.095]   - Field: ‘owner’
[16:12:46.095]   - Field: ‘envir’
[16:12:46.096]   - Field: ‘workers’
[16:12:46.096]   - Field: ‘packages’
[16:12:46.096]   - Field: ‘gc’
[16:12:46.096]   - Field: ‘job’
[16:12:46.096]   - Field: ‘conditions’
[16:12:46.099]   - Field: ‘expr’
[16:12:46.099]   - Field: ‘uuid’
[16:12:46.099]   - Field: ‘seed’
[16:12:46.099]   - Field: ‘version’
[16:12:46.099]   - Field: ‘result’
[16:12:46.099]   - Field: ‘asynchronous’
[16:12:46.099]   - Field: ‘calls’
[16:12:46.099]   - Field: ‘globals’
[16:12:46.100]   - Field: ‘stdout’
[16:12:46.100]   - Field: ‘earlySignal’
[16:12:46.100]   - Field: ‘lazy’
[16:12:46.100]   - Field: ‘state’
[16:12:46.100] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.100] - Launch lazy future ...
[16:12:46.101] Packages needed by the future expression (n = 0): <none>
[16:12:46.101] Packages needed by future strategies (n = 0): <none>
[16:12:46.102] {
[16:12:46.102]     {
[16:12:46.102]         {
[16:12:46.102]             ...future.startTime <- base::Sys.time()
[16:12:46.102]             {
[16:12:46.102]                 {
[16:12:46.102]                   {
[16:12:46.102]                     {
[16:12:46.102]                       base::local({
[16:12:46.102]                         has_future <- base::requireNamespace("future", 
[16:12:46.102]                           quietly = TRUE)
[16:12:46.102]                         if (has_future) {
[16:12:46.102]                           ns <- base::getNamespace("future")
[16:12:46.102]                           version <- ns[[".package"]][["version"]]
[16:12:46.102]                           if (is.null(version)) 
[16:12:46.102]                             version <- utils::packageVersion("future")
[16:12:46.102]                         }
[16:12:46.102]                         else {
[16:12:46.102]                           version <- NULL
[16:12:46.102]                         }
[16:12:46.102]                         if (!has_future || version < "1.8.0") {
[16:12:46.102]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.102]                             "", base::R.version$version.string), 
[16:12:46.102]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.102]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.102]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.102]                               "release", "version")], collapse = " "), 
[16:12:46.102]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.102]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.102]                             info)
[16:12:46.102]                           info <- base::paste(info, collapse = "; ")
[16:12:46.102]                           if (!has_future) {
[16:12:46.102]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.102]                               info)
[16:12:46.102]                           }
[16:12:46.102]                           else {
[16:12:46.102]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.102]                               info, version)
[16:12:46.102]                           }
[16:12:46.102]                           base::stop(msg)
[16:12:46.102]                         }
[16:12:46.102]                       })
[16:12:46.102]                     }
[16:12:46.102]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.102]                     base::options(mc.cores = 1L)
[16:12:46.102]                   }
[16:12:46.102]                   options(future.plan = NULL)
[16:12:46.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.102]                 }
[16:12:46.102]                 ...future.workdir <- getwd()
[16:12:46.102]             }
[16:12:46.102]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.102]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.102]         }
[16:12:46.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.102]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.102]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.102]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.102]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.102]             base::names(...future.oldOptions))
[16:12:46.102]     }
[16:12:46.102]     if (FALSE) {
[16:12:46.102]     }
[16:12:46.102]     else {
[16:12:46.102]         if (TRUE) {
[16:12:46.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.102]                 open = "w")
[16:12:46.102]         }
[16:12:46.102]         else {
[16:12:46.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.102]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.102]         }
[16:12:46.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.102]             base::sink(type = "output", split = FALSE)
[16:12:46.102]             base::close(...future.stdout)
[16:12:46.102]         }, add = TRUE)
[16:12:46.102]     }
[16:12:46.102]     ...future.frame <- base::sys.nframe()
[16:12:46.102]     ...future.conditions <- base::list()
[16:12:46.102]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.102]     if (FALSE) {
[16:12:46.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.102]     }
[16:12:46.102]     ...future.result <- base::tryCatch({
[16:12:46.102]         base::withCallingHandlers({
[16:12:46.102]             ...future.value <- base::withVisible(base::local({
[16:12:46.102]                 withCallingHandlers({
[16:12:46.102]                   {
[16:12:46.102]                     x$a <- 1
[16:12:46.102]                     x
[16:12:46.102]                   }
[16:12:46.102]                 }, immediateCondition = function(cond) {
[16:12:46.102]                   save_rds <- function (object, pathname, ...) 
[16:12:46.102]                   {
[16:12:46.102]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.102]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.102]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.102]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.102]                         fi_tmp[["mtime"]])
[16:12:46.102]                     }
[16:12:46.102]                     tryCatch({
[16:12:46.102]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.102]                     }, error = function(ex) {
[16:12:46.102]                       msg <- conditionMessage(ex)
[16:12:46.102]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.102]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.102]                         fi_tmp[["mtime"]], msg)
[16:12:46.102]                       ex$message <- msg
[16:12:46.102]                       stop(ex)
[16:12:46.102]                     })
[16:12:46.102]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.102]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.102]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.102]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.102]                       fi <- file.info(pathname)
[16:12:46.102]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.102]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.102]                         fi[["size"]], fi[["mtime"]])
[16:12:46.102]                       stop(msg)
[16:12:46.102]                     }
[16:12:46.102]                     invisible(pathname)
[16:12:46.102]                   }
[16:12:46.102]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.102]                     rootPath = tempdir()) 
[16:12:46.102]                   {
[16:12:46.102]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.102]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.102]                       tmpdir = path, fileext = ".rds")
[16:12:46.102]                     save_rds(obj, file)
[16:12:46.102]                   }
[16:12:46.102]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.102]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.102]                   {
[16:12:46.102]                     inherits <- base::inherits
[16:12:46.102]                     invokeRestart <- base::invokeRestart
[16:12:46.102]                     is.null <- base::is.null
[16:12:46.102]                     muffled <- FALSE
[16:12:46.102]                     if (inherits(cond, "message")) {
[16:12:46.102]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.102]                       if (muffled) 
[16:12:46.102]                         invokeRestart("muffleMessage")
[16:12:46.102]                     }
[16:12:46.102]                     else if (inherits(cond, "warning")) {
[16:12:46.102]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.102]                       if (muffled) 
[16:12:46.102]                         invokeRestart("muffleWarning")
[16:12:46.102]                     }
[16:12:46.102]                     else if (inherits(cond, "condition")) {
[16:12:46.102]                       if (!is.null(pattern)) {
[16:12:46.102]                         computeRestarts <- base::computeRestarts
[16:12:46.102]                         grepl <- base::grepl
[16:12:46.102]                         restarts <- computeRestarts(cond)
[16:12:46.102]                         for (restart in restarts) {
[16:12:46.102]                           name <- restart$name
[16:12:46.102]                           if (is.null(name)) 
[16:12:46.102]                             next
[16:12:46.102]                           if (!grepl(pattern, name)) 
[16:12:46.102]                             next
[16:12:46.102]                           invokeRestart(restart)
[16:12:46.102]                           muffled <- TRUE
[16:12:46.102]                           break
[16:12:46.102]                         }
[16:12:46.102]                       }
[16:12:46.102]                     }
[16:12:46.102]                     invisible(muffled)
[16:12:46.102]                   }
[16:12:46.102]                   muffleCondition(cond)
[16:12:46.102]                 })
[16:12:46.102]             }))
[16:12:46.102]             future::FutureResult(value = ...future.value$value, 
[16:12:46.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.102]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.102]                     ...future.globalenv.names))
[16:12:46.102]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.102]         }, condition = base::local({
[16:12:46.102]             c <- base::c
[16:12:46.102]             inherits <- base::inherits
[16:12:46.102]             invokeRestart <- base::invokeRestart
[16:12:46.102]             length <- base::length
[16:12:46.102]             list <- base::list
[16:12:46.102]             seq.int <- base::seq.int
[16:12:46.102]             signalCondition <- base::signalCondition
[16:12:46.102]             sys.calls <- base::sys.calls
[16:12:46.102]             `[[` <- base::`[[`
[16:12:46.102]             `+` <- base::`+`
[16:12:46.102]             `<<-` <- base::`<<-`
[16:12:46.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.102]                   3L)]
[16:12:46.102]             }
[16:12:46.102]             function(cond) {
[16:12:46.102]                 is_error <- inherits(cond, "error")
[16:12:46.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.102]                   NULL)
[16:12:46.102]                 if (is_error) {
[16:12:46.102]                   sessionInformation <- function() {
[16:12:46.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.102]                       search = base::search(), system = base::Sys.info())
[16:12:46.102]                   }
[16:12:46.102]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.102]                     cond$call), session = sessionInformation(), 
[16:12:46.102]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.102]                   signalCondition(cond)
[16:12:46.102]                 }
[16:12:46.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.102]                 "immediateCondition"))) {
[16:12:46.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.102]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.102]                   if (TRUE && !signal) {
[16:12:46.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.102]                     {
[16:12:46.102]                       inherits <- base::inherits
[16:12:46.102]                       invokeRestart <- base::invokeRestart
[16:12:46.102]                       is.null <- base::is.null
[16:12:46.102]                       muffled <- FALSE
[16:12:46.102]                       if (inherits(cond, "message")) {
[16:12:46.102]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.102]                         if (muffled) 
[16:12:46.102]                           invokeRestart("muffleMessage")
[16:12:46.102]                       }
[16:12:46.102]                       else if (inherits(cond, "warning")) {
[16:12:46.102]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.102]                         if (muffled) 
[16:12:46.102]                           invokeRestart("muffleWarning")
[16:12:46.102]                       }
[16:12:46.102]                       else if (inherits(cond, "condition")) {
[16:12:46.102]                         if (!is.null(pattern)) {
[16:12:46.102]                           computeRestarts <- base::computeRestarts
[16:12:46.102]                           grepl <- base::grepl
[16:12:46.102]                           restarts <- computeRestarts(cond)
[16:12:46.102]                           for (restart in restarts) {
[16:12:46.102]                             name <- restart$name
[16:12:46.102]                             if (is.null(name)) 
[16:12:46.102]                               next
[16:12:46.102]                             if (!grepl(pattern, name)) 
[16:12:46.102]                               next
[16:12:46.102]                             invokeRestart(restart)
[16:12:46.102]                             muffled <- TRUE
[16:12:46.102]                             break
[16:12:46.102]                           }
[16:12:46.102]                         }
[16:12:46.102]                       }
[16:12:46.102]                       invisible(muffled)
[16:12:46.102]                     }
[16:12:46.102]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.102]                   }
[16:12:46.102]                 }
[16:12:46.102]                 else {
[16:12:46.102]                   if (TRUE) {
[16:12:46.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.102]                     {
[16:12:46.102]                       inherits <- base::inherits
[16:12:46.102]                       invokeRestart <- base::invokeRestart
[16:12:46.102]                       is.null <- base::is.null
[16:12:46.102]                       muffled <- FALSE
[16:12:46.102]                       if (inherits(cond, "message")) {
[16:12:46.102]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.102]                         if (muffled) 
[16:12:46.102]                           invokeRestart("muffleMessage")
[16:12:46.102]                       }
[16:12:46.102]                       else if (inherits(cond, "warning")) {
[16:12:46.102]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.102]                         if (muffled) 
[16:12:46.102]                           invokeRestart("muffleWarning")
[16:12:46.102]                       }
[16:12:46.102]                       else if (inherits(cond, "condition")) {
[16:12:46.102]                         if (!is.null(pattern)) {
[16:12:46.102]                           computeRestarts <- base::computeRestarts
[16:12:46.102]                           grepl <- base::grepl
[16:12:46.102]                           restarts <- computeRestarts(cond)
[16:12:46.102]                           for (restart in restarts) {
[16:12:46.102]                             name <- restart$name
[16:12:46.102]                             if (is.null(name)) 
[16:12:46.102]                               next
[16:12:46.102]                             if (!grepl(pattern, name)) 
[16:12:46.102]                               next
[16:12:46.102]                             invokeRestart(restart)
[16:12:46.102]                             muffled <- TRUE
[16:12:46.102]                             break
[16:12:46.102]                           }
[16:12:46.102]                         }
[16:12:46.102]                       }
[16:12:46.102]                       invisible(muffled)
[16:12:46.102]                     }
[16:12:46.102]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.102]                   }
[16:12:46.102]                 }
[16:12:46.102]             }
[16:12:46.102]         }))
[16:12:46.102]     }, error = function(ex) {
[16:12:46.102]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.102]                 ...future.rng), started = ...future.startTime, 
[16:12:46.102]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.102]             version = "1.8"), class = "FutureResult")
[16:12:46.102]     }, finally = {
[16:12:46.102]         if (!identical(...future.workdir, getwd())) 
[16:12:46.102]             setwd(...future.workdir)
[16:12:46.102]         {
[16:12:46.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.102]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.102]             }
[16:12:46.102]             base::options(...future.oldOptions)
[16:12:46.102]             if (.Platform$OS.type == "windows") {
[16:12:46.102]                 old_names <- names(...future.oldEnvVars)
[16:12:46.102]                 envs <- base::Sys.getenv()
[16:12:46.102]                 names <- names(envs)
[16:12:46.102]                 common <- intersect(names, old_names)
[16:12:46.102]                 added <- setdiff(names, old_names)
[16:12:46.102]                 removed <- setdiff(old_names, names)
[16:12:46.102]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.102]                   envs[common]]
[16:12:46.102]                 NAMES <- toupper(changed)
[16:12:46.102]                 args <- list()
[16:12:46.102]                 for (kk in seq_along(NAMES)) {
[16:12:46.102]                   name <- changed[[kk]]
[16:12:46.102]                   NAME <- NAMES[[kk]]
[16:12:46.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.102]                     next
[16:12:46.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.102]                 }
[16:12:46.102]                 NAMES <- toupper(added)
[16:12:46.102]                 for (kk in seq_along(NAMES)) {
[16:12:46.102]                   name <- added[[kk]]
[16:12:46.102]                   NAME <- NAMES[[kk]]
[16:12:46.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.102]                     next
[16:12:46.102]                   args[[name]] <- ""
[16:12:46.102]                 }
[16:12:46.102]                 NAMES <- toupper(removed)
[16:12:46.102]                 for (kk in seq_along(NAMES)) {
[16:12:46.102]                   name <- removed[[kk]]
[16:12:46.102]                   NAME <- NAMES[[kk]]
[16:12:46.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.102]                     next
[16:12:46.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.102]                 }
[16:12:46.102]                 if (length(args) > 0) 
[16:12:46.102]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.102]             }
[16:12:46.102]             else {
[16:12:46.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.102]             }
[16:12:46.102]             {
[16:12:46.102]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.102]                   0L) {
[16:12:46.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.102]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.102]                   base::options(opts)
[16:12:46.102]                 }
[16:12:46.102]                 {
[16:12:46.102]                   {
[16:12:46.102]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.102]                     NULL
[16:12:46.102]                   }
[16:12:46.102]                   options(future.plan = NULL)
[16:12:46.102]                   if (is.na(NA_character_)) 
[16:12:46.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.102]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.102]                     envir = parent.frame()) 
[16:12:46.102]                   {
[16:12:46.102]                     default_workers <- missing(workers)
[16:12:46.102]                     if (is.function(workers)) 
[16:12:46.102]                       workers <- workers()
[16:12:46.102]                     workers <- structure(as.integer(workers), 
[16:12:46.102]                       class = class(workers))
[16:12:46.102]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.102]                       1L)
[16:12:46.102]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.102]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.102]                       if (default_workers) 
[16:12:46.102]                         supportsMulticore(warn = TRUE)
[16:12:46.102]                       return(sequential(..., envir = envir))
[16:12:46.102]                     }
[16:12:46.102]                     oopts <- options(mc.cores = workers)
[16:12:46.102]                     on.exit(options(oopts))
[16:12:46.102]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.102]                       envir = envir)
[16:12:46.102]                     if (!future$lazy) 
[16:12:46.102]                       future <- run(future)
[16:12:46.102]                     invisible(future)
[16:12:46.102]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.102]                 }
[16:12:46.102]             }
[16:12:46.102]         }
[16:12:46.102]     })
[16:12:46.102]     if (TRUE) {
[16:12:46.102]         base::sink(type = "output", split = FALSE)
[16:12:46.102]         if (TRUE) {
[16:12:46.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.102]         }
[16:12:46.102]         else {
[16:12:46.102]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.102]         }
[16:12:46.102]         base::close(...future.stdout)
[16:12:46.102]         ...future.stdout <- NULL
[16:12:46.102]     }
[16:12:46.102]     ...future.result$conditions <- ...future.conditions
[16:12:46.102]     ...future.result$finished <- base::Sys.time()
[16:12:46.102]     ...future.result
[16:12:46.102] }
[16:12:46.104] assign_globals() ...
[16:12:46.104] List of 1
[16:12:46.104]  $ x: list()
[16:12:46.104]  - attr(*, "where")=List of 1
[16:12:46.104]   ..$ x:<environment: R_EmptyEnv> 
[16:12:46.104]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:46.104]  - attr(*, "resolved")= logi TRUE
[16:12:46.104]  - attr(*, "total_size")= num 0
[16:12:46.104]  - attr(*, "already-done")= logi TRUE
[16:12:46.107] - copied ‘x’ to environment
[16:12:46.107] assign_globals() ... done
[16:12:46.107] requestCore(): workers = 2
[16:12:46.109] MulticoreFuture started
[16:12:46.110] - Launch lazy future ... done
[16:12:46.110] run() for ‘MulticoreFuture’ ... done
[16:12:46.110] plan(): Setting new future strategy stack:
[16:12:46.110] List of future strategies:
[16:12:46.110] 1. sequential:
[16:12:46.110]    - args: function (..., envir = parent.frame())
[16:12:46.110]    - tweaked: FALSE
[16:12:46.110]    - call: NULL
[16:12:46.111] plan(): nbrOfWorkers() = 1
[16:12:46.113] plan(): Setting new future strategy stack:
[16:12:46.113] List of future strategies:
[16:12:46.113] 1. multicore:
[16:12:46.113]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.113]    - tweaked: FALSE
[16:12:46.113]    - call: plan(strategy)
[16:12:46.118] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.120] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.120] Searching for globals...
[16:12:46.123] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:46.123] Searching for globals ... DONE
[16:12:46.123] Resolving globals: TRUE
[16:12:46.123] Resolving any globals that are futures ...
[16:12:46.124] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:46.124] Resolving any globals that are futures ... DONE
[16:12:46.124] Resolving futures part of globals (recursively) ...
[16:12:46.125] resolve() on list ...
[16:12:46.125]  recursive: 99
[16:12:46.125]  length: 1
[16:12:46.125]  elements: ‘x’
[16:12:46.125]  length: 0 (resolved future 1)
[16:12:46.125] resolve() on list ... DONE
[16:12:46.125] - globals: [1] ‘x’
[16:12:46.125] Resolving futures part of globals (recursively) ... DONE
[16:12:46.126] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:46.126] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:46.126] - globals: [1] ‘x’
[16:12:46.126] 
[16:12:46.126] getGlobalsAndPackages() ... DONE
[16:12:46.127] run() for ‘Future’ ...
[16:12:46.127] - state: ‘created’
[16:12:46.127] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.131] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.131] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.131]   - Field: ‘label’
[16:12:46.131]   - Field: ‘local’
[16:12:46.132]   - Field: ‘owner’
[16:12:46.132]   - Field: ‘envir’
[16:12:46.132]   - Field: ‘workers’
[16:12:46.132]   - Field: ‘packages’
[16:12:46.132]   - Field: ‘gc’
[16:12:46.132]   - Field: ‘job’
[16:12:46.132]   - Field: ‘conditions’
[16:12:46.132]   - Field: ‘expr’
[16:12:46.132]   - Field: ‘uuid’
[16:12:46.133]   - Field: ‘seed’
[16:12:46.133]   - Field: ‘version’
[16:12:46.133]   - Field: ‘result’
[16:12:46.133]   - Field: ‘asynchronous’
[16:12:46.133]   - Field: ‘calls’
[16:12:46.133]   - Field: ‘globals’
[16:12:46.133]   - Field: ‘stdout’
[16:12:46.133]   - Field: ‘earlySignal’
[16:12:46.133]   - Field: ‘lazy’
[16:12:46.134]   - Field: ‘state’
[16:12:46.134] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.134] - Launch lazy future ...
[16:12:46.134] Packages needed by the future expression (n = 0): <none>
[16:12:46.134] Packages needed by future strategies (n = 0): <none>
[16:12:46.135] {
[16:12:46.135]     {
[16:12:46.135]         {
[16:12:46.135]             ...future.startTime <- base::Sys.time()
[16:12:46.135]             {
[16:12:46.135]                 {
[16:12:46.135]                   {
[16:12:46.135]                     {
[16:12:46.135]                       base::local({
[16:12:46.135]                         has_future <- base::requireNamespace("future", 
[16:12:46.135]                           quietly = TRUE)
[16:12:46.135]                         if (has_future) {
[16:12:46.135]                           ns <- base::getNamespace("future")
[16:12:46.135]                           version <- ns[[".package"]][["version"]]
[16:12:46.135]                           if (is.null(version)) 
[16:12:46.135]                             version <- utils::packageVersion("future")
[16:12:46.135]                         }
[16:12:46.135]                         else {
[16:12:46.135]                           version <- NULL
[16:12:46.135]                         }
[16:12:46.135]                         if (!has_future || version < "1.8.0") {
[16:12:46.135]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.135]                             "", base::R.version$version.string), 
[16:12:46.135]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.135]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.135]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.135]                               "release", "version")], collapse = " "), 
[16:12:46.135]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.135]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.135]                             info)
[16:12:46.135]                           info <- base::paste(info, collapse = "; ")
[16:12:46.135]                           if (!has_future) {
[16:12:46.135]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.135]                               info)
[16:12:46.135]                           }
[16:12:46.135]                           else {
[16:12:46.135]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.135]                               info, version)
[16:12:46.135]                           }
[16:12:46.135]                           base::stop(msg)
[16:12:46.135]                         }
[16:12:46.135]                       })
[16:12:46.135]                     }
[16:12:46.135]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.135]                     base::options(mc.cores = 1L)
[16:12:46.135]                   }
[16:12:46.135]                   options(future.plan = NULL)
[16:12:46.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.135]                 }
[16:12:46.135]                 ...future.workdir <- getwd()
[16:12:46.135]             }
[16:12:46.135]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.135]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.135]         }
[16:12:46.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.135]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.135]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.135]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.135]             base::names(...future.oldOptions))
[16:12:46.135]     }
[16:12:46.135]     if (FALSE) {
[16:12:46.135]     }
[16:12:46.135]     else {
[16:12:46.135]         if (TRUE) {
[16:12:46.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.135]                 open = "w")
[16:12:46.135]         }
[16:12:46.135]         else {
[16:12:46.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.135]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.135]         }
[16:12:46.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.135]             base::sink(type = "output", split = FALSE)
[16:12:46.135]             base::close(...future.stdout)
[16:12:46.135]         }, add = TRUE)
[16:12:46.135]     }
[16:12:46.135]     ...future.frame <- base::sys.nframe()
[16:12:46.135]     ...future.conditions <- base::list()
[16:12:46.135]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.135]     if (FALSE) {
[16:12:46.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.135]     }
[16:12:46.135]     ...future.result <- base::tryCatch({
[16:12:46.135]         base::withCallingHandlers({
[16:12:46.135]             ...future.value <- base::withVisible(base::local({
[16:12:46.135]                 withCallingHandlers({
[16:12:46.135]                   {
[16:12:46.135]                     x$a <- 1
[16:12:46.135]                     x
[16:12:46.135]                   }
[16:12:46.135]                 }, immediateCondition = function(cond) {
[16:12:46.135]                   save_rds <- function (object, pathname, ...) 
[16:12:46.135]                   {
[16:12:46.135]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.135]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.135]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.135]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.135]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.135]                         fi_tmp[["mtime"]])
[16:12:46.135]                     }
[16:12:46.135]                     tryCatch({
[16:12:46.135]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.135]                     }, error = function(ex) {
[16:12:46.135]                       msg <- conditionMessage(ex)
[16:12:46.135]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.135]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.135]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.135]                         fi_tmp[["mtime"]], msg)
[16:12:46.135]                       ex$message <- msg
[16:12:46.135]                       stop(ex)
[16:12:46.135]                     })
[16:12:46.135]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.135]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.135]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.135]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.135]                       fi <- file.info(pathname)
[16:12:46.135]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.135]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.135]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.135]                         fi[["size"]], fi[["mtime"]])
[16:12:46.135]                       stop(msg)
[16:12:46.135]                     }
[16:12:46.135]                     invisible(pathname)
[16:12:46.135]                   }
[16:12:46.135]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.135]                     rootPath = tempdir()) 
[16:12:46.135]                   {
[16:12:46.135]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.135]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.135]                       tmpdir = path, fileext = ".rds")
[16:12:46.135]                     save_rds(obj, file)
[16:12:46.135]                   }
[16:12:46.135]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.135]                   {
[16:12:46.135]                     inherits <- base::inherits
[16:12:46.135]                     invokeRestart <- base::invokeRestart
[16:12:46.135]                     is.null <- base::is.null
[16:12:46.135]                     muffled <- FALSE
[16:12:46.135]                     if (inherits(cond, "message")) {
[16:12:46.135]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.135]                       if (muffled) 
[16:12:46.135]                         invokeRestart("muffleMessage")
[16:12:46.135]                     }
[16:12:46.135]                     else if (inherits(cond, "warning")) {
[16:12:46.135]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.135]                       if (muffled) 
[16:12:46.135]                         invokeRestart("muffleWarning")
[16:12:46.135]                     }
[16:12:46.135]                     else if (inherits(cond, "condition")) {
[16:12:46.135]                       if (!is.null(pattern)) {
[16:12:46.135]                         computeRestarts <- base::computeRestarts
[16:12:46.135]                         grepl <- base::grepl
[16:12:46.135]                         restarts <- computeRestarts(cond)
[16:12:46.135]                         for (restart in restarts) {
[16:12:46.135]                           name <- restart$name
[16:12:46.135]                           if (is.null(name)) 
[16:12:46.135]                             next
[16:12:46.135]                           if (!grepl(pattern, name)) 
[16:12:46.135]                             next
[16:12:46.135]                           invokeRestart(restart)
[16:12:46.135]                           muffled <- TRUE
[16:12:46.135]                           break
[16:12:46.135]                         }
[16:12:46.135]                       }
[16:12:46.135]                     }
[16:12:46.135]                     invisible(muffled)
[16:12:46.135]                   }
[16:12:46.135]                   muffleCondition(cond)
[16:12:46.135]                 })
[16:12:46.135]             }))
[16:12:46.135]             future::FutureResult(value = ...future.value$value, 
[16:12:46.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.135]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.135]                     ...future.globalenv.names))
[16:12:46.135]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.135]         }, condition = base::local({
[16:12:46.135]             c <- base::c
[16:12:46.135]             inherits <- base::inherits
[16:12:46.135]             invokeRestart <- base::invokeRestart
[16:12:46.135]             length <- base::length
[16:12:46.135]             list <- base::list
[16:12:46.135]             seq.int <- base::seq.int
[16:12:46.135]             signalCondition <- base::signalCondition
[16:12:46.135]             sys.calls <- base::sys.calls
[16:12:46.135]             `[[` <- base::`[[`
[16:12:46.135]             `+` <- base::`+`
[16:12:46.135]             `<<-` <- base::`<<-`
[16:12:46.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.135]                   3L)]
[16:12:46.135]             }
[16:12:46.135]             function(cond) {
[16:12:46.135]                 is_error <- inherits(cond, "error")
[16:12:46.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.135]                   NULL)
[16:12:46.135]                 if (is_error) {
[16:12:46.135]                   sessionInformation <- function() {
[16:12:46.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.135]                       search = base::search(), system = base::Sys.info())
[16:12:46.135]                   }
[16:12:46.135]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.135]                     cond$call), session = sessionInformation(), 
[16:12:46.135]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.135]                   signalCondition(cond)
[16:12:46.135]                 }
[16:12:46.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.135]                 "immediateCondition"))) {
[16:12:46.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.135]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.135]                   if (TRUE && !signal) {
[16:12:46.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.135]                     {
[16:12:46.135]                       inherits <- base::inherits
[16:12:46.135]                       invokeRestart <- base::invokeRestart
[16:12:46.135]                       is.null <- base::is.null
[16:12:46.135]                       muffled <- FALSE
[16:12:46.135]                       if (inherits(cond, "message")) {
[16:12:46.135]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.135]                         if (muffled) 
[16:12:46.135]                           invokeRestart("muffleMessage")
[16:12:46.135]                       }
[16:12:46.135]                       else if (inherits(cond, "warning")) {
[16:12:46.135]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.135]                         if (muffled) 
[16:12:46.135]                           invokeRestart("muffleWarning")
[16:12:46.135]                       }
[16:12:46.135]                       else if (inherits(cond, "condition")) {
[16:12:46.135]                         if (!is.null(pattern)) {
[16:12:46.135]                           computeRestarts <- base::computeRestarts
[16:12:46.135]                           grepl <- base::grepl
[16:12:46.135]                           restarts <- computeRestarts(cond)
[16:12:46.135]                           for (restart in restarts) {
[16:12:46.135]                             name <- restart$name
[16:12:46.135]                             if (is.null(name)) 
[16:12:46.135]                               next
[16:12:46.135]                             if (!grepl(pattern, name)) 
[16:12:46.135]                               next
[16:12:46.135]                             invokeRestart(restart)
[16:12:46.135]                             muffled <- TRUE
[16:12:46.135]                             break
[16:12:46.135]                           }
[16:12:46.135]                         }
[16:12:46.135]                       }
[16:12:46.135]                       invisible(muffled)
[16:12:46.135]                     }
[16:12:46.135]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.135]                   }
[16:12:46.135]                 }
[16:12:46.135]                 else {
[16:12:46.135]                   if (TRUE) {
[16:12:46.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.135]                     {
[16:12:46.135]                       inherits <- base::inherits
[16:12:46.135]                       invokeRestart <- base::invokeRestart
[16:12:46.135]                       is.null <- base::is.null
[16:12:46.135]                       muffled <- FALSE
[16:12:46.135]                       if (inherits(cond, "message")) {
[16:12:46.135]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.135]                         if (muffled) 
[16:12:46.135]                           invokeRestart("muffleMessage")
[16:12:46.135]                       }
[16:12:46.135]                       else if (inherits(cond, "warning")) {
[16:12:46.135]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.135]                         if (muffled) 
[16:12:46.135]                           invokeRestart("muffleWarning")
[16:12:46.135]                       }
[16:12:46.135]                       else if (inherits(cond, "condition")) {
[16:12:46.135]                         if (!is.null(pattern)) {
[16:12:46.135]                           computeRestarts <- base::computeRestarts
[16:12:46.135]                           grepl <- base::grepl
[16:12:46.135]                           restarts <- computeRestarts(cond)
[16:12:46.135]                           for (restart in restarts) {
[16:12:46.135]                             name <- restart$name
[16:12:46.135]                             if (is.null(name)) 
[16:12:46.135]                               next
[16:12:46.135]                             if (!grepl(pattern, name)) 
[16:12:46.135]                               next
[16:12:46.135]                             invokeRestart(restart)
[16:12:46.135]                             muffled <- TRUE
[16:12:46.135]                             break
[16:12:46.135]                           }
[16:12:46.135]                         }
[16:12:46.135]                       }
[16:12:46.135]                       invisible(muffled)
[16:12:46.135]                     }
[16:12:46.135]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.135]                   }
[16:12:46.135]                 }
[16:12:46.135]             }
[16:12:46.135]         }))
[16:12:46.135]     }, error = function(ex) {
[16:12:46.135]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.135]                 ...future.rng), started = ...future.startTime, 
[16:12:46.135]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.135]             version = "1.8"), class = "FutureResult")
[16:12:46.135]     }, finally = {
[16:12:46.135]         if (!identical(...future.workdir, getwd())) 
[16:12:46.135]             setwd(...future.workdir)
[16:12:46.135]         {
[16:12:46.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.135]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.135]             }
[16:12:46.135]             base::options(...future.oldOptions)
[16:12:46.135]             if (.Platform$OS.type == "windows") {
[16:12:46.135]                 old_names <- names(...future.oldEnvVars)
[16:12:46.135]                 envs <- base::Sys.getenv()
[16:12:46.135]                 names <- names(envs)
[16:12:46.135]                 common <- intersect(names, old_names)
[16:12:46.135]                 added <- setdiff(names, old_names)
[16:12:46.135]                 removed <- setdiff(old_names, names)
[16:12:46.135]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.135]                   envs[common]]
[16:12:46.135]                 NAMES <- toupper(changed)
[16:12:46.135]                 args <- list()
[16:12:46.135]                 for (kk in seq_along(NAMES)) {
[16:12:46.135]                   name <- changed[[kk]]
[16:12:46.135]                   NAME <- NAMES[[kk]]
[16:12:46.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.135]                     next
[16:12:46.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.135]                 }
[16:12:46.135]                 NAMES <- toupper(added)
[16:12:46.135]                 for (kk in seq_along(NAMES)) {
[16:12:46.135]                   name <- added[[kk]]
[16:12:46.135]                   NAME <- NAMES[[kk]]
[16:12:46.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.135]                     next
[16:12:46.135]                   args[[name]] <- ""
[16:12:46.135]                 }
[16:12:46.135]                 NAMES <- toupper(removed)
[16:12:46.135]                 for (kk in seq_along(NAMES)) {
[16:12:46.135]                   name <- removed[[kk]]
[16:12:46.135]                   NAME <- NAMES[[kk]]
[16:12:46.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.135]                     next
[16:12:46.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.135]                 }
[16:12:46.135]                 if (length(args) > 0) 
[16:12:46.135]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.135]             }
[16:12:46.135]             else {
[16:12:46.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.135]             }
[16:12:46.135]             {
[16:12:46.135]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.135]                   0L) {
[16:12:46.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.135]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.135]                   base::options(opts)
[16:12:46.135]                 }
[16:12:46.135]                 {
[16:12:46.135]                   {
[16:12:46.135]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.135]                     NULL
[16:12:46.135]                   }
[16:12:46.135]                   options(future.plan = NULL)
[16:12:46.135]                   if (is.na(NA_character_)) 
[16:12:46.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.135]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.135]                     envir = parent.frame()) 
[16:12:46.135]                   {
[16:12:46.135]                     default_workers <- missing(workers)
[16:12:46.135]                     if (is.function(workers)) 
[16:12:46.135]                       workers <- workers()
[16:12:46.135]                     workers <- structure(as.integer(workers), 
[16:12:46.135]                       class = class(workers))
[16:12:46.135]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.135]                       1L)
[16:12:46.135]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.135]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.135]                       if (default_workers) 
[16:12:46.135]                         supportsMulticore(warn = TRUE)
[16:12:46.135]                       return(sequential(..., envir = envir))
[16:12:46.135]                     }
[16:12:46.135]                     oopts <- options(mc.cores = workers)
[16:12:46.135]                     on.exit(options(oopts))
[16:12:46.135]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.135]                       envir = envir)
[16:12:46.135]                     if (!future$lazy) 
[16:12:46.135]                       future <- run(future)
[16:12:46.135]                     invisible(future)
[16:12:46.135]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.135]                 }
[16:12:46.135]             }
[16:12:46.135]         }
[16:12:46.135]     })
[16:12:46.135]     if (TRUE) {
[16:12:46.135]         base::sink(type = "output", split = FALSE)
[16:12:46.135]         if (TRUE) {
[16:12:46.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.135]         }
[16:12:46.135]         else {
[16:12:46.135]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.135]         }
[16:12:46.135]         base::close(...future.stdout)
[16:12:46.135]         ...future.stdout <- NULL
[16:12:46.135]     }
[16:12:46.135]     ...future.result$conditions <- ...future.conditions
[16:12:46.135]     ...future.result$finished <- base::Sys.time()
[16:12:46.135]     ...future.result
[16:12:46.135] }
[16:12:46.138] assign_globals() ...
[16:12:46.138] List of 1
[16:12:46.138]  $ x: list()
[16:12:46.138]  - attr(*, "where")=List of 1
[16:12:46.138]   ..$ x:<environment: R_EmptyEnv> 
[16:12:46.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:46.138]  - attr(*, "resolved")= logi TRUE
[16:12:46.138]  - attr(*, "total_size")= num 0
[16:12:46.138]  - attr(*, "already-done")= logi TRUE
[16:12:46.141] - copied ‘x’ to environment
[16:12:46.141] assign_globals() ... done
[16:12:46.141] requestCore(): workers = 2
[16:12:46.142] MulticoreFuture started
[16:12:46.143] - Launch lazy future ... done
[16:12:46.143] run() for ‘MulticoreFuture’ ... done
[16:12:46.144] plan(): Setting new future strategy stack:
[16:12:46.144] List of future strategies:
[16:12:46.144] 1. sequential:
[16:12:46.144]    - args: function (..., envir = parent.frame())
[16:12:46.144]    - tweaked: FALSE
[16:12:46.144]    - call: NULL
[16:12:46.145] plan(): nbrOfWorkers() = 1
[16:12:46.147] plan(): Setting new future strategy stack:
[16:12:46.147] List of future strategies:
[16:12:46.147] 1. multicore:
[16:12:46.147]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.147]    - tweaked: FALSE
[16:12:46.147]    - call: plan(strategy)
[16:12:46.152] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.153] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.154] Searching for globals...
[16:12:46.160] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:12:46.160] Searching for globals ... DONE
[16:12:46.161] Resolving globals: TRUE
[16:12:46.161] Resolving any globals that are futures ...
[16:12:46.161] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:12:46.161] Resolving any globals that are futures ... DONE
[16:12:46.162] 
[16:12:46.162] 
[16:12:46.162] getGlobalsAndPackages() ... DONE
[16:12:46.162] run() for ‘Future’ ...
[16:12:46.162] - state: ‘created’
[16:12:46.162] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.166] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.167]   - Field: ‘label’
[16:12:46.167]   - Field: ‘local’
[16:12:46.167]   - Field: ‘owner’
[16:12:46.167]   - Field: ‘envir’
[16:12:46.167]   - Field: ‘workers’
[16:12:46.167]   - Field: ‘packages’
[16:12:46.167]   - Field: ‘gc’
[16:12:46.167]   - Field: ‘job’
[16:12:46.168]   - Field: ‘conditions’
[16:12:46.168]   - Field: ‘expr’
[16:12:46.168]   - Field: ‘uuid’
[16:12:46.168]   - Field: ‘seed’
[16:12:46.168]   - Field: ‘version’
[16:12:46.168]   - Field: ‘result’
[16:12:46.168]   - Field: ‘asynchronous’
[16:12:46.168]   - Field: ‘calls’
[16:12:46.169]   - Field: ‘globals’
[16:12:46.169]   - Field: ‘stdout’
[16:12:46.169]   - Field: ‘earlySignal’
[16:12:46.169]   - Field: ‘lazy’
[16:12:46.169]   - Field: ‘state’
[16:12:46.169] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.169] - Launch lazy future ...
[16:12:46.170] Packages needed by the future expression (n = 0): <none>
[16:12:46.170] Packages needed by future strategies (n = 0): <none>
[16:12:46.170] {
[16:12:46.170]     {
[16:12:46.170]         {
[16:12:46.170]             ...future.startTime <- base::Sys.time()
[16:12:46.170]             {
[16:12:46.170]                 {
[16:12:46.170]                   {
[16:12:46.170]                     {
[16:12:46.170]                       base::local({
[16:12:46.170]                         has_future <- base::requireNamespace("future", 
[16:12:46.170]                           quietly = TRUE)
[16:12:46.170]                         if (has_future) {
[16:12:46.170]                           ns <- base::getNamespace("future")
[16:12:46.170]                           version <- ns[[".package"]][["version"]]
[16:12:46.170]                           if (is.null(version)) 
[16:12:46.170]                             version <- utils::packageVersion("future")
[16:12:46.170]                         }
[16:12:46.170]                         else {
[16:12:46.170]                           version <- NULL
[16:12:46.170]                         }
[16:12:46.170]                         if (!has_future || version < "1.8.0") {
[16:12:46.170]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.170]                             "", base::R.version$version.string), 
[16:12:46.170]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.170]                               "release", "version")], collapse = " "), 
[16:12:46.170]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.170]                             info)
[16:12:46.170]                           info <- base::paste(info, collapse = "; ")
[16:12:46.170]                           if (!has_future) {
[16:12:46.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.170]                               info)
[16:12:46.170]                           }
[16:12:46.170]                           else {
[16:12:46.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.170]                               info, version)
[16:12:46.170]                           }
[16:12:46.170]                           base::stop(msg)
[16:12:46.170]                         }
[16:12:46.170]                       })
[16:12:46.170]                     }
[16:12:46.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.170]                     base::options(mc.cores = 1L)
[16:12:46.170]                   }
[16:12:46.170]                   options(future.plan = NULL)
[16:12:46.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.170]                 }
[16:12:46.170]                 ...future.workdir <- getwd()
[16:12:46.170]             }
[16:12:46.170]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.170]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.170]         }
[16:12:46.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.170]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.170]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.170]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.170]             base::names(...future.oldOptions))
[16:12:46.170]     }
[16:12:46.170]     if (FALSE) {
[16:12:46.170]     }
[16:12:46.170]     else {
[16:12:46.170]         if (TRUE) {
[16:12:46.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.170]                 open = "w")
[16:12:46.170]         }
[16:12:46.170]         else {
[16:12:46.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.170]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.170]         }
[16:12:46.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.170]             base::sink(type = "output", split = FALSE)
[16:12:46.170]             base::close(...future.stdout)
[16:12:46.170]         }, add = TRUE)
[16:12:46.170]     }
[16:12:46.170]     ...future.frame <- base::sys.nframe()
[16:12:46.170]     ...future.conditions <- base::list()
[16:12:46.170]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.170]     if (FALSE) {
[16:12:46.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.170]     }
[16:12:46.170]     ...future.result <- base::tryCatch({
[16:12:46.170]         base::withCallingHandlers({
[16:12:46.170]             ...future.value <- base::withVisible(base::local({
[16:12:46.170]                 withCallingHandlers({
[16:12:46.170]                   {
[16:12:46.170]                     x <- list(b = 2)
[16:12:46.170]                     x$a <- 1
[16:12:46.170]                     x
[16:12:46.170]                   }
[16:12:46.170]                 }, immediateCondition = function(cond) {
[16:12:46.170]                   save_rds <- function (object, pathname, ...) 
[16:12:46.170]                   {
[16:12:46.170]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.170]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.170]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.170]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.170]                         fi_tmp[["mtime"]])
[16:12:46.170]                     }
[16:12:46.170]                     tryCatch({
[16:12:46.170]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.170]                     }, error = function(ex) {
[16:12:46.170]                       msg <- conditionMessage(ex)
[16:12:46.170]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.170]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.170]                         fi_tmp[["mtime"]], msg)
[16:12:46.170]                       ex$message <- msg
[16:12:46.170]                       stop(ex)
[16:12:46.170]                     })
[16:12:46.170]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.170]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.170]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.170]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.170]                       fi <- file.info(pathname)
[16:12:46.170]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.170]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.170]                         fi[["size"]], fi[["mtime"]])
[16:12:46.170]                       stop(msg)
[16:12:46.170]                     }
[16:12:46.170]                     invisible(pathname)
[16:12:46.170]                   }
[16:12:46.170]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.170]                     rootPath = tempdir()) 
[16:12:46.170]                   {
[16:12:46.170]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.170]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.170]                       tmpdir = path, fileext = ".rds")
[16:12:46.170]                     save_rds(obj, file)
[16:12:46.170]                   }
[16:12:46.170]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.170]                   {
[16:12:46.170]                     inherits <- base::inherits
[16:12:46.170]                     invokeRestart <- base::invokeRestart
[16:12:46.170]                     is.null <- base::is.null
[16:12:46.170]                     muffled <- FALSE
[16:12:46.170]                     if (inherits(cond, "message")) {
[16:12:46.170]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.170]                       if (muffled) 
[16:12:46.170]                         invokeRestart("muffleMessage")
[16:12:46.170]                     }
[16:12:46.170]                     else if (inherits(cond, "warning")) {
[16:12:46.170]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.170]                       if (muffled) 
[16:12:46.170]                         invokeRestart("muffleWarning")
[16:12:46.170]                     }
[16:12:46.170]                     else if (inherits(cond, "condition")) {
[16:12:46.170]                       if (!is.null(pattern)) {
[16:12:46.170]                         computeRestarts <- base::computeRestarts
[16:12:46.170]                         grepl <- base::grepl
[16:12:46.170]                         restarts <- computeRestarts(cond)
[16:12:46.170]                         for (restart in restarts) {
[16:12:46.170]                           name <- restart$name
[16:12:46.170]                           if (is.null(name)) 
[16:12:46.170]                             next
[16:12:46.170]                           if (!grepl(pattern, name)) 
[16:12:46.170]                             next
[16:12:46.170]                           invokeRestart(restart)
[16:12:46.170]                           muffled <- TRUE
[16:12:46.170]                           break
[16:12:46.170]                         }
[16:12:46.170]                       }
[16:12:46.170]                     }
[16:12:46.170]                     invisible(muffled)
[16:12:46.170]                   }
[16:12:46.170]                   muffleCondition(cond)
[16:12:46.170]                 })
[16:12:46.170]             }))
[16:12:46.170]             future::FutureResult(value = ...future.value$value, 
[16:12:46.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.170]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.170]                     ...future.globalenv.names))
[16:12:46.170]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.170]         }, condition = base::local({
[16:12:46.170]             c <- base::c
[16:12:46.170]             inherits <- base::inherits
[16:12:46.170]             invokeRestart <- base::invokeRestart
[16:12:46.170]             length <- base::length
[16:12:46.170]             list <- base::list
[16:12:46.170]             seq.int <- base::seq.int
[16:12:46.170]             signalCondition <- base::signalCondition
[16:12:46.170]             sys.calls <- base::sys.calls
[16:12:46.170]             `[[` <- base::`[[`
[16:12:46.170]             `+` <- base::`+`
[16:12:46.170]             `<<-` <- base::`<<-`
[16:12:46.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.170]                   3L)]
[16:12:46.170]             }
[16:12:46.170]             function(cond) {
[16:12:46.170]                 is_error <- inherits(cond, "error")
[16:12:46.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.170]                   NULL)
[16:12:46.170]                 if (is_error) {
[16:12:46.170]                   sessionInformation <- function() {
[16:12:46.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.170]                       search = base::search(), system = base::Sys.info())
[16:12:46.170]                   }
[16:12:46.170]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.170]                     cond$call), session = sessionInformation(), 
[16:12:46.170]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.170]                   signalCondition(cond)
[16:12:46.170]                 }
[16:12:46.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.170]                 "immediateCondition"))) {
[16:12:46.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.170]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.170]                   if (TRUE && !signal) {
[16:12:46.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.170]                     {
[16:12:46.170]                       inherits <- base::inherits
[16:12:46.170]                       invokeRestart <- base::invokeRestart
[16:12:46.170]                       is.null <- base::is.null
[16:12:46.170]                       muffled <- FALSE
[16:12:46.170]                       if (inherits(cond, "message")) {
[16:12:46.170]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.170]                         if (muffled) 
[16:12:46.170]                           invokeRestart("muffleMessage")
[16:12:46.170]                       }
[16:12:46.170]                       else if (inherits(cond, "warning")) {
[16:12:46.170]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.170]                         if (muffled) 
[16:12:46.170]                           invokeRestart("muffleWarning")
[16:12:46.170]                       }
[16:12:46.170]                       else if (inherits(cond, "condition")) {
[16:12:46.170]                         if (!is.null(pattern)) {
[16:12:46.170]                           computeRestarts <- base::computeRestarts
[16:12:46.170]                           grepl <- base::grepl
[16:12:46.170]                           restarts <- computeRestarts(cond)
[16:12:46.170]                           for (restart in restarts) {
[16:12:46.170]                             name <- restart$name
[16:12:46.170]                             if (is.null(name)) 
[16:12:46.170]                               next
[16:12:46.170]                             if (!grepl(pattern, name)) 
[16:12:46.170]                               next
[16:12:46.170]                             invokeRestart(restart)
[16:12:46.170]                             muffled <- TRUE
[16:12:46.170]                             break
[16:12:46.170]                           }
[16:12:46.170]                         }
[16:12:46.170]                       }
[16:12:46.170]                       invisible(muffled)
[16:12:46.170]                     }
[16:12:46.170]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.170]                   }
[16:12:46.170]                 }
[16:12:46.170]                 else {
[16:12:46.170]                   if (TRUE) {
[16:12:46.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.170]                     {
[16:12:46.170]                       inherits <- base::inherits
[16:12:46.170]                       invokeRestart <- base::invokeRestart
[16:12:46.170]                       is.null <- base::is.null
[16:12:46.170]                       muffled <- FALSE
[16:12:46.170]                       if (inherits(cond, "message")) {
[16:12:46.170]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.170]                         if (muffled) 
[16:12:46.170]                           invokeRestart("muffleMessage")
[16:12:46.170]                       }
[16:12:46.170]                       else if (inherits(cond, "warning")) {
[16:12:46.170]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.170]                         if (muffled) 
[16:12:46.170]                           invokeRestart("muffleWarning")
[16:12:46.170]                       }
[16:12:46.170]                       else if (inherits(cond, "condition")) {
[16:12:46.170]                         if (!is.null(pattern)) {
[16:12:46.170]                           computeRestarts <- base::computeRestarts
[16:12:46.170]                           grepl <- base::grepl
[16:12:46.170]                           restarts <- computeRestarts(cond)
[16:12:46.170]                           for (restart in restarts) {
[16:12:46.170]                             name <- restart$name
[16:12:46.170]                             if (is.null(name)) 
[16:12:46.170]                               next
[16:12:46.170]                             if (!grepl(pattern, name)) 
[16:12:46.170]                               next
[16:12:46.170]                             invokeRestart(restart)
[16:12:46.170]                             muffled <- TRUE
[16:12:46.170]                             break
[16:12:46.170]                           }
[16:12:46.170]                         }
[16:12:46.170]                       }
[16:12:46.170]                       invisible(muffled)
[16:12:46.170]                     }
[16:12:46.170]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.170]                   }
[16:12:46.170]                 }
[16:12:46.170]             }
[16:12:46.170]         }))
[16:12:46.170]     }, error = function(ex) {
[16:12:46.170]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.170]                 ...future.rng), started = ...future.startTime, 
[16:12:46.170]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.170]             version = "1.8"), class = "FutureResult")
[16:12:46.170]     }, finally = {
[16:12:46.170]         if (!identical(...future.workdir, getwd())) 
[16:12:46.170]             setwd(...future.workdir)
[16:12:46.170]         {
[16:12:46.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.170]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.170]             }
[16:12:46.170]             base::options(...future.oldOptions)
[16:12:46.170]             if (.Platform$OS.type == "windows") {
[16:12:46.170]                 old_names <- names(...future.oldEnvVars)
[16:12:46.170]                 envs <- base::Sys.getenv()
[16:12:46.170]                 names <- names(envs)
[16:12:46.170]                 common <- intersect(names, old_names)
[16:12:46.170]                 added <- setdiff(names, old_names)
[16:12:46.170]                 removed <- setdiff(old_names, names)
[16:12:46.170]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.170]                   envs[common]]
[16:12:46.170]                 NAMES <- toupper(changed)
[16:12:46.170]                 args <- list()
[16:12:46.170]                 for (kk in seq_along(NAMES)) {
[16:12:46.170]                   name <- changed[[kk]]
[16:12:46.170]                   NAME <- NAMES[[kk]]
[16:12:46.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.170]                     next
[16:12:46.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.170]                 }
[16:12:46.170]                 NAMES <- toupper(added)
[16:12:46.170]                 for (kk in seq_along(NAMES)) {
[16:12:46.170]                   name <- added[[kk]]
[16:12:46.170]                   NAME <- NAMES[[kk]]
[16:12:46.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.170]                     next
[16:12:46.170]                   args[[name]] <- ""
[16:12:46.170]                 }
[16:12:46.170]                 NAMES <- toupper(removed)
[16:12:46.170]                 for (kk in seq_along(NAMES)) {
[16:12:46.170]                   name <- removed[[kk]]
[16:12:46.170]                   NAME <- NAMES[[kk]]
[16:12:46.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.170]                     next
[16:12:46.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.170]                 }
[16:12:46.170]                 if (length(args) > 0) 
[16:12:46.170]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.170]             }
[16:12:46.170]             else {
[16:12:46.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.170]             }
[16:12:46.170]             {
[16:12:46.170]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.170]                   0L) {
[16:12:46.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.170]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.170]                   base::options(opts)
[16:12:46.170]                 }
[16:12:46.170]                 {
[16:12:46.170]                   {
[16:12:46.170]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.170]                     NULL
[16:12:46.170]                   }
[16:12:46.170]                   options(future.plan = NULL)
[16:12:46.170]                   if (is.na(NA_character_)) 
[16:12:46.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.170]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.170]                     envir = parent.frame()) 
[16:12:46.170]                   {
[16:12:46.170]                     default_workers <- missing(workers)
[16:12:46.170]                     if (is.function(workers)) 
[16:12:46.170]                       workers <- workers()
[16:12:46.170]                     workers <- structure(as.integer(workers), 
[16:12:46.170]                       class = class(workers))
[16:12:46.170]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.170]                       1L)
[16:12:46.170]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.170]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.170]                       if (default_workers) 
[16:12:46.170]                         supportsMulticore(warn = TRUE)
[16:12:46.170]                       return(sequential(..., envir = envir))
[16:12:46.170]                     }
[16:12:46.170]                     oopts <- options(mc.cores = workers)
[16:12:46.170]                     on.exit(options(oopts))
[16:12:46.170]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.170]                       envir = envir)
[16:12:46.170]                     if (!future$lazy) 
[16:12:46.170]                       future <- run(future)
[16:12:46.170]                     invisible(future)
[16:12:46.170]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.170]                 }
[16:12:46.170]             }
[16:12:46.170]         }
[16:12:46.170]     })
[16:12:46.170]     if (TRUE) {
[16:12:46.170]         base::sink(type = "output", split = FALSE)
[16:12:46.170]         if (TRUE) {
[16:12:46.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.170]         }
[16:12:46.170]         else {
[16:12:46.170]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.170]         }
[16:12:46.170]         base::close(...future.stdout)
[16:12:46.170]         ...future.stdout <- NULL
[16:12:46.170]     }
[16:12:46.170]     ...future.result$conditions <- ...future.conditions
[16:12:46.170]     ...future.result$finished <- base::Sys.time()
[16:12:46.170]     ...future.result
[16:12:46.170] }
[16:12:46.173] requestCore(): workers = 2
[16:12:46.174] MulticoreFuture started
[16:12:46.175] - Launch lazy future ... done
[16:12:46.175] run() for ‘MulticoreFuture’ ... done
[16:12:46.176] plan(): Setting new future strategy stack:
[16:12:46.176] List of future strategies:
[16:12:46.176] 1. sequential:
[16:12:46.176]    - args: function (..., envir = parent.frame())
[16:12:46.176]    - tweaked: FALSE
[16:12:46.176]    - call: NULL
[16:12:46.177] plan(): nbrOfWorkers() = 1
[16:12:46.179] plan(): Setting new future strategy stack:
[16:12:46.179] List of future strategies:
[16:12:46.179] 1. multicore:
[16:12:46.179]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.179]    - tweaked: FALSE
[16:12:46.179]    - call: plan(strategy)
[16:12:46.183] plan(): nbrOfWorkers() = 2
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.185] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.185] Searching for globals...
[16:12:46.188] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:46.188] Searching for globals ... DONE
[16:12:46.189] Resolving globals: TRUE
[16:12:46.189] Resolving any globals that are futures ...
[16:12:46.189] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:46.189] Resolving any globals that are futures ... DONE
[16:12:46.189] Resolving futures part of globals (recursively) ...
[16:12:46.190] resolve() on list ...
[16:12:46.190]  recursive: 99
[16:12:46.190]  length: 1
[16:12:46.190]  elements: ‘x’
[16:12:46.190]  length: 0 (resolved future 1)
[16:12:46.190] resolve() on list ... DONE
[16:12:46.190] - globals: [1] ‘x’
[16:12:46.191] Resolving futures part of globals (recursively) ... DONE
[16:12:46.191] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:46.191] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:46.191] - globals: [1] ‘x’
[16:12:46.191] 
[16:12:46.192] getGlobalsAndPackages() ... DONE
[16:12:46.192] run() for ‘Future’ ...
[16:12:46.192] - state: ‘created’
[16:12:46.192] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.196] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.196] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.196]   - Field: ‘label’
[16:12:46.197]   - Field: ‘local’
[16:12:46.197]   - Field: ‘owner’
[16:12:46.197]   - Field: ‘envir’
[16:12:46.197]   - Field: ‘workers’
[16:12:46.197]   - Field: ‘packages’
[16:12:46.197]   - Field: ‘gc’
[16:12:46.197]   - Field: ‘job’
[16:12:46.197]   - Field: ‘conditions’
[16:12:46.198]   - Field: ‘expr’
[16:12:46.198]   - Field: ‘uuid’
[16:12:46.198]   - Field: ‘seed’
[16:12:46.198]   - Field: ‘version’
[16:12:46.198]   - Field: ‘result’
[16:12:46.198]   - Field: ‘asynchronous’
[16:12:46.198]   - Field: ‘calls’
[16:12:46.198]   - Field: ‘globals’
[16:12:46.198]   - Field: ‘stdout’
[16:12:46.199]   - Field: ‘earlySignal’
[16:12:46.199]   - Field: ‘lazy’
[16:12:46.199]   - Field: ‘state’
[16:12:46.199] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.199] - Launch lazy future ...
[16:12:46.199] Packages needed by the future expression (n = 0): <none>
[16:12:46.199] Packages needed by future strategies (n = 0): <none>
[16:12:46.200] {
[16:12:46.200]     {
[16:12:46.200]         {
[16:12:46.200]             ...future.startTime <- base::Sys.time()
[16:12:46.200]             {
[16:12:46.200]                 {
[16:12:46.200]                   {
[16:12:46.200]                     {
[16:12:46.200]                       base::local({
[16:12:46.200]                         has_future <- base::requireNamespace("future", 
[16:12:46.200]                           quietly = TRUE)
[16:12:46.200]                         if (has_future) {
[16:12:46.200]                           ns <- base::getNamespace("future")
[16:12:46.200]                           version <- ns[[".package"]][["version"]]
[16:12:46.200]                           if (is.null(version)) 
[16:12:46.200]                             version <- utils::packageVersion("future")
[16:12:46.200]                         }
[16:12:46.200]                         else {
[16:12:46.200]                           version <- NULL
[16:12:46.200]                         }
[16:12:46.200]                         if (!has_future || version < "1.8.0") {
[16:12:46.200]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.200]                             "", base::R.version$version.string), 
[16:12:46.200]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.200]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.200]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.200]                               "release", "version")], collapse = " "), 
[16:12:46.200]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.200]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.200]                             info)
[16:12:46.200]                           info <- base::paste(info, collapse = "; ")
[16:12:46.200]                           if (!has_future) {
[16:12:46.200]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.200]                               info)
[16:12:46.200]                           }
[16:12:46.200]                           else {
[16:12:46.200]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.200]                               info, version)
[16:12:46.200]                           }
[16:12:46.200]                           base::stop(msg)
[16:12:46.200]                         }
[16:12:46.200]                       })
[16:12:46.200]                     }
[16:12:46.200]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.200]                     base::options(mc.cores = 1L)
[16:12:46.200]                   }
[16:12:46.200]                   options(future.plan = NULL)
[16:12:46.200]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.200]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.200]                 }
[16:12:46.200]                 ...future.workdir <- getwd()
[16:12:46.200]             }
[16:12:46.200]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.200]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.200]         }
[16:12:46.200]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.200]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.200]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.200]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.200]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.200]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.200]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.200]             base::names(...future.oldOptions))
[16:12:46.200]     }
[16:12:46.200]     if (FALSE) {
[16:12:46.200]     }
[16:12:46.200]     else {
[16:12:46.200]         if (TRUE) {
[16:12:46.200]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.200]                 open = "w")
[16:12:46.200]         }
[16:12:46.200]         else {
[16:12:46.200]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.200]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.200]         }
[16:12:46.200]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.200]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.200]             base::sink(type = "output", split = FALSE)
[16:12:46.200]             base::close(...future.stdout)
[16:12:46.200]         }, add = TRUE)
[16:12:46.200]     }
[16:12:46.200]     ...future.frame <- base::sys.nframe()
[16:12:46.200]     ...future.conditions <- base::list()
[16:12:46.200]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.200]     if (FALSE) {
[16:12:46.200]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.200]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.200]     }
[16:12:46.200]     ...future.result <- base::tryCatch({
[16:12:46.200]         base::withCallingHandlers({
[16:12:46.200]             ...future.value <- base::withVisible(base::local({
[16:12:46.200]                 withCallingHandlers({
[16:12:46.200]                   {
[16:12:46.200]                     x[["a"]] <- 1
[16:12:46.200]                     x
[16:12:46.200]                   }
[16:12:46.200]                 }, immediateCondition = function(cond) {
[16:12:46.200]                   save_rds <- function (object, pathname, ...) 
[16:12:46.200]                   {
[16:12:46.200]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.200]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.200]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.200]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.200]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.200]                         fi_tmp[["mtime"]])
[16:12:46.200]                     }
[16:12:46.200]                     tryCatch({
[16:12:46.200]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.200]                     }, error = function(ex) {
[16:12:46.200]                       msg <- conditionMessage(ex)
[16:12:46.200]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.200]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.200]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.200]                         fi_tmp[["mtime"]], msg)
[16:12:46.200]                       ex$message <- msg
[16:12:46.200]                       stop(ex)
[16:12:46.200]                     })
[16:12:46.200]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.200]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.200]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.200]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.200]                       fi <- file.info(pathname)
[16:12:46.200]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.200]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.200]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.200]                         fi[["size"]], fi[["mtime"]])
[16:12:46.200]                       stop(msg)
[16:12:46.200]                     }
[16:12:46.200]                     invisible(pathname)
[16:12:46.200]                   }
[16:12:46.200]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.200]                     rootPath = tempdir()) 
[16:12:46.200]                   {
[16:12:46.200]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.200]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.200]                       tmpdir = path, fileext = ".rds")
[16:12:46.200]                     save_rds(obj, file)
[16:12:46.200]                   }
[16:12:46.200]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.200]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.200]                   {
[16:12:46.200]                     inherits <- base::inherits
[16:12:46.200]                     invokeRestart <- base::invokeRestart
[16:12:46.200]                     is.null <- base::is.null
[16:12:46.200]                     muffled <- FALSE
[16:12:46.200]                     if (inherits(cond, "message")) {
[16:12:46.200]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.200]                       if (muffled) 
[16:12:46.200]                         invokeRestart("muffleMessage")
[16:12:46.200]                     }
[16:12:46.200]                     else if (inherits(cond, "warning")) {
[16:12:46.200]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.200]                       if (muffled) 
[16:12:46.200]                         invokeRestart("muffleWarning")
[16:12:46.200]                     }
[16:12:46.200]                     else if (inherits(cond, "condition")) {
[16:12:46.200]                       if (!is.null(pattern)) {
[16:12:46.200]                         computeRestarts <- base::computeRestarts
[16:12:46.200]                         grepl <- base::grepl
[16:12:46.200]                         restarts <- computeRestarts(cond)
[16:12:46.200]                         for (restart in restarts) {
[16:12:46.200]                           name <- restart$name
[16:12:46.200]                           if (is.null(name)) 
[16:12:46.200]                             next
[16:12:46.200]                           if (!grepl(pattern, name)) 
[16:12:46.200]                             next
[16:12:46.200]                           invokeRestart(restart)
[16:12:46.200]                           muffled <- TRUE
[16:12:46.200]                           break
[16:12:46.200]                         }
[16:12:46.200]                       }
[16:12:46.200]                     }
[16:12:46.200]                     invisible(muffled)
[16:12:46.200]                   }
[16:12:46.200]                   muffleCondition(cond)
[16:12:46.200]                 })
[16:12:46.200]             }))
[16:12:46.200]             future::FutureResult(value = ...future.value$value, 
[16:12:46.200]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.200]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.200]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.200]                     ...future.globalenv.names))
[16:12:46.200]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.200]         }, condition = base::local({
[16:12:46.200]             c <- base::c
[16:12:46.200]             inherits <- base::inherits
[16:12:46.200]             invokeRestart <- base::invokeRestart
[16:12:46.200]             length <- base::length
[16:12:46.200]             list <- base::list
[16:12:46.200]             seq.int <- base::seq.int
[16:12:46.200]             signalCondition <- base::signalCondition
[16:12:46.200]             sys.calls <- base::sys.calls
[16:12:46.200]             `[[` <- base::`[[`
[16:12:46.200]             `+` <- base::`+`
[16:12:46.200]             `<<-` <- base::`<<-`
[16:12:46.200]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.200]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.200]                   3L)]
[16:12:46.200]             }
[16:12:46.200]             function(cond) {
[16:12:46.200]                 is_error <- inherits(cond, "error")
[16:12:46.200]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.200]                   NULL)
[16:12:46.200]                 if (is_error) {
[16:12:46.200]                   sessionInformation <- function() {
[16:12:46.200]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.200]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.200]                       search = base::search(), system = base::Sys.info())
[16:12:46.200]                   }
[16:12:46.200]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.200]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.200]                     cond$call), session = sessionInformation(), 
[16:12:46.200]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.200]                   signalCondition(cond)
[16:12:46.200]                 }
[16:12:46.200]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.200]                 "immediateCondition"))) {
[16:12:46.200]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.200]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.200]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.200]                   if (TRUE && !signal) {
[16:12:46.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.200]                     {
[16:12:46.200]                       inherits <- base::inherits
[16:12:46.200]                       invokeRestart <- base::invokeRestart
[16:12:46.200]                       is.null <- base::is.null
[16:12:46.200]                       muffled <- FALSE
[16:12:46.200]                       if (inherits(cond, "message")) {
[16:12:46.200]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.200]                         if (muffled) 
[16:12:46.200]                           invokeRestart("muffleMessage")
[16:12:46.200]                       }
[16:12:46.200]                       else if (inherits(cond, "warning")) {
[16:12:46.200]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.200]                         if (muffled) 
[16:12:46.200]                           invokeRestart("muffleWarning")
[16:12:46.200]                       }
[16:12:46.200]                       else if (inherits(cond, "condition")) {
[16:12:46.200]                         if (!is.null(pattern)) {
[16:12:46.200]                           computeRestarts <- base::computeRestarts
[16:12:46.200]                           grepl <- base::grepl
[16:12:46.200]                           restarts <- computeRestarts(cond)
[16:12:46.200]                           for (restart in restarts) {
[16:12:46.200]                             name <- restart$name
[16:12:46.200]                             if (is.null(name)) 
[16:12:46.200]                               next
[16:12:46.200]                             if (!grepl(pattern, name)) 
[16:12:46.200]                               next
[16:12:46.200]                             invokeRestart(restart)
[16:12:46.200]                             muffled <- TRUE
[16:12:46.200]                             break
[16:12:46.200]                           }
[16:12:46.200]                         }
[16:12:46.200]                       }
[16:12:46.200]                       invisible(muffled)
[16:12:46.200]                     }
[16:12:46.200]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.200]                   }
[16:12:46.200]                 }
[16:12:46.200]                 else {
[16:12:46.200]                   if (TRUE) {
[16:12:46.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.200]                     {
[16:12:46.200]                       inherits <- base::inherits
[16:12:46.200]                       invokeRestart <- base::invokeRestart
[16:12:46.200]                       is.null <- base::is.null
[16:12:46.200]                       muffled <- FALSE
[16:12:46.200]                       if (inherits(cond, "message")) {
[16:12:46.200]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.200]                         if (muffled) 
[16:12:46.200]                           invokeRestart("muffleMessage")
[16:12:46.200]                       }
[16:12:46.200]                       else if (inherits(cond, "warning")) {
[16:12:46.200]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.200]                         if (muffled) 
[16:12:46.200]                           invokeRestart("muffleWarning")
[16:12:46.200]                       }
[16:12:46.200]                       else if (inherits(cond, "condition")) {
[16:12:46.200]                         if (!is.null(pattern)) {
[16:12:46.200]                           computeRestarts <- base::computeRestarts
[16:12:46.200]                           grepl <- base::grepl
[16:12:46.200]                           restarts <- computeRestarts(cond)
[16:12:46.200]                           for (restart in restarts) {
[16:12:46.200]                             name <- restart$name
[16:12:46.200]                             if (is.null(name)) 
[16:12:46.200]                               next
[16:12:46.200]                             if (!grepl(pattern, name)) 
[16:12:46.200]                               next
[16:12:46.200]                             invokeRestart(restart)
[16:12:46.200]                             muffled <- TRUE
[16:12:46.200]                             break
[16:12:46.200]                           }
[16:12:46.200]                         }
[16:12:46.200]                       }
[16:12:46.200]                       invisible(muffled)
[16:12:46.200]                     }
[16:12:46.200]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.200]                   }
[16:12:46.200]                 }
[16:12:46.200]             }
[16:12:46.200]         }))
[16:12:46.200]     }, error = function(ex) {
[16:12:46.200]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.200]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.200]                 ...future.rng), started = ...future.startTime, 
[16:12:46.200]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.200]             version = "1.8"), class = "FutureResult")
[16:12:46.200]     }, finally = {
[16:12:46.200]         if (!identical(...future.workdir, getwd())) 
[16:12:46.200]             setwd(...future.workdir)
[16:12:46.200]         {
[16:12:46.200]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.200]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.200]             }
[16:12:46.200]             base::options(...future.oldOptions)
[16:12:46.200]             if (.Platform$OS.type == "windows") {
[16:12:46.200]                 old_names <- names(...future.oldEnvVars)
[16:12:46.200]                 envs <- base::Sys.getenv()
[16:12:46.200]                 names <- names(envs)
[16:12:46.200]                 common <- intersect(names, old_names)
[16:12:46.200]                 added <- setdiff(names, old_names)
[16:12:46.200]                 removed <- setdiff(old_names, names)
[16:12:46.200]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.200]                   envs[common]]
[16:12:46.200]                 NAMES <- toupper(changed)
[16:12:46.200]                 args <- list()
[16:12:46.200]                 for (kk in seq_along(NAMES)) {
[16:12:46.200]                   name <- changed[[kk]]
[16:12:46.200]                   NAME <- NAMES[[kk]]
[16:12:46.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.200]                     next
[16:12:46.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.200]                 }
[16:12:46.200]                 NAMES <- toupper(added)
[16:12:46.200]                 for (kk in seq_along(NAMES)) {
[16:12:46.200]                   name <- added[[kk]]
[16:12:46.200]                   NAME <- NAMES[[kk]]
[16:12:46.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.200]                     next
[16:12:46.200]                   args[[name]] <- ""
[16:12:46.200]                 }
[16:12:46.200]                 NAMES <- toupper(removed)
[16:12:46.200]                 for (kk in seq_along(NAMES)) {
[16:12:46.200]                   name <- removed[[kk]]
[16:12:46.200]                   NAME <- NAMES[[kk]]
[16:12:46.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.200]                     next
[16:12:46.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.200]                 }
[16:12:46.200]                 if (length(args) > 0) 
[16:12:46.200]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.200]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.200]             }
[16:12:46.200]             else {
[16:12:46.200]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.200]             }
[16:12:46.200]             {
[16:12:46.200]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.200]                   0L) {
[16:12:46.200]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.200]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.200]                   base::options(opts)
[16:12:46.200]                 }
[16:12:46.200]                 {
[16:12:46.200]                   {
[16:12:46.200]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.200]                     NULL
[16:12:46.200]                   }
[16:12:46.200]                   options(future.plan = NULL)
[16:12:46.200]                   if (is.na(NA_character_)) 
[16:12:46.200]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.200]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.200]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.200]                     envir = parent.frame()) 
[16:12:46.200]                   {
[16:12:46.200]                     default_workers <- missing(workers)
[16:12:46.200]                     if (is.function(workers)) 
[16:12:46.200]                       workers <- workers()
[16:12:46.200]                     workers <- structure(as.integer(workers), 
[16:12:46.200]                       class = class(workers))
[16:12:46.200]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.200]                       1L)
[16:12:46.200]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.200]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.200]                       if (default_workers) 
[16:12:46.200]                         supportsMulticore(warn = TRUE)
[16:12:46.200]                       return(sequential(..., envir = envir))
[16:12:46.200]                     }
[16:12:46.200]                     oopts <- options(mc.cores = workers)
[16:12:46.200]                     on.exit(options(oopts))
[16:12:46.200]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.200]                       envir = envir)
[16:12:46.200]                     if (!future$lazy) 
[16:12:46.200]                       future <- run(future)
[16:12:46.200]                     invisible(future)
[16:12:46.200]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.200]                 }
[16:12:46.200]             }
[16:12:46.200]         }
[16:12:46.200]     })
[16:12:46.200]     if (TRUE) {
[16:12:46.200]         base::sink(type = "output", split = FALSE)
[16:12:46.200]         if (TRUE) {
[16:12:46.200]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.200]         }
[16:12:46.200]         else {
[16:12:46.200]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.200]         }
[16:12:46.200]         base::close(...future.stdout)
[16:12:46.200]         ...future.stdout <- NULL
[16:12:46.200]     }
[16:12:46.200]     ...future.result$conditions <- ...future.conditions
[16:12:46.200]     ...future.result$finished <- base::Sys.time()
[16:12:46.200]     ...future.result
[16:12:46.200] }
[16:12:46.203] assign_globals() ...
[16:12:46.203] List of 1
[16:12:46.203]  $ x: list()
[16:12:46.203]  - attr(*, "where")=List of 1
[16:12:46.203]   ..$ x:<environment: R_EmptyEnv> 
[16:12:46.203]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:46.203]  - attr(*, "resolved")= logi TRUE
[16:12:46.203]  - attr(*, "total_size")= num 0
[16:12:46.203]  - attr(*, "already-done")= logi TRUE
[16:12:46.206] - copied ‘x’ to environment
[16:12:46.206] assign_globals() ... done
[16:12:46.206] requestCore(): workers = 2
[16:12:46.208] MulticoreFuture started
[16:12:46.212] - Launch lazy future ... done
[16:12:46.213] run() for ‘MulticoreFuture’ ... done
[16:12:46.213] plan(): Setting new future strategy stack:
[16:12:46.213] List of future strategies:
[16:12:46.213] 1. sequential:
[16:12:46.213]    - args: function (..., envir = parent.frame())
[16:12:46.213]    - tweaked: FALSE
[16:12:46.213]    - call: NULL
[16:12:46.214] plan(): nbrOfWorkers() = 1
[16:12:46.216] plan(): Setting new future strategy stack:
[16:12:46.216] List of future strategies:
[16:12:46.216] 1. multicore:
[16:12:46.216]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.216]    - tweaked: FALSE
[16:12:46.216]    - call: plan(strategy)
[16:12:46.221] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.223] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.223] Searching for globals...
[16:12:46.227] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:46.227] Searching for globals ... DONE
[16:12:46.227] Resolving globals: TRUE
[16:12:46.227] Resolving any globals that are futures ...
[16:12:46.228] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:46.228] Resolving any globals that are futures ... DONE
[16:12:46.228] Resolving futures part of globals (recursively) ...
[16:12:46.228] resolve() on list ...
[16:12:46.229]  recursive: 99
[16:12:46.229]  length: 1
[16:12:46.229]  elements: ‘x’
[16:12:46.229]  length: 0 (resolved future 1)
[16:12:46.229] resolve() on list ... DONE
[16:12:46.229] - globals: [1] ‘x’
[16:12:46.229] Resolving futures part of globals (recursively) ... DONE
[16:12:46.230] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:46.230] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:46.230] - globals: [1] ‘x’
[16:12:46.230] 
[16:12:46.230] getGlobalsAndPackages() ... DONE
[16:12:46.231] run() for ‘Future’ ...
[16:12:46.231] - state: ‘created’
[16:12:46.231] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.235] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.235] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.235]   - Field: ‘label’
[16:12:46.235]   - Field: ‘local’
[16:12:46.235]   - Field: ‘owner’
[16:12:46.235]   - Field: ‘envir’
[16:12:46.236]   - Field: ‘workers’
[16:12:46.236]   - Field: ‘packages’
[16:12:46.236]   - Field: ‘gc’
[16:12:46.236]   - Field: ‘job’
[16:12:46.236]   - Field: ‘conditions’
[16:12:46.236]   - Field: ‘expr’
[16:12:46.236]   - Field: ‘uuid’
[16:12:46.236]   - Field: ‘seed’
[16:12:46.237]   - Field: ‘version’
[16:12:46.237]   - Field: ‘result’
[16:12:46.237]   - Field: ‘asynchronous’
[16:12:46.237]   - Field: ‘calls’
[16:12:46.237]   - Field: ‘globals’
[16:12:46.237]   - Field: ‘stdout’
[16:12:46.237]   - Field: ‘earlySignal’
[16:12:46.237]   - Field: ‘lazy’
[16:12:46.237]   - Field: ‘state’
[16:12:46.238] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.238] - Launch lazy future ...
[16:12:46.238] Packages needed by the future expression (n = 0): <none>
[16:12:46.238] Packages needed by future strategies (n = 0): <none>
[16:12:46.239] {
[16:12:46.239]     {
[16:12:46.239]         {
[16:12:46.239]             ...future.startTime <- base::Sys.time()
[16:12:46.239]             {
[16:12:46.239]                 {
[16:12:46.239]                   {
[16:12:46.239]                     {
[16:12:46.239]                       base::local({
[16:12:46.239]                         has_future <- base::requireNamespace("future", 
[16:12:46.239]                           quietly = TRUE)
[16:12:46.239]                         if (has_future) {
[16:12:46.239]                           ns <- base::getNamespace("future")
[16:12:46.239]                           version <- ns[[".package"]][["version"]]
[16:12:46.239]                           if (is.null(version)) 
[16:12:46.239]                             version <- utils::packageVersion("future")
[16:12:46.239]                         }
[16:12:46.239]                         else {
[16:12:46.239]                           version <- NULL
[16:12:46.239]                         }
[16:12:46.239]                         if (!has_future || version < "1.8.0") {
[16:12:46.239]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.239]                             "", base::R.version$version.string), 
[16:12:46.239]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.239]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.239]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.239]                               "release", "version")], collapse = " "), 
[16:12:46.239]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.239]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.239]                             info)
[16:12:46.239]                           info <- base::paste(info, collapse = "; ")
[16:12:46.239]                           if (!has_future) {
[16:12:46.239]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.239]                               info)
[16:12:46.239]                           }
[16:12:46.239]                           else {
[16:12:46.239]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.239]                               info, version)
[16:12:46.239]                           }
[16:12:46.239]                           base::stop(msg)
[16:12:46.239]                         }
[16:12:46.239]                       })
[16:12:46.239]                     }
[16:12:46.239]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.239]                     base::options(mc.cores = 1L)
[16:12:46.239]                   }
[16:12:46.239]                   options(future.plan = NULL)
[16:12:46.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.239]                 }
[16:12:46.239]                 ...future.workdir <- getwd()
[16:12:46.239]             }
[16:12:46.239]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.239]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.239]         }
[16:12:46.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.239]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.239]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.239]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.239]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.239]             base::names(...future.oldOptions))
[16:12:46.239]     }
[16:12:46.239]     if (FALSE) {
[16:12:46.239]     }
[16:12:46.239]     else {
[16:12:46.239]         if (TRUE) {
[16:12:46.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.239]                 open = "w")
[16:12:46.239]         }
[16:12:46.239]         else {
[16:12:46.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.239]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.239]         }
[16:12:46.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.239]             base::sink(type = "output", split = FALSE)
[16:12:46.239]             base::close(...future.stdout)
[16:12:46.239]         }, add = TRUE)
[16:12:46.239]     }
[16:12:46.239]     ...future.frame <- base::sys.nframe()
[16:12:46.239]     ...future.conditions <- base::list()
[16:12:46.239]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.239]     if (FALSE) {
[16:12:46.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.239]     }
[16:12:46.239]     ...future.result <- base::tryCatch({
[16:12:46.239]         base::withCallingHandlers({
[16:12:46.239]             ...future.value <- base::withVisible(base::local({
[16:12:46.239]                 withCallingHandlers({
[16:12:46.239]                   {
[16:12:46.239]                     x[["a"]] <- 1
[16:12:46.239]                     x
[16:12:46.239]                   }
[16:12:46.239]                 }, immediateCondition = function(cond) {
[16:12:46.239]                   save_rds <- function (object, pathname, ...) 
[16:12:46.239]                   {
[16:12:46.239]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.239]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.239]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.239]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.239]                         fi_tmp[["mtime"]])
[16:12:46.239]                     }
[16:12:46.239]                     tryCatch({
[16:12:46.239]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.239]                     }, error = function(ex) {
[16:12:46.239]                       msg <- conditionMessage(ex)
[16:12:46.239]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.239]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.239]                         fi_tmp[["mtime"]], msg)
[16:12:46.239]                       ex$message <- msg
[16:12:46.239]                       stop(ex)
[16:12:46.239]                     })
[16:12:46.239]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.239]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.239]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.239]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.239]                       fi <- file.info(pathname)
[16:12:46.239]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.239]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.239]                         fi[["size"]], fi[["mtime"]])
[16:12:46.239]                       stop(msg)
[16:12:46.239]                     }
[16:12:46.239]                     invisible(pathname)
[16:12:46.239]                   }
[16:12:46.239]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.239]                     rootPath = tempdir()) 
[16:12:46.239]                   {
[16:12:46.239]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.239]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.239]                       tmpdir = path, fileext = ".rds")
[16:12:46.239]                     save_rds(obj, file)
[16:12:46.239]                   }
[16:12:46.239]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.239]                   {
[16:12:46.239]                     inherits <- base::inherits
[16:12:46.239]                     invokeRestart <- base::invokeRestart
[16:12:46.239]                     is.null <- base::is.null
[16:12:46.239]                     muffled <- FALSE
[16:12:46.239]                     if (inherits(cond, "message")) {
[16:12:46.239]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.239]                       if (muffled) 
[16:12:46.239]                         invokeRestart("muffleMessage")
[16:12:46.239]                     }
[16:12:46.239]                     else if (inherits(cond, "warning")) {
[16:12:46.239]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.239]                       if (muffled) 
[16:12:46.239]                         invokeRestart("muffleWarning")
[16:12:46.239]                     }
[16:12:46.239]                     else if (inherits(cond, "condition")) {
[16:12:46.239]                       if (!is.null(pattern)) {
[16:12:46.239]                         computeRestarts <- base::computeRestarts
[16:12:46.239]                         grepl <- base::grepl
[16:12:46.239]                         restarts <- computeRestarts(cond)
[16:12:46.239]                         for (restart in restarts) {
[16:12:46.239]                           name <- restart$name
[16:12:46.239]                           if (is.null(name)) 
[16:12:46.239]                             next
[16:12:46.239]                           if (!grepl(pattern, name)) 
[16:12:46.239]                             next
[16:12:46.239]                           invokeRestart(restart)
[16:12:46.239]                           muffled <- TRUE
[16:12:46.239]                           break
[16:12:46.239]                         }
[16:12:46.239]                       }
[16:12:46.239]                     }
[16:12:46.239]                     invisible(muffled)
[16:12:46.239]                   }
[16:12:46.239]                   muffleCondition(cond)
[16:12:46.239]                 })
[16:12:46.239]             }))
[16:12:46.239]             future::FutureResult(value = ...future.value$value, 
[16:12:46.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.239]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.239]                     ...future.globalenv.names))
[16:12:46.239]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.239]         }, condition = base::local({
[16:12:46.239]             c <- base::c
[16:12:46.239]             inherits <- base::inherits
[16:12:46.239]             invokeRestart <- base::invokeRestart
[16:12:46.239]             length <- base::length
[16:12:46.239]             list <- base::list
[16:12:46.239]             seq.int <- base::seq.int
[16:12:46.239]             signalCondition <- base::signalCondition
[16:12:46.239]             sys.calls <- base::sys.calls
[16:12:46.239]             `[[` <- base::`[[`
[16:12:46.239]             `+` <- base::`+`
[16:12:46.239]             `<<-` <- base::`<<-`
[16:12:46.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.239]                   3L)]
[16:12:46.239]             }
[16:12:46.239]             function(cond) {
[16:12:46.239]                 is_error <- inherits(cond, "error")
[16:12:46.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.239]                   NULL)
[16:12:46.239]                 if (is_error) {
[16:12:46.239]                   sessionInformation <- function() {
[16:12:46.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.239]                       search = base::search(), system = base::Sys.info())
[16:12:46.239]                   }
[16:12:46.239]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.239]                     cond$call), session = sessionInformation(), 
[16:12:46.239]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.239]                   signalCondition(cond)
[16:12:46.239]                 }
[16:12:46.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.239]                 "immediateCondition"))) {
[16:12:46.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.239]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.239]                   if (TRUE && !signal) {
[16:12:46.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.239]                     {
[16:12:46.239]                       inherits <- base::inherits
[16:12:46.239]                       invokeRestart <- base::invokeRestart
[16:12:46.239]                       is.null <- base::is.null
[16:12:46.239]                       muffled <- FALSE
[16:12:46.239]                       if (inherits(cond, "message")) {
[16:12:46.239]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.239]                         if (muffled) 
[16:12:46.239]                           invokeRestart("muffleMessage")
[16:12:46.239]                       }
[16:12:46.239]                       else if (inherits(cond, "warning")) {
[16:12:46.239]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.239]                         if (muffled) 
[16:12:46.239]                           invokeRestart("muffleWarning")
[16:12:46.239]                       }
[16:12:46.239]                       else if (inherits(cond, "condition")) {
[16:12:46.239]                         if (!is.null(pattern)) {
[16:12:46.239]                           computeRestarts <- base::computeRestarts
[16:12:46.239]                           grepl <- base::grepl
[16:12:46.239]                           restarts <- computeRestarts(cond)
[16:12:46.239]                           for (restart in restarts) {
[16:12:46.239]                             name <- restart$name
[16:12:46.239]                             if (is.null(name)) 
[16:12:46.239]                               next
[16:12:46.239]                             if (!grepl(pattern, name)) 
[16:12:46.239]                               next
[16:12:46.239]                             invokeRestart(restart)
[16:12:46.239]                             muffled <- TRUE
[16:12:46.239]                             break
[16:12:46.239]                           }
[16:12:46.239]                         }
[16:12:46.239]                       }
[16:12:46.239]                       invisible(muffled)
[16:12:46.239]                     }
[16:12:46.239]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.239]                   }
[16:12:46.239]                 }
[16:12:46.239]                 else {
[16:12:46.239]                   if (TRUE) {
[16:12:46.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.239]                     {
[16:12:46.239]                       inherits <- base::inherits
[16:12:46.239]                       invokeRestart <- base::invokeRestart
[16:12:46.239]                       is.null <- base::is.null
[16:12:46.239]                       muffled <- FALSE
[16:12:46.239]                       if (inherits(cond, "message")) {
[16:12:46.239]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.239]                         if (muffled) 
[16:12:46.239]                           invokeRestart("muffleMessage")
[16:12:46.239]                       }
[16:12:46.239]                       else if (inherits(cond, "warning")) {
[16:12:46.239]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.239]                         if (muffled) 
[16:12:46.239]                           invokeRestart("muffleWarning")
[16:12:46.239]                       }
[16:12:46.239]                       else if (inherits(cond, "condition")) {
[16:12:46.239]                         if (!is.null(pattern)) {
[16:12:46.239]                           computeRestarts <- base::computeRestarts
[16:12:46.239]                           grepl <- base::grepl
[16:12:46.239]                           restarts <- computeRestarts(cond)
[16:12:46.239]                           for (restart in restarts) {
[16:12:46.239]                             name <- restart$name
[16:12:46.239]                             if (is.null(name)) 
[16:12:46.239]                               next
[16:12:46.239]                             if (!grepl(pattern, name)) 
[16:12:46.239]                               next
[16:12:46.239]                             invokeRestart(restart)
[16:12:46.239]                             muffled <- TRUE
[16:12:46.239]                             break
[16:12:46.239]                           }
[16:12:46.239]                         }
[16:12:46.239]                       }
[16:12:46.239]                       invisible(muffled)
[16:12:46.239]                     }
[16:12:46.239]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.239]                   }
[16:12:46.239]                 }
[16:12:46.239]             }
[16:12:46.239]         }))
[16:12:46.239]     }, error = function(ex) {
[16:12:46.239]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.239]                 ...future.rng), started = ...future.startTime, 
[16:12:46.239]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.239]             version = "1.8"), class = "FutureResult")
[16:12:46.239]     }, finally = {
[16:12:46.239]         if (!identical(...future.workdir, getwd())) 
[16:12:46.239]             setwd(...future.workdir)
[16:12:46.239]         {
[16:12:46.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.239]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.239]             }
[16:12:46.239]             base::options(...future.oldOptions)
[16:12:46.239]             if (.Platform$OS.type == "windows") {
[16:12:46.239]                 old_names <- names(...future.oldEnvVars)
[16:12:46.239]                 envs <- base::Sys.getenv()
[16:12:46.239]                 names <- names(envs)
[16:12:46.239]                 common <- intersect(names, old_names)
[16:12:46.239]                 added <- setdiff(names, old_names)
[16:12:46.239]                 removed <- setdiff(old_names, names)
[16:12:46.239]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.239]                   envs[common]]
[16:12:46.239]                 NAMES <- toupper(changed)
[16:12:46.239]                 args <- list()
[16:12:46.239]                 for (kk in seq_along(NAMES)) {
[16:12:46.239]                   name <- changed[[kk]]
[16:12:46.239]                   NAME <- NAMES[[kk]]
[16:12:46.239]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.239]                     next
[16:12:46.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.239]                 }
[16:12:46.239]                 NAMES <- toupper(added)
[16:12:46.239]                 for (kk in seq_along(NAMES)) {
[16:12:46.239]                   name <- added[[kk]]
[16:12:46.239]                   NAME <- NAMES[[kk]]
[16:12:46.239]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.239]                     next
[16:12:46.239]                   args[[name]] <- ""
[16:12:46.239]                 }
[16:12:46.239]                 NAMES <- toupper(removed)
[16:12:46.239]                 for (kk in seq_along(NAMES)) {
[16:12:46.239]                   name <- removed[[kk]]
[16:12:46.239]                   NAME <- NAMES[[kk]]
[16:12:46.239]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.239]                     next
[16:12:46.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.239]                 }
[16:12:46.239]                 if (length(args) > 0) 
[16:12:46.239]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.239]             }
[16:12:46.239]             else {
[16:12:46.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.239]             }
[16:12:46.239]             {
[16:12:46.239]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.239]                   0L) {
[16:12:46.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.239]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.239]                   base::options(opts)
[16:12:46.239]                 }
[16:12:46.239]                 {
[16:12:46.239]                   {
[16:12:46.239]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.239]                     NULL
[16:12:46.239]                   }
[16:12:46.239]                   options(future.plan = NULL)
[16:12:46.239]                   if (is.na(NA_character_)) 
[16:12:46.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.239]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.239]                     envir = parent.frame()) 
[16:12:46.239]                   {
[16:12:46.239]                     default_workers <- missing(workers)
[16:12:46.239]                     if (is.function(workers)) 
[16:12:46.239]                       workers <- workers()
[16:12:46.239]                     workers <- structure(as.integer(workers), 
[16:12:46.239]                       class = class(workers))
[16:12:46.239]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.239]                       1L)
[16:12:46.239]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.239]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.239]                       if (default_workers) 
[16:12:46.239]                         supportsMulticore(warn = TRUE)
[16:12:46.239]                       return(sequential(..., envir = envir))
[16:12:46.239]                     }
[16:12:46.239]                     oopts <- options(mc.cores = workers)
[16:12:46.239]                     on.exit(options(oopts))
[16:12:46.239]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.239]                       envir = envir)
[16:12:46.239]                     if (!future$lazy) 
[16:12:46.239]                       future <- run(future)
[16:12:46.239]                     invisible(future)
[16:12:46.239]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.239]                 }
[16:12:46.239]             }
[16:12:46.239]         }
[16:12:46.239]     })
[16:12:46.239]     if (TRUE) {
[16:12:46.239]         base::sink(type = "output", split = FALSE)
[16:12:46.239]         if (TRUE) {
[16:12:46.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.239]         }
[16:12:46.239]         else {
[16:12:46.239]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.239]         }
[16:12:46.239]         base::close(...future.stdout)
[16:12:46.239]         ...future.stdout <- NULL
[16:12:46.239]     }
[16:12:46.239]     ...future.result$conditions <- ...future.conditions
[16:12:46.239]     ...future.result$finished <- base::Sys.time()
[16:12:46.239]     ...future.result
[16:12:46.239] }
[16:12:46.241] assign_globals() ...
[16:12:46.241] List of 1
[16:12:46.241]  $ x: list()
[16:12:46.241]  - attr(*, "where")=List of 1
[16:12:46.241]   ..$ x:<environment: R_EmptyEnv> 
[16:12:46.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:46.241]  - attr(*, "resolved")= logi TRUE
[16:12:46.241]  - attr(*, "total_size")= num 0
[16:12:46.241]  - attr(*, "already-done")= logi TRUE
[16:12:46.244] - copied ‘x’ to environment
[16:12:46.244] assign_globals() ... done
[16:12:46.245] requestCore(): workers = 2
[16:12:46.246] MulticoreFuture started
[16:12:46.247] - Launch lazy future ... done
[16:12:46.247] run() for ‘MulticoreFuture’ ... done
[16:12:46.248] plan(): Setting new future strategy stack:
[16:12:46.248] List of future strategies:
[16:12:46.248] 1. sequential:
[16:12:46.248]    - args: function (..., envir = parent.frame())
[16:12:46.248]    - tweaked: FALSE
[16:12:46.248]    - call: NULL
[16:12:46.249] plan(): nbrOfWorkers() = 1
[16:12:46.251] plan(): Setting new future strategy stack:
[16:12:46.251] List of future strategies:
[16:12:46.251] 1. multicore:
[16:12:46.251]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.251]    - tweaked: FALSE
[16:12:46.251]    - call: plan(strategy)
[16:12:46.256] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.258] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.258] Searching for globals...
[16:12:46.261] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:46.261] Searching for globals ... DONE
[16:12:46.261] Resolving globals: TRUE
[16:12:46.261] Resolving any globals that are futures ...
[16:12:46.261] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:46.261] Resolving any globals that are futures ... DONE
[16:12:46.262] Resolving futures part of globals (recursively) ...
[16:12:46.262] resolve() on list ...
[16:12:46.262]  recursive: 99
[16:12:46.262]  length: 1
[16:12:46.262]  elements: ‘x’
[16:12:46.263]  length: 0 (resolved future 1)
[16:12:46.263] resolve() on list ... DONE
[16:12:46.263] - globals: [1] ‘x’
[16:12:46.263] Resolving futures part of globals (recursively) ... DONE
[16:12:46.263] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:46.264] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:46.264] - globals: [1] ‘x’
[16:12:46.264] 
[16:12:46.264] getGlobalsAndPackages() ... DONE
[16:12:46.264] run() for ‘Future’ ...
[16:12:46.264] - state: ‘created’
[16:12:46.265] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.269] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.269] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.269]   - Field: ‘label’
[16:12:46.269]   - Field: ‘local’
[16:12:46.269]   - Field: ‘owner’
[16:12:46.272]   - Field: ‘envir’
[16:12:46.272]   - Field: ‘workers’
[16:12:46.272]   - Field: ‘packages’
[16:12:46.272]   - Field: ‘gc’
[16:12:46.272]   - Field: ‘job’
[16:12:46.272]   - Field: ‘conditions’
[16:12:46.273]   - Field: ‘expr’
[16:12:46.273]   - Field: ‘uuid’
[16:12:46.273]   - Field: ‘seed’
[16:12:46.273]   - Field: ‘version’
[16:12:46.273]   - Field: ‘result’
[16:12:46.273]   - Field: ‘asynchronous’
[16:12:46.273]   - Field: ‘calls’
[16:12:46.274]   - Field: ‘globals’
[16:12:46.274]   - Field: ‘stdout’
[16:12:46.274]   - Field: ‘earlySignal’
[16:12:46.274]   - Field: ‘lazy’
[16:12:46.274]   - Field: ‘state’
[16:12:46.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.274] - Launch lazy future ...
[16:12:46.275] Packages needed by the future expression (n = 0): <none>
[16:12:46.275] Packages needed by future strategies (n = 0): <none>
[16:12:46.275] {
[16:12:46.275]     {
[16:12:46.275]         {
[16:12:46.275]             ...future.startTime <- base::Sys.time()
[16:12:46.275]             {
[16:12:46.275]                 {
[16:12:46.275]                   {
[16:12:46.275]                     {
[16:12:46.275]                       base::local({
[16:12:46.275]                         has_future <- base::requireNamespace("future", 
[16:12:46.275]                           quietly = TRUE)
[16:12:46.275]                         if (has_future) {
[16:12:46.275]                           ns <- base::getNamespace("future")
[16:12:46.275]                           version <- ns[[".package"]][["version"]]
[16:12:46.275]                           if (is.null(version)) 
[16:12:46.275]                             version <- utils::packageVersion("future")
[16:12:46.275]                         }
[16:12:46.275]                         else {
[16:12:46.275]                           version <- NULL
[16:12:46.275]                         }
[16:12:46.275]                         if (!has_future || version < "1.8.0") {
[16:12:46.275]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.275]                             "", base::R.version$version.string), 
[16:12:46.275]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.275]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.275]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.275]                               "release", "version")], collapse = " "), 
[16:12:46.275]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.275]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.275]                             info)
[16:12:46.275]                           info <- base::paste(info, collapse = "; ")
[16:12:46.275]                           if (!has_future) {
[16:12:46.275]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.275]                               info)
[16:12:46.275]                           }
[16:12:46.275]                           else {
[16:12:46.275]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.275]                               info, version)
[16:12:46.275]                           }
[16:12:46.275]                           base::stop(msg)
[16:12:46.275]                         }
[16:12:46.275]                       })
[16:12:46.275]                     }
[16:12:46.275]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.275]                     base::options(mc.cores = 1L)
[16:12:46.275]                   }
[16:12:46.275]                   options(future.plan = NULL)
[16:12:46.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.275]                 }
[16:12:46.275]                 ...future.workdir <- getwd()
[16:12:46.275]             }
[16:12:46.275]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.275]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.275]         }
[16:12:46.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.275]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.275]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.275]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.275]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.275]             base::names(...future.oldOptions))
[16:12:46.275]     }
[16:12:46.275]     if (FALSE) {
[16:12:46.275]     }
[16:12:46.275]     else {
[16:12:46.275]         if (TRUE) {
[16:12:46.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.275]                 open = "w")
[16:12:46.275]         }
[16:12:46.275]         else {
[16:12:46.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.275]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.275]         }
[16:12:46.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.275]             base::sink(type = "output", split = FALSE)
[16:12:46.275]             base::close(...future.stdout)
[16:12:46.275]         }, add = TRUE)
[16:12:46.275]     }
[16:12:46.275]     ...future.frame <- base::sys.nframe()
[16:12:46.275]     ...future.conditions <- base::list()
[16:12:46.275]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.275]     if (FALSE) {
[16:12:46.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.275]     }
[16:12:46.275]     ...future.result <- base::tryCatch({
[16:12:46.275]         base::withCallingHandlers({
[16:12:46.275]             ...future.value <- base::withVisible(base::local({
[16:12:46.275]                 withCallingHandlers({
[16:12:46.275]                   {
[16:12:46.275]                     x[["a"]] <- 1
[16:12:46.275]                     x
[16:12:46.275]                   }
[16:12:46.275]                 }, immediateCondition = function(cond) {
[16:12:46.275]                   save_rds <- function (object, pathname, ...) 
[16:12:46.275]                   {
[16:12:46.275]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.275]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.275]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.275]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.275]                         fi_tmp[["mtime"]])
[16:12:46.275]                     }
[16:12:46.275]                     tryCatch({
[16:12:46.275]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.275]                     }, error = function(ex) {
[16:12:46.275]                       msg <- conditionMessage(ex)
[16:12:46.275]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.275]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.275]                         fi_tmp[["mtime"]], msg)
[16:12:46.275]                       ex$message <- msg
[16:12:46.275]                       stop(ex)
[16:12:46.275]                     })
[16:12:46.275]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.275]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.275]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.275]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.275]                       fi <- file.info(pathname)
[16:12:46.275]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.275]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.275]                         fi[["size"]], fi[["mtime"]])
[16:12:46.275]                       stop(msg)
[16:12:46.275]                     }
[16:12:46.275]                     invisible(pathname)
[16:12:46.275]                   }
[16:12:46.275]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.275]                     rootPath = tempdir()) 
[16:12:46.275]                   {
[16:12:46.275]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.275]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.275]                       tmpdir = path, fileext = ".rds")
[16:12:46.275]                     save_rds(obj, file)
[16:12:46.275]                   }
[16:12:46.275]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.275]                   {
[16:12:46.275]                     inherits <- base::inherits
[16:12:46.275]                     invokeRestart <- base::invokeRestart
[16:12:46.275]                     is.null <- base::is.null
[16:12:46.275]                     muffled <- FALSE
[16:12:46.275]                     if (inherits(cond, "message")) {
[16:12:46.275]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.275]                       if (muffled) 
[16:12:46.275]                         invokeRestart("muffleMessage")
[16:12:46.275]                     }
[16:12:46.275]                     else if (inherits(cond, "warning")) {
[16:12:46.275]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.275]                       if (muffled) 
[16:12:46.275]                         invokeRestart("muffleWarning")
[16:12:46.275]                     }
[16:12:46.275]                     else if (inherits(cond, "condition")) {
[16:12:46.275]                       if (!is.null(pattern)) {
[16:12:46.275]                         computeRestarts <- base::computeRestarts
[16:12:46.275]                         grepl <- base::grepl
[16:12:46.275]                         restarts <- computeRestarts(cond)
[16:12:46.275]                         for (restart in restarts) {
[16:12:46.275]                           name <- restart$name
[16:12:46.275]                           if (is.null(name)) 
[16:12:46.275]                             next
[16:12:46.275]                           if (!grepl(pattern, name)) 
[16:12:46.275]                             next
[16:12:46.275]                           invokeRestart(restart)
[16:12:46.275]                           muffled <- TRUE
[16:12:46.275]                           break
[16:12:46.275]                         }
[16:12:46.275]                       }
[16:12:46.275]                     }
[16:12:46.275]                     invisible(muffled)
[16:12:46.275]                   }
[16:12:46.275]                   muffleCondition(cond)
[16:12:46.275]                 })
[16:12:46.275]             }))
[16:12:46.275]             future::FutureResult(value = ...future.value$value, 
[16:12:46.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.275]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.275]                     ...future.globalenv.names))
[16:12:46.275]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.275]         }, condition = base::local({
[16:12:46.275]             c <- base::c
[16:12:46.275]             inherits <- base::inherits
[16:12:46.275]             invokeRestart <- base::invokeRestart
[16:12:46.275]             length <- base::length
[16:12:46.275]             list <- base::list
[16:12:46.275]             seq.int <- base::seq.int
[16:12:46.275]             signalCondition <- base::signalCondition
[16:12:46.275]             sys.calls <- base::sys.calls
[16:12:46.275]             `[[` <- base::`[[`
[16:12:46.275]             `+` <- base::`+`
[16:12:46.275]             `<<-` <- base::`<<-`
[16:12:46.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.275]                   3L)]
[16:12:46.275]             }
[16:12:46.275]             function(cond) {
[16:12:46.275]                 is_error <- inherits(cond, "error")
[16:12:46.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.275]                   NULL)
[16:12:46.275]                 if (is_error) {
[16:12:46.275]                   sessionInformation <- function() {
[16:12:46.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.275]                       search = base::search(), system = base::Sys.info())
[16:12:46.275]                   }
[16:12:46.275]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.275]                     cond$call), session = sessionInformation(), 
[16:12:46.275]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.275]                   signalCondition(cond)
[16:12:46.275]                 }
[16:12:46.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.275]                 "immediateCondition"))) {
[16:12:46.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.275]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.275]                   if (TRUE && !signal) {
[16:12:46.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.275]                     {
[16:12:46.275]                       inherits <- base::inherits
[16:12:46.275]                       invokeRestart <- base::invokeRestart
[16:12:46.275]                       is.null <- base::is.null
[16:12:46.275]                       muffled <- FALSE
[16:12:46.275]                       if (inherits(cond, "message")) {
[16:12:46.275]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.275]                         if (muffled) 
[16:12:46.275]                           invokeRestart("muffleMessage")
[16:12:46.275]                       }
[16:12:46.275]                       else if (inherits(cond, "warning")) {
[16:12:46.275]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.275]                         if (muffled) 
[16:12:46.275]                           invokeRestart("muffleWarning")
[16:12:46.275]                       }
[16:12:46.275]                       else if (inherits(cond, "condition")) {
[16:12:46.275]                         if (!is.null(pattern)) {
[16:12:46.275]                           computeRestarts <- base::computeRestarts
[16:12:46.275]                           grepl <- base::grepl
[16:12:46.275]                           restarts <- computeRestarts(cond)
[16:12:46.275]                           for (restart in restarts) {
[16:12:46.275]                             name <- restart$name
[16:12:46.275]                             if (is.null(name)) 
[16:12:46.275]                               next
[16:12:46.275]                             if (!grepl(pattern, name)) 
[16:12:46.275]                               next
[16:12:46.275]                             invokeRestart(restart)
[16:12:46.275]                             muffled <- TRUE
[16:12:46.275]                             break
[16:12:46.275]                           }
[16:12:46.275]                         }
[16:12:46.275]                       }
[16:12:46.275]                       invisible(muffled)
[16:12:46.275]                     }
[16:12:46.275]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.275]                   }
[16:12:46.275]                 }
[16:12:46.275]                 else {
[16:12:46.275]                   if (TRUE) {
[16:12:46.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.275]                     {
[16:12:46.275]                       inherits <- base::inherits
[16:12:46.275]                       invokeRestart <- base::invokeRestart
[16:12:46.275]                       is.null <- base::is.null
[16:12:46.275]                       muffled <- FALSE
[16:12:46.275]                       if (inherits(cond, "message")) {
[16:12:46.275]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.275]                         if (muffled) 
[16:12:46.275]                           invokeRestart("muffleMessage")
[16:12:46.275]                       }
[16:12:46.275]                       else if (inherits(cond, "warning")) {
[16:12:46.275]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.275]                         if (muffled) 
[16:12:46.275]                           invokeRestart("muffleWarning")
[16:12:46.275]                       }
[16:12:46.275]                       else if (inherits(cond, "condition")) {
[16:12:46.275]                         if (!is.null(pattern)) {
[16:12:46.275]                           computeRestarts <- base::computeRestarts
[16:12:46.275]                           grepl <- base::grepl
[16:12:46.275]                           restarts <- computeRestarts(cond)
[16:12:46.275]                           for (restart in restarts) {
[16:12:46.275]                             name <- restart$name
[16:12:46.275]                             if (is.null(name)) 
[16:12:46.275]                               next
[16:12:46.275]                             if (!grepl(pattern, name)) 
[16:12:46.275]                               next
[16:12:46.275]                             invokeRestart(restart)
[16:12:46.275]                             muffled <- TRUE
[16:12:46.275]                             break
[16:12:46.275]                           }
[16:12:46.275]                         }
[16:12:46.275]                       }
[16:12:46.275]                       invisible(muffled)
[16:12:46.275]                     }
[16:12:46.275]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.275]                   }
[16:12:46.275]                 }
[16:12:46.275]             }
[16:12:46.275]         }))
[16:12:46.275]     }, error = function(ex) {
[16:12:46.275]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.275]                 ...future.rng), started = ...future.startTime, 
[16:12:46.275]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.275]             version = "1.8"), class = "FutureResult")
[16:12:46.275]     }, finally = {
[16:12:46.275]         if (!identical(...future.workdir, getwd())) 
[16:12:46.275]             setwd(...future.workdir)
[16:12:46.275]         {
[16:12:46.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.275]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.275]             }
[16:12:46.275]             base::options(...future.oldOptions)
[16:12:46.275]             if (.Platform$OS.type == "windows") {
[16:12:46.275]                 old_names <- names(...future.oldEnvVars)
[16:12:46.275]                 envs <- base::Sys.getenv()
[16:12:46.275]                 names <- names(envs)
[16:12:46.275]                 common <- intersect(names, old_names)
[16:12:46.275]                 added <- setdiff(names, old_names)
[16:12:46.275]                 removed <- setdiff(old_names, names)
[16:12:46.275]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.275]                   envs[common]]
[16:12:46.275]                 NAMES <- toupper(changed)
[16:12:46.275]                 args <- list()
[16:12:46.275]                 for (kk in seq_along(NAMES)) {
[16:12:46.275]                   name <- changed[[kk]]
[16:12:46.275]                   NAME <- NAMES[[kk]]
[16:12:46.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.275]                     next
[16:12:46.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.275]                 }
[16:12:46.275]                 NAMES <- toupper(added)
[16:12:46.275]                 for (kk in seq_along(NAMES)) {
[16:12:46.275]                   name <- added[[kk]]
[16:12:46.275]                   NAME <- NAMES[[kk]]
[16:12:46.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.275]                     next
[16:12:46.275]                   args[[name]] <- ""
[16:12:46.275]                 }
[16:12:46.275]                 NAMES <- toupper(removed)
[16:12:46.275]                 for (kk in seq_along(NAMES)) {
[16:12:46.275]                   name <- removed[[kk]]
[16:12:46.275]                   NAME <- NAMES[[kk]]
[16:12:46.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.275]                     next
[16:12:46.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.275]                 }
[16:12:46.275]                 if (length(args) > 0) 
[16:12:46.275]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.275]             }
[16:12:46.275]             else {
[16:12:46.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.275]             }
[16:12:46.275]             {
[16:12:46.275]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.275]                   0L) {
[16:12:46.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.275]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.275]                   base::options(opts)
[16:12:46.275]                 }
[16:12:46.275]                 {
[16:12:46.275]                   {
[16:12:46.275]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.275]                     NULL
[16:12:46.275]                   }
[16:12:46.275]                   options(future.plan = NULL)
[16:12:46.275]                   if (is.na(NA_character_)) 
[16:12:46.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.275]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.275]                     envir = parent.frame()) 
[16:12:46.275]                   {
[16:12:46.275]                     default_workers <- missing(workers)
[16:12:46.275]                     if (is.function(workers)) 
[16:12:46.275]                       workers <- workers()
[16:12:46.275]                     workers <- structure(as.integer(workers), 
[16:12:46.275]                       class = class(workers))
[16:12:46.275]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.275]                       1L)
[16:12:46.275]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.275]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.275]                       if (default_workers) 
[16:12:46.275]                         supportsMulticore(warn = TRUE)
[16:12:46.275]                       return(sequential(..., envir = envir))
[16:12:46.275]                     }
[16:12:46.275]                     oopts <- options(mc.cores = workers)
[16:12:46.275]                     on.exit(options(oopts))
[16:12:46.275]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.275]                       envir = envir)
[16:12:46.275]                     if (!future$lazy) 
[16:12:46.275]                       future <- run(future)
[16:12:46.275]                     invisible(future)
[16:12:46.275]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.275]                 }
[16:12:46.275]             }
[16:12:46.275]         }
[16:12:46.275]     })
[16:12:46.275]     if (TRUE) {
[16:12:46.275]         base::sink(type = "output", split = FALSE)
[16:12:46.275]         if (TRUE) {
[16:12:46.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.275]         }
[16:12:46.275]         else {
[16:12:46.275]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.275]         }
[16:12:46.275]         base::close(...future.stdout)
[16:12:46.275]         ...future.stdout <- NULL
[16:12:46.275]     }
[16:12:46.275]     ...future.result$conditions <- ...future.conditions
[16:12:46.275]     ...future.result$finished <- base::Sys.time()
[16:12:46.275]     ...future.result
[16:12:46.275] }
[16:12:46.278] assign_globals() ...
[16:12:46.278] List of 1
[16:12:46.278]  $ x: list()
[16:12:46.278]  - attr(*, "where")=List of 1
[16:12:46.278]   ..$ x:<environment: R_EmptyEnv> 
[16:12:46.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:46.278]  - attr(*, "resolved")= logi TRUE
[16:12:46.278]  - attr(*, "total_size")= num 0
[16:12:46.278]  - attr(*, "already-done")= logi TRUE
[16:12:46.281] - copied ‘x’ to environment
[16:12:46.281] assign_globals() ... done
[16:12:46.281] requestCore(): workers = 2
[16:12:46.283] MulticoreFuture started
[16:12:46.284] - Launch lazy future ... done
[16:12:46.284] run() for ‘MulticoreFuture’ ... done
[16:12:46.284] plan(): Setting new future strategy stack:
[16:12:46.285] List of future strategies:
[16:12:46.285] 1. sequential:
[16:12:46.285]    - args: function (..., envir = parent.frame())
[16:12:46.285]    - tweaked: FALSE
[16:12:46.285]    - call: NULL
[16:12:46.286] plan(): nbrOfWorkers() = 1
[16:12:46.287] plan(): Setting new future strategy stack:
[16:12:46.288] List of future strategies:
[16:12:46.288] 1. multicore:
[16:12:46.288]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.288]    - tweaked: FALSE
[16:12:46.288]    - call: plan(strategy)
[16:12:46.293] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.294] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.295] Searching for globals...
[16:12:46.298] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:46.298] Searching for globals ... DONE
[16:12:46.298] Resolving globals: TRUE
[16:12:46.298] Resolving any globals that are futures ...
[16:12:46.298] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:46.298] Resolving any globals that are futures ... DONE
[16:12:46.299] Resolving futures part of globals (recursively) ...
[16:12:46.299] resolve() on list ...
[16:12:46.299]  recursive: 99
[16:12:46.299]  length: 1
[16:12:46.299]  elements: ‘x’
[16:12:46.300]  length: 0 (resolved future 1)
[16:12:46.300] resolve() on list ... DONE
[16:12:46.300] - globals: [1] ‘x’
[16:12:46.300] Resolving futures part of globals (recursively) ... DONE
[16:12:46.300] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:46.301] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:46.301] - globals: [1] ‘x’
[16:12:46.301] 
[16:12:46.301] getGlobalsAndPackages() ... DONE
[16:12:46.301] run() for ‘Future’ ...
[16:12:46.301] - state: ‘created’
[16:12:46.302] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.306] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.306] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.306]   - Field: ‘label’
[16:12:46.306]   - Field: ‘local’
[16:12:46.306]   - Field: ‘owner’
[16:12:46.306]   - Field: ‘envir’
[16:12:46.306]   - Field: ‘workers’
[16:12:46.307]   - Field: ‘packages’
[16:12:46.307]   - Field: ‘gc’
[16:12:46.307]   - Field: ‘job’
[16:12:46.307]   - Field: ‘conditions’
[16:12:46.307]   - Field: ‘expr’
[16:12:46.307]   - Field: ‘uuid’
[16:12:46.307]   - Field: ‘seed’
[16:12:46.307]   - Field: ‘version’
[16:12:46.307]   - Field: ‘result’
[16:12:46.308]   - Field: ‘asynchronous’
[16:12:46.308]   - Field: ‘calls’
[16:12:46.308]   - Field: ‘globals’
[16:12:46.308]   - Field: ‘stdout’
[16:12:46.308]   - Field: ‘earlySignal’
[16:12:46.308]   - Field: ‘lazy’
[16:12:46.308]   - Field: ‘state’
[16:12:46.308] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.308] - Launch lazy future ...
[16:12:46.309] Packages needed by the future expression (n = 0): <none>
[16:12:46.309] Packages needed by future strategies (n = 0): <none>
[16:12:46.309] {
[16:12:46.309]     {
[16:12:46.309]         {
[16:12:46.309]             ...future.startTime <- base::Sys.time()
[16:12:46.309]             {
[16:12:46.309]                 {
[16:12:46.309]                   {
[16:12:46.309]                     {
[16:12:46.309]                       base::local({
[16:12:46.309]                         has_future <- base::requireNamespace("future", 
[16:12:46.309]                           quietly = TRUE)
[16:12:46.309]                         if (has_future) {
[16:12:46.309]                           ns <- base::getNamespace("future")
[16:12:46.309]                           version <- ns[[".package"]][["version"]]
[16:12:46.309]                           if (is.null(version)) 
[16:12:46.309]                             version <- utils::packageVersion("future")
[16:12:46.309]                         }
[16:12:46.309]                         else {
[16:12:46.309]                           version <- NULL
[16:12:46.309]                         }
[16:12:46.309]                         if (!has_future || version < "1.8.0") {
[16:12:46.309]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.309]                             "", base::R.version$version.string), 
[16:12:46.309]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.309]                               "release", "version")], collapse = " "), 
[16:12:46.309]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.309]                             info)
[16:12:46.309]                           info <- base::paste(info, collapse = "; ")
[16:12:46.309]                           if (!has_future) {
[16:12:46.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.309]                               info)
[16:12:46.309]                           }
[16:12:46.309]                           else {
[16:12:46.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.309]                               info, version)
[16:12:46.309]                           }
[16:12:46.309]                           base::stop(msg)
[16:12:46.309]                         }
[16:12:46.309]                       })
[16:12:46.309]                     }
[16:12:46.309]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.309]                     base::options(mc.cores = 1L)
[16:12:46.309]                   }
[16:12:46.309]                   options(future.plan = NULL)
[16:12:46.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.309]                 }
[16:12:46.309]                 ...future.workdir <- getwd()
[16:12:46.309]             }
[16:12:46.309]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.309]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.309]         }
[16:12:46.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.309]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.309]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.309]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.309]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.309]             base::names(...future.oldOptions))
[16:12:46.309]     }
[16:12:46.309]     if (FALSE) {
[16:12:46.309]     }
[16:12:46.309]     else {
[16:12:46.309]         if (TRUE) {
[16:12:46.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.309]                 open = "w")
[16:12:46.309]         }
[16:12:46.309]         else {
[16:12:46.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.309]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.309]         }
[16:12:46.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.309]             base::sink(type = "output", split = FALSE)
[16:12:46.309]             base::close(...future.stdout)
[16:12:46.309]         }, add = TRUE)
[16:12:46.309]     }
[16:12:46.309]     ...future.frame <- base::sys.nframe()
[16:12:46.309]     ...future.conditions <- base::list()
[16:12:46.309]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.309]     if (FALSE) {
[16:12:46.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.309]     }
[16:12:46.309]     ...future.result <- base::tryCatch({
[16:12:46.309]         base::withCallingHandlers({
[16:12:46.309]             ...future.value <- base::withVisible(base::local({
[16:12:46.309]                 withCallingHandlers({
[16:12:46.309]                   {
[16:12:46.309]                     x["a"] <- list(1)
[16:12:46.309]                     x
[16:12:46.309]                   }
[16:12:46.309]                 }, immediateCondition = function(cond) {
[16:12:46.309]                   save_rds <- function (object, pathname, ...) 
[16:12:46.309]                   {
[16:12:46.309]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.309]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.309]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.309]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.309]                         fi_tmp[["mtime"]])
[16:12:46.309]                     }
[16:12:46.309]                     tryCatch({
[16:12:46.309]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.309]                     }, error = function(ex) {
[16:12:46.309]                       msg <- conditionMessage(ex)
[16:12:46.309]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.309]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.309]                         fi_tmp[["mtime"]], msg)
[16:12:46.309]                       ex$message <- msg
[16:12:46.309]                       stop(ex)
[16:12:46.309]                     })
[16:12:46.309]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.309]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.309]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.309]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.309]                       fi <- file.info(pathname)
[16:12:46.309]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.309]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.309]                         fi[["size"]], fi[["mtime"]])
[16:12:46.309]                       stop(msg)
[16:12:46.309]                     }
[16:12:46.309]                     invisible(pathname)
[16:12:46.309]                   }
[16:12:46.309]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.309]                     rootPath = tempdir()) 
[16:12:46.309]                   {
[16:12:46.309]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.309]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.309]                       tmpdir = path, fileext = ".rds")
[16:12:46.309]                     save_rds(obj, file)
[16:12:46.309]                   }
[16:12:46.309]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.309]                   {
[16:12:46.309]                     inherits <- base::inherits
[16:12:46.309]                     invokeRestart <- base::invokeRestart
[16:12:46.309]                     is.null <- base::is.null
[16:12:46.309]                     muffled <- FALSE
[16:12:46.309]                     if (inherits(cond, "message")) {
[16:12:46.309]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.309]                       if (muffled) 
[16:12:46.309]                         invokeRestart("muffleMessage")
[16:12:46.309]                     }
[16:12:46.309]                     else if (inherits(cond, "warning")) {
[16:12:46.309]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.309]                       if (muffled) 
[16:12:46.309]                         invokeRestart("muffleWarning")
[16:12:46.309]                     }
[16:12:46.309]                     else if (inherits(cond, "condition")) {
[16:12:46.309]                       if (!is.null(pattern)) {
[16:12:46.309]                         computeRestarts <- base::computeRestarts
[16:12:46.309]                         grepl <- base::grepl
[16:12:46.309]                         restarts <- computeRestarts(cond)
[16:12:46.309]                         for (restart in restarts) {
[16:12:46.309]                           name <- restart$name
[16:12:46.309]                           if (is.null(name)) 
[16:12:46.309]                             next
[16:12:46.309]                           if (!grepl(pattern, name)) 
[16:12:46.309]                             next
[16:12:46.309]                           invokeRestart(restart)
[16:12:46.309]                           muffled <- TRUE
[16:12:46.309]                           break
[16:12:46.309]                         }
[16:12:46.309]                       }
[16:12:46.309]                     }
[16:12:46.309]                     invisible(muffled)
[16:12:46.309]                   }
[16:12:46.309]                   muffleCondition(cond)
[16:12:46.309]                 })
[16:12:46.309]             }))
[16:12:46.309]             future::FutureResult(value = ...future.value$value, 
[16:12:46.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.309]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.309]                     ...future.globalenv.names))
[16:12:46.309]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.309]         }, condition = base::local({
[16:12:46.309]             c <- base::c
[16:12:46.309]             inherits <- base::inherits
[16:12:46.309]             invokeRestart <- base::invokeRestart
[16:12:46.309]             length <- base::length
[16:12:46.309]             list <- base::list
[16:12:46.309]             seq.int <- base::seq.int
[16:12:46.309]             signalCondition <- base::signalCondition
[16:12:46.309]             sys.calls <- base::sys.calls
[16:12:46.309]             `[[` <- base::`[[`
[16:12:46.309]             `+` <- base::`+`
[16:12:46.309]             `<<-` <- base::`<<-`
[16:12:46.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.309]                   3L)]
[16:12:46.309]             }
[16:12:46.309]             function(cond) {
[16:12:46.309]                 is_error <- inherits(cond, "error")
[16:12:46.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.309]                   NULL)
[16:12:46.309]                 if (is_error) {
[16:12:46.309]                   sessionInformation <- function() {
[16:12:46.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.309]                       search = base::search(), system = base::Sys.info())
[16:12:46.309]                   }
[16:12:46.309]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.309]                     cond$call), session = sessionInformation(), 
[16:12:46.309]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.309]                   signalCondition(cond)
[16:12:46.309]                 }
[16:12:46.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.309]                 "immediateCondition"))) {
[16:12:46.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.309]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.309]                   if (TRUE && !signal) {
[16:12:46.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.309]                     {
[16:12:46.309]                       inherits <- base::inherits
[16:12:46.309]                       invokeRestart <- base::invokeRestart
[16:12:46.309]                       is.null <- base::is.null
[16:12:46.309]                       muffled <- FALSE
[16:12:46.309]                       if (inherits(cond, "message")) {
[16:12:46.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.309]                         if (muffled) 
[16:12:46.309]                           invokeRestart("muffleMessage")
[16:12:46.309]                       }
[16:12:46.309]                       else if (inherits(cond, "warning")) {
[16:12:46.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.309]                         if (muffled) 
[16:12:46.309]                           invokeRestart("muffleWarning")
[16:12:46.309]                       }
[16:12:46.309]                       else if (inherits(cond, "condition")) {
[16:12:46.309]                         if (!is.null(pattern)) {
[16:12:46.309]                           computeRestarts <- base::computeRestarts
[16:12:46.309]                           grepl <- base::grepl
[16:12:46.309]                           restarts <- computeRestarts(cond)
[16:12:46.309]                           for (restart in restarts) {
[16:12:46.309]                             name <- restart$name
[16:12:46.309]                             if (is.null(name)) 
[16:12:46.309]                               next
[16:12:46.309]                             if (!grepl(pattern, name)) 
[16:12:46.309]                               next
[16:12:46.309]                             invokeRestart(restart)
[16:12:46.309]                             muffled <- TRUE
[16:12:46.309]                             break
[16:12:46.309]                           }
[16:12:46.309]                         }
[16:12:46.309]                       }
[16:12:46.309]                       invisible(muffled)
[16:12:46.309]                     }
[16:12:46.309]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.309]                   }
[16:12:46.309]                 }
[16:12:46.309]                 else {
[16:12:46.309]                   if (TRUE) {
[16:12:46.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.309]                     {
[16:12:46.309]                       inherits <- base::inherits
[16:12:46.309]                       invokeRestart <- base::invokeRestart
[16:12:46.309]                       is.null <- base::is.null
[16:12:46.309]                       muffled <- FALSE
[16:12:46.309]                       if (inherits(cond, "message")) {
[16:12:46.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.309]                         if (muffled) 
[16:12:46.309]                           invokeRestart("muffleMessage")
[16:12:46.309]                       }
[16:12:46.309]                       else if (inherits(cond, "warning")) {
[16:12:46.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.309]                         if (muffled) 
[16:12:46.309]                           invokeRestart("muffleWarning")
[16:12:46.309]                       }
[16:12:46.309]                       else if (inherits(cond, "condition")) {
[16:12:46.309]                         if (!is.null(pattern)) {
[16:12:46.309]                           computeRestarts <- base::computeRestarts
[16:12:46.309]                           grepl <- base::grepl
[16:12:46.309]                           restarts <- computeRestarts(cond)
[16:12:46.309]                           for (restart in restarts) {
[16:12:46.309]                             name <- restart$name
[16:12:46.309]                             if (is.null(name)) 
[16:12:46.309]                               next
[16:12:46.309]                             if (!grepl(pattern, name)) 
[16:12:46.309]                               next
[16:12:46.309]                             invokeRestart(restart)
[16:12:46.309]                             muffled <- TRUE
[16:12:46.309]                             break
[16:12:46.309]                           }
[16:12:46.309]                         }
[16:12:46.309]                       }
[16:12:46.309]                       invisible(muffled)
[16:12:46.309]                     }
[16:12:46.309]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.309]                   }
[16:12:46.309]                 }
[16:12:46.309]             }
[16:12:46.309]         }))
[16:12:46.309]     }, error = function(ex) {
[16:12:46.309]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.309]                 ...future.rng), started = ...future.startTime, 
[16:12:46.309]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.309]             version = "1.8"), class = "FutureResult")
[16:12:46.309]     }, finally = {
[16:12:46.309]         if (!identical(...future.workdir, getwd())) 
[16:12:46.309]             setwd(...future.workdir)
[16:12:46.309]         {
[16:12:46.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.309]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.309]             }
[16:12:46.309]             base::options(...future.oldOptions)
[16:12:46.309]             if (.Platform$OS.type == "windows") {
[16:12:46.309]                 old_names <- names(...future.oldEnvVars)
[16:12:46.309]                 envs <- base::Sys.getenv()
[16:12:46.309]                 names <- names(envs)
[16:12:46.309]                 common <- intersect(names, old_names)
[16:12:46.309]                 added <- setdiff(names, old_names)
[16:12:46.309]                 removed <- setdiff(old_names, names)
[16:12:46.309]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.309]                   envs[common]]
[16:12:46.309]                 NAMES <- toupper(changed)
[16:12:46.309]                 args <- list()
[16:12:46.309]                 for (kk in seq_along(NAMES)) {
[16:12:46.309]                   name <- changed[[kk]]
[16:12:46.309]                   NAME <- NAMES[[kk]]
[16:12:46.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.309]                     next
[16:12:46.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.309]                 }
[16:12:46.309]                 NAMES <- toupper(added)
[16:12:46.309]                 for (kk in seq_along(NAMES)) {
[16:12:46.309]                   name <- added[[kk]]
[16:12:46.309]                   NAME <- NAMES[[kk]]
[16:12:46.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.309]                     next
[16:12:46.309]                   args[[name]] <- ""
[16:12:46.309]                 }
[16:12:46.309]                 NAMES <- toupper(removed)
[16:12:46.309]                 for (kk in seq_along(NAMES)) {
[16:12:46.309]                   name <- removed[[kk]]
[16:12:46.309]                   NAME <- NAMES[[kk]]
[16:12:46.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.309]                     next
[16:12:46.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.309]                 }
[16:12:46.309]                 if (length(args) > 0) 
[16:12:46.309]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.309]             }
[16:12:46.309]             else {
[16:12:46.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.309]             }
[16:12:46.309]             {
[16:12:46.309]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.309]                   0L) {
[16:12:46.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.309]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.309]                   base::options(opts)
[16:12:46.309]                 }
[16:12:46.309]                 {
[16:12:46.309]                   {
[16:12:46.309]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.309]                     NULL
[16:12:46.309]                   }
[16:12:46.309]                   options(future.plan = NULL)
[16:12:46.309]                   if (is.na(NA_character_)) 
[16:12:46.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.309]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.309]                     envir = parent.frame()) 
[16:12:46.309]                   {
[16:12:46.309]                     default_workers <- missing(workers)
[16:12:46.309]                     if (is.function(workers)) 
[16:12:46.309]                       workers <- workers()
[16:12:46.309]                     workers <- structure(as.integer(workers), 
[16:12:46.309]                       class = class(workers))
[16:12:46.309]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.309]                       1L)
[16:12:46.309]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.309]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.309]                       if (default_workers) 
[16:12:46.309]                         supportsMulticore(warn = TRUE)
[16:12:46.309]                       return(sequential(..., envir = envir))
[16:12:46.309]                     }
[16:12:46.309]                     oopts <- options(mc.cores = workers)
[16:12:46.309]                     on.exit(options(oopts))
[16:12:46.309]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.309]                       envir = envir)
[16:12:46.309]                     if (!future$lazy) 
[16:12:46.309]                       future <- run(future)
[16:12:46.309]                     invisible(future)
[16:12:46.309]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.309]                 }
[16:12:46.309]             }
[16:12:46.309]         }
[16:12:46.309]     })
[16:12:46.309]     if (TRUE) {
[16:12:46.309]         base::sink(type = "output", split = FALSE)
[16:12:46.309]         if (TRUE) {
[16:12:46.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.309]         }
[16:12:46.309]         else {
[16:12:46.309]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.309]         }
[16:12:46.309]         base::close(...future.stdout)
[16:12:46.309]         ...future.stdout <- NULL
[16:12:46.309]     }
[16:12:46.309]     ...future.result$conditions <- ...future.conditions
[16:12:46.309]     ...future.result$finished <- base::Sys.time()
[16:12:46.309]     ...future.result
[16:12:46.309] }
[16:12:46.312] assign_globals() ...
[16:12:46.312] List of 1
[16:12:46.312]  $ x: list()
[16:12:46.312]  - attr(*, "where")=List of 1
[16:12:46.312]   ..$ x:<environment: R_EmptyEnv> 
[16:12:46.312]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:46.312]  - attr(*, "resolved")= logi TRUE
[16:12:46.312]  - attr(*, "total_size")= num 0
[16:12:46.312]  - attr(*, "already-done")= logi TRUE
[16:12:46.315] - copied ‘x’ to environment
[16:12:46.315] assign_globals() ... done
[16:12:46.315] requestCore(): workers = 2
[16:12:46.317] MulticoreFuture started
[16:12:46.318] - Launch lazy future ... done
[16:12:46.318] run() for ‘MulticoreFuture’ ... done
[16:12:46.318] plan(): Setting new future strategy stack:
[16:12:46.318] List of future strategies:
[16:12:46.318] 1. sequential:
[16:12:46.318]    - args: function (..., envir = parent.frame())
[16:12:46.318]    - tweaked: FALSE
[16:12:46.318]    - call: NULL
[16:12:46.319] plan(): nbrOfWorkers() = 1
[16:12:46.321] plan(): Setting new future strategy stack:
[16:12:46.321] List of future strategies:
[16:12:46.321] 1. multicore:
[16:12:46.321]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.321]    - tweaked: FALSE
[16:12:46.321]    - call: plan(strategy)
[16:12:46.331] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.332] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.333] Searching for globals...
[16:12:46.338] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:46.339] Searching for globals ... DONE
[16:12:46.339] Resolving globals: TRUE
[16:12:46.339] Resolving any globals that are futures ...
[16:12:46.339] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:46.339] Resolving any globals that are futures ... DONE
[16:12:46.340] Resolving futures part of globals (recursively) ...
[16:12:46.340] resolve() on list ...
[16:12:46.340]  recursive: 99
[16:12:46.340]  length: 1
[16:12:46.340]  elements: ‘x’
[16:12:46.341]  length: 0 (resolved future 1)
[16:12:46.341] resolve() on list ... DONE
[16:12:46.341] - globals: [1] ‘x’
[16:12:46.341] Resolving futures part of globals (recursively) ... DONE
[16:12:46.341] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:46.342] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:46.342] - globals: [1] ‘x’
[16:12:46.342] 
[16:12:46.342] getGlobalsAndPackages() ... DONE
[16:12:46.342] run() for ‘Future’ ...
[16:12:46.343] - state: ‘created’
[16:12:46.343] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.347] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.347]   - Field: ‘label’
[16:12:46.347]   - Field: ‘local’
[16:12:46.347]   - Field: ‘owner’
[16:12:46.347]   - Field: ‘envir’
[16:12:46.347]   - Field: ‘workers’
[16:12:46.348]   - Field: ‘packages’
[16:12:46.348]   - Field: ‘gc’
[16:12:46.348]   - Field: ‘job’
[16:12:46.348]   - Field: ‘conditions’
[16:12:46.348]   - Field: ‘expr’
[16:12:46.348]   - Field: ‘uuid’
[16:12:46.348]   - Field: ‘seed’
[16:12:46.348]   - Field: ‘version’
[16:12:46.348]   - Field: ‘result’
[16:12:46.349]   - Field: ‘asynchronous’
[16:12:46.349]   - Field: ‘calls’
[16:12:46.349]   - Field: ‘globals’
[16:12:46.349]   - Field: ‘stdout’
[16:12:46.349]   - Field: ‘earlySignal’
[16:12:46.349]   - Field: ‘lazy’
[16:12:46.349]   - Field: ‘state’
[16:12:46.349] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.349] - Launch lazy future ...
[16:12:46.350] Packages needed by the future expression (n = 0): <none>
[16:12:46.350] Packages needed by future strategies (n = 0): <none>
[16:12:46.350] {
[16:12:46.350]     {
[16:12:46.350]         {
[16:12:46.350]             ...future.startTime <- base::Sys.time()
[16:12:46.350]             {
[16:12:46.350]                 {
[16:12:46.350]                   {
[16:12:46.350]                     {
[16:12:46.350]                       base::local({
[16:12:46.350]                         has_future <- base::requireNamespace("future", 
[16:12:46.350]                           quietly = TRUE)
[16:12:46.350]                         if (has_future) {
[16:12:46.350]                           ns <- base::getNamespace("future")
[16:12:46.350]                           version <- ns[[".package"]][["version"]]
[16:12:46.350]                           if (is.null(version)) 
[16:12:46.350]                             version <- utils::packageVersion("future")
[16:12:46.350]                         }
[16:12:46.350]                         else {
[16:12:46.350]                           version <- NULL
[16:12:46.350]                         }
[16:12:46.350]                         if (!has_future || version < "1.8.0") {
[16:12:46.350]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.350]                             "", base::R.version$version.string), 
[16:12:46.350]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.350]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.350]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.350]                               "release", "version")], collapse = " "), 
[16:12:46.350]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.350]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.350]                             info)
[16:12:46.350]                           info <- base::paste(info, collapse = "; ")
[16:12:46.350]                           if (!has_future) {
[16:12:46.350]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.350]                               info)
[16:12:46.350]                           }
[16:12:46.350]                           else {
[16:12:46.350]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.350]                               info, version)
[16:12:46.350]                           }
[16:12:46.350]                           base::stop(msg)
[16:12:46.350]                         }
[16:12:46.350]                       })
[16:12:46.350]                     }
[16:12:46.350]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.350]                     base::options(mc.cores = 1L)
[16:12:46.350]                   }
[16:12:46.350]                   options(future.plan = NULL)
[16:12:46.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.350]                 }
[16:12:46.350]                 ...future.workdir <- getwd()
[16:12:46.350]             }
[16:12:46.350]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.350]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.350]         }
[16:12:46.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.350]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.350]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.350]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.350]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.350]             base::names(...future.oldOptions))
[16:12:46.350]     }
[16:12:46.350]     if (FALSE) {
[16:12:46.350]     }
[16:12:46.350]     else {
[16:12:46.350]         if (TRUE) {
[16:12:46.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.350]                 open = "w")
[16:12:46.350]         }
[16:12:46.350]         else {
[16:12:46.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.350]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.350]         }
[16:12:46.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.350]             base::sink(type = "output", split = FALSE)
[16:12:46.350]             base::close(...future.stdout)
[16:12:46.350]         }, add = TRUE)
[16:12:46.350]     }
[16:12:46.350]     ...future.frame <- base::sys.nframe()
[16:12:46.350]     ...future.conditions <- base::list()
[16:12:46.350]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.350]     if (FALSE) {
[16:12:46.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.350]     }
[16:12:46.350]     ...future.result <- base::tryCatch({
[16:12:46.350]         base::withCallingHandlers({
[16:12:46.350]             ...future.value <- base::withVisible(base::local({
[16:12:46.350]                 withCallingHandlers({
[16:12:46.350]                   {
[16:12:46.350]                     x["a"] <- list(1)
[16:12:46.350]                     x
[16:12:46.350]                   }
[16:12:46.350]                 }, immediateCondition = function(cond) {
[16:12:46.350]                   save_rds <- function (object, pathname, ...) 
[16:12:46.350]                   {
[16:12:46.350]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.350]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.350]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.350]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.350]                         fi_tmp[["mtime"]])
[16:12:46.350]                     }
[16:12:46.350]                     tryCatch({
[16:12:46.350]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.350]                     }, error = function(ex) {
[16:12:46.350]                       msg <- conditionMessage(ex)
[16:12:46.350]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.350]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.350]                         fi_tmp[["mtime"]], msg)
[16:12:46.350]                       ex$message <- msg
[16:12:46.350]                       stop(ex)
[16:12:46.350]                     })
[16:12:46.350]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.350]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.350]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.350]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.350]                       fi <- file.info(pathname)
[16:12:46.350]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.350]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.350]                         fi[["size"]], fi[["mtime"]])
[16:12:46.350]                       stop(msg)
[16:12:46.350]                     }
[16:12:46.350]                     invisible(pathname)
[16:12:46.350]                   }
[16:12:46.350]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.350]                     rootPath = tempdir()) 
[16:12:46.350]                   {
[16:12:46.350]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.350]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.350]                       tmpdir = path, fileext = ".rds")
[16:12:46.350]                     save_rds(obj, file)
[16:12:46.350]                   }
[16:12:46.350]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.350]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.350]                   {
[16:12:46.350]                     inherits <- base::inherits
[16:12:46.350]                     invokeRestart <- base::invokeRestart
[16:12:46.350]                     is.null <- base::is.null
[16:12:46.350]                     muffled <- FALSE
[16:12:46.350]                     if (inherits(cond, "message")) {
[16:12:46.350]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.350]                       if (muffled) 
[16:12:46.350]                         invokeRestart("muffleMessage")
[16:12:46.350]                     }
[16:12:46.350]                     else if (inherits(cond, "warning")) {
[16:12:46.350]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.350]                       if (muffled) 
[16:12:46.350]                         invokeRestart("muffleWarning")
[16:12:46.350]                     }
[16:12:46.350]                     else if (inherits(cond, "condition")) {
[16:12:46.350]                       if (!is.null(pattern)) {
[16:12:46.350]                         computeRestarts <- base::computeRestarts
[16:12:46.350]                         grepl <- base::grepl
[16:12:46.350]                         restarts <- computeRestarts(cond)
[16:12:46.350]                         for (restart in restarts) {
[16:12:46.350]                           name <- restart$name
[16:12:46.350]                           if (is.null(name)) 
[16:12:46.350]                             next
[16:12:46.350]                           if (!grepl(pattern, name)) 
[16:12:46.350]                             next
[16:12:46.350]                           invokeRestart(restart)
[16:12:46.350]                           muffled <- TRUE
[16:12:46.350]                           break
[16:12:46.350]                         }
[16:12:46.350]                       }
[16:12:46.350]                     }
[16:12:46.350]                     invisible(muffled)
[16:12:46.350]                   }
[16:12:46.350]                   muffleCondition(cond)
[16:12:46.350]                 })
[16:12:46.350]             }))
[16:12:46.350]             future::FutureResult(value = ...future.value$value, 
[16:12:46.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.350]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.350]                     ...future.globalenv.names))
[16:12:46.350]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.350]         }, condition = base::local({
[16:12:46.350]             c <- base::c
[16:12:46.350]             inherits <- base::inherits
[16:12:46.350]             invokeRestart <- base::invokeRestart
[16:12:46.350]             length <- base::length
[16:12:46.350]             list <- base::list
[16:12:46.350]             seq.int <- base::seq.int
[16:12:46.350]             signalCondition <- base::signalCondition
[16:12:46.350]             sys.calls <- base::sys.calls
[16:12:46.350]             `[[` <- base::`[[`
[16:12:46.350]             `+` <- base::`+`
[16:12:46.350]             `<<-` <- base::`<<-`
[16:12:46.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.350]                   3L)]
[16:12:46.350]             }
[16:12:46.350]             function(cond) {
[16:12:46.350]                 is_error <- inherits(cond, "error")
[16:12:46.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.350]                   NULL)
[16:12:46.350]                 if (is_error) {
[16:12:46.350]                   sessionInformation <- function() {
[16:12:46.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.350]                       search = base::search(), system = base::Sys.info())
[16:12:46.350]                   }
[16:12:46.350]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.350]                     cond$call), session = sessionInformation(), 
[16:12:46.350]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.350]                   signalCondition(cond)
[16:12:46.350]                 }
[16:12:46.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.350]                 "immediateCondition"))) {
[16:12:46.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.350]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.350]                   if (TRUE && !signal) {
[16:12:46.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.350]                     {
[16:12:46.350]                       inherits <- base::inherits
[16:12:46.350]                       invokeRestart <- base::invokeRestart
[16:12:46.350]                       is.null <- base::is.null
[16:12:46.350]                       muffled <- FALSE
[16:12:46.350]                       if (inherits(cond, "message")) {
[16:12:46.350]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.350]                         if (muffled) 
[16:12:46.350]                           invokeRestart("muffleMessage")
[16:12:46.350]                       }
[16:12:46.350]                       else if (inherits(cond, "warning")) {
[16:12:46.350]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.350]                         if (muffled) 
[16:12:46.350]                           invokeRestart("muffleWarning")
[16:12:46.350]                       }
[16:12:46.350]                       else if (inherits(cond, "condition")) {
[16:12:46.350]                         if (!is.null(pattern)) {
[16:12:46.350]                           computeRestarts <- base::computeRestarts
[16:12:46.350]                           grepl <- base::grepl
[16:12:46.350]                           restarts <- computeRestarts(cond)
[16:12:46.350]                           for (restart in restarts) {
[16:12:46.350]                             name <- restart$name
[16:12:46.350]                             if (is.null(name)) 
[16:12:46.350]                               next
[16:12:46.350]                             if (!grepl(pattern, name)) 
[16:12:46.350]                               next
[16:12:46.350]                             invokeRestart(restart)
[16:12:46.350]                             muffled <- TRUE
[16:12:46.350]                             break
[16:12:46.350]                           }
[16:12:46.350]                         }
[16:12:46.350]                       }
[16:12:46.350]                       invisible(muffled)
[16:12:46.350]                     }
[16:12:46.350]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.350]                   }
[16:12:46.350]                 }
[16:12:46.350]                 else {
[16:12:46.350]                   if (TRUE) {
[16:12:46.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.350]                     {
[16:12:46.350]                       inherits <- base::inherits
[16:12:46.350]                       invokeRestart <- base::invokeRestart
[16:12:46.350]                       is.null <- base::is.null
[16:12:46.350]                       muffled <- FALSE
[16:12:46.350]                       if (inherits(cond, "message")) {
[16:12:46.350]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.350]                         if (muffled) 
[16:12:46.350]                           invokeRestart("muffleMessage")
[16:12:46.350]                       }
[16:12:46.350]                       else if (inherits(cond, "warning")) {
[16:12:46.350]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.350]                         if (muffled) 
[16:12:46.350]                           invokeRestart("muffleWarning")
[16:12:46.350]                       }
[16:12:46.350]                       else if (inherits(cond, "condition")) {
[16:12:46.350]                         if (!is.null(pattern)) {
[16:12:46.350]                           computeRestarts <- base::computeRestarts
[16:12:46.350]                           grepl <- base::grepl
[16:12:46.350]                           restarts <- computeRestarts(cond)
[16:12:46.350]                           for (restart in restarts) {
[16:12:46.350]                             name <- restart$name
[16:12:46.350]                             if (is.null(name)) 
[16:12:46.350]                               next
[16:12:46.350]                             if (!grepl(pattern, name)) 
[16:12:46.350]                               next
[16:12:46.350]                             invokeRestart(restart)
[16:12:46.350]                             muffled <- TRUE
[16:12:46.350]                             break
[16:12:46.350]                           }
[16:12:46.350]                         }
[16:12:46.350]                       }
[16:12:46.350]                       invisible(muffled)
[16:12:46.350]                     }
[16:12:46.350]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.350]                   }
[16:12:46.350]                 }
[16:12:46.350]             }
[16:12:46.350]         }))
[16:12:46.350]     }, error = function(ex) {
[16:12:46.350]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.350]                 ...future.rng), started = ...future.startTime, 
[16:12:46.350]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.350]             version = "1.8"), class = "FutureResult")
[16:12:46.350]     }, finally = {
[16:12:46.350]         if (!identical(...future.workdir, getwd())) 
[16:12:46.350]             setwd(...future.workdir)
[16:12:46.350]         {
[16:12:46.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.350]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.350]             }
[16:12:46.350]             base::options(...future.oldOptions)
[16:12:46.350]             if (.Platform$OS.type == "windows") {
[16:12:46.350]                 old_names <- names(...future.oldEnvVars)
[16:12:46.350]                 envs <- base::Sys.getenv()
[16:12:46.350]                 names <- names(envs)
[16:12:46.350]                 common <- intersect(names, old_names)
[16:12:46.350]                 added <- setdiff(names, old_names)
[16:12:46.350]                 removed <- setdiff(old_names, names)
[16:12:46.350]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.350]                   envs[common]]
[16:12:46.350]                 NAMES <- toupper(changed)
[16:12:46.350]                 args <- list()
[16:12:46.350]                 for (kk in seq_along(NAMES)) {
[16:12:46.350]                   name <- changed[[kk]]
[16:12:46.350]                   NAME <- NAMES[[kk]]
[16:12:46.350]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.350]                     next
[16:12:46.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.350]                 }
[16:12:46.350]                 NAMES <- toupper(added)
[16:12:46.350]                 for (kk in seq_along(NAMES)) {
[16:12:46.350]                   name <- added[[kk]]
[16:12:46.350]                   NAME <- NAMES[[kk]]
[16:12:46.350]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.350]                     next
[16:12:46.350]                   args[[name]] <- ""
[16:12:46.350]                 }
[16:12:46.350]                 NAMES <- toupper(removed)
[16:12:46.350]                 for (kk in seq_along(NAMES)) {
[16:12:46.350]                   name <- removed[[kk]]
[16:12:46.350]                   NAME <- NAMES[[kk]]
[16:12:46.350]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.350]                     next
[16:12:46.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.350]                 }
[16:12:46.350]                 if (length(args) > 0) 
[16:12:46.350]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.350]             }
[16:12:46.350]             else {
[16:12:46.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.350]             }
[16:12:46.350]             {
[16:12:46.350]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.350]                   0L) {
[16:12:46.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.350]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.350]                   base::options(opts)
[16:12:46.350]                 }
[16:12:46.350]                 {
[16:12:46.350]                   {
[16:12:46.350]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.350]                     NULL
[16:12:46.350]                   }
[16:12:46.350]                   options(future.plan = NULL)
[16:12:46.350]                   if (is.na(NA_character_)) 
[16:12:46.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.350]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.350]                     envir = parent.frame()) 
[16:12:46.350]                   {
[16:12:46.350]                     default_workers <- missing(workers)
[16:12:46.350]                     if (is.function(workers)) 
[16:12:46.350]                       workers <- workers()
[16:12:46.350]                     workers <- structure(as.integer(workers), 
[16:12:46.350]                       class = class(workers))
[16:12:46.350]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.350]                       1L)
[16:12:46.350]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.350]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.350]                       if (default_workers) 
[16:12:46.350]                         supportsMulticore(warn = TRUE)
[16:12:46.350]                       return(sequential(..., envir = envir))
[16:12:46.350]                     }
[16:12:46.350]                     oopts <- options(mc.cores = workers)
[16:12:46.350]                     on.exit(options(oopts))
[16:12:46.350]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.350]                       envir = envir)
[16:12:46.350]                     if (!future$lazy) 
[16:12:46.350]                       future <- run(future)
[16:12:46.350]                     invisible(future)
[16:12:46.350]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.350]                 }
[16:12:46.350]             }
[16:12:46.350]         }
[16:12:46.350]     })
[16:12:46.350]     if (TRUE) {
[16:12:46.350]         base::sink(type = "output", split = FALSE)
[16:12:46.350]         if (TRUE) {
[16:12:46.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.350]         }
[16:12:46.350]         else {
[16:12:46.350]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.350]         }
[16:12:46.350]         base::close(...future.stdout)
[16:12:46.350]         ...future.stdout <- NULL
[16:12:46.350]     }
[16:12:46.350]     ...future.result$conditions <- ...future.conditions
[16:12:46.350]     ...future.result$finished <- base::Sys.time()
[16:12:46.350]     ...future.result
[16:12:46.350] }
[16:12:46.353] assign_globals() ...
[16:12:46.353] List of 1
[16:12:46.353]  $ x: list()
[16:12:46.353]  - attr(*, "where")=List of 1
[16:12:46.353]   ..$ x:<environment: R_EmptyEnv> 
[16:12:46.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:46.353]  - attr(*, "resolved")= logi TRUE
[16:12:46.353]  - attr(*, "total_size")= num 0
[16:12:46.353]  - attr(*, "already-done")= logi TRUE
[16:12:46.356] - copied ‘x’ to environment
[16:12:46.356] assign_globals() ... done
[16:12:46.356] requestCore(): workers = 2
[16:12:46.358] MulticoreFuture started
[16:12:46.358] - Launch lazy future ... done
[16:12:46.359] run() for ‘MulticoreFuture’ ... done
[16:12:46.359] plan(): Setting new future strategy stack:
[16:12:46.359] List of future strategies:
[16:12:46.359] 1. sequential:
[16:12:46.359]    - args: function (..., envir = parent.frame())
[16:12:46.359]    - tweaked: FALSE
[16:12:46.359]    - call: NULL
[16:12:46.360] plan(): nbrOfWorkers() = 1
[16:12:46.362] plan(): Setting new future strategy stack:
[16:12:46.362] List of future strategies:
[16:12:46.362] 1. multicore:
[16:12:46.362]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.362]    - tweaked: FALSE
[16:12:46.362]    - call: plan(strategy)
[16:12:46.367] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.369] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.369] Searching for globals...
[16:12:46.372] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:46.372] Searching for globals ... DONE
[16:12:46.372] Resolving globals: TRUE
[16:12:46.372] Resolving any globals that are futures ...
[16:12:46.372] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:46.372] Resolving any globals that are futures ... DONE
[16:12:46.373] Resolving futures part of globals (recursively) ...
[16:12:46.373] resolve() on list ...
[16:12:46.373]  recursive: 99
[16:12:46.374]  length: 1
[16:12:46.374]  elements: ‘x’
[16:12:46.374]  length: 0 (resolved future 1)
[16:12:46.374] resolve() on list ... DONE
[16:12:46.374] - globals: [1] ‘x’
[16:12:46.374] Resolving futures part of globals (recursively) ... DONE
[16:12:46.374] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:46.375] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:46.375] - globals: [1] ‘x’
[16:12:46.375] 
[16:12:46.375] getGlobalsAndPackages() ... DONE
[16:12:46.376] run() for ‘Future’ ...
[16:12:46.376] - state: ‘created’
[16:12:46.376] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.380] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.380]   - Field: ‘label’
[16:12:46.380]   - Field: ‘local’
[16:12:46.380]   - Field: ‘owner’
[16:12:46.380]   - Field: ‘envir’
[16:12:46.381]   - Field: ‘workers’
[16:12:46.381]   - Field: ‘packages’
[16:12:46.381]   - Field: ‘gc’
[16:12:46.383]   - Field: ‘job’
[16:12:46.383]   - Field: ‘conditions’
[16:12:46.384]   - Field: ‘expr’
[16:12:46.384]   - Field: ‘uuid’
[16:12:46.384]   - Field: ‘seed’
[16:12:46.384]   - Field: ‘version’
[16:12:46.384]   - Field: ‘result’
[16:12:46.384]   - Field: ‘asynchronous’
[16:12:46.384]   - Field: ‘calls’
[16:12:46.384]   - Field: ‘globals’
[16:12:46.385]   - Field: ‘stdout’
[16:12:46.385]   - Field: ‘earlySignal’
[16:12:46.385]   - Field: ‘lazy’
[16:12:46.385]   - Field: ‘state’
[16:12:46.385] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.385] - Launch lazy future ...
[16:12:46.386] Packages needed by the future expression (n = 0): <none>
[16:12:46.386] Packages needed by future strategies (n = 0): <none>
[16:12:46.386] {
[16:12:46.386]     {
[16:12:46.386]         {
[16:12:46.386]             ...future.startTime <- base::Sys.time()
[16:12:46.386]             {
[16:12:46.386]                 {
[16:12:46.386]                   {
[16:12:46.386]                     {
[16:12:46.386]                       base::local({
[16:12:46.386]                         has_future <- base::requireNamespace("future", 
[16:12:46.386]                           quietly = TRUE)
[16:12:46.386]                         if (has_future) {
[16:12:46.386]                           ns <- base::getNamespace("future")
[16:12:46.386]                           version <- ns[[".package"]][["version"]]
[16:12:46.386]                           if (is.null(version)) 
[16:12:46.386]                             version <- utils::packageVersion("future")
[16:12:46.386]                         }
[16:12:46.386]                         else {
[16:12:46.386]                           version <- NULL
[16:12:46.386]                         }
[16:12:46.386]                         if (!has_future || version < "1.8.0") {
[16:12:46.386]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.386]                             "", base::R.version$version.string), 
[16:12:46.386]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.386]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.386]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.386]                               "release", "version")], collapse = " "), 
[16:12:46.386]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.386]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.386]                             info)
[16:12:46.386]                           info <- base::paste(info, collapse = "; ")
[16:12:46.386]                           if (!has_future) {
[16:12:46.386]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.386]                               info)
[16:12:46.386]                           }
[16:12:46.386]                           else {
[16:12:46.386]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.386]                               info, version)
[16:12:46.386]                           }
[16:12:46.386]                           base::stop(msg)
[16:12:46.386]                         }
[16:12:46.386]                       })
[16:12:46.386]                     }
[16:12:46.386]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.386]                     base::options(mc.cores = 1L)
[16:12:46.386]                   }
[16:12:46.386]                   options(future.plan = NULL)
[16:12:46.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.386]                 }
[16:12:46.386]                 ...future.workdir <- getwd()
[16:12:46.386]             }
[16:12:46.386]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.386]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.386]         }
[16:12:46.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.386]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.386]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.386]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.386]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.386]             base::names(...future.oldOptions))
[16:12:46.386]     }
[16:12:46.386]     if (FALSE) {
[16:12:46.386]     }
[16:12:46.386]     else {
[16:12:46.386]         if (TRUE) {
[16:12:46.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.386]                 open = "w")
[16:12:46.386]         }
[16:12:46.386]         else {
[16:12:46.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.386]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.386]         }
[16:12:46.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.386]             base::sink(type = "output", split = FALSE)
[16:12:46.386]             base::close(...future.stdout)
[16:12:46.386]         }, add = TRUE)
[16:12:46.386]     }
[16:12:46.386]     ...future.frame <- base::sys.nframe()
[16:12:46.386]     ...future.conditions <- base::list()
[16:12:46.386]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.386]     if (FALSE) {
[16:12:46.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.386]     }
[16:12:46.386]     ...future.result <- base::tryCatch({
[16:12:46.386]         base::withCallingHandlers({
[16:12:46.386]             ...future.value <- base::withVisible(base::local({
[16:12:46.386]                 withCallingHandlers({
[16:12:46.386]                   {
[16:12:46.386]                     x["a"] <- list(1)
[16:12:46.386]                     x
[16:12:46.386]                   }
[16:12:46.386]                 }, immediateCondition = function(cond) {
[16:12:46.386]                   save_rds <- function (object, pathname, ...) 
[16:12:46.386]                   {
[16:12:46.386]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.386]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.386]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.386]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.386]                         fi_tmp[["mtime"]])
[16:12:46.386]                     }
[16:12:46.386]                     tryCatch({
[16:12:46.386]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.386]                     }, error = function(ex) {
[16:12:46.386]                       msg <- conditionMessage(ex)
[16:12:46.386]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.386]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.386]                         fi_tmp[["mtime"]], msg)
[16:12:46.386]                       ex$message <- msg
[16:12:46.386]                       stop(ex)
[16:12:46.386]                     })
[16:12:46.386]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.386]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.386]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.386]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.386]                       fi <- file.info(pathname)
[16:12:46.386]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.386]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.386]                         fi[["size"]], fi[["mtime"]])
[16:12:46.386]                       stop(msg)
[16:12:46.386]                     }
[16:12:46.386]                     invisible(pathname)
[16:12:46.386]                   }
[16:12:46.386]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.386]                     rootPath = tempdir()) 
[16:12:46.386]                   {
[16:12:46.386]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.386]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.386]                       tmpdir = path, fileext = ".rds")
[16:12:46.386]                     save_rds(obj, file)
[16:12:46.386]                   }
[16:12:46.386]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.386]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.386]                   {
[16:12:46.386]                     inherits <- base::inherits
[16:12:46.386]                     invokeRestart <- base::invokeRestart
[16:12:46.386]                     is.null <- base::is.null
[16:12:46.386]                     muffled <- FALSE
[16:12:46.386]                     if (inherits(cond, "message")) {
[16:12:46.386]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.386]                       if (muffled) 
[16:12:46.386]                         invokeRestart("muffleMessage")
[16:12:46.386]                     }
[16:12:46.386]                     else if (inherits(cond, "warning")) {
[16:12:46.386]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.386]                       if (muffled) 
[16:12:46.386]                         invokeRestart("muffleWarning")
[16:12:46.386]                     }
[16:12:46.386]                     else if (inherits(cond, "condition")) {
[16:12:46.386]                       if (!is.null(pattern)) {
[16:12:46.386]                         computeRestarts <- base::computeRestarts
[16:12:46.386]                         grepl <- base::grepl
[16:12:46.386]                         restarts <- computeRestarts(cond)
[16:12:46.386]                         for (restart in restarts) {
[16:12:46.386]                           name <- restart$name
[16:12:46.386]                           if (is.null(name)) 
[16:12:46.386]                             next
[16:12:46.386]                           if (!grepl(pattern, name)) 
[16:12:46.386]                             next
[16:12:46.386]                           invokeRestart(restart)
[16:12:46.386]                           muffled <- TRUE
[16:12:46.386]                           break
[16:12:46.386]                         }
[16:12:46.386]                       }
[16:12:46.386]                     }
[16:12:46.386]                     invisible(muffled)
[16:12:46.386]                   }
[16:12:46.386]                   muffleCondition(cond)
[16:12:46.386]                 })
[16:12:46.386]             }))
[16:12:46.386]             future::FutureResult(value = ...future.value$value, 
[16:12:46.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.386]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.386]                     ...future.globalenv.names))
[16:12:46.386]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.386]         }, condition = base::local({
[16:12:46.386]             c <- base::c
[16:12:46.386]             inherits <- base::inherits
[16:12:46.386]             invokeRestart <- base::invokeRestart
[16:12:46.386]             length <- base::length
[16:12:46.386]             list <- base::list
[16:12:46.386]             seq.int <- base::seq.int
[16:12:46.386]             signalCondition <- base::signalCondition
[16:12:46.386]             sys.calls <- base::sys.calls
[16:12:46.386]             `[[` <- base::`[[`
[16:12:46.386]             `+` <- base::`+`
[16:12:46.386]             `<<-` <- base::`<<-`
[16:12:46.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.386]                   3L)]
[16:12:46.386]             }
[16:12:46.386]             function(cond) {
[16:12:46.386]                 is_error <- inherits(cond, "error")
[16:12:46.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.386]                   NULL)
[16:12:46.386]                 if (is_error) {
[16:12:46.386]                   sessionInformation <- function() {
[16:12:46.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.386]                       search = base::search(), system = base::Sys.info())
[16:12:46.386]                   }
[16:12:46.386]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.386]                     cond$call), session = sessionInformation(), 
[16:12:46.386]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.386]                   signalCondition(cond)
[16:12:46.386]                 }
[16:12:46.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.386]                 "immediateCondition"))) {
[16:12:46.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.386]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.386]                   if (TRUE && !signal) {
[16:12:46.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.386]                     {
[16:12:46.386]                       inherits <- base::inherits
[16:12:46.386]                       invokeRestart <- base::invokeRestart
[16:12:46.386]                       is.null <- base::is.null
[16:12:46.386]                       muffled <- FALSE
[16:12:46.386]                       if (inherits(cond, "message")) {
[16:12:46.386]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.386]                         if (muffled) 
[16:12:46.386]                           invokeRestart("muffleMessage")
[16:12:46.386]                       }
[16:12:46.386]                       else if (inherits(cond, "warning")) {
[16:12:46.386]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.386]                         if (muffled) 
[16:12:46.386]                           invokeRestart("muffleWarning")
[16:12:46.386]                       }
[16:12:46.386]                       else if (inherits(cond, "condition")) {
[16:12:46.386]                         if (!is.null(pattern)) {
[16:12:46.386]                           computeRestarts <- base::computeRestarts
[16:12:46.386]                           grepl <- base::grepl
[16:12:46.386]                           restarts <- computeRestarts(cond)
[16:12:46.386]                           for (restart in restarts) {
[16:12:46.386]                             name <- restart$name
[16:12:46.386]                             if (is.null(name)) 
[16:12:46.386]                               next
[16:12:46.386]                             if (!grepl(pattern, name)) 
[16:12:46.386]                               next
[16:12:46.386]                             invokeRestart(restart)
[16:12:46.386]                             muffled <- TRUE
[16:12:46.386]                             break
[16:12:46.386]                           }
[16:12:46.386]                         }
[16:12:46.386]                       }
[16:12:46.386]                       invisible(muffled)
[16:12:46.386]                     }
[16:12:46.386]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.386]                   }
[16:12:46.386]                 }
[16:12:46.386]                 else {
[16:12:46.386]                   if (TRUE) {
[16:12:46.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.386]                     {
[16:12:46.386]                       inherits <- base::inherits
[16:12:46.386]                       invokeRestart <- base::invokeRestart
[16:12:46.386]                       is.null <- base::is.null
[16:12:46.386]                       muffled <- FALSE
[16:12:46.386]                       if (inherits(cond, "message")) {
[16:12:46.386]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.386]                         if (muffled) 
[16:12:46.386]                           invokeRestart("muffleMessage")
[16:12:46.386]                       }
[16:12:46.386]                       else if (inherits(cond, "warning")) {
[16:12:46.386]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.386]                         if (muffled) 
[16:12:46.386]                           invokeRestart("muffleWarning")
[16:12:46.386]                       }
[16:12:46.386]                       else if (inherits(cond, "condition")) {
[16:12:46.386]                         if (!is.null(pattern)) {
[16:12:46.386]                           computeRestarts <- base::computeRestarts
[16:12:46.386]                           grepl <- base::grepl
[16:12:46.386]                           restarts <- computeRestarts(cond)
[16:12:46.386]                           for (restart in restarts) {
[16:12:46.386]                             name <- restart$name
[16:12:46.386]                             if (is.null(name)) 
[16:12:46.386]                               next
[16:12:46.386]                             if (!grepl(pattern, name)) 
[16:12:46.386]                               next
[16:12:46.386]                             invokeRestart(restart)
[16:12:46.386]                             muffled <- TRUE
[16:12:46.386]                             break
[16:12:46.386]                           }
[16:12:46.386]                         }
[16:12:46.386]                       }
[16:12:46.386]                       invisible(muffled)
[16:12:46.386]                     }
[16:12:46.386]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.386]                   }
[16:12:46.386]                 }
[16:12:46.386]             }
[16:12:46.386]         }))
[16:12:46.386]     }, error = function(ex) {
[16:12:46.386]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.386]                 ...future.rng), started = ...future.startTime, 
[16:12:46.386]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.386]             version = "1.8"), class = "FutureResult")
[16:12:46.386]     }, finally = {
[16:12:46.386]         if (!identical(...future.workdir, getwd())) 
[16:12:46.386]             setwd(...future.workdir)
[16:12:46.386]         {
[16:12:46.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.386]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.386]             }
[16:12:46.386]             base::options(...future.oldOptions)
[16:12:46.386]             if (.Platform$OS.type == "windows") {
[16:12:46.386]                 old_names <- names(...future.oldEnvVars)
[16:12:46.386]                 envs <- base::Sys.getenv()
[16:12:46.386]                 names <- names(envs)
[16:12:46.386]                 common <- intersect(names, old_names)
[16:12:46.386]                 added <- setdiff(names, old_names)
[16:12:46.386]                 removed <- setdiff(old_names, names)
[16:12:46.386]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.386]                   envs[common]]
[16:12:46.386]                 NAMES <- toupper(changed)
[16:12:46.386]                 args <- list()
[16:12:46.386]                 for (kk in seq_along(NAMES)) {
[16:12:46.386]                   name <- changed[[kk]]
[16:12:46.386]                   NAME <- NAMES[[kk]]
[16:12:46.386]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.386]                     next
[16:12:46.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.386]                 }
[16:12:46.386]                 NAMES <- toupper(added)
[16:12:46.386]                 for (kk in seq_along(NAMES)) {
[16:12:46.386]                   name <- added[[kk]]
[16:12:46.386]                   NAME <- NAMES[[kk]]
[16:12:46.386]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.386]                     next
[16:12:46.386]                   args[[name]] <- ""
[16:12:46.386]                 }
[16:12:46.386]                 NAMES <- toupper(removed)
[16:12:46.386]                 for (kk in seq_along(NAMES)) {
[16:12:46.386]                   name <- removed[[kk]]
[16:12:46.386]                   NAME <- NAMES[[kk]]
[16:12:46.386]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.386]                     next
[16:12:46.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.386]                 }
[16:12:46.386]                 if (length(args) > 0) 
[16:12:46.386]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.386]             }
[16:12:46.386]             else {
[16:12:46.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.386]             }
[16:12:46.386]             {
[16:12:46.386]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.386]                   0L) {
[16:12:46.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.386]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.386]                   base::options(opts)
[16:12:46.386]                 }
[16:12:46.386]                 {
[16:12:46.386]                   {
[16:12:46.386]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.386]                     NULL
[16:12:46.386]                   }
[16:12:46.386]                   options(future.plan = NULL)
[16:12:46.386]                   if (is.na(NA_character_)) 
[16:12:46.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.386]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.386]                     envir = parent.frame()) 
[16:12:46.386]                   {
[16:12:46.386]                     default_workers <- missing(workers)
[16:12:46.386]                     if (is.function(workers)) 
[16:12:46.386]                       workers <- workers()
[16:12:46.386]                     workers <- structure(as.integer(workers), 
[16:12:46.386]                       class = class(workers))
[16:12:46.386]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.386]                       1L)
[16:12:46.386]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.386]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.386]                       if (default_workers) 
[16:12:46.386]                         supportsMulticore(warn = TRUE)
[16:12:46.386]                       return(sequential(..., envir = envir))
[16:12:46.386]                     }
[16:12:46.386]                     oopts <- options(mc.cores = workers)
[16:12:46.386]                     on.exit(options(oopts))
[16:12:46.386]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.386]                       envir = envir)
[16:12:46.386]                     if (!future$lazy) 
[16:12:46.386]                       future <- run(future)
[16:12:46.386]                     invisible(future)
[16:12:46.386]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.386]                 }
[16:12:46.386]             }
[16:12:46.386]         }
[16:12:46.386]     })
[16:12:46.386]     if (TRUE) {
[16:12:46.386]         base::sink(type = "output", split = FALSE)
[16:12:46.386]         if (TRUE) {
[16:12:46.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.386]         }
[16:12:46.386]         else {
[16:12:46.386]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.386]         }
[16:12:46.386]         base::close(...future.stdout)
[16:12:46.386]         ...future.stdout <- NULL
[16:12:46.386]     }
[16:12:46.386]     ...future.result$conditions <- ...future.conditions
[16:12:46.386]     ...future.result$finished <- base::Sys.time()
[16:12:46.386]     ...future.result
[16:12:46.386] }
[16:12:46.389] assign_globals() ...
[16:12:46.389] List of 1
[16:12:46.389]  $ x: list()
[16:12:46.389]  - attr(*, "where")=List of 1
[16:12:46.389]   ..$ x:<environment: R_EmptyEnv> 
[16:12:46.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:46.389]  - attr(*, "resolved")= logi TRUE
[16:12:46.389]  - attr(*, "total_size")= num 0
[16:12:46.389]  - attr(*, "already-done")= logi TRUE
[16:12:46.392] - copied ‘x’ to environment
[16:12:46.392] assign_globals() ... done
[16:12:46.392] requestCore(): workers = 2
[16:12:46.394] MulticoreFuture started
[16:12:46.395] - Launch lazy future ... done
[16:12:46.395] run() for ‘MulticoreFuture’ ... done
[16:12:46.395] plan(): Setting new future strategy stack:
[16:12:46.396] List of future strategies:
[16:12:46.396] 1. sequential:
[16:12:46.396]    - args: function (..., envir = parent.frame())
[16:12:46.396]    - tweaked: FALSE
[16:12:46.396]    - call: NULL
[16:12:46.397] plan(): nbrOfWorkers() = 1
[16:12:46.399] plan(): Setting new future strategy stack:
[16:12:46.399] List of future strategies:
[16:12:46.399] 1. multicore:
[16:12:46.399]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.399]    - tweaked: FALSE
[16:12:46.399]    - call: plan(strategy)
[16:12:46.404] plan(): nbrOfWorkers() = 2
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.405] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.405] Searching for globals...
[16:12:46.408] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:12:46.409] Searching for globals ... DONE
[16:12:46.409] Resolving globals: TRUE
[16:12:46.409] Resolving any globals that are futures ...
[16:12:46.409] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:12:46.409] Resolving any globals that are futures ... DONE
[16:12:46.410] Resolving futures part of globals (recursively) ...
[16:12:46.410] resolve() on list ...
[16:12:46.410]  recursive: 99
[16:12:46.410]  length: 2
[16:12:46.410]  elements: ‘x’, ‘name’
[16:12:46.411]  length: 1 (resolved future 1)
[16:12:46.411]  length: 0 (resolved future 2)
[16:12:46.411] resolve() on list ... DONE
[16:12:46.411] - globals: [2] ‘x’, ‘name’
[16:12:46.411] Resolving futures part of globals (recursively) ... DONE
[16:12:46.411] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:46.412] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[16:12:46.412] - globals: [2] ‘x’, ‘name’
[16:12:46.412] 
[16:12:46.412] getGlobalsAndPackages() ... DONE
[16:12:46.413] run() for ‘Future’ ...
[16:12:46.413] - state: ‘created’
[16:12:46.413] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:46.417] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:46.417] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:46.417]   - Field: ‘label’
[16:12:46.417]   - Field: ‘local’
[16:12:46.417]   - Field: ‘owner’
[16:12:46.417]   - Field: ‘envir’
[16:12:46.418]   - Field: ‘workers’
[16:12:46.418]   - Field: ‘packages’
[16:12:46.418]   - Field: ‘gc’
[16:12:46.418]   - Field: ‘job’
[16:12:46.418]   - Field: ‘conditions’
[16:12:46.418]   - Field: ‘expr’
[16:12:46.418]   - Field: ‘uuid’
[16:12:46.418]   - Field: ‘seed’
[16:12:46.419]   - Field: ‘version’
[16:12:46.419]   - Field: ‘result’
[16:12:46.419]   - Field: ‘asynchronous’
[16:12:46.419]   - Field: ‘calls’
[16:12:46.419]   - Field: ‘globals’
[16:12:46.419]   - Field: ‘stdout’
[16:12:46.419]   - Field: ‘earlySignal’
[16:12:46.419]   - Field: ‘lazy’
[16:12:46.419]   - Field: ‘state’
[16:12:46.419] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:46.420] - Launch lazy future ...
[16:12:46.420] Packages needed by the future expression (n = 0): <none>
[16:12:46.420] Packages needed by future strategies (n = 0): <none>
[16:12:46.421] {
[16:12:46.421]     {
[16:12:46.421]         {
[16:12:46.421]             ...future.startTime <- base::Sys.time()
[16:12:46.421]             {
[16:12:46.421]                 {
[16:12:46.421]                   {
[16:12:46.421]                     {
[16:12:46.421]                       base::local({
[16:12:46.421]                         has_future <- base::requireNamespace("future", 
[16:12:46.421]                           quietly = TRUE)
[16:12:46.421]                         if (has_future) {
[16:12:46.421]                           ns <- base::getNamespace("future")
[16:12:46.421]                           version <- ns[[".package"]][["version"]]
[16:12:46.421]                           if (is.null(version)) 
[16:12:46.421]                             version <- utils::packageVersion("future")
[16:12:46.421]                         }
[16:12:46.421]                         else {
[16:12:46.421]                           version <- NULL
[16:12:46.421]                         }
[16:12:46.421]                         if (!has_future || version < "1.8.0") {
[16:12:46.421]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.421]                             "", base::R.version$version.string), 
[16:12:46.421]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.421]                               "release", "version")], collapse = " "), 
[16:12:46.421]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.421]                             info)
[16:12:46.421]                           info <- base::paste(info, collapse = "; ")
[16:12:46.421]                           if (!has_future) {
[16:12:46.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.421]                               info)
[16:12:46.421]                           }
[16:12:46.421]                           else {
[16:12:46.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.421]                               info, version)
[16:12:46.421]                           }
[16:12:46.421]                           base::stop(msg)
[16:12:46.421]                         }
[16:12:46.421]                       })
[16:12:46.421]                     }
[16:12:46.421]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.421]                     base::options(mc.cores = 1L)
[16:12:46.421]                   }
[16:12:46.421]                   options(future.plan = NULL)
[16:12:46.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.421]                 }
[16:12:46.421]                 ...future.workdir <- getwd()
[16:12:46.421]             }
[16:12:46.421]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.421]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.421]         }
[16:12:46.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.421]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.421]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.421]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.421]             base::names(...future.oldOptions))
[16:12:46.421]     }
[16:12:46.421]     if (FALSE) {
[16:12:46.421]     }
[16:12:46.421]     else {
[16:12:46.421]         if (TRUE) {
[16:12:46.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.421]                 open = "w")
[16:12:46.421]         }
[16:12:46.421]         else {
[16:12:46.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.421]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.421]         }
[16:12:46.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.421]             base::sink(type = "output", split = FALSE)
[16:12:46.421]             base::close(...future.stdout)
[16:12:46.421]         }, add = TRUE)
[16:12:46.421]     }
[16:12:46.421]     ...future.frame <- base::sys.nframe()
[16:12:46.421]     ...future.conditions <- base::list()
[16:12:46.421]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.421]     if (FALSE) {
[16:12:46.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.421]     }
[16:12:46.421]     ...future.result <- base::tryCatch({
[16:12:46.421]         base::withCallingHandlers({
[16:12:46.421]             ...future.value <- base::withVisible(base::local({
[16:12:46.421]                 withCallingHandlers({
[16:12:46.421]                   {
[16:12:46.421]                     x[name] <- list(1)
[16:12:46.421]                     x
[16:12:46.421]                   }
[16:12:46.421]                 }, immediateCondition = function(cond) {
[16:12:46.421]                   save_rds <- function (object, pathname, ...) 
[16:12:46.421]                   {
[16:12:46.421]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:46.421]                     if (file_test("-f", pathname_tmp)) {
[16:12:46.421]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.421]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:46.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.421]                         fi_tmp[["mtime"]])
[16:12:46.421]                     }
[16:12:46.421]                     tryCatch({
[16:12:46.421]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:46.421]                     }, error = function(ex) {
[16:12:46.421]                       msg <- conditionMessage(ex)
[16:12:46.421]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.421]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:46.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.421]                         fi_tmp[["mtime"]], msg)
[16:12:46.421]                       ex$message <- msg
[16:12:46.421]                       stop(ex)
[16:12:46.421]                     })
[16:12:46.421]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:46.421]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:46.421]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:46.421]                       fi_tmp <- file.info(pathname_tmp)
[16:12:46.421]                       fi <- file.info(pathname)
[16:12:46.421]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:46.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:46.421]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:46.421]                         fi[["size"]], fi[["mtime"]])
[16:12:46.421]                       stop(msg)
[16:12:46.421]                     }
[16:12:46.421]                     invisible(pathname)
[16:12:46.421]                   }
[16:12:46.421]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:46.421]                     rootPath = tempdir()) 
[16:12:46.421]                   {
[16:12:46.421]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:46.421]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:46.421]                       tmpdir = path, fileext = ".rds")
[16:12:46.421]                     save_rds(obj, file)
[16:12:46.421]                   }
[16:12:46.421]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6FOJop/.future/immediateConditions")
[16:12:46.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.421]                   {
[16:12:46.421]                     inherits <- base::inherits
[16:12:46.421]                     invokeRestart <- base::invokeRestart
[16:12:46.421]                     is.null <- base::is.null
[16:12:46.421]                     muffled <- FALSE
[16:12:46.421]                     if (inherits(cond, "message")) {
[16:12:46.421]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.421]                       if (muffled) 
[16:12:46.421]                         invokeRestart("muffleMessage")
[16:12:46.421]                     }
[16:12:46.421]                     else if (inherits(cond, "warning")) {
[16:12:46.421]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.421]                       if (muffled) 
[16:12:46.421]                         invokeRestart("muffleWarning")
[16:12:46.421]                     }
[16:12:46.421]                     else if (inherits(cond, "condition")) {
[16:12:46.421]                       if (!is.null(pattern)) {
[16:12:46.421]                         computeRestarts <- base::computeRestarts
[16:12:46.421]                         grepl <- base::grepl
[16:12:46.421]                         restarts <- computeRestarts(cond)
[16:12:46.421]                         for (restart in restarts) {
[16:12:46.421]                           name <- restart$name
[16:12:46.421]                           if (is.null(name)) 
[16:12:46.421]                             next
[16:12:46.421]                           if (!grepl(pattern, name)) 
[16:12:46.421]                             next
[16:12:46.421]                           invokeRestart(restart)
[16:12:46.421]                           muffled <- TRUE
[16:12:46.421]                           break
[16:12:46.421]                         }
[16:12:46.421]                       }
[16:12:46.421]                     }
[16:12:46.421]                     invisible(muffled)
[16:12:46.421]                   }
[16:12:46.421]                   muffleCondition(cond)
[16:12:46.421]                 })
[16:12:46.421]             }))
[16:12:46.421]             future::FutureResult(value = ...future.value$value, 
[16:12:46.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.421]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.421]                     ...future.globalenv.names))
[16:12:46.421]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.421]         }, condition = base::local({
[16:12:46.421]             c <- base::c
[16:12:46.421]             inherits <- base::inherits
[16:12:46.421]             invokeRestart <- base::invokeRestart
[16:12:46.421]             length <- base::length
[16:12:46.421]             list <- base::list
[16:12:46.421]             seq.int <- base::seq.int
[16:12:46.421]             signalCondition <- base::signalCondition
[16:12:46.421]             sys.calls <- base::sys.calls
[16:12:46.421]             `[[` <- base::`[[`
[16:12:46.421]             `+` <- base::`+`
[16:12:46.421]             `<<-` <- base::`<<-`
[16:12:46.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.421]                   3L)]
[16:12:46.421]             }
[16:12:46.421]             function(cond) {
[16:12:46.421]                 is_error <- inherits(cond, "error")
[16:12:46.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.421]                   NULL)
[16:12:46.421]                 if (is_error) {
[16:12:46.421]                   sessionInformation <- function() {
[16:12:46.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.421]                       search = base::search(), system = base::Sys.info())
[16:12:46.421]                   }
[16:12:46.421]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.421]                     cond$call), session = sessionInformation(), 
[16:12:46.421]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.421]                   signalCondition(cond)
[16:12:46.421]                 }
[16:12:46.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.421]                 "immediateCondition"))) {
[16:12:46.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.421]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.421]                   if (TRUE && !signal) {
[16:12:46.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.421]                     {
[16:12:46.421]                       inherits <- base::inherits
[16:12:46.421]                       invokeRestart <- base::invokeRestart
[16:12:46.421]                       is.null <- base::is.null
[16:12:46.421]                       muffled <- FALSE
[16:12:46.421]                       if (inherits(cond, "message")) {
[16:12:46.421]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.421]                         if (muffled) 
[16:12:46.421]                           invokeRestart("muffleMessage")
[16:12:46.421]                       }
[16:12:46.421]                       else if (inherits(cond, "warning")) {
[16:12:46.421]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.421]                         if (muffled) 
[16:12:46.421]                           invokeRestart("muffleWarning")
[16:12:46.421]                       }
[16:12:46.421]                       else if (inherits(cond, "condition")) {
[16:12:46.421]                         if (!is.null(pattern)) {
[16:12:46.421]                           computeRestarts <- base::computeRestarts
[16:12:46.421]                           grepl <- base::grepl
[16:12:46.421]                           restarts <- computeRestarts(cond)
[16:12:46.421]                           for (restart in restarts) {
[16:12:46.421]                             name <- restart$name
[16:12:46.421]                             if (is.null(name)) 
[16:12:46.421]                               next
[16:12:46.421]                             if (!grepl(pattern, name)) 
[16:12:46.421]                               next
[16:12:46.421]                             invokeRestart(restart)
[16:12:46.421]                             muffled <- TRUE
[16:12:46.421]                             break
[16:12:46.421]                           }
[16:12:46.421]                         }
[16:12:46.421]                       }
[16:12:46.421]                       invisible(muffled)
[16:12:46.421]                     }
[16:12:46.421]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.421]                   }
[16:12:46.421]                 }
[16:12:46.421]                 else {
[16:12:46.421]                   if (TRUE) {
[16:12:46.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.421]                     {
[16:12:46.421]                       inherits <- base::inherits
[16:12:46.421]                       invokeRestart <- base::invokeRestart
[16:12:46.421]                       is.null <- base::is.null
[16:12:46.421]                       muffled <- FALSE
[16:12:46.421]                       if (inherits(cond, "message")) {
[16:12:46.421]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.421]                         if (muffled) 
[16:12:46.421]                           invokeRestart("muffleMessage")
[16:12:46.421]                       }
[16:12:46.421]                       else if (inherits(cond, "warning")) {
[16:12:46.421]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.421]                         if (muffled) 
[16:12:46.421]                           invokeRestart("muffleWarning")
[16:12:46.421]                       }
[16:12:46.421]                       else if (inherits(cond, "condition")) {
[16:12:46.421]                         if (!is.null(pattern)) {
[16:12:46.421]                           computeRestarts <- base::computeRestarts
[16:12:46.421]                           grepl <- base::grepl
[16:12:46.421]                           restarts <- computeRestarts(cond)
[16:12:46.421]                           for (restart in restarts) {
[16:12:46.421]                             name <- restart$name
[16:12:46.421]                             if (is.null(name)) 
[16:12:46.421]                               next
[16:12:46.421]                             if (!grepl(pattern, name)) 
[16:12:46.421]                               next
[16:12:46.421]                             invokeRestart(restart)
[16:12:46.421]                             muffled <- TRUE
[16:12:46.421]                             break
[16:12:46.421]                           }
[16:12:46.421]                         }
[16:12:46.421]                       }
[16:12:46.421]                       invisible(muffled)
[16:12:46.421]                     }
[16:12:46.421]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.421]                   }
[16:12:46.421]                 }
[16:12:46.421]             }
[16:12:46.421]         }))
[16:12:46.421]     }, error = function(ex) {
[16:12:46.421]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.421]                 ...future.rng), started = ...future.startTime, 
[16:12:46.421]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.421]             version = "1.8"), class = "FutureResult")
[16:12:46.421]     }, finally = {
[16:12:46.421]         if (!identical(...future.workdir, getwd())) 
[16:12:46.421]             setwd(...future.workdir)
[16:12:46.421]         {
[16:12:46.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.421]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.421]             }
[16:12:46.421]             base::options(...future.oldOptions)
[16:12:46.421]             if (.Platform$OS.type == "windows") {
[16:12:46.421]                 old_names <- names(...future.oldEnvVars)
[16:12:46.421]                 envs <- base::Sys.getenv()
[16:12:46.421]                 names <- names(envs)
[16:12:46.421]                 common <- intersect(names, old_names)
[16:12:46.421]                 added <- setdiff(names, old_names)
[16:12:46.421]                 removed <- setdiff(old_names, names)
[16:12:46.421]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.421]                   envs[common]]
[16:12:46.421]                 NAMES <- toupper(changed)
[16:12:46.421]                 args <- list()
[16:12:46.421]                 for (kk in seq_along(NAMES)) {
[16:12:46.421]                   name <- changed[[kk]]
[16:12:46.421]                   NAME <- NAMES[[kk]]
[16:12:46.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.421]                     next
[16:12:46.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.421]                 }
[16:12:46.421]                 NAMES <- toupper(added)
[16:12:46.421]                 for (kk in seq_along(NAMES)) {
[16:12:46.421]                   name <- added[[kk]]
[16:12:46.421]                   NAME <- NAMES[[kk]]
[16:12:46.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.421]                     next
[16:12:46.421]                   args[[name]] <- ""
[16:12:46.421]                 }
[16:12:46.421]                 NAMES <- toupper(removed)
[16:12:46.421]                 for (kk in seq_along(NAMES)) {
[16:12:46.421]                   name <- removed[[kk]]
[16:12:46.421]                   NAME <- NAMES[[kk]]
[16:12:46.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.421]                     next
[16:12:46.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.421]                 }
[16:12:46.421]                 if (length(args) > 0) 
[16:12:46.421]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.421]             }
[16:12:46.421]             else {
[16:12:46.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.421]             }
[16:12:46.421]             {
[16:12:46.421]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.421]                   0L) {
[16:12:46.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.421]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.421]                   base::options(opts)
[16:12:46.421]                 }
[16:12:46.421]                 {
[16:12:46.421]                   {
[16:12:46.421]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.421]                     NULL
[16:12:46.421]                   }
[16:12:46.421]                   options(future.plan = NULL)
[16:12:46.421]                   if (is.na(NA_character_)) 
[16:12:46.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.421]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:46.421]                     envir = parent.frame()) 
[16:12:46.421]                   {
[16:12:46.421]                     default_workers <- missing(workers)
[16:12:46.421]                     if (is.function(workers)) 
[16:12:46.421]                       workers <- workers()
[16:12:46.421]                     workers <- structure(as.integer(workers), 
[16:12:46.421]                       class = class(workers))
[16:12:46.421]                     stop_if_not(is.finite(workers), workers >= 
[16:12:46.421]                       1L)
[16:12:46.421]                     if ((workers == 1L && !inherits(workers, 
[16:12:46.421]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:46.421]                       if (default_workers) 
[16:12:46.421]                         supportsMulticore(warn = TRUE)
[16:12:46.421]                       return(sequential(..., envir = envir))
[16:12:46.421]                     }
[16:12:46.421]                     oopts <- options(mc.cores = workers)
[16:12:46.421]                     on.exit(options(oopts))
[16:12:46.421]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:46.421]                       envir = envir)
[16:12:46.421]                     if (!future$lazy) 
[16:12:46.421]                       future <- run(future)
[16:12:46.421]                     invisible(future)
[16:12:46.421]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.421]                 }
[16:12:46.421]             }
[16:12:46.421]         }
[16:12:46.421]     })
[16:12:46.421]     if (TRUE) {
[16:12:46.421]         base::sink(type = "output", split = FALSE)
[16:12:46.421]         if (TRUE) {
[16:12:46.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.421]         }
[16:12:46.421]         else {
[16:12:46.421]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.421]         }
[16:12:46.421]         base::close(...future.stdout)
[16:12:46.421]         ...future.stdout <- NULL
[16:12:46.421]     }
[16:12:46.421]     ...future.result$conditions <- ...future.conditions
[16:12:46.421]     ...future.result$finished <- base::Sys.time()
[16:12:46.421]     ...future.result
[16:12:46.421] }
[16:12:46.423] assign_globals() ...
[16:12:46.424] List of 2
[16:12:46.424]  $ x   : list()
[16:12:46.424]  $ name: chr "a"
[16:12:46.424]  - attr(*, "where")=List of 2
[16:12:46.424]   ..$ x   :<environment: R_EmptyEnv> 
[16:12:46.424]   ..$ name:<environment: R_EmptyEnv> 
[16:12:46.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:46.424]  - attr(*, "resolved")= logi TRUE
[16:12:46.424]  - attr(*, "total_size")= num 112
[16:12:46.424]  - attr(*, "already-done")= logi TRUE
[16:12:46.427] - copied ‘x’ to environment
[16:12:46.427] - copied ‘name’ to environment
[16:12:46.427] assign_globals() ... done
[16:12:46.427] requestCore(): workers = 2
[16:12:46.429] MulticoreFuture started
[16:12:46.430] - Launch lazy future ... done
[16:12:46.430] run() for ‘MulticoreFuture’ ... done
[16:12:46.430] plan(): Setting new future strategy stack:
[16:12:46.430] List of future strategies:
[16:12:46.430] 1. sequential:
[16:12:46.430]    - args: function (..., envir = parent.frame())
[16:12:46.430]    - tweaked: FALSE
[16:12:46.430]    - call: NULL
[16:12:46.436] plan(): nbrOfWorkers() = 1
[16:12:46.438] plan(): Setting new future strategy stack:
[16:12:46.438] List of future strategies:
[16:12:46.438] 1. multicore:
[16:12:46.438]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:46.438]    - tweaked: FALSE
[16:12:46.438]    - call: plan(strategy)
[16:12:46.444] plan(): nbrOfWorkers() = 2
$a
[1] 1

- plan('multisession') ...
[16:12:46.448] plan(): Setting new future strategy stack:
[16:12:46.448] List of future strategies:
[16:12:46.448] 1. multisession:
[16:12:46.448]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:46.448]    - tweaked: FALSE
[16:12:46.448]    - call: plan(strategy)
[16:12:46.449] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:12:46.449] multisession:
[16:12:46.449] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:46.449] - tweaked: FALSE
[16:12:46.449] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:46.456] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:46.456] Not searching for globals
[16:12:46.457] - globals: [0] <none>
[16:12:46.457] getGlobalsAndPackages() ... DONE
[16:12:46.457] [local output] makeClusterPSOCK() ...
[16:12:46.496] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:12:46.502] [local output] Base port: 11334
[16:12:46.502] [local output] Getting setup options for 2 cluster nodes ...
[16:12:46.502] [local output]  - Node 1 of 2 ...
[16:12:46.502] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:46.503] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6FOJop/worker.rank=1.parallelly.parent=85576.14e4819aaa2c6.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp6FOJop/worker.rank=1.parallelly.parent=85576.14e4819aaa2c6.pid")'’
[16:12:46.696] - Possible to infer worker's PID: TRUE
[16:12:46.696] [local output] Rscript port: 11334

[16:12:46.697] [local output]  - Node 2 of 2 ...
[16:12:46.697] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:46.698] [local output] Rscript port: 11334

[16:12:46.698] [local output] Getting setup options for 2 cluster nodes ... done
[16:12:46.698] [local output]  - Parallel setup requested for some PSOCK nodes
[16:12:46.699] [local output] Setting up PSOCK nodes in parallel
[16:12:46.699] List of 36
[16:12:46.699]  $ worker          : chr "localhost"
[16:12:46.699]   ..- attr(*, "localhost")= logi TRUE
[16:12:46.699]  $ master          : chr "localhost"
[16:12:46.699]  $ port            : int 11334
[16:12:46.699]  $ connectTimeout  : num 120
[16:12:46.699]  $ timeout         : num 2592000
[16:12:46.699]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:12:46.699]  $ homogeneous     : logi TRUE
[16:12:46.699]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:12:46.699]  $ rscript_envs    : NULL
[16:12:46.699]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:46.699]  $ rscript_startup : NULL
[16:12:46.699]  $ rscript_sh      : chr "sh"
[16:12:46.699]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:46.699]  $ methods         : logi TRUE
[16:12:46.699]  $ socketOptions   : chr "no-delay"
[16:12:46.699]  $ useXDR          : logi FALSE
[16:12:46.699]  $ outfile         : chr "/dev/null"
[16:12:46.699]  $ renice          : int NA
[16:12:46.699]  $ rshcmd          : NULL
[16:12:46.699]  $ user            : chr(0) 
[16:12:46.699]  $ revtunnel       : logi FALSE
[16:12:46.699]  $ rshlogfile      : NULL
[16:12:46.699]  $ rshopts         : chr(0) 
[16:12:46.699]  $ rank            : int 1
[16:12:46.699]  $ manual          : logi FALSE
[16:12:46.699]  $ dryrun          : logi FALSE
[16:12:46.699]  $ quiet           : logi FALSE
[16:12:46.699]  $ setup_strategy  : chr "parallel"
[16:12:46.699]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:46.699]  $ pidfile         : chr "/tmp/Rtmp6FOJop/worker.rank=1.parallelly.parent=85576.14e4819aaa2c6.pid"
[16:12:46.699]  $ rshcmd_label    : NULL
[16:12:46.699]  $ rsh_call        : NULL
[16:12:46.699]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:46.699]  $ localMachine    : logi TRUE
[16:12:46.699]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:12:46.699]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:12:46.699]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:12:46.699]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:12:46.699]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:12:46.699]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:12:46.699]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:12:46.699]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:12:46.699]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:12:46.699]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:12:46.699]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:12:46.699]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:12:46.699]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:12:46.699]  $ arguments       :List of 28
[16:12:46.699]   ..$ worker          : chr "localhost"
[16:12:46.699]   ..$ master          : NULL
[16:12:46.699]   ..$ port            : int 11334
[16:12:46.699]   ..$ connectTimeout  : num 120
[16:12:46.699]   ..$ timeout         : num 2592000
[16:12:46.699]   ..$ rscript         : NULL
[16:12:46.699]   ..$ homogeneous     : NULL
[16:12:46.699]   ..$ rscript_args    : NULL
[16:12:46.699]   ..$ rscript_envs    : NULL
[16:12:46.699]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:46.699]   ..$ rscript_startup : NULL
[16:12:46.699]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:12:46.699]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:46.699]   ..$ methods         : logi TRUE
[16:12:46.699]   ..$ socketOptions   : chr "no-delay"
[16:12:46.699]   ..$ useXDR          : logi FALSE
[16:12:46.699]   ..$ outfile         : chr "/dev/null"
[16:12:46.699]   ..$ renice          : int NA
[16:12:46.699]   ..$ rshcmd          : NULL
[16:12:46.699]   ..$ user            : NULL
[16:12:46.699]   ..$ revtunnel       : logi NA
[16:12:46.699]   ..$ rshlogfile      : NULL
[16:12:46.699]   ..$ rshopts         : NULL
[16:12:46.699]   ..$ rank            : int 1
[16:12:46.699]   ..$ manual          : logi FALSE
[16:12:46.699]   ..$ dryrun          : logi FALSE
[16:12:46.699]   ..$ quiet           : logi FALSE
[16:12:46.699]   ..$ setup_strategy  : chr "parallel"
[16:12:46.699]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:12:46.717] [local output] System call to launch all workers:
[16:12:46.717] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6FOJop/worker.rank=1.parallelly.parent=85576.14e4819aaa2c6.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11334 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:12:46.717] [local output] Starting PSOCK main server
[16:12:46.718] [local output] Workers launched
[16:12:46.719] [local output] Waiting for workers to connect back
[16:12:46.719]  - [local output] 0 workers out of 2 ready
[16:12:46.958]  - [local output] 0 workers out of 2 ready
[16:12:46.958]  - [local output] 1 workers out of 2 ready
[16:12:46.969]  - [local output] 1 workers out of 2 ready
[16:12:46.970]  - [local output] 2 workers out of 2 ready
[16:12:46.970] [local output] Launching of workers completed
[16:12:46.970] [local output] Collecting session information from workers
[16:12:46.971] [local output]  - Worker #1 of 2
[16:12:46.972] [local output]  - Worker #2 of 2
[16:12:46.972] [local output] makeClusterPSOCK() ... done
[16:12:46.984] Packages needed by the future expression (n = 0): <none>
[16:12:46.984] Packages needed by future strategies (n = 0): <none>
[16:12:46.984] {
[16:12:46.984]     {
[16:12:46.984]         {
[16:12:46.984]             ...future.startTime <- base::Sys.time()
[16:12:46.984]             {
[16:12:46.984]                 {
[16:12:46.984]                   {
[16:12:46.984]                     {
[16:12:46.984]                       base::local({
[16:12:46.984]                         has_future <- base::requireNamespace("future", 
[16:12:46.984]                           quietly = TRUE)
[16:12:46.984]                         if (has_future) {
[16:12:46.984]                           ns <- base::getNamespace("future")
[16:12:46.984]                           version <- ns[[".package"]][["version"]]
[16:12:46.984]                           if (is.null(version)) 
[16:12:46.984]                             version <- utils::packageVersion("future")
[16:12:46.984]                         }
[16:12:46.984]                         else {
[16:12:46.984]                           version <- NULL
[16:12:46.984]                         }
[16:12:46.984]                         if (!has_future || version < "1.8.0") {
[16:12:46.984]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:46.984]                             "", base::R.version$version.string), 
[16:12:46.984]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:46.984]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:46.984]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:46.984]                               "release", "version")], collapse = " "), 
[16:12:46.984]                             hostname = base::Sys.info()[["nodename"]])
[16:12:46.984]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:46.984]                             info)
[16:12:46.984]                           info <- base::paste(info, collapse = "; ")
[16:12:46.984]                           if (!has_future) {
[16:12:46.984]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:46.984]                               info)
[16:12:46.984]                           }
[16:12:46.984]                           else {
[16:12:46.984]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:46.984]                               info, version)
[16:12:46.984]                           }
[16:12:46.984]                           base::stop(msg)
[16:12:46.984]                         }
[16:12:46.984]                       })
[16:12:46.984]                     }
[16:12:46.984]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:46.984]                     base::options(mc.cores = 1L)
[16:12:46.984]                   }
[16:12:46.984]                   options(future.plan = NULL)
[16:12:46.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.984]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:46.984]                 }
[16:12:46.984]                 ...future.workdir <- getwd()
[16:12:46.984]             }
[16:12:46.984]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:46.984]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:46.984]         }
[16:12:46.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:46.984]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:46.984]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:46.984]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:46.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:46.984]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:46.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:46.984]             base::names(...future.oldOptions))
[16:12:46.984]     }
[16:12:46.984]     if (FALSE) {
[16:12:46.984]     }
[16:12:46.984]     else {
[16:12:46.984]         if (TRUE) {
[16:12:46.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:46.984]                 open = "w")
[16:12:46.984]         }
[16:12:46.984]         else {
[16:12:46.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:46.984]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:46.984]         }
[16:12:46.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:46.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:46.984]             base::sink(type = "output", split = FALSE)
[16:12:46.984]             base::close(...future.stdout)
[16:12:46.984]         }, add = TRUE)
[16:12:46.984]     }
[16:12:46.984]     ...future.frame <- base::sys.nframe()
[16:12:46.984]     ...future.conditions <- base::list()
[16:12:46.984]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:46.984]     if (FALSE) {
[16:12:46.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:46.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:46.984]     }
[16:12:46.984]     ...future.result <- base::tryCatch({
[16:12:46.984]         base::withCallingHandlers({
[16:12:46.984]             ...future.value <- base::withVisible(base::local({
[16:12:46.984]                 ...future.makeSendCondition <- local({
[16:12:46.984]                   sendCondition <- NULL
[16:12:46.984]                   function(frame = 1L) {
[16:12:46.984]                     if (is.function(sendCondition)) 
[16:12:46.984]                       return(sendCondition)
[16:12:46.984]                     ns <- getNamespace("parallel")
[16:12:46.984]                     if (exists("sendData", mode = "function", 
[16:12:46.984]                       envir = ns)) {
[16:12:46.984]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:46.984]                         envir = ns)
[16:12:46.984]                       envir <- sys.frame(frame)
[16:12:46.984]                       master <- NULL
[16:12:46.984]                       while (!identical(envir, .GlobalEnv) && 
[16:12:46.984]                         !identical(envir, emptyenv())) {
[16:12:46.984]                         if (exists("master", mode = "list", envir = envir, 
[16:12:46.984]                           inherits = FALSE)) {
[16:12:46.984]                           master <- get("master", mode = "list", 
[16:12:46.984]                             envir = envir, inherits = FALSE)
[16:12:46.984]                           if (inherits(master, c("SOCKnode", 
[16:12:46.984]                             "SOCK0node"))) {
[16:12:46.984]                             sendCondition <<- function(cond) {
[16:12:46.984]                               data <- list(type = "VALUE", value = cond, 
[16:12:46.984]                                 success = TRUE)
[16:12:46.984]                               parallel_sendData(master, data)
[16:12:46.984]                             }
[16:12:46.984]                             return(sendCondition)
[16:12:46.984]                           }
[16:12:46.984]                         }
[16:12:46.984]                         frame <- frame + 1L
[16:12:46.984]                         envir <- sys.frame(frame)
[16:12:46.984]                       }
[16:12:46.984]                     }
[16:12:46.984]                     sendCondition <<- function(cond) NULL
[16:12:46.984]                   }
[16:12:46.984]                 })
[16:12:46.984]                 withCallingHandlers({
[16:12:46.984]                   NA
[16:12:46.984]                 }, immediateCondition = function(cond) {
[16:12:46.984]                   sendCondition <- ...future.makeSendCondition()
[16:12:46.984]                   sendCondition(cond)
[16:12:46.984]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.984]                   {
[16:12:46.984]                     inherits <- base::inherits
[16:12:46.984]                     invokeRestart <- base::invokeRestart
[16:12:46.984]                     is.null <- base::is.null
[16:12:46.984]                     muffled <- FALSE
[16:12:46.984]                     if (inherits(cond, "message")) {
[16:12:46.984]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:46.984]                       if (muffled) 
[16:12:46.984]                         invokeRestart("muffleMessage")
[16:12:46.984]                     }
[16:12:46.984]                     else if (inherits(cond, "warning")) {
[16:12:46.984]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:46.984]                       if (muffled) 
[16:12:46.984]                         invokeRestart("muffleWarning")
[16:12:46.984]                     }
[16:12:46.984]                     else if (inherits(cond, "condition")) {
[16:12:46.984]                       if (!is.null(pattern)) {
[16:12:46.984]                         computeRestarts <- base::computeRestarts
[16:12:46.984]                         grepl <- base::grepl
[16:12:46.984]                         restarts <- computeRestarts(cond)
[16:12:46.984]                         for (restart in restarts) {
[16:12:46.984]                           name <- restart$name
[16:12:46.984]                           if (is.null(name)) 
[16:12:46.984]                             next
[16:12:46.984]                           if (!grepl(pattern, name)) 
[16:12:46.984]                             next
[16:12:46.984]                           invokeRestart(restart)
[16:12:46.984]                           muffled <- TRUE
[16:12:46.984]                           break
[16:12:46.984]                         }
[16:12:46.984]                       }
[16:12:46.984]                     }
[16:12:46.984]                     invisible(muffled)
[16:12:46.984]                   }
[16:12:46.984]                   muffleCondition(cond)
[16:12:46.984]                 })
[16:12:46.984]             }))
[16:12:46.984]             future::FutureResult(value = ...future.value$value, 
[16:12:46.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.984]                   ...future.rng), globalenv = if (FALSE) 
[16:12:46.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:46.984]                     ...future.globalenv.names))
[16:12:46.984]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:46.984]         }, condition = base::local({
[16:12:46.984]             c <- base::c
[16:12:46.984]             inherits <- base::inherits
[16:12:46.984]             invokeRestart <- base::invokeRestart
[16:12:46.984]             length <- base::length
[16:12:46.984]             list <- base::list
[16:12:46.984]             seq.int <- base::seq.int
[16:12:46.984]             signalCondition <- base::signalCondition
[16:12:46.984]             sys.calls <- base::sys.calls
[16:12:46.984]             `[[` <- base::`[[`
[16:12:46.984]             `+` <- base::`+`
[16:12:46.984]             `<<-` <- base::`<<-`
[16:12:46.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:46.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:46.984]                   3L)]
[16:12:46.984]             }
[16:12:46.984]             function(cond) {
[16:12:46.984]                 is_error <- inherits(cond, "error")
[16:12:46.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:46.984]                   NULL)
[16:12:46.984]                 if (is_error) {
[16:12:46.984]                   sessionInformation <- function() {
[16:12:46.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:46.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:46.984]                       search = base::search(), system = base::Sys.info())
[16:12:46.984]                   }
[16:12:46.984]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:46.984]                     cond$call), session = sessionInformation(), 
[16:12:46.984]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:46.984]                   signalCondition(cond)
[16:12:46.984]                 }
[16:12:46.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:46.984]                 "immediateCondition"))) {
[16:12:46.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:46.984]                   ...future.conditions[[length(...future.conditions) + 
[16:12:46.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:46.984]                   if (TRUE && !signal) {
[16:12:46.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.984]                     {
[16:12:46.984]                       inherits <- base::inherits
[16:12:46.984]                       invokeRestart <- base::invokeRestart
[16:12:46.984]                       is.null <- base::is.null
[16:12:46.984]                       muffled <- FALSE
[16:12:46.984]                       if (inherits(cond, "message")) {
[16:12:46.984]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.984]                         if (muffled) 
[16:12:46.984]                           invokeRestart("muffleMessage")
[16:12:46.984]                       }
[16:12:46.984]                       else if (inherits(cond, "warning")) {
[16:12:46.984]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.984]                         if (muffled) 
[16:12:46.984]                           invokeRestart("muffleWarning")
[16:12:46.984]                       }
[16:12:46.984]                       else if (inherits(cond, "condition")) {
[16:12:46.984]                         if (!is.null(pattern)) {
[16:12:46.984]                           computeRestarts <- base::computeRestarts
[16:12:46.984]                           grepl <- base::grepl
[16:12:46.984]                           restarts <- computeRestarts(cond)
[16:12:46.984]                           for (restart in restarts) {
[16:12:46.984]                             name <- restart$name
[16:12:46.984]                             if (is.null(name)) 
[16:12:46.984]                               next
[16:12:46.984]                             if (!grepl(pattern, name)) 
[16:12:46.984]                               next
[16:12:46.984]                             invokeRestart(restart)
[16:12:46.984]                             muffled <- TRUE
[16:12:46.984]                             break
[16:12:46.984]                           }
[16:12:46.984]                         }
[16:12:46.984]                       }
[16:12:46.984]                       invisible(muffled)
[16:12:46.984]                     }
[16:12:46.984]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.984]                   }
[16:12:46.984]                 }
[16:12:46.984]                 else {
[16:12:46.984]                   if (TRUE) {
[16:12:46.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:46.984]                     {
[16:12:46.984]                       inherits <- base::inherits
[16:12:46.984]                       invokeRestart <- base::invokeRestart
[16:12:46.984]                       is.null <- base::is.null
[16:12:46.984]                       muffled <- FALSE
[16:12:46.984]                       if (inherits(cond, "message")) {
[16:12:46.984]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:46.984]                         if (muffled) 
[16:12:46.984]                           invokeRestart("muffleMessage")
[16:12:46.984]                       }
[16:12:46.984]                       else if (inherits(cond, "warning")) {
[16:12:46.984]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:46.984]                         if (muffled) 
[16:12:46.984]                           invokeRestart("muffleWarning")
[16:12:46.984]                       }
[16:12:46.984]                       else if (inherits(cond, "condition")) {
[16:12:46.984]                         if (!is.null(pattern)) {
[16:12:46.984]                           computeRestarts <- base::computeRestarts
[16:12:46.984]                           grepl <- base::grepl
[16:12:46.984]                           restarts <- computeRestarts(cond)
[16:12:46.984]                           for (restart in restarts) {
[16:12:46.984]                             name <- restart$name
[16:12:46.984]                             if (is.null(name)) 
[16:12:46.984]                               next
[16:12:46.984]                             if (!grepl(pattern, name)) 
[16:12:46.984]                               next
[16:12:46.984]                             invokeRestart(restart)
[16:12:46.984]                             muffled <- TRUE
[16:12:46.984]                             break
[16:12:46.984]                           }
[16:12:46.984]                         }
[16:12:46.984]                       }
[16:12:46.984]                       invisible(muffled)
[16:12:46.984]                     }
[16:12:46.984]                     muffleCondition(cond, pattern = "^muffle")
[16:12:46.984]                   }
[16:12:46.984]                 }
[16:12:46.984]             }
[16:12:46.984]         }))
[16:12:46.984]     }, error = function(ex) {
[16:12:46.984]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:46.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:46.984]                 ...future.rng), started = ...future.startTime, 
[16:12:46.984]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:46.984]             version = "1.8"), class = "FutureResult")
[16:12:46.984]     }, finally = {
[16:12:46.984]         if (!identical(...future.workdir, getwd())) 
[16:12:46.984]             setwd(...future.workdir)
[16:12:46.984]         {
[16:12:46.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:46.984]                 ...future.oldOptions$nwarnings <- NULL
[16:12:46.984]             }
[16:12:46.984]             base::options(...future.oldOptions)
[16:12:46.984]             if (.Platform$OS.type == "windows") {
[16:12:46.984]                 old_names <- names(...future.oldEnvVars)
[16:12:46.984]                 envs <- base::Sys.getenv()
[16:12:46.984]                 names <- names(envs)
[16:12:46.984]                 common <- intersect(names, old_names)
[16:12:46.984]                 added <- setdiff(names, old_names)
[16:12:46.984]                 removed <- setdiff(old_names, names)
[16:12:46.984]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:46.984]                   envs[common]]
[16:12:46.984]                 NAMES <- toupper(changed)
[16:12:46.984]                 args <- list()
[16:12:46.984]                 for (kk in seq_along(NAMES)) {
[16:12:46.984]                   name <- changed[[kk]]
[16:12:46.984]                   NAME <- NAMES[[kk]]
[16:12:46.984]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.984]                     next
[16:12:46.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.984]                 }
[16:12:46.984]                 NAMES <- toupper(added)
[16:12:46.984]                 for (kk in seq_along(NAMES)) {
[16:12:46.984]                   name <- added[[kk]]
[16:12:46.984]                   NAME <- NAMES[[kk]]
[16:12:46.984]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.984]                     next
[16:12:46.984]                   args[[name]] <- ""
[16:12:46.984]                 }
[16:12:46.984]                 NAMES <- toupper(removed)
[16:12:46.984]                 for (kk in seq_along(NAMES)) {
[16:12:46.984]                   name <- removed[[kk]]
[16:12:46.984]                   NAME <- NAMES[[kk]]
[16:12:46.984]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:46.984]                     next
[16:12:46.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:46.984]                 }
[16:12:46.984]                 if (length(args) > 0) 
[16:12:46.984]                   base::do.call(base::Sys.setenv, args = args)
[16:12:46.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:46.984]             }
[16:12:46.984]             else {
[16:12:46.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:46.984]             }
[16:12:46.984]             {
[16:12:46.984]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:46.984]                   0L) {
[16:12:46.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:46.984]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:46.984]                   base::options(opts)
[16:12:46.984]                 }
[16:12:46.984]                 {
[16:12:46.984]                   {
[16:12:46.984]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:46.984]                     NULL
[16:12:46.984]                   }
[16:12:46.984]                   options(future.plan = NULL)
[16:12:46.984]                   if (is.na(NA_character_)) 
[16:12:46.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:46.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:46.984]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:46.984]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:46.984]                     envir = parent.frame()) 
[16:12:46.984]                   {
[16:12:46.984]                     if (is.function(workers)) 
[16:12:46.984]                       workers <- workers()
[16:12:46.984]                     workers <- structure(as.integer(workers), 
[16:12:46.984]                       class = class(workers))
[16:12:46.984]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:46.984]                       workers >= 1)
[16:12:46.984]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:46.984]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:46.984]                     }
[16:12:46.984]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:46.984]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:46.984]                       envir = envir)
[16:12:46.984]                     if (!future$lazy) 
[16:12:46.984]                       future <- run(future)
[16:12:46.984]                     invisible(future)
[16:12:46.984]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:46.984]                 }
[16:12:46.984]             }
[16:12:46.984]         }
[16:12:46.984]     })
[16:12:46.984]     if (TRUE) {
[16:12:46.984]         base::sink(type = "output", split = FALSE)
[16:12:46.984]         if (TRUE) {
[16:12:46.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:46.984]         }
[16:12:46.984]         else {
[16:12:46.984]             ...future.result["stdout"] <- base::list(NULL)
[16:12:46.984]         }
[16:12:46.984]         base::close(...future.stdout)
[16:12:46.984]         ...future.stdout <- NULL
[16:12:46.984]     }
[16:12:46.984]     ...future.result$conditions <- ...future.conditions
[16:12:46.984]     ...future.result$finished <- base::Sys.time()
[16:12:46.984]     ...future.result
[16:12:46.984] }
[16:12:47.057] MultisessionFuture started
[16:12:47.058] result() for ClusterFuture ...
[16:12:47.059] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.059] - Validating connection of MultisessionFuture
[16:12:47.092] - received message: FutureResult
[16:12:47.092] - Received FutureResult
[16:12:47.092] - Erased future from FutureRegistry
[16:12:47.093] result() for ClusterFuture ...
[16:12:47.093] - result already collected: FutureResult
[16:12:47.093] result() for ClusterFuture ... done
[16:12:47.093] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.093] result() for ClusterFuture ... done
[16:12:47.093] result() for ClusterFuture ...
[16:12:47.093] - result already collected: FutureResult
[16:12:47.093] result() for ClusterFuture ... done
[16:12:47.094] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:12:47.097] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.098] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.098] Searching for globals...
[16:12:47.100] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:47.101] Searching for globals ... DONE
[16:12:47.101] Resolving globals: TRUE
[16:12:47.101] Resolving any globals that are futures ...
[16:12:47.101] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:47.101] Resolving any globals that are futures ... DONE
[16:12:47.102] Resolving futures part of globals (recursively) ...
[16:12:47.102] resolve() on list ...
[16:12:47.102]  recursive: 99
[16:12:47.102]  length: 1
[16:12:47.102]  elements: ‘x’
[16:12:47.102]  length: 0 (resolved future 1)
[16:12:47.102] resolve() on list ... DONE
[16:12:47.103] - globals: [1] ‘x’
[16:12:47.103] Resolving futures part of globals (recursively) ... DONE
[16:12:47.103] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:47.103] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:47.103] - globals: [1] ‘x’
[16:12:47.104] 
[16:12:47.104] getGlobalsAndPackages() ... DONE
[16:12:47.104] run() for ‘Future’ ...
[16:12:47.104] - state: ‘created’
[16:12:47.104] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.119] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.119] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.120]   - Field: ‘node’
[16:12:47.120]   - Field: ‘label’
[16:12:47.120]   - Field: ‘local’
[16:12:47.120]   - Field: ‘owner’
[16:12:47.120]   - Field: ‘envir’
[16:12:47.120]   - Field: ‘workers’
[16:12:47.120]   - Field: ‘packages’
[16:12:47.120]   - Field: ‘gc’
[16:12:47.120]   - Field: ‘conditions’
[16:12:47.121]   - Field: ‘persistent’
[16:12:47.121]   - Field: ‘expr’
[16:12:47.121]   - Field: ‘uuid’
[16:12:47.121]   - Field: ‘seed’
[16:12:47.121]   - Field: ‘version’
[16:12:47.121]   - Field: ‘result’
[16:12:47.121]   - Field: ‘asynchronous’
[16:12:47.121]   - Field: ‘calls’
[16:12:47.122]   - Field: ‘globals’
[16:12:47.122]   - Field: ‘stdout’
[16:12:47.122]   - Field: ‘earlySignal’
[16:12:47.122]   - Field: ‘lazy’
[16:12:47.122]   - Field: ‘state’
[16:12:47.122] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.122] - Launch lazy future ...
[16:12:47.123] Packages needed by the future expression (n = 0): <none>
[16:12:47.123] Packages needed by future strategies (n = 0): <none>
[16:12:47.123] {
[16:12:47.123]     {
[16:12:47.123]         {
[16:12:47.123]             ...future.startTime <- base::Sys.time()
[16:12:47.123]             {
[16:12:47.123]                 {
[16:12:47.123]                   {
[16:12:47.123]                     {
[16:12:47.123]                       base::local({
[16:12:47.123]                         has_future <- base::requireNamespace("future", 
[16:12:47.123]                           quietly = TRUE)
[16:12:47.123]                         if (has_future) {
[16:12:47.123]                           ns <- base::getNamespace("future")
[16:12:47.123]                           version <- ns[[".package"]][["version"]]
[16:12:47.123]                           if (is.null(version)) 
[16:12:47.123]                             version <- utils::packageVersion("future")
[16:12:47.123]                         }
[16:12:47.123]                         else {
[16:12:47.123]                           version <- NULL
[16:12:47.123]                         }
[16:12:47.123]                         if (!has_future || version < "1.8.0") {
[16:12:47.123]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.123]                             "", base::R.version$version.string), 
[16:12:47.123]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.123]                               "release", "version")], collapse = " "), 
[16:12:47.123]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.123]                             info)
[16:12:47.123]                           info <- base::paste(info, collapse = "; ")
[16:12:47.123]                           if (!has_future) {
[16:12:47.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.123]                               info)
[16:12:47.123]                           }
[16:12:47.123]                           else {
[16:12:47.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.123]                               info, version)
[16:12:47.123]                           }
[16:12:47.123]                           base::stop(msg)
[16:12:47.123]                         }
[16:12:47.123]                       })
[16:12:47.123]                     }
[16:12:47.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.123]                     base::options(mc.cores = 1L)
[16:12:47.123]                   }
[16:12:47.123]                   options(future.plan = NULL)
[16:12:47.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.123]                 }
[16:12:47.123]                 ...future.workdir <- getwd()
[16:12:47.123]             }
[16:12:47.123]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.123]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.123]         }
[16:12:47.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.123]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.123]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.123]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.123]             base::names(...future.oldOptions))
[16:12:47.123]     }
[16:12:47.123]     if (FALSE) {
[16:12:47.123]     }
[16:12:47.123]     else {
[16:12:47.123]         if (TRUE) {
[16:12:47.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.123]                 open = "w")
[16:12:47.123]         }
[16:12:47.123]         else {
[16:12:47.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.123]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.123]         }
[16:12:47.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.123]             base::sink(type = "output", split = FALSE)
[16:12:47.123]             base::close(...future.stdout)
[16:12:47.123]         }, add = TRUE)
[16:12:47.123]     }
[16:12:47.123]     ...future.frame <- base::sys.nframe()
[16:12:47.123]     ...future.conditions <- base::list()
[16:12:47.123]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.123]     if (FALSE) {
[16:12:47.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.123]     }
[16:12:47.123]     ...future.result <- base::tryCatch({
[16:12:47.123]         base::withCallingHandlers({
[16:12:47.123]             ...future.value <- base::withVisible(base::local({
[16:12:47.123]                 ...future.makeSendCondition <- local({
[16:12:47.123]                   sendCondition <- NULL
[16:12:47.123]                   function(frame = 1L) {
[16:12:47.123]                     if (is.function(sendCondition)) 
[16:12:47.123]                       return(sendCondition)
[16:12:47.123]                     ns <- getNamespace("parallel")
[16:12:47.123]                     if (exists("sendData", mode = "function", 
[16:12:47.123]                       envir = ns)) {
[16:12:47.123]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.123]                         envir = ns)
[16:12:47.123]                       envir <- sys.frame(frame)
[16:12:47.123]                       master <- NULL
[16:12:47.123]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.123]                         !identical(envir, emptyenv())) {
[16:12:47.123]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.123]                           inherits = FALSE)) {
[16:12:47.123]                           master <- get("master", mode = "list", 
[16:12:47.123]                             envir = envir, inherits = FALSE)
[16:12:47.123]                           if (inherits(master, c("SOCKnode", 
[16:12:47.123]                             "SOCK0node"))) {
[16:12:47.123]                             sendCondition <<- function(cond) {
[16:12:47.123]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.123]                                 success = TRUE)
[16:12:47.123]                               parallel_sendData(master, data)
[16:12:47.123]                             }
[16:12:47.123]                             return(sendCondition)
[16:12:47.123]                           }
[16:12:47.123]                         }
[16:12:47.123]                         frame <- frame + 1L
[16:12:47.123]                         envir <- sys.frame(frame)
[16:12:47.123]                       }
[16:12:47.123]                     }
[16:12:47.123]                     sendCondition <<- function(cond) NULL
[16:12:47.123]                   }
[16:12:47.123]                 })
[16:12:47.123]                 withCallingHandlers({
[16:12:47.123]                   {
[16:12:47.123]                     x$a <- 1
[16:12:47.123]                     x
[16:12:47.123]                   }
[16:12:47.123]                 }, immediateCondition = function(cond) {
[16:12:47.123]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.123]                   sendCondition(cond)
[16:12:47.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.123]                   {
[16:12:47.123]                     inherits <- base::inherits
[16:12:47.123]                     invokeRestart <- base::invokeRestart
[16:12:47.123]                     is.null <- base::is.null
[16:12:47.123]                     muffled <- FALSE
[16:12:47.123]                     if (inherits(cond, "message")) {
[16:12:47.123]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.123]                       if (muffled) 
[16:12:47.123]                         invokeRestart("muffleMessage")
[16:12:47.123]                     }
[16:12:47.123]                     else if (inherits(cond, "warning")) {
[16:12:47.123]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.123]                       if (muffled) 
[16:12:47.123]                         invokeRestart("muffleWarning")
[16:12:47.123]                     }
[16:12:47.123]                     else if (inherits(cond, "condition")) {
[16:12:47.123]                       if (!is.null(pattern)) {
[16:12:47.123]                         computeRestarts <- base::computeRestarts
[16:12:47.123]                         grepl <- base::grepl
[16:12:47.123]                         restarts <- computeRestarts(cond)
[16:12:47.123]                         for (restart in restarts) {
[16:12:47.123]                           name <- restart$name
[16:12:47.123]                           if (is.null(name)) 
[16:12:47.123]                             next
[16:12:47.123]                           if (!grepl(pattern, name)) 
[16:12:47.123]                             next
[16:12:47.123]                           invokeRestart(restart)
[16:12:47.123]                           muffled <- TRUE
[16:12:47.123]                           break
[16:12:47.123]                         }
[16:12:47.123]                       }
[16:12:47.123]                     }
[16:12:47.123]                     invisible(muffled)
[16:12:47.123]                   }
[16:12:47.123]                   muffleCondition(cond)
[16:12:47.123]                 })
[16:12:47.123]             }))
[16:12:47.123]             future::FutureResult(value = ...future.value$value, 
[16:12:47.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.123]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.123]                     ...future.globalenv.names))
[16:12:47.123]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.123]         }, condition = base::local({
[16:12:47.123]             c <- base::c
[16:12:47.123]             inherits <- base::inherits
[16:12:47.123]             invokeRestart <- base::invokeRestart
[16:12:47.123]             length <- base::length
[16:12:47.123]             list <- base::list
[16:12:47.123]             seq.int <- base::seq.int
[16:12:47.123]             signalCondition <- base::signalCondition
[16:12:47.123]             sys.calls <- base::sys.calls
[16:12:47.123]             `[[` <- base::`[[`
[16:12:47.123]             `+` <- base::`+`
[16:12:47.123]             `<<-` <- base::`<<-`
[16:12:47.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.123]                   3L)]
[16:12:47.123]             }
[16:12:47.123]             function(cond) {
[16:12:47.123]                 is_error <- inherits(cond, "error")
[16:12:47.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.123]                   NULL)
[16:12:47.123]                 if (is_error) {
[16:12:47.123]                   sessionInformation <- function() {
[16:12:47.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.123]                       search = base::search(), system = base::Sys.info())
[16:12:47.123]                   }
[16:12:47.123]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.123]                     cond$call), session = sessionInformation(), 
[16:12:47.123]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.123]                   signalCondition(cond)
[16:12:47.123]                 }
[16:12:47.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.123]                 "immediateCondition"))) {
[16:12:47.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.123]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.123]                   if (TRUE && !signal) {
[16:12:47.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.123]                     {
[16:12:47.123]                       inherits <- base::inherits
[16:12:47.123]                       invokeRestart <- base::invokeRestart
[16:12:47.123]                       is.null <- base::is.null
[16:12:47.123]                       muffled <- FALSE
[16:12:47.123]                       if (inherits(cond, "message")) {
[16:12:47.123]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.123]                         if (muffled) 
[16:12:47.123]                           invokeRestart("muffleMessage")
[16:12:47.123]                       }
[16:12:47.123]                       else if (inherits(cond, "warning")) {
[16:12:47.123]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.123]                         if (muffled) 
[16:12:47.123]                           invokeRestart("muffleWarning")
[16:12:47.123]                       }
[16:12:47.123]                       else if (inherits(cond, "condition")) {
[16:12:47.123]                         if (!is.null(pattern)) {
[16:12:47.123]                           computeRestarts <- base::computeRestarts
[16:12:47.123]                           grepl <- base::grepl
[16:12:47.123]                           restarts <- computeRestarts(cond)
[16:12:47.123]                           for (restart in restarts) {
[16:12:47.123]                             name <- restart$name
[16:12:47.123]                             if (is.null(name)) 
[16:12:47.123]                               next
[16:12:47.123]                             if (!grepl(pattern, name)) 
[16:12:47.123]                               next
[16:12:47.123]                             invokeRestart(restart)
[16:12:47.123]                             muffled <- TRUE
[16:12:47.123]                             break
[16:12:47.123]                           }
[16:12:47.123]                         }
[16:12:47.123]                       }
[16:12:47.123]                       invisible(muffled)
[16:12:47.123]                     }
[16:12:47.123]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.123]                   }
[16:12:47.123]                 }
[16:12:47.123]                 else {
[16:12:47.123]                   if (TRUE) {
[16:12:47.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.123]                     {
[16:12:47.123]                       inherits <- base::inherits
[16:12:47.123]                       invokeRestart <- base::invokeRestart
[16:12:47.123]                       is.null <- base::is.null
[16:12:47.123]                       muffled <- FALSE
[16:12:47.123]                       if (inherits(cond, "message")) {
[16:12:47.123]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.123]                         if (muffled) 
[16:12:47.123]                           invokeRestart("muffleMessage")
[16:12:47.123]                       }
[16:12:47.123]                       else if (inherits(cond, "warning")) {
[16:12:47.123]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.123]                         if (muffled) 
[16:12:47.123]                           invokeRestart("muffleWarning")
[16:12:47.123]                       }
[16:12:47.123]                       else if (inherits(cond, "condition")) {
[16:12:47.123]                         if (!is.null(pattern)) {
[16:12:47.123]                           computeRestarts <- base::computeRestarts
[16:12:47.123]                           grepl <- base::grepl
[16:12:47.123]                           restarts <- computeRestarts(cond)
[16:12:47.123]                           for (restart in restarts) {
[16:12:47.123]                             name <- restart$name
[16:12:47.123]                             if (is.null(name)) 
[16:12:47.123]                               next
[16:12:47.123]                             if (!grepl(pattern, name)) 
[16:12:47.123]                               next
[16:12:47.123]                             invokeRestart(restart)
[16:12:47.123]                             muffled <- TRUE
[16:12:47.123]                             break
[16:12:47.123]                           }
[16:12:47.123]                         }
[16:12:47.123]                       }
[16:12:47.123]                       invisible(muffled)
[16:12:47.123]                     }
[16:12:47.123]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.123]                   }
[16:12:47.123]                 }
[16:12:47.123]             }
[16:12:47.123]         }))
[16:12:47.123]     }, error = function(ex) {
[16:12:47.123]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.123]                 ...future.rng), started = ...future.startTime, 
[16:12:47.123]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.123]             version = "1.8"), class = "FutureResult")
[16:12:47.123]     }, finally = {
[16:12:47.123]         if (!identical(...future.workdir, getwd())) 
[16:12:47.123]             setwd(...future.workdir)
[16:12:47.123]         {
[16:12:47.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.123]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.123]             }
[16:12:47.123]             base::options(...future.oldOptions)
[16:12:47.123]             if (.Platform$OS.type == "windows") {
[16:12:47.123]                 old_names <- names(...future.oldEnvVars)
[16:12:47.123]                 envs <- base::Sys.getenv()
[16:12:47.123]                 names <- names(envs)
[16:12:47.123]                 common <- intersect(names, old_names)
[16:12:47.123]                 added <- setdiff(names, old_names)
[16:12:47.123]                 removed <- setdiff(old_names, names)
[16:12:47.123]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.123]                   envs[common]]
[16:12:47.123]                 NAMES <- toupper(changed)
[16:12:47.123]                 args <- list()
[16:12:47.123]                 for (kk in seq_along(NAMES)) {
[16:12:47.123]                   name <- changed[[kk]]
[16:12:47.123]                   NAME <- NAMES[[kk]]
[16:12:47.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.123]                     next
[16:12:47.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.123]                 }
[16:12:47.123]                 NAMES <- toupper(added)
[16:12:47.123]                 for (kk in seq_along(NAMES)) {
[16:12:47.123]                   name <- added[[kk]]
[16:12:47.123]                   NAME <- NAMES[[kk]]
[16:12:47.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.123]                     next
[16:12:47.123]                   args[[name]] <- ""
[16:12:47.123]                 }
[16:12:47.123]                 NAMES <- toupper(removed)
[16:12:47.123]                 for (kk in seq_along(NAMES)) {
[16:12:47.123]                   name <- removed[[kk]]
[16:12:47.123]                   NAME <- NAMES[[kk]]
[16:12:47.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.123]                     next
[16:12:47.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.123]                 }
[16:12:47.123]                 if (length(args) > 0) 
[16:12:47.123]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.123]             }
[16:12:47.123]             else {
[16:12:47.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.123]             }
[16:12:47.123]             {
[16:12:47.123]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.123]                   0L) {
[16:12:47.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.123]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.123]                   base::options(opts)
[16:12:47.123]                 }
[16:12:47.123]                 {
[16:12:47.123]                   {
[16:12:47.123]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.123]                     NULL
[16:12:47.123]                   }
[16:12:47.123]                   options(future.plan = NULL)
[16:12:47.123]                   if (is.na(NA_character_)) 
[16:12:47.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.123]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.123]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.123]                     envir = parent.frame()) 
[16:12:47.123]                   {
[16:12:47.123]                     if (is.function(workers)) 
[16:12:47.123]                       workers <- workers()
[16:12:47.123]                     workers <- structure(as.integer(workers), 
[16:12:47.123]                       class = class(workers))
[16:12:47.123]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.123]                       workers >= 1)
[16:12:47.123]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.123]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.123]                     }
[16:12:47.123]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.123]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.123]                       envir = envir)
[16:12:47.123]                     if (!future$lazy) 
[16:12:47.123]                       future <- run(future)
[16:12:47.123]                     invisible(future)
[16:12:47.123]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.123]                 }
[16:12:47.123]             }
[16:12:47.123]         }
[16:12:47.123]     })
[16:12:47.123]     if (TRUE) {
[16:12:47.123]         base::sink(type = "output", split = FALSE)
[16:12:47.123]         if (TRUE) {
[16:12:47.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.123]         }
[16:12:47.123]         else {
[16:12:47.123]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.123]         }
[16:12:47.123]         base::close(...future.stdout)
[16:12:47.123]         ...future.stdout <- NULL
[16:12:47.123]     }
[16:12:47.123]     ...future.result$conditions <- ...future.conditions
[16:12:47.123]     ...future.result$finished <- base::Sys.time()
[16:12:47.123]     ...future.result
[16:12:47.123] }
[16:12:47.126] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:12:47.127] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:12:47.127] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:12:47.127] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:12:47.128] MultisessionFuture started
[16:12:47.128] - Launch lazy future ... done
[16:12:47.128] run() for ‘MultisessionFuture’ ... done
[16:12:47.128] result() for ClusterFuture ...
[16:12:47.128] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.128] - Validating connection of MultisessionFuture
[16:12:47.177] - received message: FutureResult
[16:12:47.177] - Received FutureResult
[16:12:47.178] - Erased future from FutureRegistry
[16:12:47.178] result() for ClusterFuture ...
[16:12:47.178] - result already collected: FutureResult
[16:12:47.178] result() for ClusterFuture ... done
[16:12:47.178] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.178] result() for ClusterFuture ... done
[16:12:47.179] result() for ClusterFuture ...
[16:12:47.179] - result already collected: FutureResult
[16:12:47.179] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.179] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.179] Searching for globals...
[16:12:47.182] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:47.182] Searching for globals ... DONE
[16:12:47.182] Resolving globals: TRUE
[16:12:47.182] Resolving any globals that are futures ...
[16:12:47.183] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:47.183] Resolving any globals that are futures ... DONE
[16:12:47.183] Resolving futures part of globals (recursively) ...
[16:12:47.183] resolve() on list ...
[16:12:47.184]  recursive: 99
[16:12:47.184]  length: 1
[16:12:47.184]  elements: ‘x’
[16:12:47.184]  length: 0 (resolved future 1)
[16:12:47.184] resolve() on list ... DONE
[16:12:47.184] - globals: [1] ‘x’
[16:12:47.184] Resolving futures part of globals (recursively) ... DONE
[16:12:47.185] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:47.185] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:47.185] - globals: [1] ‘x’
[16:12:47.185] 
[16:12:47.185] getGlobalsAndPackages() ... DONE
[16:12:47.186] run() for ‘Future’ ...
[16:12:47.186] - state: ‘created’
[16:12:47.186] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.201] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.201]   - Field: ‘node’
[16:12:47.202]   - Field: ‘label’
[16:12:47.202]   - Field: ‘local’
[16:12:47.202]   - Field: ‘owner’
[16:12:47.202]   - Field: ‘envir’
[16:12:47.202]   - Field: ‘workers’
[16:12:47.202]   - Field: ‘packages’
[16:12:47.202]   - Field: ‘gc’
[16:12:47.202]   - Field: ‘conditions’
[16:12:47.202]   - Field: ‘persistent’
[16:12:47.202]   - Field: ‘expr’
[16:12:47.203]   - Field: ‘uuid’
[16:12:47.203]   - Field: ‘seed’
[16:12:47.203]   - Field: ‘version’
[16:12:47.203]   - Field: ‘result’
[16:12:47.203]   - Field: ‘asynchronous’
[16:12:47.203]   - Field: ‘calls’
[16:12:47.203]   - Field: ‘globals’
[16:12:47.203]   - Field: ‘stdout’
[16:12:47.204]   - Field: ‘earlySignal’
[16:12:47.204]   - Field: ‘lazy’
[16:12:47.204]   - Field: ‘state’
[16:12:47.204] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.204] - Launch lazy future ...
[16:12:47.204] Packages needed by the future expression (n = 0): <none>
[16:12:47.205] Packages needed by future strategies (n = 0): <none>
[16:12:47.205] {
[16:12:47.205]     {
[16:12:47.205]         {
[16:12:47.205]             ...future.startTime <- base::Sys.time()
[16:12:47.205]             {
[16:12:47.205]                 {
[16:12:47.205]                   {
[16:12:47.205]                     {
[16:12:47.205]                       base::local({
[16:12:47.205]                         has_future <- base::requireNamespace("future", 
[16:12:47.205]                           quietly = TRUE)
[16:12:47.205]                         if (has_future) {
[16:12:47.205]                           ns <- base::getNamespace("future")
[16:12:47.205]                           version <- ns[[".package"]][["version"]]
[16:12:47.205]                           if (is.null(version)) 
[16:12:47.205]                             version <- utils::packageVersion("future")
[16:12:47.205]                         }
[16:12:47.205]                         else {
[16:12:47.205]                           version <- NULL
[16:12:47.205]                         }
[16:12:47.205]                         if (!has_future || version < "1.8.0") {
[16:12:47.205]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.205]                             "", base::R.version$version.string), 
[16:12:47.205]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.205]                               "release", "version")], collapse = " "), 
[16:12:47.205]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.205]                             info)
[16:12:47.205]                           info <- base::paste(info, collapse = "; ")
[16:12:47.205]                           if (!has_future) {
[16:12:47.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.205]                               info)
[16:12:47.205]                           }
[16:12:47.205]                           else {
[16:12:47.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.205]                               info, version)
[16:12:47.205]                           }
[16:12:47.205]                           base::stop(msg)
[16:12:47.205]                         }
[16:12:47.205]                       })
[16:12:47.205]                     }
[16:12:47.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.205]                     base::options(mc.cores = 1L)
[16:12:47.205]                   }
[16:12:47.205]                   options(future.plan = NULL)
[16:12:47.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.205]                 }
[16:12:47.205]                 ...future.workdir <- getwd()
[16:12:47.205]             }
[16:12:47.205]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.205]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.205]         }
[16:12:47.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.205]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.205]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.205]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.205]             base::names(...future.oldOptions))
[16:12:47.205]     }
[16:12:47.205]     if (FALSE) {
[16:12:47.205]     }
[16:12:47.205]     else {
[16:12:47.205]         if (TRUE) {
[16:12:47.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.205]                 open = "w")
[16:12:47.205]         }
[16:12:47.205]         else {
[16:12:47.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.205]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.205]         }
[16:12:47.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.205]             base::sink(type = "output", split = FALSE)
[16:12:47.205]             base::close(...future.stdout)
[16:12:47.205]         }, add = TRUE)
[16:12:47.205]     }
[16:12:47.205]     ...future.frame <- base::sys.nframe()
[16:12:47.205]     ...future.conditions <- base::list()
[16:12:47.205]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.205]     if (FALSE) {
[16:12:47.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.205]     }
[16:12:47.205]     ...future.result <- base::tryCatch({
[16:12:47.205]         base::withCallingHandlers({
[16:12:47.205]             ...future.value <- base::withVisible(base::local({
[16:12:47.205]                 ...future.makeSendCondition <- local({
[16:12:47.205]                   sendCondition <- NULL
[16:12:47.205]                   function(frame = 1L) {
[16:12:47.205]                     if (is.function(sendCondition)) 
[16:12:47.205]                       return(sendCondition)
[16:12:47.205]                     ns <- getNamespace("parallel")
[16:12:47.205]                     if (exists("sendData", mode = "function", 
[16:12:47.205]                       envir = ns)) {
[16:12:47.205]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.205]                         envir = ns)
[16:12:47.205]                       envir <- sys.frame(frame)
[16:12:47.205]                       master <- NULL
[16:12:47.205]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.205]                         !identical(envir, emptyenv())) {
[16:12:47.205]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.205]                           inherits = FALSE)) {
[16:12:47.205]                           master <- get("master", mode = "list", 
[16:12:47.205]                             envir = envir, inherits = FALSE)
[16:12:47.205]                           if (inherits(master, c("SOCKnode", 
[16:12:47.205]                             "SOCK0node"))) {
[16:12:47.205]                             sendCondition <<- function(cond) {
[16:12:47.205]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.205]                                 success = TRUE)
[16:12:47.205]                               parallel_sendData(master, data)
[16:12:47.205]                             }
[16:12:47.205]                             return(sendCondition)
[16:12:47.205]                           }
[16:12:47.205]                         }
[16:12:47.205]                         frame <- frame + 1L
[16:12:47.205]                         envir <- sys.frame(frame)
[16:12:47.205]                       }
[16:12:47.205]                     }
[16:12:47.205]                     sendCondition <<- function(cond) NULL
[16:12:47.205]                   }
[16:12:47.205]                 })
[16:12:47.205]                 withCallingHandlers({
[16:12:47.205]                   {
[16:12:47.205]                     x$a <- 1
[16:12:47.205]                     x
[16:12:47.205]                   }
[16:12:47.205]                 }, immediateCondition = function(cond) {
[16:12:47.205]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.205]                   sendCondition(cond)
[16:12:47.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.205]                   {
[16:12:47.205]                     inherits <- base::inherits
[16:12:47.205]                     invokeRestart <- base::invokeRestart
[16:12:47.205]                     is.null <- base::is.null
[16:12:47.205]                     muffled <- FALSE
[16:12:47.205]                     if (inherits(cond, "message")) {
[16:12:47.205]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.205]                       if (muffled) 
[16:12:47.205]                         invokeRestart("muffleMessage")
[16:12:47.205]                     }
[16:12:47.205]                     else if (inherits(cond, "warning")) {
[16:12:47.205]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.205]                       if (muffled) 
[16:12:47.205]                         invokeRestart("muffleWarning")
[16:12:47.205]                     }
[16:12:47.205]                     else if (inherits(cond, "condition")) {
[16:12:47.205]                       if (!is.null(pattern)) {
[16:12:47.205]                         computeRestarts <- base::computeRestarts
[16:12:47.205]                         grepl <- base::grepl
[16:12:47.205]                         restarts <- computeRestarts(cond)
[16:12:47.205]                         for (restart in restarts) {
[16:12:47.205]                           name <- restart$name
[16:12:47.205]                           if (is.null(name)) 
[16:12:47.205]                             next
[16:12:47.205]                           if (!grepl(pattern, name)) 
[16:12:47.205]                             next
[16:12:47.205]                           invokeRestart(restart)
[16:12:47.205]                           muffled <- TRUE
[16:12:47.205]                           break
[16:12:47.205]                         }
[16:12:47.205]                       }
[16:12:47.205]                     }
[16:12:47.205]                     invisible(muffled)
[16:12:47.205]                   }
[16:12:47.205]                   muffleCondition(cond)
[16:12:47.205]                 })
[16:12:47.205]             }))
[16:12:47.205]             future::FutureResult(value = ...future.value$value, 
[16:12:47.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.205]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.205]                     ...future.globalenv.names))
[16:12:47.205]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.205]         }, condition = base::local({
[16:12:47.205]             c <- base::c
[16:12:47.205]             inherits <- base::inherits
[16:12:47.205]             invokeRestart <- base::invokeRestart
[16:12:47.205]             length <- base::length
[16:12:47.205]             list <- base::list
[16:12:47.205]             seq.int <- base::seq.int
[16:12:47.205]             signalCondition <- base::signalCondition
[16:12:47.205]             sys.calls <- base::sys.calls
[16:12:47.205]             `[[` <- base::`[[`
[16:12:47.205]             `+` <- base::`+`
[16:12:47.205]             `<<-` <- base::`<<-`
[16:12:47.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.205]                   3L)]
[16:12:47.205]             }
[16:12:47.205]             function(cond) {
[16:12:47.205]                 is_error <- inherits(cond, "error")
[16:12:47.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.205]                   NULL)
[16:12:47.205]                 if (is_error) {
[16:12:47.205]                   sessionInformation <- function() {
[16:12:47.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.205]                       search = base::search(), system = base::Sys.info())
[16:12:47.205]                   }
[16:12:47.205]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.205]                     cond$call), session = sessionInformation(), 
[16:12:47.205]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.205]                   signalCondition(cond)
[16:12:47.205]                 }
[16:12:47.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.205]                 "immediateCondition"))) {
[16:12:47.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.205]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.205]                   if (TRUE && !signal) {
[16:12:47.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.205]                     {
[16:12:47.205]                       inherits <- base::inherits
[16:12:47.205]                       invokeRestart <- base::invokeRestart
[16:12:47.205]                       is.null <- base::is.null
[16:12:47.205]                       muffled <- FALSE
[16:12:47.205]                       if (inherits(cond, "message")) {
[16:12:47.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.205]                         if (muffled) 
[16:12:47.205]                           invokeRestart("muffleMessage")
[16:12:47.205]                       }
[16:12:47.205]                       else if (inherits(cond, "warning")) {
[16:12:47.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.205]                         if (muffled) 
[16:12:47.205]                           invokeRestart("muffleWarning")
[16:12:47.205]                       }
[16:12:47.205]                       else if (inherits(cond, "condition")) {
[16:12:47.205]                         if (!is.null(pattern)) {
[16:12:47.205]                           computeRestarts <- base::computeRestarts
[16:12:47.205]                           grepl <- base::grepl
[16:12:47.205]                           restarts <- computeRestarts(cond)
[16:12:47.205]                           for (restart in restarts) {
[16:12:47.205]                             name <- restart$name
[16:12:47.205]                             if (is.null(name)) 
[16:12:47.205]                               next
[16:12:47.205]                             if (!grepl(pattern, name)) 
[16:12:47.205]                               next
[16:12:47.205]                             invokeRestart(restart)
[16:12:47.205]                             muffled <- TRUE
[16:12:47.205]                             break
[16:12:47.205]                           }
[16:12:47.205]                         }
[16:12:47.205]                       }
[16:12:47.205]                       invisible(muffled)
[16:12:47.205]                     }
[16:12:47.205]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.205]                   }
[16:12:47.205]                 }
[16:12:47.205]                 else {
[16:12:47.205]                   if (TRUE) {
[16:12:47.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.205]                     {
[16:12:47.205]                       inherits <- base::inherits
[16:12:47.205]                       invokeRestart <- base::invokeRestart
[16:12:47.205]                       is.null <- base::is.null
[16:12:47.205]                       muffled <- FALSE
[16:12:47.205]                       if (inherits(cond, "message")) {
[16:12:47.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.205]                         if (muffled) 
[16:12:47.205]                           invokeRestart("muffleMessage")
[16:12:47.205]                       }
[16:12:47.205]                       else if (inherits(cond, "warning")) {
[16:12:47.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.205]                         if (muffled) 
[16:12:47.205]                           invokeRestart("muffleWarning")
[16:12:47.205]                       }
[16:12:47.205]                       else if (inherits(cond, "condition")) {
[16:12:47.205]                         if (!is.null(pattern)) {
[16:12:47.205]                           computeRestarts <- base::computeRestarts
[16:12:47.205]                           grepl <- base::grepl
[16:12:47.205]                           restarts <- computeRestarts(cond)
[16:12:47.205]                           for (restart in restarts) {
[16:12:47.205]                             name <- restart$name
[16:12:47.205]                             if (is.null(name)) 
[16:12:47.205]                               next
[16:12:47.205]                             if (!grepl(pattern, name)) 
[16:12:47.205]                               next
[16:12:47.205]                             invokeRestart(restart)
[16:12:47.205]                             muffled <- TRUE
[16:12:47.205]                             break
[16:12:47.205]                           }
[16:12:47.205]                         }
[16:12:47.205]                       }
[16:12:47.205]                       invisible(muffled)
[16:12:47.205]                     }
[16:12:47.205]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.205]                   }
[16:12:47.205]                 }
[16:12:47.205]             }
[16:12:47.205]         }))
[16:12:47.205]     }, error = function(ex) {
[16:12:47.205]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.205]                 ...future.rng), started = ...future.startTime, 
[16:12:47.205]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.205]             version = "1.8"), class = "FutureResult")
[16:12:47.205]     }, finally = {
[16:12:47.205]         if (!identical(...future.workdir, getwd())) 
[16:12:47.205]             setwd(...future.workdir)
[16:12:47.205]         {
[16:12:47.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.205]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.205]             }
[16:12:47.205]             base::options(...future.oldOptions)
[16:12:47.205]             if (.Platform$OS.type == "windows") {
[16:12:47.205]                 old_names <- names(...future.oldEnvVars)
[16:12:47.205]                 envs <- base::Sys.getenv()
[16:12:47.205]                 names <- names(envs)
[16:12:47.205]                 common <- intersect(names, old_names)
[16:12:47.205]                 added <- setdiff(names, old_names)
[16:12:47.205]                 removed <- setdiff(old_names, names)
[16:12:47.205]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.205]                   envs[common]]
[16:12:47.205]                 NAMES <- toupper(changed)
[16:12:47.205]                 args <- list()
[16:12:47.205]                 for (kk in seq_along(NAMES)) {
[16:12:47.205]                   name <- changed[[kk]]
[16:12:47.205]                   NAME <- NAMES[[kk]]
[16:12:47.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.205]                     next
[16:12:47.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.205]                 }
[16:12:47.205]                 NAMES <- toupper(added)
[16:12:47.205]                 for (kk in seq_along(NAMES)) {
[16:12:47.205]                   name <- added[[kk]]
[16:12:47.205]                   NAME <- NAMES[[kk]]
[16:12:47.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.205]                     next
[16:12:47.205]                   args[[name]] <- ""
[16:12:47.205]                 }
[16:12:47.205]                 NAMES <- toupper(removed)
[16:12:47.205]                 for (kk in seq_along(NAMES)) {
[16:12:47.205]                   name <- removed[[kk]]
[16:12:47.205]                   NAME <- NAMES[[kk]]
[16:12:47.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.205]                     next
[16:12:47.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.205]                 }
[16:12:47.205]                 if (length(args) > 0) 
[16:12:47.205]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.205]             }
[16:12:47.205]             else {
[16:12:47.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.205]             }
[16:12:47.205]             {
[16:12:47.205]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.205]                   0L) {
[16:12:47.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.205]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.205]                   base::options(opts)
[16:12:47.205]                 }
[16:12:47.205]                 {
[16:12:47.205]                   {
[16:12:47.205]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.205]                     NULL
[16:12:47.205]                   }
[16:12:47.205]                   options(future.plan = NULL)
[16:12:47.205]                   if (is.na(NA_character_)) 
[16:12:47.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.205]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.205]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.205]                     envir = parent.frame()) 
[16:12:47.205]                   {
[16:12:47.205]                     if (is.function(workers)) 
[16:12:47.205]                       workers <- workers()
[16:12:47.205]                     workers <- structure(as.integer(workers), 
[16:12:47.205]                       class = class(workers))
[16:12:47.205]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.205]                       workers >= 1)
[16:12:47.205]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.205]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.205]                     }
[16:12:47.205]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.205]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.205]                       envir = envir)
[16:12:47.205]                     if (!future$lazy) 
[16:12:47.205]                       future <- run(future)
[16:12:47.205]                     invisible(future)
[16:12:47.205]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.205]                 }
[16:12:47.205]             }
[16:12:47.205]         }
[16:12:47.205]     })
[16:12:47.205]     if (TRUE) {
[16:12:47.205]         base::sink(type = "output", split = FALSE)
[16:12:47.205]         if (TRUE) {
[16:12:47.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.205]         }
[16:12:47.205]         else {
[16:12:47.205]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.205]         }
[16:12:47.205]         base::close(...future.stdout)
[16:12:47.205]         ...future.stdout <- NULL
[16:12:47.205]     }
[16:12:47.205]     ...future.result$conditions <- ...future.conditions
[16:12:47.205]     ...future.result$finished <- base::Sys.time()
[16:12:47.205]     ...future.result
[16:12:47.205] }
[16:12:47.208] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:12:47.208] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:12:47.209] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:12:47.209] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:12:47.209] MultisessionFuture started
[16:12:47.210] - Launch lazy future ... done
[16:12:47.210] run() for ‘MultisessionFuture’ ... done
[16:12:47.210] result() for ClusterFuture ...
[16:12:47.210] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.210] - Validating connection of MultisessionFuture
[16:12:47.257] - received message: FutureResult
[16:12:47.257] - Received FutureResult
[16:12:47.257] - Erased future from FutureRegistry
[16:12:47.257] result() for ClusterFuture ...
[16:12:47.258] - result already collected: FutureResult
[16:12:47.258] result() for ClusterFuture ... done
[16:12:47.258] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.258] result() for ClusterFuture ... done
[16:12:47.258] result() for ClusterFuture ...
[16:12:47.258] - result already collected: FutureResult
[16:12:47.258] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.259] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.259] Searching for globals...
[16:12:47.262] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:47.262] Searching for globals ... DONE
[16:12:47.262] Resolving globals: TRUE
[16:12:47.262] Resolving any globals that are futures ...
[16:12:47.262] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:47.262] Resolving any globals that are futures ... DONE
[16:12:47.263] Resolving futures part of globals (recursively) ...
[16:12:47.263] resolve() on list ...
[16:12:47.263]  recursive: 99
[16:12:47.263]  length: 1
[16:12:47.263]  elements: ‘x’
[16:12:47.264]  length: 0 (resolved future 1)
[16:12:47.264] resolve() on list ... DONE
[16:12:47.264] - globals: [1] ‘x’
[16:12:47.264] Resolving futures part of globals (recursively) ... DONE
[16:12:47.264] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:47.265] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:47.265] - globals: [1] ‘x’
[16:12:47.265] 
[16:12:47.265] getGlobalsAndPackages() ... DONE
[16:12:47.265] run() for ‘Future’ ...
[16:12:47.265] - state: ‘created’
[16:12:47.266] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.284] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.285]   - Field: ‘node’
[16:12:47.285]   - Field: ‘label’
[16:12:47.285]   - Field: ‘local’
[16:12:47.285]   - Field: ‘owner’
[16:12:47.285]   - Field: ‘envir’
[16:12:47.285]   - Field: ‘workers’
[16:12:47.285]   - Field: ‘packages’
[16:12:47.285]   - Field: ‘gc’
[16:12:47.286]   - Field: ‘conditions’
[16:12:47.286]   - Field: ‘persistent’
[16:12:47.286]   - Field: ‘expr’
[16:12:47.286]   - Field: ‘uuid’
[16:12:47.286]   - Field: ‘seed’
[16:12:47.286]   - Field: ‘version’
[16:12:47.286]   - Field: ‘result’
[16:12:47.286]   - Field: ‘asynchronous’
[16:12:47.286]   - Field: ‘calls’
[16:12:47.286]   - Field: ‘globals’
[16:12:47.286]   - Field: ‘stdout’
[16:12:47.287]   - Field: ‘earlySignal’
[16:12:47.287]   - Field: ‘lazy’
[16:12:47.287]   - Field: ‘state’
[16:12:47.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.287] - Launch lazy future ...
[16:12:47.287] Packages needed by the future expression (n = 0): <none>
[16:12:47.287] Packages needed by future strategies (n = 0): <none>
[16:12:47.288] {
[16:12:47.288]     {
[16:12:47.288]         {
[16:12:47.288]             ...future.startTime <- base::Sys.time()
[16:12:47.288]             {
[16:12:47.288]                 {
[16:12:47.288]                   {
[16:12:47.288]                     {
[16:12:47.288]                       base::local({
[16:12:47.288]                         has_future <- base::requireNamespace("future", 
[16:12:47.288]                           quietly = TRUE)
[16:12:47.288]                         if (has_future) {
[16:12:47.288]                           ns <- base::getNamespace("future")
[16:12:47.288]                           version <- ns[[".package"]][["version"]]
[16:12:47.288]                           if (is.null(version)) 
[16:12:47.288]                             version <- utils::packageVersion("future")
[16:12:47.288]                         }
[16:12:47.288]                         else {
[16:12:47.288]                           version <- NULL
[16:12:47.288]                         }
[16:12:47.288]                         if (!has_future || version < "1.8.0") {
[16:12:47.288]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.288]                             "", base::R.version$version.string), 
[16:12:47.288]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.288]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.288]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.288]                               "release", "version")], collapse = " "), 
[16:12:47.288]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.288]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.288]                             info)
[16:12:47.288]                           info <- base::paste(info, collapse = "; ")
[16:12:47.288]                           if (!has_future) {
[16:12:47.288]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.288]                               info)
[16:12:47.288]                           }
[16:12:47.288]                           else {
[16:12:47.288]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.288]                               info, version)
[16:12:47.288]                           }
[16:12:47.288]                           base::stop(msg)
[16:12:47.288]                         }
[16:12:47.288]                       })
[16:12:47.288]                     }
[16:12:47.288]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.288]                     base::options(mc.cores = 1L)
[16:12:47.288]                   }
[16:12:47.288]                   options(future.plan = NULL)
[16:12:47.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.288]                 }
[16:12:47.288]                 ...future.workdir <- getwd()
[16:12:47.288]             }
[16:12:47.288]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.288]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.288]         }
[16:12:47.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.288]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.288]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.288]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.288]             base::names(...future.oldOptions))
[16:12:47.288]     }
[16:12:47.288]     if (FALSE) {
[16:12:47.288]     }
[16:12:47.288]     else {
[16:12:47.288]         if (TRUE) {
[16:12:47.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.288]                 open = "w")
[16:12:47.288]         }
[16:12:47.288]         else {
[16:12:47.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.288]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.288]         }
[16:12:47.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.288]             base::sink(type = "output", split = FALSE)
[16:12:47.288]             base::close(...future.stdout)
[16:12:47.288]         }, add = TRUE)
[16:12:47.288]     }
[16:12:47.288]     ...future.frame <- base::sys.nframe()
[16:12:47.288]     ...future.conditions <- base::list()
[16:12:47.288]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.288]     if (FALSE) {
[16:12:47.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.288]     }
[16:12:47.288]     ...future.result <- base::tryCatch({
[16:12:47.288]         base::withCallingHandlers({
[16:12:47.288]             ...future.value <- base::withVisible(base::local({
[16:12:47.288]                 ...future.makeSendCondition <- local({
[16:12:47.288]                   sendCondition <- NULL
[16:12:47.288]                   function(frame = 1L) {
[16:12:47.288]                     if (is.function(sendCondition)) 
[16:12:47.288]                       return(sendCondition)
[16:12:47.288]                     ns <- getNamespace("parallel")
[16:12:47.288]                     if (exists("sendData", mode = "function", 
[16:12:47.288]                       envir = ns)) {
[16:12:47.288]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.288]                         envir = ns)
[16:12:47.288]                       envir <- sys.frame(frame)
[16:12:47.288]                       master <- NULL
[16:12:47.288]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.288]                         !identical(envir, emptyenv())) {
[16:12:47.288]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.288]                           inherits = FALSE)) {
[16:12:47.288]                           master <- get("master", mode = "list", 
[16:12:47.288]                             envir = envir, inherits = FALSE)
[16:12:47.288]                           if (inherits(master, c("SOCKnode", 
[16:12:47.288]                             "SOCK0node"))) {
[16:12:47.288]                             sendCondition <<- function(cond) {
[16:12:47.288]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.288]                                 success = TRUE)
[16:12:47.288]                               parallel_sendData(master, data)
[16:12:47.288]                             }
[16:12:47.288]                             return(sendCondition)
[16:12:47.288]                           }
[16:12:47.288]                         }
[16:12:47.288]                         frame <- frame + 1L
[16:12:47.288]                         envir <- sys.frame(frame)
[16:12:47.288]                       }
[16:12:47.288]                     }
[16:12:47.288]                     sendCondition <<- function(cond) NULL
[16:12:47.288]                   }
[16:12:47.288]                 })
[16:12:47.288]                 withCallingHandlers({
[16:12:47.288]                   {
[16:12:47.288]                     x$a <- 1
[16:12:47.288]                     x
[16:12:47.288]                   }
[16:12:47.288]                 }, immediateCondition = function(cond) {
[16:12:47.288]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.288]                   sendCondition(cond)
[16:12:47.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.288]                   {
[16:12:47.288]                     inherits <- base::inherits
[16:12:47.288]                     invokeRestart <- base::invokeRestart
[16:12:47.288]                     is.null <- base::is.null
[16:12:47.288]                     muffled <- FALSE
[16:12:47.288]                     if (inherits(cond, "message")) {
[16:12:47.288]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.288]                       if (muffled) 
[16:12:47.288]                         invokeRestart("muffleMessage")
[16:12:47.288]                     }
[16:12:47.288]                     else if (inherits(cond, "warning")) {
[16:12:47.288]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.288]                       if (muffled) 
[16:12:47.288]                         invokeRestart("muffleWarning")
[16:12:47.288]                     }
[16:12:47.288]                     else if (inherits(cond, "condition")) {
[16:12:47.288]                       if (!is.null(pattern)) {
[16:12:47.288]                         computeRestarts <- base::computeRestarts
[16:12:47.288]                         grepl <- base::grepl
[16:12:47.288]                         restarts <- computeRestarts(cond)
[16:12:47.288]                         for (restart in restarts) {
[16:12:47.288]                           name <- restart$name
[16:12:47.288]                           if (is.null(name)) 
[16:12:47.288]                             next
[16:12:47.288]                           if (!grepl(pattern, name)) 
[16:12:47.288]                             next
[16:12:47.288]                           invokeRestart(restart)
[16:12:47.288]                           muffled <- TRUE
[16:12:47.288]                           break
[16:12:47.288]                         }
[16:12:47.288]                       }
[16:12:47.288]                     }
[16:12:47.288]                     invisible(muffled)
[16:12:47.288]                   }
[16:12:47.288]                   muffleCondition(cond)
[16:12:47.288]                 })
[16:12:47.288]             }))
[16:12:47.288]             future::FutureResult(value = ...future.value$value, 
[16:12:47.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.288]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.288]                     ...future.globalenv.names))
[16:12:47.288]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.288]         }, condition = base::local({
[16:12:47.288]             c <- base::c
[16:12:47.288]             inherits <- base::inherits
[16:12:47.288]             invokeRestart <- base::invokeRestart
[16:12:47.288]             length <- base::length
[16:12:47.288]             list <- base::list
[16:12:47.288]             seq.int <- base::seq.int
[16:12:47.288]             signalCondition <- base::signalCondition
[16:12:47.288]             sys.calls <- base::sys.calls
[16:12:47.288]             `[[` <- base::`[[`
[16:12:47.288]             `+` <- base::`+`
[16:12:47.288]             `<<-` <- base::`<<-`
[16:12:47.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.288]                   3L)]
[16:12:47.288]             }
[16:12:47.288]             function(cond) {
[16:12:47.288]                 is_error <- inherits(cond, "error")
[16:12:47.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.288]                   NULL)
[16:12:47.288]                 if (is_error) {
[16:12:47.288]                   sessionInformation <- function() {
[16:12:47.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.288]                       search = base::search(), system = base::Sys.info())
[16:12:47.288]                   }
[16:12:47.288]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.288]                     cond$call), session = sessionInformation(), 
[16:12:47.288]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.288]                   signalCondition(cond)
[16:12:47.288]                 }
[16:12:47.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.288]                 "immediateCondition"))) {
[16:12:47.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.288]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.288]                   if (TRUE && !signal) {
[16:12:47.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.288]                     {
[16:12:47.288]                       inherits <- base::inherits
[16:12:47.288]                       invokeRestart <- base::invokeRestart
[16:12:47.288]                       is.null <- base::is.null
[16:12:47.288]                       muffled <- FALSE
[16:12:47.288]                       if (inherits(cond, "message")) {
[16:12:47.288]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.288]                         if (muffled) 
[16:12:47.288]                           invokeRestart("muffleMessage")
[16:12:47.288]                       }
[16:12:47.288]                       else if (inherits(cond, "warning")) {
[16:12:47.288]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.288]                         if (muffled) 
[16:12:47.288]                           invokeRestart("muffleWarning")
[16:12:47.288]                       }
[16:12:47.288]                       else if (inherits(cond, "condition")) {
[16:12:47.288]                         if (!is.null(pattern)) {
[16:12:47.288]                           computeRestarts <- base::computeRestarts
[16:12:47.288]                           grepl <- base::grepl
[16:12:47.288]                           restarts <- computeRestarts(cond)
[16:12:47.288]                           for (restart in restarts) {
[16:12:47.288]                             name <- restart$name
[16:12:47.288]                             if (is.null(name)) 
[16:12:47.288]                               next
[16:12:47.288]                             if (!grepl(pattern, name)) 
[16:12:47.288]                               next
[16:12:47.288]                             invokeRestart(restart)
[16:12:47.288]                             muffled <- TRUE
[16:12:47.288]                             break
[16:12:47.288]                           }
[16:12:47.288]                         }
[16:12:47.288]                       }
[16:12:47.288]                       invisible(muffled)
[16:12:47.288]                     }
[16:12:47.288]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.288]                   }
[16:12:47.288]                 }
[16:12:47.288]                 else {
[16:12:47.288]                   if (TRUE) {
[16:12:47.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.288]                     {
[16:12:47.288]                       inherits <- base::inherits
[16:12:47.288]                       invokeRestart <- base::invokeRestart
[16:12:47.288]                       is.null <- base::is.null
[16:12:47.288]                       muffled <- FALSE
[16:12:47.288]                       if (inherits(cond, "message")) {
[16:12:47.288]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.288]                         if (muffled) 
[16:12:47.288]                           invokeRestart("muffleMessage")
[16:12:47.288]                       }
[16:12:47.288]                       else if (inherits(cond, "warning")) {
[16:12:47.288]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.288]                         if (muffled) 
[16:12:47.288]                           invokeRestart("muffleWarning")
[16:12:47.288]                       }
[16:12:47.288]                       else if (inherits(cond, "condition")) {
[16:12:47.288]                         if (!is.null(pattern)) {
[16:12:47.288]                           computeRestarts <- base::computeRestarts
[16:12:47.288]                           grepl <- base::grepl
[16:12:47.288]                           restarts <- computeRestarts(cond)
[16:12:47.288]                           for (restart in restarts) {
[16:12:47.288]                             name <- restart$name
[16:12:47.288]                             if (is.null(name)) 
[16:12:47.288]                               next
[16:12:47.288]                             if (!grepl(pattern, name)) 
[16:12:47.288]                               next
[16:12:47.288]                             invokeRestart(restart)
[16:12:47.288]                             muffled <- TRUE
[16:12:47.288]                             break
[16:12:47.288]                           }
[16:12:47.288]                         }
[16:12:47.288]                       }
[16:12:47.288]                       invisible(muffled)
[16:12:47.288]                     }
[16:12:47.288]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.288]                   }
[16:12:47.288]                 }
[16:12:47.288]             }
[16:12:47.288]         }))
[16:12:47.288]     }, error = function(ex) {
[16:12:47.288]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.288]                 ...future.rng), started = ...future.startTime, 
[16:12:47.288]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.288]             version = "1.8"), class = "FutureResult")
[16:12:47.288]     }, finally = {
[16:12:47.288]         if (!identical(...future.workdir, getwd())) 
[16:12:47.288]             setwd(...future.workdir)
[16:12:47.288]         {
[16:12:47.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.288]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.288]             }
[16:12:47.288]             base::options(...future.oldOptions)
[16:12:47.288]             if (.Platform$OS.type == "windows") {
[16:12:47.288]                 old_names <- names(...future.oldEnvVars)
[16:12:47.288]                 envs <- base::Sys.getenv()
[16:12:47.288]                 names <- names(envs)
[16:12:47.288]                 common <- intersect(names, old_names)
[16:12:47.288]                 added <- setdiff(names, old_names)
[16:12:47.288]                 removed <- setdiff(old_names, names)
[16:12:47.288]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.288]                   envs[common]]
[16:12:47.288]                 NAMES <- toupper(changed)
[16:12:47.288]                 args <- list()
[16:12:47.288]                 for (kk in seq_along(NAMES)) {
[16:12:47.288]                   name <- changed[[kk]]
[16:12:47.288]                   NAME <- NAMES[[kk]]
[16:12:47.288]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.288]                     next
[16:12:47.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.288]                 }
[16:12:47.288]                 NAMES <- toupper(added)
[16:12:47.288]                 for (kk in seq_along(NAMES)) {
[16:12:47.288]                   name <- added[[kk]]
[16:12:47.288]                   NAME <- NAMES[[kk]]
[16:12:47.288]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.288]                     next
[16:12:47.288]                   args[[name]] <- ""
[16:12:47.288]                 }
[16:12:47.288]                 NAMES <- toupper(removed)
[16:12:47.288]                 for (kk in seq_along(NAMES)) {
[16:12:47.288]                   name <- removed[[kk]]
[16:12:47.288]                   NAME <- NAMES[[kk]]
[16:12:47.288]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.288]                     next
[16:12:47.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.288]                 }
[16:12:47.288]                 if (length(args) > 0) 
[16:12:47.288]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.288]             }
[16:12:47.288]             else {
[16:12:47.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.288]             }
[16:12:47.288]             {
[16:12:47.288]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.288]                   0L) {
[16:12:47.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.288]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.288]                   base::options(opts)
[16:12:47.288]                 }
[16:12:47.288]                 {
[16:12:47.288]                   {
[16:12:47.288]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.288]                     NULL
[16:12:47.288]                   }
[16:12:47.288]                   options(future.plan = NULL)
[16:12:47.288]                   if (is.na(NA_character_)) 
[16:12:47.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.288]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.288]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.288]                     envir = parent.frame()) 
[16:12:47.288]                   {
[16:12:47.288]                     if (is.function(workers)) 
[16:12:47.288]                       workers <- workers()
[16:12:47.288]                     workers <- structure(as.integer(workers), 
[16:12:47.288]                       class = class(workers))
[16:12:47.288]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.288]                       workers >= 1)
[16:12:47.288]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.288]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.288]                     }
[16:12:47.288]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.288]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.288]                       envir = envir)
[16:12:47.288]                     if (!future$lazy) 
[16:12:47.288]                       future <- run(future)
[16:12:47.288]                     invisible(future)
[16:12:47.288]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.288]                 }
[16:12:47.288]             }
[16:12:47.288]         }
[16:12:47.288]     })
[16:12:47.288]     if (TRUE) {
[16:12:47.288]         base::sink(type = "output", split = FALSE)
[16:12:47.288]         if (TRUE) {
[16:12:47.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.288]         }
[16:12:47.288]         else {
[16:12:47.288]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.288]         }
[16:12:47.288]         base::close(...future.stdout)
[16:12:47.288]         ...future.stdout <- NULL
[16:12:47.288]     }
[16:12:47.288]     ...future.result$conditions <- ...future.conditions
[16:12:47.288]     ...future.result$finished <- base::Sys.time()
[16:12:47.288]     ...future.result
[16:12:47.288] }
[16:12:47.291] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:12:47.291] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:12:47.291] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:12:47.291] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:12:47.292] MultisessionFuture started
[16:12:47.292] - Launch lazy future ... done
[16:12:47.292] run() for ‘MultisessionFuture’ ... done
[16:12:47.292] result() for ClusterFuture ...
[16:12:47.292] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.292] - Validating connection of MultisessionFuture
[16:12:47.341] - received message: FutureResult
[16:12:47.341] - Received FutureResult
[16:12:47.341] - Erased future from FutureRegistry
[16:12:47.341] result() for ClusterFuture ...
[16:12:47.341] - result already collected: FutureResult
[16:12:47.342] result() for ClusterFuture ... done
[16:12:47.342] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.342] result() for ClusterFuture ... done
[16:12:47.342] result() for ClusterFuture ...
[16:12:47.342] - result already collected: FutureResult
[16:12:47.342] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.343] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.343] Searching for globals...
[16:12:47.345] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:47.345] Searching for globals ... DONE
[16:12:47.345] Resolving globals: TRUE
[16:12:47.345] Resolving any globals that are futures ...
[16:12:47.345] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[16:12:47.345] Resolving any globals that are futures ... DONE
[16:12:47.346] Resolving futures part of globals (recursively) ...
[16:12:47.346] resolve() on list ...
[16:12:47.346]  recursive: 99
[16:12:47.346]  length: 1
[16:12:47.346]  elements: ‘x’
[16:12:47.346]  length: 0 (resolved future 1)
[16:12:47.346] resolve() on list ... DONE
[16:12:47.346] - globals: [1] ‘x’
[16:12:47.347] Resolving futures part of globals (recursively) ... DONE
[16:12:47.347] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:47.347] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:47.347] - globals: [1] ‘x’
[16:12:47.347] 
[16:12:47.347] getGlobalsAndPackages() ... DONE
[16:12:47.348] run() for ‘Future’ ...
[16:12:47.348] - state: ‘created’
[16:12:47.348] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.363] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.363] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.364]   - Field: ‘node’
[16:12:47.364]   - Field: ‘label’
[16:12:47.364]   - Field: ‘local’
[16:12:47.364]   - Field: ‘owner’
[16:12:47.364]   - Field: ‘envir’
[16:12:47.364]   - Field: ‘workers’
[16:12:47.364]   - Field: ‘packages’
[16:12:47.364]   - Field: ‘gc’
[16:12:47.364]   - Field: ‘conditions’
[16:12:47.364]   - Field: ‘persistent’
[16:12:47.365]   - Field: ‘expr’
[16:12:47.365]   - Field: ‘uuid’
[16:12:47.365]   - Field: ‘seed’
[16:12:47.365]   - Field: ‘version’
[16:12:47.365]   - Field: ‘result’
[16:12:47.365]   - Field: ‘asynchronous’
[16:12:47.365]   - Field: ‘calls’
[16:12:47.365]   - Field: ‘globals’
[16:12:47.365]   - Field: ‘stdout’
[16:12:47.365]   - Field: ‘earlySignal’
[16:12:47.365]   - Field: ‘lazy’
[16:12:47.366]   - Field: ‘state’
[16:12:47.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.366] - Launch lazy future ...
[16:12:47.366] Packages needed by the future expression (n = 0): <none>
[16:12:47.366] Packages needed by future strategies (n = 0): <none>
[16:12:47.367] {
[16:12:47.367]     {
[16:12:47.367]         {
[16:12:47.367]             ...future.startTime <- base::Sys.time()
[16:12:47.367]             {
[16:12:47.367]                 {
[16:12:47.367]                   {
[16:12:47.367]                     {
[16:12:47.367]                       base::local({
[16:12:47.367]                         has_future <- base::requireNamespace("future", 
[16:12:47.367]                           quietly = TRUE)
[16:12:47.367]                         if (has_future) {
[16:12:47.367]                           ns <- base::getNamespace("future")
[16:12:47.367]                           version <- ns[[".package"]][["version"]]
[16:12:47.367]                           if (is.null(version)) 
[16:12:47.367]                             version <- utils::packageVersion("future")
[16:12:47.367]                         }
[16:12:47.367]                         else {
[16:12:47.367]                           version <- NULL
[16:12:47.367]                         }
[16:12:47.367]                         if (!has_future || version < "1.8.0") {
[16:12:47.367]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.367]                             "", base::R.version$version.string), 
[16:12:47.367]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.367]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.367]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.367]                               "release", "version")], collapse = " "), 
[16:12:47.367]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.367]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.367]                             info)
[16:12:47.367]                           info <- base::paste(info, collapse = "; ")
[16:12:47.367]                           if (!has_future) {
[16:12:47.367]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.367]                               info)
[16:12:47.367]                           }
[16:12:47.367]                           else {
[16:12:47.367]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.367]                               info, version)
[16:12:47.367]                           }
[16:12:47.367]                           base::stop(msg)
[16:12:47.367]                         }
[16:12:47.367]                       })
[16:12:47.367]                     }
[16:12:47.367]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.367]                     base::options(mc.cores = 1L)
[16:12:47.367]                   }
[16:12:47.367]                   options(future.plan = NULL)
[16:12:47.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.367]                 }
[16:12:47.367]                 ...future.workdir <- getwd()
[16:12:47.367]             }
[16:12:47.367]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.367]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.367]         }
[16:12:47.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.367]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.367]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.367]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.367]             base::names(...future.oldOptions))
[16:12:47.367]     }
[16:12:47.367]     if (FALSE) {
[16:12:47.367]     }
[16:12:47.367]     else {
[16:12:47.367]         if (TRUE) {
[16:12:47.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.367]                 open = "w")
[16:12:47.367]         }
[16:12:47.367]         else {
[16:12:47.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.367]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.367]         }
[16:12:47.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.367]             base::sink(type = "output", split = FALSE)
[16:12:47.367]             base::close(...future.stdout)
[16:12:47.367]         }, add = TRUE)
[16:12:47.367]     }
[16:12:47.367]     ...future.frame <- base::sys.nframe()
[16:12:47.367]     ...future.conditions <- base::list()
[16:12:47.367]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.367]     if (FALSE) {
[16:12:47.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.367]     }
[16:12:47.367]     ...future.result <- base::tryCatch({
[16:12:47.367]         base::withCallingHandlers({
[16:12:47.367]             ...future.value <- base::withVisible(base::local({
[16:12:47.367]                 ...future.makeSendCondition <- local({
[16:12:47.367]                   sendCondition <- NULL
[16:12:47.367]                   function(frame = 1L) {
[16:12:47.367]                     if (is.function(sendCondition)) 
[16:12:47.367]                       return(sendCondition)
[16:12:47.367]                     ns <- getNamespace("parallel")
[16:12:47.367]                     if (exists("sendData", mode = "function", 
[16:12:47.367]                       envir = ns)) {
[16:12:47.367]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.367]                         envir = ns)
[16:12:47.367]                       envir <- sys.frame(frame)
[16:12:47.367]                       master <- NULL
[16:12:47.367]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.367]                         !identical(envir, emptyenv())) {
[16:12:47.367]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.367]                           inherits = FALSE)) {
[16:12:47.367]                           master <- get("master", mode = "list", 
[16:12:47.367]                             envir = envir, inherits = FALSE)
[16:12:47.367]                           if (inherits(master, c("SOCKnode", 
[16:12:47.367]                             "SOCK0node"))) {
[16:12:47.367]                             sendCondition <<- function(cond) {
[16:12:47.367]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.367]                                 success = TRUE)
[16:12:47.367]                               parallel_sendData(master, data)
[16:12:47.367]                             }
[16:12:47.367]                             return(sendCondition)
[16:12:47.367]                           }
[16:12:47.367]                         }
[16:12:47.367]                         frame <- frame + 1L
[16:12:47.367]                         envir <- sys.frame(frame)
[16:12:47.367]                       }
[16:12:47.367]                     }
[16:12:47.367]                     sendCondition <<- function(cond) NULL
[16:12:47.367]                   }
[16:12:47.367]                 })
[16:12:47.367]                 withCallingHandlers({
[16:12:47.367]                   {
[16:12:47.367]                     x$a <- 1
[16:12:47.367]                     x
[16:12:47.367]                   }
[16:12:47.367]                 }, immediateCondition = function(cond) {
[16:12:47.367]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.367]                   sendCondition(cond)
[16:12:47.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.367]                   {
[16:12:47.367]                     inherits <- base::inherits
[16:12:47.367]                     invokeRestart <- base::invokeRestart
[16:12:47.367]                     is.null <- base::is.null
[16:12:47.367]                     muffled <- FALSE
[16:12:47.367]                     if (inherits(cond, "message")) {
[16:12:47.367]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.367]                       if (muffled) 
[16:12:47.367]                         invokeRestart("muffleMessage")
[16:12:47.367]                     }
[16:12:47.367]                     else if (inherits(cond, "warning")) {
[16:12:47.367]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.367]                       if (muffled) 
[16:12:47.367]                         invokeRestart("muffleWarning")
[16:12:47.367]                     }
[16:12:47.367]                     else if (inherits(cond, "condition")) {
[16:12:47.367]                       if (!is.null(pattern)) {
[16:12:47.367]                         computeRestarts <- base::computeRestarts
[16:12:47.367]                         grepl <- base::grepl
[16:12:47.367]                         restarts <- computeRestarts(cond)
[16:12:47.367]                         for (restart in restarts) {
[16:12:47.367]                           name <- restart$name
[16:12:47.367]                           if (is.null(name)) 
[16:12:47.367]                             next
[16:12:47.367]                           if (!grepl(pattern, name)) 
[16:12:47.367]                             next
[16:12:47.367]                           invokeRestart(restart)
[16:12:47.367]                           muffled <- TRUE
[16:12:47.367]                           break
[16:12:47.367]                         }
[16:12:47.367]                       }
[16:12:47.367]                     }
[16:12:47.367]                     invisible(muffled)
[16:12:47.367]                   }
[16:12:47.367]                   muffleCondition(cond)
[16:12:47.367]                 })
[16:12:47.367]             }))
[16:12:47.367]             future::FutureResult(value = ...future.value$value, 
[16:12:47.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.367]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.367]                     ...future.globalenv.names))
[16:12:47.367]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.367]         }, condition = base::local({
[16:12:47.367]             c <- base::c
[16:12:47.367]             inherits <- base::inherits
[16:12:47.367]             invokeRestart <- base::invokeRestart
[16:12:47.367]             length <- base::length
[16:12:47.367]             list <- base::list
[16:12:47.367]             seq.int <- base::seq.int
[16:12:47.367]             signalCondition <- base::signalCondition
[16:12:47.367]             sys.calls <- base::sys.calls
[16:12:47.367]             `[[` <- base::`[[`
[16:12:47.367]             `+` <- base::`+`
[16:12:47.367]             `<<-` <- base::`<<-`
[16:12:47.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.367]                   3L)]
[16:12:47.367]             }
[16:12:47.367]             function(cond) {
[16:12:47.367]                 is_error <- inherits(cond, "error")
[16:12:47.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.367]                   NULL)
[16:12:47.367]                 if (is_error) {
[16:12:47.367]                   sessionInformation <- function() {
[16:12:47.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.367]                       search = base::search(), system = base::Sys.info())
[16:12:47.367]                   }
[16:12:47.367]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.367]                     cond$call), session = sessionInformation(), 
[16:12:47.367]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.367]                   signalCondition(cond)
[16:12:47.367]                 }
[16:12:47.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.367]                 "immediateCondition"))) {
[16:12:47.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.367]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.367]                   if (TRUE && !signal) {
[16:12:47.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.367]                     {
[16:12:47.367]                       inherits <- base::inherits
[16:12:47.367]                       invokeRestart <- base::invokeRestart
[16:12:47.367]                       is.null <- base::is.null
[16:12:47.367]                       muffled <- FALSE
[16:12:47.367]                       if (inherits(cond, "message")) {
[16:12:47.367]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.367]                         if (muffled) 
[16:12:47.367]                           invokeRestart("muffleMessage")
[16:12:47.367]                       }
[16:12:47.367]                       else if (inherits(cond, "warning")) {
[16:12:47.367]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.367]                         if (muffled) 
[16:12:47.367]                           invokeRestart("muffleWarning")
[16:12:47.367]                       }
[16:12:47.367]                       else if (inherits(cond, "condition")) {
[16:12:47.367]                         if (!is.null(pattern)) {
[16:12:47.367]                           computeRestarts <- base::computeRestarts
[16:12:47.367]                           grepl <- base::grepl
[16:12:47.367]                           restarts <- computeRestarts(cond)
[16:12:47.367]                           for (restart in restarts) {
[16:12:47.367]                             name <- restart$name
[16:12:47.367]                             if (is.null(name)) 
[16:12:47.367]                               next
[16:12:47.367]                             if (!grepl(pattern, name)) 
[16:12:47.367]                               next
[16:12:47.367]                             invokeRestart(restart)
[16:12:47.367]                             muffled <- TRUE
[16:12:47.367]                             break
[16:12:47.367]                           }
[16:12:47.367]                         }
[16:12:47.367]                       }
[16:12:47.367]                       invisible(muffled)
[16:12:47.367]                     }
[16:12:47.367]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.367]                   }
[16:12:47.367]                 }
[16:12:47.367]                 else {
[16:12:47.367]                   if (TRUE) {
[16:12:47.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.367]                     {
[16:12:47.367]                       inherits <- base::inherits
[16:12:47.367]                       invokeRestart <- base::invokeRestart
[16:12:47.367]                       is.null <- base::is.null
[16:12:47.367]                       muffled <- FALSE
[16:12:47.367]                       if (inherits(cond, "message")) {
[16:12:47.367]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.367]                         if (muffled) 
[16:12:47.367]                           invokeRestart("muffleMessage")
[16:12:47.367]                       }
[16:12:47.367]                       else if (inherits(cond, "warning")) {
[16:12:47.367]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.367]                         if (muffled) 
[16:12:47.367]                           invokeRestart("muffleWarning")
[16:12:47.367]                       }
[16:12:47.367]                       else if (inherits(cond, "condition")) {
[16:12:47.367]                         if (!is.null(pattern)) {
[16:12:47.367]                           computeRestarts <- base::computeRestarts
[16:12:47.367]                           grepl <- base::grepl
[16:12:47.367]                           restarts <- computeRestarts(cond)
[16:12:47.367]                           for (restart in restarts) {
[16:12:47.367]                             name <- restart$name
[16:12:47.367]                             if (is.null(name)) 
[16:12:47.367]                               next
[16:12:47.367]                             if (!grepl(pattern, name)) 
[16:12:47.367]                               next
[16:12:47.367]                             invokeRestart(restart)
[16:12:47.367]                             muffled <- TRUE
[16:12:47.367]                             break
[16:12:47.367]                           }
[16:12:47.367]                         }
[16:12:47.367]                       }
[16:12:47.367]                       invisible(muffled)
[16:12:47.367]                     }
[16:12:47.367]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.367]                   }
[16:12:47.367]                 }
[16:12:47.367]             }
[16:12:47.367]         }))
[16:12:47.367]     }, error = function(ex) {
[16:12:47.367]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.367]                 ...future.rng), started = ...future.startTime, 
[16:12:47.367]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.367]             version = "1.8"), class = "FutureResult")
[16:12:47.367]     }, finally = {
[16:12:47.367]         if (!identical(...future.workdir, getwd())) 
[16:12:47.367]             setwd(...future.workdir)
[16:12:47.367]         {
[16:12:47.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.367]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.367]             }
[16:12:47.367]             base::options(...future.oldOptions)
[16:12:47.367]             if (.Platform$OS.type == "windows") {
[16:12:47.367]                 old_names <- names(...future.oldEnvVars)
[16:12:47.367]                 envs <- base::Sys.getenv()
[16:12:47.367]                 names <- names(envs)
[16:12:47.367]                 common <- intersect(names, old_names)
[16:12:47.367]                 added <- setdiff(names, old_names)
[16:12:47.367]                 removed <- setdiff(old_names, names)
[16:12:47.367]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.367]                   envs[common]]
[16:12:47.367]                 NAMES <- toupper(changed)
[16:12:47.367]                 args <- list()
[16:12:47.367]                 for (kk in seq_along(NAMES)) {
[16:12:47.367]                   name <- changed[[kk]]
[16:12:47.367]                   NAME <- NAMES[[kk]]
[16:12:47.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.367]                     next
[16:12:47.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.367]                 }
[16:12:47.367]                 NAMES <- toupper(added)
[16:12:47.367]                 for (kk in seq_along(NAMES)) {
[16:12:47.367]                   name <- added[[kk]]
[16:12:47.367]                   NAME <- NAMES[[kk]]
[16:12:47.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.367]                     next
[16:12:47.367]                   args[[name]] <- ""
[16:12:47.367]                 }
[16:12:47.367]                 NAMES <- toupper(removed)
[16:12:47.367]                 for (kk in seq_along(NAMES)) {
[16:12:47.367]                   name <- removed[[kk]]
[16:12:47.367]                   NAME <- NAMES[[kk]]
[16:12:47.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.367]                     next
[16:12:47.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.367]                 }
[16:12:47.367]                 if (length(args) > 0) 
[16:12:47.367]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.367]             }
[16:12:47.367]             else {
[16:12:47.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.367]             }
[16:12:47.367]             {
[16:12:47.367]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.367]                   0L) {
[16:12:47.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.367]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.367]                   base::options(opts)
[16:12:47.367]                 }
[16:12:47.367]                 {
[16:12:47.367]                   {
[16:12:47.367]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.367]                     NULL
[16:12:47.367]                   }
[16:12:47.367]                   options(future.plan = NULL)
[16:12:47.367]                   if (is.na(NA_character_)) 
[16:12:47.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.367]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.367]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.367]                     envir = parent.frame()) 
[16:12:47.367]                   {
[16:12:47.367]                     if (is.function(workers)) 
[16:12:47.367]                       workers <- workers()
[16:12:47.367]                     workers <- structure(as.integer(workers), 
[16:12:47.367]                       class = class(workers))
[16:12:47.367]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.367]                       workers >= 1)
[16:12:47.367]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.367]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.367]                     }
[16:12:47.367]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.367]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.367]                       envir = envir)
[16:12:47.367]                     if (!future$lazy) 
[16:12:47.367]                       future <- run(future)
[16:12:47.367]                     invisible(future)
[16:12:47.367]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.367]                 }
[16:12:47.367]             }
[16:12:47.367]         }
[16:12:47.367]     })
[16:12:47.367]     if (TRUE) {
[16:12:47.367]         base::sink(type = "output", split = FALSE)
[16:12:47.367]         if (TRUE) {
[16:12:47.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.367]         }
[16:12:47.367]         else {
[16:12:47.367]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.367]         }
[16:12:47.367]         base::close(...future.stdout)
[16:12:47.367]         ...future.stdout <- NULL
[16:12:47.367]     }
[16:12:47.367]     ...future.result$conditions <- ...future.conditions
[16:12:47.367]     ...future.result$finished <- base::Sys.time()
[16:12:47.367]     ...future.result
[16:12:47.367] }
[16:12:47.370] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:12:47.370] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:12:47.370] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:12:47.370] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:12:47.371] MultisessionFuture started
[16:12:47.371] - Launch lazy future ... done
[16:12:47.371] run() for ‘MultisessionFuture’ ... done
[16:12:47.371] result() for ClusterFuture ...
[16:12:47.371] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.371] - Validating connection of MultisessionFuture
[16:12:47.417] - received message: FutureResult
[16:12:47.417] - Received FutureResult
[16:12:47.417] - Erased future from FutureRegistry
[16:12:47.417] result() for ClusterFuture ...
[16:12:47.417] - result already collected: FutureResult
[16:12:47.417] result() for ClusterFuture ... done
[16:12:47.417] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.417] result() for ClusterFuture ... done
[16:12:47.418] result() for ClusterFuture ...
[16:12:47.418] - result already collected: FutureResult
[16:12:47.418] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.418] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.418] Searching for globals...
[16:12:47.421] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:12:47.421] Searching for globals ... DONE
[16:12:47.421] Resolving globals: TRUE
[16:12:47.421] Resolving any globals that are futures ...
[16:12:47.422] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[16:12:47.422] Resolving any globals that are futures ... DONE
[16:12:47.422] 
[16:12:47.422] 
[16:12:47.422] getGlobalsAndPackages() ... DONE
[16:12:47.423] run() for ‘Future’ ...
[16:12:47.423] - state: ‘created’
[16:12:47.423] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.437] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.438]   - Field: ‘node’
[16:12:47.438]   - Field: ‘label’
[16:12:47.438]   - Field: ‘local’
[16:12:47.438]   - Field: ‘owner’
[16:12:47.438]   - Field: ‘envir’
[16:12:47.438]   - Field: ‘workers’
[16:12:47.438]   - Field: ‘packages’
[16:12:47.438]   - Field: ‘gc’
[16:12:47.438]   - Field: ‘conditions’
[16:12:47.439]   - Field: ‘persistent’
[16:12:47.439]   - Field: ‘expr’
[16:12:47.439]   - Field: ‘uuid’
[16:12:47.439]   - Field: ‘seed’
[16:12:47.439]   - Field: ‘version’
[16:12:47.439]   - Field: ‘result’
[16:12:47.439]   - Field: ‘asynchronous’
[16:12:47.439]   - Field: ‘calls’
[16:12:47.439]   - Field: ‘globals’
[16:12:47.439]   - Field: ‘stdout’
[16:12:47.439]   - Field: ‘earlySignal’
[16:12:47.440]   - Field: ‘lazy’
[16:12:47.440]   - Field: ‘state’
[16:12:47.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.440] - Launch lazy future ...
[16:12:47.440] Packages needed by the future expression (n = 0): <none>
[16:12:47.440] Packages needed by future strategies (n = 0): <none>
[16:12:47.441] {
[16:12:47.441]     {
[16:12:47.441]         {
[16:12:47.441]             ...future.startTime <- base::Sys.time()
[16:12:47.441]             {
[16:12:47.441]                 {
[16:12:47.441]                   {
[16:12:47.441]                     {
[16:12:47.441]                       base::local({
[16:12:47.441]                         has_future <- base::requireNamespace("future", 
[16:12:47.441]                           quietly = TRUE)
[16:12:47.441]                         if (has_future) {
[16:12:47.441]                           ns <- base::getNamespace("future")
[16:12:47.441]                           version <- ns[[".package"]][["version"]]
[16:12:47.441]                           if (is.null(version)) 
[16:12:47.441]                             version <- utils::packageVersion("future")
[16:12:47.441]                         }
[16:12:47.441]                         else {
[16:12:47.441]                           version <- NULL
[16:12:47.441]                         }
[16:12:47.441]                         if (!has_future || version < "1.8.0") {
[16:12:47.441]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.441]                             "", base::R.version$version.string), 
[16:12:47.441]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.441]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.441]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.441]                               "release", "version")], collapse = " "), 
[16:12:47.441]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.441]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.441]                             info)
[16:12:47.441]                           info <- base::paste(info, collapse = "; ")
[16:12:47.441]                           if (!has_future) {
[16:12:47.441]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.441]                               info)
[16:12:47.441]                           }
[16:12:47.441]                           else {
[16:12:47.441]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.441]                               info, version)
[16:12:47.441]                           }
[16:12:47.441]                           base::stop(msg)
[16:12:47.441]                         }
[16:12:47.441]                       })
[16:12:47.441]                     }
[16:12:47.441]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.441]                     base::options(mc.cores = 1L)
[16:12:47.441]                   }
[16:12:47.441]                   options(future.plan = NULL)
[16:12:47.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.441]                 }
[16:12:47.441]                 ...future.workdir <- getwd()
[16:12:47.441]             }
[16:12:47.441]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.441]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.441]         }
[16:12:47.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.441]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.441]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.441]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.441]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.441]             base::names(...future.oldOptions))
[16:12:47.441]     }
[16:12:47.441]     if (FALSE) {
[16:12:47.441]     }
[16:12:47.441]     else {
[16:12:47.441]         if (TRUE) {
[16:12:47.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.441]                 open = "w")
[16:12:47.441]         }
[16:12:47.441]         else {
[16:12:47.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.441]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.441]         }
[16:12:47.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.441]             base::sink(type = "output", split = FALSE)
[16:12:47.441]             base::close(...future.stdout)
[16:12:47.441]         }, add = TRUE)
[16:12:47.441]     }
[16:12:47.441]     ...future.frame <- base::sys.nframe()
[16:12:47.441]     ...future.conditions <- base::list()
[16:12:47.441]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.441]     if (FALSE) {
[16:12:47.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.441]     }
[16:12:47.441]     ...future.result <- base::tryCatch({
[16:12:47.441]         base::withCallingHandlers({
[16:12:47.441]             ...future.value <- base::withVisible(base::local({
[16:12:47.441]                 ...future.makeSendCondition <- local({
[16:12:47.441]                   sendCondition <- NULL
[16:12:47.441]                   function(frame = 1L) {
[16:12:47.441]                     if (is.function(sendCondition)) 
[16:12:47.441]                       return(sendCondition)
[16:12:47.441]                     ns <- getNamespace("parallel")
[16:12:47.441]                     if (exists("sendData", mode = "function", 
[16:12:47.441]                       envir = ns)) {
[16:12:47.441]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.441]                         envir = ns)
[16:12:47.441]                       envir <- sys.frame(frame)
[16:12:47.441]                       master <- NULL
[16:12:47.441]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.441]                         !identical(envir, emptyenv())) {
[16:12:47.441]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.441]                           inherits = FALSE)) {
[16:12:47.441]                           master <- get("master", mode = "list", 
[16:12:47.441]                             envir = envir, inherits = FALSE)
[16:12:47.441]                           if (inherits(master, c("SOCKnode", 
[16:12:47.441]                             "SOCK0node"))) {
[16:12:47.441]                             sendCondition <<- function(cond) {
[16:12:47.441]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.441]                                 success = TRUE)
[16:12:47.441]                               parallel_sendData(master, data)
[16:12:47.441]                             }
[16:12:47.441]                             return(sendCondition)
[16:12:47.441]                           }
[16:12:47.441]                         }
[16:12:47.441]                         frame <- frame + 1L
[16:12:47.441]                         envir <- sys.frame(frame)
[16:12:47.441]                       }
[16:12:47.441]                     }
[16:12:47.441]                     sendCondition <<- function(cond) NULL
[16:12:47.441]                   }
[16:12:47.441]                 })
[16:12:47.441]                 withCallingHandlers({
[16:12:47.441]                   {
[16:12:47.441]                     x <- list(b = 2)
[16:12:47.441]                     x$a <- 1
[16:12:47.441]                     x
[16:12:47.441]                   }
[16:12:47.441]                 }, immediateCondition = function(cond) {
[16:12:47.441]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.441]                   sendCondition(cond)
[16:12:47.441]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.441]                   {
[16:12:47.441]                     inherits <- base::inherits
[16:12:47.441]                     invokeRestart <- base::invokeRestart
[16:12:47.441]                     is.null <- base::is.null
[16:12:47.441]                     muffled <- FALSE
[16:12:47.441]                     if (inherits(cond, "message")) {
[16:12:47.441]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.441]                       if (muffled) 
[16:12:47.441]                         invokeRestart("muffleMessage")
[16:12:47.441]                     }
[16:12:47.441]                     else if (inherits(cond, "warning")) {
[16:12:47.441]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.441]                       if (muffled) 
[16:12:47.441]                         invokeRestart("muffleWarning")
[16:12:47.441]                     }
[16:12:47.441]                     else if (inherits(cond, "condition")) {
[16:12:47.441]                       if (!is.null(pattern)) {
[16:12:47.441]                         computeRestarts <- base::computeRestarts
[16:12:47.441]                         grepl <- base::grepl
[16:12:47.441]                         restarts <- computeRestarts(cond)
[16:12:47.441]                         for (restart in restarts) {
[16:12:47.441]                           name <- restart$name
[16:12:47.441]                           if (is.null(name)) 
[16:12:47.441]                             next
[16:12:47.441]                           if (!grepl(pattern, name)) 
[16:12:47.441]                             next
[16:12:47.441]                           invokeRestart(restart)
[16:12:47.441]                           muffled <- TRUE
[16:12:47.441]                           break
[16:12:47.441]                         }
[16:12:47.441]                       }
[16:12:47.441]                     }
[16:12:47.441]                     invisible(muffled)
[16:12:47.441]                   }
[16:12:47.441]                   muffleCondition(cond)
[16:12:47.441]                 })
[16:12:47.441]             }))
[16:12:47.441]             future::FutureResult(value = ...future.value$value, 
[16:12:47.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.441]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.441]                     ...future.globalenv.names))
[16:12:47.441]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.441]         }, condition = base::local({
[16:12:47.441]             c <- base::c
[16:12:47.441]             inherits <- base::inherits
[16:12:47.441]             invokeRestart <- base::invokeRestart
[16:12:47.441]             length <- base::length
[16:12:47.441]             list <- base::list
[16:12:47.441]             seq.int <- base::seq.int
[16:12:47.441]             signalCondition <- base::signalCondition
[16:12:47.441]             sys.calls <- base::sys.calls
[16:12:47.441]             `[[` <- base::`[[`
[16:12:47.441]             `+` <- base::`+`
[16:12:47.441]             `<<-` <- base::`<<-`
[16:12:47.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.441]                   3L)]
[16:12:47.441]             }
[16:12:47.441]             function(cond) {
[16:12:47.441]                 is_error <- inherits(cond, "error")
[16:12:47.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.441]                   NULL)
[16:12:47.441]                 if (is_error) {
[16:12:47.441]                   sessionInformation <- function() {
[16:12:47.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.441]                       search = base::search(), system = base::Sys.info())
[16:12:47.441]                   }
[16:12:47.441]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.441]                     cond$call), session = sessionInformation(), 
[16:12:47.441]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.441]                   signalCondition(cond)
[16:12:47.441]                 }
[16:12:47.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.441]                 "immediateCondition"))) {
[16:12:47.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.441]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.441]                   if (TRUE && !signal) {
[16:12:47.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.441]                     {
[16:12:47.441]                       inherits <- base::inherits
[16:12:47.441]                       invokeRestart <- base::invokeRestart
[16:12:47.441]                       is.null <- base::is.null
[16:12:47.441]                       muffled <- FALSE
[16:12:47.441]                       if (inherits(cond, "message")) {
[16:12:47.441]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.441]                         if (muffled) 
[16:12:47.441]                           invokeRestart("muffleMessage")
[16:12:47.441]                       }
[16:12:47.441]                       else if (inherits(cond, "warning")) {
[16:12:47.441]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.441]                         if (muffled) 
[16:12:47.441]                           invokeRestart("muffleWarning")
[16:12:47.441]                       }
[16:12:47.441]                       else if (inherits(cond, "condition")) {
[16:12:47.441]                         if (!is.null(pattern)) {
[16:12:47.441]                           computeRestarts <- base::computeRestarts
[16:12:47.441]                           grepl <- base::grepl
[16:12:47.441]                           restarts <- computeRestarts(cond)
[16:12:47.441]                           for (restart in restarts) {
[16:12:47.441]                             name <- restart$name
[16:12:47.441]                             if (is.null(name)) 
[16:12:47.441]                               next
[16:12:47.441]                             if (!grepl(pattern, name)) 
[16:12:47.441]                               next
[16:12:47.441]                             invokeRestart(restart)
[16:12:47.441]                             muffled <- TRUE
[16:12:47.441]                             break
[16:12:47.441]                           }
[16:12:47.441]                         }
[16:12:47.441]                       }
[16:12:47.441]                       invisible(muffled)
[16:12:47.441]                     }
[16:12:47.441]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.441]                   }
[16:12:47.441]                 }
[16:12:47.441]                 else {
[16:12:47.441]                   if (TRUE) {
[16:12:47.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.441]                     {
[16:12:47.441]                       inherits <- base::inherits
[16:12:47.441]                       invokeRestart <- base::invokeRestart
[16:12:47.441]                       is.null <- base::is.null
[16:12:47.441]                       muffled <- FALSE
[16:12:47.441]                       if (inherits(cond, "message")) {
[16:12:47.441]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.441]                         if (muffled) 
[16:12:47.441]                           invokeRestart("muffleMessage")
[16:12:47.441]                       }
[16:12:47.441]                       else if (inherits(cond, "warning")) {
[16:12:47.441]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.441]                         if (muffled) 
[16:12:47.441]                           invokeRestart("muffleWarning")
[16:12:47.441]                       }
[16:12:47.441]                       else if (inherits(cond, "condition")) {
[16:12:47.441]                         if (!is.null(pattern)) {
[16:12:47.441]                           computeRestarts <- base::computeRestarts
[16:12:47.441]                           grepl <- base::grepl
[16:12:47.441]                           restarts <- computeRestarts(cond)
[16:12:47.441]                           for (restart in restarts) {
[16:12:47.441]                             name <- restart$name
[16:12:47.441]                             if (is.null(name)) 
[16:12:47.441]                               next
[16:12:47.441]                             if (!grepl(pattern, name)) 
[16:12:47.441]                               next
[16:12:47.441]                             invokeRestart(restart)
[16:12:47.441]                             muffled <- TRUE
[16:12:47.441]                             break
[16:12:47.441]                           }
[16:12:47.441]                         }
[16:12:47.441]                       }
[16:12:47.441]                       invisible(muffled)
[16:12:47.441]                     }
[16:12:47.441]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.441]                   }
[16:12:47.441]                 }
[16:12:47.441]             }
[16:12:47.441]         }))
[16:12:47.441]     }, error = function(ex) {
[16:12:47.441]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.441]                 ...future.rng), started = ...future.startTime, 
[16:12:47.441]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.441]             version = "1.8"), class = "FutureResult")
[16:12:47.441]     }, finally = {
[16:12:47.441]         if (!identical(...future.workdir, getwd())) 
[16:12:47.441]             setwd(...future.workdir)
[16:12:47.441]         {
[16:12:47.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.441]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.441]             }
[16:12:47.441]             base::options(...future.oldOptions)
[16:12:47.441]             if (.Platform$OS.type == "windows") {
[16:12:47.441]                 old_names <- names(...future.oldEnvVars)
[16:12:47.441]                 envs <- base::Sys.getenv()
[16:12:47.441]                 names <- names(envs)
[16:12:47.441]                 common <- intersect(names, old_names)
[16:12:47.441]                 added <- setdiff(names, old_names)
[16:12:47.441]                 removed <- setdiff(old_names, names)
[16:12:47.441]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.441]                   envs[common]]
[16:12:47.441]                 NAMES <- toupper(changed)
[16:12:47.441]                 args <- list()
[16:12:47.441]                 for (kk in seq_along(NAMES)) {
[16:12:47.441]                   name <- changed[[kk]]
[16:12:47.441]                   NAME <- NAMES[[kk]]
[16:12:47.441]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.441]                     next
[16:12:47.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.441]                 }
[16:12:47.441]                 NAMES <- toupper(added)
[16:12:47.441]                 for (kk in seq_along(NAMES)) {
[16:12:47.441]                   name <- added[[kk]]
[16:12:47.441]                   NAME <- NAMES[[kk]]
[16:12:47.441]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.441]                     next
[16:12:47.441]                   args[[name]] <- ""
[16:12:47.441]                 }
[16:12:47.441]                 NAMES <- toupper(removed)
[16:12:47.441]                 for (kk in seq_along(NAMES)) {
[16:12:47.441]                   name <- removed[[kk]]
[16:12:47.441]                   NAME <- NAMES[[kk]]
[16:12:47.441]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.441]                     next
[16:12:47.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.441]                 }
[16:12:47.441]                 if (length(args) > 0) 
[16:12:47.441]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.441]             }
[16:12:47.441]             else {
[16:12:47.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.441]             }
[16:12:47.441]             {
[16:12:47.441]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.441]                   0L) {
[16:12:47.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.441]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.441]                   base::options(opts)
[16:12:47.441]                 }
[16:12:47.441]                 {
[16:12:47.441]                   {
[16:12:47.441]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.441]                     NULL
[16:12:47.441]                   }
[16:12:47.441]                   options(future.plan = NULL)
[16:12:47.441]                   if (is.na(NA_character_)) 
[16:12:47.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.441]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.441]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.441]                     envir = parent.frame()) 
[16:12:47.441]                   {
[16:12:47.441]                     if (is.function(workers)) 
[16:12:47.441]                       workers <- workers()
[16:12:47.441]                     workers <- structure(as.integer(workers), 
[16:12:47.441]                       class = class(workers))
[16:12:47.441]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.441]                       workers >= 1)
[16:12:47.441]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.441]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.441]                     }
[16:12:47.441]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.441]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.441]                       envir = envir)
[16:12:47.441]                     if (!future$lazy) 
[16:12:47.441]                       future <- run(future)
[16:12:47.441]                     invisible(future)
[16:12:47.441]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.441]                 }
[16:12:47.441]             }
[16:12:47.441]         }
[16:12:47.441]     })
[16:12:47.441]     if (TRUE) {
[16:12:47.441]         base::sink(type = "output", split = FALSE)
[16:12:47.441]         if (TRUE) {
[16:12:47.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.441]         }
[16:12:47.441]         else {
[16:12:47.441]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.441]         }
[16:12:47.441]         base::close(...future.stdout)
[16:12:47.441]         ...future.stdout <- NULL
[16:12:47.441]     }
[16:12:47.441]     ...future.result$conditions <- ...future.conditions
[16:12:47.441]     ...future.result$finished <- base::Sys.time()
[16:12:47.441]     ...future.result
[16:12:47.441] }
[16:12:47.444] MultisessionFuture started
[16:12:47.444] - Launch lazy future ... done
[16:12:47.444] run() for ‘MultisessionFuture’ ... done
[16:12:47.444] result() for ClusterFuture ...
[16:12:47.444] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.445] - Validating connection of MultisessionFuture
[16:12:47.493] - received message: FutureResult
[16:12:47.493] - Received FutureResult
[16:12:47.493] - Erased future from FutureRegistry
[16:12:47.493] result() for ClusterFuture ...
[16:12:47.493] - result already collected: FutureResult
[16:12:47.493] result() for ClusterFuture ... done
[16:12:47.493] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.494] result() for ClusterFuture ... done
[16:12:47.494] result() for ClusterFuture ...
[16:12:47.494] - result already collected: FutureResult
[16:12:47.494] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.494] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.494] Searching for globals...
[16:12:47.496] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:47.497] Searching for globals ... DONE
[16:12:47.497] Resolving globals: TRUE
[16:12:47.497] Resolving any globals that are futures ...
[16:12:47.497] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:47.497] Resolving any globals that are futures ... DONE
[16:12:47.497] Resolving futures part of globals (recursively) ...
[16:12:47.498] resolve() on list ...
[16:12:47.498]  recursive: 99
[16:12:47.498]  length: 1
[16:12:47.498]  elements: ‘x’
[16:12:47.498]  length: 0 (resolved future 1)
[16:12:47.498] resolve() on list ... DONE
[16:12:47.498] - globals: [1] ‘x’
[16:12:47.498] Resolving futures part of globals (recursively) ... DONE
[16:12:47.499] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:47.499] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:47.499] - globals: [1] ‘x’
[16:12:47.499] 
[16:12:47.499] getGlobalsAndPackages() ... DONE
[16:12:47.499] run() for ‘Future’ ...
[16:12:47.500] - state: ‘created’
[16:12:47.500] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.514] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.515]   - Field: ‘node’
[16:12:47.515]   - Field: ‘label’
[16:12:47.515]   - Field: ‘local’
[16:12:47.515]   - Field: ‘owner’
[16:12:47.515]   - Field: ‘envir’
[16:12:47.515]   - Field: ‘workers’
[16:12:47.515]   - Field: ‘packages’
[16:12:47.515]   - Field: ‘gc’
[16:12:47.515]   - Field: ‘conditions’
[16:12:47.515]   - Field: ‘persistent’
[16:12:47.516]   - Field: ‘expr’
[16:12:47.516]   - Field: ‘uuid’
[16:12:47.516]   - Field: ‘seed’
[16:12:47.516]   - Field: ‘version’
[16:12:47.516]   - Field: ‘result’
[16:12:47.516]   - Field: ‘asynchronous’
[16:12:47.516]   - Field: ‘calls’
[16:12:47.516]   - Field: ‘globals’
[16:12:47.516]   - Field: ‘stdout’
[16:12:47.516]   - Field: ‘earlySignal’
[16:12:47.517]   - Field: ‘lazy’
[16:12:47.517]   - Field: ‘state’
[16:12:47.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.517] - Launch lazy future ...
[16:12:47.517] Packages needed by the future expression (n = 0): <none>
[16:12:47.517] Packages needed by future strategies (n = 0): <none>
[16:12:47.518] {
[16:12:47.518]     {
[16:12:47.518]         {
[16:12:47.518]             ...future.startTime <- base::Sys.time()
[16:12:47.518]             {
[16:12:47.518]                 {
[16:12:47.518]                   {
[16:12:47.518]                     {
[16:12:47.518]                       base::local({
[16:12:47.518]                         has_future <- base::requireNamespace("future", 
[16:12:47.518]                           quietly = TRUE)
[16:12:47.518]                         if (has_future) {
[16:12:47.518]                           ns <- base::getNamespace("future")
[16:12:47.518]                           version <- ns[[".package"]][["version"]]
[16:12:47.518]                           if (is.null(version)) 
[16:12:47.518]                             version <- utils::packageVersion("future")
[16:12:47.518]                         }
[16:12:47.518]                         else {
[16:12:47.518]                           version <- NULL
[16:12:47.518]                         }
[16:12:47.518]                         if (!has_future || version < "1.8.0") {
[16:12:47.518]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.518]                             "", base::R.version$version.string), 
[16:12:47.518]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.518]                               "release", "version")], collapse = " "), 
[16:12:47.518]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.518]                             info)
[16:12:47.518]                           info <- base::paste(info, collapse = "; ")
[16:12:47.518]                           if (!has_future) {
[16:12:47.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.518]                               info)
[16:12:47.518]                           }
[16:12:47.518]                           else {
[16:12:47.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.518]                               info, version)
[16:12:47.518]                           }
[16:12:47.518]                           base::stop(msg)
[16:12:47.518]                         }
[16:12:47.518]                       })
[16:12:47.518]                     }
[16:12:47.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.518]                     base::options(mc.cores = 1L)
[16:12:47.518]                   }
[16:12:47.518]                   options(future.plan = NULL)
[16:12:47.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.518]                 }
[16:12:47.518]                 ...future.workdir <- getwd()
[16:12:47.518]             }
[16:12:47.518]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.518]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.518]         }
[16:12:47.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.518]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.518]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.518]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.518]             base::names(...future.oldOptions))
[16:12:47.518]     }
[16:12:47.518]     if (FALSE) {
[16:12:47.518]     }
[16:12:47.518]     else {
[16:12:47.518]         if (TRUE) {
[16:12:47.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.518]                 open = "w")
[16:12:47.518]         }
[16:12:47.518]         else {
[16:12:47.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.518]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.518]         }
[16:12:47.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.518]             base::sink(type = "output", split = FALSE)
[16:12:47.518]             base::close(...future.stdout)
[16:12:47.518]         }, add = TRUE)
[16:12:47.518]     }
[16:12:47.518]     ...future.frame <- base::sys.nframe()
[16:12:47.518]     ...future.conditions <- base::list()
[16:12:47.518]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.518]     if (FALSE) {
[16:12:47.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.518]     }
[16:12:47.518]     ...future.result <- base::tryCatch({
[16:12:47.518]         base::withCallingHandlers({
[16:12:47.518]             ...future.value <- base::withVisible(base::local({
[16:12:47.518]                 ...future.makeSendCondition <- local({
[16:12:47.518]                   sendCondition <- NULL
[16:12:47.518]                   function(frame = 1L) {
[16:12:47.518]                     if (is.function(sendCondition)) 
[16:12:47.518]                       return(sendCondition)
[16:12:47.518]                     ns <- getNamespace("parallel")
[16:12:47.518]                     if (exists("sendData", mode = "function", 
[16:12:47.518]                       envir = ns)) {
[16:12:47.518]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.518]                         envir = ns)
[16:12:47.518]                       envir <- sys.frame(frame)
[16:12:47.518]                       master <- NULL
[16:12:47.518]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.518]                         !identical(envir, emptyenv())) {
[16:12:47.518]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.518]                           inherits = FALSE)) {
[16:12:47.518]                           master <- get("master", mode = "list", 
[16:12:47.518]                             envir = envir, inherits = FALSE)
[16:12:47.518]                           if (inherits(master, c("SOCKnode", 
[16:12:47.518]                             "SOCK0node"))) {
[16:12:47.518]                             sendCondition <<- function(cond) {
[16:12:47.518]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.518]                                 success = TRUE)
[16:12:47.518]                               parallel_sendData(master, data)
[16:12:47.518]                             }
[16:12:47.518]                             return(sendCondition)
[16:12:47.518]                           }
[16:12:47.518]                         }
[16:12:47.518]                         frame <- frame + 1L
[16:12:47.518]                         envir <- sys.frame(frame)
[16:12:47.518]                       }
[16:12:47.518]                     }
[16:12:47.518]                     sendCondition <<- function(cond) NULL
[16:12:47.518]                   }
[16:12:47.518]                 })
[16:12:47.518]                 withCallingHandlers({
[16:12:47.518]                   {
[16:12:47.518]                     x[["a"]] <- 1
[16:12:47.518]                     x
[16:12:47.518]                   }
[16:12:47.518]                 }, immediateCondition = function(cond) {
[16:12:47.518]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.518]                   sendCondition(cond)
[16:12:47.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.518]                   {
[16:12:47.518]                     inherits <- base::inherits
[16:12:47.518]                     invokeRestart <- base::invokeRestart
[16:12:47.518]                     is.null <- base::is.null
[16:12:47.518]                     muffled <- FALSE
[16:12:47.518]                     if (inherits(cond, "message")) {
[16:12:47.518]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.518]                       if (muffled) 
[16:12:47.518]                         invokeRestart("muffleMessage")
[16:12:47.518]                     }
[16:12:47.518]                     else if (inherits(cond, "warning")) {
[16:12:47.518]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.518]                       if (muffled) 
[16:12:47.518]                         invokeRestart("muffleWarning")
[16:12:47.518]                     }
[16:12:47.518]                     else if (inherits(cond, "condition")) {
[16:12:47.518]                       if (!is.null(pattern)) {
[16:12:47.518]                         computeRestarts <- base::computeRestarts
[16:12:47.518]                         grepl <- base::grepl
[16:12:47.518]                         restarts <- computeRestarts(cond)
[16:12:47.518]                         for (restart in restarts) {
[16:12:47.518]                           name <- restart$name
[16:12:47.518]                           if (is.null(name)) 
[16:12:47.518]                             next
[16:12:47.518]                           if (!grepl(pattern, name)) 
[16:12:47.518]                             next
[16:12:47.518]                           invokeRestart(restart)
[16:12:47.518]                           muffled <- TRUE
[16:12:47.518]                           break
[16:12:47.518]                         }
[16:12:47.518]                       }
[16:12:47.518]                     }
[16:12:47.518]                     invisible(muffled)
[16:12:47.518]                   }
[16:12:47.518]                   muffleCondition(cond)
[16:12:47.518]                 })
[16:12:47.518]             }))
[16:12:47.518]             future::FutureResult(value = ...future.value$value, 
[16:12:47.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.518]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.518]                     ...future.globalenv.names))
[16:12:47.518]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.518]         }, condition = base::local({
[16:12:47.518]             c <- base::c
[16:12:47.518]             inherits <- base::inherits
[16:12:47.518]             invokeRestart <- base::invokeRestart
[16:12:47.518]             length <- base::length
[16:12:47.518]             list <- base::list
[16:12:47.518]             seq.int <- base::seq.int
[16:12:47.518]             signalCondition <- base::signalCondition
[16:12:47.518]             sys.calls <- base::sys.calls
[16:12:47.518]             `[[` <- base::`[[`
[16:12:47.518]             `+` <- base::`+`
[16:12:47.518]             `<<-` <- base::`<<-`
[16:12:47.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.518]                   3L)]
[16:12:47.518]             }
[16:12:47.518]             function(cond) {
[16:12:47.518]                 is_error <- inherits(cond, "error")
[16:12:47.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.518]                   NULL)
[16:12:47.518]                 if (is_error) {
[16:12:47.518]                   sessionInformation <- function() {
[16:12:47.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.518]                       search = base::search(), system = base::Sys.info())
[16:12:47.518]                   }
[16:12:47.518]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.518]                     cond$call), session = sessionInformation(), 
[16:12:47.518]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.518]                   signalCondition(cond)
[16:12:47.518]                 }
[16:12:47.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.518]                 "immediateCondition"))) {
[16:12:47.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.518]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.518]                   if (TRUE && !signal) {
[16:12:47.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.518]                     {
[16:12:47.518]                       inherits <- base::inherits
[16:12:47.518]                       invokeRestart <- base::invokeRestart
[16:12:47.518]                       is.null <- base::is.null
[16:12:47.518]                       muffled <- FALSE
[16:12:47.518]                       if (inherits(cond, "message")) {
[16:12:47.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.518]                         if (muffled) 
[16:12:47.518]                           invokeRestart("muffleMessage")
[16:12:47.518]                       }
[16:12:47.518]                       else if (inherits(cond, "warning")) {
[16:12:47.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.518]                         if (muffled) 
[16:12:47.518]                           invokeRestart("muffleWarning")
[16:12:47.518]                       }
[16:12:47.518]                       else if (inherits(cond, "condition")) {
[16:12:47.518]                         if (!is.null(pattern)) {
[16:12:47.518]                           computeRestarts <- base::computeRestarts
[16:12:47.518]                           grepl <- base::grepl
[16:12:47.518]                           restarts <- computeRestarts(cond)
[16:12:47.518]                           for (restart in restarts) {
[16:12:47.518]                             name <- restart$name
[16:12:47.518]                             if (is.null(name)) 
[16:12:47.518]                               next
[16:12:47.518]                             if (!grepl(pattern, name)) 
[16:12:47.518]                               next
[16:12:47.518]                             invokeRestart(restart)
[16:12:47.518]                             muffled <- TRUE
[16:12:47.518]                             break
[16:12:47.518]                           }
[16:12:47.518]                         }
[16:12:47.518]                       }
[16:12:47.518]                       invisible(muffled)
[16:12:47.518]                     }
[16:12:47.518]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.518]                   }
[16:12:47.518]                 }
[16:12:47.518]                 else {
[16:12:47.518]                   if (TRUE) {
[16:12:47.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.518]                     {
[16:12:47.518]                       inherits <- base::inherits
[16:12:47.518]                       invokeRestart <- base::invokeRestart
[16:12:47.518]                       is.null <- base::is.null
[16:12:47.518]                       muffled <- FALSE
[16:12:47.518]                       if (inherits(cond, "message")) {
[16:12:47.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.518]                         if (muffled) 
[16:12:47.518]                           invokeRestart("muffleMessage")
[16:12:47.518]                       }
[16:12:47.518]                       else if (inherits(cond, "warning")) {
[16:12:47.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.518]                         if (muffled) 
[16:12:47.518]                           invokeRestart("muffleWarning")
[16:12:47.518]                       }
[16:12:47.518]                       else if (inherits(cond, "condition")) {
[16:12:47.518]                         if (!is.null(pattern)) {
[16:12:47.518]                           computeRestarts <- base::computeRestarts
[16:12:47.518]                           grepl <- base::grepl
[16:12:47.518]                           restarts <- computeRestarts(cond)
[16:12:47.518]                           for (restart in restarts) {
[16:12:47.518]                             name <- restart$name
[16:12:47.518]                             if (is.null(name)) 
[16:12:47.518]                               next
[16:12:47.518]                             if (!grepl(pattern, name)) 
[16:12:47.518]                               next
[16:12:47.518]                             invokeRestart(restart)
[16:12:47.518]                             muffled <- TRUE
[16:12:47.518]                             break
[16:12:47.518]                           }
[16:12:47.518]                         }
[16:12:47.518]                       }
[16:12:47.518]                       invisible(muffled)
[16:12:47.518]                     }
[16:12:47.518]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.518]                   }
[16:12:47.518]                 }
[16:12:47.518]             }
[16:12:47.518]         }))
[16:12:47.518]     }, error = function(ex) {
[16:12:47.518]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.518]                 ...future.rng), started = ...future.startTime, 
[16:12:47.518]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.518]             version = "1.8"), class = "FutureResult")
[16:12:47.518]     }, finally = {
[16:12:47.518]         if (!identical(...future.workdir, getwd())) 
[16:12:47.518]             setwd(...future.workdir)
[16:12:47.518]         {
[16:12:47.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.518]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.518]             }
[16:12:47.518]             base::options(...future.oldOptions)
[16:12:47.518]             if (.Platform$OS.type == "windows") {
[16:12:47.518]                 old_names <- names(...future.oldEnvVars)
[16:12:47.518]                 envs <- base::Sys.getenv()
[16:12:47.518]                 names <- names(envs)
[16:12:47.518]                 common <- intersect(names, old_names)
[16:12:47.518]                 added <- setdiff(names, old_names)
[16:12:47.518]                 removed <- setdiff(old_names, names)
[16:12:47.518]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.518]                   envs[common]]
[16:12:47.518]                 NAMES <- toupper(changed)
[16:12:47.518]                 args <- list()
[16:12:47.518]                 for (kk in seq_along(NAMES)) {
[16:12:47.518]                   name <- changed[[kk]]
[16:12:47.518]                   NAME <- NAMES[[kk]]
[16:12:47.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.518]                     next
[16:12:47.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.518]                 }
[16:12:47.518]                 NAMES <- toupper(added)
[16:12:47.518]                 for (kk in seq_along(NAMES)) {
[16:12:47.518]                   name <- added[[kk]]
[16:12:47.518]                   NAME <- NAMES[[kk]]
[16:12:47.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.518]                     next
[16:12:47.518]                   args[[name]] <- ""
[16:12:47.518]                 }
[16:12:47.518]                 NAMES <- toupper(removed)
[16:12:47.518]                 for (kk in seq_along(NAMES)) {
[16:12:47.518]                   name <- removed[[kk]]
[16:12:47.518]                   NAME <- NAMES[[kk]]
[16:12:47.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.518]                     next
[16:12:47.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.518]                 }
[16:12:47.518]                 if (length(args) > 0) 
[16:12:47.518]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.518]             }
[16:12:47.518]             else {
[16:12:47.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.518]             }
[16:12:47.518]             {
[16:12:47.518]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.518]                   0L) {
[16:12:47.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.518]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.518]                   base::options(opts)
[16:12:47.518]                 }
[16:12:47.518]                 {
[16:12:47.518]                   {
[16:12:47.518]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.518]                     NULL
[16:12:47.518]                   }
[16:12:47.518]                   options(future.plan = NULL)
[16:12:47.518]                   if (is.na(NA_character_)) 
[16:12:47.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.518]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.518]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.518]                     envir = parent.frame()) 
[16:12:47.518]                   {
[16:12:47.518]                     if (is.function(workers)) 
[16:12:47.518]                       workers <- workers()
[16:12:47.518]                     workers <- structure(as.integer(workers), 
[16:12:47.518]                       class = class(workers))
[16:12:47.518]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.518]                       workers >= 1)
[16:12:47.518]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.518]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.518]                     }
[16:12:47.518]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.518]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.518]                       envir = envir)
[16:12:47.518]                     if (!future$lazy) 
[16:12:47.518]                       future <- run(future)
[16:12:47.518]                     invisible(future)
[16:12:47.518]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.518]                 }
[16:12:47.518]             }
[16:12:47.518]         }
[16:12:47.518]     })
[16:12:47.518]     if (TRUE) {
[16:12:47.518]         base::sink(type = "output", split = FALSE)
[16:12:47.518]         if (TRUE) {
[16:12:47.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.518]         }
[16:12:47.518]         else {
[16:12:47.518]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.518]         }
[16:12:47.518]         base::close(...future.stdout)
[16:12:47.518]         ...future.stdout <- NULL
[16:12:47.518]     }
[16:12:47.518]     ...future.result$conditions <- ...future.conditions
[16:12:47.518]     ...future.result$finished <- base::Sys.time()
[16:12:47.518]     ...future.result
[16:12:47.518] }
[16:12:47.521] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:12:47.521] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:12:47.521] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:12:47.521] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:12:47.522] MultisessionFuture started
[16:12:47.522] - Launch lazy future ... done
[16:12:47.522] run() for ‘MultisessionFuture’ ... done
[16:12:47.522] result() for ClusterFuture ...
[16:12:47.522] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.522] - Validating connection of MultisessionFuture
[16:12:47.569] - received message: FutureResult
[16:12:47.569] - Received FutureResult
[16:12:47.569] - Erased future from FutureRegistry
[16:12:47.569] result() for ClusterFuture ...
[16:12:47.570] - result already collected: FutureResult
[16:12:47.570] result() for ClusterFuture ... done
[16:12:47.570] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.570] result() for ClusterFuture ... done
[16:12:47.570] result() for ClusterFuture ...
[16:12:47.570] - result already collected: FutureResult
[16:12:47.570] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.570] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.571] Searching for globals...
[16:12:47.573] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:47.573] Searching for globals ... DONE
[16:12:47.573] Resolving globals: TRUE
[16:12:47.573] Resolving any globals that are futures ...
[16:12:47.573] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:47.574] Resolving any globals that are futures ... DONE
[16:12:47.574] Resolving futures part of globals (recursively) ...
[16:12:47.574] resolve() on list ...
[16:12:47.574]  recursive: 99
[16:12:47.574]  length: 1
[16:12:47.575]  elements: ‘x’
[16:12:47.575]  length: 0 (resolved future 1)
[16:12:47.575] resolve() on list ... DONE
[16:12:47.575] - globals: [1] ‘x’
[16:12:47.575] Resolving futures part of globals (recursively) ... DONE
[16:12:47.575] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:47.576] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:47.576] - globals: [1] ‘x’
[16:12:47.576] 
[16:12:47.576] getGlobalsAndPackages() ... DONE
[16:12:47.576] run() for ‘Future’ ...
[16:12:47.577] - state: ‘created’
[16:12:47.577] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.591] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.592] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.592]   - Field: ‘node’
[16:12:47.592]   - Field: ‘label’
[16:12:47.592]   - Field: ‘local’
[16:12:47.592]   - Field: ‘owner’
[16:12:47.592]   - Field: ‘envir’
[16:12:47.592]   - Field: ‘workers’
[16:12:47.592]   - Field: ‘packages’
[16:12:47.592]   - Field: ‘gc’
[16:12:47.593]   - Field: ‘conditions’
[16:12:47.593]   - Field: ‘persistent’
[16:12:47.593]   - Field: ‘expr’
[16:12:47.593]   - Field: ‘uuid’
[16:12:47.593]   - Field: ‘seed’
[16:12:47.593]   - Field: ‘version’
[16:12:47.593]   - Field: ‘result’
[16:12:47.593]   - Field: ‘asynchronous’
[16:12:47.593]   - Field: ‘calls’
[16:12:47.593]   - Field: ‘globals’
[16:12:47.593]   - Field: ‘stdout’
[16:12:47.594]   - Field: ‘earlySignal’
[16:12:47.594]   - Field: ‘lazy’
[16:12:47.594]   - Field: ‘state’
[16:12:47.594] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.594] - Launch lazy future ...
[16:12:47.594] Packages needed by the future expression (n = 0): <none>
[16:12:47.594] Packages needed by future strategies (n = 0): <none>
[16:12:47.595] {
[16:12:47.595]     {
[16:12:47.595]         {
[16:12:47.595]             ...future.startTime <- base::Sys.time()
[16:12:47.595]             {
[16:12:47.595]                 {
[16:12:47.595]                   {
[16:12:47.595]                     {
[16:12:47.595]                       base::local({
[16:12:47.595]                         has_future <- base::requireNamespace("future", 
[16:12:47.595]                           quietly = TRUE)
[16:12:47.595]                         if (has_future) {
[16:12:47.595]                           ns <- base::getNamespace("future")
[16:12:47.595]                           version <- ns[[".package"]][["version"]]
[16:12:47.595]                           if (is.null(version)) 
[16:12:47.595]                             version <- utils::packageVersion("future")
[16:12:47.595]                         }
[16:12:47.595]                         else {
[16:12:47.595]                           version <- NULL
[16:12:47.595]                         }
[16:12:47.595]                         if (!has_future || version < "1.8.0") {
[16:12:47.595]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.595]                             "", base::R.version$version.string), 
[16:12:47.595]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.595]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.595]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.595]                               "release", "version")], collapse = " "), 
[16:12:47.595]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.595]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.595]                             info)
[16:12:47.595]                           info <- base::paste(info, collapse = "; ")
[16:12:47.595]                           if (!has_future) {
[16:12:47.595]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.595]                               info)
[16:12:47.595]                           }
[16:12:47.595]                           else {
[16:12:47.595]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.595]                               info, version)
[16:12:47.595]                           }
[16:12:47.595]                           base::stop(msg)
[16:12:47.595]                         }
[16:12:47.595]                       })
[16:12:47.595]                     }
[16:12:47.595]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.595]                     base::options(mc.cores = 1L)
[16:12:47.595]                   }
[16:12:47.595]                   options(future.plan = NULL)
[16:12:47.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.595]                 }
[16:12:47.595]                 ...future.workdir <- getwd()
[16:12:47.595]             }
[16:12:47.595]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.595]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.595]         }
[16:12:47.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.595]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.595]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.595]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.595]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.595]             base::names(...future.oldOptions))
[16:12:47.595]     }
[16:12:47.595]     if (FALSE) {
[16:12:47.595]     }
[16:12:47.595]     else {
[16:12:47.595]         if (TRUE) {
[16:12:47.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.595]                 open = "w")
[16:12:47.595]         }
[16:12:47.595]         else {
[16:12:47.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.595]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.595]         }
[16:12:47.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.595]             base::sink(type = "output", split = FALSE)
[16:12:47.595]             base::close(...future.stdout)
[16:12:47.595]         }, add = TRUE)
[16:12:47.595]     }
[16:12:47.595]     ...future.frame <- base::sys.nframe()
[16:12:47.595]     ...future.conditions <- base::list()
[16:12:47.595]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.595]     if (FALSE) {
[16:12:47.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.595]     }
[16:12:47.595]     ...future.result <- base::tryCatch({
[16:12:47.595]         base::withCallingHandlers({
[16:12:47.595]             ...future.value <- base::withVisible(base::local({
[16:12:47.595]                 ...future.makeSendCondition <- local({
[16:12:47.595]                   sendCondition <- NULL
[16:12:47.595]                   function(frame = 1L) {
[16:12:47.595]                     if (is.function(sendCondition)) 
[16:12:47.595]                       return(sendCondition)
[16:12:47.595]                     ns <- getNamespace("parallel")
[16:12:47.595]                     if (exists("sendData", mode = "function", 
[16:12:47.595]                       envir = ns)) {
[16:12:47.595]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.595]                         envir = ns)
[16:12:47.595]                       envir <- sys.frame(frame)
[16:12:47.595]                       master <- NULL
[16:12:47.595]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.595]                         !identical(envir, emptyenv())) {
[16:12:47.595]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.595]                           inherits = FALSE)) {
[16:12:47.595]                           master <- get("master", mode = "list", 
[16:12:47.595]                             envir = envir, inherits = FALSE)
[16:12:47.595]                           if (inherits(master, c("SOCKnode", 
[16:12:47.595]                             "SOCK0node"))) {
[16:12:47.595]                             sendCondition <<- function(cond) {
[16:12:47.595]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.595]                                 success = TRUE)
[16:12:47.595]                               parallel_sendData(master, data)
[16:12:47.595]                             }
[16:12:47.595]                             return(sendCondition)
[16:12:47.595]                           }
[16:12:47.595]                         }
[16:12:47.595]                         frame <- frame + 1L
[16:12:47.595]                         envir <- sys.frame(frame)
[16:12:47.595]                       }
[16:12:47.595]                     }
[16:12:47.595]                     sendCondition <<- function(cond) NULL
[16:12:47.595]                   }
[16:12:47.595]                 })
[16:12:47.595]                 withCallingHandlers({
[16:12:47.595]                   {
[16:12:47.595]                     x[["a"]] <- 1
[16:12:47.595]                     x
[16:12:47.595]                   }
[16:12:47.595]                 }, immediateCondition = function(cond) {
[16:12:47.595]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.595]                   sendCondition(cond)
[16:12:47.595]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.595]                   {
[16:12:47.595]                     inherits <- base::inherits
[16:12:47.595]                     invokeRestart <- base::invokeRestart
[16:12:47.595]                     is.null <- base::is.null
[16:12:47.595]                     muffled <- FALSE
[16:12:47.595]                     if (inherits(cond, "message")) {
[16:12:47.595]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.595]                       if (muffled) 
[16:12:47.595]                         invokeRestart("muffleMessage")
[16:12:47.595]                     }
[16:12:47.595]                     else if (inherits(cond, "warning")) {
[16:12:47.595]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.595]                       if (muffled) 
[16:12:47.595]                         invokeRestart("muffleWarning")
[16:12:47.595]                     }
[16:12:47.595]                     else if (inherits(cond, "condition")) {
[16:12:47.595]                       if (!is.null(pattern)) {
[16:12:47.595]                         computeRestarts <- base::computeRestarts
[16:12:47.595]                         grepl <- base::grepl
[16:12:47.595]                         restarts <- computeRestarts(cond)
[16:12:47.595]                         for (restart in restarts) {
[16:12:47.595]                           name <- restart$name
[16:12:47.595]                           if (is.null(name)) 
[16:12:47.595]                             next
[16:12:47.595]                           if (!grepl(pattern, name)) 
[16:12:47.595]                             next
[16:12:47.595]                           invokeRestart(restart)
[16:12:47.595]                           muffled <- TRUE
[16:12:47.595]                           break
[16:12:47.595]                         }
[16:12:47.595]                       }
[16:12:47.595]                     }
[16:12:47.595]                     invisible(muffled)
[16:12:47.595]                   }
[16:12:47.595]                   muffleCondition(cond)
[16:12:47.595]                 })
[16:12:47.595]             }))
[16:12:47.595]             future::FutureResult(value = ...future.value$value, 
[16:12:47.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.595]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.595]                     ...future.globalenv.names))
[16:12:47.595]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.595]         }, condition = base::local({
[16:12:47.595]             c <- base::c
[16:12:47.595]             inherits <- base::inherits
[16:12:47.595]             invokeRestart <- base::invokeRestart
[16:12:47.595]             length <- base::length
[16:12:47.595]             list <- base::list
[16:12:47.595]             seq.int <- base::seq.int
[16:12:47.595]             signalCondition <- base::signalCondition
[16:12:47.595]             sys.calls <- base::sys.calls
[16:12:47.595]             `[[` <- base::`[[`
[16:12:47.595]             `+` <- base::`+`
[16:12:47.595]             `<<-` <- base::`<<-`
[16:12:47.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.595]                   3L)]
[16:12:47.595]             }
[16:12:47.595]             function(cond) {
[16:12:47.595]                 is_error <- inherits(cond, "error")
[16:12:47.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.595]                   NULL)
[16:12:47.595]                 if (is_error) {
[16:12:47.595]                   sessionInformation <- function() {
[16:12:47.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.595]                       search = base::search(), system = base::Sys.info())
[16:12:47.595]                   }
[16:12:47.595]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.595]                     cond$call), session = sessionInformation(), 
[16:12:47.595]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.595]                   signalCondition(cond)
[16:12:47.595]                 }
[16:12:47.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.595]                 "immediateCondition"))) {
[16:12:47.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.595]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.595]                   if (TRUE && !signal) {
[16:12:47.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.595]                     {
[16:12:47.595]                       inherits <- base::inherits
[16:12:47.595]                       invokeRestart <- base::invokeRestart
[16:12:47.595]                       is.null <- base::is.null
[16:12:47.595]                       muffled <- FALSE
[16:12:47.595]                       if (inherits(cond, "message")) {
[16:12:47.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.595]                         if (muffled) 
[16:12:47.595]                           invokeRestart("muffleMessage")
[16:12:47.595]                       }
[16:12:47.595]                       else if (inherits(cond, "warning")) {
[16:12:47.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.595]                         if (muffled) 
[16:12:47.595]                           invokeRestart("muffleWarning")
[16:12:47.595]                       }
[16:12:47.595]                       else if (inherits(cond, "condition")) {
[16:12:47.595]                         if (!is.null(pattern)) {
[16:12:47.595]                           computeRestarts <- base::computeRestarts
[16:12:47.595]                           grepl <- base::grepl
[16:12:47.595]                           restarts <- computeRestarts(cond)
[16:12:47.595]                           for (restart in restarts) {
[16:12:47.595]                             name <- restart$name
[16:12:47.595]                             if (is.null(name)) 
[16:12:47.595]                               next
[16:12:47.595]                             if (!grepl(pattern, name)) 
[16:12:47.595]                               next
[16:12:47.595]                             invokeRestart(restart)
[16:12:47.595]                             muffled <- TRUE
[16:12:47.595]                             break
[16:12:47.595]                           }
[16:12:47.595]                         }
[16:12:47.595]                       }
[16:12:47.595]                       invisible(muffled)
[16:12:47.595]                     }
[16:12:47.595]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.595]                   }
[16:12:47.595]                 }
[16:12:47.595]                 else {
[16:12:47.595]                   if (TRUE) {
[16:12:47.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.595]                     {
[16:12:47.595]                       inherits <- base::inherits
[16:12:47.595]                       invokeRestart <- base::invokeRestart
[16:12:47.595]                       is.null <- base::is.null
[16:12:47.595]                       muffled <- FALSE
[16:12:47.595]                       if (inherits(cond, "message")) {
[16:12:47.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.595]                         if (muffled) 
[16:12:47.595]                           invokeRestart("muffleMessage")
[16:12:47.595]                       }
[16:12:47.595]                       else if (inherits(cond, "warning")) {
[16:12:47.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.595]                         if (muffled) 
[16:12:47.595]                           invokeRestart("muffleWarning")
[16:12:47.595]                       }
[16:12:47.595]                       else if (inherits(cond, "condition")) {
[16:12:47.595]                         if (!is.null(pattern)) {
[16:12:47.595]                           computeRestarts <- base::computeRestarts
[16:12:47.595]                           grepl <- base::grepl
[16:12:47.595]                           restarts <- computeRestarts(cond)
[16:12:47.595]                           for (restart in restarts) {
[16:12:47.595]                             name <- restart$name
[16:12:47.595]                             if (is.null(name)) 
[16:12:47.595]                               next
[16:12:47.595]                             if (!grepl(pattern, name)) 
[16:12:47.595]                               next
[16:12:47.595]                             invokeRestart(restart)
[16:12:47.595]                             muffled <- TRUE
[16:12:47.595]                             break
[16:12:47.595]                           }
[16:12:47.595]                         }
[16:12:47.595]                       }
[16:12:47.595]                       invisible(muffled)
[16:12:47.595]                     }
[16:12:47.595]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.595]                   }
[16:12:47.595]                 }
[16:12:47.595]             }
[16:12:47.595]         }))
[16:12:47.595]     }, error = function(ex) {
[16:12:47.595]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.595]                 ...future.rng), started = ...future.startTime, 
[16:12:47.595]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.595]             version = "1.8"), class = "FutureResult")
[16:12:47.595]     }, finally = {
[16:12:47.595]         if (!identical(...future.workdir, getwd())) 
[16:12:47.595]             setwd(...future.workdir)
[16:12:47.595]         {
[16:12:47.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.595]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.595]             }
[16:12:47.595]             base::options(...future.oldOptions)
[16:12:47.595]             if (.Platform$OS.type == "windows") {
[16:12:47.595]                 old_names <- names(...future.oldEnvVars)
[16:12:47.595]                 envs <- base::Sys.getenv()
[16:12:47.595]                 names <- names(envs)
[16:12:47.595]                 common <- intersect(names, old_names)
[16:12:47.595]                 added <- setdiff(names, old_names)
[16:12:47.595]                 removed <- setdiff(old_names, names)
[16:12:47.595]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.595]                   envs[common]]
[16:12:47.595]                 NAMES <- toupper(changed)
[16:12:47.595]                 args <- list()
[16:12:47.595]                 for (kk in seq_along(NAMES)) {
[16:12:47.595]                   name <- changed[[kk]]
[16:12:47.595]                   NAME <- NAMES[[kk]]
[16:12:47.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.595]                     next
[16:12:47.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.595]                 }
[16:12:47.595]                 NAMES <- toupper(added)
[16:12:47.595]                 for (kk in seq_along(NAMES)) {
[16:12:47.595]                   name <- added[[kk]]
[16:12:47.595]                   NAME <- NAMES[[kk]]
[16:12:47.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.595]                     next
[16:12:47.595]                   args[[name]] <- ""
[16:12:47.595]                 }
[16:12:47.595]                 NAMES <- toupper(removed)
[16:12:47.595]                 for (kk in seq_along(NAMES)) {
[16:12:47.595]                   name <- removed[[kk]]
[16:12:47.595]                   NAME <- NAMES[[kk]]
[16:12:47.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.595]                     next
[16:12:47.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.595]                 }
[16:12:47.595]                 if (length(args) > 0) 
[16:12:47.595]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.595]             }
[16:12:47.595]             else {
[16:12:47.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.595]             }
[16:12:47.595]             {
[16:12:47.595]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.595]                   0L) {
[16:12:47.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.595]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.595]                   base::options(opts)
[16:12:47.595]                 }
[16:12:47.595]                 {
[16:12:47.595]                   {
[16:12:47.595]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.595]                     NULL
[16:12:47.595]                   }
[16:12:47.595]                   options(future.plan = NULL)
[16:12:47.595]                   if (is.na(NA_character_)) 
[16:12:47.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.595]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.595]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.595]                     envir = parent.frame()) 
[16:12:47.595]                   {
[16:12:47.595]                     if (is.function(workers)) 
[16:12:47.595]                       workers <- workers()
[16:12:47.595]                     workers <- structure(as.integer(workers), 
[16:12:47.595]                       class = class(workers))
[16:12:47.595]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.595]                       workers >= 1)
[16:12:47.595]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.595]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.595]                     }
[16:12:47.595]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.595]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.595]                       envir = envir)
[16:12:47.595]                     if (!future$lazy) 
[16:12:47.595]                       future <- run(future)
[16:12:47.595]                     invisible(future)
[16:12:47.595]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.595]                 }
[16:12:47.595]             }
[16:12:47.595]         }
[16:12:47.595]     })
[16:12:47.595]     if (TRUE) {
[16:12:47.595]         base::sink(type = "output", split = FALSE)
[16:12:47.595]         if (TRUE) {
[16:12:47.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.595]         }
[16:12:47.595]         else {
[16:12:47.595]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.595]         }
[16:12:47.595]         base::close(...future.stdout)
[16:12:47.595]         ...future.stdout <- NULL
[16:12:47.595]     }
[16:12:47.595]     ...future.result$conditions <- ...future.conditions
[16:12:47.595]     ...future.result$finished <- base::Sys.time()
[16:12:47.595]     ...future.result
[16:12:47.595] }
[16:12:47.598] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:12:47.598] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:12:47.598] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:12:47.598] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:12:47.599] MultisessionFuture started
[16:12:47.599] - Launch lazy future ... done
[16:12:47.599] run() for ‘MultisessionFuture’ ... done
[16:12:47.599] result() for ClusterFuture ...
[16:12:47.599] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.599] - Validating connection of MultisessionFuture
[16:12:47.645] - received message: FutureResult
[16:12:47.645] - Received FutureResult
[16:12:47.645] - Erased future from FutureRegistry
[16:12:47.645] result() for ClusterFuture ...
[16:12:47.645] - result already collected: FutureResult
[16:12:47.646] result() for ClusterFuture ... done
[16:12:47.646] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.646] result() for ClusterFuture ... done
[16:12:47.646] result() for ClusterFuture ...
[16:12:47.646] - result already collected: FutureResult
[16:12:47.646] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.647] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.647] Searching for globals...
[16:12:47.649] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:47.649] Searching for globals ... DONE
[16:12:47.650] Resolving globals: TRUE
[16:12:47.650] Resolving any globals that are futures ...
[16:12:47.650] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[16:12:47.650] Resolving any globals that are futures ... DONE
[16:12:47.650] Resolving futures part of globals (recursively) ...
[16:12:47.651] resolve() on list ...
[16:12:47.651]  recursive: 99
[16:12:47.653]  length: 1
[16:12:47.654]  elements: ‘x’
[16:12:47.654]  length: 0 (resolved future 1)
[16:12:47.654] resolve() on list ... DONE
[16:12:47.654] - globals: [1] ‘x’
[16:12:47.654] Resolving futures part of globals (recursively) ... DONE
[16:12:47.654] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:47.655] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:47.655] - globals: [1] ‘x’
[16:12:47.655] 
[16:12:47.655] getGlobalsAndPackages() ... DONE
[16:12:47.655] run() for ‘Future’ ...
[16:12:47.655] - state: ‘created’
[16:12:47.655] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.670] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.670] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.670]   - Field: ‘node’
[16:12:47.671]   - Field: ‘label’
[16:12:47.671]   - Field: ‘local’
[16:12:47.671]   - Field: ‘owner’
[16:12:47.671]   - Field: ‘envir’
[16:12:47.671]   - Field: ‘workers’
[16:12:47.671]   - Field: ‘packages’
[16:12:47.671]   - Field: ‘gc’
[16:12:47.671]   - Field: ‘conditions’
[16:12:47.671]   - Field: ‘persistent’
[16:12:47.671]   - Field: ‘expr’
[16:12:47.671]   - Field: ‘uuid’
[16:12:47.672]   - Field: ‘seed’
[16:12:47.672]   - Field: ‘version’
[16:12:47.672]   - Field: ‘result’
[16:12:47.672]   - Field: ‘asynchronous’
[16:12:47.672]   - Field: ‘calls’
[16:12:47.672]   - Field: ‘globals’
[16:12:47.672]   - Field: ‘stdout’
[16:12:47.672]   - Field: ‘earlySignal’
[16:12:47.672]   - Field: ‘lazy’
[16:12:47.672]   - Field: ‘state’
[16:12:47.673] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.673] - Launch lazy future ...
[16:12:47.673] Packages needed by the future expression (n = 0): <none>
[16:12:47.673] Packages needed by future strategies (n = 0): <none>
[16:12:47.673] {
[16:12:47.673]     {
[16:12:47.673]         {
[16:12:47.673]             ...future.startTime <- base::Sys.time()
[16:12:47.673]             {
[16:12:47.673]                 {
[16:12:47.673]                   {
[16:12:47.673]                     {
[16:12:47.673]                       base::local({
[16:12:47.673]                         has_future <- base::requireNamespace("future", 
[16:12:47.673]                           quietly = TRUE)
[16:12:47.673]                         if (has_future) {
[16:12:47.673]                           ns <- base::getNamespace("future")
[16:12:47.673]                           version <- ns[[".package"]][["version"]]
[16:12:47.673]                           if (is.null(version)) 
[16:12:47.673]                             version <- utils::packageVersion("future")
[16:12:47.673]                         }
[16:12:47.673]                         else {
[16:12:47.673]                           version <- NULL
[16:12:47.673]                         }
[16:12:47.673]                         if (!has_future || version < "1.8.0") {
[16:12:47.673]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.673]                             "", base::R.version$version.string), 
[16:12:47.673]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.673]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.673]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.673]                               "release", "version")], collapse = " "), 
[16:12:47.673]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.673]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.673]                             info)
[16:12:47.673]                           info <- base::paste(info, collapse = "; ")
[16:12:47.673]                           if (!has_future) {
[16:12:47.673]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.673]                               info)
[16:12:47.673]                           }
[16:12:47.673]                           else {
[16:12:47.673]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.673]                               info, version)
[16:12:47.673]                           }
[16:12:47.673]                           base::stop(msg)
[16:12:47.673]                         }
[16:12:47.673]                       })
[16:12:47.673]                     }
[16:12:47.673]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.673]                     base::options(mc.cores = 1L)
[16:12:47.673]                   }
[16:12:47.673]                   options(future.plan = NULL)
[16:12:47.673]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.673]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.673]                 }
[16:12:47.673]                 ...future.workdir <- getwd()
[16:12:47.673]             }
[16:12:47.673]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.673]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.673]         }
[16:12:47.673]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.673]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.673]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.673]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.673]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.673]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.673]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.673]             base::names(...future.oldOptions))
[16:12:47.673]     }
[16:12:47.673]     if (FALSE) {
[16:12:47.673]     }
[16:12:47.673]     else {
[16:12:47.673]         if (TRUE) {
[16:12:47.673]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.673]                 open = "w")
[16:12:47.673]         }
[16:12:47.673]         else {
[16:12:47.673]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.673]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.673]         }
[16:12:47.673]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.673]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.673]             base::sink(type = "output", split = FALSE)
[16:12:47.673]             base::close(...future.stdout)
[16:12:47.673]         }, add = TRUE)
[16:12:47.673]     }
[16:12:47.673]     ...future.frame <- base::sys.nframe()
[16:12:47.673]     ...future.conditions <- base::list()
[16:12:47.673]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.673]     if (FALSE) {
[16:12:47.673]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.673]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.673]     }
[16:12:47.673]     ...future.result <- base::tryCatch({
[16:12:47.673]         base::withCallingHandlers({
[16:12:47.673]             ...future.value <- base::withVisible(base::local({
[16:12:47.673]                 ...future.makeSendCondition <- local({
[16:12:47.673]                   sendCondition <- NULL
[16:12:47.673]                   function(frame = 1L) {
[16:12:47.673]                     if (is.function(sendCondition)) 
[16:12:47.673]                       return(sendCondition)
[16:12:47.673]                     ns <- getNamespace("parallel")
[16:12:47.673]                     if (exists("sendData", mode = "function", 
[16:12:47.673]                       envir = ns)) {
[16:12:47.673]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.673]                         envir = ns)
[16:12:47.673]                       envir <- sys.frame(frame)
[16:12:47.673]                       master <- NULL
[16:12:47.673]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.673]                         !identical(envir, emptyenv())) {
[16:12:47.673]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.673]                           inherits = FALSE)) {
[16:12:47.673]                           master <- get("master", mode = "list", 
[16:12:47.673]                             envir = envir, inherits = FALSE)
[16:12:47.673]                           if (inherits(master, c("SOCKnode", 
[16:12:47.673]                             "SOCK0node"))) {
[16:12:47.673]                             sendCondition <<- function(cond) {
[16:12:47.673]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.673]                                 success = TRUE)
[16:12:47.673]                               parallel_sendData(master, data)
[16:12:47.673]                             }
[16:12:47.673]                             return(sendCondition)
[16:12:47.673]                           }
[16:12:47.673]                         }
[16:12:47.673]                         frame <- frame + 1L
[16:12:47.673]                         envir <- sys.frame(frame)
[16:12:47.673]                       }
[16:12:47.673]                     }
[16:12:47.673]                     sendCondition <<- function(cond) NULL
[16:12:47.673]                   }
[16:12:47.673]                 })
[16:12:47.673]                 withCallingHandlers({
[16:12:47.673]                   {
[16:12:47.673]                     x[["a"]] <- 1
[16:12:47.673]                     x
[16:12:47.673]                   }
[16:12:47.673]                 }, immediateCondition = function(cond) {
[16:12:47.673]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.673]                   sendCondition(cond)
[16:12:47.673]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.673]                   {
[16:12:47.673]                     inherits <- base::inherits
[16:12:47.673]                     invokeRestart <- base::invokeRestart
[16:12:47.673]                     is.null <- base::is.null
[16:12:47.673]                     muffled <- FALSE
[16:12:47.673]                     if (inherits(cond, "message")) {
[16:12:47.673]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.673]                       if (muffled) 
[16:12:47.673]                         invokeRestart("muffleMessage")
[16:12:47.673]                     }
[16:12:47.673]                     else if (inherits(cond, "warning")) {
[16:12:47.673]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.673]                       if (muffled) 
[16:12:47.673]                         invokeRestart("muffleWarning")
[16:12:47.673]                     }
[16:12:47.673]                     else if (inherits(cond, "condition")) {
[16:12:47.673]                       if (!is.null(pattern)) {
[16:12:47.673]                         computeRestarts <- base::computeRestarts
[16:12:47.673]                         grepl <- base::grepl
[16:12:47.673]                         restarts <- computeRestarts(cond)
[16:12:47.673]                         for (restart in restarts) {
[16:12:47.673]                           name <- restart$name
[16:12:47.673]                           if (is.null(name)) 
[16:12:47.673]                             next
[16:12:47.673]                           if (!grepl(pattern, name)) 
[16:12:47.673]                             next
[16:12:47.673]                           invokeRestart(restart)
[16:12:47.673]                           muffled <- TRUE
[16:12:47.673]                           break
[16:12:47.673]                         }
[16:12:47.673]                       }
[16:12:47.673]                     }
[16:12:47.673]                     invisible(muffled)
[16:12:47.673]                   }
[16:12:47.673]                   muffleCondition(cond)
[16:12:47.673]                 })
[16:12:47.673]             }))
[16:12:47.673]             future::FutureResult(value = ...future.value$value, 
[16:12:47.673]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.673]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.673]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.673]                     ...future.globalenv.names))
[16:12:47.673]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.673]         }, condition = base::local({
[16:12:47.673]             c <- base::c
[16:12:47.673]             inherits <- base::inherits
[16:12:47.673]             invokeRestart <- base::invokeRestart
[16:12:47.673]             length <- base::length
[16:12:47.673]             list <- base::list
[16:12:47.673]             seq.int <- base::seq.int
[16:12:47.673]             signalCondition <- base::signalCondition
[16:12:47.673]             sys.calls <- base::sys.calls
[16:12:47.673]             `[[` <- base::`[[`
[16:12:47.673]             `+` <- base::`+`
[16:12:47.673]             `<<-` <- base::`<<-`
[16:12:47.673]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.673]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.673]                   3L)]
[16:12:47.673]             }
[16:12:47.673]             function(cond) {
[16:12:47.673]                 is_error <- inherits(cond, "error")
[16:12:47.673]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.673]                   NULL)
[16:12:47.673]                 if (is_error) {
[16:12:47.673]                   sessionInformation <- function() {
[16:12:47.673]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.673]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.673]                       search = base::search(), system = base::Sys.info())
[16:12:47.673]                   }
[16:12:47.673]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.673]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.673]                     cond$call), session = sessionInformation(), 
[16:12:47.673]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.673]                   signalCondition(cond)
[16:12:47.673]                 }
[16:12:47.673]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.673]                 "immediateCondition"))) {
[16:12:47.673]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.673]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.673]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.673]                   if (TRUE && !signal) {
[16:12:47.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.673]                     {
[16:12:47.673]                       inherits <- base::inherits
[16:12:47.673]                       invokeRestart <- base::invokeRestart
[16:12:47.673]                       is.null <- base::is.null
[16:12:47.673]                       muffled <- FALSE
[16:12:47.673]                       if (inherits(cond, "message")) {
[16:12:47.673]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.673]                         if (muffled) 
[16:12:47.673]                           invokeRestart("muffleMessage")
[16:12:47.673]                       }
[16:12:47.673]                       else if (inherits(cond, "warning")) {
[16:12:47.673]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.673]                         if (muffled) 
[16:12:47.673]                           invokeRestart("muffleWarning")
[16:12:47.673]                       }
[16:12:47.673]                       else if (inherits(cond, "condition")) {
[16:12:47.673]                         if (!is.null(pattern)) {
[16:12:47.673]                           computeRestarts <- base::computeRestarts
[16:12:47.673]                           grepl <- base::grepl
[16:12:47.673]                           restarts <- computeRestarts(cond)
[16:12:47.673]                           for (restart in restarts) {
[16:12:47.673]                             name <- restart$name
[16:12:47.673]                             if (is.null(name)) 
[16:12:47.673]                               next
[16:12:47.673]                             if (!grepl(pattern, name)) 
[16:12:47.673]                               next
[16:12:47.673]                             invokeRestart(restart)
[16:12:47.673]                             muffled <- TRUE
[16:12:47.673]                             break
[16:12:47.673]                           }
[16:12:47.673]                         }
[16:12:47.673]                       }
[16:12:47.673]                       invisible(muffled)
[16:12:47.673]                     }
[16:12:47.673]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.673]                   }
[16:12:47.673]                 }
[16:12:47.673]                 else {
[16:12:47.673]                   if (TRUE) {
[16:12:47.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.673]                     {
[16:12:47.673]                       inherits <- base::inherits
[16:12:47.673]                       invokeRestart <- base::invokeRestart
[16:12:47.673]                       is.null <- base::is.null
[16:12:47.673]                       muffled <- FALSE
[16:12:47.673]                       if (inherits(cond, "message")) {
[16:12:47.673]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.673]                         if (muffled) 
[16:12:47.673]                           invokeRestart("muffleMessage")
[16:12:47.673]                       }
[16:12:47.673]                       else if (inherits(cond, "warning")) {
[16:12:47.673]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.673]                         if (muffled) 
[16:12:47.673]                           invokeRestart("muffleWarning")
[16:12:47.673]                       }
[16:12:47.673]                       else if (inherits(cond, "condition")) {
[16:12:47.673]                         if (!is.null(pattern)) {
[16:12:47.673]                           computeRestarts <- base::computeRestarts
[16:12:47.673]                           grepl <- base::grepl
[16:12:47.673]                           restarts <- computeRestarts(cond)
[16:12:47.673]                           for (restart in restarts) {
[16:12:47.673]                             name <- restart$name
[16:12:47.673]                             if (is.null(name)) 
[16:12:47.673]                               next
[16:12:47.673]                             if (!grepl(pattern, name)) 
[16:12:47.673]                               next
[16:12:47.673]                             invokeRestart(restart)
[16:12:47.673]                             muffled <- TRUE
[16:12:47.673]                             break
[16:12:47.673]                           }
[16:12:47.673]                         }
[16:12:47.673]                       }
[16:12:47.673]                       invisible(muffled)
[16:12:47.673]                     }
[16:12:47.673]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.673]                   }
[16:12:47.673]                 }
[16:12:47.673]             }
[16:12:47.673]         }))
[16:12:47.673]     }, error = function(ex) {
[16:12:47.673]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.673]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.673]                 ...future.rng), started = ...future.startTime, 
[16:12:47.673]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.673]             version = "1.8"), class = "FutureResult")
[16:12:47.673]     }, finally = {
[16:12:47.673]         if (!identical(...future.workdir, getwd())) 
[16:12:47.673]             setwd(...future.workdir)
[16:12:47.673]         {
[16:12:47.673]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.673]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.673]             }
[16:12:47.673]             base::options(...future.oldOptions)
[16:12:47.673]             if (.Platform$OS.type == "windows") {
[16:12:47.673]                 old_names <- names(...future.oldEnvVars)
[16:12:47.673]                 envs <- base::Sys.getenv()
[16:12:47.673]                 names <- names(envs)
[16:12:47.673]                 common <- intersect(names, old_names)
[16:12:47.673]                 added <- setdiff(names, old_names)
[16:12:47.673]                 removed <- setdiff(old_names, names)
[16:12:47.673]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.673]                   envs[common]]
[16:12:47.673]                 NAMES <- toupper(changed)
[16:12:47.673]                 args <- list()
[16:12:47.673]                 for (kk in seq_along(NAMES)) {
[16:12:47.673]                   name <- changed[[kk]]
[16:12:47.673]                   NAME <- NAMES[[kk]]
[16:12:47.673]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.673]                     next
[16:12:47.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.673]                 }
[16:12:47.673]                 NAMES <- toupper(added)
[16:12:47.673]                 for (kk in seq_along(NAMES)) {
[16:12:47.673]                   name <- added[[kk]]
[16:12:47.673]                   NAME <- NAMES[[kk]]
[16:12:47.673]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.673]                     next
[16:12:47.673]                   args[[name]] <- ""
[16:12:47.673]                 }
[16:12:47.673]                 NAMES <- toupper(removed)
[16:12:47.673]                 for (kk in seq_along(NAMES)) {
[16:12:47.673]                   name <- removed[[kk]]
[16:12:47.673]                   NAME <- NAMES[[kk]]
[16:12:47.673]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.673]                     next
[16:12:47.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.673]                 }
[16:12:47.673]                 if (length(args) > 0) 
[16:12:47.673]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.673]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.673]             }
[16:12:47.673]             else {
[16:12:47.673]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.673]             }
[16:12:47.673]             {
[16:12:47.673]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.673]                   0L) {
[16:12:47.673]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.673]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.673]                   base::options(opts)
[16:12:47.673]                 }
[16:12:47.673]                 {
[16:12:47.673]                   {
[16:12:47.673]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.673]                     NULL
[16:12:47.673]                   }
[16:12:47.673]                   options(future.plan = NULL)
[16:12:47.673]                   if (is.na(NA_character_)) 
[16:12:47.673]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.673]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.673]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.673]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.673]                     envir = parent.frame()) 
[16:12:47.673]                   {
[16:12:47.673]                     if (is.function(workers)) 
[16:12:47.673]                       workers <- workers()
[16:12:47.673]                     workers <- structure(as.integer(workers), 
[16:12:47.673]                       class = class(workers))
[16:12:47.673]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.673]                       workers >= 1)
[16:12:47.673]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.673]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.673]                     }
[16:12:47.673]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.673]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.673]                       envir = envir)
[16:12:47.673]                     if (!future$lazy) 
[16:12:47.673]                       future <- run(future)
[16:12:47.673]                     invisible(future)
[16:12:47.673]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.673]                 }
[16:12:47.673]             }
[16:12:47.673]         }
[16:12:47.673]     })
[16:12:47.673]     if (TRUE) {
[16:12:47.673]         base::sink(type = "output", split = FALSE)
[16:12:47.673]         if (TRUE) {
[16:12:47.673]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.673]         }
[16:12:47.673]         else {
[16:12:47.673]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.673]         }
[16:12:47.673]         base::close(...future.stdout)
[16:12:47.673]         ...future.stdout <- NULL
[16:12:47.673]     }
[16:12:47.673]     ...future.result$conditions <- ...future.conditions
[16:12:47.673]     ...future.result$finished <- base::Sys.time()
[16:12:47.673]     ...future.result
[16:12:47.673] }
[16:12:47.676] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:12:47.676] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:12:47.677] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:12:47.677] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:12:47.677] MultisessionFuture started
[16:12:47.677] - Launch lazy future ... done
[16:12:47.677] run() for ‘MultisessionFuture’ ... done
[16:12:47.678] result() for ClusterFuture ...
[16:12:47.678] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.678] - Validating connection of MultisessionFuture
[16:12:47.725] - received message: FutureResult
[16:12:47.725] - Received FutureResult
[16:12:47.725] - Erased future from FutureRegistry
[16:12:47.725] result() for ClusterFuture ...
[16:12:47.725] - result already collected: FutureResult
[16:12:47.725] result() for ClusterFuture ... done
[16:12:47.725] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.725] result() for ClusterFuture ... done
[16:12:47.725] result() for ClusterFuture ...
[16:12:47.725] - result already collected: FutureResult
[16:12:47.726] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.726] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.726] Searching for globals...
[16:12:47.728] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:47.728] Searching for globals ... DONE
[16:12:47.729] Resolving globals: TRUE
[16:12:47.729] Resolving any globals that are futures ...
[16:12:47.729] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:47.729] Resolving any globals that are futures ... DONE
[16:12:47.729] Resolving futures part of globals (recursively) ...
[16:12:47.729] resolve() on list ...
[16:12:47.730]  recursive: 99
[16:12:47.730]  length: 1
[16:12:47.730]  elements: ‘x’
[16:12:47.730]  length: 0 (resolved future 1)
[16:12:47.730] resolve() on list ... DONE
[16:12:47.730] - globals: [1] ‘x’
[16:12:47.730] Resolving futures part of globals (recursively) ... DONE
[16:12:47.730] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:47.731] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:47.731] - globals: [1] ‘x’
[16:12:47.731] 
[16:12:47.731] getGlobalsAndPackages() ... DONE
[16:12:47.731] run() for ‘Future’ ...
[16:12:47.731] - state: ‘created’
[16:12:47.731] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.746] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.746] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.746]   - Field: ‘node’
[16:12:47.746]   - Field: ‘label’
[16:12:47.746]   - Field: ‘local’
[16:12:47.747]   - Field: ‘owner’
[16:12:47.747]   - Field: ‘envir’
[16:12:47.747]   - Field: ‘workers’
[16:12:47.747]   - Field: ‘packages’
[16:12:47.747]   - Field: ‘gc’
[16:12:47.747]   - Field: ‘conditions’
[16:12:47.747]   - Field: ‘persistent’
[16:12:47.747]   - Field: ‘expr’
[16:12:47.747]   - Field: ‘uuid’
[16:12:47.747]   - Field: ‘seed’
[16:12:47.747]   - Field: ‘version’
[16:12:47.748]   - Field: ‘result’
[16:12:47.748]   - Field: ‘asynchronous’
[16:12:47.748]   - Field: ‘calls’
[16:12:47.748]   - Field: ‘globals’
[16:12:47.748]   - Field: ‘stdout’
[16:12:47.748]   - Field: ‘earlySignal’
[16:12:47.748]   - Field: ‘lazy’
[16:12:47.749]   - Field: ‘state’
[16:12:47.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.749] - Launch lazy future ...
[16:12:47.749] Packages needed by the future expression (n = 0): <none>
[16:12:47.749] Packages needed by future strategies (n = 0): <none>
[16:12:47.750] {
[16:12:47.750]     {
[16:12:47.750]         {
[16:12:47.750]             ...future.startTime <- base::Sys.time()
[16:12:47.750]             {
[16:12:47.750]                 {
[16:12:47.750]                   {
[16:12:47.750]                     {
[16:12:47.750]                       base::local({
[16:12:47.750]                         has_future <- base::requireNamespace("future", 
[16:12:47.750]                           quietly = TRUE)
[16:12:47.750]                         if (has_future) {
[16:12:47.750]                           ns <- base::getNamespace("future")
[16:12:47.750]                           version <- ns[[".package"]][["version"]]
[16:12:47.750]                           if (is.null(version)) 
[16:12:47.750]                             version <- utils::packageVersion("future")
[16:12:47.750]                         }
[16:12:47.750]                         else {
[16:12:47.750]                           version <- NULL
[16:12:47.750]                         }
[16:12:47.750]                         if (!has_future || version < "1.8.0") {
[16:12:47.750]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.750]                             "", base::R.version$version.string), 
[16:12:47.750]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.750]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.750]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.750]                               "release", "version")], collapse = " "), 
[16:12:47.750]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.750]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.750]                             info)
[16:12:47.750]                           info <- base::paste(info, collapse = "; ")
[16:12:47.750]                           if (!has_future) {
[16:12:47.750]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.750]                               info)
[16:12:47.750]                           }
[16:12:47.750]                           else {
[16:12:47.750]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.750]                               info, version)
[16:12:47.750]                           }
[16:12:47.750]                           base::stop(msg)
[16:12:47.750]                         }
[16:12:47.750]                       })
[16:12:47.750]                     }
[16:12:47.750]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.750]                     base::options(mc.cores = 1L)
[16:12:47.750]                   }
[16:12:47.750]                   options(future.plan = NULL)
[16:12:47.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.750]                 }
[16:12:47.750]                 ...future.workdir <- getwd()
[16:12:47.750]             }
[16:12:47.750]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.750]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.750]         }
[16:12:47.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.750]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.750]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.750]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.750]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.750]             base::names(...future.oldOptions))
[16:12:47.750]     }
[16:12:47.750]     if (FALSE) {
[16:12:47.750]     }
[16:12:47.750]     else {
[16:12:47.750]         if (TRUE) {
[16:12:47.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.750]                 open = "w")
[16:12:47.750]         }
[16:12:47.750]         else {
[16:12:47.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.750]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.750]         }
[16:12:47.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.750]             base::sink(type = "output", split = FALSE)
[16:12:47.750]             base::close(...future.stdout)
[16:12:47.750]         }, add = TRUE)
[16:12:47.750]     }
[16:12:47.750]     ...future.frame <- base::sys.nframe()
[16:12:47.750]     ...future.conditions <- base::list()
[16:12:47.750]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.750]     if (FALSE) {
[16:12:47.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.750]     }
[16:12:47.750]     ...future.result <- base::tryCatch({
[16:12:47.750]         base::withCallingHandlers({
[16:12:47.750]             ...future.value <- base::withVisible(base::local({
[16:12:47.750]                 ...future.makeSendCondition <- local({
[16:12:47.750]                   sendCondition <- NULL
[16:12:47.750]                   function(frame = 1L) {
[16:12:47.750]                     if (is.function(sendCondition)) 
[16:12:47.750]                       return(sendCondition)
[16:12:47.750]                     ns <- getNamespace("parallel")
[16:12:47.750]                     if (exists("sendData", mode = "function", 
[16:12:47.750]                       envir = ns)) {
[16:12:47.750]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.750]                         envir = ns)
[16:12:47.750]                       envir <- sys.frame(frame)
[16:12:47.750]                       master <- NULL
[16:12:47.750]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.750]                         !identical(envir, emptyenv())) {
[16:12:47.750]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.750]                           inherits = FALSE)) {
[16:12:47.750]                           master <- get("master", mode = "list", 
[16:12:47.750]                             envir = envir, inherits = FALSE)
[16:12:47.750]                           if (inherits(master, c("SOCKnode", 
[16:12:47.750]                             "SOCK0node"))) {
[16:12:47.750]                             sendCondition <<- function(cond) {
[16:12:47.750]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.750]                                 success = TRUE)
[16:12:47.750]                               parallel_sendData(master, data)
[16:12:47.750]                             }
[16:12:47.750]                             return(sendCondition)
[16:12:47.750]                           }
[16:12:47.750]                         }
[16:12:47.750]                         frame <- frame + 1L
[16:12:47.750]                         envir <- sys.frame(frame)
[16:12:47.750]                       }
[16:12:47.750]                     }
[16:12:47.750]                     sendCondition <<- function(cond) NULL
[16:12:47.750]                   }
[16:12:47.750]                 })
[16:12:47.750]                 withCallingHandlers({
[16:12:47.750]                   {
[16:12:47.750]                     x["a"] <- list(1)
[16:12:47.750]                     x
[16:12:47.750]                   }
[16:12:47.750]                 }, immediateCondition = function(cond) {
[16:12:47.750]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.750]                   sendCondition(cond)
[16:12:47.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.750]                   {
[16:12:47.750]                     inherits <- base::inherits
[16:12:47.750]                     invokeRestart <- base::invokeRestart
[16:12:47.750]                     is.null <- base::is.null
[16:12:47.750]                     muffled <- FALSE
[16:12:47.750]                     if (inherits(cond, "message")) {
[16:12:47.750]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.750]                       if (muffled) 
[16:12:47.750]                         invokeRestart("muffleMessage")
[16:12:47.750]                     }
[16:12:47.750]                     else if (inherits(cond, "warning")) {
[16:12:47.750]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.750]                       if (muffled) 
[16:12:47.750]                         invokeRestart("muffleWarning")
[16:12:47.750]                     }
[16:12:47.750]                     else if (inherits(cond, "condition")) {
[16:12:47.750]                       if (!is.null(pattern)) {
[16:12:47.750]                         computeRestarts <- base::computeRestarts
[16:12:47.750]                         grepl <- base::grepl
[16:12:47.750]                         restarts <- computeRestarts(cond)
[16:12:47.750]                         for (restart in restarts) {
[16:12:47.750]                           name <- restart$name
[16:12:47.750]                           if (is.null(name)) 
[16:12:47.750]                             next
[16:12:47.750]                           if (!grepl(pattern, name)) 
[16:12:47.750]                             next
[16:12:47.750]                           invokeRestart(restart)
[16:12:47.750]                           muffled <- TRUE
[16:12:47.750]                           break
[16:12:47.750]                         }
[16:12:47.750]                       }
[16:12:47.750]                     }
[16:12:47.750]                     invisible(muffled)
[16:12:47.750]                   }
[16:12:47.750]                   muffleCondition(cond)
[16:12:47.750]                 })
[16:12:47.750]             }))
[16:12:47.750]             future::FutureResult(value = ...future.value$value, 
[16:12:47.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.750]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.750]                     ...future.globalenv.names))
[16:12:47.750]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.750]         }, condition = base::local({
[16:12:47.750]             c <- base::c
[16:12:47.750]             inherits <- base::inherits
[16:12:47.750]             invokeRestart <- base::invokeRestart
[16:12:47.750]             length <- base::length
[16:12:47.750]             list <- base::list
[16:12:47.750]             seq.int <- base::seq.int
[16:12:47.750]             signalCondition <- base::signalCondition
[16:12:47.750]             sys.calls <- base::sys.calls
[16:12:47.750]             `[[` <- base::`[[`
[16:12:47.750]             `+` <- base::`+`
[16:12:47.750]             `<<-` <- base::`<<-`
[16:12:47.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.750]                   3L)]
[16:12:47.750]             }
[16:12:47.750]             function(cond) {
[16:12:47.750]                 is_error <- inherits(cond, "error")
[16:12:47.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.750]                   NULL)
[16:12:47.750]                 if (is_error) {
[16:12:47.750]                   sessionInformation <- function() {
[16:12:47.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.750]                       search = base::search(), system = base::Sys.info())
[16:12:47.750]                   }
[16:12:47.750]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.750]                     cond$call), session = sessionInformation(), 
[16:12:47.750]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.750]                   signalCondition(cond)
[16:12:47.750]                 }
[16:12:47.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.750]                 "immediateCondition"))) {
[16:12:47.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.750]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.750]                   if (TRUE && !signal) {
[16:12:47.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.750]                     {
[16:12:47.750]                       inherits <- base::inherits
[16:12:47.750]                       invokeRestart <- base::invokeRestart
[16:12:47.750]                       is.null <- base::is.null
[16:12:47.750]                       muffled <- FALSE
[16:12:47.750]                       if (inherits(cond, "message")) {
[16:12:47.750]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.750]                         if (muffled) 
[16:12:47.750]                           invokeRestart("muffleMessage")
[16:12:47.750]                       }
[16:12:47.750]                       else if (inherits(cond, "warning")) {
[16:12:47.750]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.750]                         if (muffled) 
[16:12:47.750]                           invokeRestart("muffleWarning")
[16:12:47.750]                       }
[16:12:47.750]                       else if (inherits(cond, "condition")) {
[16:12:47.750]                         if (!is.null(pattern)) {
[16:12:47.750]                           computeRestarts <- base::computeRestarts
[16:12:47.750]                           grepl <- base::grepl
[16:12:47.750]                           restarts <- computeRestarts(cond)
[16:12:47.750]                           for (restart in restarts) {
[16:12:47.750]                             name <- restart$name
[16:12:47.750]                             if (is.null(name)) 
[16:12:47.750]                               next
[16:12:47.750]                             if (!grepl(pattern, name)) 
[16:12:47.750]                               next
[16:12:47.750]                             invokeRestart(restart)
[16:12:47.750]                             muffled <- TRUE
[16:12:47.750]                             break
[16:12:47.750]                           }
[16:12:47.750]                         }
[16:12:47.750]                       }
[16:12:47.750]                       invisible(muffled)
[16:12:47.750]                     }
[16:12:47.750]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.750]                   }
[16:12:47.750]                 }
[16:12:47.750]                 else {
[16:12:47.750]                   if (TRUE) {
[16:12:47.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.750]                     {
[16:12:47.750]                       inherits <- base::inherits
[16:12:47.750]                       invokeRestart <- base::invokeRestart
[16:12:47.750]                       is.null <- base::is.null
[16:12:47.750]                       muffled <- FALSE
[16:12:47.750]                       if (inherits(cond, "message")) {
[16:12:47.750]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.750]                         if (muffled) 
[16:12:47.750]                           invokeRestart("muffleMessage")
[16:12:47.750]                       }
[16:12:47.750]                       else if (inherits(cond, "warning")) {
[16:12:47.750]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.750]                         if (muffled) 
[16:12:47.750]                           invokeRestart("muffleWarning")
[16:12:47.750]                       }
[16:12:47.750]                       else if (inherits(cond, "condition")) {
[16:12:47.750]                         if (!is.null(pattern)) {
[16:12:47.750]                           computeRestarts <- base::computeRestarts
[16:12:47.750]                           grepl <- base::grepl
[16:12:47.750]                           restarts <- computeRestarts(cond)
[16:12:47.750]                           for (restart in restarts) {
[16:12:47.750]                             name <- restart$name
[16:12:47.750]                             if (is.null(name)) 
[16:12:47.750]                               next
[16:12:47.750]                             if (!grepl(pattern, name)) 
[16:12:47.750]                               next
[16:12:47.750]                             invokeRestart(restart)
[16:12:47.750]                             muffled <- TRUE
[16:12:47.750]                             break
[16:12:47.750]                           }
[16:12:47.750]                         }
[16:12:47.750]                       }
[16:12:47.750]                       invisible(muffled)
[16:12:47.750]                     }
[16:12:47.750]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.750]                   }
[16:12:47.750]                 }
[16:12:47.750]             }
[16:12:47.750]         }))
[16:12:47.750]     }, error = function(ex) {
[16:12:47.750]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.750]                 ...future.rng), started = ...future.startTime, 
[16:12:47.750]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.750]             version = "1.8"), class = "FutureResult")
[16:12:47.750]     }, finally = {
[16:12:47.750]         if (!identical(...future.workdir, getwd())) 
[16:12:47.750]             setwd(...future.workdir)
[16:12:47.750]         {
[16:12:47.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.750]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.750]             }
[16:12:47.750]             base::options(...future.oldOptions)
[16:12:47.750]             if (.Platform$OS.type == "windows") {
[16:12:47.750]                 old_names <- names(...future.oldEnvVars)
[16:12:47.750]                 envs <- base::Sys.getenv()
[16:12:47.750]                 names <- names(envs)
[16:12:47.750]                 common <- intersect(names, old_names)
[16:12:47.750]                 added <- setdiff(names, old_names)
[16:12:47.750]                 removed <- setdiff(old_names, names)
[16:12:47.750]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.750]                   envs[common]]
[16:12:47.750]                 NAMES <- toupper(changed)
[16:12:47.750]                 args <- list()
[16:12:47.750]                 for (kk in seq_along(NAMES)) {
[16:12:47.750]                   name <- changed[[kk]]
[16:12:47.750]                   NAME <- NAMES[[kk]]
[16:12:47.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.750]                     next
[16:12:47.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.750]                 }
[16:12:47.750]                 NAMES <- toupper(added)
[16:12:47.750]                 for (kk in seq_along(NAMES)) {
[16:12:47.750]                   name <- added[[kk]]
[16:12:47.750]                   NAME <- NAMES[[kk]]
[16:12:47.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.750]                     next
[16:12:47.750]                   args[[name]] <- ""
[16:12:47.750]                 }
[16:12:47.750]                 NAMES <- toupper(removed)
[16:12:47.750]                 for (kk in seq_along(NAMES)) {
[16:12:47.750]                   name <- removed[[kk]]
[16:12:47.750]                   NAME <- NAMES[[kk]]
[16:12:47.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.750]                     next
[16:12:47.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.750]                 }
[16:12:47.750]                 if (length(args) > 0) 
[16:12:47.750]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.750]             }
[16:12:47.750]             else {
[16:12:47.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.750]             }
[16:12:47.750]             {
[16:12:47.750]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.750]                   0L) {
[16:12:47.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.750]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.750]                   base::options(opts)
[16:12:47.750]                 }
[16:12:47.750]                 {
[16:12:47.750]                   {
[16:12:47.750]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.750]                     NULL
[16:12:47.750]                   }
[16:12:47.750]                   options(future.plan = NULL)
[16:12:47.750]                   if (is.na(NA_character_)) 
[16:12:47.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.750]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.750]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.750]                     envir = parent.frame()) 
[16:12:47.750]                   {
[16:12:47.750]                     if (is.function(workers)) 
[16:12:47.750]                       workers <- workers()
[16:12:47.750]                     workers <- structure(as.integer(workers), 
[16:12:47.750]                       class = class(workers))
[16:12:47.750]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.750]                       workers >= 1)
[16:12:47.750]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.750]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.750]                     }
[16:12:47.750]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.750]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.750]                       envir = envir)
[16:12:47.750]                     if (!future$lazy) 
[16:12:47.750]                       future <- run(future)
[16:12:47.750]                     invisible(future)
[16:12:47.750]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.750]                 }
[16:12:47.750]             }
[16:12:47.750]         }
[16:12:47.750]     })
[16:12:47.750]     if (TRUE) {
[16:12:47.750]         base::sink(type = "output", split = FALSE)
[16:12:47.750]         if (TRUE) {
[16:12:47.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.750]         }
[16:12:47.750]         else {
[16:12:47.750]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.750]         }
[16:12:47.750]         base::close(...future.stdout)
[16:12:47.750]         ...future.stdout <- NULL
[16:12:47.750]     }
[16:12:47.750]     ...future.result$conditions <- ...future.conditions
[16:12:47.750]     ...future.result$finished <- base::Sys.time()
[16:12:47.750]     ...future.result
[16:12:47.750] }
[16:12:47.753] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:12:47.753] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:12:47.754] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:12:47.754] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:12:47.754] MultisessionFuture started
[16:12:47.754] - Launch lazy future ... done
[16:12:47.754] run() for ‘MultisessionFuture’ ... done
[16:12:47.754] result() for ClusterFuture ...
[16:12:47.755] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.755] - Validating connection of MultisessionFuture
[16:12:47.801] - received message: FutureResult
[16:12:47.801] - Received FutureResult
[16:12:47.801] - Erased future from FutureRegistry
[16:12:47.802] result() for ClusterFuture ...
[16:12:47.802] - result already collected: FutureResult
[16:12:47.802] result() for ClusterFuture ... done
[16:12:47.802] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.802] result() for ClusterFuture ... done
[16:12:47.802] result() for ClusterFuture ...
[16:12:47.802] - result already collected: FutureResult
[16:12:47.802] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.803] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.803] Searching for globals...
[16:12:47.805] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:47.805] Searching for globals ... DONE
[16:12:47.805] Resolving globals: TRUE
[16:12:47.805] Resolving any globals that are futures ...
[16:12:47.806] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:47.806] Resolving any globals that are futures ... DONE
[16:12:47.806] Resolving futures part of globals (recursively) ...
[16:12:47.806] resolve() on list ...
[16:12:47.806]  recursive: 99
[16:12:47.806]  length: 1
[16:12:47.807]  elements: ‘x’
[16:12:47.807]  length: 0 (resolved future 1)
[16:12:47.807] resolve() on list ... DONE
[16:12:47.807] - globals: [1] ‘x’
[16:12:47.807] Resolving futures part of globals (recursively) ... DONE
[16:12:47.807] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:47.807] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:47.808] - globals: [1] ‘x’
[16:12:47.808] 
[16:12:47.808] getGlobalsAndPackages() ... DONE
[16:12:47.808] run() for ‘Future’ ...
[16:12:47.808] - state: ‘created’
[16:12:47.808] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.823] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.823] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.823]   - Field: ‘node’
[16:12:47.823]   - Field: ‘label’
[16:12:47.823]   - Field: ‘local’
[16:12:47.824]   - Field: ‘owner’
[16:12:47.824]   - Field: ‘envir’
[16:12:47.824]   - Field: ‘workers’
[16:12:47.824]   - Field: ‘packages’
[16:12:47.824]   - Field: ‘gc’
[16:12:47.824]   - Field: ‘conditions’
[16:12:47.824]   - Field: ‘persistent’
[16:12:47.824]   - Field: ‘expr’
[16:12:47.824]   - Field: ‘uuid’
[16:12:47.824]   - Field: ‘seed’
[16:12:47.824]   - Field: ‘version’
[16:12:47.825]   - Field: ‘result’
[16:12:47.825]   - Field: ‘asynchronous’
[16:12:47.825]   - Field: ‘calls’
[16:12:47.825]   - Field: ‘globals’
[16:12:47.825]   - Field: ‘stdout’
[16:12:47.825]   - Field: ‘earlySignal’
[16:12:47.825]   - Field: ‘lazy’
[16:12:47.825]   - Field: ‘state’
[16:12:47.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.825] - Launch lazy future ...
[16:12:47.826] Packages needed by the future expression (n = 0): <none>
[16:12:47.826] Packages needed by future strategies (n = 0): <none>
[16:12:47.826] {
[16:12:47.826]     {
[16:12:47.826]         {
[16:12:47.826]             ...future.startTime <- base::Sys.time()
[16:12:47.826]             {
[16:12:47.826]                 {
[16:12:47.826]                   {
[16:12:47.826]                     {
[16:12:47.826]                       base::local({
[16:12:47.826]                         has_future <- base::requireNamespace("future", 
[16:12:47.826]                           quietly = TRUE)
[16:12:47.826]                         if (has_future) {
[16:12:47.826]                           ns <- base::getNamespace("future")
[16:12:47.826]                           version <- ns[[".package"]][["version"]]
[16:12:47.826]                           if (is.null(version)) 
[16:12:47.826]                             version <- utils::packageVersion("future")
[16:12:47.826]                         }
[16:12:47.826]                         else {
[16:12:47.826]                           version <- NULL
[16:12:47.826]                         }
[16:12:47.826]                         if (!has_future || version < "1.8.0") {
[16:12:47.826]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.826]                             "", base::R.version$version.string), 
[16:12:47.826]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.826]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.826]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.826]                               "release", "version")], collapse = " "), 
[16:12:47.826]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.826]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.826]                             info)
[16:12:47.826]                           info <- base::paste(info, collapse = "; ")
[16:12:47.826]                           if (!has_future) {
[16:12:47.826]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.826]                               info)
[16:12:47.826]                           }
[16:12:47.826]                           else {
[16:12:47.826]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.826]                               info, version)
[16:12:47.826]                           }
[16:12:47.826]                           base::stop(msg)
[16:12:47.826]                         }
[16:12:47.826]                       })
[16:12:47.826]                     }
[16:12:47.826]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.826]                     base::options(mc.cores = 1L)
[16:12:47.826]                   }
[16:12:47.826]                   options(future.plan = NULL)
[16:12:47.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.826]                 }
[16:12:47.826]                 ...future.workdir <- getwd()
[16:12:47.826]             }
[16:12:47.826]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.826]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.826]         }
[16:12:47.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.826]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.826]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.826]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.826]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.826]             base::names(...future.oldOptions))
[16:12:47.826]     }
[16:12:47.826]     if (FALSE) {
[16:12:47.826]     }
[16:12:47.826]     else {
[16:12:47.826]         if (TRUE) {
[16:12:47.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.826]                 open = "w")
[16:12:47.826]         }
[16:12:47.826]         else {
[16:12:47.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.826]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.826]         }
[16:12:47.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.826]             base::sink(type = "output", split = FALSE)
[16:12:47.826]             base::close(...future.stdout)
[16:12:47.826]         }, add = TRUE)
[16:12:47.826]     }
[16:12:47.826]     ...future.frame <- base::sys.nframe()
[16:12:47.826]     ...future.conditions <- base::list()
[16:12:47.826]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.826]     if (FALSE) {
[16:12:47.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.826]     }
[16:12:47.826]     ...future.result <- base::tryCatch({
[16:12:47.826]         base::withCallingHandlers({
[16:12:47.826]             ...future.value <- base::withVisible(base::local({
[16:12:47.826]                 ...future.makeSendCondition <- local({
[16:12:47.826]                   sendCondition <- NULL
[16:12:47.826]                   function(frame = 1L) {
[16:12:47.826]                     if (is.function(sendCondition)) 
[16:12:47.826]                       return(sendCondition)
[16:12:47.826]                     ns <- getNamespace("parallel")
[16:12:47.826]                     if (exists("sendData", mode = "function", 
[16:12:47.826]                       envir = ns)) {
[16:12:47.826]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.826]                         envir = ns)
[16:12:47.826]                       envir <- sys.frame(frame)
[16:12:47.826]                       master <- NULL
[16:12:47.826]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.826]                         !identical(envir, emptyenv())) {
[16:12:47.826]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.826]                           inherits = FALSE)) {
[16:12:47.826]                           master <- get("master", mode = "list", 
[16:12:47.826]                             envir = envir, inherits = FALSE)
[16:12:47.826]                           if (inherits(master, c("SOCKnode", 
[16:12:47.826]                             "SOCK0node"))) {
[16:12:47.826]                             sendCondition <<- function(cond) {
[16:12:47.826]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.826]                                 success = TRUE)
[16:12:47.826]                               parallel_sendData(master, data)
[16:12:47.826]                             }
[16:12:47.826]                             return(sendCondition)
[16:12:47.826]                           }
[16:12:47.826]                         }
[16:12:47.826]                         frame <- frame + 1L
[16:12:47.826]                         envir <- sys.frame(frame)
[16:12:47.826]                       }
[16:12:47.826]                     }
[16:12:47.826]                     sendCondition <<- function(cond) NULL
[16:12:47.826]                   }
[16:12:47.826]                 })
[16:12:47.826]                 withCallingHandlers({
[16:12:47.826]                   {
[16:12:47.826]                     x["a"] <- list(1)
[16:12:47.826]                     x
[16:12:47.826]                   }
[16:12:47.826]                 }, immediateCondition = function(cond) {
[16:12:47.826]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.826]                   sendCondition(cond)
[16:12:47.826]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.826]                   {
[16:12:47.826]                     inherits <- base::inherits
[16:12:47.826]                     invokeRestart <- base::invokeRestart
[16:12:47.826]                     is.null <- base::is.null
[16:12:47.826]                     muffled <- FALSE
[16:12:47.826]                     if (inherits(cond, "message")) {
[16:12:47.826]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.826]                       if (muffled) 
[16:12:47.826]                         invokeRestart("muffleMessage")
[16:12:47.826]                     }
[16:12:47.826]                     else if (inherits(cond, "warning")) {
[16:12:47.826]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.826]                       if (muffled) 
[16:12:47.826]                         invokeRestart("muffleWarning")
[16:12:47.826]                     }
[16:12:47.826]                     else if (inherits(cond, "condition")) {
[16:12:47.826]                       if (!is.null(pattern)) {
[16:12:47.826]                         computeRestarts <- base::computeRestarts
[16:12:47.826]                         grepl <- base::grepl
[16:12:47.826]                         restarts <- computeRestarts(cond)
[16:12:47.826]                         for (restart in restarts) {
[16:12:47.826]                           name <- restart$name
[16:12:47.826]                           if (is.null(name)) 
[16:12:47.826]                             next
[16:12:47.826]                           if (!grepl(pattern, name)) 
[16:12:47.826]                             next
[16:12:47.826]                           invokeRestart(restart)
[16:12:47.826]                           muffled <- TRUE
[16:12:47.826]                           break
[16:12:47.826]                         }
[16:12:47.826]                       }
[16:12:47.826]                     }
[16:12:47.826]                     invisible(muffled)
[16:12:47.826]                   }
[16:12:47.826]                   muffleCondition(cond)
[16:12:47.826]                 })
[16:12:47.826]             }))
[16:12:47.826]             future::FutureResult(value = ...future.value$value, 
[16:12:47.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.826]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.826]                     ...future.globalenv.names))
[16:12:47.826]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.826]         }, condition = base::local({
[16:12:47.826]             c <- base::c
[16:12:47.826]             inherits <- base::inherits
[16:12:47.826]             invokeRestart <- base::invokeRestart
[16:12:47.826]             length <- base::length
[16:12:47.826]             list <- base::list
[16:12:47.826]             seq.int <- base::seq.int
[16:12:47.826]             signalCondition <- base::signalCondition
[16:12:47.826]             sys.calls <- base::sys.calls
[16:12:47.826]             `[[` <- base::`[[`
[16:12:47.826]             `+` <- base::`+`
[16:12:47.826]             `<<-` <- base::`<<-`
[16:12:47.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.826]                   3L)]
[16:12:47.826]             }
[16:12:47.826]             function(cond) {
[16:12:47.826]                 is_error <- inherits(cond, "error")
[16:12:47.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.826]                   NULL)
[16:12:47.826]                 if (is_error) {
[16:12:47.826]                   sessionInformation <- function() {
[16:12:47.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.826]                       search = base::search(), system = base::Sys.info())
[16:12:47.826]                   }
[16:12:47.826]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.826]                     cond$call), session = sessionInformation(), 
[16:12:47.826]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.826]                   signalCondition(cond)
[16:12:47.826]                 }
[16:12:47.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.826]                 "immediateCondition"))) {
[16:12:47.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.826]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.826]                   if (TRUE && !signal) {
[16:12:47.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.826]                     {
[16:12:47.826]                       inherits <- base::inherits
[16:12:47.826]                       invokeRestart <- base::invokeRestart
[16:12:47.826]                       is.null <- base::is.null
[16:12:47.826]                       muffled <- FALSE
[16:12:47.826]                       if (inherits(cond, "message")) {
[16:12:47.826]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.826]                         if (muffled) 
[16:12:47.826]                           invokeRestart("muffleMessage")
[16:12:47.826]                       }
[16:12:47.826]                       else if (inherits(cond, "warning")) {
[16:12:47.826]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.826]                         if (muffled) 
[16:12:47.826]                           invokeRestart("muffleWarning")
[16:12:47.826]                       }
[16:12:47.826]                       else if (inherits(cond, "condition")) {
[16:12:47.826]                         if (!is.null(pattern)) {
[16:12:47.826]                           computeRestarts <- base::computeRestarts
[16:12:47.826]                           grepl <- base::grepl
[16:12:47.826]                           restarts <- computeRestarts(cond)
[16:12:47.826]                           for (restart in restarts) {
[16:12:47.826]                             name <- restart$name
[16:12:47.826]                             if (is.null(name)) 
[16:12:47.826]                               next
[16:12:47.826]                             if (!grepl(pattern, name)) 
[16:12:47.826]                               next
[16:12:47.826]                             invokeRestart(restart)
[16:12:47.826]                             muffled <- TRUE
[16:12:47.826]                             break
[16:12:47.826]                           }
[16:12:47.826]                         }
[16:12:47.826]                       }
[16:12:47.826]                       invisible(muffled)
[16:12:47.826]                     }
[16:12:47.826]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.826]                   }
[16:12:47.826]                 }
[16:12:47.826]                 else {
[16:12:47.826]                   if (TRUE) {
[16:12:47.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.826]                     {
[16:12:47.826]                       inherits <- base::inherits
[16:12:47.826]                       invokeRestart <- base::invokeRestart
[16:12:47.826]                       is.null <- base::is.null
[16:12:47.826]                       muffled <- FALSE
[16:12:47.826]                       if (inherits(cond, "message")) {
[16:12:47.826]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.826]                         if (muffled) 
[16:12:47.826]                           invokeRestart("muffleMessage")
[16:12:47.826]                       }
[16:12:47.826]                       else if (inherits(cond, "warning")) {
[16:12:47.826]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.826]                         if (muffled) 
[16:12:47.826]                           invokeRestart("muffleWarning")
[16:12:47.826]                       }
[16:12:47.826]                       else if (inherits(cond, "condition")) {
[16:12:47.826]                         if (!is.null(pattern)) {
[16:12:47.826]                           computeRestarts <- base::computeRestarts
[16:12:47.826]                           grepl <- base::grepl
[16:12:47.826]                           restarts <- computeRestarts(cond)
[16:12:47.826]                           for (restart in restarts) {
[16:12:47.826]                             name <- restart$name
[16:12:47.826]                             if (is.null(name)) 
[16:12:47.826]                               next
[16:12:47.826]                             if (!grepl(pattern, name)) 
[16:12:47.826]                               next
[16:12:47.826]                             invokeRestart(restart)
[16:12:47.826]                             muffled <- TRUE
[16:12:47.826]                             break
[16:12:47.826]                           }
[16:12:47.826]                         }
[16:12:47.826]                       }
[16:12:47.826]                       invisible(muffled)
[16:12:47.826]                     }
[16:12:47.826]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.826]                   }
[16:12:47.826]                 }
[16:12:47.826]             }
[16:12:47.826]         }))
[16:12:47.826]     }, error = function(ex) {
[16:12:47.826]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.826]                 ...future.rng), started = ...future.startTime, 
[16:12:47.826]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.826]             version = "1.8"), class = "FutureResult")
[16:12:47.826]     }, finally = {
[16:12:47.826]         if (!identical(...future.workdir, getwd())) 
[16:12:47.826]             setwd(...future.workdir)
[16:12:47.826]         {
[16:12:47.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.826]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.826]             }
[16:12:47.826]             base::options(...future.oldOptions)
[16:12:47.826]             if (.Platform$OS.type == "windows") {
[16:12:47.826]                 old_names <- names(...future.oldEnvVars)
[16:12:47.826]                 envs <- base::Sys.getenv()
[16:12:47.826]                 names <- names(envs)
[16:12:47.826]                 common <- intersect(names, old_names)
[16:12:47.826]                 added <- setdiff(names, old_names)
[16:12:47.826]                 removed <- setdiff(old_names, names)
[16:12:47.826]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.826]                   envs[common]]
[16:12:47.826]                 NAMES <- toupper(changed)
[16:12:47.826]                 args <- list()
[16:12:47.826]                 for (kk in seq_along(NAMES)) {
[16:12:47.826]                   name <- changed[[kk]]
[16:12:47.826]                   NAME <- NAMES[[kk]]
[16:12:47.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.826]                     next
[16:12:47.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.826]                 }
[16:12:47.826]                 NAMES <- toupper(added)
[16:12:47.826]                 for (kk in seq_along(NAMES)) {
[16:12:47.826]                   name <- added[[kk]]
[16:12:47.826]                   NAME <- NAMES[[kk]]
[16:12:47.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.826]                     next
[16:12:47.826]                   args[[name]] <- ""
[16:12:47.826]                 }
[16:12:47.826]                 NAMES <- toupper(removed)
[16:12:47.826]                 for (kk in seq_along(NAMES)) {
[16:12:47.826]                   name <- removed[[kk]]
[16:12:47.826]                   NAME <- NAMES[[kk]]
[16:12:47.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.826]                     next
[16:12:47.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.826]                 }
[16:12:47.826]                 if (length(args) > 0) 
[16:12:47.826]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.826]             }
[16:12:47.826]             else {
[16:12:47.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.826]             }
[16:12:47.826]             {
[16:12:47.826]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.826]                   0L) {
[16:12:47.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.826]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.826]                   base::options(opts)
[16:12:47.826]                 }
[16:12:47.826]                 {
[16:12:47.826]                   {
[16:12:47.826]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.826]                     NULL
[16:12:47.826]                   }
[16:12:47.826]                   options(future.plan = NULL)
[16:12:47.826]                   if (is.na(NA_character_)) 
[16:12:47.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.826]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.826]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.826]                     envir = parent.frame()) 
[16:12:47.826]                   {
[16:12:47.826]                     if (is.function(workers)) 
[16:12:47.826]                       workers <- workers()
[16:12:47.826]                     workers <- structure(as.integer(workers), 
[16:12:47.826]                       class = class(workers))
[16:12:47.826]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.826]                       workers >= 1)
[16:12:47.826]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.826]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.826]                     }
[16:12:47.826]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.826]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.826]                       envir = envir)
[16:12:47.826]                     if (!future$lazy) 
[16:12:47.826]                       future <- run(future)
[16:12:47.826]                     invisible(future)
[16:12:47.826]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.826]                 }
[16:12:47.826]             }
[16:12:47.826]         }
[16:12:47.826]     })
[16:12:47.826]     if (TRUE) {
[16:12:47.826]         base::sink(type = "output", split = FALSE)
[16:12:47.826]         if (TRUE) {
[16:12:47.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.826]         }
[16:12:47.826]         else {
[16:12:47.826]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.826]         }
[16:12:47.826]         base::close(...future.stdout)
[16:12:47.826]         ...future.stdout <- NULL
[16:12:47.826]     }
[16:12:47.826]     ...future.result$conditions <- ...future.conditions
[16:12:47.826]     ...future.result$finished <- base::Sys.time()
[16:12:47.826]     ...future.result
[16:12:47.826] }
[16:12:47.829] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:12:47.829] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:12:47.830] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:12:47.830] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:12:47.830] MultisessionFuture started
[16:12:47.830] - Launch lazy future ... done
[16:12:47.830] run() for ‘MultisessionFuture’ ... done
[16:12:47.831] result() for ClusterFuture ...
[16:12:47.831] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.831] - Validating connection of MultisessionFuture
[16:12:47.877] - received message: FutureResult
[16:12:47.877] - Received FutureResult
[16:12:47.877] - Erased future from FutureRegistry
[16:12:47.877] result() for ClusterFuture ...
[16:12:47.877] - result already collected: FutureResult
[16:12:47.878] result() for ClusterFuture ... done
[16:12:47.878] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.878] result() for ClusterFuture ... done
[16:12:47.878] result() for ClusterFuture ...
[16:12:47.878] - result already collected: FutureResult
[16:12:47.878] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.879] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.879] Searching for globals...
[16:12:47.881] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:47.881] Searching for globals ... DONE
[16:12:47.881] Resolving globals: TRUE
[16:12:47.881] Resolving any globals that are futures ...
[16:12:47.881] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[16:12:47.882] Resolving any globals that are futures ... DONE
[16:12:47.882] Resolving futures part of globals (recursively) ...
[16:12:47.882] resolve() on list ...
[16:12:47.882]  recursive: 99
[16:12:47.882]  length: 1
[16:12:47.883]  elements: ‘x’
[16:12:47.883]  length: 0 (resolved future 1)
[16:12:47.883] resolve() on list ... DONE
[16:12:47.883] - globals: [1] ‘x’
[16:12:47.883] Resolving futures part of globals (recursively) ... DONE
[16:12:47.883] The total size of the 1 globals is 0 bytes (0 bytes)
[16:12:47.883] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[16:12:47.884] - globals: [1] ‘x’
[16:12:47.884] 
[16:12:47.884] getGlobalsAndPackages() ... DONE
[16:12:47.884] run() for ‘Future’ ...
[16:12:47.884] - state: ‘created’
[16:12:47.884] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.899] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.899] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.899]   - Field: ‘node’
[16:12:47.899]   - Field: ‘label’
[16:12:47.899]   - Field: ‘local’
[16:12:47.900]   - Field: ‘owner’
[16:12:47.900]   - Field: ‘envir’
[16:12:47.900]   - Field: ‘workers’
[16:12:47.900]   - Field: ‘packages’
[16:12:47.900]   - Field: ‘gc’
[16:12:47.900]   - Field: ‘conditions’
[16:12:47.900]   - Field: ‘persistent’
[16:12:47.900]   - Field: ‘expr’
[16:12:47.900]   - Field: ‘uuid’
[16:12:47.900]   - Field: ‘seed’
[16:12:47.901]   - Field: ‘version’
[16:12:47.901]   - Field: ‘result’
[16:12:47.901]   - Field: ‘asynchronous’
[16:12:47.901]   - Field: ‘calls’
[16:12:47.901]   - Field: ‘globals’
[16:12:47.901]   - Field: ‘stdout’
[16:12:47.901]   - Field: ‘earlySignal’
[16:12:47.901]   - Field: ‘lazy’
[16:12:47.901]   - Field: ‘state’
[16:12:47.901] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.901] - Launch lazy future ...
[16:12:47.902] Packages needed by the future expression (n = 0): <none>
[16:12:47.902] Packages needed by future strategies (n = 0): <none>
[16:12:47.902] {
[16:12:47.902]     {
[16:12:47.902]         {
[16:12:47.902]             ...future.startTime <- base::Sys.time()
[16:12:47.902]             {
[16:12:47.902]                 {
[16:12:47.902]                   {
[16:12:47.902]                     {
[16:12:47.902]                       base::local({
[16:12:47.902]                         has_future <- base::requireNamespace("future", 
[16:12:47.902]                           quietly = TRUE)
[16:12:47.902]                         if (has_future) {
[16:12:47.902]                           ns <- base::getNamespace("future")
[16:12:47.902]                           version <- ns[[".package"]][["version"]]
[16:12:47.902]                           if (is.null(version)) 
[16:12:47.902]                             version <- utils::packageVersion("future")
[16:12:47.902]                         }
[16:12:47.902]                         else {
[16:12:47.902]                           version <- NULL
[16:12:47.902]                         }
[16:12:47.902]                         if (!has_future || version < "1.8.0") {
[16:12:47.902]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.902]                             "", base::R.version$version.string), 
[16:12:47.902]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.902]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.902]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.902]                               "release", "version")], collapse = " "), 
[16:12:47.902]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.902]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.902]                             info)
[16:12:47.902]                           info <- base::paste(info, collapse = "; ")
[16:12:47.902]                           if (!has_future) {
[16:12:47.902]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.902]                               info)
[16:12:47.902]                           }
[16:12:47.902]                           else {
[16:12:47.902]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.902]                               info, version)
[16:12:47.902]                           }
[16:12:47.902]                           base::stop(msg)
[16:12:47.902]                         }
[16:12:47.902]                       })
[16:12:47.902]                     }
[16:12:47.902]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.902]                     base::options(mc.cores = 1L)
[16:12:47.902]                   }
[16:12:47.902]                   options(future.plan = NULL)
[16:12:47.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.902]                 }
[16:12:47.902]                 ...future.workdir <- getwd()
[16:12:47.902]             }
[16:12:47.902]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.902]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.902]         }
[16:12:47.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.902]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.902]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.902]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.902]             base::names(...future.oldOptions))
[16:12:47.902]     }
[16:12:47.902]     if (FALSE) {
[16:12:47.902]     }
[16:12:47.902]     else {
[16:12:47.902]         if (TRUE) {
[16:12:47.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.902]                 open = "w")
[16:12:47.902]         }
[16:12:47.902]         else {
[16:12:47.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.902]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.902]         }
[16:12:47.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.902]             base::sink(type = "output", split = FALSE)
[16:12:47.902]             base::close(...future.stdout)
[16:12:47.902]         }, add = TRUE)
[16:12:47.902]     }
[16:12:47.902]     ...future.frame <- base::sys.nframe()
[16:12:47.902]     ...future.conditions <- base::list()
[16:12:47.902]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.902]     if (FALSE) {
[16:12:47.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.902]     }
[16:12:47.902]     ...future.result <- base::tryCatch({
[16:12:47.902]         base::withCallingHandlers({
[16:12:47.902]             ...future.value <- base::withVisible(base::local({
[16:12:47.902]                 ...future.makeSendCondition <- local({
[16:12:47.902]                   sendCondition <- NULL
[16:12:47.902]                   function(frame = 1L) {
[16:12:47.902]                     if (is.function(sendCondition)) 
[16:12:47.902]                       return(sendCondition)
[16:12:47.902]                     ns <- getNamespace("parallel")
[16:12:47.902]                     if (exists("sendData", mode = "function", 
[16:12:47.902]                       envir = ns)) {
[16:12:47.902]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.902]                         envir = ns)
[16:12:47.902]                       envir <- sys.frame(frame)
[16:12:47.902]                       master <- NULL
[16:12:47.902]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.902]                         !identical(envir, emptyenv())) {
[16:12:47.902]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.902]                           inherits = FALSE)) {
[16:12:47.902]                           master <- get("master", mode = "list", 
[16:12:47.902]                             envir = envir, inherits = FALSE)
[16:12:47.902]                           if (inherits(master, c("SOCKnode", 
[16:12:47.902]                             "SOCK0node"))) {
[16:12:47.902]                             sendCondition <<- function(cond) {
[16:12:47.902]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.902]                                 success = TRUE)
[16:12:47.902]                               parallel_sendData(master, data)
[16:12:47.902]                             }
[16:12:47.902]                             return(sendCondition)
[16:12:47.902]                           }
[16:12:47.902]                         }
[16:12:47.902]                         frame <- frame + 1L
[16:12:47.902]                         envir <- sys.frame(frame)
[16:12:47.902]                       }
[16:12:47.902]                     }
[16:12:47.902]                     sendCondition <<- function(cond) NULL
[16:12:47.902]                   }
[16:12:47.902]                 })
[16:12:47.902]                 withCallingHandlers({
[16:12:47.902]                   {
[16:12:47.902]                     x["a"] <- list(1)
[16:12:47.902]                     x
[16:12:47.902]                   }
[16:12:47.902]                 }, immediateCondition = function(cond) {
[16:12:47.902]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.902]                   sendCondition(cond)
[16:12:47.902]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.902]                   {
[16:12:47.902]                     inherits <- base::inherits
[16:12:47.902]                     invokeRestart <- base::invokeRestart
[16:12:47.902]                     is.null <- base::is.null
[16:12:47.902]                     muffled <- FALSE
[16:12:47.902]                     if (inherits(cond, "message")) {
[16:12:47.902]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.902]                       if (muffled) 
[16:12:47.902]                         invokeRestart("muffleMessage")
[16:12:47.902]                     }
[16:12:47.902]                     else if (inherits(cond, "warning")) {
[16:12:47.902]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.902]                       if (muffled) 
[16:12:47.902]                         invokeRestart("muffleWarning")
[16:12:47.902]                     }
[16:12:47.902]                     else if (inherits(cond, "condition")) {
[16:12:47.902]                       if (!is.null(pattern)) {
[16:12:47.902]                         computeRestarts <- base::computeRestarts
[16:12:47.902]                         grepl <- base::grepl
[16:12:47.902]                         restarts <- computeRestarts(cond)
[16:12:47.902]                         for (restart in restarts) {
[16:12:47.902]                           name <- restart$name
[16:12:47.902]                           if (is.null(name)) 
[16:12:47.902]                             next
[16:12:47.902]                           if (!grepl(pattern, name)) 
[16:12:47.902]                             next
[16:12:47.902]                           invokeRestart(restart)
[16:12:47.902]                           muffled <- TRUE
[16:12:47.902]                           break
[16:12:47.902]                         }
[16:12:47.902]                       }
[16:12:47.902]                     }
[16:12:47.902]                     invisible(muffled)
[16:12:47.902]                   }
[16:12:47.902]                   muffleCondition(cond)
[16:12:47.902]                 })
[16:12:47.902]             }))
[16:12:47.902]             future::FutureResult(value = ...future.value$value, 
[16:12:47.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.902]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.902]                     ...future.globalenv.names))
[16:12:47.902]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.902]         }, condition = base::local({
[16:12:47.902]             c <- base::c
[16:12:47.902]             inherits <- base::inherits
[16:12:47.902]             invokeRestart <- base::invokeRestart
[16:12:47.902]             length <- base::length
[16:12:47.902]             list <- base::list
[16:12:47.902]             seq.int <- base::seq.int
[16:12:47.902]             signalCondition <- base::signalCondition
[16:12:47.902]             sys.calls <- base::sys.calls
[16:12:47.902]             `[[` <- base::`[[`
[16:12:47.902]             `+` <- base::`+`
[16:12:47.902]             `<<-` <- base::`<<-`
[16:12:47.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.902]                   3L)]
[16:12:47.902]             }
[16:12:47.902]             function(cond) {
[16:12:47.902]                 is_error <- inherits(cond, "error")
[16:12:47.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.902]                   NULL)
[16:12:47.902]                 if (is_error) {
[16:12:47.902]                   sessionInformation <- function() {
[16:12:47.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.902]                       search = base::search(), system = base::Sys.info())
[16:12:47.902]                   }
[16:12:47.902]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.902]                     cond$call), session = sessionInformation(), 
[16:12:47.902]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.902]                   signalCondition(cond)
[16:12:47.902]                 }
[16:12:47.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.902]                 "immediateCondition"))) {
[16:12:47.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.902]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.902]                   if (TRUE && !signal) {
[16:12:47.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.902]                     {
[16:12:47.902]                       inherits <- base::inherits
[16:12:47.902]                       invokeRestart <- base::invokeRestart
[16:12:47.902]                       is.null <- base::is.null
[16:12:47.902]                       muffled <- FALSE
[16:12:47.902]                       if (inherits(cond, "message")) {
[16:12:47.902]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.902]                         if (muffled) 
[16:12:47.902]                           invokeRestart("muffleMessage")
[16:12:47.902]                       }
[16:12:47.902]                       else if (inherits(cond, "warning")) {
[16:12:47.902]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.902]                         if (muffled) 
[16:12:47.902]                           invokeRestart("muffleWarning")
[16:12:47.902]                       }
[16:12:47.902]                       else if (inherits(cond, "condition")) {
[16:12:47.902]                         if (!is.null(pattern)) {
[16:12:47.902]                           computeRestarts <- base::computeRestarts
[16:12:47.902]                           grepl <- base::grepl
[16:12:47.902]                           restarts <- computeRestarts(cond)
[16:12:47.902]                           for (restart in restarts) {
[16:12:47.902]                             name <- restart$name
[16:12:47.902]                             if (is.null(name)) 
[16:12:47.902]                               next
[16:12:47.902]                             if (!grepl(pattern, name)) 
[16:12:47.902]                               next
[16:12:47.902]                             invokeRestart(restart)
[16:12:47.902]                             muffled <- TRUE
[16:12:47.902]                             break
[16:12:47.902]                           }
[16:12:47.902]                         }
[16:12:47.902]                       }
[16:12:47.902]                       invisible(muffled)
[16:12:47.902]                     }
[16:12:47.902]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.902]                   }
[16:12:47.902]                 }
[16:12:47.902]                 else {
[16:12:47.902]                   if (TRUE) {
[16:12:47.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.902]                     {
[16:12:47.902]                       inherits <- base::inherits
[16:12:47.902]                       invokeRestart <- base::invokeRestart
[16:12:47.902]                       is.null <- base::is.null
[16:12:47.902]                       muffled <- FALSE
[16:12:47.902]                       if (inherits(cond, "message")) {
[16:12:47.902]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.902]                         if (muffled) 
[16:12:47.902]                           invokeRestart("muffleMessage")
[16:12:47.902]                       }
[16:12:47.902]                       else if (inherits(cond, "warning")) {
[16:12:47.902]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.902]                         if (muffled) 
[16:12:47.902]                           invokeRestart("muffleWarning")
[16:12:47.902]                       }
[16:12:47.902]                       else if (inherits(cond, "condition")) {
[16:12:47.902]                         if (!is.null(pattern)) {
[16:12:47.902]                           computeRestarts <- base::computeRestarts
[16:12:47.902]                           grepl <- base::grepl
[16:12:47.902]                           restarts <- computeRestarts(cond)
[16:12:47.902]                           for (restart in restarts) {
[16:12:47.902]                             name <- restart$name
[16:12:47.902]                             if (is.null(name)) 
[16:12:47.902]                               next
[16:12:47.902]                             if (!grepl(pattern, name)) 
[16:12:47.902]                               next
[16:12:47.902]                             invokeRestart(restart)
[16:12:47.902]                             muffled <- TRUE
[16:12:47.902]                             break
[16:12:47.902]                           }
[16:12:47.902]                         }
[16:12:47.902]                       }
[16:12:47.902]                       invisible(muffled)
[16:12:47.902]                     }
[16:12:47.902]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.902]                   }
[16:12:47.902]                 }
[16:12:47.902]             }
[16:12:47.902]         }))
[16:12:47.902]     }, error = function(ex) {
[16:12:47.902]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.902]                 ...future.rng), started = ...future.startTime, 
[16:12:47.902]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.902]             version = "1.8"), class = "FutureResult")
[16:12:47.902]     }, finally = {
[16:12:47.902]         if (!identical(...future.workdir, getwd())) 
[16:12:47.902]             setwd(...future.workdir)
[16:12:47.902]         {
[16:12:47.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.902]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.902]             }
[16:12:47.902]             base::options(...future.oldOptions)
[16:12:47.902]             if (.Platform$OS.type == "windows") {
[16:12:47.902]                 old_names <- names(...future.oldEnvVars)
[16:12:47.902]                 envs <- base::Sys.getenv()
[16:12:47.902]                 names <- names(envs)
[16:12:47.902]                 common <- intersect(names, old_names)
[16:12:47.902]                 added <- setdiff(names, old_names)
[16:12:47.902]                 removed <- setdiff(old_names, names)
[16:12:47.902]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.902]                   envs[common]]
[16:12:47.902]                 NAMES <- toupper(changed)
[16:12:47.902]                 args <- list()
[16:12:47.902]                 for (kk in seq_along(NAMES)) {
[16:12:47.902]                   name <- changed[[kk]]
[16:12:47.902]                   NAME <- NAMES[[kk]]
[16:12:47.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.902]                     next
[16:12:47.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.902]                 }
[16:12:47.902]                 NAMES <- toupper(added)
[16:12:47.902]                 for (kk in seq_along(NAMES)) {
[16:12:47.902]                   name <- added[[kk]]
[16:12:47.902]                   NAME <- NAMES[[kk]]
[16:12:47.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.902]                     next
[16:12:47.902]                   args[[name]] <- ""
[16:12:47.902]                 }
[16:12:47.902]                 NAMES <- toupper(removed)
[16:12:47.902]                 for (kk in seq_along(NAMES)) {
[16:12:47.902]                   name <- removed[[kk]]
[16:12:47.902]                   NAME <- NAMES[[kk]]
[16:12:47.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.902]                     next
[16:12:47.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.902]                 }
[16:12:47.902]                 if (length(args) > 0) 
[16:12:47.902]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.902]             }
[16:12:47.902]             else {
[16:12:47.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.902]             }
[16:12:47.902]             {
[16:12:47.902]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.902]                   0L) {
[16:12:47.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.902]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.902]                   base::options(opts)
[16:12:47.902]                 }
[16:12:47.902]                 {
[16:12:47.902]                   {
[16:12:47.902]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.902]                     NULL
[16:12:47.902]                   }
[16:12:47.902]                   options(future.plan = NULL)
[16:12:47.902]                   if (is.na(NA_character_)) 
[16:12:47.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.902]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.902]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.902]                     envir = parent.frame()) 
[16:12:47.902]                   {
[16:12:47.902]                     if (is.function(workers)) 
[16:12:47.902]                       workers <- workers()
[16:12:47.902]                     workers <- structure(as.integer(workers), 
[16:12:47.902]                       class = class(workers))
[16:12:47.902]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.902]                       workers >= 1)
[16:12:47.902]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.902]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.902]                     }
[16:12:47.902]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.902]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.902]                       envir = envir)
[16:12:47.902]                     if (!future$lazy) 
[16:12:47.902]                       future <- run(future)
[16:12:47.902]                     invisible(future)
[16:12:47.902]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.902]                 }
[16:12:47.902]             }
[16:12:47.902]         }
[16:12:47.902]     })
[16:12:47.902]     if (TRUE) {
[16:12:47.902]         base::sink(type = "output", split = FALSE)
[16:12:47.902]         if (TRUE) {
[16:12:47.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.902]         }
[16:12:47.902]         else {
[16:12:47.902]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.902]         }
[16:12:47.902]         base::close(...future.stdout)
[16:12:47.902]         ...future.stdout <- NULL
[16:12:47.902]     }
[16:12:47.902]     ...future.result$conditions <- ...future.conditions
[16:12:47.902]     ...future.result$finished <- base::Sys.time()
[16:12:47.902]     ...future.result
[16:12:47.902] }
[16:12:47.905] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[16:12:47.905] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:12:47.906] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:12:47.906] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[16:12:47.906] MultisessionFuture started
[16:12:47.906] - Launch lazy future ... done
[16:12:47.906] run() for ‘MultisessionFuture’ ... done
[16:12:47.907] result() for ClusterFuture ...
[16:12:47.907] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.907] - Validating connection of MultisessionFuture
[16:12:47.953] - received message: FutureResult
[16:12:47.954] - Received FutureResult
[16:12:47.954] - Erased future from FutureRegistry
[16:12:47.954] result() for ClusterFuture ...
[16:12:47.954] - result already collected: FutureResult
[16:12:47.954] result() for ClusterFuture ... done
[16:12:47.954] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:47.954] result() for ClusterFuture ... done
[16:12:47.955] result() for ClusterFuture ...
[16:12:47.955] - result already collected: FutureResult
[16:12:47.955] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:47.955] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:47.955] Searching for globals...
[16:12:47.958] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:12:47.958] Searching for globals ... DONE
[16:12:47.958] Resolving globals: TRUE
[16:12:47.958] Resolving any globals that are futures ...
[16:12:47.958] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[16:12:47.958] Resolving any globals that are futures ... DONE
[16:12:47.959] Resolving futures part of globals (recursively) ...
[16:12:47.959] resolve() on list ...
[16:12:47.959]  recursive: 99
[16:12:47.959]  length: 2
[16:12:47.959]  elements: ‘x’, ‘name’
[16:12:47.959]  length: 1 (resolved future 1)
[16:12:47.960]  length: 0 (resolved future 2)
[16:12:47.960] resolve() on list ... DONE
[16:12:47.960] - globals: [2] ‘x’, ‘name’
[16:12:47.960] Resolving futures part of globals (recursively) ... DONE
[16:12:47.960] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:47.960] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[16:12:47.961] - globals: [2] ‘x’, ‘name’
[16:12:47.961] 
[16:12:47.961] getGlobalsAndPackages() ... DONE
[16:12:47.961] run() for ‘Future’ ...
[16:12:47.961] - state: ‘created’
[16:12:47.961] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:47.976] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:47.976] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:47.976]   - Field: ‘node’
[16:12:47.976]   - Field: ‘label’
[16:12:47.977]   - Field: ‘local’
[16:12:47.977]   - Field: ‘owner’
[16:12:47.977]   - Field: ‘envir’
[16:12:47.977]   - Field: ‘workers’
[16:12:47.977]   - Field: ‘packages’
[16:12:47.977]   - Field: ‘gc’
[16:12:47.977]   - Field: ‘conditions’
[16:12:47.977]   - Field: ‘persistent’
[16:12:47.977]   - Field: ‘expr’
[16:12:47.977]   - Field: ‘uuid’
[16:12:47.978]   - Field: ‘seed’
[16:12:47.978]   - Field: ‘version’
[16:12:47.978]   - Field: ‘result’
[16:12:47.978]   - Field: ‘asynchronous’
[16:12:47.978]   - Field: ‘calls’
[16:12:47.978]   - Field: ‘globals’
[16:12:47.978]   - Field: ‘stdout’
[16:12:47.978]   - Field: ‘earlySignal’
[16:12:47.978]   - Field: ‘lazy’
[16:12:47.978]   - Field: ‘state’
[16:12:47.978] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:47.979] - Launch lazy future ...
[16:12:47.979] Packages needed by the future expression (n = 0): <none>
[16:12:47.979] Packages needed by future strategies (n = 0): <none>
[16:12:47.979] {
[16:12:47.979]     {
[16:12:47.979]         {
[16:12:47.979]             ...future.startTime <- base::Sys.time()
[16:12:47.979]             {
[16:12:47.979]                 {
[16:12:47.979]                   {
[16:12:47.979]                     {
[16:12:47.979]                       base::local({
[16:12:47.979]                         has_future <- base::requireNamespace("future", 
[16:12:47.979]                           quietly = TRUE)
[16:12:47.979]                         if (has_future) {
[16:12:47.979]                           ns <- base::getNamespace("future")
[16:12:47.979]                           version <- ns[[".package"]][["version"]]
[16:12:47.979]                           if (is.null(version)) 
[16:12:47.979]                             version <- utils::packageVersion("future")
[16:12:47.979]                         }
[16:12:47.979]                         else {
[16:12:47.979]                           version <- NULL
[16:12:47.979]                         }
[16:12:47.979]                         if (!has_future || version < "1.8.0") {
[16:12:47.979]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:47.979]                             "", base::R.version$version.string), 
[16:12:47.979]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:47.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:47.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:47.979]                               "release", "version")], collapse = " "), 
[16:12:47.979]                             hostname = base::Sys.info()[["nodename"]])
[16:12:47.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:47.979]                             info)
[16:12:47.979]                           info <- base::paste(info, collapse = "; ")
[16:12:47.979]                           if (!has_future) {
[16:12:47.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:47.979]                               info)
[16:12:47.979]                           }
[16:12:47.979]                           else {
[16:12:47.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:47.979]                               info, version)
[16:12:47.979]                           }
[16:12:47.979]                           base::stop(msg)
[16:12:47.979]                         }
[16:12:47.979]                       })
[16:12:47.979]                     }
[16:12:47.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:47.979]                     base::options(mc.cores = 1L)
[16:12:47.979]                   }
[16:12:47.979]                   options(future.plan = NULL)
[16:12:47.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:47.979]                 }
[16:12:47.979]                 ...future.workdir <- getwd()
[16:12:47.979]             }
[16:12:47.979]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:47.979]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:47.979]         }
[16:12:47.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:47.979]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:47.979]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:47.979]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:47.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:47.979]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:47.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:47.979]             base::names(...future.oldOptions))
[16:12:47.979]     }
[16:12:47.979]     if (FALSE) {
[16:12:47.979]     }
[16:12:47.979]     else {
[16:12:47.979]         if (TRUE) {
[16:12:47.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:47.979]                 open = "w")
[16:12:47.979]         }
[16:12:47.979]         else {
[16:12:47.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:47.979]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:47.979]         }
[16:12:47.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:47.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:47.979]             base::sink(type = "output", split = FALSE)
[16:12:47.979]             base::close(...future.stdout)
[16:12:47.979]         }, add = TRUE)
[16:12:47.979]     }
[16:12:47.979]     ...future.frame <- base::sys.nframe()
[16:12:47.979]     ...future.conditions <- base::list()
[16:12:47.979]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:47.979]     if (FALSE) {
[16:12:47.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:47.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:47.979]     }
[16:12:47.979]     ...future.result <- base::tryCatch({
[16:12:47.979]         base::withCallingHandlers({
[16:12:47.979]             ...future.value <- base::withVisible(base::local({
[16:12:47.979]                 ...future.makeSendCondition <- local({
[16:12:47.979]                   sendCondition <- NULL
[16:12:47.979]                   function(frame = 1L) {
[16:12:47.979]                     if (is.function(sendCondition)) 
[16:12:47.979]                       return(sendCondition)
[16:12:47.979]                     ns <- getNamespace("parallel")
[16:12:47.979]                     if (exists("sendData", mode = "function", 
[16:12:47.979]                       envir = ns)) {
[16:12:47.979]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:47.979]                         envir = ns)
[16:12:47.979]                       envir <- sys.frame(frame)
[16:12:47.979]                       master <- NULL
[16:12:47.979]                       while (!identical(envir, .GlobalEnv) && 
[16:12:47.979]                         !identical(envir, emptyenv())) {
[16:12:47.979]                         if (exists("master", mode = "list", envir = envir, 
[16:12:47.979]                           inherits = FALSE)) {
[16:12:47.979]                           master <- get("master", mode = "list", 
[16:12:47.979]                             envir = envir, inherits = FALSE)
[16:12:47.979]                           if (inherits(master, c("SOCKnode", 
[16:12:47.979]                             "SOCK0node"))) {
[16:12:47.979]                             sendCondition <<- function(cond) {
[16:12:47.979]                               data <- list(type = "VALUE", value = cond, 
[16:12:47.979]                                 success = TRUE)
[16:12:47.979]                               parallel_sendData(master, data)
[16:12:47.979]                             }
[16:12:47.979]                             return(sendCondition)
[16:12:47.979]                           }
[16:12:47.979]                         }
[16:12:47.979]                         frame <- frame + 1L
[16:12:47.979]                         envir <- sys.frame(frame)
[16:12:47.979]                       }
[16:12:47.979]                     }
[16:12:47.979]                     sendCondition <<- function(cond) NULL
[16:12:47.979]                   }
[16:12:47.979]                 })
[16:12:47.979]                 withCallingHandlers({
[16:12:47.979]                   {
[16:12:47.979]                     x[name] <- list(1)
[16:12:47.979]                     x
[16:12:47.979]                   }
[16:12:47.979]                 }, immediateCondition = function(cond) {
[16:12:47.979]                   sendCondition <- ...future.makeSendCondition()
[16:12:47.979]                   sendCondition(cond)
[16:12:47.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.979]                   {
[16:12:47.979]                     inherits <- base::inherits
[16:12:47.979]                     invokeRestart <- base::invokeRestart
[16:12:47.979]                     is.null <- base::is.null
[16:12:47.979]                     muffled <- FALSE
[16:12:47.979]                     if (inherits(cond, "message")) {
[16:12:47.979]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:47.979]                       if (muffled) 
[16:12:47.979]                         invokeRestart("muffleMessage")
[16:12:47.979]                     }
[16:12:47.979]                     else if (inherits(cond, "warning")) {
[16:12:47.979]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:47.979]                       if (muffled) 
[16:12:47.979]                         invokeRestart("muffleWarning")
[16:12:47.979]                     }
[16:12:47.979]                     else if (inherits(cond, "condition")) {
[16:12:47.979]                       if (!is.null(pattern)) {
[16:12:47.979]                         computeRestarts <- base::computeRestarts
[16:12:47.979]                         grepl <- base::grepl
[16:12:47.979]                         restarts <- computeRestarts(cond)
[16:12:47.979]                         for (restart in restarts) {
[16:12:47.979]                           name <- restart$name
[16:12:47.979]                           if (is.null(name)) 
[16:12:47.979]                             next
[16:12:47.979]                           if (!grepl(pattern, name)) 
[16:12:47.979]                             next
[16:12:47.979]                           invokeRestart(restart)
[16:12:47.979]                           muffled <- TRUE
[16:12:47.979]                           break
[16:12:47.979]                         }
[16:12:47.979]                       }
[16:12:47.979]                     }
[16:12:47.979]                     invisible(muffled)
[16:12:47.979]                   }
[16:12:47.979]                   muffleCondition(cond)
[16:12:47.979]                 })
[16:12:47.979]             }))
[16:12:47.979]             future::FutureResult(value = ...future.value$value, 
[16:12:47.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.979]                   ...future.rng), globalenv = if (FALSE) 
[16:12:47.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:47.979]                     ...future.globalenv.names))
[16:12:47.979]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:47.979]         }, condition = base::local({
[16:12:47.979]             c <- base::c
[16:12:47.979]             inherits <- base::inherits
[16:12:47.979]             invokeRestart <- base::invokeRestart
[16:12:47.979]             length <- base::length
[16:12:47.979]             list <- base::list
[16:12:47.979]             seq.int <- base::seq.int
[16:12:47.979]             signalCondition <- base::signalCondition
[16:12:47.979]             sys.calls <- base::sys.calls
[16:12:47.979]             `[[` <- base::`[[`
[16:12:47.979]             `+` <- base::`+`
[16:12:47.979]             `<<-` <- base::`<<-`
[16:12:47.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:47.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:47.979]                   3L)]
[16:12:47.979]             }
[16:12:47.979]             function(cond) {
[16:12:47.979]                 is_error <- inherits(cond, "error")
[16:12:47.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:47.979]                   NULL)
[16:12:47.979]                 if (is_error) {
[16:12:47.979]                   sessionInformation <- function() {
[16:12:47.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:47.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:47.979]                       search = base::search(), system = base::Sys.info())
[16:12:47.979]                   }
[16:12:47.979]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:47.979]                     cond$call), session = sessionInformation(), 
[16:12:47.979]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:47.979]                   signalCondition(cond)
[16:12:47.979]                 }
[16:12:47.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:47.979]                 "immediateCondition"))) {
[16:12:47.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:47.979]                   ...future.conditions[[length(...future.conditions) + 
[16:12:47.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:47.979]                   if (TRUE && !signal) {
[16:12:47.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.979]                     {
[16:12:47.979]                       inherits <- base::inherits
[16:12:47.979]                       invokeRestart <- base::invokeRestart
[16:12:47.979]                       is.null <- base::is.null
[16:12:47.979]                       muffled <- FALSE
[16:12:47.979]                       if (inherits(cond, "message")) {
[16:12:47.979]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.979]                         if (muffled) 
[16:12:47.979]                           invokeRestart("muffleMessage")
[16:12:47.979]                       }
[16:12:47.979]                       else if (inherits(cond, "warning")) {
[16:12:47.979]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.979]                         if (muffled) 
[16:12:47.979]                           invokeRestart("muffleWarning")
[16:12:47.979]                       }
[16:12:47.979]                       else if (inherits(cond, "condition")) {
[16:12:47.979]                         if (!is.null(pattern)) {
[16:12:47.979]                           computeRestarts <- base::computeRestarts
[16:12:47.979]                           grepl <- base::grepl
[16:12:47.979]                           restarts <- computeRestarts(cond)
[16:12:47.979]                           for (restart in restarts) {
[16:12:47.979]                             name <- restart$name
[16:12:47.979]                             if (is.null(name)) 
[16:12:47.979]                               next
[16:12:47.979]                             if (!grepl(pattern, name)) 
[16:12:47.979]                               next
[16:12:47.979]                             invokeRestart(restart)
[16:12:47.979]                             muffled <- TRUE
[16:12:47.979]                             break
[16:12:47.979]                           }
[16:12:47.979]                         }
[16:12:47.979]                       }
[16:12:47.979]                       invisible(muffled)
[16:12:47.979]                     }
[16:12:47.979]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.979]                   }
[16:12:47.979]                 }
[16:12:47.979]                 else {
[16:12:47.979]                   if (TRUE) {
[16:12:47.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:47.979]                     {
[16:12:47.979]                       inherits <- base::inherits
[16:12:47.979]                       invokeRestart <- base::invokeRestart
[16:12:47.979]                       is.null <- base::is.null
[16:12:47.979]                       muffled <- FALSE
[16:12:47.979]                       if (inherits(cond, "message")) {
[16:12:47.979]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:47.979]                         if (muffled) 
[16:12:47.979]                           invokeRestart("muffleMessage")
[16:12:47.979]                       }
[16:12:47.979]                       else if (inherits(cond, "warning")) {
[16:12:47.979]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:47.979]                         if (muffled) 
[16:12:47.979]                           invokeRestart("muffleWarning")
[16:12:47.979]                       }
[16:12:47.979]                       else if (inherits(cond, "condition")) {
[16:12:47.979]                         if (!is.null(pattern)) {
[16:12:47.979]                           computeRestarts <- base::computeRestarts
[16:12:47.979]                           grepl <- base::grepl
[16:12:47.979]                           restarts <- computeRestarts(cond)
[16:12:47.979]                           for (restart in restarts) {
[16:12:47.979]                             name <- restart$name
[16:12:47.979]                             if (is.null(name)) 
[16:12:47.979]                               next
[16:12:47.979]                             if (!grepl(pattern, name)) 
[16:12:47.979]                               next
[16:12:47.979]                             invokeRestart(restart)
[16:12:47.979]                             muffled <- TRUE
[16:12:47.979]                             break
[16:12:47.979]                           }
[16:12:47.979]                         }
[16:12:47.979]                       }
[16:12:47.979]                       invisible(muffled)
[16:12:47.979]                     }
[16:12:47.979]                     muffleCondition(cond, pattern = "^muffle")
[16:12:47.979]                   }
[16:12:47.979]                 }
[16:12:47.979]             }
[16:12:47.979]         }))
[16:12:47.979]     }, error = function(ex) {
[16:12:47.979]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:47.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:47.979]                 ...future.rng), started = ...future.startTime, 
[16:12:47.979]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:47.979]             version = "1.8"), class = "FutureResult")
[16:12:47.979]     }, finally = {
[16:12:47.979]         if (!identical(...future.workdir, getwd())) 
[16:12:47.979]             setwd(...future.workdir)
[16:12:47.979]         {
[16:12:47.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:47.979]                 ...future.oldOptions$nwarnings <- NULL
[16:12:47.979]             }
[16:12:47.979]             base::options(...future.oldOptions)
[16:12:47.979]             if (.Platform$OS.type == "windows") {
[16:12:47.979]                 old_names <- names(...future.oldEnvVars)
[16:12:47.979]                 envs <- base::Sys.getenv()
[16:12:47.979]                 names <- names(envs)
[16:12:47.979]                 common <- intersect(names, old_names)
[16:12:47.979]                 added <- setdiff(names, old_names)
[16:12:47.979]                 removed <- setdiff(old_names, names)
[16:12:47.979]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:47.979]                   envs[common]]
[16:12:47.979]                 NAMES <- toupper(changed)
[16:12:47.979]                 args <- list()
[16:12:47.979]                 for (kk in seq_along(NAMES)) {
[16:12:47.979]                   name <- changed[[kk]]
[16:12:47.979]                   NAME <- NAMES[[kk]]
[16:12:47.979]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.979]                     next
[16:12:47.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.979]                 }
[16:12:47.979]                 NAMES <- toupper(added)
[16:12:47.979]                 for (kk in seq_along(NAMES)) {
[16:12:47.979]                   name <- added[[kk]]
[16:12:47.979]                   NAME <- NAMES[[kk]]
[16:12:47.979]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.979]                     next
[16:12:47.979]                   args[[name]] <- ""
[16:12:47.979]                 }
[16:12:47.979]                 NAMES <- toupper(removed)
[16:12:47.979]                 for (kk in seq_along(NAMES)) {
[16:12:47.979]                   name <- removed[[kk]]
[16:12:47.979]                   NAME <- NAMES[[kk]]
[16:12:47.979]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:47.979]                     next
[16:12:47.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:47.979]                 }
[16:12:47.979]                 if (length(args) > 0) 
[16:12:47.979]                   base::do.call(base::Sys.setenv, args = args)
[16:12:47.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:47.979]             }
[16:12:47.979]             else {
[16:12:47.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:47.979]             }
[16:12:47.979]             {
[16:12:47.979]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:47.979]                   0L) {
[16:12:47.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:47.979]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:47.979]                   base::options(opts)
[16:12:47.979]                 }
[16:12:47.979]                 {
[16:12:47.979]                   {
[16:12:47.979]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:47.979]                     NULL
[16:12:47.979]                   }
[16:12:47.979]                   options(future.plan = NULL)
[16:12:47.979]                   if (is.na(NA_character_)) 
[16:12:47.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:47.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:47.979]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:47.979]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:47.979]                     envir = parent.frame()) 
[16:12:47.979]                   {
[16:12:47.979]                     if (is.function(workers)) 
[16:12:47.979]                       workers <- workers()
[16:12:47.979]                     workers <- structure(as.integer(workers), 
[16:12:47.979]                       class = class(workers))
[16:12:47.979]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:47.979]                       workers >= 1)
[16:12:47.979]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:47.979]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:47.979]                     }
[16:12:47.979]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:47.979]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:47.979]                       envir = envir)
[16:12:47.979]                     if (!future$lazy) 
[16:12:47.979]                       future <- run(future)
[16:12:47.979]                     invisible(future)
[16:12:47.979]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:47.979]                 }
[16:12:47.979]             }
[16:12:47.979]         }
[16:12:47.979]     })
[16:12:47.979]     if (TRUE) {
[16:12:47.979]         base::sink(type = "output", split = FALSE)
[16:12:47.979]         if (TRUE) {
[16:12:47.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:47.979]         }
[16:12:47.979]         else {
[16:12:47.979]             ...future.result["stdout"] <- base::list(NULL)
[16:12:47.979]         }
[16:12:47.979]         base::close(...future.stdout)
[16:12:47.979]         ...future.stdout <- NULL
[16:12:47.979]     }
[16:12:47.979]     ...future.result$conditions <- ...future.conditions
[16:12:47.979]     ...future.result$finished <- base::Sys.time()
[16:12:47.979]     ...future.result
[16:12:47.979] }
[16:12:47.982] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:12:47.985] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[16:12:47.986] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[16:12:47.986] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[16:12:47.986] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[16:12:47.986] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:12:47.987] MultisessionFuture started
[16:12:47.987] - Launch lazy future ... done
[16:12:47.987] run() for ‘MultisessionFuture’ ... done
[16:12:47.987] result() for ClusterFuture ...
[16:12:47.987] receiveMessageFromWorker() for ClusterFuture ...
[16:12:47.987] - Validating connection of MultisessionFuture
[16:12:48.033] - received message: FutureResult
[16:12:48.033] - Received FutureResult
[16:12:48.033] - Erased future from FutureRegistry
[16:12:48.033] result() for ClusterFuture ...
[16:12:48.033] - result already collected: FutureResult
[16:12:48.034] result() for ClusterFuture ... done
[16:12:48.034] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:48.034] result() for ClusterFuture ... done
[16:12:48.034] result() for ClusterFuture ...
[16:12:48.034] - result already collected: FutureResult
[16:12:48.034] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[16:12:48.035] plan(): Setting new future strategy stack:
[16:12:48.035] List of future strategies:
[16:12:48.035] 1. FutureStrategy:
[16:12:48.035]    - args: function (..., envir = parent.frame())
[16:12:48.035]    - tweaked: FALSE
[16:12:48.035]    - call: future::plan(oplan)
[16:12:48.036] plan(): nbrOfWorkers() = 1
> 
