
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:42:34.378] plan(): Setting new future strategy stack:
[17:42:34.379] List of future strategies:
[17:42:34.379] 1. sequential:
[17:42:34.379]    - args: function (..., envir = parent.frame())
[17:42:34.379]    - tweaked: FALSE
[17:42:34.379]    - call: future::plan("sequential")
[17:42:34.393] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** Globals w/ non-standard evaluation (NSE) ...")
*** Globals w/ non-standard evaluation (NSE) ...
> 
> data <- data.frame(x = 1:5, y = 1:5)
> v0 <- subset(data, x < 3)$y
> 
> for (strategy in supportedStrategies()) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("- Strategy: %s ...", strategy))
+   
+   plan(strategy)
+ 
+   ## Assert option is passed on to future
+   options(future.globals.onMissing = "error")
+   opt1 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt1, "error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   opt2 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt2, "ignore"))
+ 
+   options(future.globals.onMissing = "error")
+   res <- try({ v1 %<-% subset(data, x < 3)$y }, silent = TRUE)
+   stopifnot(inherits(res, "try-error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   v2 %<-% subset(data, x < 3)$y
+   stopifnot(identical(v2, v0))
+ 
+   ## Nested futures (requires option is passed on to future)
+   plan(list(sequential, strategy))
+   options(future.globals.onMissing = "ignore")
+   v3 %<-% {
+     a %<-% subset(data, x < 3)$y
+     a
+   } %lazy% TRUE
+   stopifnot(identical(v3, v0))
+ 
+   message(sprintf("- Strategy: %s ... DONE", strategy))
+ }
- Strategy: sequential ...
[17:42:34.426] plan(): Setting new future strategy stack:
[17:42:34.426] List of future strategies:
[17:42:34.426] 1. sequential:
[17:42:34.426]    - args: function (..., envir = parent.frame())
[17:42:34.426]    - tweaked: FALSE
[17:42:34.426]    - call: plan(strategy)
[17:42:34.437] plan(): nbrOfWorkers() = 1
[17:42:34.439] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:34.439] Searching for globals...
[17:42:34.443] - globals found: [1] ‘getOption’
[17:42:34.443] Searching for globals ... DONE
[17:42:34.443] Resolving globals: FALSE
[17:42:34.444] 
[17:42:34.444] 
[17:42:34.444] getGlobalsAndPackages() ... DONE
[17:42:34.445] run() for ‘Future’ ...
[17:42:34.445] - state: ‘created’
[17:42:34.445] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:34.446] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:34.446] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:34.446]   - Field: ‘label’
[17:42:34.446]   - Field: ‘local’
[17:42:34.446]   - Field: ‘owner’
[17:42:34.446]   - Field: ‘envir’
[17:42:34.446]   - Field: ‘packages’
[17:42:34.446]   - Field: ‘gc’
[17:42:34.446]   - Field: ‘conditions’
[17:42:34.446]   - Field: ‘expr’
[17:42:34.447]   - Field: ‘uuid’
[17:42:34.447]   - Field: ‘seed’
[17:42:34.447]   - Field: ‘version’
[17:42:34.447]   - Field: ‘result’
[17:42:34.447]   - Field: ‘asynchronous’
[17:42:34.447]   - Field: ‘calls’
[17:42:34.447]   - Field: ‘globals’
[17:42:34.447]   - Field: ‘stdout’
[17:42:34.447]   - Field: ‘earlySignal’
[17:42:34.447]   - Field: ‘lazy’
[17:42:34.448]   - Field: ‘state’
[17:42:34.448] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:34.448] - Launch lazy future ...
[17:42:34.449] Packages needed by the future expression (n = 0): <none>
[17:42:34.449] Packages needed by future strategies (n = 0): <none>
[17:42:34.450] {
[17:42:34.450]     {
[17:42:34.450]         {
[17:42:34.450]             ...future.startTime <- base::Sys.time()
[17:42:34.450]             {
[17:42:34.450]                 {
[17:42:34.450]                   {
[17:42:34.450]                     base::local({
[17:42:34.450]                       has_future <- base::requireNamespace("future", 
[17:42:34.450]                         quietly = TRUE)
[17:42:34.450]                       if (has_future) {
[17:42:34.450]                         ns <- base::getNamespace("future")
[17:42:34.450]                         version <- ns[[".package"]][["version"]]
[17:42:34.450]                         if (is.null(version)) 
[17:42:34.450]                           version <- utils::packageVersion("future")
[17:42:34.450]                       }
[17:42:34.450]                       else {
[17:42:34.450]                         version <- NULL
[17:42:34.450]                       }
[17:42:34.450]                       if (!has_future || version < "1.8.0") {
[17:42:34.450]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:34.450]                           "", base::R.version$version.string), 
[17:42:34.450]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:34.450]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:34.450]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:34.450]                             "release", "version")], collapse = " "), 
[17:42:34.450]                           hostname = base::Sys.info()[["nodename"]])
[17:42:34.450]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:34.450]                           info)
[17:42:34.450]                         info <- base::paste(info, collapse = "; ")
[17:42:34.450]                         if (!has_future) {
[17:42:34.450]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:34.450]                             info)
[17:42:34.450]                         }
[17:42:34.450]                         else {
[17:42:34.450]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:34.450]                             info, version)
[17:42:34.450]                         }
[17:42:34.450]                         base::stop(msg)
[17:42:34.450]                       }
[17:42:34.450]                     })
[17:42:34.450]                   }
[17:42:34.450]                   options(future.plan = NULL)
[17:42:34.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:34.450]                 }
[17:42:34.450]                 ...future.workdir <- getwd()
[17:42:34.450]             }
[17:42:34.450]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:34.450]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:34.450]         }
[17:42:34.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:34.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:34.450]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:34.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:34.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:34.450]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:34.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:34.450]             base::names(...future.oldOptions))
[17:42:34.450]     }
[17:42:34.450]     if (FALSE) {
[17:42:34.450]     }
[17:42:34.450]     else {
[17:42:34.450]         if (TRUE) {
[17:42:34.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:34.450]                 open = "w")
[17:42:34.450]         }
[17:42:34.450]         else {
[17:42:34.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:34.450]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:34.450]         }
[17:42:34.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:34.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:34.450]             base::sink(type = "output", split = FALSE)
[17:42:34.450]             base::close(...future.stdout)
[17:42:34.450]         }, add = TRUE)
[17:42:34.450]     }
[17:42:34.450]     ...future.frame <- base::sys.nframe()
[17:42:34.450]     ...future.conditions <- base::list()
[17:42:34.450]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:34.450]     if (FALSE) {
[17:42:34.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:34.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:34.450]     }
[17:42:34.450]     ...future.result <- base::tryCatch({
[17:42:34.450]         base::withCallingHandlers({
[17:42:34.450]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[17:42:34.450]             future::FutureResult(value = ...future.value$value, 
[17:42:34.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.450]                   ...future.rng), globalenv = if (FALSE) 
[17:42:34.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:34.450]                     ...future.globalenv.names))
[17:42:34.450]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:34.450]         }, condition = base::local({
[17:42:34.450]             c <- base::c
[17:42:34.450]             inherits <- base::inherits
[17:42:34.450]             invokeRestart <- base::invokeRestart
[17:42:34.450]             length <- base::length
[17:42:34.450]             list <- base::list
[17:42:34.450]             seq.int <- base::seq.int
[17:42:34.450]             signalCondition <- base::signalCondition
[17:42:34.450]             sys.calls <- base::sys.calls
[17:42:34.450]             `[[` <- base::`[[`
[17:42:34.450]             `+` <- base::`+`
[17:42:34.450]             `<<-` <- base::`<<-`
[17:42:34.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:34.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:34.450]                   3L)]
[17:42:34.450]             }
[17:42:34.450]             function(cond) {
[17:42:34.450]                 is_error <- inherits(cond, "error")
[17:42:34.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:34.450]                   NULL)
[17:42:34.450]                 if (is_error) {
[17:42:34.450]                   sessionInformation <- function() {
[17:42:34.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:34.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:34.450]                       search = base::search(), system = base::Sys.info())
[17:42:34.450]                   }
[17:42:34.450]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:34.450]                     cond$call), session = sessionInformation(), 
[17:42:34.450]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:34.450]                   signalCondition(cond)
[17:42:34.450]                 }
[17:42:34.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:34.450]                 "immediateCondition"))) {
[17:42:34.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:34.450]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:34.450]                   if (TRUE && !signal) {
[17:42:34.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.450]                     {
[17:42:34.450]                       inherits <- base::inherits
[17:42:34.450]                       invokeRestart <- base::invokeRestart
[17:42:34.450]                       is.null <- base::is.null
[17:42:34.450]                       muffled <- FALSE
[17:42:34.450]                       if (inherits(cond, "message")) {
[17:42:34.450]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.450]                         if (muffled) 
[17:42:34.450]                           invokeRestart("muffleMessage")
[17:42:34.450]                       }
[17:42:34.450]                       else if (inherits(cond, "warning")) {
[17:42:34.450]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.450]                         if (muffled) 
[17:42:34.450]                           invokeRestart("muffleWarning")
[17:42:34.450]                       }
[17:42:34.450]                       else if (inherits(cond, "condition")) {
[17:42:34.450]                         if (!is.null(pattern)) {
[17:42:34.450]                           computeRestarts <- base::computeRestarts
[17:42:34.450]                           grepl <- base::grepl
[17:42:34.450]                           restarts <- computeRestarts(cond)
[17:42:34.450]                           for (restart in restarts) {
[17:42:34.450]                             name <- restart$name
[17:42:34.450]                             if (is.null(name)) 
[17:42:34.450]                               next
[17:42:34.450]                             if (!grepl(pattern, name)) 
[17:42:34.450]                               next
[17:42:34.450]                             invokeRestart(restart)
[17:42:34.450]                             muffled <- TRUE
[17:42:34.450]                             break
[17:42:34.450]                           }
[17:42:34.450]                         }
[17:42:34.450]                       }
[17:42:34.450]                       invisible(muffled)
[17:42:34.450]                     }
[17:42:34.450]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.450]                   }
[17:42:34.450]                 }
[17:42:34.450]                 else {
[17:42:34.450]                   if (TRUE) {
[17:42:34.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.450]                     {
[17:42:34.450]                       inherits <- base::inherits
[17:42:34.450]                       invokeRestart <- base::invokeRestart
[17:42:34.450]                       is.null <- base::is.null
[17:42:34.450]                       muffled <- FALSE
[17:42:34.450]                       if (inherits(cond, "message")) {
[17:42:34.450]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.450]                         if (muffled) 
[17:42:34.450]                           invokeRestart("muffleMessage")
[17:42:34.450]                       }
[17:42:34.450]                       else if (inherits(cond, "warning")) {
[17:42:34.450]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.450]                         if (muffled) 
[17:42:34.450]                           invokeRestart("muffleWarning")
[17:42:34.450]                       }
[17:42:34.450]                       else if (inherits(cond, "condition")) {
[17:42:34.450]                         if (!is.null(pattern)) {
[17:42:34.450]                           computeRestarts <- base::computeRestarts
[17:42:34.450]                           grepl <- base::grepl
[17:42:34.450]                           restarts <- computeRestarts(cond)
[17:42:34.450]                           for (restart in restarts) {
[17:42:34.450]                             name <- restart$name
[17:42:34.450]                             if (is.null(name)) 
[17:42:34.450]                               next
[17:42:34.450]                             if (!grepl(pattern, name)) 
[17:42:34.450]                               next
[17:42:34.450]                             invokeRestart(restart)
[17:42:34.450]                             muffled <- TRUE
[17:42:34.450]                             break
[17:42:34.450]                           }
[17:42:34.450]                         }
[17:42:34.450]                       }
[17:42:34.450]                       invisible(muffled)
[17:42:34.450]                     }
[17:42:34.450]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.450]                   }
[17:42:34.450]                 }
[17:42:34.450]             }
[17:42:34.450]         }))
[17:42:34.450]     }, error = function(ex) {
[17:42:34.450]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:34.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.450]                 ...future.rng), started = ...future.startTime, 
[17:42:34.450]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:34.450]             version = "1.8"), class = "FutureResult")
[17:42:34.450]     }, finally = {
[17:42:34.450]         if (!identical(...future.workdir, getwd())) 
[17:42:34.450]             setwd(...future.workdir)
[17:42:34.450]         {
[17:42:34.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:34.450]                 ...future.oldOptions$nwarnings <- NULL
[17:42:34.450]             }
[17:42:34.450]             base::options(...future.oldOptions)
[17:42:34.450]             if (.Platform$OS.type == "windows") {
[17:42:34.450]                 old_names <- names(...future.oldEnvVars)
[17:42:34.450]                 envs <- base::Sys.getenv()
[17:42:34.450]                 names <- names(envs)
[17:42:34.450]                 common <- intersect(names, old_names)
[17:42:34.450]                 added <- setdiff(names, old_names)
[17:42:34.450]                 removed <- setdiff(old_names, names)
[17:42:34.450]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:34.450]                   envs[common]]
[17:42:34.450]                 NAMES <- toupper(changed)
[17:42:34.450]                 args <- list()
[17:42:34.450]                 for (kk in seq_along(NAMES)) {
[17:42:34.450]                   name <- changed[[kk]]
[17:42:34.450]                   NAME <- NAMES[[kk]]
[17:42:34.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.450]                     next
[17:42:34.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.450]                 }
[17:42:34.450]                 NAMES <- toupper(added)
[17:42:34.450]                 for (kk in seq_along(NAMES)) {
[17:42:34.450]                   name <- added[[kk]]
[17:42:34.450]                   NAME <- NAMES[[kk]]
[17:42:34.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.450]                     next
[17:42:34.450]                   args[[name]] <- ""
[17:42:34.450]                 }
[17:42:34.450]                 NAMES <- toupper(removed)
[17:42:34.450]                 for (kk in seq_along(NAMES)) {
[17:42:34.450]                   name <- removed[[kk]]
[17:42:34.450]                   NAME <- NAMES[[kk]]
[17:42:34.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.450]                     next
[17:42:34.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.450]                 }
[17:42:34.450]                 if (length(args) > 0) 
[17:42:34.450]                   base::do.call(base::Sys.setenv, args = args)
[17:42:34.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:34.450]             }
[17:42:34.450]             else {
[17:42:34.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:34.450]             }
[17:42:34.450]             {
[17:42:34.450]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:34.450]                   0L) {
[17:42:34.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:34.450]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:34.450]                   base::options(opts)
[17:42:34.450]                 }
[17:42:34.450]                 {
[17:42:34.450]                   {
[17:42:34.450]                     NULL
[17:42:34.450]                     RNGkind("Mersenne-Twister")
[17:42:34.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:34.450]                       inherits = FALSE)
[17:42:34.450]                   }
[17:42:34.450]                   options(future.plan = NULL)
[17:42:34.450]                   if (is.na(NA_character_)) 
[17:42:34.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:34.450]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:34.450]                   {
[17:42:34.450]                     future <- SequentialFuture(..., envir = envir)
[17:42:34.450]                     if (!future$lazy) 
[17:42:34.450]                       future <- run(future)
[17:42:34.450]                     invisible(future)
[17:42:34.450]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.450]                 }
[17:42:34.450]             }
[17:42:34.450]         }
[17:42:34.450]     })
[17:42:34.450]     if (TRUE) {
[17:42:34.450]         base::sink(type = "output", split = FALSE)
[17:42:34.450]         if (TRUE) {
[17:42:34.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:34.450]         }
[17:42:34.450]         else {
[17:42:34.450]             ...future.result["stdout"] <- base::list(NULL)
[17:42:34.450]         }
[17:42:34.450]         base::close(...future.stdout)
[17:42:34.450]         ...future.stdout <- NULL
[17:42:34.450]     }
[17:42:34.450]     ...future.result$conditions <- ...future.conditions
[17:42:34.450]     ...future.result$finished <- base::Sys.time()
[17:42:34.450]     ...future.result
[17:42:34.450] }
[17:42:34.452] plan(): Setting new future strategy stack:
[17:42:34.452] List of future strategies:
[17:42:34.452] 1. sequential:
[17:42:34.452]    - args: function (..., envir = parent.frame())
[17:42:34.452]    - tweaked: FALSE
[17:42:34.452]    - call: NULL
[17:42:34.452] plan(): nbrOfWorkers() = 1
[17:42:34.453] plan(): Setting new future strategy stack:
[17:42:34.453] List of future strategies:
[17:42:34.453] 1. sequential:
[17:42:34.453]    - args: function (..., envir = parent.frame())
[17:42:34.453]    - tweaked: FALSE
[17:42:34.453]    - call: plan(strategy)
[17:42:34.454] plan(): nbrOfWorkers() = 1
[17:42:34.454] SequentialFuture started (and completed)
[17:42:34.454] - Launch lazy future ... done
[17:42:34.454] run() for ‘SequentialFuture’ ... done
[17:42:34.455] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:34.455] Searching for globals...
[17:42:34.456] - globals found: [1] ‘getOption’
[17:42:34.456] Searching for globals ... DONE
[17:42:34.456] Resolving globals: FALSE
[17:42:34.457] 
[17:42:34.457] 
[17:42:34.457] getGlobalsAndPackages() ... DONE
[17:42:34.457] run() for ‘Future’ ...
[17:42:34.457] - state: ‘created’
[17:42:34.460] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:34.460] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:34.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:34.460]   - Field: ‘label’
[17:42:34.460]   - Field: ‘local’
[17:42:34.460]   - Field: ‘owner’
[17:42:34.460]   - Field: ‘envir’
[17:42:34.461]   - Field: ‘packages’
[17:42:34.461]   - Field: ‘gc’
[17:42:34.461]   - Field: ‘conditions’
[17:42:34.461]   - Field: ‘expr’
[17:42:34.461]   - Field: ‘uuid’
[17:42:34.461]   - Field: ‘seed’
[17:42:34.461]   - Field: ‘version’
[17:42:34.461]   - Field: ‘result’
[17:42:34.461]   - Field: ‘asynchronous’
[17:42:34.461]   - Field: ‘calls’
[17:42:34.461]   - Field: ‘globals’
[17:42:34.462]   - Field: ‘stdout’
[17:42:34.462]   - Field: ‘earlySignal’
[17:42:34.462]   - Field: ‘lazy’
[17:42:34.462]   - Field: ‘state’
[17:42:34.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:34.462] - Launch lazy future ...
[17:42:34.462] Packages needed by the future expression (n = 0): <none>
[17:42:34.462] Packages needed by future strategies (n = 0): <none>
[17:42:34.463] {
[17:42:34.463]     {
[17:42:34.463]         {
[17:42:34.463]             ...future.startTime <- base::Sys.time()
[17:42:34.463]             {
[17:42:34.463]                 {
[17:42:34.463]                   {
[17:42:34.463]                     base::local({
[17:42:34.463]                       has_future <- base::requireNamespace("future", 
[17:42:34.463]                         quietly = TRUE)
[17:42:34.463]                       if (has_future) {
[17:42:34.463]                         ns <- base::getNamespace("future")
[17:42:34.463]                         version <- ns[[".package"]][["version"]]
[17:42:34.463]                         if (is.null(version)) 
[17:42:34.463]                           version <- utils::packageVersion("future")
[17:42:34.463]                       }
[17:42:34.463]                       else {
[17:42:34.463]                         version <- NULL
[17:42:34.463]                       }
[17:42:34.463]                       if (!has_future || version < "1.8.0") {
[17:42:34.463]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:34.463]                           "", base::R.version$version.string), 
[17:42:34.463]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:34.463]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:34.463]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:34.463]                             "release", "version")], collapse = " "), 
[17:42:34.463]                           hostname = base::Sys.info()[["nodename"]])
[17:42:34.463]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:34.463]                           info)
[17:42:34.463]                         info <- base::paste(info, collapse = "; ")
[17:42:34.463]                         if (!has_future) {
[17:42:34.463]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:34.463]                             info)
[17:42:34.463]                         }
[17:42:34.463]                         else {
[17:42:34.463]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:34.463]                             info, version)
[17:42:34.463]                         }
[17:42:34.463]                         base::stop(msg)
[17:42:34.463]                       }
[17:42:34.463]                     })
[17:42:34.463]                   }
[17:42:34.463]                   options(future.plan = NULL)
[17:42:34.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:34.463]                 }
[17:42:34.463]                 ...future.workdir <- getwd()
[17:42:34.463]             }
[17:42:34.463]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:34.463]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:34.463]         }
[17:42:34.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:34.463]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:34.463]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:34.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:34.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:34.463]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:34.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:34.463]             base::names(...future.oldOptions))
[17:42:34.463]     }
[17:42:34.463]     if (FALSE) {
[17:42:34.463]     }
[17:42:34.463]     else {
[17:42:34.463]         if (TRUE) {
[17:42:34.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:34.463]                 open = "w")
[17:42:34.463]         }
[17:42:34.463]         else {
[17:42:34.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:34.463]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:34.463]         }
[17:42:34.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:34.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:34.463]             base::sink(type = "output", split = FALSE)
[17:42:34.463]             base::close(...future.stdout)
[17:42:34.463]         }, add = TRUE)
[17:42:34.463]     }
[17:42:34.463]     ...future.frame <- base::sys.nframe()
[17:42:34.463]     ...future.conditions <- base::list()
[17:42:34.463]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:34.463]     if (FALSE) {
[17:42:34.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:34.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:34.463]     }
[17:42:34.463]     ...future.result <- base::tryCatch({
[17:42:34.463]         base::withCallingHandlers({
[17:42:34.463]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[17:42:34.463]             future::FutureResult(value = ...future.value$value, 
[17:42:34.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.463]                   ...future.rng), globalenv = if (FALSE) 
[17:42:34.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:34.463]                     ...future.globalenv.names))
[17:42:34.463]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:34.463]         }, condition = base::local({
[17:42:34.463]             c <- base::c
[17:42:34.463]             inherits <- base::inherits
[17:42:34.463]             invokeRestart <- base::invokeRestart
[17:42:34.463]             length <- base::length
[17:42:34.463]             list <- base::list
[17:42:34.463]             seq.int <- base::seq.int
[17:42:34.463]             signalCondition <- base::signalCondition
[17:42:34.463]             sys.calls <- base::sys.calls
[17:42:34.463]             `[[` <- base::`[[`
[17:42:34.463]             `+` <- base::`+`
[17:42:34.463]             `<<-` <- base::`<<-`
[17:42:34.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:34.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:34.463]                   3L)]
[17:42:34.463]             }
[17:42:34.463]             function(cond) {
[17:42:34.463]                 is_error <- inherits(cond, "error")
[17:42:34.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:34.463]                   NULL)
[17:42:34.463]                 if (is_error) {
[17:42:34.463]                   sessionInformation <- function() {
[17:42:34.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:34.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:34.463]                       search = base::search(), system = base::Sys.info())
[17:42:34.463]                   }
[17:42:34.463]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:34.463]                     cond$call), session = sessionInformation(), 
[17:42:34.463]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:34.463]                   signalCondition(cond)
[17:42:34.463]                 }
[17:42:34.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:34.463]                 "immediateCondition"))) {
[17:42:34.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:34.463]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:34.463]                   if (TRUE && !signal) {
[17:42:34.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.463]                     {
[17:42:34.463]                       inherits <- base::inherits
[17:42:34.463]                       invokeRestart <- base::invokeRestart
[17:42:34.463]                       is.null <- base::is.null
[17:42:34.463]                       muffled <- FALSE
[17:42:34.463]                       if (inherits(cond, "message")) {
[17:42:34.463]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.463]                         if (muffled) 
[17:42:34.463]                           invokeRestart("muffleMessage")
[17:42:34.463]                       }
[17:42:34.463]                       else if (inherits(cond, "warning")) {
[17:42:34.463]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.463]                         if (muffled) 
[17:42:34.463]                           invokeRestart("muffleWarning")
[17:42:34.463]                       }
[17:42:34.463]                       else if (inherits(cond, "condition")) {
[17:42:34.463]                         if (!is.null(pattern)) {
[17:42:34.463]                           computeRestarts <- base::computeRestarts
[17:42:34.463]                           grepl <- base::grepl
[17:42:34.463]                           restarts <- computeRestarts(cond)
[17:42:34.463]                           for (restart in restarts) {
[17:42:34.463]                             name <- restart$name
[17:42:34.463]                             if (is.null(name)) 
[17:42:34.463]                               next
[17:42:34.463]                             if (!grepl(pattern, name)) 
[17:42:34.463]                               next
[17:42:34.463]                             invokeRestart(restart)
[17:42:34.463]                             muffled <- TRUE
[17:42:34.463]                             break
[17:42:34.463]                           }
[17:42:34.463]                         }
[17:42:34.463]                       }
[17:42:34.463]                       invisible(muffled)
[17:42:34.463]                     }
[17:42:34.463]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.463]                   }
[17:42:34.463]                 }
[17:42:34.463]                 else {
[17:42:34.463]                   if (TRUE) {
[17:42:34.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.463]                     {
[17:42:34.463]                       inherits <- base::inherits
[17:42:34.463]                       invokeRestart <- base::invokeRestart
[17:42:34.463]                       is.null <- base::is.null
[17:42:34.463]                       muffled <- FALSE
[17:42:34.463]                       if (inherits(cond, "message")) {
[17:42:34.463]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.463]                         if (muffled) 
[17:42:34.463]                           invokeRestart("muffleMessage")
[17:42:34.463]                       }
[17:42:34.463]                       else if (inherits(cond, "warning")) {
[17:42:34.463]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.463]                         if (muffled) 
[17:42:34.463]                           invokeRestart("muffleWarning")
[17:42:34.463]                       }
[17:42:34.463]                       else if (inherits(cond, "condition")) {
[17:42:34.463]                         if (!is.null(pattern)) {
[17:42:34.463]                           computeRestarts <- base::computeRestarts
[17:42:34.463]                           grepl <- base::grepl
[17:42:34.463]                           restarts <- computeRestarts(cond)
[17:42:34.463]                           for (restart in restarts) {
[17:42:34.463]                             name <- restart$name
[17:42:34.463]                             if (is.null(name)) 
[17:42:34.463]                               next
[17:42:34.463]                             if (!grepl(pattern, name)) 
[17:42:34.463]                               next
[17:42:34.463]                             invokeRestart(restart)
[17:42:34.463]                             muffled <- TRUE
[17:42:34.463]                             break
[17:42:34.463]                           }
[17:42:34.463]                         }
[17:42:34.463]                       }
[17:42:34.463]                       invisible(muffled)
[17:42:34.463]                     }
[17:42:34.463]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.463]                   }
[17:42:34.463]                 }
[17:42:34.463]             }
[17:42:34.463]         }))
[17:42:34.463]     }, error = function(ex) {
[17:42:34.463]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:34.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.463]                 ...future.rng), started = ...future.startTime, 
[17:42:34.463]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:34.463]             version = "1.8"), class = "FutureResult")
[17:42:34.463]     }, finally = {
[17:42:34.463]         if (!identical(...future.workdir, getwd())) 
[17:42:34.463]             setwd(...future.workdir)
[17:42:34.463]         {
[17:42:34.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:34.463]                 ...future.oldOptions$nwarnings <- NULL
[17:42:34.463]             }
[17:42:34.463]             base::options(...future.oldOptions)
[17:42:34.463]             if (.Platform$OS.type == "windows") {
[17:42:34.463]                 old_names <- names(...future.oldEnvVars)
[17:42:34.463]                 envs <- base::Sys.getenv()
[17:42:34.463]                 names <- names(envs)
[17:42:34.463]                 common <- intersect(names, old_names)
[17:42:34.463]                 added <- setdiff(names, old_names)
[17:42:34.463]                 removed <- setdiff(old_names, names)
[17:42:34.463]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:34.463]                   envs[common]]
[17:42:34.463]                 NAMES <- toupper(changed)
[17:42:34.463]                 args <- list()
[17:42:34.463]                 for (kk in seq_along(NAMES)) {
[17:42:34.463]                   name <- changed[[kk]]
[17:42:34.463]                   NAME <- NAMES[[kk]]
[17:42:34.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.463]                     next
[17:42:34.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.463]                 }
[17:42:34.463]                 NAMES <- toupper(added)
[17:42:34.463]                 for (kk in seq_along(NAMES)) {
[17:42:34.463]                   name <- added[[kk]]
[17:42:34.463]                   NAME <- NAMES[[kk]]
[17:42:34.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.463]                     next
[17:42:34.463]                   args[[name]] <- ""
[17:42:34.463]                 }
[17:42:34.463]                 NAMES <- toupper(removed)
[17:42:34.463]                 for (kk in seq_along(NAMES)) {
[17:42:34.463]                   name <- removed[[kk]]
[17:42:34.463]                   NAME <- NAMES[[kk]]
[17:42:34.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.463]                     next
[17:42:34.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.463]                 }
[17:42:34.463]                 if (length(args) > 0) 
[17:42:34.463]                   base::do.call(base::Sys.setenv, args = args)
[17:42:34.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:34.463]             }
[17:42:34.463]             else {
[17:42:34.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:34.463]             }
[17:42:34.463]             {
[17:42:34.463]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:34.463]                   0L) {
[17:42:34.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:34.463]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:34.463]                   base::options(opts)
[17:42:34.463]                 }
[17:42:34.463]                 {
[17:42:34.463]                   {
[17:42:34.463]                     NULL
[17:42:34.463]                     RNGkind("Mersenne-Twister")
[17:42:34.463]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:34.463]                       inherits = FALSE)
[17:42:34.463]                   }
[17:42:34.463]                   options(future.plan = NULL)
[17:42:34.463]                   if (is.na(NA_character_)) 
[17:42:34.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:34.463]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:34.463]                   {
[17:42:34.463]                     future <- SequentialFuture(..., envir = envir)
[17:42:34.463]                     if (!future$lazy) 
[17:42:34.463]                       future <- run(future)
[17:42:34.463]                     invisible(future)
[17:42:34.463]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.463]                 }
[17:42:34.463]             }
[17:42:34.463]         }
[17:42:34.463]     })
[17:42:34.463]     if (TRUE) {
[17:42:34.463]         base::sink(type = "output", split = FALSE)
[17:42:34.463]         if (TRUE) {
[17:42:34.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:34.463]         }
[17:42:34.463]         else {
[17:42:34.463]             ...future.result["stdout"] <- base::list(NULL)
[17:42:34.463]         }
[17:42:34.463]         base::close(...future.stdout)
[17:42:34.463]         ...future.stdout <- NULL
[17:42:34.463]     }
[17:42:34.463]     ...future.result$conditions <- ...future.conditions
[17:42:34.463]     ...future.result$finished <- base::Sys.time()
[17:42:34.463]     ...future.result
[17:42:34.463] }
[17:42:34.464] plan(): Setting new future strategy stack:
[17:42:34.465] List of future strategies:
[17:42:34.465] 1. sequential:
[17:42:34.465]    - args: function (..., envir = parent.frame())
[17:42:34.465]    - tweaked: FALSE
[17:42:34.465]    - call: NULL
[17:42:34.465] plan(): nbrOfWorkers() = 1
[17:42:34.466] plan(): Setting new future strategy stack:
[17:42:34.466] List of future strategies:
[17:42:34.466] 1. sequential:
[17:42:34.466]    - args: function (..., envir = parent.frame())
[17:42:34.466]    - tweaked: FALSE
[17:42:34.466]    - call: plan(strategy)
[17:42:34.466] plan(): nbrOfWorkers() = 1
[17:42:34.466] SequentialFuture started (and completed)
[17:42:34.466] - Launch lazy future ... done
[17:42:34.467] run() for ‘SequentialFuture’ ... done
[17:42:34.467] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:34.467] Searching for globals...
[17:42:34.469] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:34.469] Searching for globals...
[17:42:34.470] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[17:42:34.470] Searching for globals ... DONE
[17:42:34.470] Resolving globals: FALSE
[17:42:34.471] The total size of the 1 globals is 160 bytes (160 bytes)
[17:42:34.472] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[17:42:34.472] - globals: [1] ‘data’
[17:42:34.472] 
[17:42:34.472] getGlobalsAndPackages() ... DONE
[17:42:34.472] run() for ‘Future’ ...
[17:42:34.472] - state: ‘created’
[17:42:34.472] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:34.473] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:34.473] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:34.473]   - Field: ‘label’
[17:42:34.473]   - Field: ‘local’
[17:42:34.473]   - Field: ‘owner’
[17:42:34.473]   - Field: ‘envir’
[17:42:34.473]   - Field: ‘packages’
[17:42:34.473]   - Field: ‘gc’
[17:42:34.473]   - Field: ‘conditions’
[17:42:34.474]   - Field: ‘expr’
[17:42:34.474]   - Field: ‘uuid’
[17:42:34.474]   - Field: ‘seed’
[17:42:34.474]   - Field: ‘version’
[17:42:34.474]   - Field: ‘result’
[17:42:34.474]   - Field: ‘asynchronous’
[17:42:34.474]   - Field: ‘calls’
[17:42:34.474]   - Field: ‘globals’
[17:42:34.474]   - Field: ‘stdout’
[17:42:34.474]   - Field: ‘earlySignal’
[17:42:34.475]   - Field: ‘lazy’
[17:42:34.475]   - Field: ‘state’
[17:42:34.475] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:34.475] - Launch lazy future ...
[17:42:34.475] Packages needed by the future expression (n = 0): <none>
[17:42:34.475] Packages needed by future strategies (n = 0): <none>
[17:42:34.476] {
[17:42:34.476]     {
[17:42:34.476]         {
[17:42:34.476]             ...future.startTime <- base::Sys.time()
[17:42:34.476]             {
[17:42:34.476]                 {
[17:42:34.476]                   {
[17:42:34.476]                     base::local({
[17:42:34.476]                       has_future <- base::requireNamespace("future", 
[17:42:34.476]                         quietly = TRUE)
[17:42:34.476]                       if (has_future) {
[17:42:34.476]                         ns <- base::getNamespace("future")
[17:42:34.476]                         version <- ns[[".package"]][["version"]]
[17:42:34.476]                         if (is.null(version)) 
[17:42:34.476]                           version <- utils::packageVersion("future")
[17:42:34.476]                       }
[17:42:34.476]                       else {
[17:42:34.476]                         version <- NULL
[17:42:34.476]                       }
[17:42:34.476]                       if (!has_future || version < "1.8.0") {
[17:42:34.476]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:34.476]                           "", base::R.version$version.string), 
[17:42:34.476]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:34.476]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:34.476]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:34.476]                             "release", "version")], collapse = " "), 
[17:42:34.476]                           hostname = base::Sys.info()[["nodename"]])
[17:42:34.476]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:34.476]                           info)
[17:42:34.476]                         info <- base::paste(info, collapse = "; ")
[17:42:34.476]                         if (!has_future) {
[17:42:34.476]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:34.476]                             info)
[17:42:34.476]                         }
[17:42:34.476]                         else {
[17:42:34.476]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:34.476]                             info, version)
[17:42:34.476]                         }
[17:42:34.476]                         base::stop(msg)
[17:42:34.476]                       }
[17:42:34.476]                     })
[17:42:34.476]                   }
[17:42:34.476]                   options(future.plan = NULL)
[17:42:34.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:34.476]                 }
[17:42:34.476]                 ...future.workdir <- getwd()
[17:42:34.476]             }
[17:42:34.476]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:34.476]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:34.476]         }
[17:42:34.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:34.476]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:34.476]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:34.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:34.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:34.476]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:34.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:34.476]             base::names(...future.oldOptions))
[17:42:34.476]     }
[17:42:34.476]     if (FALSE) {
[17:42:34.476]     }
[17:42:34.476]     else {
[17:42:34.476]         if (TRUE) {
[17:42:34.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:34.476]                 open = "w")
[17:42:34.476]         }
[17:42:34.476]         else {
[17:42:34.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:34.476]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:34.476]         }
[17:42:34.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:34.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:34.476]             base::sink(type = "output", split = FALSE)
[17:42:34.476]             base::close(...future.stdout)
[17:42:34.476]         }, add = TRUE)
[17:42:34.476]     }
[17:42:34.476]     ...future.frame <- base::sys.nframe()
[17:42:34.476]     ...future.conditions <- base::list()
[17:42:34.476]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:34.476]     if (FALSE) {
[17:42:34.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:34.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:34.476]     }
[17:42:34.476]     ...future.result <- base::tryCatch({
[17:42:34.476]         base::withCallingHandlers({
[17:42:34.476]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:42:34.476]                 x < 3)$y))
[17:42:34.476]             future::FutureResult(value = ...future.value$value, 
[17:42:34.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.476]                   ...future.rng), globalenv = if (FALSE) 
[17:42:34.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:34.476]                     ...future.globalenv.names))
[17:42:34.476]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:34.476]         }, condition = base::local({
[17:42:34.476]             c <- base::c
[17:42:34.476]             inherits <- base::inherits
[17:42:34.476]             invokeRestart <- base::invokeRestart
[17:42:34.476]             length <- base::length
[17:42:34.476]             list <- base::list
[17:42:34.476]             seq.int <- base::seq.int
[17:42:34.476]             signalCondition <- base::signalCondition
[17:42:34.476]             sys.calls <- base::sys.calls
[17:42:34.476]             `[[` <- base::`[[`
[17:42:34.476]             `+` <- base::`+`
[17:42:34.476]             `<<-` <- base::`<<-`
[17:42:34.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:34.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:34.476]                   3L)]
[17:42:34.476]             }
[17:42:34.476]             function(cond) {
[17:42:34.476]                 is_error <- inherits(cond, "error")
[17:42:34.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:34.476]                   NULL)
[17:42:34.476]                 if (is_error) {
[17:42:34.476]                   sessionInformation <- function() {
[17:42:34.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:34.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:34.476]                       search = base::search(), system = base::Sys.info())
[17:42:34.476]                   }
[17:42:34.476]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:34.476]                     cond$call), session = sessionInformation(), 
[17:42:34.476]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:34.476]                   signalCondition(cond)
[17:42:34.476]                 }
[17:42:34.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:34.476]                 "immediateCondition"))) {
[17:42:34.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:34.476]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:34.476]                   if (TRUE && !signal) {
[17:42:34.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.476]                     {
[17:42:34.476]                       inherits <- base::inherits
[17:42:34.476]                       invokeRestart <- base::invokeRestart
[17:42:34.476]                       is.null <- base::is.null
[17:42:34.476]                       muffled <- FALSE
[17:42:34.476]                       if (inherits(cond, "message")) {
[17:42:34.476]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.476]                         if (muffled) 
[17:42:34.476]                           invokeRestart("muffleMessage")
[17:42:34.476]                       }
[17:42:34.476]                       else if (inherits(cond, "warning")) {
[17:42:34.476]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.476]                         if (muffled) 
[17:42:34.476]                           invokeRestart("muffleWarning")
[17:42:34.476]                       }
[17:42:34.476]                       else if (inherits(cond, "condition")) {
[17:42:34.476]                         if (!is.null(pattern)) {
[17:42:34.476]                           computeRestarts <- base::computeRestarts
[17:42:34.476]                           grepl <- base::grepl
[17:42:34.476]                           restarts <- computeRestarts(cond)
[17:42:34.476]                           for (restart in restarts) {
[17:42:34.476]                             name <- restart$name
[17:42:34.476]                             if (is.null(name)) 
[17:42:34.476]                               next
[17:42:34.476]                             if (!grepl(pattern, name)) 
[17:42:34.476]                               next
[17:42:34.476]                             invokeRestart(restart)
[17:42:34.476]                             muffled <- TRUE
[17:42:34.476]                             break
[17:42:34.476]                           }
[17:42:34.476]                         }
[17:42:34.476]                       }
[17:42:34.476]                       invisible(muffled)
[17:42:34.476]                     }
[17:42:34.476]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.476]                   }
[17:42:34.476]                 }
[17:42:34.476]                 else {
[17:42:34.476]                   if (TRUE) {
[17:42:34.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.476]                     {
[17:42:34.476]                       inherits <- base::inherits
[17:42:34.476]                       invokeRestart <- base::invokeRestart
[17:42:34.476]                       is.null <- base::is.null
[17:42:34.476]                       muffled <- FALSE
[17:42:34.476]                       if (inherits(cond, "message")) {
[17:42:34.476]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.476]                         if (muffled) 
[17:42:34.476]                           invokeRestart("muffleMessage")
[17:42:34.476]                       }
[17:42:34.476]                       else if (inherits(cond, "warning")) {
[17:42:34.476]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.476]                         if (muffled) 
[17:42:34.476]                           invokeRestart("muffleWarning")
[17:42:34.476]                       }
[17:42:34.476]                       else if (inherits(cond, "condition")) {
[17:42:34.476]                         if (!is.null(pattern)) {
[17:42:34.476]                           computeRestarts <- base::computeRestarts
[17:42:34.476]                           grepl <- base::grepl
[17:42:34.476]                           restarts <- computeRestarts(cond)
[17:42:34.476]                           for (restart in restarts) {
[17:42:34.476]                             name <- restart$name
[17:42:34.476]                             if (is.null(name)) 
[17:42:34.476]                               next
[17:42:34.476]                             if (!grepl(pattern, name)) 
[17:42:34.476]                               next
[17:42:34.476]                             invokeRestart(restart)
[17:42:34.476]                             muffled <- TRUE
[17:42:34.476]                             break
[17:42:34.476]                           }
[17:42:34.476]                         }
[17:42:34.476]                       }
[17:42:34.476]                       invisible(muffled)
[17:42:34.476]                     }
[17:42:34.476]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.476]                   }
[17:42:34.476]                 }
[17:42:34.476]             }
[17:42:34.476]         }))
[17:42:34.476]     }, error = function(ex) {
[17:42:34.476]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:34.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.476]                 ...future.rng), started = ...future.startTime, 
[17:42:34.476]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:34.476]             version = "1.8"), class = "FutureResult")
[17:42:34.476]     }, finally = {
[17:42:34.476]         if (!identical(...future.workdir, getwd())) 
[17:42:34.476]             setwd(...future.workdir)
[17:42:34.476]         {
[17:42:34.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:34.476]                 ...future.oldOptions$nwarnings <- NULL
[17:42:34.476]             }
[17:42:34.476]             base::options(...future.oldOptions)
[17:42:34.476]             if (.Platform$OS.type == "windows") {
[17:42:34.476]                 old_names <- names(...future.oldEnvVars)
[17:42:34.476]                 envs <- base::Sys.getenv()
[17:42:34.476]                 names <- names(envs)
[17:42:34.476]                 common <- intersect(names, old_names)
[17:42:34.476]                 added <- setdiff(names, old_names)
[17:42:34.476]                 removed <- setdiff(old_names, names)
[17:42:34.476]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:34.476]                   envs[common]]
[17:42:34.476]                 NAMES <- toupper(changed)
[17:42:34.476]                 args <- list()
[17:42:34.476]                 for (kk in seq_along(NAMES)) {
[17:42:34.476]                   name <- changed[[kk]]
[17:42:34.476]                   NAME <- NAMES[[kk]]
[17:42:34.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.476]                     next
[17:42:34.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.476]                 }
[17:42:34.476]                 NAMES <- toupper(added)
[17:42:34.476]                 for (kk in seq_along(NAMES)) {
[17:42:34.476]                   name <- added[[kk]]
[17:42:34.476]                   NAME <- NAMES[[kk]]
[17:42:34.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.476]                     next
[17:42:34.476]                   args[[name]] <- ""
[17:42:34.476]                 }
[17:42:34.476]                 NAMES <- toupper(removed)
[17:42:34.476]                 for (kk in seq_along(NAMES)) {
[17:42:34.476]                   name <- removed[[kk]]
[17:42:34.476]                   NAME <- NAMES[[kk]]
[17:42:34.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.476]                     next
[17:42:34.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.476]                 }
[17:42:34.476]                 if (length(args) > 0) 
[17:42:34.476]                   base::do.call(base::Sys.setenv, args = args)
[17:42:34.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:34.476]             }
[17:42:34.476]             else {
[17:42:34.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:34.476]             }
[17:42:34.476]             {
[17:42:34.476]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:34.476]                   0L) {
[17:42:34.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:34.476]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:34.476]                   base::options(opts)
[17:42:34.476]                 }
[17:42:34.476]                 {
[17:42:34.476]                   {
[17:42:34.476]                     NULL
[17:42:34.476]                     RNGkind("Mersenne-Twister")
[17:42:34.476]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:34.476]                       inherits = FALSE)
[17:42:34.476]                   }
[17:42:34.476]                   options(future.plan = NULL)
[17:42:34.476]                   if (is.na(NA_character_)) 
[17:42:34.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:34.476]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:34.476]                   {
[17:42:34.476]                     future <- SequentialFuture(..., envir = envir)
[17:42:34.476]                     if (!future$lazy) 
[17:42:34.476]                       future <- run(future)
[17:42:34.476]                     invisible(future)
[17:42:34.476]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.476]                 }
[17:42:34.476]             }
[17:42:34.476]         }
[17:42:34.476]     })
[17:42:34.476]     if (TRUE) {
[17:42:34.476]         base::sink(type = "output", split = FALSE)
[17:42:34.476]         if (TRUE) {
[17:42:34.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:34.476]         }
[17:42:34.476]         else {
[17:42:34.476]             ...future.result["stdout"] <- base::list(NULL)
[17:42:34.476]         }
[17:42:34.476]         base::close(...future.stdout)
[17:42:34.476]         ...future.stdout <- NULL
[17:42:34.476]     }
[17:42:34.476]     ...future.result$conditions <- ...future.conditions
[17:42:34.476]     ...future.result$finished <- base::Sys.time()
[17:42:34.476]     ...future.result
[17:42:34.476] }
[17:42:34.477] assign_globals() ...
[17:42:34.477] List of 1
[17:42:34.477]  $ data:'data.frame':	5 obs. of  2 variables:
[17:42:34.477]   ..$ x: int [1:5] 1 2 3 4 5
[17:42:34.477]   ..$ y: int [1:5] 1 2 3 4 5
[17:42:34.477]  - attr(*, "where")=List of 1
[17:42:34.477]   ..$ data:<environment: R_EmptyEnv> 
[17:42:34.477]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:34.477]  - attr(*, "resolved")= logi FALSE
[17:42:34.477]  - attr(*, "total_size")= num 160
[17:42:34.477]  - attr(*, "already-done")= logi TRUE
[17:42:34.483] - copied ‘data’ to environment
[17:42:34.483] assign_globals() ... done
[17:42:34.484] plan(): Setting new future strategy stack:
[17:42:34.484] List of future strategies:
[17:42:34.484] 1. sequential:
[17:42:34.484]    - args: function (..., envir = parent.frame())
[17:42:34.484]    - tweaked: FALSE
[17:42:34.484]    - call: NULL
[17:42:34.484] plan(): nbrOfWorkers() = 1
[17:42:34.485] plan(): Setting new future strategy stack:
[17:42:34.485] List of future strategies:
[17:42:34.485] 1. sequential:
[17:42:34.485]    - args: function (..., envir = parent.frame())
[17:42:34.485]    - tweaked: FALSE
[17:42:34.485]    - call: plan(strategy)
[17:42:34.486] plan(): nbrOfWorkers() = 1
[17:42:34.486] SequentialFuture started (and completed)
[17:42:34.486] - Launch lazy future ... done
[17:42:34.486] run() for ‘SequentialFuture’ ... done
[17:42:34.486] plan(): Setting new future strategy stack:
[17:42:34.486] List of future strategies:
[17:42:34.486] 1. sequential:
[17:42:34.486]    - args: function (..., envir = parent.frame())
[17:42:34.486]    - tweaked: FALSE
[17:42:34.486]    - call: plan(list(sequential, strategy))
[17:42:34.486] 2. sequential:
[17:42:34.486]    - args: function (..., envir = parent.frame())
[17:42:34.486]    - tweaked: FALSE
[17:42:34.486]    - call: plan(list(sequential, strategy))
[17:42:34.487] plan(): nbrOfWorkers() = 1
[17:42:34.487] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:34.487] Searching for globals...
[17:42:34.495] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[17:42:34.495] Searching for globals ... DONE
[17:42:34.495] Resolving globals: FALSE
[17:42:34.495] The total size of the 1 globals is 160 bytes (160 bytes)
[17:42:34.496] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[17:42:34.496] - globals: [1] ‘data’
[17:42:34.496] - packages: [1] ‘future’
[17:42:34.496] getGlobalsAndPackages() ... DONE
[17:42:34.497] run() for ‘Future’ ...
[17:42:34.497] - state: ‘created’
[17:42:34.497] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:34.497] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:34.497] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:34.497]   - Field: ‘label’
[17:42:34.497]   - Field: ‘local’
[17:42:34.497]   - Field: ‘owner’
[17:42:34.498]   - Field: ‘envir’
[17:42:34.498]   - Field: ‘packages’
[17:42:34.498]   - Field: ‘gc’
[17:42:34.498]   - Field: ‘conditions’
[17:42:34.498]   - Field: ‘expr’
[17:42:34.498]   - Field: ‘uuid’
[17:42:34.498]   - Field: ‘seed’
[17:42:34.498]   - Field: ‘version’
[17:42:34.498]   - Field: ‘result’
[17:42:34.498]   - Field: ‘asynchronous’
[17:42:34.498]   - Field: ‘calls’
[17:42:34.499]   - Field: ‘globals’
[17:42:34.499]   - Field: ‘stdout’
[17:42:34.499]   - Field: ‘earlySignal’
[17:42:34.499]   - Field: ‘lazy’
[17:42:34.499]   - Field: ‘state’
[17:42:34.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:34.499] - Launch lazy future ...
[17:42:34.499] Packages needed by the future expression (n = 1): ‘future’
[17:42:34.499] Packages needed by future strategies (n = 1): ‘future’
[17:42:34.500] {
[17:42:34.500]     {
[17:42:34.500]         {
[17:42:34.500]             ...future.startTime <- base::Sys.time()
[17:42:34.500]             {
[17:42:34.500]                 {
[17:42:34.500]                   {
[17:42:34.500]                     {
[17:42:34.500]                       base::local({
[17:42:34.500]                         has_future <- base::requireNamespace("future", 
[17:42:34.500]                           quietly = TRUE)
[17:42:34.500]                         if (has_future) {
[17:42:34.500]                           ns <- base::getNamespace("future")
[17:42:34.500]                           version <- ns[[".package"]][["version"]]
[17:42:34.500]                           if (is.null(version)) 
[17:42:34.500]                             version <- utils::packageVersion("future")
[17:42:34.500]                         }
[17:42:34.500]                         else {
[17:42:34.500]                           version <- NULL
[17:42:34.500]                         }
[17:42:34.500]                         if (!has_future || version < "1.8.0") {
[17:42:34.500]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:34.500]                             "", base::R.version$version.string), 
[17:42:34.500]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:34.500]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:34.500]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:34.500]                               "release", "version")], collapse = " "), 
[17:42:34.500]                             hostname = base::Sys.info()[["nodename"]])
[17:42:34.500]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:34.500]                             info)
[17:42:34.500]                           info <- base::paste(info, collapse = "; ")
[17:42:34.500]                           if (!has_future) {
[17:42:34.500]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:34.500]                               info)
[17:42:34.500]                           }
[17:42:34.500]                           else {
[17:42:34.500]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:34.500]                               info, version)
[17:42:34.500]                           }
[17:42:34.500]                           base::stop(msg)
[17:42:34.500]                         }
[17:42:34.500]                       })
[17:42:34.500]                     }
[17:42:34.500]                     base::local({
[17:42:34.500]                       for (pkg in "future") {
[17:42:34.500]                         base::loadNamespace(pkg)
[17:42:34.500]                         base::library(pkg, character.only = TRUE)
[17:42:34.500]                       }
[17:42:34.500]                     })
[17:42:34.500]                   }
[17:42:34.500]                   options(future.plan = NULL)
[17:42:34.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.500]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:34.500]                   {
[17:42:34.500]                     future <- SequentialFuture(..., envir = envir)
[17:42:34.500]                     if (!future$lazy) 
[17:42:34.500]                       future <- run(future)
[17:42:34.500]                     invisible(future)
[17:42:34.500]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.500]                 }
[17:42:34.500]                 ...future.workdir <- getwd()
[17:42:34.500]             }
[17:42:34.500]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:34.500]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:34.500]         }
[17:42:34.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:34.500]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:34.500]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:34.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:34.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:34.500]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:34.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:34.500]             base::names(...future.oldOptions))
[17:42:34.500]     }
[17:42:34.500]     if (FALSE) {
[17:42:34.500]     }
[17:42:34.500]     else {
[17:42:34.500]         if (TRUE) {
[17:42:34.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:34.500]                 open = "w")
[17:42:34.500]         }
[17:42:34.500]         else {
[17:42:34.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:34.500]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:34.500]         }
[17:42:34.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:34.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:34.500]             base::sink(type = "output", split = FALSE)
[17:42:34.500]             base::close(...future.stdout)
[17:42:34.500]         }, add = TRUE)
[17:42:34.500]     }
[17:42:34.500]     ...future.frame <- base::sys.nframe()
[17:42:34.500]     ...future.conditions <- base::list()
[17:42:34.500]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:34.500]     if (FALSE) {
[17:42:34.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:34.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:34.500]     }
[17:42:34.500]     ...future.result <- base::tryCatch({
[17:42:34.500]         base::withCallingHandlers({
[17:42:34.500]             ...future.value <- base::withVisible(base::local({
[17:42:34.500]                 a %<-% subset(data, x < 3)$y
[17:42:34.500]                 a
[17:42:34.500]             }))
[17:42:34.500]             future::FutureResult(value = ...future.value$value, 
[17:42:34.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.500]                   ...future.rng), globalenv = if (FALSE) 
[17:42:34.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:34.500]                     ...future.globalenv.names))
[17:42:34.500]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:34.500]         }, condition = base::local({
[17:42:34.500]             c <- base::c
[17:42:34.500]             inherits <- base::inherits
[17:42:34.500]             invokeRestart <- base::invokeRestart
[17:42:34.500]             length <- base::length
[17:42:34.500]             list <- base::list
[17:42:34.500]             seq.int <- base::seq.int
[17:42:34.500]             signalCondition <- base::signalCondition
[17:42:34.500]             sys.calls <- base::sys.calls
[17:42:34.500]             `[[` <- base::`[[`
[17:42:34.500]             `+` <- base::`+`
[17:42:34.500]             `<<-` <- base::`<<-`
[17:42:34.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:34.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:34.500]                   3L)]
[17:42:34.500]             }
[17:42:34.500]             function(cond) {
[17:42:34.500]                 is_error <- inherits(cond, "error")
[17:42:34.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:34.500]                   NULL)
[17:42:34.500]                 if (is_error) {
[17:42:34.500]                   sessionInformation <- function() {
[17:42:34.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:34.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:34.500]                       search = base::search(), system = base::Sys.info())
[17:42:34.500]                   }
[17:42:34.500]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:34.500]                     cond$call), session = sessionInformation(), 
[17:42:34.500]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:34.500]                   signalCondition(cond)
[17:42:34.500]                 }
[17:42:34.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:34.500]                 "immediateCondition"))) {
[17:42:34.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:34.500]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:34.500]                   if (TRUE && !signal) {
[17:42:34.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.500]                     {
[17:42:34.500]                       inherits <- base::inherits
[17:42:34.500]                       invokeRestart <- base::invokeRestart
[17:42:34.500]                       is.null <- base::is.null
[17:42:34.500]                       muffled <- FALSE
[17:42:34.500]                       if (inherits(cond, "message")) {
[17:42:34.500]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.500]                         if (muffled) 
[17:42:34.500]                           invokeRestart("muffleMessage")
[17:42:34.500]                       }
[17:42:34.500]                       else if (inherits(cond, "warning")) {
[17:42:34.500]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.500]                         if (muffled) 
[17:42:34.500]                           invokeRestart("muffleWarning")
[17:42:34.500]                       }
[17:42:34.500]                       else if (inherits(cond, "condition")) {
[17:42:34.500]                         if (!is.null(pattern)) {
[17:42:34.500]                           computeRestarts <- base::computeRestarts
[17:42:34.500]                           grepl <- base::grepl
[17:42:34.500]                           restarts <- computeRestarts(cond)
[17:42:34.500]                           for (restart in restarts) {
[17:42:34.500]                             name <- restart$name
[17:42:34.500]                             if (is.null(name)) 
[17:42:34.500]                               next
[17:42:34.500]                             if (!grepl(pattern, name)) 
[17:42:34.500]                               next
[17:42:34.500]                             invokeRestart(restart)
[17:42:34.500]                             muffled <- TRUE
[17:42:34.500]                             break
[17:42:34.500]                           }
[17:42:34.500]                         }
[17:42:34.500]                       }
[17:42:34.500]                       invisible(muffled)
[17:42:34.500]                     }
[17:42:34.500]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.500]                   }
[17:42:34.500]                 }
[17:42:34.500]                 else {
[17:42:34.500]                   if (TRUE) {
[17:42:34.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.500]                     {
[17:42:34.500]                       inherits <- base::inherits
[17:42:34.500]                       invokeRestart <- base::invokeRestart
[17:42:34.500]                       is.null <- base::is.null
[17:42:34.500]                       muffled <- FALSE
[17:42:34.500]                       if (inherits(cond, "message")) {
[17:42:34.500]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.500]                         if (muffled) 
[17:42:34.500]                           invokeRestart("muffleMessage")
[17:42:34.500]                       }
[17:42:34.500]                       else if (inherits(cond, "warning")) {
[17:42:34.500]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.500]                         if (muffled) 
[17:42:34.500]                           invokeRestart("muffleWarning")
[17:42:34.500]                       }
[17:42:34.500]                       else if (inherits(cond, "condition")) {
[17:42:34.500]                         if (!is.null(pattern)) {
[17:42:34.500]                           computeRestarts <- base::computeRestarts
[17:42:34.500]                           grepl <- base::grepl
[17:42:34.500]                           restarts <- computeRestarts(cond)
[17:42:34.500]                           for (restart in restarts) {
[17:42:34.500]                             name <- restart$name
[17:42:34.500]                             if (is.null(name)) 
[17:42:34.500]                               next
[17:42:34.500]                             if (!grepl(pattern, name)) 
[17:42:34.500]                               next
[17:42:34.500]                             invokeRestart(restart)
[17:42:34.500]                             muffled <- TRUE
[17:42:34.500]                             break
[17:42:34.500]                           }
[17:42:34.500]                         }
[17:42:34.500]                       }
[17:42:34.500]                       invisible(muffled)
[17:42:34.500]                     }
[17:42:34.500]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.500]                   }
[17:42:34.500]                 }
[17:42:34.500]             }
[17:42:34.500]         }))
[17:42:34.500]     }, error = function(ex) {
[17:42:34.500]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:34.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.500]                 ...future.rng), started = ...future.startTime, 
[17:42:34.500]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:34.500]             version = "1.8"), class = "FutureResult")
[17:42:34.500]     }, finally = {
[17:42:34.500]         if (!identical(...future.workdir, getwd())) 
[17:42:34.500]             setwd(...future.workdir)
[17:42:34.500]         {
[17:42:34.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:34.500]                 ...future.oldOptions$nwarnings <- NULL
[17:42:34.500]             }
[17:42:34.500]             base::options(...future.oldOptions)
[17:42:34.500]             if (.Platform$OS.type == "windows") {
[17:42:34.500]                 old_names <- names(...future.oldEnvVars)
[17:42:34.500]                 envs <- base::Sys.getenv()
[17:42:34.500]                 names <- names(envs)
[17:42:34.500]                 common <- intersect(names, old_names)
[17:42:34.500]                 added <- setdiff(names, old_names)
[17:42:34.500]                 removed <- setdiff(old_names, names)
[17:42:34.500]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:34.500]                   envs[common]]
[17:42:34.500]                 NAMES <- toupper(changed)
[17:42:34.500]                 args <- list()
[17:42:34.500]                 for (kk in seq_along(NAMES)) {
[17:42:34.500]                   name <- changed[[kk]]
[17:42:34.500]                   NAME <- NAMES[[kk]]
[17:42:34.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.500]                     next
[17:42:34.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.500]                 }
[17:42:34.500]                 NAMES <- toupper(added)
[17:42:34.500]                 for (kk in seq_along(NAMES)) {
[17:42:34.500]                   name <- added[[kk]]
[17:42:34.500]                   NAME <- NAMES[[kk]]
[17:42:34.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.500]                     next
[17:42:34.500]                   args[[name]] <- ""
[17:42:34.500]                 }
[17:42:34.500]                 NAMES <- toupper(removed)
[17:42:34.500]                 for (kk in seq_along(NAMES)) {
[17:42:34.500]                   name <- removed[[kk]]
[17:42:34.500]                   NAME <- NAMES[[kk]]
[17:42:34.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.500]                     next
[17:42:34.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.500]                 }
[17:42:34.500]                 if (length(args) > 0) 
[17:42:34.500]                   base::do.call(base::Sys.setenv, args = args)
[17:42:34.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:34.500]             }
[17:42:34.500]             else {
[17:42:34.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:34.500]             }
[17:42:34.500]             {
[17:42:34.500]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:34.500]                   0L) {
[17:42:34.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:34.500]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:34.500]                   base::options(opts)
[17:42:34.500]                 }
[17:42:34.500]                 {
[17:42:34.500]                   {
[17:42:34.500]                     NULL
[17:42:34.500]                     RNGkind("Mersenne-Twister")
[17:42:34.500]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:34.500]                       inherits = FALSE)
[17:42:34.500]                   }
[17:42:34.500]                   options(future.plan = NULL)
[17:42:34.500]                   if (is.na(NA_character_)) 
[17:42:34.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:34.500]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:34.500]                   {
[17:42:34.500]                     future <- SequentialFuture(..., envir = envir)
[17:42:34.500]                     if (!future$lazy) 
[17:42:34.500]                       future <- run(future)
[17:42:34.500]                     invisible(future)
[17:42:34.500]                   }, function (..., envir = parent.frame()) 
[17:42:34.500]                   {
[17:42:34.500]                     future <- SequentialFuture(..., envir = envir)
[17:42:34.500]                     if (!future$lazy) 
[17:42:34.500]                       future <- run(future)
[17:42:34.500]                     invisible(future)
[17:42:34.500]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.500]                 }
[17:42:34.500]             }
[17:42:34.500]         }
[17:42:34.500]     })
[17:42:34.500]     if (TRUE) {
[17:42:34.500]         base::sink(type = "output", split = FALSE)
[17:42:34.500]         if (TRUE) {
[17:42:34.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:34.500]         }
[17:42:34.500]         else {
[17:42:34.500]             ...future.result["stdout"] <- base::list(NULL)
[17:42:34.500]         }
[17:42:34.500]         base::close(...future.stdout)
[17:42:34.500]         ...future.stdout <- NULL
[17:42:34.500]     }
[17:42:34.500]     ...future.result$conditions <- ...future.conditions
[17:42:34.500]     ...future.result$finished <- base::Sys.time()
[17:42:34.500]     ...future.result
[17:42:34.500] }
[17:42:34.502] assign_globals() ...
[17:42:34.502] List of 1
[17:42:34.502]  $ data:'data.frame':	5 obs. of  2 variables:
[17:42:34.502]   ..$ x: int [1:5] 1 2 3 4 5
[17:42:34.502]   ..$ y: int [1:5] 1 2 3 4 5
[17:42:34.502]  - attr(*, "where")=List of 1
[17:42:34.502]   ..$ data:<environment: R_EmptyEnv> 
[17:42:34.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:34.502]  - attr(*, "resolved")= logi FALSE
[17:42:34.502]  - attr(*, "total_size")= num 160
[17:42:34.502]  - attr(*, "already-done")= logi TRUE
[17:42:34.505] - copied ‘data’ to environment
[17:42:34.505] assign_globals() ... done
[17:42:34.505] plan(): Setting new future strategy stack:
[17:42:34.505] List of future strategies:
[17:42:34.505] 1. sequential:
[17:42:34.505]    - args: function (..., envir = parent.frame())
[17:42:34.505]    - tweaked: FALSE
[17:42:34.505]    - call: plan(list(sequential, strategy))
[17:42:34.506] plan(): nbrOfWorkers() = 1
[17:42:34.536] plan(): Setting new future strategy stack:
[17:42:34.536] List of future strategies:
[17:42:34.536] 1. sequential:
[17:42:34.536]    - args: function (..., envir = parent.frame())
[17:42:34.536]    - tweaked: FALSE
[17:42:34.536]    - call: plan(list(sequential, strategy))
[17:42:34.536] 2. sequential:
[17:42:34.536]    - args: function (..., envir = parent.frame())
[17:42:34.536]    - tweaked: FALSE
[17:42:34.536]    - call: plan(list(sequential, strategy))
[17:42:34.536] plan(): nbrOfWorkers() = 1
[17:42:34.537] SequentialFuture started (and completed)
[17:42:34.537] signalConditions() ...
[17:42:34.537]  - include = ‘immediateCondition’
[17:42:34.537]  - exclude = 
[17:42:34.537]  - resignal = FALSE
[17:42:34.537]  - Number of conditions: 53
[17:42:34.537] signalConditions() ... done
[17:42:34.537] - Launch lazy future ... done
[17:42:34.538] run() for ‘SequentialFuture’ ... done
[17:42:34.538] signalConditions() ...
[17:42:34.538]  - include = ‘immediateCondition’
[17:42:34.538]  - exclude = 
[17:42:34.538]  - resignal = FALSE
[17:42:34.538]  - Number of conditions: 53
[17:42:34.538] signalConditions() ... done
[17:42:34.538] Future state: ‘finished’
[17:42:34.538] signalConditions() ...
[17:42:34.538]  - include = ‘condition’
[17:42:34.539]  - exclude = ‘immediateCondition’
[17:42:34.539]  - resignal = TRUE
[17:42:34.539]  - Number of conditions: 53
[17:42:34.539]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.506] getGlobalsAndPackages() ...
[17:42:34.539]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:34.539]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.522] Searching for globals...
[17:42:34.539]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.523] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[17:42:34.539]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.523] Searching for globals ... DONE
[17:42:34.540]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.523] Resolving globals: FALSE
[17:42:34.542]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.523] The total size of the 1 globals is 160 bytes (160 bytes)
[17:42:34.542]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.524] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[17:42:34.542]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.524] - globals: [1] ‘data’
[17:42:34.542]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.524] 
[17:42:34.542]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.524] getGlobalsAndPackages() ... DONE
[17:42:34.542]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.524] run() for ‘Future’ ...
[17:42:34.542]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.524] - state: ‘created’
[17:42:34.543]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.525] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:34.543]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.525] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:34.543]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.525] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:34.543]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.525]   - Field: ‘label’
[17:42:34.543]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.525]   - Field: ‘local’
[17:42:34.543]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.525]   - Field: ‘owner’
[17:42:34.543]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.525]   - Field: ‘envir’
[17:42:34.544]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.525]   - Field: ‘packages’
[17:42:34.544]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.526]   - Field: ‘gc’
[17:42:34.544]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.526]   - Field: ‘conditions’
[17:42:34.544]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.526]   - Field: ‘expr’
[17:42:34.544]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.526]   - Field: ‘uuid’
[17:42:34.544]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.526]   - Field: ‘seed’
[17:42:34.544]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.526]   - Field: ‘version’
[17:42:34.545]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.526]   - Field: ‘result’
[17:42:34.545]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.526]   - Field: ‘asynchronous’
[17:42:34.545]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.526]   - Field: ‘calls’
[17:42:34.545]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.526]   - Field: ‘globals’
[17:42:34.545]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.527]   - Field: ‘stdout’
[17:42:34.545]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.527]   - Field: ‘earlySignal’
[17:42:34.545]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.527]   - Field: ‘lazy’
[17:42:34.546]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.527]   - Field: ‘state’
[17:42:34.546]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.527] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:34.546]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.527] - Launch lazy future ...
[17:42:34.546]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.527] Packages needed by the future expression (n = 0): <none>
[17:42:34.546]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.527] Packages needed by future strategies (n = 0): <none>
[17:42:34.546]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.528] {
[17:42:34.528]     {
[17:42:34.528]         {
[17:42:34.528]             ...future.startTime <- base::Sys.time()
[17:42:34.528]             {
[17:42:34.528]                 {
[17:42:34.528]                   {
[17:42:34.528]                     base::local({
[17:42:34.528]                       has_future <- base::requireNamespace("future", 
[17:42:34.528]                         quietly = TRUE)
[17:42:34.528]                       if (has_future) {
[17:42:34.528]                         ns <- base::getNamespace("future")
[17:42:34.528]                         version <- ns[[".package"]][["version"]]
[17:42:34.528]                         if (is.null(version)) 
[17:42:34.528]                           version <- utils::packageVersion("future")
[17:42:34.528]                       }
[17:42:34.528]                       else {
[17:42:34.528]                         version <- NULL
[17:42:34.528]                       }
[17:42:34.528]                       if (!has_future || version < "1.8.0") {
[17:42:34.528]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:34.528]                           "", base::R.version$version.string), 
[17:42:34.528]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:34.528]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:34.528]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:34.528]                             "release", "version")], collapse = " "), 
[17:42:34.528]                           hostname = base::Sys.info()[["nodename"]])
[17:42:34.528]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:34.528]                           info)
[17:42:34.528]                         info <- base::paste(info, collapse = "; ")
[17:42:34.528]                         if (!has_future) {
[17:42:34.528]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:34.528]                             info)
[17:42:34.528]                         }
[17:42:34.528]                         else {
[17:42:34.528]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:34.528]                             info, version)
[17:42:34.528]                         }
[17:42:34.528]                         base::stop(msg)
[17:42:34.528]                       }
[17:42:34.528]                     })
[17:42:34.528]                   }
[17:42:34.528]                   options(future.plan = NULL)
[17:42:34.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:34.528]                 }
[17:42:34.528]                 ...future.workdir <- getwd()
[17:42:34.528]             }
[17:42:34.528]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:34.528]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:34.528]         }
[17:42:34.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:34.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:34.528]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:34.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:34.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:34.528]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:34.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:34.528]             base::names(...future.oldOptions))
[17:42:34.528]     }
[17:42:34.528]     if (FALSE) {
[17:42:34.528]     }
[17:42:34.528]     else {
[17:42:34.528]         if (TRUE) {
[17:42:34.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:34.528]                 open = "w")
[17:42:34.528]         }
[17:42:34.528]         else {
[17:42:34.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:34.528]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:34.528]         }
[17:42:34.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:34.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:34.528]             base::sink(type = "output", split = FALSE)
[17:42:34.528]             base::close(...future.stdout)
[17:42:34.528]         }, add = TRUE)
[17:42:34.528]     }
[17:42:34.528]     ...future.frame <- base::sys.nframe()
[17:42:34.528]     ...future.conditions <- base::list()
[17:42:34.528]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:34.528]     if (FALSE) {
[17:42:34.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:34.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:34.528]     }
[17:42:34.528]     ...future.result <- base::tryCatch({
[17:42:34.528]         base::withCallingHandlers({
[17:42:34.528]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:42:34.528]                 x < 3)$y))
[17:42:34.528]             future::FutureResult(value = ...future.value$value, 
[17:42:34.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.528]                   ...future.rng), globalenv = if (FALSE) 
[17:42:34.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:34.528]                     ...future.globalenv.names))
[17:42:34.528]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:34.528]         }, condition = base::local({
[17:42:34.528]             c <- base::c
[17:42:34.528]             inherits <- base::inherits
[17:42:34.528]             invokeRestart <- base::invokeRestart
[17:42:34.528]             length <- base::length
[17:42:34.528]             list <- base::list
[17:42:34.528]             seq.int <- base::seq.int
[17:42:34.528]             signalCondition <- base::signalCondition
[17:42:34.528]             sys.calls <- base::sys.calls
[17:42:34.528]             `[[` <- base::`[[`
[17:42:34.528]             `+` <- base::`+`
[17:42:34.528]             `<<-` <- base::`<<-`
[17:42:34.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:34.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:34.528]                   3L)]
[17:42:34.528]             }
[17:42:34.528]             function(cond) {
[17:42:34.528]                 is_error <- inherits(cond, "error")
[17:42:34.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:34.528]                   NULL)
[17:42:34.528]                 if (is_error) {
[17:42:34.528]                   sessionInformation <- function() {
[17:42:34.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:34.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:34.528]                       search = base::search(), system = base::Sys.info())
[17:42:34.528]                   }
[17:42:34.528]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:34.528]                     cond$call), session = sessionInformation(), 
[17:42:34.528]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:34.528]                   signalCondition(cond)
[17:42:34.528]                 }
[17:42:34.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:34.528]                 "immediateCondition"))) {
[17:42:34.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:34.528]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:34.528]                   if (TRUE && !signal) {
[17:42:34.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.528]                     {
[17:42:34.528]                       inherits <- base::inherits
[17:42:34.528]                       invokeRestart <- base::invokeRestart
[17:42:34.528]                       is.null <- base::is.null
[17:42:34.528]                       muffled <- FALSE
[17:42:34.528]                       if (inherits(cond, "message")) {
[17:42:34.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.528]                         if (muffled) 
[17:42:34.528]                           invokeRestart("muffleMessage")
[17:42:34.528]                       }
[17:42:34.528]                       else if (inherits(cond, "warning")) {
[17:42:34.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.528]                         if (muffled) 
[17:42:34.528]                           invokeRestart("muffleWarning")
[17:42:34.528]                       }
[17:42:34.528]                       else if (inherits(cond, "condition")) {
[17:42:34.528]                         if (!is.null(pattern)) {
[17:42:34.528]                           computeRestarts <- base::computeRestarts
[17:42:34.528]                           grepl <- base::grepl
[17:42:34.528]                           restarts <- computeRestarts(cond)
[17:42:34.528]                           for (restart in restarts) {
[17:42:34.528]                             name <- restart$name
[17:42:34.528]                             if (is.null(name)) 
[17:42:34.528]                               next
[17:42:34.528]                             if (!grepl(pattern, name)) 
[17:42:34.528]                               next
[17:42:34.528]                             invokeRestart(restart)
[17:42:34.528]                             muffled <- TRUE
[17:42:34.528]                             break
[17:42:34.528]                           }
[17:42:34.528]                         }
[17:42:34.528]                       }
[17:42:34.528]                       invisible(muffled)
[17:42:34.528]                     }
[17:42:34.528]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.528]                   }
[17:42:34.528]                 }
[17:42:34.528]                 else {
[17:42:34.528]                   if (TRUE) {
[17:42:34.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.528]                     {
[17:42:34.528]                       inherits <- base::inherits
[17:42:34.528]                       invokeRestart <- base::invokeRestart
[17:42:34.528]                       is.null <- base::is.null
[17:42:34.528]                       muffled <- FALSE
[17:42:34.528]                       if (inherits(cond, "message")) {
[17:42:34.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.528]                         if (muffled) 
[17:42:34.528]                           invokeRestart("muffleMessage")
[17:42:34.528]                       }
[17:42:34.528]                       else if (inherits(cond, "warning")) {
[17:42:34.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.528]                         if (muffled) 
[17:42:34.528]                           invokeRestart("muffleWarning")
[17:42:34.528]                       }
[17:42:34.528]                       else if (inherits(cond, "condition")) {
[17:42:34.528]                         if (!is.null(pattern)) {
[17:42:34.528]                           computeRestarts <- base::computeRestarts
[17:42:34.528]                           grepl <- base::grepl
[17:42:34.528]                           restarts <- computeRestarts(cond)
[17:42:34.528]                           for (restart in restarts) {
[17:42:34.528]                             name <- restart$name
[17:42:34.528]                             if (is.null(name)) 
[17:42:34.528]                               next
[17:42:34.528]                             if (!grepl(pattern, name)) 
[17:42:34.528]                               next
[17:42:34.528]                             invokeRestart(restart)
[17:42:34.528]                             muffled <- TRUE
[17:42:34.528]                             break
[17:42:34.528]                           }
[17:42:34.528]                         }
[17:42:34.528]                       }
[17:42:34.528]                       invisible(muffled)
[17:42:34.528]                     }
[17:42:34.528]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.528]                   }
[17:42:34.528]                 }
[17:42:34.528]             }
[17:42:34.528]         }))
[17:42:34.528]     }, error = function(ex) {
[17:42:34.528]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:34.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.528]                 ...future.rng), started = ...future.startTime, 
[17:42:34.528]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:34.528]             version = "1.8"), class = "FutureResult")
[17:42:34.528]     }, finally = {
[17:42:34.528]         if (!identical(...future.workdir, getwd())) 
[17:42:34.528]             setwd(...future.workdir)
[17:42:34.528]         {
[17:42:34.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:34.528]                 ...future.oldOptions$nwarnings <- NULL
[17:42:34.528]             }
[17:42:34.528]             base::options(...future.oldOptions)
[17:42:34.528]             if (.Platform$OS.type == "windows") {
[17:42:34.528]                 old_names <- names(...future.oldEnvVars)
[17:42:34.528]                 envs <- base::Sys.getenv()
[17:42:34.528]                 names <- names(envs)
[17:42:34.528]                 common <- intersect(names, old_names)
[17:42:34.528]                 added <- setdiff(names, old_names)
[17:42:34.528]                 removed <- setdiff(old_names, names)
[17:42:34.528]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:34.528]                   envs[common]]
[17:42:34.528]                 NAMES <- toupper(changed)
[17:42:34.528]                 args <- list()
[17:42:34.528]                 for (kk in seq_along(NAMES)) {
[17:42:34.528]                   name <- changed[[kk]]
[17:42:34.528]                   NAME <- NAMES[[kk]]
[17:42:34.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.528]                     next
[17:42:34.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.528]                 }
[17:42:34.528]                 NAMES <- toupper(added)
[17:42:34.528]                 for (kk in seq_along(NAMES)) {
[17:42:34.528]                   name <- added[[kk]]
[17:42:34.528]                   NAME <- NAMES[[kk]]
[17:42:34.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.528]                     next
[17:42:34.528]                   args[[name]] <- ""
[17:42:34.528]                 }
[17:42:34.528]                 NAMES <- toupper(removed)
[17:42:34.528]                 for (kk in seq_along(NAMES)) {
[17:42:34.528]                   name <- removed[[kk]]
[17:42:34.528]                   NAME <- NAMES[[kk]]
[17:42:34.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.528]                     next
[17:42:34.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.528]                 }
[17:42:34.528]                 if (length(args) > 0) 
[17:42:34.528]                   base::do.call(base::Sys.setenv, args = args)
[17:42:34.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:34.528]             }
[17:42:34.528]             else {
[17:42:34.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:34.528]             }
[17:42:34.528]             {
[17:42:34.528]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:34.528]                   0L) {
[17:42:34.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:34.528]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:34.528]                   base::options(opts)
[17:42:34.528]                 }
[17:42:34.528]                 {
[17:42:34.528]                   {
[17:42:34.528]                     NULL
[17:42:34.528]                     RNGkind("Mersenne-Twister")
[17:42:34.528]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:34.528]                       inherits = FALSE)
[17:42:34.528]                   }
[17:42:34.528]                   options(future.plan = NULL)
[17:42:34.528]                   if (is.na(NA_character_)) 
[17:42:34.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:34.528]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:34.528]                   {
[17:42:34.528]                     future <- SequentialFuture(..., envir = envir)
[17:42:34.528]                     if (!future$lazy) 
[17:42:34.528]                       future <- run(future)
[17:42:34.528]                     invisible(future)
[17:42:34.528]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.528]                 }
[17:42:34.528]             }
[17:42:34.528]         }
[17:42:34.528]     })
[17:42:34.528]     if (TRUE) {
[17:42:34.528]         base::sink(type = "output", split = FALSE)
[17:42:34.528]         if (TRUE) {
[17:42:34.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:34.528]         }
[17:42:34.528]         else {
[17:42:34.528]             ...future.result["stdout"] <- base::list(NULL)
[17:42:34.528]         }
[17:42:34.528]         base::close(...future.stdout)
[17:42:34.528]         ...future.stdout <- NULL
[17:42:34.528]     }
[17:42:34.528]     ...future.result$conditions <- ...future.conditions
[17:42:34.528]     ...future.result$finished <- base::Sys.time()
[17:42:34.528]     ...future.result
[17:42:34.528] }
[17:42:34.546]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.529] assign_globals() ...
[17:42:34.547]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.530] List of 1
[17:42:34.530]  $ data:'data.frame':	5 obs. of  2 variables:
[17:42:34.530]   ..$ x: int [1:5] 1 2 3 4 5
[17:42:34.530]   ..$ y: int [1:5] 1 2 3 4 5
[17:42:34.530]  - attr(*, "where")=List of 1
[17:42:34.530]   ..$ data:<environment: R_EmptyEnv> 
[17:42:34.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:34.530]  - attr(*, "resolved")= logi FALSE
[17:42:34.530]  - attr(*, "total_size")= num 160
[17:42:34.530]  - attr(*, "already-done")= logi TRUE
[17:42:34.547]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.533] - copied ‘data’ to environment
[17:42:34.547]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.533] assign_globals() ... done
[17:42:34.547]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.533] plan(): Setting new future strategy stack:
[17:42:34.547]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.533] List of future strategies:
[17:42:34.533] 1. sequential:
[17:42:34.533]    - args: function (..., envir = parent.frame())
[17:42:34.533]    - tweaked: FALSE
[17:42:34.533]    - call: NULL
[17:42:34.547]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.533] plan(): nbrOfWorkers() = 1
[17:42:34.547]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.534] plan(): Setting new future strategy stack:
[17:42:34.548]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.534] List of future strategies:
[17:42:34.534] 1. sequential:
[17:42:34.534]    - args: function (..., envir = parent.frame())
[17:42:34.534]    - tweaked: FALSE
[17:42:34.534]    - call: plan(list(sequential, strategy))
[17:42:34.548]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.535] plan(): nbrOfWorkers() = 1
[17:42:34.548]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.535] SequentialFuture started (and completed)
[17:42:34.548]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.535] - Launch lazy future ... done
[17:42:34.548]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.535] run() for ‘SequentialFuture’ ... done
[17:42:34.548] signalConditions() ... done
- Strategy: sequential ... DONE
- Strategy: multicore ...
[17:42:34.549] plan(): Setting new future strategy stack:
[17:42:34.549] List of future strategies:
[17:42:34.549] 1. multicore:
[17:42:34.549]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:34.549]    - tweaked: FALSE
[17:42:34.549]    - call: plan(strategy)
[17:42:34.553] plan(): nbrOfWorkers() = 2
[17:42:34.553] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:34.554] Searching for globals...
[17:42:34.554] - globals found: [1] ‘getOption’
[17:42:34.554] Searching for globals ... DONE
[17:42:34.554] Resolving globals: FALSE
[17:42:34.555] 
[17:42:34.555] 
[17:42:34.555] getGlobalsAndPackages() ... DONE
[17:42:34.555] run() for ‘Future’ ...
[17:42:34.555] - state: ‘created’
[17:42:34.555] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:34.559] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:34.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:34.559]   - Field: ‘label’
[17:42:34.559]   - Field: ‘local’
[17:42:34.559]   - Field: ‘owner’
[17:42:34.560]   - Field: ‘envir’
[17:42:34.560]   - Field: ‘workers’
[17:42:34.560]   - Field: ‘packages’
[17:42:34.560]   - Field: ‘gc’
[17:42:34.560]   - Field: ‘job’
[17:42:34.560]   - Field: ‘conditions’
[17:42:34.560]   - Field: ‘expr’
[17:42:34.560]   - Field: ‘uuid’
[17:42:34.561]   - Field: ‘seed’
[17:42:34.561]   - Field: ‘version’
[17:42:34.561]   - Field: ‘result’
[17:42:34.561]   - Field: ‘asynchronous’
[17:42:34.561]   - Field: ‘calls’
[17:42:34.561]   - Field: ‘globals’
[17:42:34.561]   - Field: ‘stdout’
[17:42:34.561]   - Field: ‘earlySignal’
[17:42:34.561]   - Field: ‘lazy’
[17:42:34.561]   - Field: ‘state’
[17:42:34.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:34.562] - Launch lazy future ...
[17:42:34.563] Packages needed by the future expression (n = 0): <none>
[17:42:34.563] Packages needed by future strategies (n = 0): <none>
[17:42:34.563] {
[17:42:34.563]     {
[17:42:34.563]         {
[17:42:34.563]             ...future.startTime <- base::Sys.time()
[17:42:34.563]             {
[17:42:34.563]                 {
[17:42:34.563]                   {
[17:42:34.563]                     {
[17:42:34.563]                       base::local({
[17:42:34.563]                         has_future <- base::requireNamespace("future", 
[17:42:34.563]                           quietly = TRUE)
[17:42:34.563]                         if (has_future) {
[17:42:34.563]                           ns <- base::getNamespace("future")
[17:42:34.563]                           version <- ns[[".package"]][["version"]]
[17:42:34.563]                           if (is.null(version)) 
[17:42:34.563]                             version <- utils::packageVersion("future")
[17:42:34.563]                         }
[17:42:34.563]                         else {
[17:42:34.563]                           version <- NULL
[17:42:34.563]                         }
[17:42:34.563]                         if (!has_future || version < "1.8.0") {
[17:42:34.563]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:34.563]                             "", base::R.version$version.string), 
[17:42:34.563]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:34.563]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:34.563]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:34.563]                               "release", "version")], collapse = " "), 
[17:42:34.563]                             hostname = base::Sys.info()[["nodename"]])
[17:42:34.563]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:34.563]                             info)
[17:42:34.563]                           info <- base::paste(info, collapse = "; ")
[17:42:34.563]                           if (!has_future) {
[17:42:34.563]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:34.563]                               info)
[17:42:34.563]                           }
[17:42:34.563]                           else {
[17:42:34.563]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:34.563]                               info, version)
[17:42:34.563]                           }
[17:42:34.563]                           base::stop(msg)
[17:42:34.563]                         }
[17:42:34.563]                       })
[17:42:34.563]                     }
[17:42:34.563]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:34.563]                     base::options(mc.cores = 1L)
[17:42:34.563]                   }
[17:42:34.563]                   options(future.plan = NULL)
[17:42:34.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:34.563]                 }
[17:42:34.563]                 ...future.workdir <- getwd()
[17:42:34.563]             }
[17:42:34.563]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:34.563]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:34.563]         }
[17:42:34.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:34.563]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:34.563]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:34.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:34.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:34.563]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:34.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:34.563]             base::names(...future.oldOptions))
[17:42:34.563]     }
[17:42:34.563]     if (FALSE) {
[17:42:34.563]     }
[17:42:34.563]     else {
[17:42:34.563]         if (TRUE) {
[17:42:34.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:34.563]                 open = "w")
[17:42:34.563]         }
[17:42:34.563]         else {
[17:42:34.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:34.563]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:34.563]         }
[17:42:34.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:34.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:34.563]             base::sink(type = "output", split = FALSE)
[17:42:34.563]             base::close(...future.stdout)
[17:42:34.563]         }, add = TRUE)
[17:42:34.563]     }
[17:42:34.563]     ...future.frame <- base::sys.nframe()
[17:42:34.563]     ...future.conditions <- base::list()
[17:42:34.563]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:34.563]     if (FALSE) {
[17:42:34.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:34.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:34.563]     }
[17:42:34.563]     ...future.result <- base::tryCatch({
[17:42:34.563]         base::withCallingHandlers({
[17:42:34.563]             ...future.value <- base::withVisible(base::local({
[17:42:34.563]                 withCallingHandlers({
[17:42:34.563]                   getOption("future.globals.onMissing")
[17:42:34.563]                 }, immediateCondition = function(cond) {
[17:42:34.563]                   save_rds <- function (object, pathname, ...) 
[17:42:34.563]                   {
[17:42:34.563]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:34.563]                     if (file_test("-f", pathname_tmp)) {
[17:42:34.563]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.563]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:34.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.563]                         fi_tmp[["mtime"]])
[17:42:34.563]                     }
[17:42:34.563]                     tryCatch({
[17:42:34.563]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:34.563]                     }, error = function(ex) {
[17:42:34.563]                       msg <- conditionMessage(ex)
[17:42:34.563]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.563]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:34.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.563]                         fi_tmp[["mtime"]], msg)
[17:42:34.563]                       ex$message <- msg
[17:42:34.563]                       stop(ex)
[17:42:34.563]                     })
[17:42:34.563]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:34.563]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:34.563]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:34.563]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.563]                       fi <- file.info(pathname)
[17:42:34.563]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:34.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.563]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:34.563]                         fi[["size"]], fi[["mtime"]])
[17:42:34.563]                       stop(msg)
[17:42:34.563]                     }
[17:42:34.563]                     invisible(pathname)
[17:42:34.563]                   }
[17:42:34.563]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:34.563]                     rootPath = tempdir()) 
[17:42:34.563]                   {
[17:42:34.563]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:34.563]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:34.563]                       tmpdir = path, fileext = ".rds")
[17:42:34.563]                     save_rds(obj, file)
[17:42:34.563]                   }
[17:42:34.563]                   saveImmediateCondition(cond, path = "/tmp/RtmpND951N/.future/immediateConditions")
[17:42:34.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.563]                   {
[17:42:34.563]                     inherits <- base::inherits
[17:42:34.563]                     invokeRestart <- base::invokeRestart
[17:42:34.563]                     is.null <- base::is.null
[17:42:34.563]                     muffled <- FALSE
[17:42:34.563]                     if (inherits(cond, "message")) {
[17:42:34.563]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:34.563]                       if (muffled) 
[17:42:34.563]                         invokeRestart("muffleMessage")
[17:42:34.563]                     }
[17:42:34.563]                     else if (inherits(cond, "warning")) {
[17:42:34.563]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:34.563]                       if (muffled) 
[17:42:34.563]                         invokeRestart("muffleWarning")
[17:42:34.563]                     }
[17:42:34.563]                     else if (inherits(cond, "condition")) {
[17:42:34.563]                       if (!is.null(pattern)) {
[17:42:34.563]                         computeRestarts <- base::computeRestarts
[17:42:34.563]                         grepl <- base::grepl
[17:42:34.563]                         restarts <- computeRestarts(cond)
[17:42:34.563]                         for (restart in restarts) {
[17:42:34.563]                           name <- restart$name
[17:42:34.563]                           if (is.null(name)) 
[17:42:34.563]                             next
[17:42:34.563]                           if (!grepl(pattern, name)) 
[17:42:34.563]                             next
[17:42:34.563]                           invokeRestart(restart)
[17:42:34.563]                           muffled <- TRUE
[17:42:34.563]                           break
[17:42:34.563]                         }
[17:42:34.563]                       }
[17:42:34.563]                     }
[17:42:34.563]                     invisible(muffled)
[17:42:34.563]                   }
[17:42:34.563]                   muffleCondition(cond)
[17:42:34.563]                 })
[17:42:34.563]             }))
[17:42:34.563]             future::FutureResult(value = ...future.value$value, 
[17:42:34.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.563]                   ...future.rng), globalenv = if (FALSE) 
[17:42:34.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:34.563]                     ...future.globalenv.names))
[17:42:34.563]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:34.563]         }, condition = base::local({
[17:42:34.563]             c <- base::c
[17:42:34.563]             inherits <- base::inherits
[17:42:34.563]             invokeRestart <- base::invokeRestart
[17:42:34.563]             length <- base::length
[17:42:34.563]             list <- base::list
[17:42:34.563]             seq.int <- base::seq.int
[17:42:34.563]             signalCondition <- base::signalCondition
[17:42:34.563]             sys.calls <- base::sys.calls
[17:42:34.563]             `[[` <- base::`[[`
[17:42:34.563]             `+` <- base::`+`
[17:42:34.563]             `<<-` <- base::`<<-`
[17:42:34.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:34.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:34.563]                   3L)]
[17:42:34.563]             }
[17:42:34.563]             function(cond) {
[17:42:34.563]                 is_error <- inherits(cond, "error")
[17:42:34.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:34.563]                   NULL)
[17:42:34.563]                 if (is_error) {
[17:42:34.563]                   sessionInformation <- function() {
[17:42:34.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:34.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:34.563]                       search = base::search(), system = base::Sys.info())
[17:42:34.563]                   }
[17:42:34.563]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:34.563]                     cond$call), session = sessionInformation(), 
[17:42:34.563]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:34.563]                   signalCondition(cond)
[17:42:34.563]                 }
[17:42:34.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:34.563]                 "immediateCondition"))) {
[17:42:34.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:34.563]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:34.563]                   if (TRUE && !signal) {
[17:42:34.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.563]                     {
[17:42:34.563]                       inherits <- base::inherits
[17:42:34.563]                       invokeRestart <- base::invokeRestart
[17:42:34.563]                       is.null <- base::is.null
[17:42:34.563]                       muffled <- FALSE
[17:42:34.563]                       if (inherits(cond, "message")) {
[17:42:34.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.563]                         if (muffled) 
[17:42:34.563]                           invokeRestart("muffleMessage")
[17:42:34.563]                       }
[17:42:34.563]                       else if (inherits(cond, "warning")) {
[17:42:34.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.563]                         if (muffled) 
[17:42:34.563]                           invokeRestart("muffleWarning")
[17:42:34.563]                       }
[17:42:34.563]                       else if (inherits(cond, "condition")) {
[17:42:34.563]                         if (!is.null(pattern)) {
[17:42:34.563]                           computeRestarts <- base::computeRestarts
[17:42:34.563]                           grepl <- base::grepl
[17:42:34.563]                           restarts <- computeRestarts(cond)
[17:42:34.563]                           for (restart in restarts) {
[17:42:34.563]                             name <- restart$name
[17:42:34.563]                             if (is.null(name)) 
[17:42:34.563]                               next
[17:42:34.563]                             if (!grepl(pattern, name)) 
[17:42:34.563]                               next
[17:42:34.563]                             invokeRestart(restart)
[17:42:34.563]                             muffled <- TRUE
[17:42:34.563]                             break
[17:42:34.563]                           }
[17:42:34.563]                         }
[17:42:34.563]                       }
[17:42:34.563]                       invisible(muffled)
[17:42:34.563]                     }
[17:42:34.563]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.563]                   }
[17:42:34.563]                 }
[17:42:34.563]                 else {
[17:42:34.563]                   if (TRUE) {
[17:42:34.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.563]                     {
[17:42:34.563]                       inherits <- base::inherits
[17:42:34.563]                       invokeRestart <- base::invokeRestart
[17:42:34.563]                       is.null <- base::is.null
[17:42:34.563]                       muffled <- FALSE
[17:42:34.563]                       if (inherits(cond, "message")) {
[17:42:34.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.563]                         if (muffled) 
[17:42:34.563]                           invokeRestart("muffleMessage")
[17:42:34.563]                       }
[17:42:34.563]                       else if (inherits(cond, "warning")) {
[17:42:34.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.563]                         if (muffled) 
[17:42:34.563]                           invokeRestart("muffleWarning")
[17:42:34.563]                       }
[17:42:34.563]                       else if (inherits(cond, "condition")) {
[17:42:34.563]                         if (!is.null(pattern)) {
[17:42:34.563]                           computeRestarts <- base::computeRestarts
[17:42:34.563]                           grepl <- base::grepl
[17:42:34.563]                           restarts <- computeRestarts(cond)
[17:42:34.563]                           for (restart in restarts) {
[17:42:34.563]                             name <- restart$name
[17:42:34.563]                             if (is.null(name)) 
[17:42:34.563]                               next
[17:42:34.563]                             if (!grepl(pattern, name)) 
[17:42:34.563]                               next
[17:42:34.563]                             invokeRestart(restart)
[17:42:34.563]                             muffled <- TRUE
[17:42:34.563]                             break
[17:42:34.563]                           }
[17:42:34.563]                         }
[17:42:34.563]                       }
[17:42:34.563]                       invisible(muffled)
[17:42:34.563]                     }
[17:42:34.563]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.563]                   }
[17:42:34.563]                 }
[17:42:34.563]             }
[17:42:34.563]         }))
[17:42:34.563]     }, error = function(ex) {
[17:42:34.563]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:34.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.563]                 ...future.rng), started = ...future.startTime, 
[17:42:34.563]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:34.563]             version = "1.8"), class = "FutureResult")
[17:42:34.563]     }, finally = {
[17:42:34.563]         if (!identical(...future.workdir, getwd())) 
[17:42:34.563]             setwd(...future.workdir)
[17:42:34.563]         {
[17:42:34.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:34.563]                 ...future.oldOptions$nwarnings <- NULL
[17:42:34.563]             }
[17:42:34.563]             base::options(...future.oldOptions)
[17:42:34.563]             if (.Platform$OS.type == "windows") {
[17:42:34.563]                 old_names <- names(...future.oldEnvVars)
[17:42:34.563]                 envs <- base::Sys.getenv()
[17:42:34.563]                 names <- names(envs)
[17:42:34.563]                 common <- intersect(names, old_names)
[17:42:34.563]                 added <- setdiff(names, old_names)
[17:42:34.563]                 removed <- setdiff(old_names, names)
[17:42:34.563]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:34.563]                   envs[common]]
[17:42:34.563]                 NAMES <- toupper(changed)
[17:42:34.563]                 args <- list()
[17:42:34.563]                 for (kk in seq_along(NAMES)) {
[17:42:34.563]                   name <- changed[[kk]]
[17:42:34.563]                   NAME <- NAMES[[kk]]
[17:42:34.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.563]                     next
[17:42:34.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.563]                 }
[17:42:34.563]                 NAMES <- toupper(added)
[17:42:34.563]                 for (kk in seq_along(NAMES)) {
[17:42:34.563]                   name <- added[[kk]]
[17:42:34.563]                   NAME <- NAMES[[kk]]
[17:42:34.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.563]                     next
[17:42:34.563]                   args[[name]] <- ""
[17:42:34.563]                 }
[17:42:34.563]                 NAMES <- toupper(removed)
[17:42:34.563]                 for (kk in seq_along(NAMES)) {
[17:42:34.563]                   name <- removed[[kk]]
[17:42:34.563]                   NAME <- NAMES[[kk]]
[17:42:34.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.563]                     next
[17:42:34.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.563]                 }
[17:42:34.563]                 if (length(args) > 0) 
[17:42:34.563]                   base::do.call(base::Sys.setenv, args = args)
[17:42:34.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:34.563]             }
[17:42:34.563]             else {
[17:42:34.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:34.563]             }
[17:42:34.563]             {
[17:42:34.563]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:34.563]                   0L) {
[17:42:34.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:34.563]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:34.563]                   base::options(opts)
[17:42:34.563]                 }
[17:42:34.563]                 {
[17:42:34.563]                   {
[17:42:34.563]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:34.563]                     NULL
[17:42:34.563]                   }
[17:42:34.563]                   options(future.plan = NULL)
[17:42:34.563]                   if (is.na(NA_character_)) 
[17:42:34.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:34.563]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:34.563]                     envir = parent.frame()) 
[17:42:34.563]                   {
[17:42:34.563]                     default_workers <- missing(workers)
[17:42:34.563]                     if (is.function(workers)) 
[17:42:34.563]                       workers <- workers()
[17:42:34.563]                     workers <- structure(as.integer(workers), 
[17:42:34.563]                       class = class(workers))
[17:42:34.563]                     stop_if_not(is.finite(workers), workers >= 
[17:42:34.563]                       1L)
[17:42:34.563]                     if ((workers == 1L && !inherits(workers, 
[17:42:34.563]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:34.563]                       if (default_workers) 
[17:42:34.563]                         supportsMulticore(warn = TRUE)
[17:42:34.563]                       return(sequential(..., envir = envir))
[17:42:34.563]                     }
[17:42:34.563]                     oopts <- options(mc.cores = workers)
[17:42:34.563]                     on.exit(options(oopts))
[17:42:34.563]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:34.563]                       envir = envir)
[17:42:34.563]                     if (!future$lazy) 
[17:42:34.563]                       future <- run(future)
[17:42:34.563]                     invisible(future)
[17:42:34.563]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.563]                 }
[17:42:34.563]             }
[17:42:34.563]         }
[17:42:34.563]     })
[17:42:34.563]     if (TRUE) {
[17:42:34.563]         base::sink(type = "output", split = FALSE)
[17:42:34.563]         if (TRUE) {
[17:42:34.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:34.563]         }
[17:42:34.563]         else {
[17:42:34.563]             ...future.result["stdout"] <- base::list(NULL)
[17:42:34.563]         }
[17:42:34.563]         base::close(...future.stdout)
[17:42:34.563]         ...future.stdout <- NULL
[17:42:34.563]     }
[17:42:34.563]     ...future.result$conditions <- ...future.conditions
[17:42:34.563]     ...future.result$finished <- base::Sys.time()
[17:42:34.563]     ...future.result
[17:42:34.563] }
[17:42:34.566] requestCore(): workers = 2
[17:42:34.568] MulticoreFuture started
[17:42:34.569] - Launch lazy future ... done
[17:42:34.569] run() for ‘MulticoreFuture’ ... done
[17:42:34.569] plan(): Setting new future strategy stack:
[17:42:34.570] List of future strategies:
[17:42:34.570] 1. sequential:
[17:42:34.570]    - args: function (..., envir = parent.frame())
[17:42:34.570]    - tweaked: FALSE
[17:42:34.570]    - call: NULL
[17:42:34.570] plan(): nbrOfWorkers() = 1
[17:42:34.572] plan(): Setting new future strategy stack:
[17:42:34.573] List of future strategies:
[17:42:34.573] 1. multicore:
[17:42:34.573]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:34.573]    - tweaked: FALSE
[17:42:34.573]    - call: plan(strategy)
[17:42:34.578] plan(): nbrOfWorkers() = 2
[17:42:34.583] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:34.583] Searching for globals...
[17:42:34.584] - globals found: [1] ‘getOption’
[17:42:34.584] Searching for globals ... DONE
[17:42:34.584] Resolving globals: FALSE
[17:42:34.584] 
[17:42:34.584] 
[17:42:34.585] getGlobalsAndPackages() ... DONE
[17:42:34.585] run() for ‘Future’ ...
[17:42:34.585] - state: ‘created’
[17:42:34.585] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:34.589] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:34.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:34.589]   - Field: ‘label’
[17:42:34.590]   - Field: ‘local’
[17:42:34.590]   - Field: ‘owner’
[17:42:34.590]   - Field: ‘envir’
[17:42:34.592]   - Field: ‘workers’
[17:42:34.593]   - Field: ‘packages’
[17:42:34.593]   - Field: ‘gc’
[17:42:34.593]   - Field: ‘job’
[17:42:34.593]   - Field: ‘conditions’
[17:42:34.593]   - Field: ‘expr’
[17:42:34.593]   - Field: ‘uuid’
[17:42:34.593]   - Field: ‘seed’
[17:42:34.593]   - Field: ‘version’
[17:42:34.594]   - Field: ‘result’
[17:42:34.594]   - Field: ‘asynchronous’
[17:42:34.594]   - Field: ‘calls’
[17:42:34.594]   - Field: ‘globals’
[17:42:34.594]   - Field: ‘stdout’
[17:42:34.594]   - Field: ‘earlySignal’
[17:42:34.594]   - Field: ‘lazy’
[17:42:34.595]   - Field: ‘state’
[17:42:34.595] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:34.595] - Launch lazy future ...
[17:42:34.595] Packages needed by the future expression (n = 0): <none>
[17:42:34.595] Packages needed by future strategies (n = 0): <none>
[17:42:34.596] {
[17:42:34.596]     {
[17:42:34.596]         {
[17:42:34.596]             ...future.startTime <- base::Sys.time()
[17:42:34.596]             {
[17:42:34.596]                 {
[17:42:34.596]                   {
[17:42:34.596]                     {
[17:42:34.596]                       base::local({
[17:42:34.596]                         has_future <- base::requireNamespace("future", 
[17:42:34.596]                           quietly = TRUE)
[17:42:34.596]                         if (has_future) {
[17:42:34.596]                           ns <- base::getNamespace("future")
[17:42:34.596]                           version <- ns[[".package"]][["version"]]
[17:42:34.596]                           if (is.null(version)) 
[17:42:34.596]                             version <- utils::packageVersion("future")
[17:42:34.596]                         }
[17:42:34.596]                         else {
[17:42:34.596]                           version <- NULL
[17:42:34.596]                         }
[17:42:34.596]                         if (!has_future || version < "1.8.0") {
[17:42:34.596]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:34.596]                             "", base::R.version$version.string), 
[17:42:34.596]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:34.596]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:34.596]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:34.596]                               "release", "version")], collapse = " "), 
[17:42:34.596]                             hostname = base::Sys.info()[["nodename"]])
[17:42:34.596]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:34.596]                             info)
[17:42:34.596]                           info <- base::paste(info, collapse = "; ")
[17:42:34.596]                           if (!has_future) {
[17:42:34.596]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:34.596]                               info)
[17:42:34.596]                           }
[17:42:34.596]                           else {
[17:42:34.596]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:34.596]                               info, version)
[17:42:34.596]                           }
[17:42:34.596]                           base::stop(msg)
[17:42:34.596]                         }
[17:42:34.596]                       })
[17:42:34.596]                     }
[17:42:34.596]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:34.596]                     base::options(mc.cores = 1L)
[17:42:34.596]                   }
[17:42:34.596]                   options(future.plan = NULL)
[17:42:34.596]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.596]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:34.596]                 }
[17:42:34.596]                 ...future.workdir <- getwd()
[17:42:34.596]             }
[17:42:34.596]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:34.596]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:34.596]         }
[17:42:34.596]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:34.596]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:34.596]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:34.596]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:34.596]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:34.596]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:34.596]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:34.596]             base::names(...future.oldOptions))
[17:42:34.596]     }
[17:42:34.596]     if (FALSE) {
[17:42:34.596]     }
[17:42:34.596]     else {
[17:42:34.596]         if (TRUE) {
[17:42:34.596]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:34.596]                 open = "w")
[17:42:34.596]         }
[17:42:34.596]         else {
[17:42:34.596]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:34.596]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:34.596]         }
[17:42:34.596]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:34.596]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:34.596]             base::sink(type = "output", split = FALSE)
[17:42:34.596]             base::close(...future.stdout)
[17:42:34.596]         }, add = TRUE)
[17:42:34.596]     }
[17:42:34.596]     ...future.frame <- base::sys.nframe()
[17:42:34.596]     ...future.conditions <- base::list()
[17:42:34.596]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:34.596]     if (FALSE) {
[17:42:34.596]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:34.596]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:34.596]     }
[17:42:34.596]     ...future.result <- base::tryCatch({
[17:42:34.596]         base::withCallingHandlers({
[17:42:34.596]             ...future.value <- base::withVisible(base::local({
[17:42:34.596]                 withCallingHandlers({
[17:42:34.596]                   getOption("future.globals.onMissing")
[17:42:34.596]                 }, immediateCondition = function(cond) {
[17:42:34.596]                   save_rds <- function (object, pathname, ...) 
[17:42:34.596]                   {
[17:42:34.596]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:34.596]                     if (file_test("-f", pathname_tmp)) {
[17:42:34.596]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.596]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:34.596]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.596]                         fi_tmp[["mtime"]])
[17:42:34.596]                     }
[17:42:34.596]                     tryCatch({
[17:42:34.596]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:34.596]                     }, error = function(ex) {
[17:42:34.596]                       msg <- conditionMessage(ex)
[17:42:34.596]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.596]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:34.596]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.596]                         fi_tmp[["mtime"]], msg)
[17:42:34.596]                       ex$message <- msg
[17:42:34.596]                       stop(ex)
[17:42:34.596]                     })
[17:42:34.596]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:34.596]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:34.596]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:34.596]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.596]                       fi <- file.info(pathname)
[17:42:34.596]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:34.596]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.596]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:34.596]                         fi[["size"]], fi[["mtime"]])
[17:42:34.596]                       stop(msg)
[17:42:34.596]                     }
[17:42:34.596]                     invisible(pathname)
[17:42:34.596]                   }
[17:42:34.596]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:34.596]                     rootPath = tempdir()) 
[17:42:34.596]                   {
[17:42:34.596]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:34.596]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:34.596]                       tmpdir = path, fileext = ".rds")
[17:42:34.596]                     save_rds(obj, file)
[17:42:34.596]                   }
[17:42:34.596]                   saveImmediateCondition(cond, path = "/tmp/RtmpND951N/.future/immediateConditions")
[17:42:34.596]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.596]                   {
[17:42:34.596]                     inherits <- base::inherits
[17:42:34.596]                     invokeRestart <- base::invokeRestart
[17:42:34.596]                     is.null <- base::is.null
[17:42:34.596]                     muffled <- FALSE
[17:42:34.596]                     if (inherits(cond, "message")) {
[17:42:34.596]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:34.596]                       if (muffled) 
[17:42:34.596]                         invokeRestart("muffleMessage")
[17:42:34.596]                     }
[17:42:34.596]                     else if (inherits(cond, "warning")) {
[17:42:34.596]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:34.596]                       if (muffled) 
[17:42:34.596]                         invokeRestart("muffleWarning")
[17:42:34.596]                     }
[17:42:34.596]                     else if (inherits(cond, "condition")) {
[17:42:34.596]                       if (!is.null(pattern)) {
[17:42:34.596]                         computeRestarts <- base::computeRestarts
[17:42:34.596]                         grepl <- base::grepl
[17:42:34.596]                         restarts <- computeRestarts(cond)
[17:42:34.596]                         for (restart in restarts) {
[17:42:34.596]                           name <- restart$name
[17:42:34.596]                           if (is.null(name)) 
[17:42:34.596]                             next
[17:42:34.596]                           if (!grepl(pattern, name)) 
[17:42:34.596]                             next
[17:42:34.596]                           invokeRestart(restart)
[17:42:34.596]                           muffled <- TRUE
[17:42:34.596]                           break
[17:42:34.596]                         }
[17:42:34.596]                       }
[17:42:34.596]                     }
[17:42:34.596]                     invisible(muffled)
[17:42:34.596]                   }
[17:42:34.596]                   muffleCondition(cond)
[17:42:34.596]                 })
[17:42:34.596]             }))
[17:42:34.596]             future::FutureResult(value = ...future.value$value, 
[17:42:34.596]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.596]                   ...future.rng), globalenv = if (FALSE) 
[17:42:34.596]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:34.596]                     ...future.globalenv.names))
[17:42:34.596]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:34.596]         }, condition = base::local({
[17:42:34.596]             c <- base::c
[17:42:34.596]             inherits <- base::inherits
[17:42:34.596]             invokeRestart <- base::invokeRestart
[17:42:34.596]             length <- base::length
[17:42:34.596]             list <- base::list
[17:42:34.596]             seq.int <- base::seq.int
[17:42:34.596]             signalCondition <- base::signalCondition
[17:42:34.596]             sys.calls <- base::sys.calls
[17:42:34.596]             `[[` <- base::`[[`
[17:42:34.596]             `+` <- base::`+`
[17:42:34.596]             `<<-` <- base::`<<-`
[17:42:34.596]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:34.596]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:34.596]                   3L)]
[17:42:34.596]             }
[17:42:34.596]             function(cond) {
[17:42:34.596]                 is_error <- inherits(cond, "error")
[17:42:34.596]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:34.596]                   NULL)
[17:42:34.596]                 if (is_error) {
[17:42:34.596]                   sessionInformation <- function() {
[17:42:34.596]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:34.596]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:34.596]                       search = base::search(), system = base::Sys.info())
[17:42:34.596]                   }
[17:42:34.596]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.596]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:34.596]                     cond$call), session = sessionInformation(), 
[17:42:34.596]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:34.596]                   signalCondition(cond)
[17:42:34.596]                 }
[17:42:34.596]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:34.596]                 "immediateCondition"))) {
[17:42:34.596]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:34.596]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.596]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:34.596]                   if (TRUE && !signal) {
[17:42:34.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.596]                     {
[17:42:34.596]                       inherits <- base::inherits
[17:42:34.596]                       invokeRestart <- base::invokeRestart
[17:42:34.596]                       is.null <- base::is.null
[17:42:34.596]                       muffled <- FALSE
[17:42:34.596]                       if (inherits(cond, "message")) {
[17:42:34.596]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.596]                         if (muffled) 
[17:42:34.596]                           invokeRestart("muffleMessage")
[17:42:34.596]                       }
[17:42:34.596]                       else if (inherits(cond, "warning")) {
[17:42:34.596]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.596]                         if (muffled) 
[17:42:34.596]                           invokeRestart("muffleWarning")
[17:42:34.596]                       }
[17:42:34.596]                       else if (inherits(cond, "condition")) {
[17:42:34.596]                         if (!is.null(pattern)) {
[17:42:34.596]                           computeRestarts <- base::computeRestarts
[17:42:34.596]                           grepl <- base::grepl
[17:42:34.596]                           restarts <- computeRestarts(cond)
[17:42:34.596]                           for (restart in restarts) {
[17:42:34.596]                             name <- restart$name
[17:42:34.596]                             if (is.null(name)) 
[17:42:34.596]                               next
[17:42:34.596]                             if (!grepl(pattern, name)) 
[17:42:34.596]                               next
[17:42:34.596]                             invokeRestart(restart)
[17:42:34.596]                             muffled <- TRUE
[17:42:34.596]                             break
[17:42:34.596]                           }
[17:42:34.596]                         }
[17:42:34.596]                       }
[17:42:34.596]                       invisible(muffled)
[17:42:34.596]                     }
[17:42:34.596]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.596]                   }
[17:42:34.596]                 }
[17:42:34.596]                 else {
[17:42:34.596]                   if (TRUE) {
[17:42:34.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.596]                     {
[17:42:34.596]                       inherits <- base::inherits
[17:42:34.596]                       invokeRestart <- base::invokeRestart
[17:42:34.596]                       is.null <- base::is.null
[17:42:34.596]                       muffled <- FALSE
[17:42:34.596]                       if (inherits(cond, "message")) {
[17:42:34.596]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.596]                         if (muffled) 
[17:42:34.596]                           invokeRestart("muffleMessage")
[17:42:34.596]                       }
[17:42:34.596]                       else if (inherits(cond, "warning")) {
[17:42:34.596]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.596]                         if (muffled) 
[17:42:34.596]                           invokeRestart("muffleWarning")
[17:42:34.596]                       }
[17:42:34.596]                       else if (inherits(cond, "condition")) {
[17:42:34.596]                         if (!is.null(pattern)) {
[17:42:34.596]                           computeRestarts <- base::computeRestarts
[17:42:34.596]                           grepl <- base::grepl
[17:42:34.596]                           restarts <- computeRestarts(cond)
[17:42:34.596]                           for (restart in restarts) {
[17:42:34.596]                             name <- restart$name
[17:42:34.596]                             if (is.null(name)) 
[17:42:34.596]                               next
[17:42:34.596]                             if (!grepl(pattern, name)) 
[17:42:34.596]                               next
[17:42:34.596]                             invokeRestart(restart)
[17:42:34.596]                             muffled <- TRUE
[17:42:34.596]                             break
[17:42:34.596]                           }
[17:42:34.596]                         }
[17:42:34.596]                       }
[17:42:34.596]                       invisible(muffled)
[17:42:34.596]                     }
[17:42:34.596]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.596]                   }
[17:42:34.596]                 }
[17:42:34.596]             }
[17:42:34.596]         }))
[17:42:34.596]     }, error = function(ex) {
[17:42:34.596]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:34.596]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.596]                 ...future.rng), started = ...future.startTime, 
[17:42:34.596]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:34.596]             version = "1.8"), class = "FutureResult")
[17:42:34.596]     }, finally = {
[17:42:34.596]         if (!identical(...future.workdir, getwd())) 
[17:42:34.596]             setwd(...future.workdir)
[17:42:34.596]         {
[17:42:34.596]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:34.596]                 ...future.oldOptions$nwarnings <- NULL
[17:42:34.596]             }
[17:42:34.596]             base::options(...future.oldOptions)
[17:42:34.596]             if (.Platform$OS.type == "windows") {
[17:42:34.596]                 old_names <- names(...future.oldEnvVars)
[17:42:34.596]                 envs <- base::Sys.getenv()
[17:42:34.596]                 names <- names(envs)
[17:42:34.596]                 common <- intersect(names, old_names)
[17:42:34.596]                 added <- setdiff(names, old_names)
[17:42:34.596]                 removed <- setdiff(old_names, names)
[17:42:34.596]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:34.596]                   envs[common]]
[17:42:34.596]                 NAMES <- toupper(changed)
[17:42:34.596]                 args <- list()
[17:42:34.596]                 for (kk in seq_along(NAMES)) {
[17:42:34.596]                   name <- changed[[kk]]
[17:42:34.596]                   NAME <- NAMES[[kk]]
[17:42:34.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.596]                     next
[17:42:34.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.596]                 }
[17:42:34.596]                 NAMES <- toupper(added)
[17:42:34.596]                 for (kk in seq_along(NAMES)) {
[17:42:34.596]                   name <- added[[kk]]
[17:42:34.596]                   NAME <- NAMES[[kk]]
[17:42:34.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.596]                     next
[17:42:34.596]                   args[[name]] <- ""
[17:42:34.596]                 }
[17:42:34.596]                 NAMES <- toupper(removed)
[17:42:34.596]                 for (kk in seq_along(NAMES)) {
[17:42:34.596]                   name <- removed[[kk]]
[17:42:34.596]                   NAME <- NAMES[[kk]]
[17:42:34.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.596]                     next
[17:42:34.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.596]                 }
[17:42:34.596]                 if (length(args) > 0) 
[17:42:34.596]                   base::do.call(base::Sys.setenv, args = args)
[17:42:34.596]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:34.596]             }
[17:42:34.596]             else {
[17:42:34.596]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:34.596]             }
[17:42:34.596]             {
[17:42:34.596]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:34.596]                   0L) {
[17:42:34.596]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:34.596]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:34.596]                   base::options(opts)
[17:42:34.596]                 }
[17:42:34.596]                 {
[17:42:34.596]                   {
[17:42:34.596]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:34.596]                     NULL
[17:42:34.596]                   }
[17:42:34.596]                   options(future.plan = NULL)
[17:42:34.596]                   if (is.na(NA_character_)) 
[17:42:34.596]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.596]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:34.596]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:34.596]                     envir = parent.frame()) 
[17:42:34.596]                   {
[17:42:34.596]                     default_workers <- missing(workers)
[17:42:34.596]                     if (is.function(workers)) 
[17:42:34.596]                       workers <- workers()
[17:42:34.596]                     workers <- structure(as.integer(workers), 
[17:42:34.596]                       class = class(workers))
[17:42:34.596]                     stop_if_not(is.finite(workers), workers >= 
[17:42:34.596]                       1L)
[17:42:34.596]                     if ((workers == 1L && !inherits(workers, 
[17:42:34.596]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:34.596]                       if (default_workers) 
[17:42:34.596]                         supportsMulticore(warn = TRUE)
[17:42:34.596]                       return(sequential(..., envir = envir))
[17:42:34.596]                     }
[17:42:34.596]                     oopts <- options(mc.cores = workers)
[17:42:34.596]                     on.exit(options(oopts))
[17:42:34.596]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:34.596]                       envir = envir)
[17:42:34.596]                     if (!future$lazy) 
[17:42:34.596]                       future <- run(future)
[17:42:34.596]                     invisible(future)
[17:42:34.596]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.596]                 }
[17:42:34.596]             }
[17:42:34.596]         }
[17:42:34.596]     })
[17:42:34.596]     if (TRUE) {
[17:42:34.596]         base::sink(type = "output", split = FALSE)
[17:42:34.596]         if (TRUE) {
[17:42:34.596]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:34.596]         }
[17:42:34.596]         else {
[17:42:34.596]             ...future.result["stdout"] <- base::list(NULL)
[17:42:34.596]         }
[17:42:34.596]         base::close(...future.stdout)
[17:42:34.596]         ...future.stdout <- NULL
[17:42:34.596]     }
[17:42:34.596]     ...future.result$conditions <- ...future.conditions
[17:42:34.596]     ...future.result$finished <- base::Sys.time()
[17:42:34.596]     ...future.result
[17:42:34.596] }
[17:42:34.598] requestCore(): workers = 2
[17:42:34.600] MulticoreFuture started
[17:42:34.600] - Launch lazy future ... done
[17:42:34.601] run() for ‘MulticoreFuture’ ... done
[17:42:34.601] plan(): Setting new future strategy stack:
[17:42:34.601] List of future strategies:
[17:42:34.601] 1. sequential:
[17:42:34.601]    - args: function (..., envir = parent.frame())
[17:42:34.601]    - tweaked: FALSE
[17:42:34.601]    - call: NULL
[17:42:34.602] plan(): nbrOfWorkers() = 1
[17:42:34.604] plan(): Setting new future strategy stack:
[17:42:34.604] List of future strategies:
[17:42:34.604] 1. multicore:
[17:42:34.604]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:34.604]    - tweaked: FALSE
[17:42:34.604]    - call: plan(strategy)
[17:42:34.610] plan(): nbrOfWorkers() = 2
[17:42:34.611] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:34.612] Searching for globals...
[17:42:34.614] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:34.614] Searching for globals...
[17:42:34.615] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[17:42:34.615] Searching for globals ... DONE
[17:42:34.615] Resolving globals: FALSE
[17:42:34.616] The total size of the 1 globals is 160 bytes (160 bytes)
[17:42:34.616] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[17:42:34.617] - globals: [1] ‘data’
[17:42:34.617] 
[17:42:34.617] getGlobalsAndPackages() ... DONE
[17:42:34.617] run() for ‘Future’ ...
[17:42:34.617] - state: ‘created’
[17:42:34.617] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:34.621] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:34.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:34.622]   - Field: ‘label’
[17:42:34.622]   - Field: ‘local’
[17:42:34.622]   - Field: ‘owner’
[17:42:34.622]   - Field: ‘envir’
[17:42:34.622]   - Field: ‘workers’
[17:42:34.622]   - Field: ‘packages’
[17:42:34.622]   - Field: ‘gc’
[17:42:34.622]   - Field: ‘job’
[17:42:34.623]   - Field: ‘conditions’
[17:42:34.623]   - Field: ‘expr’
[17:42:34.623]   - Field: ‘uuid’
[17:42:34.623]   - Field: ‘seed’
[17:42:34.623]   - Field: ‘version’
[17:42:34.623]   - Field: ‘result’
[17:42:34.623]   - Field: ‘asynchronous’
[17:42:34.623]   - Field: ‘calls’
[17:42:34.624]   - Field: ‘globals’
[17:42:34.624]   - Field: ‘stdout’
[17:42:34.624]   - Field: ‘earlySignal’
[17:42:34.624]   - Field: ‘lazy’
[17:42:34.624]   - Field: ‘state’
[17:42:34.624] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:34.624] - Launch lazy future ...
[17:42:34.625] Packages needed by the future expression (n = 0): <none>
[17:42:34.625] Packages needed by future strategies (n = 0): <none>
[17:42:34.625] {
[17:42:34.625]     {
[17:42:34.625]         {
[17:42:34.625]             ...future.startTime <- base::Sys.time()
[17:42:34.625]             {
[17:42:34.625]                 {
[17:42:34.625]                   {
[17:42:34.625]                     {
[17:42:34.625]                       base::local({
[17:42:34.625]                         has_future <- base::requireNamespace("future", 
[17:42:34.625]                           quietly = TRUE)
[17:42:34.625]                         if (has_future) {
[17:42:34.625]                           ns <- base::getNamespace("future")
[17:42:34.625]                           version <- ns[[".package"]][["version"]]
[17:42:34.625]                           if (is.null(version)) 
[17:42:34.625]                             version <- utils::packageVersion("future")
[17:42:34.625]                         }
[17:42:34.625]                         else {
[17:42:34.625]                           version <- NULL
[17:42:34.625]                         }
[17:42:34.625]                         if (!has_future || version < "1.8.0") {
[17:42:34.625]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:34.625]                             "", base::R.version$version.string), 
[17:42:34.625]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:34.625]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:34.625]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:34.625]                               "release", "version")], collapse = " "), 
[17:42:34.625]                             hostname = base::Sys.info()[["nodename"]])
[17:42:34.625]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:34.625]                             info)
[17:42:34.625]                           info <- base::paste(info, collapse = "; ")
[17:42:34.625]                           if (!has_future) {
[17:42:34.625]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:34.625]                               info)
[17:42:34.625]                           }
[17:42:34.625]                           else {
[17:42:34.625]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:34.625]                               info, version)
[17:42:34.625]                           }
[17:42:34.625]                           base::stop(msg)
[17:42:34.625]                         }
[17:42:34.625]                       })
[17:42:34.625]                     }
[17:42:34.625]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:34.625]                     base::options(mc.cores = 1L)
[17:42:34.625]                   }
[17:42:34.625]                   options(future.plan = NULL)
[17:42:34.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:34.625]                 }
[17:42:34.625]                 ...future.workdir <- getwd()
[17:42:34.625]             }
[17:42:34.625]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:34.625]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:34.625]         }
[17:42:34.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:34.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:34.625]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:34.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:34.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:34.625]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:34.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:34.625]             base::names(...future.oldOptions))
[17:42:34.625]     }
[17:42:34.625]     if (FALSE) {
[17:42:34.625]     }
[17:42:34.625]     else {
[17:42:34.625]         if (TRUE) {
[17:42:34.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:34.625]                 open = "w")
[17:42:34.625]         }
[17:42:34.625]         else {
[17:42:34.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:34.625]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:34.625]         }
[17:42:34.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:34.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:34.625]             base::sink(type = "output", split = FALSE)
[17:42:34.625]             base::close(...future.stdout)
[17:42:34.625]         }, add = TRUE)
[17:42:34.625]     }
[17:42:34.625]     ...future.frame <- base::sys.nframe()
[17:42:34.625]     ...future.conditions <- base::list()
[17:42:34.625]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:34.625]     if (FALSE) {
[17:42:34.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:34.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:34.625]     }
[17:42:34.625]     ...future.result <- base::tryCatch({
[17:42:34.625]         base::withCallingHandlers({
[17:42:34.625]             ...future.value <- base::withVisible(base::local({
[17:42:34.625]                 withCallingHandlers({
[17:42:34.625]                   subset(data, x < 3)$y
[17:42:34.625]                 }, immediateCondition = function(cond) {
[17:42:34.625]                   save_rds <- function (object, pathname, ...) 
[17:42:34.625]                   {
[17:42:34.625]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:34.625]                     if (file_test("-f", pathname_tmp)) {
[17:42:34.625]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.625]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:34.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.625]                         fi_tmp[["mtime"]])
[17:42:34.625]                     }
[17:42:34.625]                     tryCatch({
[17:42:34.625]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:34.625]                     }, error = function(ex) {
[17:42:34.625]                       msg <- conditionMessage(ex)
[17:42:34.625]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.625]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:34.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.625]                         fi_tmp[["mtime"]], msg)
[17:42:34.625]                       ex$message <- msg
[17:42:34.625]                       stop(ex)
[17:42:34.625]                     })
[17:42:34.625]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:34.625]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:34.625]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:34.625]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.625]                       fi <- file.info(pathname)
[17:42:34.625]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:34.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.625]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:34.625]                         fi[["size"]], fi[["mtime"]])
[17:42:34.625]                       stop(msg)
[17:42:34.625]                     }
[17:42:34.625]                     invisible(pathname)
[17:42:34.625]                   }
[17:42:34.625]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:34.625]                     rootPath = tempdir()) 
[17:42:34.625]                   {
[17:42:34.625]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:34.625]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:34.625]                       tmpdir = path, fileext = ".rds")
[17:42:34.625]                     save_rds(obj, file)
[17:42:34.625]                   }
[17:42:34.625]                   saveImmediateCondition(cond, path = "/tmp/RtmpND951N/.future/immediateConditions")
[17:42:34.625]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.625]                   {
[17:42:34.625]                     inherits <- base::inherits
[17:42:34.625]                     invokeRestart <- base::invokeRestart
[17:42:34.625]                     is.null <- base::is.null
[17:42:34.625]                     muffled <- FALSE
[17:42:34.625]                     if (inherits(cond, "message")) {
[17:42:34.625]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:34.625]                       if (muffled) 
[17:42:34.625]                         invokeRestart("muffleMessage")
[17:42:34.625]                     }
[17:42:34.625]                     else if (inherits(cond, "warning")) {
[17:42:34.625]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:34.625]                       if (muffled) 
[17:42:34.625]                         invokeRestart("muffleWarning")
[17:42:34.625]                     }
[17:42:34.625]                     else if (inherits(cond, "condition")) {
[17:42:34.625]                       if (!is.null(pattern)) {
[17:42:34.625]                         computeRestarts <- base::computeRestarts
[17:42:34.625]                         grepl <- base::grepl
[17:42:34.625]                         restarts <- computeRestarts(cond)
[17:42:34.625]                         for (restart in restarts) {
[17:42:34.625]                           name <- restart$name
[17:42:34.625]                           if (is.null(name)) 
[17:42:34.625]                             next
[17:42:34.625]                           if (!grepl(pattern, name)) 
[17:42:34.625]                             next
[17:42:34.625]                           invokeRestart(restart)
[17:42:34.625]                           muffled <- TRUE
[17:42:34.625]                           break
[17:42:34.625]                         }
[17:42:34.625]                       }
[17:42:34.625]                     }
[17:42:34.625]                     invisible(muffled)
[17:42:34.625]                   }
[17:42:34.625]                   muffleCondition(cond)
[17:42:34.625]                 })
[17:42:34.625]             }))
[17:42:34.625]             future::FutureResult(value = ...future.value$value, 
[17:42:34.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.625]                   ...future.rng), globalenv = if (FALSE) 
[17:42:34.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:34.625]                     ...future.globalenv.names))
[17:42:34.625]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:34.625]         }, condition = base::local({
[17:42:34.625]             c <- base::c
[17:42:34.625]             inherits <- base::inherits
[17:42:34.625]             invokeRestart <- base::invokeRestart
[17:42:34.625]             length <- base::length
[17:42:34.625]             list <- base::list
[17:42:34.625]             seq.int <- base::seq.int
[17:42:34.625]             signalCondition <- base::signalCondition
[17:42:34.625]             sys.calls <- base::sys.calls
[17:42:34.625]             `[[` <- base::`[[`
[17:42:34.625]             `+` <- base::`+`
[17:42:34.625]             `<<-` <- base::`<<-`
[17:42:34.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:34.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:34.625]                   3L)]
[17:42:34.625]             }
[17:42:34.625]             function(cond) {
[17:42:34.625]                 is_error <- inherits(cond, "error")
[17:42:34.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:34.625]                   NULL)
[17:42:34.625]                 if (is_error) {
[17:42:34.625]                   sessionInformation <- function() {
[17:42:34.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:34.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:34.625]                       search = base::search(), system = base::Sys.info())
[17:42:34.625]                   }
[17:42:34.625]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:34.625]                     cond$call), session = sessionInformation(), 
[17:42:34.625]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:34.625]                   signalCondition(cond)
[17:42:34.625]                 }
[17:42:34.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:34.625]                 "immediateCondition"))) {
[17:42:34.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:34.625]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:34.625]                   if (TRUE && !signal) {
[17:42:34.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.625]                     {
[17:42:34.625]                       inherits <- base::inherits
[17:42:34.625]                       invokeRestart <- base::invokeRestart
[17:42:34.625]                       is.null <- base::is.null
[17:42:34.625]                       muffled <- FALSE
[17:42:34.625]                       if (inherits(cond, "message")) {
[17:42:34.625]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.625]                         if (muffled) 
[17:42:34.625]                           invokeRestart("muffleMessage")
[17:42:34.625]                       }
[17:42:34.625]                       else if (inherits(cond, "warning")) {
[17:42:34.625]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.625]                         if (muffled) 
[17:42:34.625]                           invokeRestart("muffleWarning")
[17:42:34.625]                       }
[17:42:34.625]                       else if (inherits(cond, "condition")) {
[17:42:34.625]                         if (!is.null(pattern)) {
[17:42:34.625]                           computeRestarts <- base::computeRestarts
[17:42:34.625]                           grepl <- base::grepl
[17:42:34.625]                           restarts <- computeRestarts(cond)
[17:42:34.625]                           for (restart in restarts) {
[17:42:34.625]                             name <- restart$name
[17:42:34.625]                             if (is.null(name)) 
[17:42:34.625]                               next
[17:42:34.625]                             if (!grepl(pattern, name)) 
[17:42:34.625]                               next
[17:42:34.625]                             invokeRestart(restart)
[17:42:34.625]                             muffled <- TRUE
[17:42:34.625]                             break
[17:42:34.625]                           }
[17:42:34.625]                         }
[17:42:34.625]                       }
[17:42:34.625]                       invisible(muffled)
[17:42:34.625]                     }
[17:42:34.625]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.625]                   }
[17:42:34.625]                 }
[17:42:34.625]                 else {
[17:42:34.625]                   if (TRUE) {
[17:42:34.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.625]                     {
[17:42:34.625]                       inherits <- base::inherits
[17:42:34.625]                       invokeRestart <- base::invokeRestart
[17:42:34.625]                       is.null <- base::is.null
[17:42:34.625]                       muffled <- FALSE
[17:42:34.625]                       if (inherits(cond, "message")) {
[17:42:34.625]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.625]                         if (muffled) 
[17:42:34.625]                           invokeRestart("muffleMessage")
[17:42:34.625]                       }
[17:42:34.625]                       else if (inherits(cond, "warning")) {
[17:42:34.625]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.625]                         if (muffled) 
[17:42:34.625]                           invokeRestart("muffleWarning")
[17:42:34.625]                       }
[17:42:34.625]                       else if (inherits(cond, "condition")) {
[17:42:34.625]                         if (!is.null(pattern)) {
[17:42:34.625]                           computeRestarts <- base::computeRestarts
[17:42:34.625]                           grepl <- base::grepl
[17:42:34.625]                           restarts <- computeRestarts(cond)
[17:42:34.625]                           for (restart in restarts) {
[17:42:34.625]                             name <- restart$name
[17:42:34.625]                             if (is.null(name)) 
[17:42:34.625]                               next
[17:42:34.625]                             if (!grepl(pattern, name)) 
[17:42:34.625]                               next
[17:42:34.625]                             invokeRestart(restart)
[17:42:34.625]                             muffled <- TRUE
[17:42:34.625]                             break
[17:42:34.625]                           }
[17:42:34.625]                         }
[17:42:34.625]                       }
[17:42:34.625]                       invisible(muffled)
[17:42:34.625]                     }
[17:42:34.625]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.625]                   }
[17:42:34.625]                 }
[17:42:34.625]             }
[17:42:34.625]         }))
[17:42:34.625]     }, error = function(ex) {
[17:42:34.625]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:34.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.625]                 ...future.rng), started = ...future.startTime, 
[17:42:34.625]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:34.625]             version = "1.8"), class = "FutureResult")
[17:42:34.625]     }, finally = {
[17:42:34.625]         if (!identical(...future.workdir, getwd())) 
[17:42:34.625]             setwd(...future.workdir)
[17:42:34.625]         {
[17:42:34.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:34.625]                 ...future.oldOptions$nwarnings <- NULL
[17:42:34.625]             }
[17:42:34.625]             base::options(...future.oldOptions)
[17:42:34.625]             if (.Platform$OS.type == "windows") {
[17:42:34.625]                 old_names <- names(...future.oldEnvVars)
[17:42:34.625]                 envs <- base::Sys.getenv()
[17:42:34.625]                 names <- names(envs)
[17:42:34.625]                 common <- intersect(names, old_names)
[17:42:34.625]                 added <- setdiff(names, old_names)
[17:42:34.625]                 removed <- setdiff(old_names, names)
[17:42:34.625]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:34.625]                   envs[common]]
[17:42:34.625]                 NAMES <- toupper(changed)
[17:42:34.625]                 args <- list()
[17:42:34.625]                 for (kk in seq_along(NAMES)) {
[17:42:34.625]                   name <- changed[[kk]]
[17:42:34.625]                   NAME <- NAMES[[kk]]
[17:42:34.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.625]                     next
[17:42:34.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.625]                 }
[17:42:34.625]                 NAMES <- toupper(added)
[17:42:34.625]                 for (kk in seq_along(NAMES)) {
[17:42:34.625]                   name <- added[[kk]]
[17:42:34.625]                   NAME <- NAMES[[kk]]
[17:42:34.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.625]                     next
[17:42:34.625]                   args[[name]] <- ""
[17:42:34.625]                 }
[17:42:34.625]                 NAMES <- toupper(removed)
[17:42:34.625]                 for (kk in seq_along(NAMES)) {
[17:42:34.625]                   name <- removed[[kk]]
[17:42:34.625]                   NAME <- NAMES[[kk]]
[17:42:34.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.625]                     next
[17:42:34.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.625]                 }
[17:42:34.625]                 if (length(args) > 0) 
[17:42:34.625]                   base::do.call(base::Sys.setenv, args = args)
[17:42:34.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:34.625]             }
[17:42:34.625]             else {
[17:42:34.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:34.625]             }
[17:42:34.625]             {
[17:42:34.625]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:34.625]                   0L) {
[17:42:34.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:34.625]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:34.625]                   base::options(opts)
[17:42:34.625]                 }
[17:42:34.625]                 {
[17:42:34.625]                   {
[17:42:34.625]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:34.625]                     NULL
[17:42:34.625]                   }
[17:42:34.625]                   options(future.plan = NULL)
[17:42:34.625]                   if (is.na(NA_character_)) 
[17:42:34.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:34.625]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:34.625]                     envir = parent.frame()) 
[17:42:34.625]                   {
[17:42:34.625]                     default_workers <- missing(workers)
[17:42:34.625]                     if (is.function(workers)) 
[17:42:34.625]                       workers <- workers()
[17:42:34.625]                     workers <- structure(as.integer(workers), 
[17:42:34.625]                       class = class(workers))
[17:42:34.625]                     stop_if_not(is.finite(workers), workers >= 
[17:42:34.625]                       1L)
[17:42:34.625]                     if ((workers == 1L && !inherits(workers, 
[17:42:34.625]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:34.625]                       if (default_workers) 
[17:42:34.625]                         supportsMulticore(warn = TRUE)
[17:42:34.625]                       return(sequential(..., envir = envir))
[17:42:34.625]                     }
[17:42:34.625]                     oopts <- options(mc.cores = workers)
[17:42:34.625]                     on.exit(options(oopts))
[17:42:34.625]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:34.625]                       envir = envir)
[17:42:34.625]                     if (!future$lazy) 
[17:42:34.625]                       future <- run(future)
[17:42:34.625]                     invisible(future)
[17:42:34.625]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.625]                 }
[17:42:34.625]             }
[17:42:34.625]         }
[17:42:34.625]     })
[17:42:34.625]     if (TRUE) {
[17:42:34.625]         base::sink(type = "output", split = FALSE)
[17:42:34.625]         if (TRUE) {
[17:42:34.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:34.625]         }
[17:42:34.625]         else {
[17:42:34.625]             ...future.result["stdout"] <- base::list(NULL)
[17:42:34.625]         }
[17:42:34.625]         base::close(...future.stdout)
[17:42:34.625]         ...future.stdout <- NULL
[17:42:34.625]     }
[17:42:34.625]     ...future.result$conditions <- ...future.conditions
[17:42:34.625]     ...future.result$finished <- base::Sys.time()
[17:42:34.625]     ...future.result
[17:42:34.625] }
[17:42:34.628] assign_globals() ...
[17:42:34.628] List of 1
[17:42:34.628]  $ data:'data.frame':	5 obs. of  2 variables:
[17:42:34.628]   ..$ x: int [1:5] 1 2 3 4 5
[17:42:34.628]   ..$ y: int [1:5] 1 2 3 4 5
[17:42:34.628]  - attr(*, "where")=List of 1
[17:42:34.628]   ..$ data:<environment: R_EmptyEnv> 
[17:42:34.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:34.628]  - attr(*, "resolved")= logi FALSE
[17:42:34.628]  - attr(*, "total_size")= num 160
[17:42:34.628]  - attr(*, "already-done")= logi TRUE
[17:42:34.632] - copied ‘data’ to environment
[17:42:34.632] assign_globals() ... done
[17:42:34.632] requestCore(): workers = 2
[17:42:34.634] MulticoreFuture started
[17:42:34.634] - Launch lazy future ... done
[17:42:34.635] run() for ‘MulticoreFuture’ ... done
[17:42:34.635] plan(): Setting new future strategy stack:
[17:42:34.636] List of future strategies:
[17:42:34.636] 1. sequential:
[17:42:34.636]    - args: function (..., envir = parent.frame())
[17:42:34.636]    - tweaked: FALSE
[17:42:34.636]    - call: NULL
[17:42:34.637] plan(): nbrOfWorkers() = 1
[17:42:34.639] plan(): Setting new future strategy stack:
[17:42:34.639] List of future strategies:
[17:42:34.639] 1. multicore:
[17:42:34.639]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:34.639]    - tweaked: FALSE
[17:42:34.639]    - call: plan(strategy)
[17:42:34.645] plan(): nbrOfWorkers() = 2
[17:42:34.646] plan(): Setting new future strategy stack:
[17:42:34.646] List of future strategies:
[17:42:34.646] 1. sequential:
[17:42:34.646]    - args: function (..., envir = parent.frame())
[17:42:34.646]    - tweaked: FALSE
[17:42:34.646]    - call: plan(list(sequential, strategy))
[17:42:34.646] 2. multicore:
[17:42:34.646]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:34.646]    - tweaked: FALSE
[17:42:34.646]    - call: plan(list(sequential, strategy))
[17:42:34.647] plan(): nbrOfWorkers() = 1
[17:42:34.647] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:34.648] Searching for globals...
[17:42:34.654] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[17:42:34.654] Searching for globals ... DONE
[17:42:34.654] Resolving globals: FALSE
[17:42:34.655] The total size of the 1 globals is 160 bytes (160 bytes)
[17:42:34.655] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[17:42:34.656] - globals: [1] ‘data’
[17:42:34.656] - packages: [1] ‘future’
[17:42:34.656] getGlobalsAndPackages() ... DONE
[17:42:34.656] run() for ‘Future’ ...
[17:42:34.657] - state: ‘created’
[17:42:34.657] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:34.657] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:34.657] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:34.657]   - Field: ‘label’
[17:42:34.658]   - Field: ‘local’
[17:42:34.658]   - Field: ‘owner’
[17:42:34.658]   - Field: ‘envir’
[17:42:34.658]   - Field: ‘packages’
[17:42:34.658]   - Field: ‘gc’
[17:42:34.658]   - Field: ‘conditions’
[17:42:34.658]   - Field: ‘expr’
[17:42:34.658]   - Field: ‘uuid’
[17:42:34.659]   - Field: ‘seed’
[17:42:34.659]   - Field: ‘version’
[17:42:34.659]   - Field: ‘result’
[17:42:34.659]   - Field: ‘asynchronous’
[17:42:34.659]   - Field: ‘calls’
[17:42:34.659]   - Field: ‘globals’
[17:42:34.659]   - Field: ‘stdout’
[17:42:34.659]   - Field: ‘earlySignal’
[17:42:34.660]   - Field: ‘lazy’
[17:42:34.660]   - Field: ‘state’
[17:42:34.660] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:34.660] - Launch lazy future ...
[17:42:34.660] Packages needed by the future expression (n = 1): ‘future’
[17:42:34.660] Packages needed by future strategies (n = 1): ‘future’
[17:42:34.661] {
[17:42:34.661]     {
[17:42:34.661]         {
[17:42:34.661]             ...future.startTime <- base::Sys.time()
[17:42:34.661]             {
[17:42:34.661]                 {
[17:42:34.661]                   {
[17:42:34.661]                     {
[17:42:34.661]                       base::local({
[17:42:34.661]                         has_future <- base::requireNamespace("future", 
[17:42:34.661]                           quietly = TRUE)
[17:42:34.661]                         if (has_future) {
[17:42:34.661]                           ns <- base::getNamespace("future")
[17:42:34.661]                           version <- ns[[".package"]][["version"]]
[17:42:34.661]                           if (is.null(version)) 
[17:42:34.661]                             version <- utils::packageVersion("future")
[17:42:34.661]                         }
[17:42:34.661]                         else {
[17:42:34.661]                           version <- NULL
[17:42:34.661]                         }
[17:42:34.661]                         if (!has_future || version < "1.8.0") {
[17:42:34.661]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:34.661]                             "", base::R.version$version.string), 
[17:42:34.661]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:34.661]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:34.661]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:34.661]                               "release", "version")], collapse = " "), 
[17:42:34.661]                             hostname = base::Sys.info()[["nodename"]])
[17:42:34.661]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:34.661]                             info)
[17:42:34.661]                           info <- base::paste(info, collapse = "; ")
[17:42:34.661]                           if (!has_future) {
[17:42:34.661]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:34.661]                               info)
[17:42:34.661]                           }
[17:42:34.661]                           else {
[17:42:34.661]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:34.661]                               info, version)
[17:42:34.661]                           }
[17:42:34.661]                           base::stop(msg)
[17:42:34.661]                         }
[17:42:34.661]                       })
[17:42:34.661]                     }
[17:42:34.661]                     base::local({
[17:42:34.661]                       for (pkg in "future") {
[17:42:34.661]                         base::loadNamespace(pkg)
[17:42:34.661]                         base::library(pkg, character.only = TRUE)
[17:42:34.661]                       }
[17:42:34.661]                     })
[17:42:34.661]                   }
[17:42:34.661]                   options(future.plan = NULL)
[17:42:34.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.661]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:34.661]                     envir = parent.frame()) 
[17:42:34.661]                   {
[17:42:34.661]                     default_workers <- missing(workers)
[17:42:34.661]                     if (is.function(workers)) 
[17:42:34.661]                       workers <- workers()
[17:42:34.661]                     workers <- structure(as.integer(workers), 
[17:42:34.661]                       class = class(workers))
[17:42:34.661]                     stop_if_not(is.finite(workers), workers >= 
[17:42:34.661]                       1L)
[17:42:34.661]                     if ((workers == 1L && !inherits(workers, 
[17:42:34.661]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:34.661]                       if (default_workers) 
[17:42:34.661]                         supportsMulticore(warn = TRUE)
[17:42:34.661]                       return(sequential(..., envir = envir))
[17:42:34.661]                     }
[17:42:34.661]                     oopts <- options(mc.cores = workers)
[17:42:34.661]                     on.exit(options(oopts))
[17:42:34.661]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:34.661]                       envir = envir)
[17:42:34.661]                     if (!future$lazy) 
[17:42:34.661]                       future <- run(future)
[17:42:34.661]                     invisible(future)
[17:42:34.661]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.661]                 }
[17:42:34.661]                 ...future.workdir <- getwd()
[17:42:34.661]             }
[17:42:34.661]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:34.661]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:34.661]         }
[17:42:34.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:34.661]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:34.661]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:34.661]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:34.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:34.661]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:34.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:34.661]             base::names(...future.oldOptions))
[17:42:34.661]     }
[17:42:34.661]     if (FALSE) {
[17:42:34.661]     }
[17:42:34.661]     else {
[17:42:34.661]         if (TRUE) {
[17:42:34.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:34.661]                 open = "w")
[17:42:34.661]         }
[17:42:34.661]         else {
[17:42:34.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:34.661]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:34.661]         }
[17:42:34.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:34.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:34.661]             base::sink(type = "output", split = FALSE)
[17:42:34.661]             base::close(...future.stdout)
[17:42:34.661]         }, add = TRUE)
[17:42:34.661]     }
[17:42:34.661]     ...future.frame <- base::sys.nframe()
[17:42:34.661]     ...future.conditions <- base::list()
[17:42:34.661]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:34.661]     if (FALSE) {
[17:42:34.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:34.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:34.661]     }
[17:42:34.661]     ...future.result <- base::tryCatch({
[17:42:34.661]         base::withCallingHandlers({
[17:42:34.661]             ...future.value <- base::withVisible(base::local({
[17:42:34.661]                 a %<-% subset(data, x < 3)$y
[17:42:34.661]                 a
[17:42:34.661]             }))
[17:42:34.661]             future::FutureResult(value = ...future.value$value, 
[17:42:34.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.661]                   ...future.rng), globalenv = if (FALSE) 
[17:42:34.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:34.661]                     ...future.globalenv.names))
[17:42:34.661]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:34.661]         }, condition = base::local({
[17:42:34.661]             c <- base::c
[17:42:34.661]             inherits <- base::inherits
[17:42:34.661]             invokeRestart <- base::invokeRestart
[17:42:34.661]             length <- base::length
[17:42:34.661]             list <- base::list
[17:42:34.661]             seq.int <- base::seq.int
[17:42:34.661]             signalCondition <- base::signalCondition
[17:42:34.661]             sys.calls <- base::sys.calls
[17:42:34.661]             `[[` <- base::`[[`
[17:42:34.661]             `+` <- base::`+`
[17:42:34.661]             `<<-` <- base::`<<-`
[17:42:34.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:34.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:34.661]                   3L)]
[17:42:34.661]             }
[17:42:34.661]             function(cond) {
[17:42:34.661]                 is_error <- inherits(cond, "error")
[17:42:34.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:34.661]                   NULL)
[17:42:34.661]                 if (is_error) {
[17:42:34.661]                   sessionInformation <- function() {
[17:42:34.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:34.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:34.661]                       search = base::search(), system = base::Sys.info())
[17:42:34.661]                   }
[17:42:34.661]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:34.661]                     cond$call), session = sessionInformation(), 
[17:42:34.661]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:34.661]                   signalCondition(cond)
[17:42:34.661]                 }
[17:42:34.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:34.661]                 "immediateCondition"))) {
[17:42:34.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:34.661]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:34.661]                   if (TRUE && !signal) {
[17:42:34.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.661]                     {
[17:42:34.661]                       inherits <- base::inherits
[17:42:34.661]                       invokeRestart <- base::invokeRestart
[17:42:34.661]                       is.null <- base::is.null
[17:42:34.661]                       muffled <- FALSE
[17:42:34.661]                       if (inherits(cond, "message")) {
[17:42:34.661]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.661]                         if (muffled) 
[17:42:34.661]                           invokeRestart("muffleMessage")
[17:42:34.661]                       }
[17:42:34.661]                       else if (inherits(cond, "warning")) {
[17:42:34.661]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.661]                         if (muffled) 
[17:42:34.661]                           invokeRestart("muffleWarning")
[17:42:34.661]                       }
[17:42:34.661]                       else if (inherits(cond, "condition")) {
[17:42:34.661]                         if (!is.null(pattern)) {
[17:42:34.661]                           computeRestarts <- base::computeRestarts
[17:42:34.661]                           grepl <- base::grepl
[17:42:34.661]                           restarts <- computeRestarts(cond)
[17:42:34.661]                           for (restart in restarts) {
[17:42:34.661]                             name <- restart$name
[17:42:34.661]                             if (is.null(name)) 
[17:42:34.661]                               next
[17:42:34.661]                             if (!grepl(pattern, name)) 
[17:42:34.661]                               next
[17:42:34.661]                             invokeRestart(restart)
[17:42:34.661]                             muffled <- TRUE
[17:42:34.661]                             break
[17:42:34.661]                           }
[17:42:34.661]                         }
[17:42:34.661]                       }
[17:42:34.661]                       invisible(muffled)
[17:42:34.661]                     }
[17:42:34.661]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.661]                   }
[17:42:34.661]                 }
[17:42:34.661]                 else {
[17:42:34.661]                   if (TRUE) {
[17:42:34.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.661]                     {
[17:42:34.661]                       inherits <- base::inherits
[17:42:34.661]                       invokeRestart <- base::invokeRestart
[17:42:34.661]                       is.null <- base::is.null
[17:42:34.661]                       muffled <- FALSE
[17:42:34.661]                       if (inherits(cond, "message")) {
[17:42:34.661]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.661]                         if (muffled) 
[17:42:34.661]                           invokeRestart("muffleMessage")
[17:42:34.661]                       }
[17:42:34.661]                       else if (inherits(cond, "warning")) {
[17:42:34.661]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.661]                         if (muffled) 
[17:42:34.661]                           invokeRestart("muffleWarning")
[17:42:34.661]                       }
[17:42:34.661]                       else if (inherits(cond, "condition")) {
[17:42:34.661]                         if (!is.null(pattern)) {
[17:42:34.661]                           computeRestarts <- base::computeRestarts
[17:42:34.661]                           grepl <- base::grepl
[17:42:34.661]                           restarts <- computeRestarts(cond)
[17:42:34.661]                           for (restart in restarts) {
[17:42:34.661]                             name <- restart$name
[17:42:34.661]                             if (is.null(name)) 
[17:42:34.661]                               next
[17:42:34.661]                             if (!grepl(pattern, name)) 
[17:42:34.661]                               next
[17:42:34.661]                             invokeRestart(restart)
[17:42:34.661]                             muffled <- TRUE
[17:42:34.661]                             break
[17:42:34.661]                           }
[17:42:34.661]                         }
[17:42:34.661]                       }
[17:42:34.661]                       invisible(muffled)
[17:42:34.661]                     }
[17:42:34.661]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.661]                   }
[17:42:34.661]                 }
[17:42:34.661]             }
[17:42:34.661]         }))
[17:42:34.661]     }, error = function(ex) {
[17:42:34.661]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:34.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.661]                 ...future.rng), started = ...future.startTime, 
[17:42:34.661]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:34.661]             version = "1.8"), class = "FutureResult")
[17:42:34.661]     }, finally = {
[17:42:34.661]         if (!identical(...future.workdir, getwd())) 
[17:42:34.661]             setwd(...future.workdir)
[17:42:34.661]         {
[17:42:34.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:34.661]                 ...future.oldOptions$nwarnings <- NULL
[17:42:34.661]             }
[17:42:34.661]             base::options(...future.oldOptions)
[17:42:34.661]             if (.Platform$OS.type == "windows") {
[17:42:34.661]                 old_names <- names(...future.oldEnvVars)
[17:42:34.661]                 envs <- base::Sys.getenv()
[17:42:34.661]                 names <- names(envs)
[17:42:34.661]                 common <- intersect(names, old_names)
[17:42:34.661]                 added <- setdiff(names, old_names)
[17:42:34.661]                 removed <- setdiff(old_names, names)
[17:42:34.661]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:34.661]                   envs[common]]
[17:42:34.661]                 NAMES <- toupper(changed)
[17:42:34.661]                 args <- list()
[17:42:34.661]                 for (kk in seq_along(NAMES)) {
[17:42:34.661]                   name <- changed[[kk]]
[17:42:34.661]                   NAME <- NAMES[[kk]]
[17:42:34.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.661]                     next
[17:42:34.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.661]                 }
[17:42:34.661]                 NAMES <- toupper(added)
[17:42:34.661]                 for (kk in seq_along(NAMES)) {
[17:42:34.661]                   name <- added[[kk]]
[17:42:34.661]                   NAME <- NAMES[[kk]]
[17:42:34.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.661]                     next
[17:42:34.661]                   args[[name]] <- ""
[17:42:34.661]                 }
[17:42:34.661]                 NAMES <- toupper(removed)
[17:42:34.661]                 for (kk in seq_along(NAMES)) {
[17:42:34.661]                   name <- removed[[kk]]
[17:42:34.661]                   NAME <- NAMES[[kk]]
[17:42:34.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.661]                     next
[17:42:34.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.661]                 }
[17:42:34.661]                 if (length(args) > 0) 
[17:42:34.661]                   base::do.call(base::Sys.setenv, args = args)
[17:42:34.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:34.661]             }
[17:42:34.661]             else {
[17:42:34.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:34.661]             }
[17:42:34.661]             {
[17:42:34.661]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:34.661]                   0L) {
[17:42:34.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:34.661]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:34.661]                   base::options(opts)
[17:42:34.661]                 }
[17:42:34.661]                 {
[17:42:34.661]                   {
[17:42:34.661]                     NULL
[17:42:34.661]                     RNGkind("Mersenne-Twister")
[17:42:34.661]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:34.661]                       inherits = FALSE)
[17:42:34.661]                   }
[17:42:34.661]                   options(future.plan = NULL)
[17:42:34.661]                   if (is.na(NA_character_)) 
[17:42:34.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:34.661]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:34.661]                   {
[17:42:34.661]                     future <- SequentialFuture(..., envir = envir)
[17:42:34.661]                     if (!future$lazy) 
[17:42:34.661]                       future <- run(future)
[17:42:34.661]                     invisible(future)
[17:42:34.661]                   }, function (..., workers = availableCores(constraints = "multicore"), 
[17:42:34.661]                     envir = parent.frame()) 
[17:42:34.661]                   {
[17:42:34.661]                     default_workers <- missing(workers)
[17:42:34.661]                     if (is.function(workers)) 
[17:42:34.661]                       workers <- workers()
[17:42:34.661]                     workers <- structure(as.integer(workers), 
[17:42:34.661]                       class = class(workers))
[17:42:34.661]                     stop_if_not(is.finite(workers), workers >= 
[17:42:34.661]                       1L)
[17:42:34.661]                     if ((workers == 1L && !inherits(workers, 
[17:42:34.661]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:34.661]                       if (default_workers) 
[17:42:34.661]                         supportsMulticore(warn = TRUE)
[17:42:34.661]                       return(sequential(..., envir = envir))
[17:42:34.661]                     }
[17:42:34.661]                     oopts <- options(mc.cores = workers)
[17:42:34.661]                     on.exit(options(oopts))
[17:42:34.661]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:34.661]                       envir = envir)
[17:42:34.661]                     if (!future$lazy) 
[17:42:34.661]                       future <- run(future)
[17:42:34.661]                     invisible(future)
[17:42:34.661]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.661]                 }
[17:42:34.661]             }
[17:42:34.661]         }
[17:42:34.661]     })
[17:42:34.661]     if (TRUE) {
[17:42:34.661]         base::sink(type = "output", split = FALSE)
[17:42:34.661]         if (TRUE) {
[17:42:34.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:34.661]         }
[17:42:34.661]         else {
[17:42:34.661]             ...future.result["stdout"] <- base::list(NULL)
[17:42:34.661]         }
[17:42:34.661]         base::close(...future.stdout)
[17:42:34.661]         ...future.stdout <- NULL
[17:42:34.661]     }
[17:42:34.661]     ...future.result$conditions <- ...future.conditions
[17:42:34.661]     ...future.result$finished <- base::Sys.time()
[17:42:34.661]     ...future.result
[17:42:34.661] }
[17:42:34.663] assign_globals() ...
[17:42:34.663] List of 1
[17:42:34.663]  $ data:'data.frame':	5 obs. of  2 variables:
[17:42:34.663]   ..$ x: int [1:5] 1 2 3 4 5
[17:42:34.663]   ..$ y: int [1:5] 1 2 3 4 5
[17:42:34.663]  - attr(*, "where")=List of 1
[17:42:34.663]   ..$ data:<environment: R_EmptyEnv> 
[17:42:34.663]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:34.663]  - attr(*, "resolved")= logi FALSE
[17:42:34.663]  - attr(*, "total_size")= num 160
[17:42:34.663]  - attr(*, "already-done")= logi TRUE
[17:42:34.667] - copied ‘data’ to environment
[17:42:34.667] assign_globals() ... done
[17:42:34.668] plan(): Setting new future strategy stack:
[17:42:34.668] List of future strategies:
[17:42:34.668] 1. multicore:
[17:42:34.668]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:34.668]    - tweaked: FALSE
[17:42:34.668]    - call: plan(list(sequential, strategy))
[17:42:34.672] plan(): nbrOfWorkers() = 2
[17:42:34.718] plan(): Setting new future strategy stack:
[17:42:34.718] List of future strategies:
[17:42:34.718] 1. sequential:
[17:42:34.718]    - args: function (..., envir = parent.frame())
[17:42:34.718]    - tweaked: FALSE
[17:42:34.718]    - call: plan(list(sequential, strategy))
[17:42:34.718] 2. multicore:
[17:42:34.718]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:34.718]    - tweaked: FALSE
[17:42:34.718]    - call: plan(list(sequential, strategy))
[17:42:34.719] plan(): nbrOfWorkers() = 1
[17:42:34.719] SequentialFuture started (and completed)
[17:42:34.719] signalConditions() ...
[17:42:34.719]  - include = ‘immediateCondition’
[17:42:34.719]  - exclude = 
[17:42:34.720]  - resignal = FALSE
[17:42:34.720]  - Number of conditions: 50
[17:42:34.720] signalConditions() ... done
[17:42:34.720] - Launch lazy future ... done
[17:42:34.720] run() for ‘SequentialFuture’ ... done
[17:42:34.720] signalConditions() ...
[17:42:34.720]  - include = ‘immediateCondition’
[17:42:34.720]  - exclude = 
[17:42:34.721]  - resignal = FALSE
[17:42:34.721]  - Number of conditions: 50
[17:42:34.723] signalConditions() ... done
[17:42:34.724] Future state: ‘finished’
[17:42:34.724] signalConditions() ...
[17:42:34.724]  - include = ‘condition’
[17:42:34.724]  - exclude = ‘immediateCondition’
[17:42:34.724]  - resignal = TRUE
[17:42:34.724]  - Number of conditions: 50
[17:42:34.724]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.673] getGlobalsAndPackages() ...
[17:42:34.724]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:34.725]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.688] Searching for globals...
[17:42:34.725]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.689] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[17:42:34.725]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.689] Searching for globals ... DONE
[17:42:34.725]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.690] Resolving globals: FALSE
[17:42:34.726]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.690] The total size of the 1 globals is 160 bytes (160 bytes)
[17:42:34.726]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.690] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[17:42:34.726]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.691] - globals: [1] ‘data’
[17:42:34.726]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.691] 
[17:42:34.726]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.691] getGlobalsAndPackages() ... DONE
[17:42:34.727]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.691] run() for ‘Future’ ...
[17:42:34.727]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.691] - state: ‘created’
[17:42:34.727]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.691] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:34.727]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.695] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:34.727]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.695] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:34.728]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.695]   - Field: ‘label’
[17:42:34.728]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.695]   - Field: ‘local’
[17:42:34.728]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.695]   - Field: ‘owner’
[17:42:34.728]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.695]   - Field: ‘envir’
[17:42:34.728]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.695]   - Field: ‘workers’
[17:42:34.728]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.696]   - Field: ‘packages’
[17:42:34.729]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.696]   - Field: ‘gc’
[17:42:34.729]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.696]   - Field: ‘job’
[17:42:34.729]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.696]   - Field: ‘conditions’
[17:42:34.729]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.696]   - Field: ‘expr’
[17:42:34.730]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.696]   - Field: ‘uuid’
[17:42:34.730]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.696]   - Field: ‘seed’
[17:42:34.730]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.696]   - Field: ‘version’
[17:42:34.730]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.696]   - Field: ‘result’
[17:42:34.730]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.696]   - Field: ‘asynchronous’
[17:42:34.730]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.697]   - Field: ‘calls’
[17:42:34.731]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.697]   - Field: ‘globals’
[17:42:34.731]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.697]   - Field: ‘stdout’
[17:42:34.731]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.697]   - Field: ‘earlySignal’
[17:42:34.731]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.697]   - Field: ‘lazy’
[17:42:34.731]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.697]   - Field: ‘state’
[17:42:34.731]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.697] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:34.732]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.697] - Launch lazy future ...
[17:42:34.732]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.698] Packages needed by the future expression (n = 0): <none>
[17:42:34.732]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.698] Packages needed by future strategies (n = 0): <none>
[17:42:34.732]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.698] {
[17:42:34.698]     {
[17:42:34.698]         {
[17:42:34.698]             ...future.startTime <- base::Sys.time()
[17:42:34.698]             {
[17:42:34.698]                 {
[17:42:34.698]                   {
[17:42:34.698]                     {
[17:42:34.698]                       base::local({
[17:42:34.698]                         has_future <- base::requireNamespace("future", 
[17:42:34.698]                           quietly = TRUE)
[17:42:34.698]                         if (has_future) {
[17:42:34.698]                           ns <- base::getNamespace("future")
[17:42:34.698]                           version <- ns[[".package"]][["version"]]
[17:42:34.698]                           if (is.null(version)) 
[17:42:34.698]                             version <- utils::packageVersion("future")
[17:42:34.698]                         }
[17:42:34.698]                         else {
[17:42:34.698]                           version <- NULL
[17:42:34.698]                         }
[17:42:34.698]                         if (!has_future || version < "1.8.0") {
[17:42:34.698]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:34.698]                             "", base::R.version$version.string), 
[17:42:34.698]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:34.698]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:34.698]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:34.698]                               "release", "version")], collapse = " "), 
[17:42:34.698]                             hostname = base::Sys.info()[["nodename"]])
[17:42:34.698]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:34.698]                             info)
[17:42:34.698]                           info <- base::paste(info, collapse = "; ")
[17:42:34.698]                           if (!has_future) {
[17:42:34.698]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:34.698]                               info)
[17:42:34.698]                           }
[17:42:34.698]                           else {
[17:42:34.698]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:34.698]                               info, version)
[17:42:34.698]                           }
[17:42:34.698]                           base::stop(msg)
[17:42:34.698]                         }
[17:42:34.698]                       })
[17:42:34.698]                     }
[17:42:34.698]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:34.698]                     base::options(mc.cores = 1L)
[17:42:34.698]                   }
[17:42:34.698]                   options(future.plan = NULL)
[17:42:34.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:34.698]                 }
[17:42:34.698]                 ...future.workdir <- getwd()
[17:42:34.698]             }
[17:42:34.698]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:34.698]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:34.698]         }
[17:42:34.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:34.698]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:34.698]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:34.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:34.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:34.698]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:34.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:34.698]             base::names(...future.oldOptions))
[17:42:34.698]     }
[17:42:34.698]     if (FALSE) {
[17:42:34.698]     }
[17:42:34.698]     else {
[17:42:34.698]         if (TRUE) {
[17:42:34.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:34.698]                 open = "w")
[17:42:34.698]         }
[17:42:34.698]         else {
[17:42:34.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:34.698]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:34.698]         }
[17:42:34.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:34.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:34.698]             base::sink(type = "output", split = FALSE)
[17:42:34.698]             base::close(...future.stdout)
[17:42:34.698]         }, add = TRUE)
[17:42:34.698]     }
[17:42:34.698]     ...future.frame <- base::sys.nframe()
[17:42:34.698]     ...future.conditions <- base::list()
[17:42:34.698]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:34.698]     if (FALSE) {
[17:42:34.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:34.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:34.698]     }
[17:42:34.698]     ...future.result <- base::tryCatch({
[17:42:34.698]         base::withCallingHandlers({
[17:42:34.698]             ...future.value <- base::withVisible(base::local({
[17:42:34.698]                 withCallingHandlers({
[17:42:34.698]                   subset(data, x < 3)$y
[17:42:34.698]                 }, immediateCondition = function(cond) {
[17:42:34.698]                   save_rds <- function (object, pathname, ...) 
[17:42:34.698]                   {
[17:42:34.698]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:34.698]                     if (file_test("-f", pathname_tmp)) {
[17:42:34.698]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.698]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:34.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.698]                         fi_tmp[["mtime"]])
[17:42:34.698]                     }
[17:42:34.698]                     tryCatch({
[17:42:34.698]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:34.698]                     }, error = function(ex) {
[17:42:34.698]                       msg <- conditionMessage(ex)
[17:42:34.698]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.698]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:34.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.698]                         fi_tmp[["mtime"]], msg)
[17:42:34.698]                       ex$message <- msg
[17:42:34.698]                       stop(ex)
[17:42:34.698]                     })
[17:42:34.698]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:34.698]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:34.698]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:34.698]                       fi_tmp <- file.info(pathname_tmp)
[17:42:34.698]                       fi <- file.info(pathname)
[17:42:34.698]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:34.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:34.698]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:34.698]                         fi[["size"]], fi[["mtime"]])
[17:42:34.698]                       stop(msg)
[17:42:34.698]                     }
[17:42:34.698]                     invisible(pathname)
[17:42:34.698]                   }
[17:42:34.698]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:34.698]                     rootPath = tempdir()) 
[17:42:34.698]                   {
[17:42:34.698]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:34.698]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:34.698]                       tmpdir = path, fileext = ".rds")
[17:42:34.698]                     save_rds(obj, file)
[17:42:34.698]                   }
[17:42:34.698]                   saveImmediateCondition(cond, path = "/tmp/RtmpND951N/.future/immediateConditions")
[17:42:34.698]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.698]                   {
[17:42:34.698]                     inherits <- base::inherits
[17:42:34.698]                     invokeRestart <- base::invokeRestart
[17:42:34.698]                     is.null <- base::is.null
[17:42:34.698]                     muffled <- FALSE
[17:42:34.698]                     if (inherits(cond, "message")) {
[17:42:34.698]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:34.698]                       if (muffled) 
[17:42:34.698]                         invokeRestart("muffleMessage")
[17:42:34.698]                     }
[17:42:34.698]                     else if (inherits(cond, "warning")) {
[17:42:34.698]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:34.698]                       if (muffled) 
[17:42:34.698]                         invokeRestart("muffleWarning")
[17:42:34.698]                     }
[17:42:34.698]                     else if (inherits(cond, "condition")) {
[17:42:34.698]                       if (!is.null(pattern)) {
[17:42:34.698]                         computeRestarts <- base::computeRestarts
[17:42:34.698]                         grepl <- base::grepl
[17:42:34.698]                         restarts <- computeRestarts(cond)
[17:42:34.698]                         for (restart in restarts) {
[17:42:34.698]                           name <- restart$name
[17:42:34.698]                           if (is.null(name)) 
[17:42:34.698]                             next
[17:42:34.698]                           if (!grepl(pattern, name)) 
[17:42:34.698]                             next
[17:42:34.698]                           invokeRestart(restart)
[17:42:34.698]                           muffled <- TRUE
[17:42:34.698]                           break
[17:42:34.698]                         }
[17:42:34.698]                       }
[17:42:34.698]                     }
[17:42:34.698]                     invisible(muffled)
[17:42:34.698]                   }
[17:42:34.698]                   muffleCondition(cond)
[17:42:34.698]                 })
[17:42:34.698]             }))
[17:42:34.698]             future::FutureResult(value = ...future.value$value, 
[17:42:34.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.698]                   ...future.rng), globalenv = if (FALSE) 
[17:42:34.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:34.698]                     ...future.globalenv.names))
[17:42:34.698]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:34.698]         }, condition = base::local({
[17:42:34.698]             c <- base::c
[17:42:34.698]             inherits <- base::inherits
[17:42:34.698]             invokeRestart <- base::invokeRestart
[17:42:34.698]             length <- base::length
[17:42:34.698]             list <- base::list
[17:42:34.698]             seq.int <- base::seq.int
[17:42:34.698]             signalCondition <- base::signalCondition
[17:42:34.698]             sys.calls <- base::sys.calls
[17:42:34.698]             `[[` <- base::`[[`
[17:42:34.698]             `+` <- base::`+`
[17:42:34.698]             `<<-` <- base::`<<-`
[17:42:34.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:34.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:34.698]                   3L)]
[17:42:34.698]             }
[17:42:34.698]             function(cond) {
[17:42:34.698]                 is_error <- inherits(cond, "error")
[17:42:34.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:34.698]                   NULL)
[17:42:34.698]                 if (is_error) {
[17:42:34.698]                   sessionInformation <- function() {
[17:42:34.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:34.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:34.698]                       search = base::search(), system = base::Sys.info())
[17:42:34.698]                   }
[17:42:34.698]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:34.698]                     cond$call), session = sessionInformation(), 
[17:42:34.698]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:34.698]                   signalCondition(cond)
[17:42:34.698]                 }
[17:42:34.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:34.698]                 "immediateCondition"))) {
[17:42:34.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:34.698]                   ...future.conditions[[length(...future.conditions) + 
[17:42:34.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:34.698]                   if (TRUE && !signal) {
[17:42:34.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.698]                     {
[17:42:34.698]                       inherits <- base::inherits
[17:42:34.698]                       invokeRestart <- base::invokeRestart
[17:42:34.698]                       is.null <- base::is.null
[17:42:34.698]                       muffled <- FALSE
[17:42:34.698]                       if (inherits(cond, "message")) {
[17:42:34.698]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.698]                         if (muffled) 
[17:42:34.698]                           invokeRestart("muffleMessage")
[17:42:34.698]                       }
[17:42:34.698]                       else if (inherits(cond, "warning")) {
[17:42:34.698]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.698]                         if (muffled) 
[17:42:34.698]                           invokeRestart("muffleWarning")
[17:42:34.698]                       }
[17:42:34.698]                       else if (inherits(cond, "condition")) {
[17:42:34.698]                         if (!is.null(pattern)) {
[17:42:34.698]                           computeRestarts <- base::computeRestarts
[17:42:34.698]                           grepl <- base::grepl
[17:42:34.698]                           restarts <- computeRestarts(cond)
[17:42:34.698]                           for (restart in restarts) {
[17:42:34.698]                             name <- restart$name
[17:42:34.698]                             if (is.null(name)) 
[17:42:34.698]                               next
[17:42:34.698]                             if (!grepl(pattern, name)) 
[17:42:34.698]                               next
[17:42:34.698]                             invokeRestart(restart)
[17:42:34.698]                             muffled <- TRUE
[17:42:34.698]                             break
[17:42:34.698]                           }
[17:42:34.698]                         }
[17:42:34.698]                       }
[17:42:34.698]                       invisible(muffled)
[17:42:34.698]                     }
[17:42:34.698]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.698]                   }
[17:42:34.698]                 }
[17:42:34.698]                 else {
[17:42:34.698]                   if (TRUE) {
[17:42:34.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:34.698]                     {
[17:42:34.698]                       inherits <- base::inherits
[17:42:34.698]                       invokeRestart <- base::invokeRestart
[17:42:34.698]                       is.null <- base::is.null
[17:42:34.698]                       muffled <- FALSE
[17:42:34.698]                       if (inherits(cond, "message")) {
[17:42:34.698]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:34.698]                         if (muffled) 
[17:42:34.698]                           invokeRestart("muffleMessage")
[17:42:34.698]                       }
[17:42:34.698]                       else if (inherits(cond, "warning")) {
[17:42:34.698]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:34.698]                         if (muffled) 
[17:42:34.698]                           invokeRestart("muffleWarning")
[17:42:34.698]                       }
[17:42:34.698]                       else if (inherits(cond, "condition")) {
[17:42:34.698]                         if (!is.null(pattern)) {
[17:42:34.698]                           computeRestarts <- base::computeRestarts
[17:42:34.698]                           grepl <- base::grepl
[17:42:34.698]                           restarts <- computeRestarts(cond)
[17:42:34.698]                           for (restart in restarts) {
[17:42:34.698]                             name <- restart$name
[17:42:34.698]                             if (is.null(name)) 
[17:42:34.698]                               next
[17:42:34.698]                             if (!grepl(pattern, name)) 
[17:42:34.698]                               next
[17:42:34.698]                             invokeRestart(restart)
[17:42:34.698]                             muffled <- TRUE
[17:42:34.698]                             break
[17:42:34.698]                           }
[17:42:34.698]                         }
[17:42:34.698]                       }
[17:42:34.698]                       invisible(muffled)
[17:42:34.698]                     }
[17:42:34.698]                     muffleCondition(cond, pattern = "^muffle")
[17:42:34.698]                   }
[17:42:34.698]                 }
[17:42:34.698]             }
[17:42:34.698]         }))
[17:42:34.698]     }, error = function(ex) {
[17:42:34.698]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:34.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:34.698]                 ...future.rng), started = ...future.startTime, 
[17:42:34.698]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:34.698]             version = "1.8"), class = "FutureResult")
[17:42:34.698]     }, finally = {
[17:42:34.698]         if (!identical(...future.workdir, getwd())) 
[17:42:34.698]             setwd(...future.workdir)
[17:42:34.698]         {
[17:42:34.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:34.698]                 ...future.oldOptions$nwarnings <- NULL
[17:42:34.698]             }
[17:42:34.698]             base::options(...future.oldOptions)
[17:42:34.698]             if (.Platform$OS.type == "windows") {
[17:42:34.698]                 old_names <- names(...future.oldEnvVars)
[17:42:34.698]                 envs <- base::Sys.getenv()
[17:42:34.698]                 names <- names(envs)
[17:42:34.698]                 common <- intersect(names, old_names)
[17:42:34.698]                 added <- setdiff(names, old_names)
[17:42:34.698]                 removed <- setdiff(old_names, names)
[17:42:34.698]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:34.698]                   envs[common]]
[17:42:34.698]                 NAMES <- toupper(changed)
[17:42:34.698]                 args <- list()
[17:42:34.698]                 for (kk in seq_along(NAMES)) {
[17:42:34.698]                   name <- changed[[kk]]
[17:42:34.698]                   NAME <- NAMES[[kk]]
[17:42:34.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.698]                     next
[17:42:34.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.698]                 }
[17:42:34.698]                 NAMES <- toupper(added)
[17:42:34.698]                 for (kk in seq_along(NAMES)) {
[17:42:34.698]                   name <- added[[kk]]
[17:42:34.698]                   NAME <- NAMES[[kk]]
[17:42:34.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.698]                     next
[17:42:34.698]                   args[[name]] <- ""
[17:42:34.698]                 }
[17:42:34.698]                 NAMES <- toupper(removed)
[17:42:34.698]                 for (kk in seq_along(NAMES)) {
[17:42:34.698]                   name <- removed[[kk]]
[17:42:34.698]                   NAME <- NAMES[[kk]]
[17:42:34.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:34.698]                     next
[17:42:34.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:34.698]                 }
[17:42:34.698]                 if (length(args) > 0) 
[17:42:34.698]                   base::do.call(base::Sys.setenv, args = args)
[17:42:34.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:34.698]             }
[17:42:34.698]             else {
[17:42:34.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:34.698]             }
[17:42:34.698]             {
[17:42:34.698]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:34.698]                   0L) {
[17:42:34.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:34.698]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:34.698]                   base::options(opts)
[17:42:34.698]                 }
[17:42:34.698]                 {
[17:42:34.698]                   {
[17:42:34.698]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:34.698]                     NULL
[17:42:34.698]                   }
[17:42:34.698]                   options(future.plan = NULL)
[17:42:34.698]                   if (is.na(NA_character_)) 
[17:42:34.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:34.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:34.698]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:34.698]                     envir = parent.frame()) 
[17:42:34.698]                   {
[17:42:34.698]                     default_workers <- missing(workers)
[17:42:34.698]                     if (is.function(workers)) 
[17:42:34.698]                       workers <- workers()
[17:42:34.698]                     workers <- structure(as.integer(workers), 
[17:42:34.698]                       class = class(workers))
[17:42:34.698]                     stop_if_not(is.finite(workers), workers >= 
[17:42:34.698]                       1L)
[17:42:34.698]                     if ((workers == 1L && !inherits(workers, 
[17:42:34.698]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:34.698]                       if (default_workers) 
[17:42:34.698]                         supportsMulticore(warn = TRUE)
[17:42:34.698]                       return(sequential(..., envir = envir))
[17:42:34.698]                     }
[17:42:34.698]                     oopts <- options(mc.cores = workers)
[17:42:34.698]                     on.exit(options(oopts))
[17:42:34.698]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:34.698]                       envir = envir)
[17:42:34.698]                     if (!future$lazy) 
[17:42:34.698]                       future <- run(future)
[17:42:34.698]                     invisible(future)
[17:42:34.698]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:34.698]                 }
[17:42:34.698]             }
[17:42:34.698]         }
[17:42:34.698]     })
[17:42:34.698]     if (TRUE) {
[17:42:34.698]         base::sink(type = "output", split = FALSE)
[17:42:34.698]         if (TRUE) {
[17:42:34.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:34.698]         }
[17:42:34.698]         else {
[17:42:34.698]             ...future.result["stdout"] <- base::list(NULL)
[17:42:34.698]         }
[17:42:34.698]         base::close(...future.stdout)
[17:42:34.698]         ...future.stdout <- NULL
[17:42:34.698]     }
[17:42:34.698]     ...future.result$conditions <- ...future.conditions
[17:42:34.698]     ...future.result$finished <- base::Sys.time()
[17:42:34.698]     ...future.result
[17:42:34.698] }
[17:42:34.732]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.700] assign_globals() ...
[17:42:34.732]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.700] List of 1
[17:42:34.700]  $ data:'data.frame':	5 obs. of  2 variables:
[17:42:34.700]   ..$ x: int [1:5] 1 2 3 4 5
[17:42:34.700]   ..$ y: int [1:5] 1 2 3 4 5
[17:42:34.700]  - attr(*, "where")=List of 1
[17:42:34.700]   ..$ data:<environment: R_EmptyEnv> 
[17:42:34.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:34.700]  - attr(*, "resolved")= logi FALSE
[17:42:34.700]  - attr(*, "total_size")= num 160
[17:42:34.700]  - attr(*, "already-done")= logi TRUE
[17:42:34.733]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.704] - copied ‘data’ to environment
[17:42:34.733]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.704] assign_globals() ... done
[17:42:34.733]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.704] requestCore(): workers = 2
[17:42:34.733]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.706] MulticoreFuture started
[17:42:34.733]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.707] - Launch lazy future ... done
[17:42:34.733]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:34.707] run() for ‘MulticoreFuture’ ... done
[17:42:34.734] signalConditions() ... done
- Strategy: multicore ... DONE
- Strategy: multisession ...
[17:42:34.734] plan(): Setting new future strategy stack:
[17:42:34.734] List of future strategies:
[17:42:34.734] 1. multisession:
[17:42:34.734]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:34.734]    - tweaked: FALSE
[17:42:34.734]    - call: plan(strategy)
[17:42:34.735] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:42:34.735] multisession:
[17:42:34.735] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:34.735] - tweaked: FALSE
[17:42:34.735] - call: plan(strategy)
[17:42:34.742] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:34.742] Not searching for globals
[17:42:34.742] - globals: [0] <none>
[17:42:34.743] getGlobalsAndPackages() ... DONE
[17:42:34.743] [local output] makeClusterPSOCK() ...
[17:42:34.782] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:42:34.788] [local output] Base port: 11263
[17:42:34.788] [local output] Getting setup options for 2 cluster nodes ...
[17:42:34.788] [local output]  - Node 1 of 2 ...
[17:42:34.788] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:34.789] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpND951N/worker.rank=1.parallelly.parent=46443.b56b5699ddd8.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpND951N/worker.rank=1.parallelly.parent=46443.b56b5699ddd8.pid")'’
[17:42:34.980] - Possible to infer worker's PID: TRUE
[17:42:34.980] [local output] Rscript port: 11263

[17:42:34.980] [local output]  - Node 2 of 2 ...
[17:42:34.981] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:34.981] [local output] Rscript port: 11263

[17:42:34.982] [local output] Getting setup options for 2 cluster nodes ... done
[17:42:34.982] [local output]  - Parallel setup requested for some PSOCK nodes
[17:42:34.982] [local output] Setting up PSOCK nodes in parallel
[17:42:34.982] List of 36
[17:42:34.982]  $ worker          : chr "localhost"
[17:42:34.982]   ..- attr(*, "localhost")= logi TRUE
[17:42:34.982]  $ master          : chr "localhost"
[17:42:34.982]  $ port            : int 11263
[17:42:34.982]  $ connectTimeout  : num 120
[17:42:34.982]  $ timeout         : num 2592000
[17:42:34.982]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:42:34.982]  $ homogeneous     : logi TRUE
[17:42:34.982]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:42:34.982]  $ rscript_envs    : NULL
[17:42:34.982]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:34.982]  $ rscript_startup : NULL
[17:42:34.982]  $ rscript_sh      : chr "sh"
[17:42:34.982]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:34.982]  $ methods         : logi TRUE
[17:42:34.982]  $ socketOptions   : chr "no-delay"
[17:42:34.982]  $ useXDR          : logi FALSE
[17:42:34.982]  $ outfile         : chr "/dev/null"
[17:42:34.982]  $ renice          : int NA
[17:42:34.982]  $ rshcmd          : NULL
[17:42:34.982]  $ user            : chr(0) 
[17:42:34.982]  $ revtunnel       : logi FALSE
[17:42:34.982]  $ rshlogfile      : NULL
[17:42:34.982]  $ rshopts         : chr(0) 
[17:42:34.982]  $ rank            : int 1
[17:42:34.982]  $ manual          : logi FALSE
[17:42:34.982]  $ dryrun          : logi FALSE
[17:42:34.982]  $ quiet           : logi FALSE
[17:42:34.982]  $ setup_strategy  : chr "parallel"
[17:42:34.982]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:34.982]  $ pidfile         : chr "/tmp/RtmpND951N/worker.rank=1.parallelly.parent=46443.b56b5699ddd8.pid"
[17:42:34.982]  $ rshcmd_label    : NULL
[17:42:34.982]  $ rsh_call        : NULL
[17:42:34.982]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:34.982]  $ localMachine    : logi TRUE
[17:42:34.982]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:42:34.982]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:42:34.982]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:42:34.982]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:42:34.982]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:42:34.982]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:42:34.982]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:42:34.982]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:42:34.982]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:42:34.982]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:42:34.982]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:42:34.982]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:42:34.982]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:42:34.982]  $ arguments       :List of 28
[17:42:34.982]   ..$ worker          : chr "localhost"
[17:42:34.982]   ..$ master          : NULL
[17:42:34.982]   ..$ port            : int 11263
[17:42:34.982]   ..$ connectTimeout  : num 120
[17:42:34.982]   ..$ timeout         : num 2592000
[17:42:34.982]   ..$ rscript         : NULL
[17:42:34.982]   ..$ homogeneous     : NULL
[17:42:34.982]   ..$ rscript_args    : NULL
[17:42:34.982]   ..$ rscript_envs    : NULL
[17:42:34.982]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:34.982]   ..$ rscript_startup : NULL
[17:42:34.982]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:42:34.982]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:34.982]   ..$ methods         : logi TRUE
[17:42:34.982]   ..$ socketOptions   : chr "no-delay"
[17:42:34.982]   ..$ useXDR          : logi FALSE
[17:42:34.982]   ..$ outfile         : chr "/dev/null"
[17:42:34.982]   ..$ renice          : int NA
[17:42:34.982]   ..$ rshcmd          : NULL
[17:42:34.982]   ..$ user            : NULL
[17:42:34.982]   ..$ revtunnel       : logi NA
[17:42:34.982]   ..$ rshlogfile      : NULL
[17:42:34.982]   ..$ rshopts         : NULL
[17:42:34.982]   ..$ rank            : int 1
[17:42:34.982]   ..$ manual          : logi FALSE
[17:42:34.982]   ..$ dryrun          : logi FALSE
[17:42:34.982]   ..$ quiet           : logi FALSE
[17:42:34.982]   ..$ setup_strategy  : chr "parallel"
[17:42:34.982]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:42:34.999] [local output] System call to launch all workers:
[17:42:34.999] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpND951N/worker.rank=1.parallelly.parent=46443.b56b5699ddd8.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11263 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:42:34.999] [local output] Starting PSOCK main server
[17:42:35.001] [local output] Workers launched
[17:42:35.001] [local output] Waiting for workers to connect back
[17:42:35.001]  - [local output] 0 workers out of 2 ready
[17:42:35.246]  - [local output] 0 workers out of 2 ready
[17:42:35.246]  - [local output] 1 workers out of 2 ready
[17:42:35.250]  - [local output] 1 workers out of 2 ready
[17:42:35.250]  - [local output] 2 workers out of 2 ready
[17:42:35.251] [local output] Launching of workers completed
[17:42:35.251] [local output] Collecting session information from workers
[17:42:35.252] [local output]  - Worker #1 of 2
[17:42:35.252] [local output]  - Worker #2 of 2
[17:42:35.252] [local output] makeClusterPSOCK() ... done
[17:42:35.264] Packages needed by the future expression (n = 0): <none>
[17:42:35.264] Packages needed by future strategies (n = 0): <none>
[17:42:35.265] {
[17:42:35.265]     {
[17:42:35.265]         {
[17:42:35.265]             ...future.startTime <- base::Sys.time()
[17:42:35.265]             {
[17:42:35.265]                 {
[17:42:35.265]                   {
[17:42:35.265]                     {
[17:42:35.265]                       base::local({
[17:42:35.265]                         has_future <- base::requireNamespace("future", 
[17:42:35.265]                           quietly = TRUE)
[17:42:35.265]                         if (has_future) {
[17:42:35.265]                           ns <- base::getNamespace("future")
[17:42:35.265]                           version <- ns[[".package"]][["version"]]
[17:42:35.265]                           if (is.null(version)) 
[17:42:35.265]                             version <- utils::packageVersion("future")
[17:42:35.265]                         }
[17:42:35.265]                         else {
[17:42:35.265]                           version <- NULL
[17:42:35.265]                         }
[17:42:35.265]                         if (!has_future || version < "1.8.0") {
[17:42:35.265]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:35.265]                             "", base::R.version$version.string), 
[17:42:35.265]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:35.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:35.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:35.265]                               "release", "version")], collapse = " "), 
[17:42:35.265]                             hostname = base::Sys.info()[["nodename"]])
[17:42:35.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:35.265]                             info)
[17:42:35.265]                           info <- base::paste(info, collapse = "; ")
[17:42:35.265]                           if (!has_future) {
[17:42:35.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:35.265]                               info)
[17:42:35.265]                           }
[17:42:35.265]                           else {
[17:42:35.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:35.265]                               info, version)
[17:42:35.265]                           }
[17:42:35.265]                           base::stop(msg)
[17:42:35.265]                         }
[17:42:35.265]                       })
[17:42:35.265]                     }
[17:42:35.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:35.265]                     base::options(mc.cores = 1L)
[17:42:35.265]                   }
[17:42:35.265]                   options(future.plan = NULL)
[17:42:35.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:35.265]                 }
[17:42:35.265]                 ...future.workdir <- getwd()
[17:42:35.265]             }
[17:42:35.265]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:35.265]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:35.265]         }
[17:42:35.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:35.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:35.265]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:35.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:35.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:35.265]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:35.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:35.265]             base::names(...future.oldOptions))
[17:42:35.265]     }
[17:42:35.265]     if (FALSE) {
[17:42:35.265]     }
[17:42:35.265]     else {
[17:42:35.265]         if (TRUE) {
[17:42:35.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:35.265]                 open = "w")
[17:42:35.265]         }
[17:42:35.265]         else {
[17:42:35.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:35.265]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:35.265]         }
[17:42:35.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:35.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:35.265]             base::sink(type = "output", split = FALSE)
[17:42:35.265]             base::close(...future.stdout)
[17:42:35.265]         }, add = TRUE)
[17:42:35.265]     }
[17:42:35.265]     ...future.frame <- base::sys.nframe()
[17:42:35.265]     ...future.conditions <- base::list()
[17:42:35.265]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:35.265]     if (FALSE) {
[17:42:35.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:35.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:35.265]     }
[17:42:35.265]     ...future.result <- base::tryCatch({
[17:42:35.265]         base::withCallingHandlers({
[17:42:35.265]             ...future.value <- base::withVisible(base::local({
[17:42:35.265]                 ...future.makeSendCondition <- local({
[17:42:35.265]                   sendCondition <- NULL
[17:42:35.265]                   function(frame = 1L) {
[17:42:35.265]                     if (is.function(sendCondition)) 
[17:42:35.265]                       return(sendCondition)
[17:42:35.265]                     ns <- getNamespace("parallel")
[17:42:35.265]                     if (exists("sendData", mode = "function", 
[17:42:35.265]                       envir = ns)) {
[17:42:35.265]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:35.265]                         envir = ns)
[17:42:35.265]                       envir <- sys.frame(frame)
[17:42:35.265]                       master <- NULL
[17:42:35.265]                       while (!identical(envir, .GlobalEnv) && 
[17:42:35.265]                         !identical(envir, emptyenv())) {
[17:42:35.265]                         if (exists("master", mode = "list", envir = envir, 
[17:42:35.265]                           inherits = FALSE)) {
[17:42:35.265]                           master <- get("master", mode = "list", 
[17:42:35.265]                             envir = envir, inherits = FALSE)
[17:42:35.265]                           if (inherits(master, c("SOCKnode", 
[17:42:35.265]                             "SOCK0node"))) {
[17:42:35.265]                             sendCondition <<- function(cond) {
[17:42:35.265]                               data <- list(type = "VALUE", value = cond, 
[17:42:35.265]                                 success = TRUE)
[17:42:35.265]                               parallel_sendData(master, data)
[17:42:35.265]                             }
[17:42:35.265]                             return(sendCondition)
[17:42:35.265]                           }
[17:42:35.265]                         }
[17:42:35.265]                         frame <- frame + 1L
[17:42:35.265]                         envir <- sys.frame(frame)
[17:42:35.265]                       }
[17:42:35.265]                     }
[17:42:35.265]                     sendCondition <<- function(cond) NULL
[17:42:35.265]                   }
[17:42:35.265]                 })
[17:42:35.265]                 withCallingHandlers({
[17:42:35.265]                   NA
[17:42:35.265]                 }, immediateCondition = function(cond) {
[17:42:35.265]                   sendCondition <- ...future.makeSendCondition()
[17:42:35.265]                   sendCondition(cond)
[17:42:35.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.265]                   {
[17:42:35.265]                     inherits <- base::inherits
[17:42:35.265]                     invokeRestart <- base::invokeRestart
[17:42:35.265]                     is.null <- base::is.null
[17:42:35.265]                     muffled <- FALSE
[17:42:35.265]                     if (inherits(cond, "message")) {
[17:42:35.265]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:35.265]                       if (muffled) 
[17:42:35.265]                         invokeRestart("muffleMessage")
[17:42:35.265]                     }
[17:42:35.265]                     else if (inherits(cond, "warning")) {
[17:42:35.265]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:35.265]                       if (muffled) 
[17:42:35.265]                         invokeRestart("muffleWarning")
[17:42:35.265]                     }
[17:42:35.265]                     else if (inherits(cond, "condition")) {
[17:42:35.265]                       if (!is.null(pattern)) {
[17:42:35.265]                         computeRestarts <- base::computeRestarts
[17:42:35.265]                         grepl <- base::grepl
[17:42:35.265]                         restarts <- computeRestarts(cond)
[17:42:35.265]                         for (restart in restarts) {
[17:42:35.265]                           name <- restart$name
[17:42:35.265]                           if (is.null(name)) 
[17:42:35.265]                             next
[17:42:35.265]                           if (!grepl(pattern, name)) 
[17:42:35.265]                             next
[17:42:35.265]                           invokeRestart(restart)
[17:42:35.265]                           muffled <- TRUE
[17:42:35.265]                           break
[17:42:35.265]                         }
[17:42:35.265]                       }
[17:42:35.265]                     }
[17:42:35.265]                     invisible(muffled)
[17:42:35.265]                   }
[17:42:35.265]                   muffleCondition(cond)
[17:42:35.265]                 })
[17:42:35.265]             }))
[17:42:35.265]             future::FutureResult(value = ...future.value$value, 
[17:42:35.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.265]                   ...future.rng), globalenv = if (FALSE) 
[17:42:35.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:35.265]                     ...future.globalenv.names))
[17:42:35.265]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:35.265]         }, condition = base::local({
[17:42:35.265]             c <- base::c
[17:42:35.265]             inherits <- base::inherits
[17:42:35.265]             invokeRestart <- base::invokeRestart
[17:42:35.265]             length <- base::length
[17:42:35.265]             list <- base::list
[17:42:35.265]             seq.int <- base::seq.int
[17:42:35.265]             signalCondition <- base::signalCondition
[17:42:35.265]             sys.calls <- base::sys.calls
[17:42:35.265]             `[[` <- base::`[[`
[17:42:35.265]             `+` <- base::`+`
[17:42:35.265]             `<<-` <- base::`<<-`
[17:42:35.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:35.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:35.265]                   3L)]
[17:42:35.265]             }
[17:42:35.265]             function(cond) {
[17:42:35.265]                 is_error <- inherits(cond, "error")
[17:42:35.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:35.265]                   NULL)
[17:42:35.265]                 if (is_error) {
[17:42:35.265]                   sessionInformation <- function() {
[17:42:35.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:35.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:35.265]                       search = base::search(), system = base::Sys.info())
[17:42:35.265]                   }
[17:42:35.265]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:35.265]                     cond$call), session = sessionInformation(), 
[17:42:35.265]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:35.265]                   signalCondition(cond)
[17:42:35.265]                 }
[17:42:35.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:35.265]                 "immediateCondition"))) {
[17:42:35.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:35.265]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:35.265]                   if (TRUE && !signal) {
[17:42:35.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.265]                     {
[17:42:35.265]                       inherits <- base::inherits
[17:42:35.265]                       invokeRestart <- base::invokeRestart
[17:42:35.265]                       is.null <- base::is.null
[17:42:35.265]                       muffled <- FALSE
[17:42:35.265]                       if (inherits(cond, "message")) {
[17:42:35.265]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.265]                         if (muffled) 
[17:42:35.265]                           invokeRestart("muffleMessage")
[17:42:35.265]                       }
[17:42:35.265]                       else if (inherits(cond, "warning")) {
[17:42:35.265]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.265]                         if (muffled) 
[17:42:35.265]                           invokeRestart("muffleWarning")
[17:42:35.265]                       }
[17:42:35.265]                       else if (inherits(cond, "condition")) {
[17:42:35.265]                         if (!is.null(pattern)) {
[17:42:35.265]                           computeRestarts <- base::computeRestarts
[17:42:35.265]                           grepl <- base::grepl
[17:42:35.265]                           restarts <- computeRestarts(cond)
[17:42:35.265]                           for (restart in restarts) {
[17:42:35.265]                             name <- restart$name
[17:42:35.265]                             if (is.null(name)) 
[17:42:35.265]                               next
[17:42:35.265]                             if (!grepl(pattern, name)) 
[17:42:35.265]                               next
[17:42:35.265]                             invokeRestart(restart)
[17:42:35.265]                             muffled <- TRUE
[17:42:35.265]                             break
[17:42:35.265]                           }
[17:42:35.265]                         }
[17:42:35.265]                       }
[17:42:35.265]                       invisible(muffled)
[17:42:35.265]                     }
[17:42:35.265]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.265]                   }
[17:42:35.265]                 }
[17:42:35.265]                 else {
[17:42:35.265]                   if (TRUE) {
[17:42:35.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.265]                     {
[17:42:35.265]                       inherits <- base::inherits
[17:42:35.265]                       invokeRestart <- base::invokeRestart
[17:42:35.265]                       is.null <- base::is.null
[17:42:35.265]                       muffled <- FALSE
[17:42:35.265]                       if (inherits(cond, "message")) {
[17:42:35.265]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.265]                         if (muffled) 
[17:42:35.265]                           invokeRestart("muffleMessage")
[17:42:35.265]                       }
[17:42:35.265]                       else if (inherits(cond, "warning")) {
[17:42:35.265]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.265]                         if (muffled) 
[17:42:35.265]                           invokeRestart("muffleWarning")
[17:42:35.265]                       }
[17:42:35.265]                       else if (inherits(cond, "condition")) {
[17:42:35.265]                         if (!is.null(pattern)) {
[17:42:35.265]                           computeRestarts <- base::computeRestarts
[17:42:35.265]                           grepl <- base::grepl
[17:42:35.265]                           restarts <- computeRestarts(cond)
[17:42:35.265]                           for (restart in restarts) {
[17:42:35.265]                             name <- restart$name
[17:42:35.265]                             if (is.null(name)) 
[17:42:35.265]                               next
[17:42:35.265]                             if (!grepl(pattern, name)) 
[17:42:35.265]                               next
[17:42:35.265]                             invokeRestart(restart)
[17:42:35.265]                             muffled <- TRUE
[17:42:35.265]                             break
[17:42:35.265]                           }
[17:42:35.265]                         }
[17:42:35.265]                       }
[17:42:35.265]                       invisible(muffled)
[17:42:35.265]                     }
[17:42:35.265]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.265]                   }
[17:42:35.265]                 }
[17:42:35.265]             }
[17:42:35.265]         }))
[17:42:35.265]     }, error = function(ex) {
[17:42:35.265]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:35.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.265]                 ...future.rng), started = ...future.startTime, 
[17:42:35.265]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:35.265]             version = "1.8"), class = "FutureResult")
[17:42:35.265]     }, finally = {
[17:42:35.265]         if (!identical(...future.workdir, getwd())) 
[17:42:35.265]             setwd(...future.workdir)
[17:42:35.265]         {
[17:42:35.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:35.265]                 ...future.oldOptions$nwarnings <- NULL
[17:42:35.265]             }
[17:42:35.265]             base::options(...future.oldOptions)
[17:42:35.265]             if (.Platform$OS.type == "windows") {
[17:42:35.265]                 old_names <- names(...future.oldEnvVars)
[17:42:35.265]                 envs <- base::Sys.getenv()
[17:42:35.265]                 names <- names(envs)
[17:42:35.265]                 common <- intersect(names, old_names)
[17:42:35.265]                 added <- setdiff(names, old_names)
[17:42:35.265]                 removed <- setdiff(old_names, names)
[17:42:35.265]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:35.265]                   envs[common]]
[17:42:35.265]                 NAMES <- toupper(changed)
[17:42:35.265]                 args <- list()
[17:42:35.265]                 for (kk in seq_along(NAMES)) {
[17:42:35.265]                   name <- changed[[kk]]
[17:42:35.265]                   NAME <- NAMES[[kk]]
[17:42:35.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.265]                     next
[17:42:35.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.265]                 }
[17:42:35.265]                 NAMES <- toupper(added)
[17:42:35.265]                 for (kk in seq_along(NAMES)) {
[17:42:35.265]                   name <- added[[kk]]
[17:42:35.265]                   NAME <- NAMES[[kk]]
[17:42:35.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.265]                     next
[17:42:35.265]                   args[[name]] <- ""
[17:42:35.265]                 }
[17:42:35.265]                 NAMES <- toupper(removed)
[17:42:35.265]                 for (kk in seq_along(NAMES)) {
[17:42:35.265]                   name <- removed[[kk]]
[17:42:35.265]                   NAME <- NAMES[[kk]]
[17:42:35.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.265]                     next
[17:42:35.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.265]                 }
[17:42:35.265]                 if (length(args) > 0) 
[17:42:35.265]                   base::do.call(base::Sys.setenv, args = args)
[17:42:35.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:35.265]             }
[17:42:35.265]             else {
[17:42:35.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:35.265]             }
[17:42:35.265]             {
[17:42:35.265]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:35.265]                   0L) {
[17:42:35.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:35.265]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:35.265]                   base::options(opts)
[17:42:35.265]                 }
[17:42:35.265]                 {
[17:42:35.265]                   {
[17:42:35.265]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:35.265]                     NULL
[17:42:35.265]                   }
[17:42:35.265]                   options(future.plan = NULL)
[17:42:35.265]                   if (is.na(NA_character_)) 
[17:42:35.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:35.265]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:35.265]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:35.265]                     envir = parent.frame()) 
[17:42:35.265]                   {
[17:42:35.265]                     if (is.function(workers)) 
[17:42:35.265]                       workers <- workers()
[17:42:35.265]                     workers <- structure(as.integer(workers), 
[17:42:35.265]                       class = class(workers))
[17:42:35.265]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:35.265]                       workers >= 1)
[17:42:35.265]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:35.265]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:35.265]                     }
[17:42:35.265]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:35.265]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:35.265]                       envir = envir)
[17:42:35.265]                     if (!future$lazy) 
[17:42:35.265]                       future <- run(future)
[17:42:35.265]                     invisible(future)
[17:42:35.265]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:35.265]                 }
[17:42:35.265]             }
[17:42:35.265]         }
[17:42:35.265]     })
[17:42:35.265]     if (TRUE) {
[17:42:35.265]         base::sink(type = "output", split = FALSE)
[17:42:35.265]         if (TRUE) {
[17:42:35.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:35.265]         }
[17:42:35.265]         else {
[17:42:35.265]             ...future.result["stdout"] <- base::list(NULL)
[17:42:35.265]         }
[17:42:35.265]         base::close(...future.stdout)
[17:42:35.265]         ...future.stdout <- NULL
[17:42:35.265]     }
[17:42:35.265]     ...future.result$conditions <- ...future.conditions
[17:42:35.265]     ...future.result$finished <- base::Sys.time()
[17:42:35.265]     ...future.result
[17:42:35.265] }
[17:42:35.338] MultisessionFuture started
[17:42:35.339] result() for ClusterFuture ...
[17:42:35.340] receiveMessageFromWorker() for ClusterFuture ...
[17:42:35.340] - Validating connection of MultisessionFuture
[17:42:35.373] - received message: FutureResult
[17:42:35.373] - Received FutureResult
[17:42:35.373] - Erased future from FutureRegistry
[17:42:35.373] result() for ClusterFuture ...
[17:42:35.373] - result already collected: FutureResult
[17:42:35.373] result() for ClusterFuture ... done
[17:42:35.374] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:35.374] result() for ClusterFuture ... done
[17:42:35.374] result() for ClusterFuture ...
[17:42:35.374] - result already collected: FutureResult
[17:42:35.374] result() for ClusterFuture ... done
[17:42:35.374] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:42:35.378] plan(): nbrOfWorkers() = 2
[17:42:35.378] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:35.378] Searching for globals...
[17:42:35.379] - globals found: [1] ‘getOption’
[17:42:35.379] Searching for globals ... DONE
[17:42:35.379] Resolving globals: FALSE
[17:42:35.380] 
[17:42:35.380] 
[17:42:35.380] getGlobalsAndPackages() ... DONE
[17:42:35.380] run() for ‘Future’ ...
[17:42:35.380] - state: ‘created’
[17:42:35.381] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:35.395] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:35.396] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:35.396]   - Field: ‘node’
[17:42:35.396]   - Field: ‘label’
[17:42:35.396]   - Field: ‘local’
[17:42:35.396]   - Field: ‘owner’
[17:42:35.396]   - Field: ‘envir’
[17:42:35.396]   - Field: ‘workers’
[17:42:35.396]   - Field: ‘packages’
[17:42:35.396]   - Field: ‘gc’
[17:42:35.397]   - Field: ‘conditions’
[17:42:35.397]   - Field: ‘persistent’
[17:42:35.397]   - Field: ‘expr’
[17:42:35.397]   - Field: ‘uuid’
[17:42:35.397]   - Field: ‘seed’
[17:42:35.397]   - Field: ‘version’
[17:42:35.397]   - Field: ‘result’
[17:42:35.397]   - Field: ‘asynchronous’
[17:42:35.397]   - Field: ‘calls’
[17:42:35.398]   - Field: ‘globals’
[17:42:35.398]   - Field: ‘stdout’
[17:42:35.398]   - Field: ‘earlySignal’
[17:42:35.398]   - Field: ‘lazy’
[17:42:35.398]   - Field: ‘state’
[17:42:35.398] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:35.398] - Launch lazy future ...
[17:42:35.399] Packages needed by the future expression (n = 0): <none>
[17:42:35.399] Packages needed by future strategies (n = 0): <none>
[17:42:35.399] {
[17:42:35.399]     {
[17:42:35.399]         {
[17:42:35.399]             ...future.startTime <- base::Sys.time()
[17:42:35.399]             {
[17:42:35.399]                 {
[17:42:35.399]                   {
[17:42:35.399]                     {
[17:42:35.399]                       base::local({
[17:42:35.399]                         has_future <- base::requireNamespace("future", 
[17:42:35.399]                           quietly = TRUE)
[17:42:35.399]                         if (has_future) {
[17:42:35.399]                           ns <- base::getNamespace("future")
[17:42:35.399]                           version <- ns[[".package"]][["version"]]
[17:42:35.399]                           if (is.null(version)) 
[17:42:35.399]                             version <- utils::packageVersion("future")
[17:42:35.399]                         }
[17:42:35.399]                         else {
[17:42:35.399]                           version <- NULL
[17:42:35.399]                         }
[17:42:35.399]                         if (!has_future || version < "1.8.0") {
[17:42:35.399]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:35.399]                             "", base::R.version$version.string), 
[17:42:35.399]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:35.399]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:35.399]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:35.399]                               "release", "version")], collapse = " "), 
[17:42:35.399]                             hostname = base::Sys.info()[["nodename"]])
[17:42:35.399]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:35.399]                             info)
[17:42:35.399]                           info <- base::paste(info, collapse = "; ")
[17:42:35.399]                           if (!has_future) {
[17:42:35.399]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:35.399]                               info)
[17:42:35.399]                           }
[17:42:35.399]                           else {
[17:42:35.399]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:35.399]                               info, version)
[17:42:35.399]                           }
[17:42:35.399]                           base::stop(msg)
[17:42:35.399]                         }
[17:42:35.399]                       })
[17:42:35.399]                     }
[17:42:35.399]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:35.399]                     base::options(mc.cores = 1L)
[17:42:35.399]                   }
[17:42:35.399]                   options(future.plan = NULL)
[17:42:35.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:35.399]                 }
[17:42:35.399]                 ...future.workdir <- getwd()
[17:42:35.399]             }
[17:42:35.399]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:35.399]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:35.399]         }
[17:42:35.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:35.399]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:35.399]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:35.399]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:35.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:35.399]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:35.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:35.399]             base::names(...future.oldOptions))
[17:42:35.399]     }
[17:42:35.399]     if (FALSE) {
[17:42:35.399]     }
[17:42:35.399]     else {
[17:42:35.399]         if (TRUE) {
[17:42:35.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:35.399]                 open = "w")
[17:42:35.399]         }
[17:42:35.399]         else {
[17:42:35.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:35.399]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:35.399]         }
[17:42:35.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:35.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:35.399]             base::sink(type = "output", split = FALSE)
[17:42:35.399]             base::close(...future.stdout)
[17:42:35.399]         }, add = TRUE)
[17:42:35.399]     }
[17:42:35.399]     ...future.frame <- base::sys.nframe()
[17:42:35.399]     ...future.conditions <- base::list()
[17:42:35.399]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:35.399]     if (FALSE) {
[17:42:35.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:35.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:35.399]     }
[17:42:35.399]     ...future.result <- base::tryCatch({
[17:42:35.399]         base::withCallingHandlers({
[17:42:35.399]             ...future.value <- base::withVisible(base::local({
[17:42:35.399]                 ...future.makeSendCondition <- local({
[17:42:35.399]                   sendCondition <- NULL
[17:42:35.399]                   function(frame = 1L) {
[17:42:35.399]                     if (is.function(sendCondition)) 
[17:42:35.399]                       return(sendCondition)
[17:42:35.399]                     ns <- getNamespace("parallel")
[17:42:35.399]                     if (exists("sendData", mode = "function", 
[17:42:35.399]                       envir = ns)) {
[17:42:35.399]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:35.399]                         envir = ns)
[17:42:35.399]                       envir <- sys.frame(frame)
[17:42:35.399]                       master <- NULL
[17:42:35.399]                       while (!identical(envir, .GlobalEnv) && 
[17:42:35.399]                         !identical(envir, emptyenv())) {
[17:42:35.399]                         if (exists("master", mode = "list", envir = envir, 
[17:42:35.399]                           inherits = FALSE)) {
[17:42:35.399]                           master <- get("master", mode = "list", 
[17:42:35.399]                             envir = envir, inherits = FALSE)
[17:42:35.399]                           if (inherits(master, c("SOCKnode", 
[17:42:35.399]                             "SOCK0node"))) {
[17:42:35.399]                             sendCondition <<- function(cond) {
[17:42:35.399]                               data <- list(type = "VALUE", value = cond, 
[17:42:35.399]                                 success = TRUE)
[17:42:35.399]                               parallel_sendData(master, data)
[17:42:35.399]                             }
[17:42:35.399]                             return(sendCondition)
[17:42:35.399]                           }
[17:42:35.399]                         }
[17:42:35.399]                         frame <- frame + 1L
[17:42:35.399]                         envir <- sys.frame(frame)
[17:42:35.399]                       }
[17:42:35.399]                     }
[17:42:35.399]                     sendCondition <<- function(cond) NULL
[17:42:35.399]                   }
[17:42:35.399]                 })
[17:42:35.399]                 withCallingHandlers({
[17:42:35.399]                   getOption("future.globals.onMissing")
[17:42:35.399]                 }, immediateCondition = function(cond) {
[17:42:35.399]                   sendCondition <- ...future.makeSendCondition()
[17:42:35.399]                   sendCondition(cond)
[17:42:35.399]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.399]                   {
[17:42:35.399]                     inherits <- base::inherits
[17:42:35.399]                     invokeRestart <- base::invokeRestart
[17:42:35.399]                     is.null <- base::is.null
[17:42:35.399]                     muffled <- FALSE
[17:42:35.399]                     if (inherits(cond, "message")) {
[17:42:35.399]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:35.399]                       if (muffled) 
[17:42:35.399]                         invokeRestart("muffleMessage")
[17:42:35.399]                     }
[17:42:35.399]                     else if (inherits(cond, "warning")) {
[17:42:35.399]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:35.399]                       if (muffled) 
[17:42:35.399]                         invokeRestart("muffleWarning")
[17:42:35.399]                     }
[17:42:35.399]                     else if (inherits(cond, "condition")) {
[17:42:35.399]                       if (!is.null(pattern)) {
[17:42:35.399]                         computeRestarts <- base::computeRestarts
[17:42:35.399]                         grepl <- base::grepl
[17:42:35.399]                         restarts <- computeRestarts(cond)
[17:42:35.399]                         for (restart in restarts) {
[17:42:35.399]                           name <- restart$name
[17:42:35.399]                           if (is.null(name)) 
[17:42:35.399]                             next
[17:42:35.399]                           if (!grepl(pattern, name)) 
[17:42:35.399]                             next
[17:42:35.399]                           invokeRestart(restart)
[17:42:35.399]                           muffled <- TRUE
[17:42:35.399]                           break
[17:42:35.399]                         }
[17:42:35.399]                       }
[17:42:35.399]                     }
[17:42:35.399]                     invisible(muffled)
[17:42:35.399]                   }
[17:42:35.399]                   muffleCondition(cond)
[17:42:35.399]                 })
[17:42:35.399]             }))
[17:42:35.399]             future::FutureResult(value = ...future.value$value, 
[17:42:35.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.399]                   ...future.rng), globalenv = if (FALSE) 
[17:42:35.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:35.399]                     ...future.globalenv.names))
[17:42:35.399]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:35.399]         }, condition = base::local({
[17:42:35.399]             c <- base::c
[17:42:35.399]             inherits <- base::inherits
[17:42:35.399]             invokeRestart <- base::invokeRestart
[17:42:35.399]             length <- base::length
[17:42:35.399]             list <- base::list
[17:42:35.399]             seq.int <- base::seq.int
[17:42:35.399]             signalCondition <- base::signalCondition
[17:42:35.399]             sys.calls <- base::sys.calls
[17:42:35.399]             `[[` <- base::`[[`
[17:42:35.399]             `+` <- base::`+`
[17:42:35.399]             `<<-` <- base::`<<-`
[17:42:35.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:35.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:35.399]                   3L)]
[17:42:35.399]             }
[17:42:35.399]             function(cond) {
[17:42:35.399]                 is_error <- inherits(cond, "error")
[17:42:35.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:35.399]                   NULL)
[17:42:35.399]                 if (is_error) {
[17:42:35.399]                   sessionInformation <- function() {
[17:42:35.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:35.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:35.399]                       search = base::search(), system = base::Sys.info())
[17:42:35.399]                   }
[17:42:35.399]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:35.399]                     cond$call), session = sessionInformation(), 
[17:42:35.399]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:35.399]                   signalCondition(cond)
[17:42:35.399]                 }
[17:42:35.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:35.399]                 "immediateCondition"))) {
[17:42:35.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:35.399]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:35.399]                   if (TRUE && !signal) {
[17:42:35.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.399]                     {
[17:42:35.399]                       inherits <- base::inherits
[17:42:35.399]                       invokeRestart <- base::invokeRestart
[17:42:35.399]                       is.null <- base::is.null
[17:42:35.399]                       muffled <- FALSE
[17:42:35.399]                       if (inherits(cond, "message")) {
[17:42:35.399]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.399]                         if (muffled) 
[17:42:35.399]                           invokeRestart("muffleMessage")
[17:42:35.399]                       }
[17:42:35.399]                       else if (inherits(cond, "warning")) {
[17:42:35.399]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.399]                         if (muffled) 
[17:42:35.399]                           invokeRestart("muffleWarning")
[17:42:35.399]                       }
[17:42:35.399]                       else if (inherits(cond, "condition")) {
[17:42:35.399]                         if (!is.null(pattern)) {
[17:42:35.399]                           computeRestarts <- base::computeRestarts
[17:42:35.399]                           grepl <- base::grepl
[17:42:35.399]                           restarts <- computeRestarts(cond)
[17:42:35.399]                           for (restart in restarts) {
[17:42:35.399]                             name <- restart$name
[17:42:35.399]                             if (is.null(name)) 
[17:42:35.399]                               next
[17:42:35.399]                             if (!grepl(pattern, name)) 
[17:42:35.399]                               next
[17:42:35.399]                             invokeRestart(restart)
[17:42:35.399]                             muffled <- TRUE
[17:42:35.399]                             break
[17:42:35.399]                           }
[17:42:35.399]                         }
[17:42:35.399]                       }
[17:42:35.399]                       invisible(muffled)
[17:42:35.399]                     }
[17:42:35.399]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.399]                   }
[17:42:35.399]                 }
[17:42:35.399]                 else {
[17:42:35.399]                   if (TRUE) {
[17:42:35.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.399]                     {
[17:42:35.399]                       inherits <- base::inherits
[17:42:35.399]                       invokeRestart <- base::invokeRestart
[17:42:35.399]                       is.null <- base::is.null
[17:42:35.399]                       muffled <- FALSE
[17:42:35.399]                       if (inherits(cond, "message")) {
[17:42:35.399]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.399]                         if (muffled) 
[17:42:35.399]                           invokeRestart("muffleMessage")
[17:42:35.399]                       }
[17:42:35.399]                       else if (inherits(cond, "warning")) {
[17:42:35.399]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.399]                         if (muffled) 
[17:42:35.399]                           invokeRestart("muffleWarning")
[17:42:35.399]                       }
[17:42:35.399]                       else if (inherits(cond, "condition")) {
[17:42:35.399]                         if (!is.null(pattern)) {
[17:42:35.399]                           computeRestarts <- base::computeRestarts
[17:42:35.399]                           grepl <- base::grepl
[17:42:35.399]                           restarts <- computeRestarts(cond)
[17:42:35.399]                           for (restart in restarts) {
[17:42:35.399]                             name <- restart$name
[17:42:35.399]                             if (is.null(name)) 
[17:42:35.399]                               next
[17:42:35.399]                             if (!grepl(pattern, name)) 
[17:42:35.399]                               next
[17:42:35.399]                             invokeRestart(restart)
[17:42:35.399]                             muffled <- TRUE
[17:42:35.399]                             break
[17:42:35.399]                           }
[17:42:35.399]                         }
[17:42:35.399]                       }
[17:42:35.399]                       invisible(muffled)
[17:42:35.399]                     }
[17:42:35.399]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.399]                   }
[17:42:35.399]                 }
[17:42:35.399]             }
[17:42:35.399]         }))
[17:42:35.399]     }, error = function(ex) {
[17:42:35.399]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:35.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.399]                 ...future.rng), started = ...future.startTime, 
[17:42:35.399]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:35.399]             version = "1.8"), class = "FutureResult")
[17:42:35.399]     }, finally = {
[17:42:35.399]         if (!identical(...future.workdir, getwd())) 
[17:42:35.399]             setwd(...future.workdir)
[17:42:35.399]         {
[17:42:35.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:35.399]                 ...future.oldOptions$nwarnings <- NULL
[17:42:35.399]             }
[17:42:35.399]             base::options(...future.oldOptions)
[17:42:35.399]             if (.Platform$OS.type == "windows") {
[17:42:35.399]                 old_names <- names(...future.oldEnvVars)
[17:42:35.399]                 envs <- base::Sys.getenv()
[17:42:35.399]                 names <- names(envs)
[17:42:35.399]                 common <- intersect(names, old_names)
[17:42:35.399]                 added <- setdiff(names, old_names)
[17:42:35.399]                 removed <- setdiff(old_names, names)
[17:42:35.399]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:35.399]                   envs[common]]
[17:42:35.399]                 NAMES <- toupper(changed)
[17:42:35.399]                 args <- list()
[17:42:35.399]                 for (kk in seq_along(NAMES)) {
[17:42:35.399]                   name <- changed[[kk]]
[17:42:35.399]                   NAME <- NAMES[[kk]]
[17:42:35.399]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.399]                     next
[17:42:35.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.399]                 }
[17:42:35.399]                 NAMES <- toupper(added)
[17:42:35.399]                 for (kk in seq_along(NAMES)) {
[17:42:35.399]                   name <- added[[kk]]
[17:42:35.399]                   NAME <- NAMES[[kk]]
[17:42:35.399]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.399]                     next
[17:42:35.399]                   args[[name]] <- ""
[17:42:35.399]                 }
[17:42:35.399]                 NAMES <- toupper(removed)
[17:42:35.399]                 for (kk in seq_along(NAMES)) {
[17:42:35.399]                   name <- removed[[kk]]
[17:42:35.399]                   NAME <- NAMES[[kk]]
[17:42:35.399]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.399]                     next
[17:42:35.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.399]                 }
[17:42:35.399]                 if (length(args) > 0) 
[17:42:35.399]                   base::do.call(base::Sys.setenv, args = args)
[17:42:35.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:35.399]             }
[17:42:35.399]             else {
[17:42:35.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:35.399]             }
[17:42:35.399]             {
[17:42:35.399]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:35.399]                   0L) {
[17:42:35.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:35.399]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:35.399]                   base::options(opts)
[17:42:35.399]                 }
[17:42:35.399]                 {
[17:42:35.399]                   {
[17:42:35.399]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:35.399]                     NULL
[17:42:35.399]                   }
[17:42:35.399]                   options(future.plan = NULL)
[17:42:35.399]                   if (is.na(NA_character_)) 
[17:42:35.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:35.399]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:35.399]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:35.399]                     envir = parent.frame()) 
[17:42:35.399]                   {
[17:42:35.399]                     if (is.function(workers)) 
[17:42:35.399]                       workers <- workers()
[17:42:35.399]                     workers <- structure(as.integer(workers), 
[17:42:35.399]                       class = class(workers))
[17:42:35.399]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:35.399]                       workers >= 1)
[17:42:35.399]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:35.399]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:35.399]                     }
[17:42:35.399]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:35.399]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:35.399]                       envir = envir)
[17:42:35.399]                     if (!future$lazy) 
[17:42:35.399]                       future <- run(future)
[17:42:35.399]                     invisible(future)
[17:42:35.399]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:35.399]                 }
[17:42:35.399]             }
[17:42:35.399]         }
[17:42:35.399]     })
[17:42:35.399]     if (TRUE) {
[17:42:35.399]         base::sink(type = "output", split = FALSE)
[17:42:35.399]         if (TRUE) {
[17:42:35.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:35.399]         }
[17:42:35.399]         else {
[17:42:35.399]             ...future.result["stdout"] <- base::list(NULL)
[17:42:35.399]         }
[17:42:35.399]         base::close(...future.stdout)
[17:42:35.399]         ...future.stdout <- NULL
[17:42:35.399]     }
[17:42:35.399]     ...future.result$conditions <- ...future.conditions
[17:42:35.399]     ...future.result$finished <- base::Sys.time()
[17:42:35.399]     ...future.result
[17:42:35.399] }
[17:42:35.403] MultisessionFuture started
[17:42:35.403] - Launch lazy future ... done
[17:42:35.403] run() for ‘MultisessionFuture’ ... done
[17:42:35.404] result() for ClusterFuture ...
[17:42:35.404] receiveMessageFromWorker() for ClusterFuture ...
[17:42:35.404] - Validating connection of MultisessionFuture
[17:42:35.452] - received message: FutureResult
[17:42:35.452] - Received FutureResult
[17:42:35.452] - Erased future from FutureRegistry
[17:42:35.452] result() for ClusterFuture ...
[17:42:35.453] - result already collected: FutureResult
[17:42:35.453] result() for ClusterFuture ... done
[17:42:35.453] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:35.453] result() for ClusterFuture ... done
[17:42:35.453] result() for ClusterFuture ...
[17:42:35.453] - result already collected: FutureResult
[17:42:35.453] result() for ClusterFuture ... done
[17:42:35.454] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:35.454] Searching for globals...
[17:42:35.455] - globals found: [1] ‘getOption’
[17:42:35.455] Searching for globals ... DONE
[17:42:35.455] Resolving globals: FALSE
[17:42:35.455] 
[17:42:35.455] 
[17:42:35.455] getGlobalsAndPackages() ... DONE
[17:42:35.456] run() for ‘Future’ ...
[17:42:35.456] - state: ‘created’
[17:42:35.456] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:35.471] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:35.472] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:35.472]   - Field: ‘node’
[17:42:35.472]   - Field: ‘label’
[17:42:35.472]   - Field: ‘local’
[17:42:35.472]   - Field: ‘owner’
[17:42:35.472]   - Field: ‘envir’
[17:42:35.472]   - Field: ‘workers’
[17:42:35.472]   - Field: ‘packages’
[17:42:35.472]   - Field: ‘gc’
[17:42:35.473]   - Field: ‘conditions’
[17:42:35.473]   - Field: ‘persistent’
[17:42:35.473]   - Field: ‘expr’
[17:42:35.473]   - Field: ‘uuid’
[17:42:35.473]   - Field: ‘seed’
[17:42:35.473]   - Field: ‘version’
[17:42:35.473]   - Field: ‘result’
[17:42:35.473]   - Field: ‘asynchronous’
[17:42:35.474]   - Field: ‘calls’
[17:42:35.474]   - Field: ‘globals’
[17:42:35.474]   - Field: ‘stdout’
[17:42:35.474]   - Field: ‘earlySignal’
[17:42:35.474]   - Field: ‘lazy’
[17:42:35.474]   - Field: ‘state’
[17:42:35.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:35.474] - Launch lazy future ...
[17:42:35.475] Packages needed by the future expression (n = 0): <none>
[17:42:35.475] Packages needed by future strategies (n = 0): <none>
[17:42:35.475] {
[17:42:35.475]     {
[17:42:35.475]         {
[17:42:35.475]             ...future.startTime <- base::Sys.time()
[17:42:35.475]             {
[17:42:35.475]                 {
[17:42:35.475]                   {
[17:42:35.475]                     {
[17:42:35.475]                       base::local({
[17:42:35.475]                         has_future <- base::requireNamespace("future", 
[17:42:35.475]                           quietly = TRUE)
[17:42:35.475]                         if (has_future) {
[17:42:35.475]                           ns <- base::getNamespace("future")
[17:42:35.475]                           version <- ns[[".package"]][["version"]]
[17:42:35.475]                           if (is.null(version)) 
[17:42:35.475]                             version <- utils::packageVersion("future")
[17:42:35.475]                         }
[17:42:35.475]                         else {
[17:42:35.475]                           version <- NULL
[17:42:35.475]                         }
[17:42:35.475]                         if (!has_future || version < "1.8.0") {
[17:42:35.475]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:35.475]                             "", base::R.version$version.string), 
[17:42:35.475]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:35.475]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:35.475]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:35.475]                               "release", "version")], collapse = " "), 
[17:42:35.475]                             hostname = base::Sys.info()[["nodename"]])
[17:42:35.475]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:35.475]                             info)
[17:42:35.475]                           info <- base::paste(info, collapse = "; ")
[17:42:35.475]                           if (!has_future) {
[17:42:35.475]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:35.475]                               info)
[17:42:35.475]                           }
[17:42:35.475]                           else {
[17:42:35.475]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:35.475]                               info, version)
[17:42:35.475]                           }
[17:42:35.475]                           base::stop(msg)
[17:42:35.475]                         }
[17:42:35.475]                       })
[17:42:35.475]                     }
[17:42:35.475]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:35.475]                     base::options(mc.cores = 1L)
[17:42:35.475]                   }
[17:42:35.475]                   options(future.plan = NULL)
[17:42:35.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:35.475]                 }
[17:42:35.475]                 ...future.workdir <- getwd()
[17:42:35.475]             }
[17:42:35.475]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:35.475]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:35.475]         }
[17:42:35.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:35.475]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:35.475]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:35.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:35.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:35.475]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:35.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:35.475]             base::names(...future.oldOptions))
[17:42:35.475]     }
[17:42:35.475]     if (FALSE) {
[17:42:35.475]     }
[17:42:35.475]     else {
[17:42:35.475]         if (TRUE) {
[17:42:35.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:35.475]                 open = "w")
[17:42:35.475]         }
[17:42:35.475]         else {
[17:42:35.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:35.475]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:35.475]         }
[17:42:35.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:35.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:35.475]             base::sink(type = "output", split = FALSE)
[17:42:35.475]             base::close(...future.stdout)
[17:42:35.475]         }, add = TRUE)
[17:42:35.475]     }
[17:42:35.475]     ...future.frame <- base::sys.nframe()
[17:42:35.475]     ...future.conditions <- base::list()
[17:42:35.475]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:35.475]     if (FALSE) {
[17:42:35.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:35.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:35.475]     }
[17:42:35.475]     ...future.result <- base::tryCatch({
[17:42:35.475]         base::withCallingHandlers({
[17:42:35.475]             ...future.value <- base::withVisible(base::local({
[17:42:35.475]                 ...future.makeSendCondition <- local({
[17:42:35.475]                   sendCondition <- NULL
[17:42:35.475]                   function(frame = 1L) {
[17:42:35.475]                     if (is.function(sendCondition)) 
[17:42:35.475]                       return(sendCondition)
[17:42:35.475]                     ns <- getNamespace("parallel")
[17:42:35.475]                     if (exists("sendData", mode = "function", 
[17:42:35.475]                       envir = ns)) {
[17:42:35.475]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:35.475]                         envir = ns)
[17:42:35.475]                       envir <- sys.frame(frame)
[17:42:35.475]                       master <- NULL
[17:42:35.475]                       while (!identical(envir, .GlobalEnv) && 
[17:42:35.475]                         !identical(envir, emptyenv())) {
[17:42:35.475]                         if (exists("master", mode = "list", envir = envir, 
[17:42:35.475]                           inherits = FALSE)) {
[17:42:35.475]                           master <- get("master", mode = "list", 
[17:42:35.475]                             envir = envir, inherits = FALSE)
[17:42:35.475]                           if (inherits(master, c("SOCKnode", 
[17:42:35.475]                             "SOCK0node"))) {
[17:42:35.475]                             sendCondition <<- function(cond) {
[17:42:35.475]                               data <- list(type = "VALUE", value = cond, 
[17:42:35.475]                                 success = TRUE)
[17:42:35.475]                               parallel_sendData(master, data)
[17:42:35.475]                             }
[17:42:35.475]                             return(sendCondition)
[17:42:35.475]                           }
[17:42:35.475]                         }
[17:42:35.475]                         frame <- frame + 1L
[17:42:35.475]                         envir <- sys.frame(frame)
[17:42:35.475]                       }
[17:42:35.475]                     }
[17:42:35.475]                     sendCondition <<- function(cond) NULL
[17:42:35.475]                   }
[17:42:35.475]                 })
[17:42:35.475]                 withCallingHandlers({
[17:42:35.475]                   getOption("future.globals.onMissing")
[17:42:35.475]                 }, immediateCondition = function(cond) {
[17:42:35.475]                   sendCondition <- ...future.makeSendCondition()
[17:42:35.475]                   sendCondition(cond)
[17:42:35.475]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.475]                   {
[17:42:35.475]                     inherits <- base::inherits
[17:42:35.475]                     invokeRestart <- base::invokeRestart
[17:42:35.475]                     is.null <- base::is.null
[17:42:35.475]                     muffled <- FALSE
[17:42:35.475]                     if (inherits(cond, "message")) {
[17:42:35.475]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:35.475]                       if (muffled) 
[17:42:35.475]                         invokeRestart("muffleMessage")
[17:42:35.475]                     }
[17:42:35.475]                     else if (inherits(cond, "warning")) {
[17:42:35.475]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:35.475]                       if (muffled) 
[17:42:35.475]                         invokeRestart("muffleWarning")
[17:42:35.475]                     }
[17:42:35.475]                     else if (inherits(cond, "condition")) {
[17:42:35.475]                       if (!is.null(pattern)) {
[17:42:35.475]                         computeRestarts <- base::computeRestarts
[17:42:35.475]                         grepl <- base::grepl
[17:42:35.475]                         restarts <- computeRestarts(cond)
[17:42:35.475]                         for (restart in restarts) {
[17:42:35.475]                           name <- restart$name
[17:42:35.475]                           if (is.null(name)) 
[17:42:35.475]                             next
[17:42:35.475]                           if (!grepl(pattern, name)) 
[17:42:35.475]                             next
[17:42:35.475]                           invokeRestart(restart)
[17:42:35.475]                           muffled <- TRUE
[17:42:35.475]                           break
[17:42:35.475]                         }
[17:42:35.475]                       }
[17:42:35.475]                     }
[17:42:35.475]                     invisible(muffled)
[17:42:35.475]                   }
[17:42:35.475]                   muffleCondition(cond)
[17:42:35.475]                 })
[17:42:35.475]             }))
[17:42:35.475]             future::FutureResult(value = ...future.value$value, 
[17:42:35.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.475]                   ...future.rng), globalenv = if (FALSE) 
[17:42:35.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:35.475]                     ...future.globalenv.names))
[17:42:35.475]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:35.475]         }, condition = base::local({
[17:42:35.475]             c <- base::c
[17:42:35.475]             inherits <- base::inherits
[17:42:35.475]             invokeRestart <- base::invokeRestart
[17:42:35.475]             length <- base::length
[17:42:35.475]             list <- base::list
[17:42:35.475]             seq.int <- base::seq.int
[17:42:35.475]             signalCondition <- base::signalCondition
[17:42:35.475]             sys.calls <- base::sys.calls
[17:42:35.475]             `[[` <- base::`[[`
[17:42:35.475]             `+` <- base::`+`
[17:42:35.475]             `<<-` <- base::`<<-`
[17:42:35.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:35.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:35.475]                   3L)]
[17:42:35.475]             }
[17:42:35.475]             function(cond) {
[17:42:35.475]                 is_error <- inherits(cond, "error")
[17:42:35.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:35.475]                   NULL)
[17:42:35.475]                 if (is_error) {
[17:42:35.475]                   sessionInformation <- function() {
[17:42:35.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:35.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:35.475]                       search = base::search(), system = base::Sys.info())
[17:42:35.475]                   }
[17:42:35.475]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:35.475]                     cond$call), session = sessionInformation(), 
[17:42:35.475]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:35.475]                   signalCondition(cond)
[17:42:35.475]                 }
[17:42:35.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:35.475]                 "immediateCondition"))) {
[17:42:35.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:35.475]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:35.475]                   if (TRUE && !signal) {
[17:42:35.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.475]                     {
[17:42:35.475]                       inherits <- base::inherits
[17:42:35.475]                       invokeRestart <- base::invokeRestart
[17:42:35.475]                       is.null <- base::is.null
[17:42:35.475]                       muffled <- FALSE
[17:42:35.475]                       if (inherits(cond, "message")) {
[17:42:35.475]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.475]                         if (muffled) 
[17:42:35.475]                           invokeRestart("muffleMessage")
[17:42:35.475]                       }
[17:42:35.475]                       else if (inherits(cond, "warning")) {
[17:42:35.475]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.475]                         if (muffled) 
[17:42:35.475]                           invokeRestart("muffleWarning")
[17:42:35.475]                       }
[17:42:35.475]                       else if (inherits(cond, "condition")) {
[17:42:35.475]                         if (!is.null(pattern)) {
[17:42:35.475]                           computeRestarts <- base::computeRestarts
[17:42:35.475]                           grepl <- base::grepl
[17:42:35.475]                           restarts <- computeRestarts(cond)
[17:42:35.475]                           for (restart in restarts) {
[17:42:35.475]                             name <- restart$name
[17:42:35.475]                             if (is.null(name)) 
[17:42:35.475]                               next
[17:42:35.475]                             if (!grepl(pattern, name)) 
[17:42:35.475]                               next
[17:42:35.475]                             invokeRestart(restart)
[17:42:35.475]                             muffled <- TRUE
[17:42:35.475]                             break
[17:42:35.475]                           }
[17:42:35.475]                         }
[17:42:35.475]                       }
[17:42:35.475]                       invisible(muffled)
[17:42:35.475]                     }
[17:42:35.475]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.475]                   }
[17:42:35.475]                 }
[17:42:35.475]                 else {
[17:42:35.475]                   if (TRUE) {
[17:42:35.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.475]                     {
[17:42:35.475]                       inherits <- base::inherits
[17:42:35.475]                       invokeRestart <- base::invokeRestart
[17:42:35.475]                       is.null <- base::is.null
[17:42:35.475]                       muffled <- FALSE
[17:42:35.475]                       if (inherits(cond, "message")) {
[17:42:35.475]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.475]                         if (muffled) 
[17:42:35.475]                           invokeRestart("muffleMessage")
[17:42:35.475]                       }
[17:42:35.475]                       else if (inherits(cond, "warning")) {
[17:42:35.475]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.475]                         if (muffled) 
[17:42:35.475]                           invokeRestart("muffleWarning")
[17:42:35.475]                       }
[17:42:35.475]                       else if (inherits(cond, "condition")) {
[17:42:35.475]                         if (!is.null(pattern)) {
[17:42:35.475]                           computeRestarts <- base::computeRestarts
[17:42:35.475]                           grepl <- base::grepl
[17:42:35.475]                           restarts <- computeRestarts(cond)
[17:42:35.475]                           for (restart in restarts) {
[17:42:35.475]                             name <- restart$name
[17:42:35.475]                             if (is.null(name)) 
[17:42:35.475]                               next
[17:42:35.475]                             if (!grepl(pattern, name)) 
[17:42:35.475]                               next
[17:42:35.475]                             invokeRestart(restart)
[17:42:35.475]                             muffled <- TRUE
[17:42:35.475]                             break
[17:42:35.475]                           }
[17:42:35.475]                         }
[17:42:35.475]                       }
[17:42:35.475]                       invisible(muffled)
[17:42:35.475]                     }
[17:42:35.475]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.475]                   }
[17:42:35.475]                 }
[17:42:35.475]             }
[17:42:35.475]         }))
[17:42:35.475]     }, error = function(ex) {
[17:42:35.475]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:35.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.475]                 ...future.rng), started = ...future.startTime, 
[17:42:35.475]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:35.475]             version = "1.8"), class = "FutureResult")
[17:42:35.475]     }, finally = {
[17:42:35.475]         if (!identical(...future.workdir, getwd())) 
[17:42:35.475]             setwd(...future.workdir)
[17:42:35.475]         {
[17:42:35.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:35.475]                 ...future.oldOptions$nwarnings <- NULL
[17:42:35.475]             }
[17:42:35.475]             base::options(...future.oldOptions)
[17:42:35.475]             if (.Platform$OS.type == "windows") {
[17:42:35.475]                 old_names <- names(...future.oldEnvVars)
[17:42:35.475]                 envs <- base::Sys.getenv()
[17:42:35.475]                 names <- names(envs)
[17:42:35.475]                 common <- intersect(names, old_names)
[17:42:35.475]                 added <- setdiff(names, old_names)
[17:42:35.475]                 removed <- setdiff(old_names, names)
[17:42:35.475]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:35.475]                   envs[common]]
[17:42:35.475]                 NAMES <- toupper(changed)
[17:42:35.475]                 args <- list()
[17:42:35.475]                 for (kk in seq_along(NAMES)) {
[17:42:35.475]                   name <- changed[[kk]]
[17:42:35.475]                   NAME <- NAMES[[kk]]
[17:42:35.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.475]                     next
[17:42:35.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.475]                 }
[17:42:35.475]                 NAMES <- toupper(added)
[17:42:35.475]                 for (kk in seq_along(NAMES)) {
[17:42:35.475]                   name <- added[[kk]]
[17:42:35.475]                   NAME <- NAMES[[kk]]
[17:42:35.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.475]                     next
[17:42:35.475]                   args[[name]] <- ""
[17:42:35.475]                 }
[17:42:35.475]                 NAMES <- toupper(removed)
[17:42:35.475]                 for (kk in seq_along(NAMES)) {
[17:42:35.475]                   name <- removed[[kk]]
[17:42:35.475]                   NAME <- NAMES[[kk]]
[17:42:35.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.475]                     next
[17:42:35.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.475]                 }
[17:42:35.475]                 if (length(args) > 0) 
[17:42:35.475]                   base::do.call(base::Sys.setenv, args = args)
[17:42:35.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:35.475]             }
[17:42:35.475]             else {
[17:42:35.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:35.475]             }
[17:42:35.475]             {
[17:42:35.475]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:35.475]                   0L) {
[17:42:35.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:35.475]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:35.475]                   base::options(opts)
[17:42:35.475]                 }
[17:42:35.475]                 {
[17:42:35.475]                   {
[17:42:35.475]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:35.475]                     NULL
[17:42:35.475]                   }
[17:42:35.475]                   options(future.plan = NULL)
[17:42:35.475]                   if (is.na(NA_character_)) 
[17:42:35.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:35.475]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:35.475]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:35.475]                     envir = parent.frame()) 
[17:42:35.475]                   {
[17:42:35.475]                     if (is.function(workers)) 
[17:42:35.475]                       workers <- workers()
[17:42:35.475]                     workers <- structure(as.integer(workers), 
[17:42:35.475]                       class = class(workers))
[17:42:35.475]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:35.475]                       workers >= 1)
[17:42:35.475]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:35.475]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:35.475]                     }
[17:42:35.475]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:35.475]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:35.475]                       envir = envir)
[17:42:35.475]                     if (!future$lazy) 
[17:42:35.475]                       future <- run(future)
[17:42:35.475]                     invisible(future)
[17:42:35.475]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:35.475]                 }
[17:42:35.475]             }
[17:42:35.475]         }
[17:42:35.475]     })
[17:42:35.475]     if (TRUE) {
[17:42:35.475]         base::sink(type = "output", split = FALSE)
[17:42:35.475]         if (TRUE) {
[17:42:35.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:35.475]         }
[17:42:35.475]         else {
[17:42:35.475]             ...future.result["stdout"] <- base::list(NULL)
[17:42:35.475]         }
[17:42:35.475]         base::close(...future.stdout)
[17:42:35.475]         ...future.stdout <- NULL
[17:42:35.475]     }
[17:42:35.475]     ...future.result$conditions <- ...future.conditions
[17:42:35.475]     ...future.result$finished <- base::Sys.time()
[17:42:35.475]     ...future.result
[17:42:35.475] }
[17:42:35.479] MultisessionFuture started
[17:42:35.479] - Launch lazy future ... done
[17:42:35.479] run() for ‘MultisessionFuture’ ... done
[17:42:35.480] result() for ClusterFuture ...
[17:42:35.480] receiveMessageFromWorker() for ClusterFuture ...
[17:42:35.480] - Validating connection of MultisessionFuture
[17:42:35.528] - received message: FutureResult
[17:42:35.528] - Received FutureResult
[17:42:35.528] - Erased future from FutureRegistry
[17:42:35.529] result() for ClusterFuture ...
[17:42:35.529] - result already collected: FutureResult
[17:42:35.529] result() for ClusterFuture ... done
[17:42:35.529] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:35.529] result() for ClusterFuture ... done
[17:42:35.529] result() for ClusterFuture ...
[17:42:35.530] - result already collected: FutureResult
[17:42:35.530] result() for ClusterFuture ... done
[17:42:35.530] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:35.530] Searching for globals...
[17:42:35.532] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:35.532] Searching for globals...
[17:42:35.533] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[17:42:35.533] Searching for globals ... DONE
[17:42:35.534] Resolving globals: FALSE
[17:42:35.534] The total size of the 1 globals is 160 bytes (160 bytes)
[17:42:35.535] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[17:42:35.535] - globals: [1] ‘data’
[17:42:35.535] 
[17:42:35.535] getGlobalsAndPackages() ... DONE
[17:42:35.535] run() for ‘Future’ ...
[17:42:35.536] - state: ‘created’
[17:42:35.536] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:35.551] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:35.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:35.552]   - Field: ‘node’
[17:42:35.552]   - Field: ‘label’
[17:42:35.552]   - Field: ‘local’
[17:42:35.552]   - Field: ‘owner’
[17:42:35.552]   - Field: ‘envir’
[17:42:35.552]   - Field: ‘workers’
[17:42:35.553]   - Field: ‘packages’
[17:42:35.553]   - Field: ‘gc’
[17:42:35.553]   - Field: ‘conditions’
[17:42:35.553]   - Field: ‘persistent’
[17:42:35.553]   - Field: ‘expr’
[17:42:35.553]   - Field: ‘uuid’
[17:42:35.554]   - Field: ‘seed’
[17:42:35.554]   - Field: ‘version’
[17:42:35.554]   - Field: ‘result’
[17:42:35.554]   - Field: ‘asynchronous’
[17:42:35.555]   - Field: ‘calls’
[17:42:35.555]   - Field: ‘globals’
[17:42:35.555]   - Field: ‘stdout’
[17:42:35.555]   - Field: ‘earlySignal’
[17:42:35.555]   - Field: ‘lazy’
[17:42:35.555]   - Field: ‘state’
[17:42:35.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:35.556] - Launch lazy future ...
[17:42:35.556] Packages needed by the future expression (n = 0): <none>
[17:42:35.556] Packages needed by future strategies (n = 0): <none>
[17:42:35.557] {
[17:42:35.557]     {
[17:42:35.557]         {
[17:42:35.557]             ...future.startTime <- base::Sys.time()
[17:42:35.557]             {
[17:42:35.557]                 {
[17:42:35.557]                   {
[17:42:35.557]                     {
[17:42:35.557]                       base::local({
[17:42:35.557]                         has_future <- base::requireNamespace("future", 
[17:42:35.557]                           quietly = TRUE)
[17:42:35.557]                         if (has_future) {
[17:42:35.557]                           ns <- base::getNamespace("future")
[17:42:35.557]                           version <- ns[[".package"]][["version"]]
[17:42:35.557]                           if (is.null(version)) 
[17:42:35.557]                             version <- utils::packageVersion("future")
[17:42:35.557]                         }
[17:42:35.557]                         else {
[17:42:35.557]                           version <- NULL
[17:42:35.557]                         }
[17:42:35.557]                         if (!has_future || version < "1.8.0") {
[17:42:35.557]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:35.557]                             "", base::R.version$version.string), 
[17:42:35.557]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:35.557]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:35.557]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:35.557]                               "release", "version")], collapse = " "), 
[17:42:35.557]                             hostname = base::Sys.info()[["nodename"]])
[17:42:35.557]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:35.557]                             info)
[17:42:35.557]                           info <- base::paste(info, collapse = "; ")
[17:42:35.557]                           if (!has_future) {
[17:42:35.557]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:35.557]                               info)
[17:42:35.557]                           }
[17:42:35.557]                           else {
[17:42:35.557]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:35.557]                               info, version)
[17:42:35.557]                           }
[17:42:35.557]                           base::stop(msg)
[17:42:35.557]                         }
[17:42:35.557]                       })
[17:42:35.557]                     }
[17:42:35.557]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:35.557]                     base::options(mc.cores = 1L)
[17:42:35.557]                   }
[17:42:35.557]                   options(future.plan = NULL)
[17:42:35.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:35.557]                 }
[17:42:35.557]                 ...future.workdir <- getwd()
[17:42:35.557]             }
[17:42:35.557]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:35.557]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:35.557]         }
[17:42:35.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:35.557]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:35.557]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:35.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:35.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:35.557]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:35.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:35.557]             base::names(...future.oldOptions))
[17:42:35.557]     }
[17:42:35.557]     if (FALSE) {
[17:42:35.557]     }
[17:42:35.557]     else {
[17:42:35.557]         if (TRUE) {
[17:42:35.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:35.557]                 open = "w")
[17:42:35.557]         }
[17:42:35.557]         else {
[17:42:35.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:35.557]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:35.557]         }
[17:42:35.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:35.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:35.557]             base::sink(type = "output", split = FALSE)
[17:42:35.557]             base::close(...future.stdout)
[17:42:35.557]         }, add = TRUE)
[17:42:35.557]     }
[17:42:35.557]     ...future.frame <- base::sys.nframe()
[17:42:35.557]     ...future.conditions <- base::list()
[17:42:35.557]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:35.557]     if (FALSE) {
[17:42:35.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:35.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:35.557]     }
[17:42:35.557]     ...future.result <- base::tryCatch({
[17:42:35.557]         base::withCallingHandlers({
[17:42:35.557]             ...future.value <- base::withVisible(base::local({
[17:42:35.557]                 ...future.makeSendCondition <- local({
[17:42:35.557]                   sendCondition <- NULL
[17:42:35.557]                   function(frame = 1L) {
[17:42:35.557]                     if (is.function(sendCondition)) 
[17:42:35.557]                       return(sendCondition)
[17:42:35.557]                     ns <- getNamespace("parallel")
[17:42:35.557]                     if (exists("sendData", mode = "function", 
[17:42:35.557]                       envir = ns)) {
[17:42:35.557]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:35.557]                         envir = ns)
[17:42:35.557]                       envir <- sys.frame(frame)
[17:42:35.557]                       master <- NULL
[17:42:35.557]                       while (!identical(envir, .GlobalEnv) && 
[17:42:35.557]                         !identical(envir, emptyenv())) {
[17:42:35.557]                         if (exists("master", mode = "list", envir = envir, 
[17:42:35.557]                           inherits = FALSE)) {
[17:42:35.557]                           master <- get("master", mode = "list", 
[17:42:35.557]                             envir = envir, inherits = FALSE)
[17:42:35.557]                           if (inherits(master, c("SOCKnode", 
[17:42:35.557]                             "SOCK0node"))) {
[17:42:35.557]                             sendCondition <<- function(cond) {
[17:42:35.557]                               data <- list(type = "VALUE", value = cond, 
[17:42:35.557]                                 success = TRUE)
[17:42:35.557]                               parallel_sendData(master, data)
[17:42:35.557]                             }
[17:42:35.557]                             return(sendCondition)
[17:42:35.557]                           }
[17:42:35.557]                         }
[17:42:35.557]                         frame <- frame + 1L
[17:42:35.557]                         envir <- sys.frame(frame)
[17:42:35.557]                       }
[17:42:35.557]                     }
[17:42:35.557]                     sendCondition <<- function(cond) NULL
[17:42:35.557]                   }
[17:42:35.557]                 })
[17:42:35.557]                 withCallingHandlers({
[17:42:35.557]                   subset(data, x < 3)$y
[17:42:35.557]                 }, immediateCondition = function(cond) {
[17:42:35.557]                   sendCondition <- ...future.makeSendCondition()
[17:42:35.557]                   sendCondition(cond)
[17:42:35.557]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.557]                   {
[17:42:35.557]                     inherits <- base::inherits
[17:42:35.557]                     invokeRestart <- base::invokeRestart
[17:42:35.557]                     is.null <- base::is.null
[17:42:35.557]                     muffled <- FALSE
[17:42:35.557]                     if (inherits(cond, "message")) {
[17:42:35.557]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:35.557]                       if (muffled) 
[17:42:35.557]                         invokeRestart("muffleMessage")
[17:42:35.557]                     }
[17:42:35.557]                     else if (inherits(cond, "warning")) {
[17:42:35.557]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:35.557]                       if (muffled) 
[17:42:35.557]                         invokeRestart("muffleWarning")
[17:42:35.557]                     }
[17:42:35.557]                     else if (inherits(cond, "condition")) {
[17:42:35.557]                       if (!is.null(pattern)) {
[17:42:35.557]                         computeRestarts <- base::computeRestarts
[17:42:35.557]                         grepl <- base::grepl
[17:42:35.557]                         restarts <- computeRestarts(cond)
[17:42:35.557]                         for (restart in restarts) {
[17:42:35.557]                           name <- restart$name
[17:42:35.557]                           if (is.null(name)) 
[17:42:35.557]                             next
[17:42:35.557]                           if (!grepl(pattern, name)) 
[17:42:35.557]                             next
[17:42:35.557]                           invokeRestart(restart)
[17:42:35.557]                           muffled <- TRUE
[17:42:35.557]                           break
[17:42:35.557]                         }
[17:42:35.557]                       }
[17:42:35.557]                     }
[17:42:35.557]                     invisible(muffled)
[17:42:35.557]                   }
[17:42:35.557]                   muffleCondition(cond)
[17:42:35.557]                 })
[17:42:35.557]             }))
[17:42:35.557]             future::FutureResult(value = ...future.value$value, 
[17:42:35.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.557]                   ...future.rng), globalenv = if (FALSE) 
[17:42:35.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:35.557]                     ...future.globalenv.names))
[17:42:35.557]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:35.557]         }, condition = base::local({
[17:42:35.557]             c <- base::c
[17:42:35.557]             inherits <- base::inherits
[17:42:35.557]             invokeRestart <- base::invokeRestart
[17:42:35.557]             length <- base::length
[17:42:35.557]             list <- base::list
[17:42:35.557]             seq.int <- base::seq.int
[17:42:35.557]             signalCondition <- base::signalCondition
[17:42:35.557]             sys.calls <- base::sys.calls
[17:42:35.557]             `[[` <- base::`[[`
[17:42:35.557]             `+` <- base::`+`
[17:42:35.557]             `<<-` <- base::`<<-`
[17:42:35.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:35.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:35.557]                   3L)]
[17:42:35.557]             }
[17:42:35.557]             function(cond) {
[17:42:35.557]                 is_error <- inherits(cond, "error")
[17:42:35.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:35.557]                   NULL)
[17:42:35.557]                 if (is_error) {
[17:42:35.557]                   sessionInformation <- function() {
[17:42:35.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:35.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:35.557]                       search = base::search(), system = base::Sys.info())
[17:42:35.557]                   }
[17:42:35.557]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:35.557]                     cond$call), session = sessionInformation(), 
[17:42:35.557]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:35.557]                   signalCondition(cond)
[17:42:35.557]                 }
[17:42:35.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:35.557]                 "immediateCondition"))) {
[17:42:35.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:35.557]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:35.557]                   if (TRUE && !signal) {
[17:42:35.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.557]                     {
[17:42:35.557]                       inherits <- base::inherits
[17:42:35.557]                       invokeRestart <- base::invokeRestart
[17:42:35.557]                       is.null <- base::is.null
[17:42:35.557]                       muffled <- FALSE
[17:42:35.557]                       if (inherits(cond, "message")) {
[17:42:35.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.557]                         if (muffled) 
[17:42:35.557]                           invokeRestart("muffleMessage")
[17:42:35.557]                       }
[17:42:35.557]                       else if (inherits(cond, "warning")) {
[17:42:35.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.557]                         if (muffled) 
[17:42:35.557]                           invokeRestart("muffleWarning")
[17:42:35.557]                       }
[17:42:35.557]                       else if (inherits(cond, "condition")) {
[17:42:35.557]                         if (!is.null(pattern)) {
[17:42:35.557]                           computeRestarts <- base::computeRestarts
[17:42:35.557]                           grepl <- base::grepl
[17:42:35.557]                           restarts <- computeRestarts(cond)
[17:42:35.557]                           for (restart in restarts) {
[17:42:35.557]                             name <- restart$name
[17:42:35.557]                             if (is.null(name)) 
[17:42:35.557]                               next
[17:42:35.557]                             if (!grepl(pattern, name)) 
[17:42:35.557]                               next
[17:42:35.557]                             invokeRestart(restart)
[17:42:35.557]                             muffled <- TRUE
[17:42:35.557]                             break
[17:42:35.557]                           }
[17:42:35.557]                         }
[17:42:35.557]                       }
[17:42:35.557]                       invisible(muffled)
[17:42:35.557]                     }
[17:42:35.557]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.557]                   }
[17:42:35.557]                 }
[17:42:35.557]                 else {
[17:42:35.557]                   if (TRUE) {
[17:42:35.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.557]                     {
[17:42:35.557]                       inherits <- base::inherits
[17:42:35.557]                       invokeRestart <- base::invokeRestart
[17:42:35.557]                       is.null <- base::is.null
[17:42:35.557]                       muffled <- FALSE
[17:42:35.557]                       if (inherits(cond, "message")) {
[17:42:35.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.557]                         if (muffled) 
[17:42:35.557]                           invokeRestart("muffleMessage")
[17:42:35.557]                       }
[17:42:35.557]                       else if (inherits(cond, "warning")) {
[17:42:35.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.557]                         if (muffled) 
[17:42:35.557]                           invokeRestart("muffleWarning")
[17:42:35.557]                       }
[17:42:35.557]                       else if (inherits(cond, "condition")) {
[17:42:35.557]                         if (!is.null(pattern)) {
[17:42:35.557]                           computeRestarts <- base::computeRestarts
[17:42:35.557]                           grepl <- base::grepl
[17:42:35.557]                           restarts <- computeRestarts(cond)
[17:42:35.557]                           for (restart in restarts) {
[17:42:35.557]                             name <- restart$name
[17:42:35.557]                             if (is.null(name)) 
[17:42:35.557]                               next
[17:42:35.557]                             if (!grepl(pattern, name)) 
[17:42:35.557]                               next
[17:42:35.557]                             invokeRestart(restart)
[17:42:35.557]                             muffled <- TRUE
[17:42:35.557]                             break
[17:42:35.557]                           }
[17:42:35.557]                         }
[17:42:35.557]                       }
[17:42:35.557]                       invisible(muffled)
[17:42:35.557]                     }
[17:42:35.557]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.557]                   }
[17:42:35.557]                 }
[17:42:35.557]             }
[17:42:35.557]         }))
[17:42:35.557]     }, error = function(ex) {
[17:42:35.557]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:35.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.557]                 ...future.rng), started = ...future.startTime, 
[17:42:35.557]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:35.557]             version = "1.8"), class = "FutureResult")
[17:42:35.557]     }, finally = {
[17:42:35.557]         if (!identical(...future.workdir, getwd())) 
[17:42:35.557]             setwd(...future.workdir)
[17:42:35.557]         {
[17:42:35.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:35.557]                 ...future.oldOptions$nwarnings <- NULL
[17:42:35.557]             }
[17:42:35.557]             base::options(...future.oldOptions)
[17:42:35.557]             if (.Platform$OS.type == "windows") {
[17:42:35.557]                 old_names <- names(...future.oldEnvVars)
[17:42:35.557]                 envs <- base::Sys.getenv()
[17:42:35.557]                 names <- names(envs)
[17:42:35.557]                 common <- intersect(names, old_names)
[17:42:35.557]                 added <- setdiff(names, old_names)
[17:42:35.557]                 removed <- setdiff(old_names, names)
[17:42:35.557]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:35.557]                   envs[common]]
[17:42:35.557]                 NAMES <- toupper(changed)
[17:42:35.557]                 args <- list()
[17:42:35.557]                 for (kk in seq_along(NAMES)) {
[17:42:35.557]                   name <- changed[[kk]]
[17:42:35.557]                   NAME <- NAMES[[kk]]
[17:42:35.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.557]                     next
[17:42:35.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.557]                 }
[17:42:35.557]                 NAMES <- toupper(added)
[17:42:35.557]                 for (kk in seq_along(NAMES)) {
[17:42:35.557]                   name <- added[[kk]]
[17:42:35.557]                   NAME <- NAMES[[kk]]
[17:42:35.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.557]                     next
[17:42:35.557]                   args[[name]] <- ""
[17:42:35.557]                 }
[17:42:35.557]                 NAMES <- toupper(removed)
[17:42:35.557]                 for (kk in seq_along(NAMES)) {
[17:42:35.557]                   name <- removed[[kk]]
[17:42:35.557]                   NAME <- NAMES[[kk]]
[17:42:35.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.557]                     next
[17:42:35.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.557]                 }
[17:42:35.557]                 if (length(args) > 0) 
[17:42:35.557]                   base::do.call(base::Sys.setenv, args = args)
[17:42:35.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:35.557]             }
[17:42:35.557]             else {
[17:42:35.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:35.557]             }
[17:42:35.557]             {
[17:42:35.557]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:35.557]                   0L) {
[17:42:35.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:35.557]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:35.557]                   base::options(opts)
[17:42:35.557]                 }
[17:42:35.557]                 {
[17:42:35.557]                   {
[17:42:35.557]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:35.557]                     NULL
[17:42:35.557]                   }
[17:42:35.557]                   options(future.plan = NULL)
[17:42:35.557]                   if (is.na(NA_character_)) 
[17:42:35.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:35.557]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:35.557]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:35.557]                     envir = parent.frame()) 
[17:42:35.557]                   {
[17:42:35.557]                     if (is.function(workers)) 
[17:42:35.557]                       workers <- workers()
[17:42:35.557]                     workers <- structure(as.integer(workers), 
[17:42:35.557]                       class = class(workers))
[17:42:35.557]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:35.557]                       workers >= 1)
[17:42:35.557]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:35.557]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:35.557]                     }
[17:42:35.557]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:35.557]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:35.557]                       envir = envir)
[17:42:35.557]                     if (!future$lazy) 
[17:42:35.557]                       future <- run(future)
[17:42:35.557]                     invisible(future)
[17:42:35.557]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:35.557]                 }
[17:42:35.557]             }
[17:42:35.557]         }
[17:42:35.557]     })
[17:42:35.557]     if (TRUE) {
[17:42:35.557]         base::sink(type = "output", split = FALSE)
[17:42:35.557]         if (TRUE) {
[17:42:35.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:35.557]         }
[17:42:35.557]         else {
[17:42:35.557]             ...future.result["stdout"] <- base::list(NULL)
[17:42:35.557]         }
[17:42:35.557]         base::close(...future.stdout)
[17:42:35.557]         ...future.stdout <- NULL
[17:42:35.557]     }
[17:42:35.557]     ...future.result$conditions <- ...future.conditions
[17:42:35.557]     ...future.result$finished <- base::Sys.time()
[17:42:35.557]     ...future.result
[17:42:35.557] }
[17:42:35.560] Exporting 1 global objects (160 bytes) to cluster node #1 ...
[17:42:35.560] Exporting ‘data’ (160 bytes) to cluster node #1 ...
[17:42:35.560] Exporting ‘data’ (160 bytes) to cluster node #1 ... DONE
[17:42:35.561] Exporting 1 global objects (160 bytes) to cluster node #1 ... DONE
[17:42:35.561] MultisessionFuture started
[17:42:35.561] - Launch lazy future ... done
[17:42:35.562] run() for ‘MultisessionFuture’ ... done
[17:42:35.562] result() for ClusterFuture ...
[17:42:35.562] receiveMessageFromWorker() for ClusterFuture ...
[17:42:35.562] - Validating connection of MultisessionFuture
[17:42:35.610] - received message: FutureResult
[17:42:35.611] - Received FutureResult
[17:42:35.611] - Erased future from FutureRegistry
[17:42:35.611] result() for ClusterFuture ...
[17:42:35.611] - result already collected: FutureResult
[17:42:35.611] result() for ClusterFuture ... done
[17:42:35.611] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:35.611] result() for ClusterFuture ... done
[17:42:35.612] result() for ClusterFuture ...
[17:42:35.612] - result already collected: FutureResult
[17:42:35.612] result() for ClusterFuture ... done
[17:42:35.612] plan(): Setting new future strategy stack:
[17:42:35.612] List of future strategies:
[17:42:35.612] 1. sequential:
[17:42:35.612]    - args: function (..., envir = parent.frame())
[17:42:35.612]    - tweaked: FALSE
[17:42:35.612]    - call: plan(list(sequential, strategy))
[17:42:35.612] 2. multisession:
[17:42:35.612]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:35.612]    - tweaked: FALSE
[17:42:35.612]    - call: plan(list(sequential, strategy))
[17:42:35.614] plan(): nbrOfWorkers() = 1
[17:42:35.614] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:35.615] Searching for globals...
[17:42:35.623] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[17:42:35.623] Searching for globals ... DONE
[17:42:35.623] Resolving globals: FALSE
[17:42:35.624] The total size of the 1 globals is 160 bytes (160 bytes)
[17:42:35.625] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[17:42:35.625] - globals: [1] ‘data’
[17:42:35.625] - packages: [1] ‘future’
[17:42:35.625] getGlobalsAndPackages() ... DONE
[17:42:35.626] run() for ‘Future’ ...
[17:42:35.626] - state: ‘created’
[17:42:35.626] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:35.627] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:35.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:35.627]   - Field: ‘label’
[17:42:35.627]   - Field: ‘local’
[17:42:35.627]   - Field: ‘owner’
[17:42:35.628]   - Field: ‘envir’
[17:42:35.628]   - Field: ‘packages’
[17:42:35.628]   - Field: ‘gc’
[17:42:35.628]   - Field: ‘conditions’
[17:42:35.628]   - Field: ‘expr’
[17:42:35.628]   - Field: ‘uuid’
[17:42:35.629]   - Field: ‘seed’
[17:42:35.629]   - Field: ‘version’
[17:42:35.629]   - Field: ‘result’
[17:42:35.629]   - Field: ‘asynchronous’
[17:42:35.629]   - Field: ‘calls’
[17:42:35.629]   - Field: ‘globals’
[17:42:35.629]   - Field: ‘stdout’
[17:42:35.629]   - Field: ‘earlySignal’
[17:42:35.630]   - Field: ‘lazy’
[17:42:35.630]   - Field: ‘state’
[17:42:35.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:35.630] - Launch lazy future ...
[17:42:35.630] Packages needed by the future expression (n = 1): ‘future’
[17:42:35.630] Packages needed by future strategies (n = 1): ‘future’
[17:42:35.631] {
[17:42:35.631]     {
[17:42:35.631]         {
[17:42:35.631]             ...future.startTime <- base::Sys.time()
[17:42:35.631]             {
[17:42:35.631]                 {
[17:42:35.631]                   {
[17:42:35.631]                     {
[17:42:35.631]                       base::local({
[17:42:35.631]                         has_future <- base::requireNamespace("future", 
[17:42:35.631]                           quietly = TRUE)
[17:42:35.631]                         if (has_future) {
[17:42:35.631]                           ns <- base::getNamespace("future")
[17:42:35.631]                           version <- ns[[".package"]][["version"]]
[17:42:35.631]                           if (is.null(version)) 
[17:42:35.631]                             version <- utils::packageVersion("future")
[17:42:35.631]                         }
[17:42:35.631]                         else {
[17:42:35.631]                           version <- NULL
[17:42:35.631]                         }
[17:42:35.631]                         if (!has_future || version < "1.8.0") {
[17:42:35.631]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:35.631]                             "", base::R.version$version.string), 
[17:42:35.631]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:35.631]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:35.631]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:35.631]                               "release", "version")], collapse = " "), 
[17:42:35.631]                             hostname = base::Sys.info()[["nodename"]])
[17:42:35.631]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:35.631]                             info)
[17:42:35.631]                           info <- base::paste(info, collapse = "; ")
[17:42:35.631]                           if (!has_future) {
[17:42:35.631]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:35.631]                               info)
[17:42:35.631]                           }
[17:42:35.631]                           else {
[17:42:35.631]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:35.631]                               info, version)
[17:42:35.631]                           }
[17:42:35.631]                           base::stop(msg)
[17:42:35.631]                         }
[17:42:35.631]                       })
[17:42:35.631]                     }
[17:42:35.631]                     base::local({
[17:42:35.631]                       for (pkg in "future") {
[17:42:35.631]                         base::loadNamespace(pkg)
[17:42:35.631]                         base::library(pkg, character.only = TRUE)
[17:42:35.631]                       }
[17:42:35.631]                     })
[17:42:35.631]                   }
[17:42:35.631]                   options(future.plan = NULL)
[17:42:35.631]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.631]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:35.631]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:35.631]                     envir = parent.frame()) 
[17:42:35.631]                   {
[17:42:35.631]                     if (is.function(workers)) 
[17:42:35.631]                       workers <- workers()
[17:42:35.631]                     workers <- structure(as.integer(workers), 
[17:42:35.631]                       class = class(workers))
[17:42:35.631]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:35.631]                       workers >= 1)
[17:42:35.631]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:35.631]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:35.631]                     }
[17:42:35.631]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:35.631]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:35.631]                       envir = envir)
[17:42:35.631]                     if (!future$lazy) 
[17:42:35.631]                       future <- run(future)
[17:42:35.631]                     invisible(future)
[17:42:35.631]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:35.631]                 }
[17:42:35.631]                 ...future.workdir <- getwd()
[17:42:35.631]             }
[17:42:35.631]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:35.631]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:35.631]         }
[17:42:35.631]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:35.631]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:35.631]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:35.631]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:35.631]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:35.631]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:35.631]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:35.631]             base::names(...future.oldOptions))
[17:42:35.631]     }
[17:42:35.631]     if (FALSE) {
[17:42:35.631]     }
[17:42:35.631]     else {
[17:42:35.631]         if (TRUE) {
[17:42:35.631]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:35.631]                 open = "w")
[17:42:35.631]         }
[17:42:35.631]         else {
[17:42:35.631]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:35.631]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:35.631]         }
[17:42:35.631]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:35.631]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:35.631]             base::sink(type = "output", split = FALSE)
[17:42:35.631]             base::close(...future.stdout)
[17:42:35.631]         }, add = TRUE)
[17:42:35.631]     }
[17:42:35.631]     ...future.frame <- base::sys.nframe()
[17:42:35.631]     ...future.conditions <- base::list()
[17:42:35.631]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:35.631]     if (FALSE) {
[17:42:35.631]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:35.631]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:35.631]     }
[17:42:35.631]     ...future.result <- base::tryCatch({
[17:42:35.631]         base::withCallingHandlers({
[17:42:35.631]             ...future.value <- base::withVisible(base::local({
[17:42:35.631]                 a %<-% subset(data, x < 3)$y
[17:42:35.631]                 a
[17:42:35.631]             }))
[17:42:35.631]             future::FutureResult(value = ...future.value$value, 
[17:42:35.631]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.631]                   ...future.rng), globalenv = if (FALSE) 
[17:42:35.631]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:35.631]                     ...future.globalenv.names))
[17:42:35.631]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:35.631]         }, condition = base::local({
[17:42:35.631]             c <- base::c
[17:42:35.631]             inherits <- base::inherits
[17:42:35.631]             invokeRestart <- base::invokeRestart
[17:42:35.631]             length <- base::length
[17:42:35.631]             list <- base::list
[17:42:35.631]             seq.int <- base::seq.int
[17:42:35.631]             signalCondition <- base::signalCondition
[17:42:35.631]             sys.calls <- base::sys.calls
[17:42:35.631]             `[[` <- base::`[[`
[17:42:35.631]             `+` <- base::`+`
[17:42:35.631]             `<<-` <- base::`<<-`
[17:42:35.631]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:35.631]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:35.631]                   3L)]
[17:42:35.631]             }
[17:42:35.631]             function(cond) {
[17:42:35.631]                 is_error <- inherits(cond, "error")
[17:42:35.631]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:35.631]                   NULL)
[17:42:35.631]                 if (is_error) {
[17:42:35.631]                   sessionInformation <- function() {
[17:42:35.631]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:35.631]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:35.631]                       search = base::search(), system = base::Sys.info())
[17:42:35.631]                   }
[17:42:35.631]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.631]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:35.631]                     cond$call), session = sessionInformation(), 
[17:42:35.631]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:35.631]                   signalCondition(cond)
[17:42:35.631]                 }
[17:42:35.631]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:35.631]                 "immediateCondition"))) {
[17:42:35.631]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:35.631]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.631]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:35.631]                   if (TRUE && !signal) {
[17:42:35.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.631]                     {
[17:42:35.631]                       inherits <- base::inherits
[17:42:35.631]                       invokeRestart <- base::invokeRestart
[17:42:35.631]                       is.null <- base::is.null
[17:42:35.631]                       muffled <- FALSE
[17:42:35.631]                       if (inherits(cond, "message")) {
[17:42:35.631]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.631]                         if (muffled) 
[17:42:35.631]                           invokeRestart("muffleMessage")
[17:42:35.631]                       }
[17:42:35.631]                       else if (inherits(cond, "warning")) {
[17:42:35.631]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.631]                         if (muffled) 
[17:42:35.631]                           invokeRestart("muffleWarning")
[17:42:35.631]                       }
[17:42:35.631]                       else if (inherits(cond, "condition")) {
[17:42:35.631]                         if (!is.null(pattern)) {
[17:42:35.631]                           computeRestarts <- base::computeRestarts
[17:42:35.631]                           grepl <- base::grepl
[17:42:35.631]                           restarts <- computeRestarts(cond)
[17:42:35.631]                           for (restart in restarts) {
[17:42:35.631]                             name <- restart$name
[17:42:35.631]                             if (is.null(name)) 
[17:42:35.631]                               next
[17:42:35.631]                             if (!grepl(pattern, name)) 
[17:42:35.631]                               next
[17:42:35.631]                             invokeRestart(restart)
[17:42:35.631]                             muffled <- TRUE
[17:42:35.631]                             break
[17:42:35.631]                           }
[17:42:35.631]                         }
[17:42:35.631]                       }
[17:42:35.631]                       invisible(muffled)
[17:42:35.631]                     }
[17:42:35.631]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.631]                   }
[17:42:35.631]                 }
[17:42:35.631]                 else {
[17:42:35.631]                   if (TRUE) {
[17:42:35.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.631]                     {
[17:42:35.631]                       inherits <- base::inherits
[17:42:35.631]                       invokeRestart <- base::invokeRestart
[17:42:35.631]                       is.null <- base::is.null
[17:42:35.631]                       muffled <- FALSE
[17:42:35.631]                       if (inherits(cond, "message")) {
[17:42:35.631]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.631]                         if (muffled) 
[17:42:35.631]                           invokeRestart("muffleMessage")
[17:42:35.631]                       }
[17:42:35.631]                       else if (inherits(cond, "warning")) {
[17:42:35.631]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.631]                         if (muffled) 
[17:42:35.631]                           invokeRestart("muffleWarning")
[17:42:35.631]                       }
[17:42:35.631]                       else if (inherits(cond, "condition")) {
[17:42:35.631]                         if (!is.null(pattern)) {
[17:42:35.631]                           computeRestarts <- base::computeRestarts
[17:42:35.631]                           grepl <- base::grepl
[17:42:35.631]                           restarts <- computeRestarts(cond)
[17:42:35.631]                           for (restart in restarts) {
[17:42:35.631]                             name <- restart$name
[17:42:35.631]                             if (is.null(name)) 
[17:42:35.631]                               next
[17:42:35.631]                             if (!grepl(pattern, name)) 
[17:42:35.631]                               next
[17:42:35.631]                             invokeRestart(restart)
[17:42:35.631]                             muffled <- TRUE
[17:42:35.631]                             break
[17:42:35.631]                           }
[17:42:35.631]                         }
[17:42:35.631]                       }
[17:42:35.631]                       invisible(muffled)
[17:42:35.631]                     }
[17:42:35.631]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.631]                   }
[17:42:35.631]                 }
[17:42:35.631]             }
[17:42:35.631]         }))
[17:42:35.631]     }, error = function(ex) {
[17:42:35.631]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:35.631]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.631]                 ...future.rng), started = ...future.startTime, 
[17:42:35.631]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:35.631]             version = "1.8"), class = "FutureResult")
[17:42:35.631]     }, finally = {
[17:42:35.631]         if (!identical(...future.workdir, getwd())) 
[17:42:35.631]             setwd(...future.workdir)
[17:42:35.631]         {
[17:42:35.631]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:35.631]                 ...future.oldOptions$nwarnings <- NULL
[17:42:35.631]             }
[17:42:35.631]             base::options(...future.oldOptions)
[17:42:35.631]             if (.Platform$OS.type == "windows") {
[17:42:35.631]                 old_names <- names(...future.oldEnvVars)
[17:42:35.631]                 envs <- base::Sys.getenv()
[17:42:35.631]                 names <- names(envs)
[17:42:35.631]                 common <- intersect(names, old_names)
[17:42:35.631]                 added <- setdiff(names, old_names)
[17:42:35.631]                 removed <- setdiff(old_names, names)
[17:42:35.631]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:35.631]                   envs[common]]
[17:42:35.631]                 NAMES <- toupper(changed)
[17:42:35.631]                 args <- list()
[17:42:35.631]                 for (kk in seq_along(NAMES)) {
[17:42:35.631]                   name <- changed[[kk]]
[17:42:35.631]                   NAME <- NAMES[[kk]]
[17:42:35.631]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.631]                     next
[17:42:35.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.631]                 }
[17:42:35.631]                 NAMES <- toupper(added)
[17:42:35.631]                 for (kk in seq_along(NAMES)) {
[17:42:35.631]                   name <- added[[kk]]
[17:42:35.631]                   NAME <- NAMES[[kk]]
[17:42:35.631]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.631]                     next
[17:42:35.631]                   args[[name]] <- ""
[17:42:35.631]                 }
[17:42:35.631]                 NAMES <- toupper(removed)
[17:42:35.631]                 for (kk in seq_along(NAMES)) {
[17:42:35.631]                   name <- removed[[kk]]
[17:42:35.631]                   NAME <- NAMES[[kk]]
[17:42:35.631]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.631]                     next
[17:42:35.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.631]                 }
[17:42:35.631]                 if (length(args) > 0) 
[17:42:35.631]                   base::do.call(base::Sys.setenv, args = args)
[17:42:35.631]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:35.631]             }
[17:42:35.631]             else {
[17:42:35.631]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:35.631]             }
[17:42:35.631]             {
[17:42:35.631]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:35.631]                   0L) {
[17:42:35.631]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:35.631]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:35.631]                   base::options(opts)
[17:42:35.631]                 }
[17:42:35.631]                 {
[17:42:35.631]                   {
[17:42:35.631]                     NULL
[17:42:35.631]                     RNGkind("Mersenne-Twister")
[17:42:35.631]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:35.631]                       inherits = FALSE)
[17:42:35.631]                   }
[17:42:35.631]                   options(future.plan = NULL)
[17:42:35.631]                   if (is.na(NA_character_)) 
[17:42:35.631]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.631]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:35.631]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:35.631]                   {
[17:42:35.631]                     future <- SequentialFuture(..., envir = envir)
[17:42:35.631]                     if (!future$lazy) 
[17:42:35.631]                       future <- run(future)
[17:42:35.631]                     invisible(future)
[17:42:35.631]                   }, function (..., workers = availableCores(), 
[17:42:35.631]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:35.631]                     envir = parent.frame()) 
[17:42:35.631]                   {
[17:42:35.631]                     if (is.function(workers)) 
[17:42:35.631]                       workers <- workers()
[17:42:35.631]                     workers <- structure(as.integer(workers), 
[17:42:35.631]                       class = class(workers))
[17:42:35.631]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:35.631]                       workers >= 1)
[17:42:35.631]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:35.631]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:35.631]                     }
[17:42:35.631]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:35.631]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:35.631]                       envir = envir)
[17:42:35.631]                     if (!future$lazy) 
[17:42:35.631]                       future <- run(future)
[17:42:35.631]                     invisible(future)
[17:42:35.631]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:35.631]                 }
[17:42:35.631]             }
[17:42:35.631]         }
[17:42:35.631]     })
[17:42:35.631]     if (TRUE) {
[17:42:35.631]         base::sink(type = "output", split = FALSE)
[17:42:35.631]         if (TRUE) {
[17:42:35.631]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:35.631]         }
[17:42:35.631]         else {
[17:42:35.631]             ...future.result["stdout"] <- base::list(NULL)
[17:42:35.631]         }
[17:42:35.631]         base::close(...future.stdout)
[17:42:35.631]         ...future.stdout <- NULL
[17:42:35.631]     }
[17:42:35.631]     ...future.result$conditions <- ...future.conditions
[17:42:35.631]     ...future.result$finished <- base::Sys.time()
[17:42:35.631]     ...future.result
[17:42:35.631] }
[17:42:35.634] assign_globals() ...
[17:42:35.634] List of 1
[17:42:35.634]  $ data:'data.frame':	5 obs. of  2 variables:
[17:42:35.634]   ..$ x: int [1:5] 1 2 3 4 5
[17:42:35.634]   ..$ y: int [1:5] 1 2 3 4 5
[17:42:35.634]  - attr(*, "where")=List of 1
[17:42:35.634]   ..$ data:<environment: R_EmptyEnv> 
[17:42:35.634]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:35.634]  - attr(*, "resolved")= logi FALSE
[17:42:35.634]  - attr(*, "total_size")= num 160
[17:42:35.634]  - attr(*, "already-done")= logi TRUE
[17:42:35.638] - copied ‘data’ to environment
[17:42:35.639] assign_globals() ... done
[17:42:35.639] plan(): Setting new future strategy stack:
[17:42:35.639] List of future strategies:
[17:42:35.639] 1. multisession:
[17:42:35.639]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:35.639]    - tweaked: FALSE
[17:42:35.639]    - call: plan(list(sequential, strategy))
[17:42:35.643] plan(): nbrOfWorkers() = 2
[17:42:36.127] plan(): Setting new future strategy stack:
[17:42:36.127] List of future strategies:
[17:42:36.127] 1. sequential:
[17:42:36.127]    - args: function (..., envir = parent.frame())
[17:42:36.127]    - tweaked: FALSE
[17:42:36.127]    - call: plan(list(sequential, strategy))
[17:42:36.127] 2. multisession:
[17:42:36.127]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:36.127]    - tweaked: FALSE
[17:42:36.127]    - call: plan(list(sequential, strategy))
[17:42:36.127] plan(): nbrOfWorkers() = 1
[17:42:36.128] SequentialFuture started (and completed)
[17:42:36.128] signalConditions() ...
[17:42:36.128]  - include = ‘immediateCondition’
[17:42:36.128]  - exclude = 
[17:42:36.128]  - resignal = FALSE
[17:42:36.128]  - Number of conditions: 92
[17:42:36.128] signalConditions() ... done
[17:42:36.128] - Launch lazy future ... done
[17:42:36.128] run() for ‘SequentialFuture’ ... done
[17:42:36.129] signalConditions() ...
[17:42:36.129]  - include = ‘immediateCondition’
[17:42:36.129]  - exclude = 
[17:42:36.129]  - resignal = FALSE
[17:42:36.129]  - Number of conditions: 92
[17:42:36.129] signalConditions() ... done
[17:42:36.129] Future state: ‘finished’
[17:42:36.129] signalConditions() ...
[17:42:36.129]  - include = ‘condition’
[17:42:36.129]  - exclude = ‘immediateCondition’
[17:42:36.129]  - resignal = TRUE
[17:42:36.130]  - Number of conditions: 92
[17:42:36.130]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.644] getGlobalsAndPackages() ...
[17:42:36.130]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[17:42:36.130]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.658] Searching for globals...
[17:42:36.130]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.659] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[17:42:36.130]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.659] Searching for globals ... DONE
[17:42:36.130]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.659] Resolving globals: FALSE
[17:42:36.130]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.660] The total size of the 1 globals is 160 bytes (160 bytes)
[17:42:36.131]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.660] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[17:42:36.131]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.660] - globals: [1] ‘data’
[17:42:36.131]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.660] 
[17:42:36.131]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.661] getGlobalsAndPackages() ... DONE
[17:42:36.131]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.661] run() for ‘Future’ ...
[17:42:36.131]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.661] - state: ‘created’
[17:42:36.131]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.661] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:36.132]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.665] [local output] makeClusterPSOCK() ...
[17:42:36.132]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.665] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:42:36.132]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.666] [local output] Base port: 11470
[17:42:36.132]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.666] [local output] Getting setup options for 2 cluster nodes ...
[17:42:36.132]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.666] [local output]  - Node 1 of 2 ...
[17:42:36.132]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.666] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:36.132]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.667] [local output] Rscript port: 11470

[17:42:36.132]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.667] [local output]  - Node 2 of 2 ...
[17:42:36.133]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.668] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:36.133]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.668] [local output] Rscript port: 11470

[17:42:36.133]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.668] [local output] Getting setup options for 2 cluster nodes ... done
[17:42:36.133]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.669] [local output]  - Parallel setup requested for some PSOCK nodes
[17:42:36.133]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.669] [local output] Setting up PSOCK nodes in parallel
[17:42:36.133]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.669] List of 36
[17:42:35.669]  $ worker          : chr "localhost"
[17:42:35.669]   ..- attr(*, "localhost")= logi TRUE
[17:42:35.669]  $ master          : chr "localhost"
[17:42:35.669]  $ port            : int 11470
[17:42:35.669]  $ connectTimeout  : num 120
[17:42:35.669]  $ timeout         : num 2592000
[17:42:35.669]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:42:35.669]  $ homogeneous     : logi TRUE
[17:42:35.669]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:42:35.669]  $ rscript_envs    : NULL
[17:42:35.669]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:35.669]  $ rscript_startup : NULL
[17:42:35.669]  $ rscript_sh      : chr "sh"
[17:42:35.669]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:35.669]  $ methods         : logi TRUE
[17:42:35.669]  $ socketOptions   : chr "no-delay"
[17:42:35.669]  $ useXDR          : logi FALSE
[17:42:35.669]  $ outfile         : chr "/dev/null"
[17:42:35.669]  $ renice          : int NA
[17:42:35.669]  $ rshcmd          : NULL
[17:42:35.669]  $ user            : chr(0) 
[17:42:35.669]  $ revtunnel       : logi FALSE
[17:42:35.669]  $ rshlogfile      : NULL
[17:42:35.669]  $ rshopts         : chr(0) 
[17:42:35.669]  $ rank            : int 1
[17:42:35.669]  $ manual          : logi FALSE
[17:42:35.669]  $ dryrun          : logi FALSE
[17:42:35.669]  $ quiet           : logi FALSE
[17:42:35.669]  $ setup_strategy  : chr "parallel"
[17:42:35.669]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:35.669]  $ pidfile         : chr "/tmp/RtmpND951N/worker.rank=1.parallelly.parent=46443.b56b143ddb2a.pid"
[17:42:35.669]  $ rshcmd_label    : NULL
[17:42:35.669]  $ rsh_call        : NULL
[17:42:35.669]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:35.669]  $ localMachine    : logi TRUE
[17:42:35.669]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:42:35.669]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:42:35.669]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:42:35.669]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:42:35.669]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:42:35.669]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:42:35.669]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:42:35.669]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:42:35.669]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:42:35.669]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:42:35.669]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:42:35.669]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:42:35.669]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:42:35.669]  $ arguments       :List of 28
[17:42:35.669]   ..$ worker          : chr "localhost"
[17:42:35.669]   ..$ master          : NULL
[17:42:35.669]   ..$ port            : int 11470
[17:42:35.669]   ..$ connectTimeout  : num 120
[17:42:35.669]   ..$ timeout         : num 2592000
[17:42:35.669]   ..$ rscript         : NULL
[17:42:35.669]   ..$ homogeneous     : NULL
[17:42:35.669]   ..$ rscript_args    : NULL
[17:42:35.669]   ..$ rscript_envs    : NULL
[17:42:35.669]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:35.669]   ..$ rscript_startup : NULL
[17:42:35.669]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:42:35.669]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:35.669]   ..$ methods         : logi TRUE
[17:42:35.669]   ..$ socketOptions   : chr "no-delay"
[17:42:35.669]   ..$ useXDR          : logi FALSE
[17:42:35.669]   ..$ outfile         : chr "/dev/null"
[17:42:35.669]   ..$ renice          : int NA
[17:42:35.669]   ..$ rshcmd          : NULL
[17:42:35.669]   ..$ user            : NULL
[17:42:35.669]   ..$ revtunnel       : logi NA
[17:42:35.669]   ..$ rshlogfile      : NULL
[17:42:35.669]   ..$ rshopts         : NULL
[17:42:35.669]   ..$ rank            : int 1
[17:42:35.669]   ..$ manual          : logi FALSE
[17:42:35.669]   ..$ dryrun          : logi FALSE
[17:42:35.669]   ..$ quiet           : logi FALSE
[17:42:35.669]   ..$ setup_strategy  : chr "parallel"
[17:42:35.669]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:42:36.133]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.686] [local output] System call to launch all workers:
[17:42:36.134]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.686] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpND951N/worker.rank=1.parallelly.parent=46443.b56b143ddb2a.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11470 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:42:36.134]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.686] [local output] Starting PSOCK main server
[17:42:36.134]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.687] [local output] Workers launched
[17:42:36.134]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.688] [local output] Waiting for workers to connect back
[17:42:36.134]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.688]  - [local output] 0 workers out of 2 ready
[17:42:36.134]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.958]  - [local output] 0 workers out of 2 ready
[17:42:36.134]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.959]  - [local output] 1 workers out of 2 ready
[17:42:36.134]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.959]  - [local output] 2 workers out of 2 ready
[17:42:36.135]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.959] [local output] Launching of workers completed
[17:42:36.135]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.960] [local output] Collecting session information from workers
[17:42:36.135]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.960] [local output]  - Worker #1 of 2
[17:42:36.135]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.961] [local output]  - Worker #2 of 2
[17:42:36.135]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.961] [local output] makeClusterPSOCK() ... done
[17:42:36.135]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.972] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:36.135]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:36.136]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.973]   - Field: ‘node’
[17:42:36.136]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.973]   - Field: ‘label’
[17:42:36.136]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.973]   - Field: ‘local’
[17:42:36.136]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.973]   - Field: ‘owner’
[17:42:36.136]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.973]   - Field: ‘envir’
[17:42:36.136]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.973]   - Field: ‘workers’
[17:42:36.136]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.973]   - Field: ‘packages’
[17:42:36.136]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.973]   - Field: ‘gc’
[17:42:36.137]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.974]   - Field: ‘conditions’
[17:42:36.137]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.974]   - Field: ‘persistent’
[17:42:36.137]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.974]   - Field: ‘expr’
[17:42:36.137]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.974]   - Field: ‘uuid’
[17:42:36.137]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.974]   - Field: ‘seed’
[17:42:36.137]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.974]   - Field: ‘version’
[17:42:36.137]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.974]   - Field: ‘result’
[17:42:36.138]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.974]   - Field: ‘asynchronous’
[17:42:36.138]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.975]   - Field: ‘calls’
[17:42:36.138]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.975]   - Field: ‘globals’
[17:42:36.138]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.975]   - Field: ‘stdout’
[17:42:36.138]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.975]   - Field: ‘earlySignal’
[17:42:36.138]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.975]   - Field: ‘lazy’
[17:42:36.138]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.975]   - Field: ‘state’
[17:42:36.138]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.975] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:36.139]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.975] - Launch lazy future ...
[17:42:36.139]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.976] Packages needed by the future expression (n = 0): <none>
[17:42:36.139]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.976] Packages needed by future strategies (n = 0): <none>
[17:42:36.139]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:35.976] {
[17:42:35.976]     {
[17:42:35.976]         {
[17:42:35.976]             ...future.startTime <- base::Sys.time()
[17:42:35.976]             {
[17:42:35.976]                 {
[17:42:35.976]                   {
[17:42:35.976]                     {
[17:42:35.976]                       base::local({
[17:42:35.976]                         has_future <- base::requireNamespace("future", 
[17:42:35.976]                           quietly = TRUE)
[17:42:35.976]                         if (has_future) {
[17:42:35.976]                           ns <- base::getNamespace("future")
[17:42:35.976]                           version <- ns[[".package"]][["version"]]
[17:42:35.976]                           if (is.null(version)) 
[17:42:35.976]                             version <- utils::packageVersion("future")
[17:42:35.976]                         }
[17:42:35.976]                         else {
[17:42:35.976]                           version <- NULL
[17:42:35.976]                         }
[17:42:35.976]                         if (!has_future || version < "1.8.0") {
[17:42:35.976]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:35.976]                             "", base::R.version$version.string), 
[17:42:35.976]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:35.976]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:35.976]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:35.976]                               "release", "version")], collapse = " "), 
[17:42:35.976]                             hostname = base::Sys.info()[["nodename"]])
[17:42:35.976]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:35.976]                             info)
[17:42:35.976]                           info <- base::paste(info, collapse = "; ")
[17:42:35.976]                           if (!has_future) {
[17:42:35.976]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:35.976]                               info)
[17:42:35.976]                           }
[17:42:35.976]                           else {
[17:42:35.976]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:35.976]                               info, version)
[17:42:35.976]                           }
[17:42:35.976]                           base::stop(msg)
[17:42:35.976]                         }
[17:42:35.976]                       })
[17:42:35.976]                     }
[17:42:35.976]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:35.976]                     base::options(mc.cores = 1L)
[17:42:35.976]                   }
[17:42:35.976]                   options(future.plan = NULL)
[17:42:35.976]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.976]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:35.976]                 }
[17:42:35.976]                 ...future.workdir <- getwd()
[17:42:35.976]             }
[17:42:35.976]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:35.976]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:35.976]         }
[17:42:35.976]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[17:42:35.976]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:35.976]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[17:42:35.976]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:35.976]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:35.976]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:35.976]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:35.976]             base::names(...future.oldOptions))
[17:42:35.976]     }
[17:42:35.976]     if (FALSE) {
[17:42:35.976]     }
[17:42:35.976]     else {
[17:42:35.976]         if (TRUE) {
[17:42:35.976]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:35.976]                 open = "w")
[17:42:35.976]         }
[17:42:35.976]         else {
[17:42:35.976]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:35.976]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:35.976]         }
[17:42:35.976]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:35.976]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:35.976]             base::sink(type = "output", split = FALSE)
[17:42:35.976]             base::close(...future.stdout)
[17:42:35.976]         }, add = TRUE)
[17:42:35.976]     }
[17:42:35.976]     ...future.frame <- base::sys.nframe()
[17:42:35.976]     ...future.conditions <- base::list()
[17:42:35.976]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:35.976]     if (FALSE) {
[17:42:35.976]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:35.976]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:35.976]     }
[17:42:35.976]     ...future.result <- base::tryCatch({
[17:42:35.976]         base::withCallingHandlers({
[17:42:35.976]             ...future.value <- base::withVisible(base::local({
[17:42:35.976]                 ...future.makeSendCondition <- local({
[17:42:35.976]                   sendCondition <- NULL
[17:42:35.976]                   function(frame = 1L) {
[17:42:35.976]                     if (is.function(sendCondition)) 
[17:42:35.976]                       return(sendCondition)
[17:42:35.976]                     ns <- getNamespace("parallel")
[17:42:35.976]                     if (exists("sendData", mode = "function", 
[17:42:35.976]                       envir = ns)) {
[17:42:35.976]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:35.976]                         envir = ns)
[17:42:35.976]                       envir <- sys.frame(frame)
[17:42:35.976]                       master <- NULL
[17:42:35.976]                       while (!identical(envir, .GlobalEnv) && 
[17:42:35.976]                         !identical(envir, emptyenv())) {
[17:42:35.976]                         if (exists("master", mode = "list", envir = envir, 
[17:42:35.976]                           inherits = FALSE)) {
[17:42:35.976]                           master <- get("master", mode = "list", 
[17:42:35.976]                             envir = envir, inherits = FALSE)
[17:42:35.976]                           if (inherits(master, c("SOCKnode", 
[17:42:35.976]                             "SOCK0node"))) {
[17:42:35.976]                             sendCondition <<- function(cond) {
[17:42:35.976]                               data <- list(type = "VALUE", value = cond, 
[17:42:35.976]                                 success = TRUE)
[17:42:35.976]                               parallel_sendData(master, data)
[17:42:35.976]                             }
[17:42:35.976]                             return(sendCondition)
[17:42:35.976]                           }
[17:42:35.976]                         }
[17:42:35.976]                         frame <- frame + 1L
[17:42:35.976]                         envir <- sys.frame(frame)
[17:42:35.976]                       }
[17:42:35.976]                     }
[17:42:35.976]                     sendCondition <<- function(cond) NULL
[17:42:35.976]                   }
[17:42:35.976]                 })
[17:42:35.976]                 withCallingHandlers({
[17:42:35.976]                   subset(data, x < 3)$y
[17:42:35.976]                 }, immediateCondition = function(cond) {
[17:42:35.976]                   sendCondition <- ...future.makeSendCondition()
[17:42:35.976]                   sendCondition(cond)
[17:42:35.976]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.976]                   {
[17:42:35.976]                     inherits <- base::inherits
[17:42:35.976]                     invokeRestart <- base::invokeRestart
[17:42:35.976]                     is.null <- base::is.null
[17:42:35.976]                     muffled <- FALSE
[17:42:35.976]                     if (inherits(cond, "message")) {
[17:42:35.976]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:35.976]                       if (muffled) 
[17:42:35.976]                         invokeRestart("muffleMessage")
[17:42:35.976]                     }
[17:42:35.976]                     else if (inherits(cond, "warning")) {
[17:42:35.976]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:35.976]                       if (muffled) 
[17:42:35.976]                         invokeRestart("muffleWarning")
[17:42:35.976]                     }
[17:42:35.976]                     else if (inherits(cond, "condition")) {
[17:42:35.976]                       if (!is.null(pattern)) {
[17:42:35.976]                         computeRestarts <- base::computeRestarts
[17:42:35.976]                         grepl <- base::grepl
[17:42:35.976]                         restarts <- computeRestarts(cond)
[17:42:35.976]                         for (restart in restarts) {
[17:42:35.976]                           name <- restart$name
[17:42:35.976]                           if (is.null(name)) 
[17:42:35.976]                             next
[17:42:35.976]                           if (!grepl(pattern, name)) 
[17:42:35.976]                             next
[17:42:35.976]                           invokeRestart(restart)
[17:42:35.976]                           muffled <- TRUE
[17:42:35.976]                           break
[17:42:35.976]                         }
[17:42:35.976]                       }
[17:42:35.976]                     }
[17:42:35.976]                     invisible(muffled)
[17:42:35.976]                   }
[17:42:35.976]                   muffleCondition(cond)
[17:42:35.976]                 })
[17:42:35.976]             }))
[17:42:35.976]             future::FutureResult(value = ...future.value$value, 
[17:42:35.976]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.976]                   ...future.rng), globalenv = if (FALSE) 
[17:42:35.976]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:35.976]                     ...future.globalenv.names))
[17:42:35.976]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:35.976]         }, condition = base::local({
[17:42:35.976]             c <- base::c
[17:42:35.976]             inherits <- base::inherits
[17:42:35.976]             invokeRestart <- base::invokeRestart
[17:42:35.976]             length <- base::length
[17:42:35.976]             list <- base::list
[17:42:35.976]             seq.int <- base::seq.int
[17:42:35.976]             signalCondition <- base::signalCondition
[17:42:35.976]             sys.calls <- base::sys.calls
[17:42:35.976]             `[[` <- base::`[[`
[17:42:35.976]             `+` <- base::`+`
[17:42:35.976]             `<<-` <- base::`<<-`
[17:42:35.976]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:35.976]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:35.976]                   3L)]
[17:42:35.976]             }
[17:42:35.976]             function(cond) {
[17:42:35.976]                 is_error <- inherits(cond, "error")
[17:42:35.976]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:35.976]                   NULL)
[17:42:35.976]                 if (is_error) {
[17:42:35.976]                   sessionInformation <- function() {
[17:42:35.976]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:35.976]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:35.976]                       search = base::search(), system = base::Sys.info())
[17:42:35.976]                   }
[17:42:35.976]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.976]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:35.976]                     cond$call), session = sessionInformation(), 
[17:42:35.976]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:35.976]                   signalCondition(cond)
[17:42:35.976]                 }
[17:42:35.976]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:35.976]                 "immediateCondition"))) {
[17:42:35.976]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:35.976]                   ...future.conditions[[length(...future.conditions) + 
[17:42:35.976]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:35.976]                   if (TRUE && !signal) {
[17:42:35.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.976]                     {
[17:42:35.976]                       inherits <- base::inherits
[17:42:35.976]                       invokeRestart <- base::invokeRestart
[17:42:35.976]                       is.null <- base::is.null
[17:42:35.976]                       muffled <- FALSE
[17:42:35.976]                       if (inherits(cond, "message")) {
[17:42:35.976]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.976]                         if (muffled) 
[17:42:35.976]                           invokeRestart("muffleMessage")
[17:42:35.976]                       }
[17:42:35.976]                       else if (inherits(cond, "warning")) {
[17:42:35.976]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.976]                         if (muffled) 
[17:42:35.976]                           invokeRestart("muffleWarning")
[17:42:35.976]                       }
[17:42:35.976]                       else if (inherits(cond, "condition")) {
[17:42:35.976]                         if (!is.null(pattern)) {
[17:42:35.976]                           computeRestarts <- base::computeRestarts
[17:42:35.976]                           grepl <- base::grepl
[17:42:35.976]                           restarts <- computeRestarts(cond)
[17:42:35.976]                           for (restart in restarts) {
[17:42:35.976]                             name <- restart$name
[17:42:35.976]                             if (is.null(name)) 
[17:42:35.976]                               next
[17:42:35.976]                             if (!grepl(pattern, name)) 
[17:42:35.976]                               next
[17:42:35.976]                             invokeRestart(restart)
[17:42:35.976]                             muffled <- TRUE
[17:42:35.976]                             break
[17:42:35.976]                           }
[17:42:35.976]                         }
[17:42:35.976]                       }
[17:42:35.976]                       invisible(muffled)
[17:42:35.976]                     }
[17:42:35.976]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.976]                   }
[17:42:35.976]                 }
[17:42:35.976]                 else {
[17:42:35.976]                   if (TRUE) {
[17:42:35.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:35.976]                     {
[17:42:35.976]                       inherits <- base::inherits
[17:42:35.976]                       invokeRestart <- base::invokeRestart
[17:42:35.976]                       is.null <- base::is.null
[17:42:35.976]                       muffled <- FALSE
[17:42:35.976]                       if (inherits(cond, "message")) {
[17:42:35.976]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:35.976]                         if (muffled) 
[17:42:35.976]                           invokeRestart("muffleMessage")
[17:42:35.976]                       }
[17:42:35.976]                       else if (inherits(cond, "warning")) {
[17:42:35.976]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:35.976]                         if (muffled) 
[17:42:35.976]                           invokeRestart("muffleWarning")
[17:42:35.976]                       }
[17:42:35.976]                       else if (inherits(cond, "condition")) {
[17:42:35.976]                         if (!is.null(pattern)) {
[17:42:35.976]                           computeRestarts <- base::computeRestarts
[17:42:35.976]                           grepl <- base::grepl
[17:42:35.976]                           restarts <- computeRestarts(cond)
[17:42:35.976]                           for (restart in restarts) {
[17:42:35.976]                             name <- restart$name
[17:42:35.976]                             if (is.null(name)) 
[17:42:35.976]                               next
[17:42:35.976]                             if (!grepl(pattern, name)) 
[17:42:35.976]                               next
[17:42:35.976]                             invokeRestart(restart)
[17:42:35.976]                             muffled <- TRUE
[17:42:35.976]                             break
[17:42:35.976]                           }
[17:42:35.976]                         }
[17:42:35.976]                       }
[17:42:35.976]                       invisible(muffled)
[17:42:35.976]                     }
[17:42:35.976]                     muffleCondition(cond, pattern = "^muffle")
[17:42:35.976]                   }
[17:42:35.976]                 }
[17:42:35.976]             }
[17:42:35.976]         }))
[17:42:35.976]     }, error = function(ex) {
[17:42:35.976]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:35.976]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:35.976]                 ...future.rng), started = ...future.startTime, 
[17:42:35.976]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:35.976]             version = "1.8"), class = "FutureResult")
[17:42:35.976]     }, finally = {
[17:42:35.976]         if (!identical(...future.workdir, getwd())) 
[17:42:35.976]             setwd(...future.workdir)
[17:42:35.976]         {
[17:42:35.976]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:35.976]                 ...future.oldOptions$nwarnings <- NULL
[17:42:35.976]             }
[17:42:35.976]             base::options(...future.oldOptions)
[17:42:35.976]             if (.Platform$OS.type == "windows") {
[17:42:35.976]                 old_names <- names(...future.oldEnvVars)
[17:42:35.976]                 envs <- base::Sys.getenv()
[17:42:35.976]                 names <- names(envs)
[17:42:35.976]                 common <- intersect(names, old_names)
[17:42:35.976]                 added <- setdiff(names, old_names)
[17:42:35.976]                 removed <- setdiff(old_names, names)
[17:42:35.976]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:35.976]                   envs[common]]
[17:42:35.976]                 NAMES <- toupper(changed)
[17:42:35.976]                 args <- list()
[17:42:35.976]                 for (kk in seq_along(NAMES)) {
[17:42:35.976]                   name <- changed[[kk]]
[17:42:35.976]                   NAME <- NAMES[[kk]]
[17:42:35.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.976]                     next
[17:42:35.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.976]                 }
[17:42:35.976]                 NAMES <- toupper(added)
[17:42:35.976]                 for (kk in seq_along(NAMES)) {
[17:42:35.976]                   name <- added[[kk]]
[17:42:35.976]                   NAME <- NAMES[[kk]]
[17:42:35.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.976]                     next
[17:42:35.976]                   args[[name]] <- ""
[17:42:35.976]                 }
[17:42:35.976]                 NAMES <- toupper(removed)
[17:42:35.976]                 for (kk in seq_along(NAMES)) {
[17:42:35.976]                   name <- removed[[kk]]
[17:42:35.976]                   NAME <- NAMES[[kk]]
[17:42:35.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:35.976]                     next
[17:42:35.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:35.976]                 }
[17:42:35.976]                 if (length(args) > 0) 
[17:42:35.976]                   base::do.call(base::Sys.setenv, args = args)
[17:42:35.976]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:35.976]             }
[17:42:35.976]             else {
[17:42:35.976]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:35.976]             }
[17:42:35.976]             {
[17:42:35.976]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:35.976]                   0L) {
[17:42:35.976]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:35.976]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:35.976]                   base::options(opts)
[17:42:35.976]                 }
[17:42:35.976]                 {
[17:42:35.976]                   {
[17:42:35.976]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:35.976]                     NULL
[17:42:35.976]                   }
[17:42:35.976]                   options(future.plan = NULL)
[17:42:35.976]                   if (is.na(NA_character_)) 
[17:42:35.976]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:35.976]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:35.976]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:35.976]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:35.976]                     envir = parent.frame()) 
[17:42:35.976]                   {
[17:42:35.976]                     if (is.function(workers)) 
[17:42:35.976]                       workers <- workers()
[17:42:35.976]                     workers <- structure(as.integer(workers), 
[17:42:35.976]                       class = class(workers))
[17:42:35.976]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:35.976]                       workers >= 1)
[17:42:35.976]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:35.976]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:35.976]                     }
[17:42:35.976]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:35.976]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:35.976]                       envir = envir)
[17:42:35.976]                     if (!future$lazy) 
[17:42:35.976]                       future <- run(future)
[17:42:35.976]                     invisible(future)
[17:42:35.976]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:35.976]                 }
[17:42:35.976]             }
[17:42:35.976]         }
[17:42:35.976]     })
[17:42:35.976]     if (TRUE) {
[17:42:35.976]         base::sink(type = "output", split = FALSE)
[17:42:35.976]         if (TRUE) {
[17:42:35.976]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:35.976]         }
[17:42:35.976]         else {
[17:42:35.976]             ...future.result["stdout"] <- base::list(NULL)
[17:42:35.976]         }
[17:42:35.976]         base::close(...future.stdout)
[17:42:35.976]         ...future.stdout <- NULL
[17:42:35.976]     }
[17:42:35.976]     ...future.result$conditions <- ...future.conditions
[17:42:35.976]     ...future.result$finished <- base::Sys.time()
[17:42:35.976]     ...future.result
[17:42:35.976] }
[17:42:36.139]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.048] Exporting 1 global objects (160 bytes) to cluster node #1 ...
[17:42:36.139]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.049] Exporting ‘data’ (160 bytes) to cluster node #1 ...
[17:42:36.139]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.049] Exporting ‘data’ (160 bytes) to cluster node #1 ... DONE
[17:42:36.140]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.049] Exporting 1 global objects (160 bytes) to cluster node #1 ... DONE
[17:42:36.140]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.052] MultisessionFuture started
[17:42:36.140]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.052] - Launch lazy future ... done
[17:42:36.140]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.052] run() for ‘MultisessionFuture’ ... done
[17:42:36.140]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.052] result() for ClusterFuture ...
[17:42:36.140]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.052] receiveMessageFromWorker() for ClusterFuture ...
[17:42:36.140]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.052] - Validating connection of MultisessionFuture
[17:42:36.141]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.125] - received message: FutureResult
[17:42:36.141]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.125] - Received FutureResult
[17:42:36.141]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.125] - Erased future from FutureRegistry
[17:42:36.141]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.125] result() for ClusterFuture ...
[17:42:36.141]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.125] - result already collected: FutureResult
[17:42:36.141]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.125] result() for ClusterFuture ... done
[17:42:36.141]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.126] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:36.141]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.126] result() for ClusterFuture ... done
[17:42:36.142]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.126] result() for ClusterFuture ...
[17:42:36.142]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.126] - result already collected: FutureResult
[17:42:36.142]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[17:42:36.126] result() for ClusterFuture ... done
[17:42:36.142] signalConditions() ... done
- Strategy: multisession ... DONE
> 
> 
> message("*** Globals w/ non-standard evaluation (NSE) ... DONE")
*** Globals w/ non-standard evaluation (NSE) ... DONE
> 
> source("incl/end.R")
[17:42:36.143] plan(): Setting new future strategy stack:
[17:42:36.143] List of future strategies:
[17:42:36.143] 1. FutureStrategy:
[17:42:36.143]    - args: function (..., envir = parent.frame())
[17:42:36.143]    - tweaked: FALSE
[17:42:36.143]    - call: future::plan(oplan)
[17:42:36.144] plan(): nbrOfWorkers() = 1
> 
