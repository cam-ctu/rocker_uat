
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:21:23.935] plan(): Setting new future strategy stack:
[13:21:23.936] List of future strategies:
[13:21:23.936] 1. sequential:
[13:21:23.936]    - args: function (..., envir = parent.frame())
[13:21:23.936]    - tweaked: FALSE
[13:21:23.936]    - call: future::plan("sequential")
[13:21:23.950] plan(): nbrOfWorkers() = 1
> 
> options(future.debug = FALSE)
> 
> message("*** Relaying of standard output and conditions ...")
*** Relaying of standard output and conditions ...
> 
> strategies <- supportedStrategies()
> 
> for (ss in seq_along(strategies)) {
+   strategy <- strategies[[ss]]
+   message(sprintf("Relaying w/ %s ...", names(strategies)[ss]))
+   plan(strategy)
+ 
+   message("* A single future ...")
+ 
+   for (exclude in list(NULL, "message", "warning")) {
+     if (is.null(exclude)) {
+       msgs_truth <- c("M\n", "W")
+     } else if (exclude == "message") {
+       msgs_truth <- c("W")
+     } else if (exclude == "warning") {
+       msgs_truth <- c("M\n")
+     }
+ 
+     message("- creating future")
+     relay <- recordRelay({
+       f <- future({
+         cat("O\n")
+         message("M")
+         warning("W")
+         1L
+       }, conditions = structure("condition", exclude = exclude))
+     })
+     message("  class: ", paste(sQuote(class(f)), collapse = ", "))
+     stopifnot(length(relay$stdout) == 0L)
+     stopifnot(length(relay$msgs) == 0L)
+     
+     message("- checking if resolved")
+     relay <- recordRelay({
+       r <- resolved(f)
+     })
+     message("  result: ", r)
+     stopifnot(length(relay$stdout) == 0L)
+     stopifnot(length(relay$msgs) == 0L)
+   
+     message("- resolve w/ collecting results")
+     relay <- recordRelay({
+       f <- resolve(f, result = TRUE)
+     })
+     stopifnot(length(relay$stdout) == 0L)
+     stopifnot(length(relay$msgs) == 0L)
+   
+     message("- resolve w/out collecting results")
+     relay <- recordRelay({
+       f <- resolve(f, result = FALSE)
+     })
+     stopifnot(length(relay$stdout) == 0L)
+     stopifnot(length(relay$msgs) == 0L)
+   
+     message("- getting value")
+     relay <- recordRelay({
+       v <- value(f)
+     })
+     message("  value: ", v)
+     stopifnot(identical(relay$stdout, "O\n"))
+     stopifnot(identical(relay$msgs, msgs_truth))
+     
+     message("- getting value again")
+     relay <- recordRelay({
+       v <- value(f)
+     })
+     message("  value: ", v)
+     stopifnot(identical(relay$stdout, "O\n"))
+     stopifnot(identical(relay$msgs, msgs_truth))
+   } ## for (exclude ...)
+ 
+   message("* A single future ... DONE")
+ 
+ 
+   message("* Two futures ... ")
+ 
+   message("- list of two futures")
+   fs <- list()
+   relay <- recordRelay({
+     fs[[1]] <- future({ cat("O1\n"); message("M1"); 1L })
+     fs[[2]] <- future({ cat("O2\n"); message("M2"); 2L })
+   })
+   message("  class: ", paste(sQuote(class(fs[[1]])), collapse = ", "))
+   stopifnot(length(relay$stdout) == 0L)
+   stopifnot(length(relay$msgs) == 0L)
+ 
+   message("- check if resolved")
+   relay <- recordRelay({
+     rs <- resolved(fs)
+   })
+   message("  result: ", paste(rs, collapse = ", "))
+   stopifnot(length(relay$stdout) == 0L)
+   stopifnot(length(relay$msgs) == 0L)
+ 
+   message("- resolve w/ collecting results")
+   relay <- recordRelay({
+     fs <- resolve(fs, result = FALSE)
+   })
+   str(relay)
+   stopifnot(length(relay$stdout) == 0L)
+   stopifnot(length(relay$msgs) == 0L)
+ 
+   message("- resolve w/out collecting results")
+   relay <- recordRelay({
+     fs <- resolve(fs, result = TRUE)
+   })
+   str(relay)
+   stopifnot(length(relay$stdout) == 0L)
+   stopifnot(length(relay$msgs) == 0L)
+ 
+   message("- getting value")
+   relay <- recordRelay({
+     vs <- value(fs)
+   })
+   message("  values: ", paste(vs, collapse = ", "))
+   str(relay)
+   stopifnot(identical(relay$stdout, c("O1\n", "O2\n")))
+   stopifnot(identical(relay$msgs, c("M1\n", "M2\n")))
+   
+   message("- getting value again")
+   relay <- recordRelay({
+     vs <- value(fs)
+   })
+   message("  values: ", paste(vs, collapse = ", "))
+   str(relay)
+   stopifnot(identical(relay$stdout, c("O1\n", "O2\n")))
+   stopifnot(identical(relay$msgs, c("M1\n", "M2\n")))
+ 
+   message("* Two futures ... DONE")
+ 
+ 
+   message("* Two futures - out of order  ... ")
+ 
+   message("- list of two futures")
+   fs <- list()
+   relay <- recordRelay({
+     fs[[1]] <- future({ cat("O1\n"); Sys.sleep(1); message("M1"); 1L })
+     fs[[2]] <- future({ cat("O2\n"); message("M2"); 2L })
+   })
+   message("  class: ", paste(sQuote(class(fs[[1]])), collapse = ", "))
+   stopifnot(length(relay$stdout) == 0L)
+   stopifnot(length(relay$msgs) == 0L)
+ 
+   message("- getting value")
+   relay <- recordRelay({
+     vs <- value(fs)
+   })
+   message("  values: ", paste(vs, collapse = ", "))
+   str(relay)
+   stopifnot(identical(relay$stdout, c("O1\n", "O2\n")))
+   stopifnot(identical(relay$msgs, c("M1\n", "M2\n")))
+   
+   message("- getting value again")
+   relay <- recordRelay({
+     vs <- value(fs)
+   })
+   message("  values: ", paste(vs, collapse = ", "))
+   str(relay)
+   stopifnot(identical(relay$stdout, c("O1\n", "O2\n")))
+   stopifnot(identical(relay$msgs, c("M1\n", "M2\n")))
+ 
+   message("* Two futures - out of order ... DONE")
+ 
+   message("- conditions = structure(\"condition\", drop = TRUE)")
+   f <- future(message("42"), conditions = structure("condition", drop = TRUE))
+   r <- result(f)
+   stopifnot(length(r$conditions) > 0L)
+   v <- value(f)
+   r <- result(f)
+   stopifnot(length(r$conditions) == 0L)
+ 
+   message(sprintf("Relaying w/ %s ... DONE", names(strategies)[ss]))
+ } ## for (ss ...)

* A single future ...
- creating future
  class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
- checking if resolved
  result: TRUE
- resolve w/ collecting results
- resolve w/out collecting results
- getting value
O
M
Warning in eval(quote({ : W
  value: 1
- getting value again
O
M
Warning in eval(quote({ : W
  value: 1
- creating future
  class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
- checking if resolved
  result: TRUE
- resolve w/ collecting results
- resolve w/out collecting results
- getting value
O
Warning in eval(quote({ : W
  value: 1
- getting value again
O
Warning in eval(quote({ : W
  value: 1
- creating future
  class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
- checking if resolved
  result: TRUE
- resolve w/ collecting results
- resolve w/out collecting results
- getting value
O
M
  value: 1
- getting value again
O
M
  value: 1
* A single future ... DONE
* Two futures ... 
- list of two futures
  class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
- check if resolved
  result: TRUE, TRUE
- resolve w/ collecting results
List of 2
 $ stdout: chr(0) 
 $ msgs  : list()
- resolve w/out collecting results
List of 2
 $ stdout: chr(0) 
 $ msgs  : list()
- getting value
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
- getting value again
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
* Two futures ... DONE
* Two futures - out of order  ... 
- list of two futures
  class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
- getting value
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
- getting value again
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
* Two futures - out of order ... DONE
- conditions = structure("condition", drop = TRUE)
42


* A single future ...
- creating future
  class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
- checking if resolved
  result: TRUE
- resolve w/ collecting results
- resolve w/out collecting results
- getting value
O
M
Warning in withCallingHandlers({ : W
  value: 1
- getting value again
O
M
Warning in withCallingHandlers({ : W
  value: 1
- creating future
  class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
- checking if resolved
  result: FALSE
- resolve w/ collecting results
- resolve w/out collecting results
- getting value
O
Warning in withCallingHandlers({ : W
  value: 1
- getting value again
O
Warning in withCallingHandlers({ : W
  value: 1
- creating future
  class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
- checking if resolved
  result: TRUE
- resolve w/ collecting results
- resolve w/out collecting results
- getting value
O
M
  value: 1
- getting value again
O
M
  value: 1
* A single future ... DONE
* Two futures ... 
- list of two futures
  class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
- check if resolved
  result: TRUE, TRUE
- resolve w/ collecting results
List of 2
 $ stdout: chr(0) 
 $ msgs  : list()
- resolve w/out collecting results
List of 2
 $ stdout: chr(0) 
 $ msgs  : list()
- getting value
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
- getting value again
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
* Two futures ... DONE
* Two futures - out of order  ... 
- list of two futures
  class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
- getting value
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
- getting value again
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
* Two futures - out of order ... DONE
- conditions = structure("condition", drop = TRUE)
42


* A single future ...
- creating future
  class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
- checking if resolved
  result: FALSE
- resolve w/ collecting results
- resolve w/out collecting results
- getting value
O
M
Warning in withCallingHandlers({ : W
  value: 1
- getting value again
O
M
Warning in withCallingHandlers({ : W
  value: 1
- creating future
  class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
- checking if resolved
  result: FALSE
- resolve w/ collecting results
- resolve w/out collecting results
- getting value
O
Warning in withCallingHandlers({ : W
  value: 1
- getting value again
O
Warning in withCallingHandlers({ : W
  value: 1
- creating future
  class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
- checking if resolved
  result: FALSE
- resolve w/ collecting results
- resolve w/out collecting results
- getting value
O
M
  value: 1
- getting value again
O
M
  value: 1
* A single future ... DONE
* Two futures ... 
- list of two futures
  class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
- check if resolved
  result: TRUE, FALSE
- resolve w/ collecting results
List of 2
 $ stdout: chr(0) 
 $ msgs  : list()
- resolve w/out collecting results
List of 2
 $ stdout: chr(0) 
 $ msgs  : list()
- getting value
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
- getting value again
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
* Two futures ... DONE
* Two futures - out of order  ... 
- list of two futures
  class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
- getting value
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
- getting value again
O1
M1
O2
M2
  values: 1, 2
List of 2
 $ stdout: chr [1:2] "O1\n" "O2\n"
 $ msgs  : chr [1:2] "M1\n" "M2\n"
* Two futures - out of order ... DONE
- conditions = structure("condition", drop = TRUE)
42

> 
> message("*** Relaying of standard output and conditions ... DONE")
*** Relaying of standard output and conditions ... DONE
> 
> source("incl/end.R")
> 
