
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:19:58.810] plan(): Setting new future strategy stack:
[13:19:58.810] List of future strategies:
[13:19:58.810] 1. sequential:
[13:19:58.810]    - args: function (..., envir = parent.frame())
[13:19:58.810]    - tweaked: FALSE
[13:19:58.810]    - call: future::plan("sequential")
[13:19:58.824] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("*** Global argument '...' ...")
+ 
+   sum_fcns <- list()
+ 
+   sum_fcns$A <- function(x, ...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, ...) }
+     y
+   }
+ 
+ 
+   sum_fcns$B <- function(x, ...) {
+     sumt <- function(x) {
+       message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+       y %<-% { sum(x, ...) }
+       y
+     }
+     sumt(x)
+   }
+ 
+   sum_fcns$C <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y) }
+     y
+   }
+ 
+   sum_fcns$D <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y, ...) }
+     y
+   }
+ 
+   ## Issue/PR #400: Emulate how '...' may be used by the 'rlang' package
+   sum_fcns$E <- function(...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+ 
+     ## Grab '...' into a Globals object
+     globals <- globals::globalsByName("...", envir=environment())
+ 
+     ## Evaluate an expression with '...' in an environment that does not
+     ## have an '...' object - hence the parent.frame().  This will produce
+     ## an error unless we pass 'globals' which contains '...'
+     f <- future({
+       fcn <- function() sum(...)
+       fcn()
+     }, envir = parent.frame(), globals = globals)
+     y <- value(f)
+     y
+   }
+ 
+   ## Issue: https://github.com/HenrikBengtsson/globals/issues/72
+   sum_fcns$F <- function(x, y) {
+     message("Using '...' in a formula")
+ 
+     fcn <- function(x, y) {
+       z = ~ list(...)
+       sum(x, y)
+     }
+     
+     f <- future(fcn(x, y))
+     y <- value(f)
+     y
+   }
+ 
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy, substitute = FALSE)
+ 
+     for (name in names(sum_fcns)) {
+       message(sprintf("** Sum function '%s' with plan('%s') ...", name, strategy))
+       sum_fcn <- sum_fcns[[name]]
+       print(sum_fcn)
+       y <- try(sum_fcn(1:2, 3))
+       print(y)
+       if (name %in% c("D")) {
+         stopifnot(inherits(y, "try-error"))
+       } else {
+         stopifnot(y == 6)
+       }
+     }
+   }
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** Global argument '...' ...
- plan('sequential') ...
[13:19:58.873] plan(): Setting new future strategy stack:
[13:19:58.873] List of future strategies:
[13:19:58.873] 1. sequential:
[13:19:58.873]    - args: function (..., envir = parent.frame())
[13:19:58.873]    - tweaked: FALSE
[13:19:58.873]    - call: plan(strategy, substitute = FALSE)
[13:19:58.885] plan(): nbrOfWorkers() = 1
** Sum function 'A' with plan('sequential') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x56222563c7b8>
Arguments '...' exists: TRUE
[13:19:58.887] getGlobalsAndPackages() ...
[13:19:58.888] Searching for globals...
[13:19:58.896] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[13:19:58.896] Searching for globals ... DONE
[13:19:58.896] Resolving globals: FALSE
[13:19:58.896] Tweak future expression to call with '...' arguments ...
[13:19:58.897] {
[13:19:58.897]     do.call(function(...) {
[13:19:58.897]         sum(x, ...)
[13:19:58.897]     }, args = future.call.arguments)
[13:19:58.897] }
[13:19:58.897] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.898] The total size of the 2 globals is 112 bytes (112 bytes)
[13:19:58.899] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[13:19:58.899] - globals: [2] ‘x’, ‘future.call.arguments’
[13:19:58.899] 
[13:19:58.899] getGlobalsAndPackages() ... DONE
[13:19:58.900] run() for ‘Future’ ...
[13:19:58.900] - state: ‘created’
[13:19:58.900] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:58.901] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:58.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:58.901]   - Field: ‘label’
[13:19:58.901]   - Field: ‘local’
[13:19:58.901]   - Field: ‘owner’
[13:19:58.901]   - Field: ‘envir’
[13:19:58.901]   - Field: ‘packages’
[13:19:58.901]   - Field: ‘gc’
[13:19:58.901]   - Field: ‘conditions’
[13:19:58.901]   - Field: ‘expr’
[13:19:58.902]   - Field: ‘uuid’
[13:19:58.902]   - Field: ‘seed’
[13:19:58.902]   - Field: ‘version’
[13:19:58.902]   - Field: ‘result’
[13:19:58.902]   - Field: ‘asynchronous’
[13:19:58.902]   - Field: ‘calls’
[13:19:58.902]   - Field: ‘globals’
[13:19:58.902]   - Field: ‘stdout’
[13:19:58.902]   - Field: ‘earlySignal’
[13:19:58.902]   - Field: ‘lazy’
[13:19:58.902]   - Field: ‘state’
[13:19:58.902] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:58.903] - Launch lazy future ...
[13:19:58.903] Packages needed by the future expression (n = 0): <none>
[13:19:58.904] Packages needed by future strategies (n = 0): <none>
[13:19:58.904] {
[13:19:58.904]     {
[13:19:58.904]         {
[13:19:58.904]             ...future.startTime <- base::Sys.time()
[13:19:58.904]             {
[13:19:58.904]                 {
[13:19:58.904]                   {
[13:19:58.904]                     base::local({
[13:19:58.904]                       has_future <- base::requireNamespace("future", 
[13:19:58.904]                         quietly = TRUE)
[13:19:58.904]                       if (has_future) {
[13:19:58.904]                         ns <- base::getNamespace("future")
[13:19:58.904]                         version <- ns[[".package"]][["version"]]
[13:19:58.904]                         if (is.null(version)) 
[13:19:58.904]                           version <- utils::packageVersion("future")
[13:19:58.904]                       }
[13:19:58.904]                       else {
[13:19:58.904]                         version <- NULL
[13:19:58.904]                       }
[13:19:58.904]                       if (!has_future || version < "1.8.0") {
[13:19:58.904]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.904]                           "", base::R.version$version.string), 
[13:19:58.904]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:58.904]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.904]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.904]                             "release", "version")], collapse = " "), 
[13:19:58.904]                           hostname = base::Sys.info()[["nodename"]])
[13:19:58.904]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.904]                           info)
[13:19:58.904]                         info <- base::paste(info, collapse = "; ")
[13:19:58.904]                         if (!has_future) {
[13:19:58.904]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.904]                             info)
[13:19:58.904]                         }
[13:19:58.904]                         else {
[13:19:58.904]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.904]                             info, version)
[13:19:58.904]                         }
[13:19:58.904]                         base::stop(msg)
[13:19:58.904]                       }
[13:19:58.904]                     })
[13:19:58.904]                   }
[13:19:58.904]                   options(future.plan = NULL)
[13:19:58.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.904]                 }
[13:19:58.904]                 ...future.workdir <- getwd()
[13:19:58.904]             }
[13:19:58.904]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.904]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.904]         }
[13:19:58.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.904]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:58.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.904]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.904]             base::names(...future.oldOptions))
[13:19:58.904]     }
[13:19:58.904]     if (FALSE) {
[13:19:58.904]     }
[13:19:58.904]     else {
[13:19:58.904]         if (TRUE) {
[13:19:58.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.904]                 open = "w")
[13:19:58.904]         }
[13:19:58.904]         else {
[13:19:58.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.904]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.904]         }
[13:19:58.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.904]             base::sink(type = "output", split = FALSE)
[13:19:58.904]             base::close(...future.stdout)
[13:19:58.904]         }, add = TRUE)
[13:19:58.904]     }
[13:19:58.904]     ...future.frame <- base::sys.nframe()
[13:19:58.904]     ...future.conditions <- base::list()
[13:19:58.904]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.904]     if (FALSE) {
[13:19:58.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.904]     }
[13:19:58.904]     ...future.result <- base::tryCatch({
[13:19:58.904]         base::withCallingHandlers({
[13:19:58.904]             ...future.value <- base::withVisible(base::local({
[13:19:58.904]                 do.call(function(...) {
[13:19:58.904]                   sum(x, ...)
[13:19:58.904]                 }, args = future.call.arguments)
[13:19:58.904]             }))
[13:19:58.904]             future::FutureResult(value = ...future.value$value, 
[13:19:58.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.904]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.904]                     ...future.globalenv.names))
[13:19:58.904]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.904]         }, condition = base::local({
[13:19:58.904]             c <- base::c
[13:19:58.904]             inherits <- base::inherits
[13:19:58.904]             invokeRestart <- base::invokeRestart
[13:19:58.904]             length <- base::length
[13:19:58.904]             list <- base::list
[13:19:58.904]             seq.int <- base::seq.int
[13:19:58.904]             signalCondition <- base::signalCondition
[13:19:58.904]             sys.calls <- base::sys.calls
[13:19:58.904]             `[[` <- base::`[[`
[13:19:58.904]             `+` <- base::`+`
[13:19:58.904]             `<<-` <- base::`<<-`
[13:19:58.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.904]                   3L)]
[13:19:58.904]             }
[13:19:58.904]             function(cond) {
[13:19:58.904]                 is_error <- inherits(cond, "error")
[13:19:58.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.904]                   NULL)
[13:19:58.904]                 if (is_error) {
[13:19:58.904]                   sessionInformation <- function() {
[13:19:58.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.904]                       search = base::search(), system = base::Sys.info())
[13:19:58.904]                   }
[13:19:58.904]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.904]                     cond$call), session = sessionInformation(), 
[13:19:58.904]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.904]                   signalCondition(cond)
[13:19:58.904]                 }
[13:19:58.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.904]                 "immediateCondition"))) {
[13:19:58.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.904]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.904]                   if (TRUE && !signal) {
[13:19:58.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.904]                     {
[13:19:58.904]                       inherits <- base::inherits
[13:19:58.904]                       invokeRestart <- base::invokeRestart
[13:19:58.904]                       is.null <- base::is.null
[13:19:58.904]                       muffled <- FALSE
[13:19:58.904]                       if (inherits(cond, "message")) {
[13:19:58.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.904]                         if (muffled) 
[13:19:58.904]                           invokeRestart("muffleMessage")
[13:19:58.904]                       }
[13:19:58.904]                       else if (inherits(cond, "warning")) {
[13:19:58.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.904]                         if (muffled) 
[13:19:58.904]                           invokeRestart("muffleWarning")
[13:19:58.904]                       }
[13:19:58.904]                       else if (inherits(cond, "condition")) {
[13:19:58.904]                         if (!is.null(pattern)) {
[13:19:58.904]                           computeRestarts <- base::computeRestarts
[13:19:58.904]                           grepl <- base::grepl
[13:19:58.904]                           restarts <- computeRestarts(cond)
[13:19:58.904]                           for (restart in restarts) {
[13:19:58.904]                             name <- restart$name
[13:19:58.904]                             if (is.null(name)) 
[13:19:58.904]                               next
[13:19:58.904]                             if (!grepl(pattern, name)) 
[13:19:58.904]                               next
[13:19:58.904]                             invokeRestart(restart)
[13:19:58.904]                             muffled <- TRUE
[13:19:58.904]                             break
[13:19:58.904]                           }
[13:19:58.904]                         }
[13:19:58.904]                       }
[13:19:58.904]                       invisible(muffled)
[13:19:58.904]                     }
[13:19:58.904]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.904]                   }
[13:19:58.904]                 }
[13:19:58.904]                 else {
[13:19:58.904]                   if (TRUE) {
[13:19:58.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.904]                     {
[13:19:58.904]                       inherits <- base::inherits
[13:19:58.904]                       invokeRestart <- base::invokeRestart
[13:19:58.904]                       is.null <- base::is.null
[13:19:58.904]                       muffled <- FALSE
[13:19:58.904]                       if (inherits(cond, "message")) {
[13:19:58.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.904]                         if (muffled) 
[13:19:58.904]                           invokeRestart("muffleMessage")
[13:19:58.904]                       }
[13:19:58.904]                       else if (inherits(cond, "warning")) {
[13:19:58.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.904]                         if (muffled) 
[13:19:58.904]                           invokeRestart("muffleWarning")
[13:19:58.904]                       }
[13:19:58.904]                       else if (inherits(cond, "condition")) {
[13:19:58.904]                         if (!is.null(pattern)) {
[13:19:58.904]                           computeRestarts <- base::computeRestarts
[13:19:58.904]                           grepl <- base::grepl
[13:19:58.904]                           restarts <- computeRestarts(cond)
[13:19:58.904]                           for (restart in restarts) {
[13:19:58.904]                             name <- restart$name
[13:19:58.904]                             if (is.null(name)) 
[13:19:58.904]                               next
[13:19:58.904]                             if (!grepl(pattern, name)) 
[13:19:58.904]                               next
[13:19:58.904]                             invokeRestart(restart)
[13:19:58.904]                             muffled <- TRUE
[13:19:58.904]                             break
[13:19:58.904]                           }
[13:19:58.904]                         }
[13:19:58.904]                       }
[13:19:58.904]                       invisible(muffled)
[13:19:58.904]                     }
[13:19:58.904]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.904]                   }
[13:19:58.904]                 }
[13:19:58.904]             }
[13:19:58.904]         }))
[13:19:58.904]     }, error = function(ex) {
[13:19:58.904]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.904]                 ...future.rng), started = ...future.startTime, 
[13:19:58.904]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.904]             version = "1.8"), class = "FutureResult")
[13:19:58.904]     }, finally = {
[13:19:58.904]         if (!identical(...future.workdir, getwd())) 
[13:19:58.904]             setwd(...future.workdir)
[13:19:58.904]         {
[13:19:58.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.904]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.904]             }
[13:19:58.904]             base::options(...future.oldOptions)
[13:19:58.904]             if (.Platform$OS.type == "windows") {
[13:19:58.904]                 old_names <- names(...future.oldEnvVars)
[13:19:58.904]                 envs <- base::Sys.getenv()
[13:19:58.904]                 names <- names(envs)
[13:19:58.904]                 common <- intersect(names, old_names)
[13:19:58.904]                 added <- setdiff(names, old_names)
[13:19:58.904]                 removed <- setdiff(old_names, names)
[13:19:58.904]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.904]                   envs[common]]
[13:19:58.904]                 NAMES <- toupper(changed)
[13:19:58.904]                 args <- list()
[13:19:58.904]                 for (kk in seq_along(NAMES)) {
[13:19:58.904]                   name <- changed[[kk]]
[13:19:58.904]                   NAME <- NAMES[[kk]]
[13:19:58.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.904]                     next
[13:19:58.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.904]                 }
[13:19:58.904]                 NAMES <- toupper(added)
[13:19:58.904]                 for (kk in seq_along(NAMES)) {
[13:19:58.904]                   name <- added[[kk]]
[13:19:58.904]                   NAME <- NAMES[[kk]]
[13:19:58.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.904]                     next
[13:19:58.904]                   args[[name]] <- ""
[13:19:58.904]                 }
[13:19:58.904]                 NAMES <- toupper(removed)
[13:19:58.904]                 for (kk in seq_along(NAMES)) {
[13:19:58.904]                   name <- removed[[kk]]
[13:19:58.904]                   NAME <- NAMES[[kk]]
[13:19:58.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.904]                     next
[13:19:58.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.904]                 }
[13:19:58.904]                 if (length(args) > 0) 
[13:19:58.904]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.904]             }
[13:19:58.904]             else {
[13:19:58.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.904]             }
[13:19:58.904]             {
[13:19:58.904]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.904]                   0L) {
[13:19:58.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.904]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.904]                   base::options(opts)
[13:19:58.904]                 }
[13:19:58.904]                 {
[13:19:58.904]                   {
[13:19:58.904]                     NULL
[13:19:58.904]                     RNGkind("Mersenne-Twister")
[13:19:58.904]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:58.904]                       inherits = FALSE)
[13:19:58.904]                   }
[13:19:58.904]                   options(future.plan = NULL)
[13:19:58.904]                   if (is.na(NA_character_)) 
[13:19:58.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.904]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:58.904]                   {
[13:19:58.904]                     future <- SequentialFuture(..., envir = envir)
[13:19:58.904]                     if (!future$lazy) 
[13:19:58.904]                       future <- run(future)
[13:19:58.904]                     invisible(future)
[13:19:58.904]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.904]                 }
[13:19:58.904]             }
[13:19:58.904]         }
[13:19:58.904]     })
[13:19:58.904]     if (TRUE) {
[13:19:58.904]         base::sink(type = "output", split = FALSE)
[13:19:58.904]         if (TRUE) {
[13:19:58.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.904]         }
[13:19:58.904]         else {
[13:19:58.904]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.904]         }
[13:19:58.904]         base::close(...future.stdout)
[13:19:58.904]         ...future.stdout <- NULL
[13:19:58.904]     }
[13:19:58.904]     ...future.result$conditions <- ...future.conditions
[13:19:58.904]     ...future.result$finished <- base::Sys.time()
[13:19:58.904]     ...future.result
[13:19:58.904] }
[13:19:58.906] assign_globals() ...
[13:19:58.906] List of 2
[13:19:58.906]  $ x                    : int [1:2] 1 2
[13:19:58.906]  $ future.call.arguments:List of 1
[13:19:58.906]   ..$ : num 3
[13:19:58.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.906]  - attr(*, "where")=List of 2
[13:19:58.906]   ..$ x                    :<environment: R_EmptyEnv> 
[13:19:58.906]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[13:19:58.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.906]  - attr(*, "resolved")= logi FALSE
[13:19:58.906]  - attr(*, "total_size")= num 112
[13:19:58.906]  - attr(*, "already-done")= logi TRUE
[13:19:58.912] - copied ‘x’ to environment
[13:19:58.912] - copied ‘future.call.arguments’ to environment
[13:19:58.912] assign_globals() ... done
[13:19:58.913] plan(): Setting new future strategy stack:
[13:19:58.913] List of future strategies:
[13:19:58.913] 1. sequential:
[13:19:58.913]    - args: function (..., envir = parent.frame())
[13:19:58.913]    - tweaked: FALSE
[13:19:58.913]    - call: NULL
[13:19:58.913] plan(): nbrOfWorkers() = 1
[13:19:58.914] plan(): Setting new future strategy stack:
[13:19:58.914] List of future strategies:
[13:19:58.914] 1. sequential:
[13:19:58.914]    - args: function (..., envir = parent.frame())
[13:19:58.914]    - tweaked: FALSE
[13:19:58.914]    - call: plan(strategy, substitute = FALSE)
[13:19:58.915] plan(): nbrOfWorkers() = 1
[13:19:58.915] SequentialFuture started (and completed)
[13:19:58.915] - Launch lazy future ... done
[13:19:58.916] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'B' with plan('sequential') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x56222593d7d0>
Arguments '...' exists: TRUE
[13:19:58.917] getGlobalsAndPackages() ...
[13:19:58.917] Searching for globals...
[13:19:58.918] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[13:19:58.918] Searching for globals ... DONE
[13:19:58.918] Resolving globals: FALSE
[13:19:58.921] Tweak future expression to call with '...' arguments ...
[13:19:58.921] {
[13:19:58.921]     do.call(function(...) {
[13:19:58.921]         sum(x, ...)
[13:19:58.921]     }, args = future.call.arguments)
[13:19:58.921] }
[13:19:58.921] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.922] The total size of the 2 globals is 112 bytes (112 bytes)
[13:19:58.922] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[13:19:58.922] - globals: [2] ‘x’, ‘future.call.arguments’
[13:19:58.923] 
[13:19:58.923] getGlobalsAndPackages() ... DONE
[13:19:58.923] run() for ‘Future’ ...
[13:19:58.923] - state: ‘created’
[13:19:58.923] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:58.923] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:58.924] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:58.924]   - Field: ‘label’
[13:19:58.924]   - Field: ‘local’
[13:19:58.924]   - Field: ‘owner’
[13:19:58.924]   - Field: ‘envir’
[13:19:58.924]   - Field: ‘packages’
[13:19:58.924]   - Field: ‘gc’
[13:19:58.924]   - Field: ‘conditions’
[13:19:58.924]   - Field: ‘expr’
[13:19:58.924]   - Field: ‘uuid’
[13:19:58.925]   - Field: ‘seed’
[13:19:58.925]   - Field: ‘version’
[13:19:58.925]   - Field: ‘result’
[13:19:58.925]   - Field: ‘asynchronous’
[13:19:58.925]   - Field: ‘calls’
[13:19:58.925]   - Field: ‘globals’
[13:19:58.925]   - Field: ‘stdout’
[13:19:58.925]   - Field: ‘earlySignal’
[13:19:58.925]   - Field: ‘lazy’
[13:19:58.925]   - Field: ‘state’
[13:19:58.925] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:58.926] - Launch lazy future ...
[13:19:58.926] Packages needed by the future expression (n = 0): <none>
[13:19:58.926] Packages needed by future strategies (n = 0): <none>
[13:19:58.926] {
[13:19:58.926]     {
[13:19:58.926]         {
[13:19:58.926]             ...future.startTime <- base::Sys.time()
[13:19:58.926]             {
[13:19:58.926]                 {
[13:19:58.926]                   {
[13:19:58.926]                     base::local({
[13:19:58.926]                       has_future <- base::requireNamespace("future", 
[13:19:58.926]                         quietly = TRUE)
[13:19:58.926]                       if (has_future) {
[13:19:58.926]                         ns <- base::getNamespace("future")
[13:19:58.926]                         version <- ns[[".package"]][["version"]]
[13:19:58.926]                         if (is.null(version)) 
[13:19:58.926]                           version <- utils::packageVersion("future")
[13:19:58.926]                       }
[13:19:58.926]                       else {
[13:19:58.926]                         version <- NULL
[13:19:58.926]                       }
[13:19:58.926]                       if (!has_future || version < "1.8.0") {
[13:19:58.926]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.926]                           "", base::R.version$version.string), 
[13:19:58.926]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:58.926]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.926]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.926]                             "release", "version")], collapse = " "), 
[13:19:58.926]                           hostname = base::Sys.info()[["nodename"]])
[13:19:58.926]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.926]                           info)
[13:19:58.926]                         info <- base::paste(info, collapse = "; ")
[13:19:58.926]                         if (!has_future) {
[13:19:58.926]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.926]                             info)
[13:19:58.926]                         }
[13:19:58.926]                         else {
[13:19:58.926]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.926]                             info, version)
[13:19:58.926]                         }
[13:19:58.926]                         base::stop(msg)
[13:19:58.926]                       }
[13:19:58.926]                     })
[13:19:58.926]                   }
[13:19:58.926]                   options(future.plan = NULL)
[13:19:58.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.926]                 }
[13:19:58.926]                 ...future.workdir <- getwd()
[13:19:58.926]             }
[13:19:58.926]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.926]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.926]         }
[13:19:58.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.926]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:58.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.926]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.926]             base::names(...future.oldOptions))
[13:19:58.926]     }
[13:19:58.926]     if (FALSE) {
[13:19:58.926]     }
[13:19:58.926]     else {
[13:19:58.926]         if (TRUE) {
[13:19:58.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.926]                 open = "w")
[13:19:58.926]         }
[13:19:58.926]         else {
[13:19:58.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.926]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.926]         }
[13:19:58.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.926]             base::sink(type = "output", split = FALSE)
[13:19:58.926]             base::close(...future.stdout)
[13:19:58.926]         }, add = TRUE)
[13:19:58.926]     }
[13:19:58.926]     ...future.frame <- base::sys.nframe()
[13:19:58.926]     ...future.conditions <- base::list()
[13:19:58.926]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.926]     if (FALSE) {
[13:19:58.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.926]     }
[13:19:58.926]     ...future.result <- base::tryCatch({
[13:19:58.926]         base::withCallingHandlers({
[13:19:58.926]             ...future.value <- base::withVisible(base::local({
[13:19:58.926]                 do.call(function(...) {
[13:19:58.926]                   sum(x, ...)
[13:19:58.926]                 }, args = future.call.arguments)
[13:19:58.926]             }))
[13:19:58.926]             future::FutureResult(value = ...future.value$value, 
[13:19:58.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.926]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.926]                     ...future.globalenv.names))
[13:19:58.926]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.926]         }, condition = base::local({
[13:19:58.926]             c <- base::c
[13:19:58.926]             inherits <- base::inherits
[13:19:58.926]             invokeRestart <- base::invokeRestart
[13:19:58.926]             length <- base::length
[13:19:58.926]             list <- base::list
[13:19:58.926]             seq.int <- base::seq.int
[13:19:58.926]             signalCondition <- base::signalCondition
[13:19:58.926]             sys.calls <- base::sys.calls
[13:19:58.926]             `[[` <- base::`[[`
[13:19:58.926]             `+` <- base::`+`
[13:19:58.926]             `<<-` <- base::`<<-`
[13:19:58.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.926]                   3L)]
[13:19:58.926]             }
[13:19:58.926]             function(cond) {
[13:19:58.926]                 is_error <- inherits(cond, "error")
[13:19:58.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.926]                   NULL)
[13:19:58.926]                 if (is_error) {
[13:19:58.926]                   sessionInformation <- function() {
[13:19:58.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.926]                       search = base::search(), system = base::Sys.info())
[13:19:58.926]                   }
[13:19:58.926]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.926]                     cond$call), session = sessionInformation(), 
[13:19:58.926]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.926]                   signalCondition(cond)
[13:19:58.926]                 }
[13:19:58.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.926]                 "immediateCondition"))) {
[13:19:58.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.926]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.926]                   if (TRUE && !signal) {
[13:19:58.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.926]                     {
[13:19:58.926]                       inherits <- base::inherits
[13:19:58.926]                       invokeRestart <- base::invokeRestart
[13:19:58.926]                       is.null <- base::is.null
[13:19:58.926]                       muffled <- FALSE
[13:19:58.926]                       if (inherits(cond, "message")) {
[13:19:58.926]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.926]                         if (muffled) 
[13:19:58.926]                           invokeRestart("muffleMessage")
[13:19:58.926]                       }
[13:19:58.926]                       else if (inherits(cond, "warning")) {
[13:19:58.926]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.926]                         if (muffled) 
[13:19:58.926]                           invokeRestart("muffleWarning")
[13:19:58.926]                       }
[13:19:58.926]                       else if (inherits(cond, "condition")) {
[13:19:58.926]                         if (!is.null(pattern)) {
[13:19:58.926]                           computeRestarts <- base::computeRestarts
[13:19:58.926]                           grepl <- base::grepl
[13:19:58.926]                           restarts <- computeRestarts(cond)
[13:19:58.926]                           for (restart in restarts) {
[13:19:58.926]                             name <- restart$name
[13:19:58.926]                             if (is.null(name)) 
[13:19:58.926]                               next
[13:19:58.926]                             if (!grepl(pattern, name)) 
[13:19:58.926]                               next
[13:19:58.926]                             invokeRestart(restart)
[13:19:58.926]                             muffled <- TRUE
[13:19:58.926]                             break
[13:19:58.926]                           }
[13:19:58.926]                         }
[13:19:58.926]                       }
[13:19:58.926]                       invisible(muffled)
[13:19:58.926]                     }
[13:19:58.926]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.926]                   }
[13:19:58.926]                 }
[13:19:58.926]                 else {
[13:19:58.926]                   if (TRUE) {
[13:19:58.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.926]                     {
[13:19:58.926]                       inherits <- base::inherits
[13:19:58.926]                       invokeRestart <- base::invokeRestart
[13:19:58.926]                       is.null <- base::is.null
[13:19:58.926]                       muffled <- FALSE
[13:19:58.926]                       if (inherits(cond, "message")) {
[13:19:58.926]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.926]                         if (muffled) 
[13:19:58.926]                           invokeRestart("muffleMessage")
[13:19:58.926]                       }
[13:19:58.926]                       else if (inherits(cond, "warning")) {
[13:19:58.926]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.926]                         if (muffled) 
[13:19:58.926]                           invokeRestart("muffleWarning")
[13:19:58.926]                       }
[13:19:58.926]                       else if (inherits(cond, "condition")) {
[13:19:58.926]                         if (!is.null(pattern)) {
[13:19:58.926]                           computeRestarts <- base::computeRestarts
[13:19:58.926]                           grepl <- base::grepl
[13:19:58.926]                           restarts <- computeRestarts(cond)
[13:19:58.926]                           for (restart in restarts) {
[13:19:58.926]                             name <- restart$name
[13:19:58.926]                             if (is.null(name)) 
[13:19:58.926]                               next
[13:19:58.926]                             if (!grepl(pattern, name)) 
[13:19:58.926]                               next
[13:19:58.926]                             invokeRestart(restart)
[13:19:58.926]                             muffled <- TRUE
[13:19:58.926]                             break
[13:19:58.926]                           }
[13:19:58.926]                         }
[13:19:58.926]                       }
[13:19:58.926]                       invisible(muffled)
[13:19:58.926]                     }
[13:19:58.926]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.926]                   }
[13:19:58.926]                 }
[13:19:58.926]             }
[13:19:58.926]         }))
[13:19:58.926]     }, error = function(ex) {
[13:19:58.926]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.926]                 ...future.rng), started = ...future.startTime, 
[13:19:58.926]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.926]             version = "1.8"), class = "FutureResult")
[13:19:58.926]     }, finally = {
[13:19:58.926]         if (!identical(...future.workdir, getwd())) 
[13:19:58.926]             setwd(...future.workdir)
[13:19:58.926]         {
[13:19:58.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.926]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.926]             }
[13:19:58.926]             base::options(...future.oldOptions)
[13:19:58.926]             if (.Platform$OS.type == "windows") {
[13:19:58.926]                 old_names <- names(...future.oldEnvVars)
[13:19:58.926]                 envs <- base::Sys.getenv()
[13:19:58.926]                 names <- names(envs)
[13:19:58.926]                 common <- intersect(names, old_names)
[13:19:58.926]                 added <- setdiff(names, old_names)
[13:19:58.926]                 removed <- setdiff(old_names, names)
[13:19:58.926]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.926]                   envs[common]]
[13:19:58.926]                 NAMES <- toupper(changed)
[13:19:58.926]                 args <- list()
[13:19:58.926]                 for (kk in seq_along(NAMES)) {
[13:19:58.926]                   name <- changed[[kk]]
[13:19:58.926]                   NAME <- NAMES[[kk]]
[13:19:58.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.926]                     next
[13:19:58.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.926]                 }
[13:19:58.926]                 NAMES <- toupper(added)
[13:19:58.926]                 for (kk in seq_along(NAMES)) {
[13:19:58.926]                   name <- added[[kk]]
[13:19:58.926]                   NAME <- NAMES[[kk]]
[13:19:58.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.926]                     next
[13:19:58.926]                   args[[name]] <- ""
[13:19:58.926]                 }
[13:19:58.926]                 NAMES <- toupper(removed)
[13:19:58.926]                 for (kk in seq_along(NAMES)) {
[13:19:58.926]                   name <- removed[[kk]]
[13:19:58.926]                   NAME <- NAMES[[kk]]
[13:19:58.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.926]                     next
[13:19:58.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.926]                 }
[13:19:58.926]                 if (length(args) > 0) 
[13:19:58.926]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.926]             }
[13:19:58.926]             else {
[13:19:58.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.926]             }
[13:19:58.926]             {
[13:19:58.926]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.926]                   0L) {
[13:19:58.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.926]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.926]                   base::options(opts)
[13:19:58.926]                 }
[13:19:58.926]                 {
[13:19:58.926]                   {
[13:19:58.926]                     NULL
[13:19:58.926]                     RNGkind("Mersenne-Twister")
[13:19:58.926]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:58.926]                       inherits = FALSE)
[13:19:58.926]                   }
[13:19:58.926]                   options(future.plan = NULL)
[13:19:58.926]                   if (is.na(NA_character_)) 
[13:19:58.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.926]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:58.926]                   {
[13:19:58.926]                     future <- SequentialFuture(..., envir = envir)
[13:19:58.926]                     if (!future$lazy) 
[13:19:58.926]                       future <- run(future)
[13:19:58.926]                     invisible(future)
[13:19:58.926]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.926]                 }
[13:19:58.926]             }
[13:19:58.926]         }
[13:19:58.926]     })
[13:19:58.926]     if (TRUE) {
[13:19:58.926]         base::sink(type = "output", split = FALSE)
[13:19:58.926]         if (TRUE) {
[13:19:58.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.926]         }
[13:19:58.926]         else {
[13:19:58.926]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.926]         }
[13:19:58.926]         base::close(...future.stdout)
[13:19:58.926]         ...future.stdout <- NULL
[13:19:58.926]     }
[13:19:58.926]     ...future.result$conditions <- ...future.conditions
[13:19:58.926]     ...future.result$finished <- base::Sys.time()
[13:19:58.926]     ...future.result
[13:19:58.926] }
[13:19:58.928] assign_globals() ...
[13:19:58.928] List of 2
[13:19:58.928]  $ x                    : int [1:2] 1 2
[13:19:58.928]  $ future.call.arguments:List of 1
[13:19:58.928]   ..$ : num 3
[13:19:58.928]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.928]  - attr(*, "where")=List of 2
[13:19:58.928]   ..$ x                    :<environment: R_EmptyEnv> 
[13:19:58.928]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[13:19:58.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.928]  - attr(*, "resolved")= logi FALSE
[13:19:58.928]  - attr(*, "total_size")= num 112
[13:19:58.928]  - attr(*, "already-done")= logi TRUE
[13:19:58.932] - copied ‘x’ to environment
[13:19:58.932] - copied ‘future.call.arguments’ to environment
[13:19:58.932] assign_globals() ... done
[13:19:58.932] plan(): Setting new future strategy stack:
[13:19:58.932] List of future strategies:
[13:19:58.932] 1. sequential:
[13:19:58.932]    - args: function (..., envir = parent.frame())
[13:19:58.932]    - tweaked: FALSE
[13:19:58.932]    - call: NULL
[13:19:58.932] plan(): nbrOfWorkers() = 1
[13:19:58.933] plan(): Setting new future strategy stack:
[13:19:58.933] List of future strategies:
[13:19:58.933] 1. sequential:
[13:19:58.933]    - args: function (..., envir = parent.frame())
[13:19:58.933]    - tweaked: FALSE
[13:19:58.933]    - call: plan(strategy, substitute = FALSE)
[13:19:58.934] plan(): nbrOfWorkers() = 1
[13:19:58.934] SequentialFuture started (and completed)
[13:19:58.934] - Launch lazy future ... done
[13:19:58.934] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'C' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x562225ab6848>
Arguments '...' exists: FALSE
[13:19:58.935] getGlobalsAndPackages() ...
[13:19:58.935] Searching for globals...
[13:19:58.936] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[13:19:58.936] Searching for globals ... DONE
[13:19:58.936] Resolving globals: FALSE
[13:19:58.936] The total size of the 2 globals is 112 bytes (112 bytes)
[13:19:58.937] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[13:19:58.937] - globals: [2] ‘x’, ‘y’
[13:19:58.937] 
[13:19:58.937] getGlobalsAndPackages() ... DONE
[13:19:58.937] run() for ‘Future’ ...
[13:19:58.938] - state: ‘created’
[13:19:58.938] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:58.938] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:58.938] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:58.938]   - Field: ‘label’
[13:19:58.938]   - Field: ‘local’
[13:19:58.938]   - Field: ‘owner’
[13:19:58.938]   - Field: ‘envir’
[13:19:58.938]   - Field: ‘packages’
[13:19:58.939]   - Field: ‘gc’
[13:19:58.939]   - Field: ‘conditions’
[13:19:58.939]   - Field: ‘expr’
[13:19:58.939]   - Field: ‘uuid’
[13:19:58.939]   - Field: ‘seed’
[13:19:58.939]   - Field: ‘version’
[13:19:58.939]   - Field: ‘result’
[13:19:58.939]   - Field: ‘asynchronous’
[13:19:58.939]   - Field: ‘calls’
[13:19:58.939]   - Field: ‘globals’
[13:19:58.939]   - Field: ‘stdout’
[13:19:58.940]   - Field: ‘earlySignal’
[13:19:58.940]   - Field: ‘lazy’
[13:19:58.940]   - Field: ‘state’
[13:19:58.940] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:58.940] - Launch lazy future ...
[13:19:58.940] Packages needed by the future expression (n = 0): <none>
[13:19:58.940] Packages needed by future strategies (n = 0): <none>
[13:19:58.941] {
[13:19:58.941]     {
[13:19:58.941]         {
[13:19:58.941]             ...future.startTime <- base::Sys.time()
[13:19:58.941]             {
[13:19:58.941]                 {
[13:19:58.941]                   {
[13:19:58.941]                     base::local({
[13:19:58.941]                       has_future <- base::requireNamespace("future", 
[13:19:58.941]                         quietly = TRUE)
[13:19:58.941]                       if (has_future) {
[13:19:58.941]                         ns <- base::getNamespace("future")
[13:19:58.941]                         version <- ns[[".package"]][["version"]]
[13:19:58.941]                         if (is.null(version)) 
[13:19:58.941]                           version <- utils::packageVersion("future")
[13:19:58.941]                       }
[13:19:58.941]                       else {
[13:19:58.941]                         version <- NULL
[13:19:58.941]                       }
[13:19:58.941]                       if (!has_future || version < "1.8.0") {
[13:19:58.941]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.941]                           "", base::R.version$version.string), 
[13:19:58.941]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:58.941]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.941]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.941]                             "release", "version")], collapse = " "), 
[13:19:58.941]                           hostname = base::Sys.info()[["nodename"]])
[13:19:58.941]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.941]                           info)
[13:19:58.941]                         info <- base::paste(info, collapse = "; ")
[13:19:58.941]                         if (!has_future) {
[13:19:58.941]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.941]                             info)
[13:19:58.941]                         }
[13:19:58.941]                         else {
[13:19:58.941]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.941]                             info, version)
[13:19:58.941]                         }
[13:19:58.941]                         base::stop(msg)
[13:19:58.941]                       }
[13:19:58.941]                     })
[13:19:58.941]                   }
[13:19:58.941]                   options(future.plan = NULL)
[13:19:58.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.941]                 }
[13:19:58.941]                 ...future.workdir <- getwd()
[13:19:58.941]             }
[13:19:58.941]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.941]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.941]         }
[13:19:58.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.941]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:58.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.941]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.941]             base::names(...future.oldOptions))
[13:19:58.941]     }
[13:19:58.941]     if (FALSE) {
[13:19:58.941]     }
[13:19:58.941]     else {
[13:19:58.941]         if (TRUE) {
[13:19:58.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.941]                 open = "w")
[13:19:58.941]         }
[13:19:58.941]         else {
[13:19:58.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.941]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.941]         }
[13:19:58.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.941]             base::sink(type = "output", split = FALSE)
[13:19:58.941]             base::close(...future.stdout)
[13:19:58.941]         }, add = TRUE)
[13:19:58.941]     }
[13:19:58.941]     ...future.frame <- base::sys.nframe()
[13:19:58.941]     ...future.conditions <- base::list()
[13:19:58.941]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.941]     if (FALSE) {
[13:19:58.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.941]     }
[13:19:58.941]     ...future.result <- base::tryCatch({
[13:19:58.941]         base::withCallingHandlers({
[13:19:58.941]             ...future.value <- base::withVisible(base::local({
[13:19:58.941]                 sum(x, y)
[13:19:58.941]             }))
[13:19:58.941]             future::FutureResult(value = ...future.value$value, 
[13:19:58.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.941]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.941]                     ...future.globalenv.names))
[13:19:58.941]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.941]         }, condition = base::local({
[13:19:58.941]             c <- base::c
[13:19:58.941]             inherits <- base::inherits
[13:19:58.941]             invokeRestart <- base::invokeRestart
[13:19:58.941]             length <- base::length
[13:19:58.941]             list <- base::list
[13:19:58.941]             seq.int <- base::seq.int
[13:19:58.941]             signalCondition <- base::signalCondition
[13:19:58.941]             sys.calls <- base::sys.calls
[13:19:58.941]             `[[` <- base::`[[`
[13:19:58.941]             `+` <- base::`+`
[13:19:58.941]             `<<-` <- base::`<<-`
[13:19:58.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.941]                   3L)]
[13:19:58.941]             }
[13:19:58.941]             function(cond) {
[13:19:58.941]                 is_error <- inherits(cond, "error")
[13:19:58.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.941]                   NULL)
[13:19:58.941]                 if (is_error) {
[13:19:58.941]                   sessionInformation <- function() {
[13:19:58.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.941]                       search = base::search(), system = base::Sys.info())
[13:19:58.941]                   }
[13:19:58.941]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.941]                     cond$call), session = sessionInformation(), 
[13:19:58.941]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.941]                   signalCondition(cond)
[13:19:58.941]                 }
[13:19:58.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.941]                 "immediateCondition"))) {
[13:19:58.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.941]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.941]                   if (TRUE && !signal) {
[13:19:58.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.941]                     {
[13:19:58.941]                       inherits <- base::inherits
[13:19:58.941]                       invokeRestart <- base::invokeRestart
[13:19:58.941]                       is.null <- base::is.null
[13:19:58.941]                       muffled <- FALSE
[13:19:58.941]                       if (inherits(cond, "message")) {
[13:19:58.941]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.941]                         if (muffled) 
[13:19:58.941]                           invokeRestart("muffleMessage")
[13:19:58.941]                       }
[13:19:58.941]                       else if (inherits(cond, "warning")) {
[13:19:58.941]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.941]                         if (muffled) 
[13:19:58.941]                           invokeRestart("muffleWarning")
[13:19:58.941]                       }
[13:19:58.941]                       else if (inherits(cond, "condition")) {
[13:19:58.941]                         if (!is.null(pattern)) {
[13:19:58.941]                           computeRestarts <- base::computeRestarts
[13:19:58.941]                           grepl <- base::grepl
[13:19:58.941]                           restarts <- computeRestarts(cond)
[13:19:58.941]                           for (restart in restarts) {
[13:19:58.941]                             name <- restart$name
[13:19:58.941]                             if (is.null(name)) 
[13:19:58.941]                               next
[13:19:58.941]                             if (!grepl(pattern, name)) 
[13:19:58.941]                               next
[13:19:58.941]                             invokeRestart(restart)
[13:19:58.941]                             muffled <- TRUE
[13:19:58.941]                             break
[13:19:58.941]                           }
[13:19:58.941]                         }
[13:19:58.941]                       }
[13:19:58.941]                       invisible(muffled)
[13:19:58.941]                     }
[13:19:58.941]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.941]                   }
[13:19:58.941]                 }
[13:19:58.941]                 else {
[13:19:58.941]                   if (TRUE) {
[13:19:58.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.941]                     {
[13:19:58.941]                       inherits <- base::inherits
[13:19:58.941]                       invokeRestart <- base::invokeRestart
[13:19:58.941]                       is.null <- base::is.null
[13:19:58.941]                       muffled <- FALSE
[13:19:58.941]                       if (inherits(cond, "message")) {
[13:19:58.941]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.941]                         if (muffled) 
[13:19:58.941]                           invokeRestart("muffleMessage")
[13:19:58.941]                       }
[13:19:58.941]                       else if (inherits(cond, "warning")) {
[13:19:58.941]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.941]                         if (muffled) 
[13:19:58.941]                           invokeRestart("muffleWarning")
[13:19:58.941]                       }
[13:19:58.941]                       else if (inherits(cond, "condition")) {
[13:19:58.941]                         if (!is.null(pattern)) {
[13:19:58.941]                           computeRestarts <- base::computeRestarts
[13:19:58.941]                           grepl <- base::grepl
[13:19:58.941]                           restarts <- computeRestarts(cond)
[13:19:58.941]                           for (restart in restarts) {
[13:19:58.941]                             name <- restart$name
[13:19:58.941]                             if (is.null(name)) 
[13:19:58.941]                               next
[13:19:58.941]                             if (!grepl(pattern, name)) 
[13:19:58.941]                               next
[13:19:58.941]                             invokeRestart(restart)
[13:19:58.941]                             muffled <- TRUE
[13:19:58.941]                             break
[13:19:58.941]                           }
[13:19:58.941]                         }
[13:19:58.941]                       }
[13:19:58.941]                       invisible(muffled)
[13:19:58.941]                     }
[13:19:58.941]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.941]                   }
[13:19:58.941]                 }
[13:19:58.941]             }
[13:19:58.941]         }))
[13:19:58.941]     }, error = function(ex) {
[13:19:58.941]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.941]                 ...future.rng), started = ...future.startTime, 
[13:19:58.941]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.941]             version = "1.8"), class = "FutureResult")
[13:19:58.941]     }, finally = {
[13:19:58.941]         if (!identical(...future.workdir, getwd())) 
[13:19:58.941]             setwd(...future.workdir)
[13:19:58.941]         {
[13:19:58.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.941]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.941]             }
[13:19:58.941]             base::options(...future.oldOptions)
[13:19:58.941]             if (.Platform$OS.type == "windows") {
[13:19:58.941]                 old_names <- names(...future.oldEnvVars)
[13:19:58.941]                 envs <- base::Sys.getenv()
[13:19:58.941]                 names <- names(envs)
[13:19:58.941]                 common <- intersect(names, old_names)
[13:19:58.941]                 added <- setdiff(names, old_names)
[13:19:58.941]                 removed <- setdiff(old_names, names)
[13:19:58.941]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.941]                   envs[common]]
[13:19:58.941]                 NAMES <- toupper(changed)
[13:19:58.941]                 args <- list()
[13:19:58.941]                 for (kk in seq_along(NAMES)) {
[13:19:58.941]                   name <- changed[[kk]]
[13:19:58.941]                   NAME <- NAMES[[kk]]
[13:19:58.941]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.941]                     next
[13:19:58.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.941]                 }
[13:19:58.941]                 NAMES <- toupper(added)
[13:19:58.941]                 for (kk in seq_along(NAMES)) {
[13:19:58.941]                   name <- added[[kk]]
[13:19:58.941]                   NAME <- NAMES[[kk]]
[13:19:58.941]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.941]                     next
[13:19:58.941]                   args[[name]] <- ""
[13:19:58.941]                 }
[13:19:58.941]                 NAMES <- toupper(removed)
[13:19:58.941]                 for (kk in seq_along(NAMES)) {
[13:19:58.941]                   name <- removed[[kk]]
[13:19:58.941]                   NAME <- NAMES[[kk]]
[13:19:58.941]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.941]                     next
[13:19:58.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.941]                 }
[13:19:58.941]                 if (length(args) > 0) 
[13:19:58.941]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.941]             }
[13:19:58.941]             else {
[13:19:58.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.941]             }
[13:19:58.941]             {
[13:19:58.941]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.941]                   0L) {
[13:19:58.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.941]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.941]                   base::options(opts)
[13:19:58.941]                 }
[13:19:58.941]                 {
[13:19:58.941]                   {
[13:19:58.941]                     NULL
[13:19:58.941]                     RNGkind("Mersenne-Twister")
[13:19:58.941]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:58.941]                       inherits = FALSE)
[13:19:58.941]                   }
[13:19:58.941]                   options(future.plan = NULL)
[13:19:58.941]                   if (is.na(NA_character_)) 
[13:19:58.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.941]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:58.941]                   {
[13:19:58.941]                     future <- SequentialFuture(..., envir = envir)
[13:19:58.941]                     if (!future$lazy) 
[13:19:58.941]                       future <- run(future)
[13:19:58.941]                     invisible(future)
[13:19:58.941]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.941]                 }
[13:19:58.941]             }
[13:19:58.941]         }
[13:19:58.941]     })
[13:19:58.941]     if (TRUE) {
[13:19:58.941]         base::sink(type = "output", split = FALSE)
[13:19:58.941]         if (TRUE) {
[13:19:58.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.941]         }
[13:19:58.941]         else {
[13:19:58.941]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.941]         }
[13:19:58.941]         base::close(...future.stdout)
[13:19:58.941]         ...future.stdout <- NULL
[13:19:58.941]     }
[13:19:58.941]     ...future.result$conditions <- ...future.conditions
[13:19:58.941]     ...future.result$finished <- base::Sys.time()
[13:19:58.941]     ...future.result
[13:19:58.941] }
[13:19:58.942] assign_globals() ...
[13:19:58.942] List of 2
[13:19:58.942]  $ x: int [1:2] 1 2
[13:19:58.942]  $ y: num 3
[13:19:58.942]  - attr(*, "where")=List of 2
[13:19:58.942]   ..$ x:<environment: R_EmptyEnv> 
[13:19:58.942]   ..$ y:<environment: R_EmptyEnv> 
[13:19:58.942]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.942]  - attr(*, "resolved")= logi FALSE
[13:19:58.942]  - attr(*, "total_size")= num 112
[13:19:58.942]  - attr(*, "already-done")= logi TRUE
[13:19:58.945] - copied ‘x’ to environment
[13:19:58.945] - copied ‘y’ to environment
[13:19:58.945] assign_globals() ... done
[13:19:58.946] plan(): Setting new future strategy stack:
[13:19:58.946] List of future strategies:
[13:19:58.946] 1. sequential:
[13:19:58.946]    - args: function (..., envir = parent.frame())
[13:19:58.946]    - tweaked: FALSE
[13:19:58.946]    - call: NULL
[13:19:58.946] plan(): nbrOfWorkers() = 1
[13:19:58.947] plan(): Setting new future strategy stack:
[13:19:58.947] List of future strategies:
[13:19:58.947] 1. sequential:
[13:19:58.947]    - args: function (..., envir = parent.frame())
[13:19:58.947]    - tweaked: FALSE
[13:19:58.947]    - call: plan(strategy, substitute = FALSE)
[13:19:58.947] plan(): nbrOfWorkers() = 1
[13:19:58.947] SequentialFuture started (and completed)
[13:19:58.948] - Launch lazy future ... done
[13:19:58.948] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'D' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x562223c69dc0>
Arguments '...' exists: FALSE
[13:19:58.948] getGlobalsAndPackages() ...
[13:19:58.948] Searching for globals...
[13:19:58.951] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[13:19:58.951] Searching for globals ... DONE
[13:19:58.951] Resolving globals: FALSE
[13:19:58.951] Tweak future expression to call with '...' arguments ...
[13:19:58.952] The total size of the 2 globals is 112 bytes (112 bytes)
[13:19:58.952] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[13:19:58.953] - globals: [2] ‘x’, ‘y’
[13:19:58.953] 
[13:19:58.953] getGlobalsAndPackages() ... DONE
[13:19:58.953] run() for ‘Future’ ...
[13:19:58.953] - state: ‘created’
[13:19:58.953] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:58.954] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:58.954] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:58.954]   - Field: ‘label’
[13:19:58.954]   - Field: ‘local’
[13:19:58.954]   - Field: ‘owner’
[13:19:58.954]   - Field: ‘envir’
[13:19:58.954]   - Field: ‘packages’
[13:19:58.954]   - Field: ‘gc’
[13:19:58.954]   - Field: ‘conditions’
[13:19:58.954]   - Field: ‘expr’
[13:19:58.954]   - Field: ‘uuid’
[13:19:58.955]   - Field: ‘seed’
[13:19:58.955]   - Field: ‘version’
[13:19:58.955]   - Field: ‘result’
[13:19:58.955]   - Field: ‘asynchronous’
[13:19:58.955]   - Field: ‘calls’
[13:19:58.955]   - Field: ‘globals’
[13:19:58.955]   - Field: ‘stdout’
[13:19:58.955]   - Field: ‘earlySignal’
[13:19:58.955]   - Field: ‘lazy’
[13:19:58.955]   - Field: ‘state’
[13:19:58.955] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:58.956] - Launch lazy future ...
[13:19:58.956] Packages needed by the future expression (n = 0): <none>
[13:19:58.956] Packages needed by future strategies (n = 0): <none>
[13:19:58.956] {
[13:19:58.956]     {
[13:19:58.956]         {
[13:19:58.956]             ...future.startTime <- base::Sys.time()
[13:19:58.956]             {
[13:19:58.956]                 {
[13:19:58.956]                   {
[13:19:58.956]                     base::local({
[13:19:58.956]                       has_future <- base::requireNamespace("future", 
[13:19:58.956]                         quietly = TRUE)
[13:19:58.956]                       if (has_future) {
[13:19:58.956]                         ns <- base::getNamespace("future")
[13:19:58.956]                         version <- ns[[".package"]][["version"]]
[13:19:58.956]                         if (is.null(version)) 
[13:19:58.956]                           version <- utils::packageVersion("future")
[13:19:58.956]                       }
[13:19:58.956]                       else {
[13:19:58.956]                         version <- NULL
[13:19:58.956]                       }
[13:19:58.956]                       if (!has_future || version < "1.8.0") {
[13:19:58.956]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.956]                           "", base::R.version$version.string), 
[13:19:58.956]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:58.956]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.956]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.956]                             "release", "version")], collapse = " "), 
[13:19:58.956]                           hostname = base::Sys.info()[["nodename"]])
[13:19:58.956]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.956]                           info)
[13:19:58.956]                         info <- base::paste(info, collapse = "; ")
[13:19:58.956]                         if (!has_future) {
[13:19:58.956]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.956]                             info)
[13:19:58.956]                         }
[13:19:58.956]                         else {
[13:19:58.956]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.956]                             info, version)
[13:19:58.956]                         }
[13:19:58.956]                         base::stop(msg)
[13:19:58.956]                       }
[13:19:58.956]                     })
[13:19:58.956]                   }
[13:19:58.956]                   options(future.plan = NULL)
[13:19:58.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.956]                 }
[13:19:58.956]                 ...future.workdir <- getwd()
[13:19:58.956]             }
[13:19:58.956]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.956]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.956]         }
[13:19:58.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.956]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:58.956]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.956]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.956]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.956]             base::names(...future.oldOptions))
[13:19:58.956]     }
[13:19:58.956]     if (FALSE) {
[13:19:58.956]     }
[13:19:58.956]     else {
[13:19:58.956]         if (TRUE) {
[13:19:58.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.956]                 open = "w")
[13:19:58.956]         }
[13:19:58.956]         else {
[13:19:58.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.956]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.956]         }
[13:19:58.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.956]             base::sink(type = "output", split = FALSE)
[13:19:58.956]             base::close(...future.stdout)
[13:19:58.956]         }, add = TRUE)
[13:19:58.956]     }
[13:19:58.956]     ...future.frame <- base::sys.nframe()
[13:19:58.956]     ...future.conditions <- base::list()
[13:19:58.956]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.956]     if (FALSE) {
[13:19:58.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.956]     }
[13:19:58.956]     ...future.result <- base::tryCatch({
[13:19:58.956]         base::withCallingHandlers({
[13:19:58.956]             ...future.value <- base::withVisible(base::local({
[13:19:58.956]                 sum(x, y, ...)
[13:19:58.956]             }))
[13:19:58.956]             future::FutureResult(value = ...future.value$value, 
[13:19:58.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.956]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.956]                     ...future.globalenv.names))
[13:19:58.956]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.956]         }, condition = base::local({
[13:19:58.956]             c <- base::c
[13:19:58.956]             inherits <- base::inherits
[13:19:58.956]             invokeRestart <- base::invokeRestart
[13:19:58.956]             length <- base::length
[13:19:58.956]             list <- base::list
[13:19:58.956]             seq.int <- base::seq.int
[13:19:58.956]             signalCondition <- base::signalCondition
[13:19:58.956]             sys.calls <- base::sys.calls
[13:19:58.956]             `[[` <- base::`[[`
[13:19:58.956]             `+` <- base::`+`
[13:19:58.956]             `<<-` <- base::`<<-`
[13:19:58.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.956]                   3L)]
[13:19:58.956]             }
[13:19:58.956]             function(cond) {
[13:19:58.956]                 is_error <- inherits(cond, "error")
[13:19:58.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.956]                   NULL)
[13:19:58.956]                 if (is_error) {
[13:19:58.956]                   sessionInformation <- function() {
[13:19:58.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.956]                       search = base::search(), system = base::Sys.info())
[13:19:58.956]                   }
[13:19:58.956]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.956]                     cond$call), session = sessionInformation(), 
[13:19:58.956]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.956]                   signalCondition(cond)
[13:19:58.956]                 }
[13:19:58.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.956]                 "immediateCondition"))) {
[13:19:58.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.956]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.956]                   if (TRUE && !signal) {
[13:19:58.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.956]                     {
[13:19:58.956]                       inherits <- base::inherits
[13:19:58.956]                       invokeRestart <- base::invokeRestart
[13:19:58.956]                       is.null <- base::is.null
[13:19:58.956]                       muffled <- FALSE
[13:19:58.956]                       if (inherits(cond, "message")) {
[13:19:58.956]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.956]                         if (muffled) 
[13:19:58.956]                           invokeRestart("muffleMessage")
[13:19:58.956]                       }
[13:19:58.956]                       else if (inherits(cond, "warning")) {
[13:19:58.956]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.956]                         if (muffled) 
[13:19:58.956]                           invokeRestart("muffleWarning")
[13:19:58.956]                       }
[13:19:58.956]                       else if (inherits(cond, "condition")) {
[13:19:58.956]                         if (!is.null(pattern)) {
[13:19:58.956]                           computeRestarts <- base::computeRestarts
[13:19:58.956]                           grepl <- base::grepl
[13:19:58.956]                           restarts <- computeRestarts(cond)
[13:19:58.956]                           for (restart in restarts) {
[13:19:58.956]                             name <- restart$name
[13:19:58.956]                             if (is.null(name)) 
[13:19:58.956]                               next
[13:19:58.956]                             if (!grepl(pattern, name)) 
[13:19:58.956]                               next
[13:19:58.956]                             invokeRestart(restart)
[13:19:58.956]                             muffled <- TRUE
[13:19:58.956]                             break
[13:19:58.956]                           }
[13:19:58.956]                         }
[13:19:58.956]                       }
[13:19:58.956]                       invisible(muffled)
[13:19:58.956]                     }
[13:19:58.956]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.956]                   }
[13:19:58.956]                 }
[13:19:58.956]                 else {
[13:19:58.956]                   if (TRUE) {
[13:19:58.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.956]                     {
[13:19:58.956]                       inherits <- base::inherits
[13:19:58.956]                       invokeRestart <- base::invokeRestart
[13:19:58.956]                       is.null <- base::is.null
[13:19:58.956]                       muffled <- FALSE
[13:19:58.956]                       if (inherits(cond, "message")) {
[13:19:58.956]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.956]                         if (muffled) 
[13:19:58.956]                           invokeRestart("muffleMessage")
[13:19:58.956]                       }
[13:19:58.956]                       else if (inherits(cond, "warning")) {
[13:19:58.956]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.956]                         if (muffled) 
[13:19:58.956]                           invokeRestart("muffleWarning")
[13:19:58.956]                       }
[13:19:58.956]                       else if (inherits(cond, "condition")) {
[13:19:58.956]                         if (!is.null(pattern)) {
[13:19:58.956]                           computeRestarts <- base::computeRestarts
[13:19:58.956]                           grepl <- base::grepl
[13:19:58.956]                           restarts <- computeRestarts(cond)
[13:19:58.956]                           for (restart in restarts) {
[13:19:58.956]                             name <- restart$name
[13:19:58.956]                             if (is.null(name)) 
[13:19:58.956]                               next
[13:19:58.956]                             if (!grepl(pattern, name)) 
[13:19:58.956]                               next
[13:19:58.956]                             invokeRestart(restart)
[13:19:58.956]                             muffled <- TRUE
[13:19:58.956]                             break
[13:19:58.956]                           }
[13:19:58.956]                         }
[13:19:58.956]                       }
[13:19:58.956]                       invisible(muffled)
[13:19:58.956]                     }
[13:19:58.956]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.956]                   }
[13:19:58.956]                 }
[13:19:58.956]             }
[13:19:58.956]         }))
[13:19:58.956]     }, error = function(ex) {
[13:19:58.956]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.956]                 ...future.rng), started = ...future.startTime, 
[13:19:58.956]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.956]             version = "1.8"), class = "FutureResult")
[13:19:58.956]     }, finally = {
[13:19:58.956]         if (!identical(...future.workdir, getwd())) 
[13:19:58.956]             setwd(...future.workdir)
[13:19:58.956]         {
[13:19:58.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.956]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.956]             }
[13:19:58.956]             base::options(...future.oldOptions)
[13:19:58.956]             if (.Platform$OS.type == "windows") {
[13:19:58.956]                 old_names <- names(...future.oldEnvVars)
[13:19:58.956]                 envs <- base::Sys.getenv()
[13:19:58.956]                 names <- names(envs)
[13:19:58.956]                 common <- intersect(names, old_names)
[13:19:58.956]                 added <- setdiff(names, old_names)
[13:19:58.956]                 removed <- setdiff(old_names, names)
[13:19:58.956]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.956]                   envs[common]]
[13:19:58.956]                 NAMES <- toupper(changed)
[13:19:58.956]                 args <- list()
[13:19:58.956]                 for (kk in seq_along(NAMES)) {
[13:19:58.956]                   name <- changed[[kk]]
[13:19:58.956]                   NAME <- NAMES[[kk]]
[13:19:58.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.956]                     next
[13:19:58.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.956]                 }
[13:19:58.956]                 NAMES <- toupper(added)
[13:19:58.956]                 for (kk in seq_along(NAMES)) {
[13:19:58.956]                   name <- added[[kk]]
[13:19:58.956]                   NAME <- NAMES[[kk]]
[13:19:58.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.956]                     next
[13:19:58.956]                   args[[name]] <- ""
[13:19:58.956]                 }
[13:19:58.956]                 NAMES <- toupper(removed)
[13:19:58.956]                 for (kk in seq_along(NAMES)) {
[13:19:58.956]                   name <- removed[[kk]]
[13:19:58.956]                   NAME <- NAMES[[kk]]
[13:19:58.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.956]                     next
[13:19:58.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.956]                 }
[13:19:58.956]                 if (length(args) > 0) 
[13:19:58.956]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.956]             }
[13:19:58.956]             else {
[13:19:58.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.956]             }
[13:19:58.956]             {
[13:19:58.956]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.956]                   0L) {
[13:19:58.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.956]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.956]                   base::options(opts)
[13:19:58.956]                 }
[13:19:58.956]                 {
[13:19:58.956]                   {
[13:19:58.956]                     NULL
[13:19:58.956]                     RNGkind("Mersenne-Twister")
[13:19:58.956]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:58.956]                       inherits = FALSE)
[13:19:58.956]                   }
[13:19:58.956]                   options(future.plan = NULL)
[13:19:58.956]                   if (is.na(NA_character_)) 
[13:19:58.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.956]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:58.956]                   {
[13:19:58.956]                     future <- SequentialFuture(..., envir = envir)
[13:19:58.956]                     if (!future$lazy) 
[13:19:58.956]                       future <- run(future)
[13:19:58.956]                     invisible(future)
[13:19:58.956]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.956]                 }
[13:19:58.956]             }
[13:19:58.956]         }
[13:19:58.956]     })
[13:19:58.956]     if (TRUE) {
[13:19:58.956]         base::sink(type = "output", split = FALSE)
[13:19:58.956]         if (TRUE) {
[13:19:58.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.956]         }
[13:19:58.956]         else {
[13:19:58.956]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.956]         }
[13:19:58.956]         base::close(...future.stdout)
[13:19:58.956]         ...future.stdout <- NULL
[13:19:58.956]     }
[13:19:58.956]     ...future.result$conditions <- ...future.conditions
[13:19:58.956]     ...future.result$finished <- base::Sys.time()
[13:19:58.956]     ...future.result
[13:19:58.956] }
[13:19:58.958] assign_globals() ...
[13:19:58.958] List of 2
[13:19:58.958]  $ x: int [1:2] 1 2
[13:19:58.958]  $ y: num 3
[13:19:58.958]  - attr(*, "where")=List of 2
[13:19:58.958]   ..$ x:<environment: R_EmptyEnv> 
[13:19:58.958]   ..$ y:<environment: R_EmptyEnv> 
[13:19:58.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.958]  - attr(*, "resolved")= logi FALSE
[13:19:58.958]  - attr(*, "total_size")= num 112
[13:19:58.958]  - attr(*, "already-done")= logi TRUE
[13:19:58.961] - copied ‘x’ to environment
[13:19:58.961] - copied ‘y’ to environment
[13:19:58.961] assign_globals() ... done
[13:19:58.961] plan(): Setting new future strategy stack:
[13:19:58.961] List of future strategies:
[13:19:58.961] 1. sequential:
[13:19:58.961]    - args: function (..., envir = parent.frame())
[13:19:58.961]    - tweaked: FALSE
[13:19:58.961]    - call: NULL
[13:19:58.962] plan(): nbrOfWorkers() = 1
[13:19:58.963] plan(): Setting new future strategy stack:
[13:19:58.963] List of future strategies:
[13:19:58.963] 1. sequential:
[13:19:58.963]    - args: function (..., envir = parent.frame())
[13:19:58.963]    - tweaked: FALSE
[13:19:58.963]    - call: plan(strategy, substitute = FALSE)
[13:19:58.963] plan(): nbrOfWorkers() = 1
[13:19:58.963] SequentialFuture started (and completed)
[13:19:58.963] signalConditions() ...
[13:19:58.963]  - include = ‘immediateCondition’
[13:19:58.964]  - exclude = 
[13:19:58.964]  - resignal = FALSE
[13:19:58.964]  - Number of conditions: 1
[13:19:58.964] signalConditions() ... done
[13:19:58.964] - Launch lazy future ... done
[13:19:58.964] run() for ‘SequentialFuture’ ... done
[13:19:58.964] signalConditions() ...
[13:19:58.964]  - include = ‘immediateCondition’
[13:19:58.964]  - exclude = 
[13:19:58.964]  - resignal = FALSE
[13:19:58.964]  - Number of conditions: 1
[13:19:58.965] signalConditions() ... done
[13:19:58.965] Future state: ‘finished’
[13:19:58.965] signalConditions() ...
[13:19:58.965]  - include = ‘condition’
[13:19:58.965]  - exclude = ‘immediateCondition’
[13:19:58.965]  - resignal = TRUE
[13:19:58.965]  - Number of conditions: 1
[13:19:58.965]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:19:58.965] signalConditions() ... done
Error in eval(quote({ : '...' used in an incorrect context
[1] "Error in eval(quote({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    sum(x, y, ...)}), new.env()): '...' used in an incorrect context>
** Sum function 'E' with plan('sequential') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x562224c2fea0>
Arguments '...' exists: TRUE
[13:19:58.966] getGlobalsAndPackages() ...
[13:19:58.966] - globals passed as-is: [1] ‘...’
[13:19:58.966] Resolving globals: FALSE
[13:19:58.966] Tweak future expression to call with '...' arguments ...
[13:19:58.967] {
[13:19:58.967]     do.call(function(...) {
[13:19:58.967]         fcn <- function() sum(...)
[13:19:58.967]         fcn()
[13:19:58.967]     }, args = future.call.arguments)
[13:19:58.967] }
[13:19:58.967] Tweak future expression to call with '...' arguments ... DONE
[13:19:58.967] The total size of the 1 globals is 112 bytes (112 bytes)
[13:19:58.967] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[13:19:58.967] - globals: [1] ‘future.call.arguments’
[13:19:58.968] 
[13:19:58.968] getGlobalsAndPackages() ... DONE
[13:19:58.968] run() for ‘Future’ ...
[13:19:58.968] - state: ‘created’
[13:19:58.968] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:58.968] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:58.968] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:58.969]   - Field: ‘label’
[13:19:58.969]   - Field: ‘local’
[13:19:58.969]   - Field: ‘owner’
[13:19:58.969]   - Field: ‘envir’
[13:19:58.969]   - Field: ‘packages’
[13:19:58.969]   - Field: ‘gc’
[13:19:58.969]   - Field: ‘conditions’
[13:19:58.969]   - Field: ‘expr’
[13:19:58.969]   - Field: ‘uuid’
[13:19:58.969]   - Field: ‘seed’
[13:19:58.970]   - Field: ‘version’
[13:19:58.970]   - Field: ‘result’
[13:19:58.970]   - Field: ‘asynchronous’
[13:19:58.970]   - Field: ‘calls’
[13:19:58.970]   - Field: ‘globals’
[13:19:58.970]   - Field: ‘stdout’
[13:19:58.970]   - Field: ‘earlySignal’
[13:19:58.970]   - Field: ‘lazy’
[13:19:58.970]   - Field: ‘state’
[13:19:58.970] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:58.970] - Launch lazy future ...
[13:19:58.971] Packages needed by the future expression (n = 0): <none>
[13:19:58.971] Packages needed by future strategies (n = 0): <none>
[13:19:58.971] {
[13:19:58.971]     {
[13:19:58.971]         {
[13:19:58.971]             ...future.startTime <- base::Sys.time()
[13:19:58.971]             {
[13:19:58.971]                 {
[13:19:58.971]                   {
[13:19:58.971]                     base::local({
[13:19:58.971]                       has_future <- base::requireNamespace("future", 
[13:19:58.971]                         quietly = TRUE)
[13:19:58.971]                       if (has_future) {
[13:19:58.971]                         ns <- base::getNamespace("future")
[13:19:58.971]                         version <- ns[[".package"]][["version"]]
[13:19:58.971]                         if (is.null(version)) 
[13:19:58.971]                           version <- utils::packageVersion("future")
[13:19:58.971]                       }
[13:19:58.971]                       else {
[13:19:58.971]                         version <- NULL
[13:19:58.971]                       }
[13:19:58.971]                       if (!has_future || version < "1.8.0") {
[13:19:58.971]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.971]                           "", base::R.version$version.string), 
[13:19:58.971]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:58.971]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.971]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.971]                             "release", "version")], collapse = " "), 
[13:19:58.971]                           hostname = base::Sys.info()[["nodename"]])
[13:19:58.971]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.971]                           info)
[13:19:58.971]                         info <- base::paste(info, collapse = "; ")
[13:19:58.971]                         if (!has_future) {
[13:19:58.971]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.971]                             info)
[13:19:58.971]                         }
[13:19:58.971]                         else {
[13:19:58.971]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.971]                             info, version)
[13:19:58.971]                         }
[13:19:58.971]                         base::stop(msg)
[13:19:58.971]                       }
[13:19:58.971]                     })
[13:19:58.971]                   }
[13:19:58.971]                   options(future.plan = NULL)
[13:19:58.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.971]                 }
[13:19:58.971]                 ...future.workdir <- getwd()
[13:19:58.971]             }
[13:19:58.971]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.971]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.971]         }
[13:19:58.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.971]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:58.971]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.971]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.971]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.971]             base::names(...future.oldOptions))
[13:19:58.971]     }
[13:19:58.971]     if (FALSE) {
[13:19:58.971]     }
[13:19:58.971]     else {
[13:19:58.971]         if (TRUE) {
[13:19:58.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.971]                 open = "w")
[13:19:58.971]         }
[13:19:58.971]         else {
[13:19:58.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.971]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.971]         }
[13:19:58.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.971]             base::sink(type = "output", split = FALSE)
[13:19:58.971]             base::close(...future.stdout)
[13:19:58.971]         }, add = TRUE)
[13:19:58.971]     }
[13:19:58.971]     ...future.frame <- base::sys.nframe()
[13:19:58.971]     ...future.conditions <- base::list()
[13:19:58.971]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.971]     if (FALSE) {
[13:19:58.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.971]     }
[13:19:58.971]     ...future.result <- base::tryCatch({
[13:19:58.971]         base::withCallingHandlers({
[13:19:58.971]             ...future.value <- base::withVisible(base::local({
[13:19:58.971]                 do.call(function(...) {
[13:19:58.971]                   fcn <- function() sum(...)
[13:19:58.971]                   fcn()
[13:19:58.971]                 }, args = future.call.arguments)
[13:19:58.971]             }))
[13:19:58.971]             future::FutureResult(value = ...future.value$value, 
[13:19:58.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.971]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.971]                     ...future.globalenv.names))
[13:19:58.971]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.971]         }, condition = base::local({
[13:19:58.971]             c <- base::c
[13:19:58.971]             inherits <- base::inherits
[13:19:58.971]             invokeRestart <- base::invokeRestart
[13:19:58.971]             length <- base::length
[13:19:58.971]             list <- base::list
[13:19:58.971]             seq.int <- base::seq.int
[13:19:58.971]             signalCondition <- base::signalCondition
[13:19:58.971]             sys.calls <- base::sys.calls
[13:19:58.971]             `[[` <- base::`[[`
[13:19:58.971]             `+` <- base::`+`
[13:19:58.971]             `<<-` <- base::`<<-`
[13:19:58.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.971]                   3L)]
[13:19:58.971]             }
[13:19:58.971]             function(cond) {
[13:19:58.971]                 is_error <- inherits(cond, "error")
[13:19:58.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.971]                   NULL)
[13:19:58.971]                 if (is_error) {
[13:19:58.971]                   sessionInformation <- function() {
[13:19:58.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.971]                       search = base::search(), system = base::Sys.info())
[13:19:58.971]                   }
[13:19:58.971]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.971]                     cond$call), session = sessionInformation(), 
[13:19:58.971]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.971]                   signalCondition(cond)
[13:19:58.971]                 }
[13:19:58.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.971]                 "immediateCondition"))) {
[13:19:58.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.971]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.971]                   if (TRUE && !signal) {
[13:19:58.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.971]                     {
[13:19:58.971]                       inherits <- base::inherits
[13:19:58.971]                       invokeRestart <- base::invokeRestart
[13:19:58.971]                       is.null <- base::is.null
[13:19:58.971]                       muffled <- FALSE
[13:19:58.971]                       if (inherits(cond, "message")) {
[13:19:58.971]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.971]                         if (muffled) 
[13:19:58.971]                           invokeRestart("muffleMessage")
[13:19:58.971]                       }
[13:19:58.971]                       else if (inherits(cond, "warning")) {
[13:19:58.971]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.971]                         if (muffled) 
[13:19:58.971]                           invokeRestart("muffleWarning")
[13:19:58.971]                       }
[13:19:58.971]                       else if (inherits(cond, "condition")) {
[13:19:58.971]                         if (!is.null(pattern)) {
[13:19:58.971]                           computeRestarts <- base::computeRestarts
[13:19:58.971]                           grepl <- base::grepl
[13:19:58.971]                           restarts <- computeRestarts(cond)
[13:19:58.971]                           for (restart in restarts) {
[13:19:58.971]                             name <- restart$name
[13:19:58.971]                             if (is.null(name)) 
[13:19:58.971]                               next
[13:19:58.971]                             if (!grepl(pattern, name)) 
[13:19:58.971]                               next
[13:19:58.971]                             invokeRestart(restart)
[13:19:58.971]                             muffled <- TRUE
[13:19:58.971]                             break
[13:19:58.971]                           }
[13:19:58.971]                         }
[13:19:58.971]                       }
[13:19:58.971]                       invisible(muffled)
[13:19:58.971]                     }
[13:19:58.971]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.971]                   }
[13:19:58.971]                 }
[13:19:58.971]                 else {
[13:19:58.971]                   if (TRUE) {
[13:19:58.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.971]                     {
[13:19:58.971]                       inherits <- base::inherits
[13:19:58.971]                       invokeRestart <- base::invokeRestart
[13:19:58.971]                       is.null <- base::is.null
[13:19:58.971]                       muffled <- FALSE
[13:19:58.971]                       if (inherits(cond, "message")) {
[13:19:58.971]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.971]                         if (muffled) 
[13:19:58.971]                           invokeRestart("muffleMessage")
[13:19:58.971]                       }
[13:19:58.971]                       else if (inherits(cond, "warning")) {
[13:19:58.971]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.971]                         if (muffled) 
[13:19:58.971]                           invokeRestart("muffleWarning")
[13:19:58.971]                       }
[13:19:58.971]                       else if (inherits(cond, "condition")) {
[13:19:58.971]                         if (!is.null(pattern)) {
[13:19:58.971]                           computeRestarts <- base::computeRestarts
[13:19:58.971]                           grepl <- base::grepl
[13:19:58.971]                           restarts <- computeRestarts(cond)
[13:19:58.971]                           for (restart in restarts) {
[13:19:58.971]                             name <- restart$name
[13:19:58.971]                             if (is.null(name)) 
[13:19:58.971]                               next
[13:19:58.971]                             if (!grepl(pattern, name)) 
[13:19:58.971]                               next
[13:19:58.971]                             invokeRestart(restart)
[13:19:58.971]                             muffled <- TRUE
[13:19:58.971]                             break
[13:19:58.971]                           }
[13:19:58.971]                         }
[13:19:58.971]                       }
[13:19:58.971]                       invisible(muffled)
[13:19:58.971]                     }
[13:19:58.971]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.971]                   }
[13:19:58.971]                 }
[13:19:58.971]             }
[13:19:58.971]         }))
[13:19:58.971]     }, error = function(ex) {
[13:19:58.971]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.971]                 ...future.rng), started = ...future.startTime, 
[13:19:58.971]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.971]             version = "1.8"), class = "FutureResult")
[13:19:58.971]     }, finally = {
[13:19:58.971]         if (!identical(...future.workdir, getwd())) 
[13:19:58.971]             setwd(...future.workdir)
[13:19:58.971]         {
[13:19:58.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.971]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.971]             }
[13:19:58.971]             base::options(...future.oldOptions)
[13:19:58.971]             if (.Platform$OS.type == "windows") {
[13:19:58.971]                 old_names <- names(...future.oldEnvVars)
[13:19:58.971]                 envs <- base::Sys.getenv()
[13:19:58.971]                 names <- names(envs)
[13:19:58.971]                 common <- intersect(names, old_names)
[13:19:58.971]                 added <- setdiff(names, old_names)
[13:19:58.971]                 removed <- setdiff(old_names, names)
[13:19:58.971]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.971]                   envs[common]]
[13:19:58.971]                 NAMES <- toupper(changed)
[13:19:58.971]                 args <- list()
[13:19:58.971]                 for (kk in seq_along(NAMES)) {
[13:19:58.971]                   name <- changed[[kk]]
[13:19:58.971]                   NAME <- NAMES[[kk]]
[13:19:58.971]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.971]                     next
[13:19:58.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.971]                 }
[13:19:58.971]                 NAMES <- toupper(added)
[13:19:58.971]                 for (kk in seq_along(NAMES)) {
[13:19:58.971]                   name <- added[[kk]]
[13:19:58.971]                   NAME <- NAMES[[kk]]
[13:19:58.971]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.971]                     next
[13:19:58.971]                   args[[name]] <- ""
[13:19:58.971]                 }
[13:19:58.971]                 NAMES <- toupper(removed)
[13:19:58.971]                 for (kk in seq_along(NAMES)) {
[13:19:58.971]                   name <- removed[[kk]]
[13:19:58.971]                   NAME <- NAMES[[kk]]
[13:19:58.971]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.971]                     next
[13:19:58.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.971]                 }
[13:19:58.971]                 if (length(args) > 0) 
[13:19:58.971]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.971]             }
[13:19:58.971]             else {
[13:19:58.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.971]             }
[13:19:58.971]             {
[13:19:58.971]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.971]                   0L) {
[13:19:58.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.971]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.971]                   base::options(opts)
[13:19:58.971]                 }
[13:19:58.971]                 {
[13:19:58.971]                   {
[13:19:58.971]                     NULL
[13:19:58.971]                     RNGkind("Mersenne-Twister")
[13:19:58.971]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:58.971]                       inherits = FALSE)
[13:19:58.971]                   }
[13:19:58.971]                   options(future.plan = NULL)
[13:19:58.971]                   if (is.na(NA_character_)) 
[13:19:58.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.971]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:58.971]                   {
[13:19:58.971]                     future <- SequentialFuture(..., envir = envir)
[13:19:58.971]                     if (!future$lazy) 
[13:19:58.971]                       future <- run(future)
[13:19:58.971]                     invisible(future)
[13:19:58.971]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.971]                 }
[13:19:58.971]             }
[13:19:58.971]         }
[13:19:58.971]     })
[13:19:58.971]     if (TRUE) {
[13:19:58.971]         base::sink(type = "output", split = FALSE)
[13:19:58.971]         if (TRUE) {
[13:19:58.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.971]         }
[13:19:58.971]         else {
[13:19:58.971]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.971]         }
[13:19:58.971]         base::close(...future.stdout)
[13:19:58.971]         ...future.stdout <- NULL
[13:19:58.971]     }
[13:19:58.971]     ...future.result$conditions <- ...future.conditions
[13:19:58.971]     ...future.result$finished <- base::Sys.time()
[13:19:58.971]     ...future.result
[13:19:58.971] }
[13:19:58.973] assign_globals() ...
[13:19:58.973] List of 1
[13:19:58.973]  $ future.call.arguments:List of 2
[13:19:58.973]   ..$ : int [1:2] 1 2
[13:19:58.973]   ..$ : num 3
[13:19:58.973]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:58.973]  - attr(*, "where")=List of 1
[13:19:58.973]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[13:19:58.973]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.973]  - attr(*, "resolved")= logi FALSE
[13:19:58.973]  - attr(*, "total_size")= num 112
[13:19:58.973]  - attr(*, "already-done")= logi TRUE
[13:19:58.976] - copied ‘future.call.arguments’ to environment
[13:19:58.976] assign_globals() ... done
[13:19:58.976] plan(): Setting new future strategy stack:
[13:19:58.976] List of future strategies:
[13:19:58.976] 1. sequential:
[13:19:58.976]    - args: function (..., envir = parent.frame())
[13:19:58.976]    - tweaked: FALSE
[13:19:58.976]    - call: NULL
[13:19:58.977] plan(): nbrOfWorkers() = 1
[13:19:58.977] plan(): Setting new future strategy stack:
[13:19:58.977] List of future strategies:
[13:19:58.977] 1. sequential:
[13:19:58.977]    - args: function (..., envir = parent.frame())
[13:19:58.977]    - tweaked: FALSE
[13:19:58.977]    - call: plan(strategy, substitute = FALSE)
[13:19:58.979] plan(): nbrOfWorkers() = 1
[13:19:58.979] SequentialFuture started (and completed)
[13:19:58.979] - Launch lazy future ... done
[13:19:58.979] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'F' with plan('sequential') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x5622250ae1d8>
Using '...' in a formula
[13:19:58.980] getGlobalsAndPackages() ...
[13:19:58.980] Searching for globals...
[13:19:58.983] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[13:19:58.983] Searching for globals ... DONE
[13:19:58.983] Resolving globals: FALSE
[13:19:58.983] Tweak future expression to call with '...' arguments ...
[13:19:58.984] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[13:19:58.984] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[13:19:58.984] - globals: [3] ‘fcn’, ‘x’, ‘y’
[13:19:58.984] 
[13:19:58.984] getGlobalsAndPackages() ... DONE
[13:19:58.984] run() for ‘Future’ ...
[13:19:58.985] - state: ‘created’
[13:19:58.985] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:58.985] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:58.985] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:58.985]   - Field: ‘label’
[13:19:58.985]   - Field: ‘local’
[13:19:58.985]   - Field: ‘owner’
[13:19:58.985]   - Field: ‘envir’
[13:19:58.986]   - Field: ‘packages’
[13:19:58.986]   - Field: ‘gc’
[13:19:58.986]   - Field: ‘conditions’
[13:19:58.986]   - Field: ‘expr’
[13:19:58.986]   - Field: ‘uuid’
[13:19:58.986]   - Field: ‘seed’
[13:19:58.986]   - Field: ‘version’
[13:19:58.986]   - Field: ‘result’
[13:19:58.986]   - Field: ‘asynchronous’
[13:19:58.986]   - Field: ‘calls’
[13:19:58.986]   - Field: ‘globals’
[13:19:58.987]   - Field: ‘stdout’
[13:19:58.987]   - Field: ‘earlySignal’
[13:19:58.987]   - Field: ‘lazy’
[13:19:58.987]   - Field: ‘state’
[13:19:58.987] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:58.987] - Launch lazy future ...
[13:19:58.987] Packages needed by the future expression (n = 0): <none>
[13:19:58.987] Packages needed by future strategies (n = 0): <none>
[13:19:58.988] {
[13:19:58.988]     {
[13:19:58.988]         {
[13:19:58.988]             ...future.startTime <- base::Sys.time()
[13:19:58.988]             {
[13:19:58.988]                 {
[13:19:58.988]                   {
[13:19:58.988]                     base::local({
[13:19:58.988]                       has_future <- base::requireNamespace("future", 
[13:19:58.988]                         quietly = TRUE)
[13:19:58.988]                       if (has_future) {
[13:19:58.988]                         ns <- base::getNamespace("future")
[13:19:58.988]                         version <- ns[[".package"]][["version"]]
[13:19:58.988]                         if (is.null(version)) 
[13:19:58.988]                           version <- utils::packageVersion("future")
[13:19:58.988]                       }
[13:19:58.988]                       else {
[13:19:58.988]                         version <- NULL
[13:19:58.988]                       }
[13:19:58.988]                       if (!has_future || version < "1.8.0") {
[13:19:58.988]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.988]                           "", base::R.version$version.string), 
[13:19:58.988]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:58.988]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:58.988]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.988]                             "release", "version")], collapse = " "), 
[13:19:58.988]                           hostname = base::Sys.info()[["nodename"]])
[13:19:58.988]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.988]                           info)
[13:19:58.988]                         info <- base::paste(info, collapse = "; ")
[13:19:58.988]                         if (!has_future) {
[13:19:58.988]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.988]                             info)
[13:19:58.988]                         }
[13:19:58.988]                         else {
[13:19:58.988]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.988]                             info, version)
[13:19:58.988]                         }
[13:19:58.988]                         base::stop(msg)
[13:19:58.988]                       }
[13:19:58.988]                     })
[13:19:58.988]                   }
[13:19:58.988]                   options(future.plan = NULL)
[13:19:58.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.988]                 }
[13:19:58.988]                 ...future.workdir <- getwd()
[13:19:58.988]             }
[13:19:58.988]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.988]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.988]         }
[13:19:58.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.988]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:58.988]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.988]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.988]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.988]             base::names(...future.oldOptions))
[13:19:58.988]     }
[13:19:58.988]     if (FALSE) {
[13:19:58.988]     }
[13:19:58.988]     else {
[13:19:58.988]         if (TRUE) {
[13:19:58.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.988]                 open = "w")
[13:19:58.988]         }
[13:19:58.988]         else {
[13:19:58.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.988]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.988]         }
[13:19:58.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.988]             base::sink(type = "output", split = FALSE)
[13:19:58.988]             base::close(...future.stdout)
[13:19:58.988]         }, add = TRUE)
[13:19:58.988]     }
[13:19:58.988]     ...future.frame <- base::sys.nframe()
[13:19:58.988]     ...future.conditions <- base::list()
[13:19:58.988]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.988]     if (FALSE) {
[13:19:58.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.988]     }
[13:19:58.988]     ...future.result <- base::tryCatch({
[13:19:58.988]         base::withCallingHandlers({
[13:19:58.988]             ...future.value <- base::withVisible(base::local(fcn(x, 
[13:19:58.988]                 y)))
[13:19:58.988]             future::FutureResult(value = ...future.value$value, 
[13:19:58.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.988]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.988]                     ...future.globalenv.names))
[13:19:58.988]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.988]         }, condition = base::local({
[13:19:58.988]             c <- base::c
[13:19:58.988]             inherits <- base::inherits
[13:19:58.988]             invokeRestart <- base::invokeRestart
[13:19:58.988]             length <- base::length
[13:19:58.988]             list <- base::list
[13:19:58.988]             seq.int <- base::seq.int
[13:19:58.988]             signalCondition <- base::signalCondition
[13:19:58.988]             sys.calls <- base::sys.calls
[13:19:58.988]             `[[` <- base::`[[`
[13:19:58.988]             `+` <- base::`+`
[13:19:58.988]             `<<-` <- base::`<<-`
[13:19:58.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.988]                   3L)]
[13:19:58.988]             }
[13:19:58.988]             function(cond) {
[13:19:58.988]                 is_error <- inherits(cond, "error")
[13:19:58.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.988]                   NULL)
[13:19:58.988]                 if (is_error) {
[13:19:58.988]                   sessionInformation <- function() {
[13:19:58.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.988]                       search = base::search(), system = base::Sys.info())
[13:19:58.988]                   }
[13:19:58.988]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.988]                     cond$call), session = sessionInformation(), 
[13:19:58.988]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.988]                   signalCondition(cond)
[13:19:58.988]                 }
[13:19:58.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.988]                 "immediateCondition"))) {
[13:19:58.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.988]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.988]                   if (TRUE && !signal) {
[13:19:58.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.988]                     {
[13:19:58.988]                       inherits <- base::inherits
[13:19:58.988]                       invokeRestart <- base::invokeRestart
[13:19:58.988]                       is.null <- base::is.null
[13:19:58.988]                       muffled <- FALSE
[13:19:58.988]                       if (inherits(cond, "message")) {
[13:19:58.988]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.988]                         if (muffled) 
[13:19:58.988]                           invokeRestart("muffleMessage")
[13:19:58.988]                       }
[13:19:58.988]                       else if (inherits(cond, "warning")) {
[13:19:58.988]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.988]                         if (muffled) 
[13:19:58.988]                           invokeRestart("muffleWarning")
[13:19:58.988]                       }
[13:19:58.988]                       else if (inherits(cond, "condition")) {
[13:19:58.988]                         if (!is.null(pattern)) {
[13:19:58.988]                           computeRestarts <- base::computeRestarts
[13:19:58.988]                           grepl <- base::grepl
[13:19:58.988]                           restarts <- computeRestarts(cond)
[13:19:58.988]                           for (restart in restarts) {
[13:19:58.988]                             name <- restart$name
[13:19:58.988]                             if (is.null(name)) 
[13:19:58.988]                               next
[13:19:58.988]                             if (!grepl(pattern, name)) 
[13:19:58.988]                               next
[13:19:58.988]                             invokeRestart(restart)
[13:19:58.988]                             muffled <- TRUE
[13:19:58.988]                             break
[13:19:58.988]                           }
[13:19:58.988]                         }
[13:19:58.988]                       }
[13:19:58.988]                       invisible(muffled)
[13:19:58.988]                     }
[13:19:58.988]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.988]                   }
[13:19:58.988]                 }
[13:19:58.988]                 else {
[13:19:58.988]                   if (TRUE) {
[13:19:58.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.988]                     {
[13:19:58.988]                       inherits <- base::inherits
[13:19:58.988]                       invokeRestart <- base::invokeRestart
[13:19:58.988]                       is.null <- base::is.null
[13:19:58.988]                       muffled <- FALSE
[13:19:58.988]                       if (inherits(cond, "message")) {
[13:19:58.988]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.988]                         if (muffled) 
[13:19:58.988]                           invokeRestart("muffleMessage")
[13:19:58.988]                       }
[13:19:58.988]                       else if (inherits(cond, "warning")) {
[13:19:58.988]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.988]                         if (muffled) 
[13:19:58.988]                           invokeRestart("muffleWarning")
[13:19:58.988]                       }
[13:19:58.988]                       else if (inherits(cond, "condition")) {
[13:19:58.988]                         if (!is.null(pattern)) {
[13:19:58.988]                           computeRestarts <- base::computeRestarts
[13:19:58.988]                           grepl <- base::grepl
[13:19:58.988]                           restarts <- computeRestarts(cond)
[13:19:58.988]                           for (restart in restarts) {
[13:19:58.988]                             name <- restart$name
[13:19:58.988]                             if (is.null(name)) 
[13:19:58.988]                               next
[13:19:58.988]                             if (!grepl(pattern, name)) 
[13:19:58.988]                               next
[13:19:58.988]                             invokeRestart(restart)
[13:19:58.988]                             muffled <- TRUE
[13:19:58.988]                             break
[13:19:58.988]                           }
[13:19:58.988]                         }
[13:19:58.988]                       }
[13:19:58.988]                       invisible(muffled)
[13:19:58.988]                     }
[13:19:58.988]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.988]                   }
[13:19:58.988]                 }
[13:19:58.988]             }
[13:19:58.988]         }))
[13:19:58.988]     }, error = function(ex) {
[13:19:58.988]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.988]                 ...future.rng), started = ...future.startTime, 
[13:19:58.988]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.988]             version = "1.8"), class = "FutureResult")
[13:19:58.988]     }, finally = {
[13:19:58.988]         if (!identical(...future.workdir, getwd())) 
[13:19:58.988]             setwd(...future.workdir)
[13:19:58.988]         {
[13:19:58.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.988]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.988]             }
[13:19:58.988]             base::options(...future.oldOptions)
[13:19:58.988]             if (.Platform$OS.type == "windows") {
[13:19:58.988]                 old_names <- names(...future.oldEnvVars)
[13:19:58.988]                 envs <- base::Sys.getenv()
[13:19:58.988]                 names <- names(envs)
[13:19:58.988]                 common <- intersect(names, old_names)
[13:19:58.988]                 added <- setdiff(names, old_names)
[13:19:58.988]                 removed <- setdiff(old_names, names)
[13:19:58.988]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.988]                   envs[common]]
[13:19:58.988]                 NAMES <- toupper(changed)
[13:19:58.988]                 args <- list()
[13:19:58.988]                 for (kk in seq_along(NAMES)) {
[13:19:58.988]                   name <- changed[[kk]]
[13:19:58.988]                   NAME <- NAMES[[kk]]
[13:19:58.988]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.988]                     next
[13:19:58.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.988]                 }
[13:19:58.988]                 NAMES <- toupper(added)
[13:19:58.988]                 for (kk in seq_along(NAMES)) {
[13:19:58.988]                   name <- added[[kk]]
[13:19:58.988]                   NAME <- NAMES[[kk]]
[13:19:58.988]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.988]                     next
[13:19:58.988]                   args[[name]] <- ""
[13:19:58.988]                 }
[13:19:58.988]                 NAMES <- toupper(removed)
[13:19:58.988]                 for (kk in seq_along(NAMES)) {
[13:19:58.988]                   name <- removed[[kk]]
[13:19:58.988]                   NAME <- NAMES[[kk]]
[13:19:58.988]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.988]                     next
[13:19:58.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.988]                 }
[13:19:58.988]                 if (length(args) > 0) 
[13:19:58.988]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.988]             }
[13:19:58.988]             else {
[13:19:58.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.988]             }
[13:19:58.988]             {
[13:19:58.988]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.988]                   0L) {
[13:19:58.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.988]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.988]                   base::options(opts)
[13:19:58.988]                 }
[13:19:58.988]                 {
[13:19:58.988]                   {
[13:19:58.988]                     NULL
[13:19:58.988]                     RNGkind("Mersenne-Twister")
[13:19:58.988]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:58.988]                       inherits = FALSE)
[13:19:58.988]                   }
[13:19:58.988]                   options(future.plan = NULL)
[13:19:58.988]                   if (is.na(NA_character_)) 
[13:19:58.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.988]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:58.988]                   {
[13:19:58.988]                     future <- SequentialFuture(..., envir = envir)
[13:19:58.988]                     if (!future$lazy) 
[13:19:58.988]                       future <- run(future)
[13:19:58.988]                     invisible(future)
[13:19:58.988]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.988]                 }
[13:19:58.988]             }
[13:19:58.988]         }
[13:19:58.988]     })
[13:19:58.988]     if (TRUE) {
[13:19:58.988]         base::sink(type = "output", split = FALSE)
[13:19:58.988]         if (TRUE) {
[13:19:58.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.988]         }
[13:19:58.988]         else {
[13:19:58.988]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.988]         }
[13:19:58.988]         base::close(...future.stdout)
[13:19:58.988]         ...future.stdout <- NULL
[13:19:58.988]     }
[13:19:58.988]     ...future.result$conditions <- ...future.conditions
[13:19:58.988]     ...future.result$finished <- base::Sys.time()
[13:19:58.988]     ...future.result
[13:19:58.988] }
[13:19:58.989] assign_globals() ...
[13:19:58.989] List of 3
[13:19:58.989]  $ fcn:function (x, y)  
[13:19:58.989]  $ x  : int [1:2] 1 2
[13:19:58.989]  $ y  : num 3
[13:19:58.989]  - attr(*, "where")=List of 3
[13:19:58.989]   ..$ fcn:<environment: R_EmptyEnv> 
[13:19:58.989]   ..$ x  :<environment: R_EmptyEnv> 
[13:19:58.989]   ..$ y  :<environment: R_EmptyEnv> 
[13:19:58.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:58.989]  - attr(*, "resolved")= logi FALSE
[13:19:58.989]  - attr(*, "total_size")= num 4280
[13:19:58.989]  - attr(*, "already-done")= logi TRUE
[13:19:58.993] - reassign environment for ‘fcn’
[13:19:58.993] - copied ‘fcn’ to environment
[13:19:58.993] - copied ‘x’ to environment
[13:19:58.993] - copied ‘y’ to environment
[13:19:58.993] assign_globals() ... done
[13:19:58.993] plan(): Setting new future strategy stack:
[13:19:58.993] List of future strategies:
[13:19:58.993] 1. sequential:
[13:19:58.993]    - args: function (..., envir = parent.frame())
[13:19:58.993]    - tweaked: FALSE
[13:19:58.993]    - call: NULL
[13:19:58.994] plan(): nbrOfWorkers() = 1
[13:19:58.994] plan(): Setting new future strategy stack:
[13:19:58.994] List of future strategies:
[13:19:58.994] 1. sequential:
[13:19:58.994]    - args: function (..., envir = parent.frame())
[13:19:58.994]    - tweaked: FALSE
[13:19:58.994]    - call: plan(strategy, substitute = FALSE)
[13:19:58.995] plan(): nbrOfWorkers() = 1
[13:19:58.995] SequentialFuture started (and completed)
[13:19:58.995] - Launch lazy future ... done
[13:19:58.995] run() for ‘SequentialFuture’ ... done
[1] 6
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** Global argument '...' ...
- plan('multicore') ...
[13:19:59.001] plan(): Setting new future strategy stack:
[13:19:59.001] List of future strategies:
[13:19:59.001] 1. multicore:
[13:19:59.001]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:59.001]    - tweaked: FALSE
[13:19:59.001]    - call: plan(strategy, substitute = FALSE)
[13:19:59.006] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multicore') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x56222563c7b8>
Arguments '...' exists: TRUE
[13:19:59.007] getGlobalsAndPackages() ...
[13:19:59.007] Searching for globals...
[13:19:59.008] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[13:19:59.009] Searching for globals ... DONE
[13:19:59.009] Resolving globals: FALSE
[13:19:59.009] Tweak future expression to call with '...' arguments ...
[13:19:59.009] {
[13:19:59.009]     do.call(function(...) {
[13:19:59.009]         sum(x, ...)
[13:19:59.009]     }, args = future.call.arguments)
[13:19:59.009] }
[13:19:59.009] Tweak future expression to call with '...' arguments ... DONE
[13:19:59.010] The total size of the 2 globals is 112 bytes (112 bytes)
[13:19:59.010] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[13:19:59.010] - globals: [2] ‘x’, ‘future.call.arguments’
[13:19:59.010] 
[13:19:59.010] getGlobalsAndPackages() ... DONE
[13:19:59.011] run() for ‘Future’ ...
[13:19:59.011] - state: ‘created’
[13:19:59.011] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.014] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.014] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:59.015]   - Field: ‘label’
[13:19:59.015]   - Field: ‘local’
[13:19:59.015]   - Field: ‘owner’
[13:19:59.015]   - Field: ‘envir’
[13:19:59.015]   - Field: ‘workers’
[13:19:59.015]   - Field: ‘packages’
[13:19:59.015]   - Field: ‘gc’
[13:19:59.015]   - Field: ‘job’
[13:19:59.015]   - Field: ‘conditions’
[13:19:59.015]   - Field: ‘expr’
[13:19:59.016]   - Field: ‘uuid’
[13:19:59.016]   - Field: ‘seed’
[13:19:59.016]   - Field: ‘version’
[13:19:59.016]   - Field: ‘result’
[13:19:59.016]   - Field: ‘asynchronous’
[13:19:59.016]   - Field: ‘calls’
[13:19:59.016]   - Field: ‘globals’
[13:19:59.016]   - Field: ‘stdout’
[13:19:59.016]   - Field: ‘earlySignal’
[13:19:59.016]   - Field: ‘lazy’
[13:19:59.016]   - Field: ‘state’
[13:19:59.017] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:59.017] - Launch lazy future ...
[13:19:59.018] Packages needed by the future expression (n = 0): <none>
[13:19:59.018] Packages needed by future strategies (n = 0): <none>
[13:19:59.018] {
[13:19:59.018]     {
[13:19:59.018]         {
[13:19:59.018]             ...future.startTime <- base::Sys.time()
[13:19:59.018]             {
[13:19:59.018]                 {
[13:19:59.018]                   {
[13:19:59.018]                     {
[13:19:59.018]                       base::local({
[13:19:59.018]                         has_future <- base::requireNamespace("future", 
[13:19:59.018]                           quietly = TRUE)
[13:19:59.018]                         if (has_future) {
[13:19:59.018]                           ns <- base::getNamespace("future")
[13:19:59.018]                           version <- ns[[".package"]][["version"]]
[13:19:59.018]                           if (is.null(version)) 
[13:19:59.018]                             version <- utils::packageVersion("future")
[13:19:59.018]                         }
[13:19:59.018]                         else {
[13:19:59.018]                           version <- NULL
[13:19:59.018]                         }
[13:19:59.018]                         if (!has_future || version < "1.8.0") {
[13:19:59.018]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.018]                             "", base::R.version$version.string), 
[13:19:59.018]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.018]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.018]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.018]                               "release", "version")], collapse = " "), 
[13:19:59.018]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.018]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.018]                             info)
[13:19:59.018]                           info <- base::paste(info, collapse = "; ")
[13:19:59.018]                           if (!has_future) {
[13:19:59.018]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.018]                               info)
[13:19:59.018]                           }
[13:19:59.018]                           else {
[13:19:59.018]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.018]                               info, version)
[13:19:59.018]                           }
[13:19:59.018]                           base::stop(msg)
[13:19:59.018]                         }
[13:19:59.018]                       })
[13:19:59.018]                     }
[13:19:59.018]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.018]                     base::options(mc.cores = 1L)
[13:19:59.018]                   }
[13:19:59.018]                   options(future.plan = NULL)
[13:19:59.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.018]                 }
[13:19:59.018]                 ...future.workdir <- getwd()
[13:19:59.018]             }
[13:19:59.018]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.018]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.018]         }
[13:19:59.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:59.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.018]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.018]             base::names(...future.oldOptions))
[13:19:59.018]     }
[13:19:59.018]     if (FALSE) {
[13:19:59.018]     }
[13:19:59.018]     else {
[13:19:59.018]         if (TRUE) {
[13:19:59.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.018]                 open = "w")
[13:19:59.018]         }
[13:19:59.018]         else {
[13:19:59.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.018]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.018]         }
[13:19:59.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.018]             base::sink(type = "output", split = FALSE)
[13:19:59.018]             base::close(...future.stdout)
[13:19:59.018]         }, add = TRUE)
[13:19:59.018]     }
[13:19:59.018]     ...future.frame <- base::sys.nframe()
[13:19:59.018]     ...future.conditions <- base::list()
[13:19:59.018]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.018]     if (FALSE) {
[13:19:59.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.018]     }
[13:19:59.018]     ...future.result <- base::tryCatch({
[13:19:59.018]         base::withCallingHandlers({
[13:19:59.018]             ...future.value <- base::withVisible(base::local({
[13:19:59.018]                 withCallingHandlers({
[13:19:59.018]                   {
[13:19:59.018]                     do.call(function(...) {
[13:19:59.018]                       sum(x, ...)
[13:19:59.018]                     }, args = future.call.arguments)
[13:19:59.018]                   }
[13:19:59.018]                 }, immediateCondition = function(cond) {
[13:19:59.018]                   save_rds <- function (object, pathname, ...) 
[13:19:59.018]                   {
[13:19:59.018]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:59.018]                     if (file_test("-f", pathname_tmp)) {
[13:19:59.018]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.018]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:59.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.018]                         fi_tmp[["mtime"]])
[13:19:59.018]                     }
[13:19:59.018]                     tryCatch({
[13:19:59.018]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:59.018]                     }, error = function(ex) {
[13:19:59.018]                       msg <- conditionMessage(ex)
[13:19:59.018]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.018]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:59.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.018]                         fi_tmp[["mtime"]], msg)
[13:19:59.018]                       ex$message <- msg
[13:19:59.018]                       stop(ex)
[13:19:59.018]                     })
[13:19:59.018]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:59.018]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:59.018]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:59.018]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.018]                       fi <- file.info(pathname)
[13:19:59.018]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:59.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.018]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:59.018]                         fi[["size"]], fi[["mtime"]])
[13:19:59.018]                       stop(msg)
[13:19:59.018]                     }
[13:19:59.018]                     invisible(pathname)
[13:19:59.018]                   }
[13:19:59.018]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:59.018]                     rootPath = tempdir()) 
[13:19:59.018]                   {
[13:19:59.018]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:59.018]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:59.018]                       tmpdir = path, fileext = ".rds")
[13:19:59.018]                     save_rds(obj, file)
[13:19:59.018]                   }
[13:19:59.018]                   saveImmediateCondition(cond, path = "/tmp/RtmpMY5dtO/.future/immediateConditions")
[13:19:59.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.018]                   {
[13:19:59.018]                     inherits <- base::inherits
[13:19:59.018]                     invokeRestart <- base::invokeRestart
[13:19:59.018]                     is.null <- base::is.null
[13:19:59.018]                     muffled <- FALSE
[13:19:59.018]                     if (inherits(cond, "message")) {
[13:19:59.018]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.018]                       if (muffled) 
[13:19:59.018]                         invokeRestart("muffleMessage")
[13:19:59.018]                     }
[13:19:59.018]                     else if (inherits(cond, "warning")) {
[13:19:59.018]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.018]                       if (muffled) 
[13:19:59.018]                         invokeRestart("muffleWarning")
[13:19:59.018]                     }
[13:19:59.018]                     else if (inherits(cond, "condition")) {
[13:19:59.018]                       if (!is.null(pattern)) {
[13:19:59.018]                         computeRestarts <- base::computeRestarts
[13:19:59.018]                         grepl <- base::grepl
[13:19:59.018]                         restarts <- computeRestarts(cond)
[13:19:59.018]                         for (restart in restarts) {
[13:19:59.018]                           name <- restart$name
[13:19:59.018]                           if (is.null(name)) 
[13:19:59.018]                             next
[13:19:59.018]                           if (!grepl(pattern, name)) 
[13:19:59.018]                             next
[13:19:59.018]                           invokeRestart(restart)
[13:19:59.018]                           muffled <- TRUE
[13:19:59.018]                           break
[13:19:59.018]                         }
[13:19:59.018]                       }
[13:19:59.018]                     }
[13:19:59.018]                     invisible(muffled)
[13:19:59.018]                   }
[13:19:59.018]                   muffleCondition(cond)
[13:19:59.018]                 })
[13:19:59.018]             }))
[13:19:59.018]             future::FutureResult(value = ...future.value$value, 
[13:19:59.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.018]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.018]                     ...future.globalenv.names))
[13:19:59.018]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.018]         }, condition = base::local({
[13:19:59.018]             c <- base::c
[13:19:59.018]             inherits <- base::inherits
[13:19:59.018]             invokeRestart <- base::invokeRestart
[13:19:59.018]             length <- base::length
[13:19:59.018]             list <- base::list
[13:19:59.018]             seq.int <- base::seq.int
[13:19:59.018]             signalCondition <- base::signalCondition
[13:19:59.018]             sys.calls <- base::sys.calls
[13:19:59.018]             `[[` <- base::`[[`
[13:19:59.018]             `+` <- base::`+`
[13:19:59.018]             `<<-` <- base::`<<-`
[13:19:59.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.018]                   3L)]
[13:19:59.018]             }
[13:19:59.018]             function(cond) {
[13:19:59.018]                 is_error <- inherits(cond, "error")
[13:19:59.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.018]                   NULL)
[13:19:59.018]                 if (is_error) {
[13:19:59.018]                   sessionInformation <- function() {
[13:19:59.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.018]                       search = base::search(), system = base::Sys.info())
[13:19:59.018]                   }
[13:19:59.018]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.018]                     cond$call), session = sessionInformation(), 
[13:19:59.018]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.018]                   signalCondition(cond)
[13:19:59.018]                 }
[13:19:59.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.018]                 "immediateCondition"))) {
[13:19:59.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.018]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.018]                   if (TRUE && !signal) {
[13:19:59.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.018]                     {
[13:19:59.018]                       inherits <- base::inherits
[13:19:59.018]                       invokeRestart <- base::invokeRestart
[13:19:59.018]                       is.null <- base::is.null
[13:19:59.018]                       muffled <- FALSE
[13:19:59.018]                       if (inherits(cond, "message")) {
[13:19:59.018]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.018]                         if (muffled) 
[13:19:59.018]                           invokeRestart("muffleMessage")
[13:19:59.018]                       }
[13:19:59.018]                       else if (inherits(cond, "warning")) {
[13:19:59.018]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.018]                         if (muffled) 
[13:19:59.018]                           invokeRestart("muffleWarning")
[13:19:59.018]                       }
[13:19:59.018]                       else if (inherits(cond, "condition")) {
[13:19:59.018]                         if (!is.null(pattern)) {
[13:19:59.018]                           computeRestarts <- base::computeRestarts
[13:19:59.018]                           grepl <- base::grepl
[13:19:59.018]                           restarts <- computeRestarts(cond)
[13:19:59.018]                           for (restart in restarts) {
[13:19:59.018]                             name <- restart$name
[13:19:59.018]                             if (is.null(name)) 
[13:19:59.018]                               next
[13:19:59.018]                             if (!grepl(pattern, name)) 
[13:19:59.018]                               next
[13:19:59.018]                             invokeRestart(restart)
[13:19:59.018]                             muffled <- TRUE
[13:19:59.018]                             break
[13:19:59.018]                           }
[13:19:59.018]                         }
[13:19:59.018]                       }
[13:19:59.018]                       invisible(muffled)
[13:19:59.018]                     }
[13:19:59.018]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.018]                   }
[13:19:59.018]                 }
[13:19:59.018]                 else {
[13:19:59.018]                   if (TRUE) {
[13:19:59.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.018]                     {
[13:19:59.018]                       inherits <- base::inherits
[13:19:59.018]                       invokeRestart <- base::invokeRestart
[13:19:59.018]                       is.null <- base::is.null
[13:19:59.018]                       muffled <- FALSE
[13:19:59.018]                       if (inherits(cond, "message")) {
[13:19:59.018]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.018]                         if (muffled) 
[13:19:59.018]                           invokeRestart("muffleMessage")
[13:19:59.018]                       }
[13:19:59.018]                       else if (inherits(cond, "warning")) {
[13:19:59.018]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.018]                         if (muffled) 
[13:19:59.018]                           invokeRestart("muffleWarning")
[13:19:59.018]                       }
[13:19:59.018]                       else if (inherits(cond, "condition")) {
[13:19:59.018]                         if (!is.null(pattern)) {
[13:19:59.018]                           computeRestarts <- base::computeRestarts
[13:19:59.018]                           grepl <- base::grepl
[13:19:59.018]                           restarts <- computeRestarts(cond)
[13:19:59.018]                           for (restart in restarts) {
[13:19:59.018]                             name <- restart$name
[13:19:59.018]                             if (is.null(name)) 
[13:19:59.018]                               next
[13:19:59.018]                             if (!grepl(pattern, name)) 
[13:19:59.018]                               next
[13:19:59.018]                             invokeRestart(restart)
[13:19:59.018]                             muffled <- TRUE
[13:19:59.018]                             break
[13:19:59.018]                           }
[13:19:59.018]                         }
[13:19:59.018]                       }
[13:19:59.018]                       invisible(muffled)
[13:19:59.018]                     }
[13:19:59.018]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.018]                   }
[13:19:59.018]                 }
[13:19:59.018]             }
[13:19:59.018]         }))
[13:19:59.018]     }, error = function(ex) {
[13:19:59.018]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.018]                 ...future.rng), started = ...future.startTime, 
[13:19:59.018]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.018]             version = "1.8"), class = "FutureResult")
[13:19:59.018]     }, finally = {
[13:19:59.018]         if (!identical(...future.workdir, getwd())) 
[13:19:59.018]             setwd(...future.workdir)
[13:19:59.018]         {
[13:19:59.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.018]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.018]             }
[13:19:59.018]             base::options(...future.oldOptions)
[13:19:59.018]             if (.Platform$OS.type == "windows") {
[13:19:59.018]                 old_names <- names(...future.oldEnvVars)
[13:19:59.018]                 envs <- base::Sys.getenv()
[13:19:59.018]                 names <- names(envs)
[13:19:59.018]                 common <- intersect(names, old_names)
[13:19:59.018]                 added <- setdiff(names, old_names)
[13:19:59.018]                 removed <- setdiff(old_names, names)
[13:19:59.018]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.018]                   envs[common]]
[13:19:59.018]                 NAMES <- toupper(changed)
[13:19:59.018]                 args <- list()
[13:19:59.018]                 for (kk in seq_along(NAMES)) {
[13:19:59.018]                   name <- changed[[kk]]
[13:19:59.018]                   NAME <- NAMES[[kk]]
[13:19:59.018]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.018]                     next
[13:19:59.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.018]                 }
[13:19:59.018]                 NAMES <- toupper(added)
[13:19:59.018]                 for (kk in seq_along(NAMES)) {
[13:19:59.018]                   name <- added[[kk]]
[13:19:59.018]                   NAME <- NAMES[[kk]]
[13:19:59.018]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.018]                     next
[13:19:59.018]                   args[[name]] <- ""
[13:19:59.018]                 }
[13:19:59.018]                 NAMES <- toupper(removed)
[13:19:59.018]                 for (kk in seq_along(NAMES)) {
[13:19:59.018]                   name <- removed[[kk]]
[13:19:59.018]                   NAME <- NAMES[[kk]]
[13:19:59.018]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.018]                     next
[13:19:59.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.018]                 }
[13:19:59.018]                 if (length(args) > 0) 
[13:19:59.018]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.018]             }
[13:19:59.018]             else {
[13:19:59.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.018]             }
[13:19:59.018]             {
[13:19:59.018]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.018]                   0L) {
[13:19:59.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.018]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.018]                   base::options(opts)
[13:19:59.018]                 }
[13:19:59.018]                 {
[13:19:59.018]                   {
[13:19:59.018]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.018]                     NULL
[13:19:59.018]                   }
[13:19:59.018]                   options(future.plan = NULL)
[13:19:59.018]                   if (is.na(NA_character_)) 
[13:19:59.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.018]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:59.018]                     envir = parent.frame()) 
[13:19:59.018]                   {
[13:19:59.018]                     default_workers <- missing(workers)
[13:19:59.018]                     if (is.function(workers)) 
[13:19:59.018]                       workers <- workers()
[13:19:59.018]                     workers <- structure(as.integer(workers), 
[13:19:59.018]                       class = class(workers))
[13:19:59.018]                     stop_if_not(is.finite(workers), workers >= 
[13:19:59.018]                       1L)
[13:19:59.018]                     if ((workers == 1L && !inherits(workers, 
[13:19:59.018]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:59.018]                       if (default_workers) 
[13:19:59.018]                         supportsMulticore(warn = TRUE)
[13:19:59.018]                       return(sequential(..., envir = envir))
[13:19:59.018]                     }
[13:19:59.018]                     oopts <- options(mc.cores = workers)
[13:19:59.018]                     on.exit(options(oopts))
[13:19:59.018]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:59.018]                       envir = envir)
[13:19:59.018]                     if (!future$lazy) 
[13:19:59.018]                       future <- run(future)
[13:19:59.018]                     invisible(future)
[13:19:59.018]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.018]                 }
[13:19:59.018]             }
[13:19:59.018]         }
[13:19:59.018]     })
[13:19:59.018]     if (TRUE) {
[13:19:59.018]         base::sink(type = "output", split = FALSE)
[13:19:59.018]         if (TRUE) {
[13:19:59.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.018]         }
[13:19:59.018]         else {
[13:19:59.018]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.018]         }
[13:19:59.018]         base::close(...future.stdout)
[13:19:59.018]         ...future.stdout <- NULL
[13:19:59.018]     }
[13:19:59.018]     ...future.result$conditions <- ...future.conditions
[13:19:59.018]     ...future.result$finished <- base::Sys.time()
[13:19:59.018]     ...future.result
[13:19:59.018] }
[13:19:59.020] assign_globals() ...
[13:19:59.021] List of 2
[13:19:59.021]  $ x                    : int [1:2] 1 2
[13:19:59.021]  $ future.call.arguments:List of 1
[13:19:59.021]   ..$ : num 3
[13:19:59.021]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:59.021]  - attr(*, "where")=List of 2
[13:19:59.021]   ..$ x                    :<environment: R_EmptyEnv> 
[13:19:59.021]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[13:19:59.021]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.021]  - attr(*, "resolved")= logi FALSE
[13:19:59.021]  - attr(*, "total_size")= num 112
[13:19:59.021]  - attr(*, "already-done")= logi TRUE
[13:19:59.024] - copied ‘x’ to environment
[13:19:59.024] - copied ‘future.call.arguments’ to environment
[13:19:59.024] assign_globals() ... done
[13:19:59.024] requestCore(): workers = 2
[13:19:59.027] MulticoreFuture started
[13:19:59.028] - Launch lazy future ... done
[13:19:59.028] plan(): Setting new future strategy stack:
[13:19:59.028] run() for ‘MulticoreFuture’ ... done
[13:19:59.028] List of future strategies:
[13:19:59.028] 1. sequential:
[13:19:59.028]    - args: function (..., envir = parent.frame())
[13:19:59.028]    - tweaked: FALSE
[13:19:59.028]    - call: NULL
[13:19:59.029] plan(): nbrOfWorkers() = 1
[13:19:59.031] plan(): Setting new future strategy stack:
[13:19:59.031] List of future strategies:
[13:19:59.031] 1. multicore:
[13:19:59.031]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:59.031]    - tweaked: FALSE
[13:19:59.031]    - call: plan(strategy, substitute = FALSE)
[13:19:59.036] plan(): nbrOfWorkers() = 2
[1] 6
** Sum function 'B' with plan('multicore') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x56222593d7d0>
Arguments '...' exists: TRUE
[13:19:59.041] getGlobalsAndPackages() ...
[13:19:59.041] Searching for globals...
[13:19:59.043] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[13:19:59.043] Searching for globals ... DONE
[13:19:59.043] Resolving globals: FALSE
[13:19:59.044] Tweak future expression to call with '...' arguments ...
[13:19:59.044] {
[13:19:59.044]     do.call(function(...) {
[13:19:59.044]         sum(x, ...)
[13:19:59.044]     }, args = future.call.arguments)
[13:19:59.044] }
[13:19:59.044] Tweak future expression to call with '...' arguments ... DONE
[13:19:59.045] The total size of the 2 globals is 112 bytes (112 bytes)
[13:19:59.045] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[13:19:59.045] - globals: [2] ‘x’, ‘future.call.arguments’
[13:19:59.045] 
[13:19:59.045] getGlobalsAndPackages() ... DONE
[13:19:59.046] run() for ‘Future’ ...
[13:19:59.046] - state: ‘created’
[13:19:59.046] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.050] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.050] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:59.050]   - Field: ‘label’
[13:19:59.050]   - Field: ‘local’
[13:19:59.050]   - Field: ‘owner’
[13:19:59.051]   - Field: ‘envir’
[13:19:59.051]   - Field: ‘workers’
[13:19:59.051]   - Field: ‘packages’
[13:19:59.053]   - Field: ‘gc’
[13:19:59.054]   - Field: ‘job’
[13:19:59.054]   - Field: ‘conditions’
[13:19:59.054]   - Field: ‘expr’
[13:19:59.054]   - Field: ‘uuid’
[13:19:59.054]   - Field: ‘seed’
[13:19:59.054]   - Field: ‘version’
[13:19:59.054]   - Field: ‘result’
[13:19:59.054]   - Field: ‘asynchronous’
[13:19:59.055]   - Field: ‘calls’
[13:19:59.055]   - Field: ‘globals’
[13:19:59.055]   - Field: ‘stdout’
[13:19:59.055]   - Field: ‘earlySignal’
[13:19:59.055]   - Field: ‘lazy’
[13:19:59.055]   - Field: ‘state’
[13:19:59.055] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:59.056] - Launch lazy future ...
[13:19:59.056] Packages needed by the future expression (n = 0): <none>
[13:19:59.056] Packages needed by future strategies (n = 0): <none>
[13:19:59.057] {
[13:19:59.057]     {
[13:19:59.057]         {
[13:19:59.057]             ...future.startTime <- base::Sys.time()
[13:19:59.057]             {
[13:19:59.057]                 {
[13:19:59.057]                   {
[13:19:59.057]                     {
[13:19:59.057]                       base::local({
[13:19:59.057]                         has_future <- base::requireNamespace("future", 
[13:19:59.057]                           quietly = TRUE)
[13:19:59.057]                         if (has_future) {
[13:19:59.057]                           ns <- base::getNamespace("future")
[13:19:59.057]                           version <- ns[[".package"]][["version"]]
[13:19:59.057]                           if (is.null(version)) 
[13:19:59.057]                             version <- utils::packageVersion("future")
[13:19:59.057]                         }
[13:19:59.057]                         else {
[13:19:59.057]                           version <- NULL
[13:19:59.057]                         }
[13:19:59.057]                         if (!has_future || version < "1.8.0") {
[13:19:59.057]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.057]                             "", base::R.version$version.string), 
[13:19:59.057]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.057]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.057]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.057]                               "release", "version")], collapse = " "), 
[13:19:59.057]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.057]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.057]                             info)
[13:19:59.057]                           info <- base::paste(info, collapse = "; ")
[13:19:59.057]                           if (!has_future) {
[13:19:59.057]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.057]                               info)
[13:19:59.057]                           }
[13:19:59.057]                           else {
[13:19:59.057]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.057]                               info, version)
[13:19:59.057]                           }
[13:19:59.057]                           base::stop(msg)
[13:19:59.057]                         }
[13:19:59.057]                       })
[13:19:59.057]                     }
[13:19:59.057]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.057]                     base::options(mc.cores = 1L)
[13:19:59.057]                   }
[13:19:59.057]                   options(future.plan = NULL)
[13:19:59.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.057]                 }
[13:19:59.057]                 ...future.workdir <- getwd()
[13:19:59.057]             }
[13:19:59.057]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.057]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.057]         }
[13:19:59.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.057]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:59.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.057]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.057]             base::names(...future.oldOptions))
[13:19:59.057]     }
[13:19:59.057]     if (FALSE) {
[13:19:59.057]     }
[13:19:59.057]     else {
[13:19:59.057]         if (TRUE) {
[13:19:59.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.057]                 open = "w")
[13:19:59.057]         }
[13:19:59.057]         else {
[13:19:59.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.057]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.057]         }
[13:19:59.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.057]             base::sink(type = "output", split = FALSE)
[13:19:59.057]             base::close(...future.stdout)
[13:19:59.057]         }, add = TRUE)
[13:19:59.057]     }
[13:19:59.057]     ...future.frame <- base::sys.nframe()
[13:19:59.057]     ...future.conditions <- base::list()
[13:19:59.057]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.057]     if (FALSE) {
[13:19:59.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.057]     }
[13:19:59.057]     ...future.result <- base::tryCatch({
[13:19:59.057]         base::withCallingHandlers({
[13:19:59.057]             ...future.value <- base::withVisible(base::local({
[13:19:59.057]                 withCallingHandlers({
[13:19:59.057]                   {
[13:19:59.057]                     do.call(function(...) {
[13:19:59.057]                       sum(x, ...)
[13:19:59.057]                     }, args = future.call.arguments)
[13:19:59.057]                   }
[13:19:59.057]                 }, immediateCondition = function(cond) {
[13:19:59.057]                   save_rds <- function (object, pathname, ...) 
[13:19:59.057]                   {
[13:19:59.057]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:59.057]                     if (file_test("-f", pathname_tmp)) {
[13:19:59.057]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.057]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:59.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.057]                         fi_tmp[["mtime"]])
[13:19:59.057]                     }
[13:19:59.057]                     tryCatch({
[13:19:59.057]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:59.057]                     }, error = function(ex) {
[13:19:59.057]                       msg <- conditionMessage(ex)
[13:19:59.057]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.057]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:59.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.057]                         fi_tmp[["mtime"]], msg)
[13:19:59.057]                       ex$message <- msg
[13:19:59.057]                       stop(ex)
[13:19:59.057]                     })
[13:19:59.057]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:59.057]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:59.057]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:59.057]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.057]                       fi <- file.info(pathname)
[13:19:59.057]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:59.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.057]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:59.057]                         fi[["size"]], fi[["mtime"]])
[13:19:59.057]                       stop(msg)
[13:19:59.057]                     }
[13:19:59.057]                     invisible(pathname)
[13:19:59.057]                   }
[13:19:59.057]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:59.057]                     rootPath = tempdir()) 
[13:19:59.057]                   {
[13:19:59.057]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:59.057]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:59.057]                       tmpdir = path, fileext = ".rds")
[13:19:59.057]                     save_rds(obj, file)
[13:19:59.057]                   }
[13:19:59.057]                   saveImmediateCondition(cond, path = "/tmp/RtmpMY5dtO/.future/immediateConditions")
[13:19:59.057]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.057]                   {
[13:19:59.057]                     inherits <- base::inherits
[13:19:59.057]                     invokeRestart <- base::invokeRestart
[13:19:59.057]                     is.null <- base::is.null
[13:19:59.057]                     muffled <- FALSE
[13:19:59.057]                     if (inherits(cond, "message")) {
[13:19:59.057]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.057]                       if (muffled) 
[13:19:59.057]                         invokeRestart("muffleMessage")
[13:19:59.057]                     }
[13:19:59.057]                     else if (inherits(cond, "warning")) {
[13:19:59.057]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.057]                       if (muffled) 
[13:19:59.057]                         invokeRestart("muffleWarning")
[13:19:59.057]                     }
[13:19:59.057]                     else if (inherits(cond, "condition")) {
[13:19:59.057]                       if (!is.null(pattern)) {
[13:19:59.057]                         computeRestarts <- base::computeRestarts
[13:19:59.057]                         grepl <- base::grepl
[13:19:59.057]                         restarts <- computeRestarts(cond)
[13:19:59.057]                         for (restart in restarts) {
[13:19:59.057]                           name <- restart$name
[13:19:59.057]                           if (is.null(name)) 
[13:19:59.057]                             next
[13:19:59.057]                           if (!grepl(pattern, name)) 
[13:19:59.057]                             next
[13:19:59.057]                           invokeRestart(restart)
[13:19:59.057]                           muffled <- TRUE
[13:19:59.057]                           break
[13:19:59.057]                         }
[13:19:59.057]                       }
[13:19:59.057]                     }
[13:19:59.057]                     invisible(muffled)
[13:19:59.057]                   }
[13:19:59.057]                   muffleCondition(cond)
[13:19:59.057]                 })
[13:19:59.057]             }))
[13:19:59.057]             future::FutureResult(value = ...future.value$value, 
[13:19:59.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.057]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.057]                     ...future.globalenv.names))
[13:19:59.057]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.057]         }, condition = base::local({
[13:19:59.057]             c <- base::c
[13:19:59.057]             inherits <- base::inherits
[13:19:59.057]             invokeRestart <- base::invokeRestart
[13:19:59.057]             length <- base::length
[13:19:59.057]             list <- base::list
[13:19:59.057]             seq.int <- base::seq.int
[13:19:59.057]             signalCondition <- base::signalCondition
[13:19:59.057]             sys.calls <- base::sys.calls
[13:19:59.057]             `[[` <- base::`[[`
[13:19:59.057]             `+` <- base::`+`
[13:19:59.057]             `<<-` <- base::`<<-`
[13:19:59.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.057]                   3L)]
[13:19:59.057]             }
[13:19:59.057]             function(cond) {
[13:19:59.057]                 is_error <- inherits(cond, "error")
[13:19:59.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.057]                   NULL)
[13:19:59.057]                 if (is_error) {
[13:19:59.057]                   sessionInformation <- function() {
[13:19:59.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.057]                       search = base::search(), system = base::Sys.info())
[13:19:59.057]                   }
[13:19:59.057]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.057]                     cond$call), session = sessionInformation(), 
[13:19:59.057]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.057]                   signalCondition(cond)
[13:19:59.057]                 }
[13:19:59.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.057]                 "immediateCondition"))) {
[13:19:59.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.057]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.057]                   if (TRUE && !signal) {
[13:19:59.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.057]                     {
[13:19:59.057]                       inherits <- base::inherits
[13:19:59.057]                       invokeRestart <- base::invokeRestart
[13:19:59.057]                       is.null <- base::is.null
[13:19:59.057]                       muffled <- FALSE
[13:19:59.057]                       if (inherits(cond, "message")) {
[13:19:59.057]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.057]                         if (muffled) 
[13:19:59.057]                           invokeRestart("muffleMessage")
[13:19:59.057]                       }
[13:19:59.057]                       else if (inherits(cond, "warning")) {
[13:19:59.057]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.057]                         if (muffled) 
[13:19:59.057]                           invokeRestart("muffleWarning")
[13:19:59.057]                       }
[13:19:59.057]                       else if (inherits(cond, "condition")) {
[13:19:59.057]                         if (!is.null(pattern)) {
[13:19:59.057]                           computeRestarts <- base::computeRestarts
[13:19:59.057]                           grepl <- base::grepl
[13:19:59.057]                           restarts <- computeRestarts(cond)
[13:19:59.057]                           for (restart in restarts) {
[13:19:59.057]                             name <- restart$name
[13:19:59.057]                             if (is.null(name)) 
[13:19:59.057]                               next
[13:19:59.057]                             if (!grepl(pattern, name)) 
[13:19:59.057]                               next
[13:19:59.057]                             invokeRestart(restart)
[13:19:59.057]                             muffled <- TRUE
[13:19:59.057]                             break
[13:19:59.057]                           }
[13:19:59.057]                         }
[13:19:59.057]                       }
[13:19:59.057]                       invisible(muffled)
[13:19:59.057]                     }
[13:19:59.057]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.057]                   }
[13:19:59.057]                 }
[13:19:59.057]                 else {
[13:19:59.057]                   if (TRUE) {
[13:19:59.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.057]                     {
[13:19:59.057]                       inherits <- base::inherits
[13:19:59.057]                       invokeRestart <- base::invokeRestart
[13:19:59.057]                       is.null <- base::is.null
[13:19:59.057]                       muffled <- FALSE
[13:19:59.057]                       if (inherits(cond, "message")) {
[13:19:59.057]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.057]                         if (muffled) 
[13:19:59.057]                           invokeRestart("muffleMessage")
[13:19:59.057]                       }
[13:19:59.057]                       else if (inherits(cond, "warning")) {
[13:19:59.057]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.057]                         if (muffled) 
[13:19:59.057]                           invokeRestart("muffleWarning")
[13:19:59.057]                       }
[13:19:59.057]                       else if (inherits(cond, "condition")) {
[13:19:59.057]                         if (!is.null(pattern)) {
[13:19:59.057]                           computeRestarts <- base::computeRestarts
[13:19:59.057]                           grepl <- base::grepl
[13:19:59.057]                           restarts <- computeRestarts(cond)
[13:19:59.057]                           for (restart in restarts) {
[13:19:59.057]                             name <- restart$name
[13:19:59.057]                             if (is.null(name)) 
[13:19:59.057]                               next
[13:19:59.057]                             if (!grepl(pattern, name)) 
[13:19:59.057]                               next
[13:19:59.057]                             invokeRestart(restart)
[13:19:59.057]                             muffled <- TRUE
[13:19:59.057]                             break
[13:19:59.057]                           }
[13:19:59.057]                         }
[13:19:59.057]                       }
[13:19:59.057]                       invisible(muffled)
[13:19:59.057]                     }
[13:19:59.057]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.057]                   }
[13:19:59.057]                 }
[13:19:59.057]             }
[13:19:59.057]         }))
[13:19:59.057]     }, error = function(ex) {
[13:19:59.057]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.057]                 ...future.rng), started = ...future.startTime, 
[13:19:59.057]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.057]             version = "1.8"), class = "FutureResult")
[13:19:59.057]     }, finally = {
[13:19:59.057]         if (!identical(...future.workdir, getwd())) 
[13:19:59.057]             setwd(...future.workdir)
[13:19:59.057]         {
[13:19:59.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.057]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.057]             }
[13:19:59.057]             base::options(...future.oldOptions)
[13:19:59.057]             if (.Platform$OS.type == "windows") {
[13:19:59.057]                 old_names <- names(...future.oldEnvVars)
[13:19:59.057]                 envs <- base::Sys.getenv()
[13:19:59.057]                 names <- names(envs)
[13:19:59.057]                 common <- intersect(names, old_names)
[13:19:59.057]                 added <- setdiff(names, old_names)
[13:19:59.057]                 removed <- setdiff(old_names, names)
[13:19:59.057]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.057]                   envs[common]]
[13:19:59.057]                 NAMES <- toupper(changed)
[13:19:59.057]                 args <- list()
[13:19:59.057]                 for (kk in seq_along(NAMES)) {
[13:19:59.057]                   name <- changed[[kk]]
[13:19:59.057]                   NAME <- NAMES[[kk]]
[13:19:59.057]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.057]                     next
[13:19:59.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.057]                 }
[13:19:59.057]                 NAMES <- toupper(added)
[13:19:59.057]                 for (kk in seq_along(NAMES)) {
[13:19:59.057]                   name <- added[[kk]]
[13:19:59.057]                   NAME <- NAMES[[kk]]
[13:19:59.057]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.057]                     next
[13:19:59.057]                   args[[name]] <- ""
[13:19:59.057]                 }
[13:19:59.057]                 NAMES <- toupper(removed)
[13:19:59.057]                 for (kk in seq_along(NAMES)) {
[13:19:59.057]                   name <- removed[[kk]]
[13:19:59.057]                   NAME <- NAMES[[kk]]
[13:19:59.057]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.057]                     next
[13:19:59.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.057]                 }
[13:19:59.057]                 if (length(args) > 0) 
[13:19:59.057]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.057]             }
[13:19:59.057]             else {
[13:19:59.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.057]             }
[13:19:59.057]             {
[13:19:59.057]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.057]                   0L) {
[13:19:59.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.057]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.057]                   base::options(opts)
[13:19:59.057]                 }
[13:19:59.057]                 {
[13:19:59.057]                   {
[13:19:59.057]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.057]                     NULL
[13:19:59.057]                   }
[13:19:59.057]                   options(future.plan = NULL)
[13:19:59.057]                   if (is.na(NA_character_)) 
[13:19:59.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.057]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:59.057]                     envir = parent.frame()) 
[13:19:59.057]                   {
[13:19:59.057]                     default_workers <- missing(workers)
[13:19:59.057]                     if (is.function(workers)) 
[13:19:59.057]                       workers <- workers()
[13:19:59.057]                     workers <- structure(as.integer(workers), 
[13:19:59.057]                       class = class(workers))
[13:19:59.057]                     stop_if_not(is.finite(workers), workers >= 
[13:19:59.057]                       1L)
[13:19:59.057]                     if ((workers == 1L && !inherits(workers, 
[13:19:59.057]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:59.057]                       if (default_workers) 
[13:19:59.057]                         supportsMulticore(warn = TRUE)
[13:19:59.057]                       return(sequential(..., envir = envir))
[13:19:59.057]                     }
[13:19:59.057]                     oopts <- options(mc.cores = workers)
[13:19:59.057]                     on.exit(options(oopts))
[13:19:59.057]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:59.057]                       envir = envir)
[13:19:59.057]                     if (!future$lazy) 
[13:19:59.057]                       future <- run(future)
[13:19:59.057]                     invisible(future)
[13:19:59.057]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.057]                 }
[13:19:59.057]             }
[13:19:59.057]         }
[13:19:59.057]     })
[13:19:59.057]     if (TRUE) {
[13:19:59.057]         base::sink(type = "output", split = FALSE)
[13:19:59.057]         if (TRUE) {
[13:19:59.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.057]         }
[13:19:59.057]         else {
[13:19:59.057]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.057]         }
[13:19:59.057]         base::close(...future.stdout)
[13:19:59.057]         ...future.stdout <- NULL
[13:19:59.057]     }
[13:19:59.057]     ...future.result$conditions <- ...future.conditions
[13:19:59.057]     ...future.result$finished <- base::Sys.time()
[13:19:59.057]     ...future.result
[13:19:59.057] }
[13:19:59.059] assign_globals() ...
[13:19:59.059] List of 2
[13:19:59.059]  $ x                    : int [1:2] 1 2
[13:19:59.059]  $ future.call.arguments:List of 1
[13:19:59.059]   ..$ : num 3
[13:19:59.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:59.059]  - attr(*, "where")=List of 2
[13:19:59.059]   ..$ x                    :<environment: R_EmptyEnv> 
[13:19:59.059]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[13:19:59.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.059]  - attr(*, "resolved")= logi FALSE
[13:19:59.059]  - attr(*, "total_size")= num 112
[13:19:59.059]  - attr(*, "already-done")= logi TRUE
[13:19:59.064] - copied ‘x’ to environment
[13:19:59.064] - copied ‘future.call.arguments’ to environment
[13:19:59.064] assign_globals() ... done
[13:19:59.064] requestCore(): workers = 2
[13:19:59.066] MulticoreFuture started
[13:19:59.066] - Launch lazy future ... done
[13:19:59.067] run() for ‘MulticoreFuture’ ... done
[13:19:59.067] plan(): Setting new future strategy stack:
[13:19:59.067] List of future strategies:
[13:19:59.067] 1. sequential:
[13:19:59.067]    - args: function (..., envir = parent.frame())
[13:19:59.067]    - tweaked: FALSE
[13:19:59.067]    - call: NULL
[13:19:59.068] plan(): nbrOfWorkers() = 1
[13:19:59.070] plan(): Setting new future strategy stack:
[13:19:59.070] List of future strategies:
[13:19:59.070] 1. multicore:
[13:19:59.070]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:59.070]    - tweaked: FALSE
[13:19:59.070]    - call: plan(strategy, substitute = FALSE)
[13:19:59.075] plan(): nbrOfWorkers() = 2
[1] 6
** Sum function 'C' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x562225ab6848>
Arguments '...' exists: FALSE
[13:19:59.077] getGlobalsAndPackages() ...
[13:19:59.077] Searching for globals...
[13:19:59.079] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[13:19:59.079] Searching for globals ... DONE
[13:19:59.079] Resolving globals: FALSE
[13:19:59.080] The total size of the 2 globals is 112 bytes (112 bytes)
[13:19:59.080] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[13:19:59.080] - globals: [2] ‘x’, ‘y’
[13:19:59.080] 
[13:19:59.081] getGlobalsAndPackages() ... DONE
[13:19:59.081] run() for ‘Future’ ...
[13:19:59.081] - state: ‘created’
[13:19:59.081] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.085] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.085] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:59.085]   - Field: ‘label’
[13:19:59.086]   - Field: ‘local’
[13:19:59.086]   - Field: ‘owner’
[13:19:59.086]   - Field: ‘envir’
[13:19:59.086]   - Field: ‘workers’
[13:19:59.086]   - Field: ‘packages’
[13:19:59.086]   - Field: ‘gc’
[13:19:59.086]   - Field: ‘job’
[13:19:59.086]   - Field: ‘conditions’
[13:19:59.087]   - Field: ‘expr’
[13:19:59.087]   - Field: ‘uuid’
[13:19:59.087]   - Field: ‘seed’
[13:19:59.087]   - Field: ‘version’
[13:19:59.087]   - Field: ‘result’
[13:19:59.087]   - Field: ‘asynchronous’
[13:19:59.087]   - Field: ‘calls’
[13:19:59.087]   - Field: ‘globals’
[13:19:59.087]   - Field: ‘stdout’
[13:19:59.088]   - Field: ‘earlySignal’
[13:19:59.088]   - Field: ‘lazy’
[13:19:59.088]   - Field: ‘state’
[13:19:59.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:59.088] - Launch lazy future ...
[13:19:59.088] Packages needed by the future expression (n = 0): <none>
[13:19:59.089] Packages needed by future strategies (n = 0): <none>
[13:19:59.089] {
[13:19:59.089]     {
[13:19:59.089]         {
[13:19:59.089]             ...future.startTime <- base::Sys.time()
[13:19:59.089]             {
[13:19:59.089]                 {
[13:19:59.089]                   {
[13:19:59.089]                     {
[13:19:59.089]                       base::local({
[13:19:59.089]                         has_future <- base::requireNamespace("future", 
[13:19:59.089]                           quietly = TRUE)
[13:19:59.089]                         if (has_future) {
[13:19:59.089]                           ns <- base::getNamespace("future")
[13:19:59.089]                           version <- ns[[".package"]][["version"]]
[13:19:59.089]                           if (is.null(version)) 
[13:19:59.089]                             version <- utils::packageVersion("future")
[13:19:59.089]                         }
[13:19:59.089]                         else {
[13:19:59.089]                           version <- NULL
[13:19:59.089]                         }
[13:19:59.089]                         if (!has_future || version < "1.8.0") {
[13:19:59.089]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.089]                             "", base::R.version$version.string), 
[13:19:59.089]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.089]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.089]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.089]                               "release", "version")], collapse = " "), 
[13:19:59.089]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.089]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.089]                             info)
[13:19:59.089]                           info <- base::paste(info, collapse = "; ")
[13:19:59.089]                           if (!has_future) {
[13:19:59.089]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.089]                               info)
[13:19:59.089]                           }
[13:19:59.089]                           else {
[13:19:59.089]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.089]                               info, version)
[13:19:59.089]                           }
[13:19:59.089]                           base::stop(msg)
[13:19:59.089]                         }
[13:19:59.089]                       })
[13:19:59.089]                     }
[13:19:59.089]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.089]                     base::options(mc.cores = 1L)
[13:19:59.089]                   }
[13:19:59.089]                   options(future.plan = NULL)
[13:19:59.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.089]                 }
[13:19:59.089]                 ...future.workdir <- getwd()
[13:19:59.089]             }
[13:19:59.089]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.089]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.089]         }
[13:19:59.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.089]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:59.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.089]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.089]             base::names(...future.oldOptions))
[13:19:59.089]     }
[13:19:59.089]     if (FALSE) {
[13:19:59.089]     }
[13:19:59.089]     else {
[13:19:59.089]         if (TRUE) {
[13:19:59.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.089]                 open = "w")
[13:19:59.089]         }
[13:19:59.089]         else {
[13:19:59.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.089]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.089]         }
[13:19:59.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.089]             base::sink(type = "output", split = FALSE)
[13:19:59.089]             base::close(...future.stdout)
[13:19:59.089]         }, add = TRUE)
[13:19:59.089]     }
[13:19:59.089]     ...future.frame <- base::sys.nframe()
[13:19:59.089]     ...future.conditions <- base::list()
[13:19:59.089]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.089]     if (FALSE) {
[13:19:59.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.089]     }
[13:19:59.089]     ...future.result <- base::tryCatch({
[13:19:59.089]         base::withCallingHandlers({
[13:19:59.089]             ...future.value <- base::withVisible(base::local({
[13:19:59.089]                 withCallingHandlers({
[13:19:59.089]                   {
[13:19:59.089]                     sum(x, y)
[13:19:59.089]                   }
[13:19:59.089]                 }, immediateCondition = function(cond) {
[13:19:59.089]                   save_rds <- function (object, pathname, ...) 
[13:19:59.089]                   {
[13:19:59.089]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:59.089]                     if (file_test("-f", pathname_tmp)) {
[13:19:59.089]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.089]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:59.089]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.089]                         fi_tmp[["mtime"]])
[13:19:59.089]                     }
[13:19:59.089]                     tryCatch({
[13:19:59.089]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:59.089]                     }, error = function(ex) {
[13:19:59.089]                       msg <- conditionMessage(ex)
[13:19:59.089]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.089]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:59.089]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.089]                         fi_tmp[["mtime"]], msg)
[13:19:59.089]                       ex$message <- msg
[13:19:59.089]                       stop(ex)
[13:19:59.089]                     })
[13:19:59.089]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:59.089]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:59.089]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:59.089]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.089]                       fi <- file.info(pathname)
[13:19:59.089]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:59.089]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.089]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:59.089]                         fi[["size"]], fi[["mtime"]])
[13:19:59.089]                       stop(msg)
[13:19:59.089]                     }
[13:19:59.089]                     invisible(pathname)
[13:19:59.089]                   }
[13:19:59.089]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:59.089]                     rootPath = tempdir()) 
[13:19:59.089]                   {
[13:19:59.089]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:59.089]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:59.089]                       tmpdir = path, fileext = ".rds")
[13:19:59.089]                     save_rds(obj, file)
[13:19:59.089]                   }
[13:19:59.089]                   saveImmediateCondition(cond, path = "/tmp/RtmpMY5dtO/.future/immediateConditions")
[13:19:59.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.089]                   {
[13:19:59.089]                     inherits <- base::inherits
[13:19:59.089]                     invokeRestart <- base::invokeRestart
[13:19:59.089]                     is.null <- base::is.null
[13:19:59.089]                     muffled <- FALSE
[13:19:59.089]                     if (inherits(cond, "message")) {
[13:19:59.089]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.089]                       if (muffled) 
[13:19:59.089]                         invokeRestart("muffleMessage")
[13:19:59.089]                     }
[13:19:59.089]                     else if (inherits(cond, "warning")) {
[13:19:59.089]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.089]                       if (muffled) 
[13:19:59.089]                         invokeRestart("muffleWarning")
[13:19:59.089]                     }
[13:19:59.089]                     else if (inherits(cond, "condition")) {
[13:19:59.089]                       if (!is.null(pattern)) {
[13:19:59.089]                         computeRestarts <- base::computeRestarts
[13:19:59.089]                         grepl <- base::grepl
[13:19:59.089]                         restarts <- computeRestarts(cond)
[13:19:59.089]                         for (restart in restarts) {
[13:19:59.089]                           name <- restart$name
[13:19:59.089]                           if (is.null(name)) 
[13:19:59.089]                             next
[13:19:59.089]                           if (!grepl(pattern, name)) 
[13:19:59.089]                             next
[13:19:59.089]                           invokeRestart(restart)
[13:19:59.089]                           muffled <- TRUE
[13:19:59.089]                           break
[13:19:59.089]                         }
[13:19:59.089]                       }
[13:19:59.089]                     }
[13:19:59.089]                     invisible(muffled)
[13:19:59.089]                   }
[13:19:59.089]                   muffleCondition(cond)
[13:19:59.089]                 })
[13:19:59.089]             }))
[13:19:59.089]             future::FutureResult(value = ...future.value$value, 
[13:19:59.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.089]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.089]                     ...future.globalenv.names))
[13:19:59.089]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.089]         }, condition = base::local({
[13:19:59.089]             c <- base::c
[13:19:59.089]             inherits <- base::inherits
[13:19:59.089]             invokeRestart <- base::invokeRestart
[13:19:59.089]             length <- base::length
[13:19:59.089]             list <- base::list
[13:19:59.089]             seq.int <- base::seq.int
[13:19:59.089]             signalCondition <- base::signalCondition
[13:19:59.089]             sys.calls <- base::sys.calls
[13:19:59.089]             `[[` <- base::`[[`
[13:19:59.089]             `+` <- base::`+`
[13:19:59.089]             `<<-` <- base::`<<-`
[13:19:59.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.089]                   3L)]
[13:19:59.089]             }
[13:19:59.089]             function(cond) {
[13:19:59.089]                 is_error <- inherits(cond, "error")
[13:19:59.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.089]                   NULL)
[13:19:59.089]                 if (is_error) {
[13:19:59.089]                   sessionInformation <- function() {
[13:19:59.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.089]                       search = base::search(), system = base::Sys.info())
[13:19:59.089]                   }
[13:19:59.089]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.089]                     cond$call), session = sessionInformation(), 
[13:19:59.089]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.089]                   signalCondition(cond)
[13:19:59.089]                 }
[13:19:59.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.089]                 "immediateCondition"))) {
[13:19:59.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.089]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.089]                   if (TRUE && !signal) {
[13:19:59.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.089]                     {
[13:19:59.089]                       inherits <- base::inherits
[13:19:59.089]                       invokeRestart <- base::invokeRestart
[13:19:59.089]                       is.null <- base::is.null
[13:19:59.089]                       muffled <- FALSE
[13:19:59.089]                       if (inherits(cond, "message")) {
[13:19:59.089]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.089]                         if (muffled) 
[13:19:59.089]                           invokeRestart("muffleMessage")
[13:19:59.089]                       }
[13:19:59.089]                       else if (inherits(cond, "warning")) {
[13:19:59.089]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.089]                         if (muffled) 
[13:19:59.089]                           invokeRestart("muffleWarning")
[13:19:59.089]                       }
[13:19:59.089]                       else if (inherits(cond, "condition")) {
[13:19:59.089]                         if (!is.null(pattern)) {
[13:19:59.089]                           computeRestarts <- base::computeRestarts
[13:19:59.089]                           grepl <- base::grepl
[13:19:59.089]                           restarts <- computeRestarts(cond)
[13:19:59.089]                           for (restart in restarts) {
[13:19:59.089]                             name <- restart$name
[13:19:59.089]                             if (is.null(name)) 
[13:19:59.089]                               next
[13:19:59.089]                             if (!grepl(pattern, name)) 
[13:19:59.089]                               next
[13:19:59.089]                             invokeRestart(restart)
[13:19:59.089]                             muffled <- TRUE
[13:19:59.089]                             break
[13:19:59.089]                           }
[13:19:59.089]                         }
[13:19:59.089]                       }
[13:19:59.089]                       invisible(muffled)
[13:19:59.089]                     }
[13:19:59.089]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.089]                   }
[13:19:59.089]                 }
[13:19:59.089]                 else {
[13:19:59.089]                   if (TRUE) {
[13:19:59.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.089]                     {
[13:19:59.089]                       inherits <- base::inherits
[13:19:59.089]                       invokeRestart <- base::invokeRestart
[13:19:59.089]                       is.null <- base::is.null
[13:19:59.089]                       muffled <- FALSE
[13:19:59.089]                       if (inherits(cond, "message")) {
[13:19:59.089]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.089]                         if (muffled) 
[13:19:59.089]                           invokeRestart("muffleMessage")
[13:19:59.089]                       }
[13:19:59.089]                       else if (inherits(cond, "warning")) {
[13:19:59.089]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.089]                         if (muffled) 
[13:19:59.089]                           invokeRestart("muffleWarning")
[13:19:59.089]                       }
[13:19:59.089]                       else if (inherits(cond, "condition")) {
[13:19:59.089]                         if (!is.null(pattern)) {
[13:19:59.089]                           computeRestarts <- base::computeRestarts
[13:19:59.089]                           grepl <- base::grepl
[13:19:59.089]                           restarts <- computeRestarts(cond)
[13:19:59.089]                           for (restart in restarts) {
[13:19:59.089]                             name <- restart$name
[13:19:59.089]                             if (is.null(name)) 
[13:19:59.089]                               next
[13:19:59.089]                             if (!grepl(pattern, name)) 
[13:19:59.089]                               next
[13:19:59.089]                             invokeRestart(restart)
[13:19:59.089]                             muffled <- TRUE
[13:19:59.089]                             break
[13:19:59.089]                           }
[13:19:59.089]                         }
[13:19:59.089]                       }
[13:19:59.089]                       invisible(muffled)
[13:19:59.089]                     }
[13:19:59.089]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.089]                   }
[13:19:59.089]                 }
[13:19:59.089]             }
[13:19:59.089]         }))
[13:19:59.089]     }, error = function(ex) {
[13:19:59.089]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.089]                 ...future.rng), started = ...future.startTime, 
[13:19:59.089]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.089]             version = "1.8"), class = "FutureResult")
[13:19:59.089]     }, finally = {
[13:19:59.089]         if (!identical(...future.workdir, getwd())) 
[13:19:59.089]             setwd(...future.workdir)
[13:19:59.089]         {
[13:19:59.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.089]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.089]             }
[13:19:59.089]             base::options(...future.oldOptions)
[13:19:59.089]             if (.Platform$OS.type == "windows") {
[13:19:59.089]                 old_names <- names(...future.oldEnvVars)
[13:19:59.089]                 envs <- base::Sys.getenv()
[13:19:59.089]                 names <- names(envs)
[13:19:59.089]                 common <- intersect(names, old_names)
[13:19:59.089]                 added <- setdiff(names, old_names)
[13:19:59.089]                 removed <- setdiff(old_names, names)
[13:19:59.089]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.089]                   envs[common]]
[13:19:59.089]                 NAMES <- toupper(changed)
[13:19:59.089]                 args <- list()
[13:19:59.089]                 for (kk in seq_along(NAMES)) {
[13:19:59.089]                   name <- changed[[kk]]
[13:19:59.089]                   NAME <- NAMES[[kk]]
[13:19:59.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.089]                     next
[13:19:59.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.089]                 }
[13:19:59.089]                 NAMES <- toupper(added)
[13:19:59.089]                 for (kk in seq_along(NAMES)) {
[13:19:59.089]                   name <- added[[kk]]
[13:19:59.089]                   NAME <- NAMES[[kk]]
[13:19:59.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.089]                     next
[13:19:59.089]                   args[[name]] <- ""
[13:19:59.089]                 }
[13:19:59.089]                 NAMES <- toupper(removed)
[13:19:59.089]                 for (kk in seq_along(NAMES)) {
[13:19:59.089]                   name <- removed[[kk]]
[13:19:59.089]                   NAME <- NAMES[[kk]]
[13:19:59.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.089]                     next
[13:19:59.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.089]                 }
[13:19:59.089]                 if (length(args) > 0) 
[13:19:59.089]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.089]             }
[13:19:59.089]             else {
[13:19:59.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.089]             }
[13:19:59.089]             {
[13:19:59.089]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.089]                   0L) {
[13:19:59.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.089]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.089]                   base::options(opts)
[13:19:59.089]                 }
[13:19:59.089]                 {
[13:19:59.089]                   {
[13:19:59.089]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.089]                     NULL
[13:19:59.089]                   }
[13:19:59.089]                   options(future.plan = NULL)
[13:19:59.089]                   if (is.na(NA_character_)) 
[13:19:59.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.089]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:59.089]                     envir = parent.frame()) 
[13:19:59.089]                   {
[13:19:59.089]                     default_workers <- missing(workers)
[13:19:59.089]                     if (is.function(workers)) 
[13:19:59.089]                       workers <- workers()
[13:19:59.089]                     workers <- structure(as.integer(workers), 
[13:19:59.089]                       class = class(workers))
[13:19:59.089]                     stop_if_not(is.finite(workers), workers >= 
[13:19:59.089]                       1L)
[13:19:59.089]                     if ((workers == 1L && !inherits(workers, 
[13:19:59.089]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:59.089]                       if (default_workers) 
[13:19:59.089]                         supportsMulticore(warn = TRUE)
[13:19:59.089]                       return(sequential(..., envir = envir))
[13:19:59.089]                     }
[13:19:59.089]                     oopts <- options(mc.cores = workers)
[13:19:59.089]                     on.exit(options(oopts))
[13:19:59.089]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:59.089]                       envir = envir)
[13:19:59.089]                     if (!future$lazy) 
[13:19:59.089]                       future <- run(future)
[13:19:59.089]                     invisible(future)
[13:19:59.089]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.089]                 }
[13:19:59.089]             }
[13:19:59.089]         }
[13:19:59.089]     })
[13:19:59.089]     if (TRUE) {
[13:19:59.089]         base::sink(type = "output", split = FALSE)
[13:19:59.089]         if (TRUE) {
[13:19:59.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.089]         }
[13:19:59.089]         else {
[13:19:59.089]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.089]         }
[13:19:59.089]         base::close(...future.stdout)
[13:19:59.089]         ...future.stdout <- NULL
[13:19:59.089]     }
[13:19:59.089]     ...future.result$conditions <- ...future.conditions
[13:19:59.089]     ...future.result$finished <- base::Sys.time()
[13:19:59.089]     ...future.result
[13:19:59.089] }
[13:19:59.092] assign_globals() ...
[13:19:59.092] List of 2
[13:19:59.092]  $ x: int [1:2] 1 2
[13:19:59.092]  $ y: num 3
[13:19:59.092]  - attr(*, "where")=List of 2
[13:19:59.092]   ..$ x:<environment: R_EmptyEnv> 
[13:19:59.092]   ..$ y:<environment: R_EmptyEnv> 
[13:19:59.092]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.092]  - attr(*, "resolved")= logi FALSE
[13:19:59.092]  - attr(*, "total_size")= num 112
[13:19:59.092]  - attr(*, "already-done")= logi TRUE
[13:19:59.096] - copied ‘x’ to environment
[13:19:59.096] - copied ‘y’ to environment
[13:19:59.096] assign_globals() ... done
[13:19:59.096] requestCore(): workers = 2
[13:19:59.098] MulticoreFuture started
[13:19:59.098] - Launch lazy future ... done
[13:19:59.098] run() for ‘MulticoreFuture’ ... done
[13:19:59.099] plan(): Setting new future strategy stack:
[13:19:59.099] List of future strategies:
[13:19:59.099] 1. sequential:
[13:19:59.099]    - args: function (..., envir = parent.frame())
[13:19:59.099]    - tweaked: FALSE
[13:19:59.099]    - call: NULL
[13:19:59.100] plan(): nbrOfWorkers() = 1
[13:19:59.102] plan(): Setting new future strategy stack:
[13:19:59.102] List of future strategies:
[13:19:59.102] 1. multicore:
[13:19:59.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:59.102]    - tweaked: FALSE
[13:19:59.102]    - call: plan(strategy, substitute = FALSE)
[13:19:59.107] plan(): nbrOfWorkers() = 2
[1] 6
** Sum function 'D' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x562223c69dc0>
Arguments '...' exists: FALSE
[13:19:59.109] getGlobalsAndPackages() ...
[13:19:59.109] Searching for globals...
[13:19:59.111] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[13:19:59.111] Searching for globals ... DONE
[13:19:59.111] Resolving globals: FALSE
[13:19:59.112] Tweak future expression to call with '...' arguments ...
[13:19:59.112] The total size of the 2 globals is 112 bytes (112 bytes)
[13:19:59.113] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[13:19:59.115] - globals: [2] ‘x’, ‘y’
[13:19:59.115] 
[13:19:59.115] getGlobalsAndPackages() ... DONE
[13:19:59.116] run() for ‘Future’ ...
[13:19:59.116] - state: ‘created’
[13:19:59.116] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.120] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.121] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:59.121]   - Field: ‘label’
[13:19:59.121]   - Field: ‘local’
[13:19:59.121]   - Field: ‘owner’
[13:19:59.121]   - Field: ‘envir’
[13:19:59.121]   - Field: ‘workers’
[13:19:59.121]   - Field: ‘packages’
[13:19:59.122]   - Field: ‘gc’
[13:19:59.122]   - Field: ‘job’
[13:19:59.122]   - Field: ‘conditions’
[13:19:59.122]   - Field: ‘expr’
[13:19:59.122]   - Field: ‘uuid’
[13:19:59.122]   - Field: ‘seed’
[13:19:59.122]   - Field: ‘version’
[13:19:59.122]   - Field: ‘result’
[13:19:59.123]   - Field: ‘asynchronous’
[13:19:59.123]   - Field: ‘calls’
[13:19:59.123]   - Field: ‘globals’
[13:19:59.123]   - Field: ‘stdout’
[13:19:59.123]   - Field: ‘earlySignal’
[13:19:59.123]   - Field: ‘lazy’
[13:19:59.123]   - Field: ‘state’
[13:19:59.123] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:59.124] - Launch lazy future ...
[13:19:59.124] Packages needed by the future expression (n = 0): <none>
[13:19:59.124] Packages needed by future strategies (n = 0): <none>
[13:19:59.125] {
[13:19:59.125]     {
[13:19:59.125]         {
[13:19:59.125]             ...future.startTime <- base::Sys.time()
[13:19:59.125]             {
[13:19:59.125]                 {
[13:19:59.125]                   {
[13:19:59.125]                     {
[13:19:59.125]                       base::local({
[13:19:59.125]                         has_future <- base::requireNamespace("future", 
[13:19:59.125]                           quietly = TRUE)
[13:19:59.125]                         if (has_future) {
[13:19:59.125]                           ns <- base::getNamespace("future")
[13:19:59.125]                           version <- ns[[".package"]][["version"]]
[13:19:59.125]                           if (is.null(version)) 
[13:19:59.125]                             version <- utils::packageVersion("future")
[13:19:59.125]                         }
[13:19:59.125]                         else {
[13:19:59.125]                           version <- NULL
[13:19:59.125]                         }
[13:19:59.125]                         if (!has_future || version < "1.8.0") {
[13:19:59.125]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.125]                             "", base::R.version$version.string), 
[13:19:59.125]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.125]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.125]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.125]                               "release", "version")], collapse = " "), 
[13:19:59.125]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.125]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.125]                             info)
[13:19:59.125]                           info <- base::paste(info, collapse = "; ")
[13:19:59.125]                           if (!has_future) {
[13:19:59.125]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.125]                               info)
[13:19:59.125]                           }
[13:19:59.125]                           else {
[13:19:59.125]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.125]                               info, version)
[13:19:59.125]                           }
[13:19:59.125]                           base::stop(msg)
[13:19:59.125]                         }
[13:19:59.125]                       })
[13:19:59.125]                     }
[13:19:59.125]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.125]                     base::options(mc.cores = 1L)
[13:19:59.125]                   }
[13:19:59.125]                   options(future.plan = NULL)
[13:19:59.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.125]                 }
[13:19:59.125]                 ...future.workdir <- getwd()
[13:19:59.125]             }
[13:19:59.125]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.125]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.125]         }
[13:19:59.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.125]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:59.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.125]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.125]             base::names(...future.oldOptions))
[13:19:59.125]     }
[13:19:59.125]     if (FALSE) {
[13:19:59.125]     }
[13:19:59.125]     else {
[13:19:59.125]         if (TRUE) {
[13:19:59.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.125]                 open = "w")
[13:19:59.125]         }
[13:19:59.125]         else {
[13:19:59.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.125]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.125]         }
[13:19:59.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.125]             base::sink(type = "output", split = FALSE)
[13:19:59.125]             base::close(...future.stdout)
[13:19:59.125]         }, add = TRUE)
[13:19:59.125]     }
[13:19:59.125]     ...future.frame <- base::sys.nframe()
[13:19:59.125]     ...future.conditions <- base::list()
[13:19:59.125]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.125]     if (FALSE) {
[13:19:59.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.125]     }
[13:19:59.125]     ...future.result <- base::tryCatch({
[13:19:59.125]         base::withCallingHandlers({
[13:19:59.125]             ...future.value <- base::withVisible(base::local({
[13:19:59.125]                 withCallingHandlers({
[13:19:59.125]                   {
[13:19:59.125]                     sum(x, y, ...)
[13:19:59.125]                   }
[13:19:59.125]                 }, immediateCondition = function(cond) {
[13:19:59.125]                   save_rds <- function (object, pathname, ...) 
[13:19:59.125]                   {
[13:19:59.125]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:59.125]                     if (file_test("-f", pathname_tmp)) {
[13:19:59.125]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.125]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:59.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.125]                         fi_tmp[["mtime"]])
[13:19:59.125]                     }
[13:19:59.125]                     tryCatch({
[13:19:59.125]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:59.125]                     }, error = function(ex) {
[13:19:59.125]                       msg <- conditionMessage(ex)
[13:19:59.125]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.125]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:59.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.125]                         fi_tmp[["mtime"]], msg)
[13:19:59.125]                       ex$message <- msg
[13:19:59.125]                       stop(ex)
[13:19:59.125]                     })
[13:19:59.125]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:59.125]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:59.125]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:59.125]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.125]                       fi <- file.info(pathname)
[13:19:59.125]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:59.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.125]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:59.125]                         fi[["size"]], fi[["mtime"]])
[13:19:59.125]                       stop(msg)
[13:19:59.125]                     }
[13:19:59.125]                     invisible(pathname)
[13:19:59.125]                   }
[13:19:59.125]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:59.125]                     rootPath = tempdir()) 
[13:19:59.125]                   {
[13:19:59.125]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:59.125]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:59.125]                       tmpdir = path, fileext = ".rds")
[13:19:59.125]                     save_rds(obj, file)
[13:19:59.125]                   }
[13:19:59.125]                   saveImmediateCondition(cond, path = "/tmp/RtmpMY5dtO/.future/immediateConditions")
[13:19:59.125]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.125]                   {
[13:19:59.125]                     inherits <- base::inherits
[13:19:59.125]                     invokeRestart <- base::invokeRestart
[13:19:59.125]                     is.null <- base::is.null
[13:19:59.125]                     muffled <- FALSE
[13:19:59.125]                     if (inherits(cond, "message")) {
[13:19:59.125]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.125]                       if (muffled) 
[13:19:59.125]                         invokeRestart("muffleMessage")
[13:19:59.125]                     }
[13:19:59.125]                     else if (inherits(cond, "warning")) {
[13:19:59.125]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.125]                       if (muffled) 
[13:19:59.125]                         invokeRestart("muffleWarning")
[13:19:59.125]                     }
[13:19:59.125]                     else if (inherits(cond, "condition")) {
[13:19:59.125]                       if (!is.null(pattern)) {
[13:19:59.125]                         computeRestarts <- base::computeRestarts
[13:19:59.125]                         grepl <- base::grepl
[13:19:59.125]                         restarts <- computeRestarts(cond)
[13:19:59.125]                         for (restart in restarts) {
[13:19:59.125]                           name <- restart$name
[13:19:59.125]                           if (is.null(name)) 
[13:19:59.125]                             next
[13:19:59.125]                           if (!grepl(pattern, name)) 
[13:19:59.125]                             next
[13:19:59.125]                           invokeRestart(restart)
[13:19:59.125]                           muffled <- TRUE
[13:19:59.125]                           break
[13:19:59.125]                         }
[13:19:59.125]                       }
[13:19:59.125]                     }
[13:19:59.125]                     invisible(muffled)
[13:19:59.125]                   }
[13:19:59.125]                   muffleCondition(cond)
[13:19:59.125]                 })
[13:19:59.125]             }))
[13:19:59.125]             future::FutureResult(value = ...future.value$value, 
[13:19:59.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.125]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.125]                     ...future.globalenv.names))
[13:19:59.125]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.125]         }, condition = base::local({
[13:19:59.125]             c <- base::c
[13:19:59.125]             inherits <- base::inherits
[13:19:59.125]             invokeRestart <- base::invokeRestart
[13:19:59.125]             length <- base::length
[13:19:59.125]             list <- base::list
[13:19:59.125]             seq.int <- base::seq.int
[13:19:59.125]             signalCondition <- base::signalCondition
[13:19:59.125]             sys.calls <- base::sys.calls
[13:19:59.125]             `[[` <- base::`[[`
[13:19:59.125]             `+` <- base::`+`
[13:19:59.125]             `<<-` <- base::`<<-`
[13:19:59.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.125]                   3L)]
[13:19:59.125]             }
[13:19:59.125]             function(cond) {
[13:19:59.125]                 is_error <- inherits(cond, "error")
[13:19:59.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.125]                   NULL)
[13:19:59.125]                 if (is_error) {
[13:19:59.125]                   sessionInformation <- function() {
[13:19:59.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.125]                       search = base::search(), system = base::Sys.info())
[13:19:59.125]                   }
[13:19:59.125]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.125]                     cond$call), session = sessionInformation(), 
[13:19:59.125]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.125]                   signalCondition(cond)
[13:19:59.125]                 }
[13:19:59.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.125]                 "immediateCondition"))) {
[13:19:59.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.125]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.125]                   if (TRUE && !signal) {
[13:19:59.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.125]                     {
[13:19:59.125]                       inherits <- base::inherits
[13:19:59.125]                       invokeRestart <- base::invokeRestart
[13:19:59.125]                       is.null <- base::is.null
[13:19:59.125]                       muffled <- FALSE
[13:19:59.125]                       if (inherits(cond, "message")) {
[13:19:59.125]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.125]                         if (muffled) 
[13:19:59.125]                           invokeRestart("muffleMessage")
[13:19:59.125]                       }
[13:19:59.125]                       else if (inherits(cond, "warning")) {
[13:19:59.125]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.125]                         if (muffled) 
[13:19:59.125]                           invokeRestart("muffleWarning")
[13:19:59.125]                       }
[13:19:59.125]                       else if (inherits(cond, "condition")) {
[13:19:59.125]                         if (!is.null(pattern)) {
[13:19:59.125]                           computeRestarts <- base::computeRestarts
[13:19:59.125]                           grepl <- base::grepl
[13:19:59.125]                           restarts <- computeRestarts(cond)
[13:19:59.125]                           for (restart in restarts) {
[13:19:59.125]                             name <- restart$name
[13:19:59.125]                             if (is.null(name)) 
[13:19:59.125]                               next
[13:19:59.125]                             if (!grepl(pattern, name)) 
[13:19:59.125]                               next
[13:19:59.125]                             invokeRestart(restart)
[13:19:59.125]                             muffled <- TRUE
[13:19:59.125]                             break
[13:19:59.125]                           }
[13:19:59.125]                         }
[13:19:59.125]                       }
[13:19:59.125]                       invisible(muffled)
[13:19:59.125]                     }
[13:19:59.125]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.125]                   }
[13:19:59.125]                 }
[13:19:59.125]                 else {
[13:19:59.125]                   if (TRUE) {
[13:19:59.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.125]                     {
[13:19:59.125]                       inherits <- base::inherits
[13:19:59.125]                       invokeRestart <- base::invokeRestart
[13:19:59.125]                       is.null <- base::is.null
[13:19:59.125]                       muffled <- FALSE
[13:19:59.125]                       if (inherits(cond, "message")) {
[13:19:59.125]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.125]                         if (muffled) 
[13:19:59.125]                           invokeRestart("muffleMessage")
[13:19:59.125]                       }
[13:19:59.125]                       else if (inherits(cond, "warning")) {
[13:19:59.125]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.125]                         if (muffled) 
[13:19:59.125]                           invokeRestart("muffleWarning")
[13:19:59.125]                       }
[13:19:59.125]                       else if (inherits(cond, "condition")) {
[13:19:59.125]                         if (!is.null(pattern)) {
[13:19:59.125]                           computeRestarts <- base::computeRestarts
[13:19:59.125]                           grepl <- base::grepl
[13:19:59.125]                           restarts <- computeRestarts(cond)
[13:19:59.125]                           for (restart in restarts) {
[13:19:59.125]                             name <- restart$name
[13:19:59.125]                             if (is.null(name)) 
[13:19:59.125]                               next
[13:19:59.125]                             if (!grepl(pattern, name)) 
[13:19:59.125]                               next
[13:19:59.125]                             invokeRestart(restart)
[13:19:59.125]                             muffled <- TRUE
[13:19:59.125]                             break
[13:19:59.125]                           }
[13:19:59.125]                         }
[13:19:59.125]                       }
[13:19:59.125]                       invisible(muffled)
[13:19:59.125]                     }
[13:19:59.125]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.125]                   }
[13:19:59.125]                 }
[13:19:59.125]             }
[13:19:59.125]         }))
[13:19:59.125]     }, error = function(ex) {
[13:19:59.125]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.125]                 ...future.rng), started = ...future.startTime, 
[13:19:59.125]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.125]             version = "1.8"), class = "FutureResult")
[13:19:59.125]     }, finally = {
[13:19:59.125]         if (!identical(...future.workdir, getwd())) 
[13:19:59.125]             setwd(...future.workdir)
[13:19:59.125]         {
[13:19:59.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.125]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.125]             }
[13:19:59.125]             base::options(...future.oldOptions)
[13:19:59.125]             if (.Platform$OS.type == "windows") {
[13:19:59.125]                 old_names <- names(...future.oldEnvVars)
[13:19:59.125]                 envs <- base::Sys.getenv()
[13:19:59.125]                 names <- names(envs)
[13:19:59.125]                 common <- intersect(names, old_names)
[13:19:59.125]                 added <- setdiff(names, old_names)
[13:19:59.125]                 removed <- setdiff(old_names, names)
[13:19:59.125]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.125]                   envs[common]]
[13:19:59.125]                 NAMES <- toupper(changed)
[13:19:59.125]                 args <- list()
[13:19:59.125]                 for (kk in seq_along(NAMES)) {
[13:19:59.125]                   name <- changed[[kk]]
[13:19:59.125]                   NAME <- NAMES[[kk]]
[13:19:59.125]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.125]                     next
[13:19:59.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.125]                 }
[13:19:59.125]                 NAMES <- toupper(added)
[13:19:59.125]                 for (kk in seq_along(NAMES)) {
[13:19:59.125]                   name <- added[[kk]]
[13:19:59.125]                   NAME <- NAMES[[kk]]
[13:19:59.125]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.125]                     next
[13:19:59.125]                   args[[name]] <- ""
[13:19:59.125]                 }
[13:19:59.125]                 NAMES <- toupper(removed)
[13:19:59.125]                 for (kk in seq_along(NAMES)) {
[13:19:59.125]                   name <- removed[[kk]]
[13:19:59.125]                   NAME <- NAMES[[kk]]
[13:19:59.125]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.125]                     next
[13:19:59.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.125]                 }
[13:19:59.125]                 if (length(args) > 0) 
[13:19:59.125]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.125]             }
[13:19:59.125]             else {
[13:19:59.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.125]             }
[13:19:59.125]             {
[13:19:59.125]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.125]                   0L) {
[13:19:59.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.125]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.125]                   base::options(opts)
[13:19:59.125]                 }
[13:19:59.125]                 {
[13:19:59.125]                   {
[13:19:59.125]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.125]                     NULL
[13:19:59.125]                   }
[13:19:59.125]                   options(future.plan = NULL)
[13:19:59.125]                   if (is.na(NA_character_)) 
[13:19:59.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.125]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:59.125]                     envir = parent.frame()) 
[13:19:59.125]                   {
[13:19:59.125]                     default_workers <- missing(workers)
[13:19:59.125]                     if (is.function(workers)) 
[13:19:59.125]                       workers <- workers()
[13:19:59.125]                     workers <- structure(as.integer(workers), 
[13:19:59.125]                       class = class(workers))
[13:19:59.125]                     stop_if_not(is.finite(workers), workers >= 
[13:19:59.125]                       1L)
[13:19:59.125]                     if ((workers == 1L && !inherits(workers, 
[13:19:59.125]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:59.125]                       if (default_workers) 
[13:19:59.125]                         supportsMulticore(warn = TRUE)
[13:19:59.125]                       return(sequential(..., envir = envir))
[13:19:59.125]                     }
[13:19:59.125]                     oopts <- options(mc.cores = workers)
[13:19:59.125]                     on.exit(options(oopts))
[13:19:59.125]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:59.125]                       envir = envir)
[13:19:59.125]                     if (!future$lazy) 
[13:19:59.125]                       future <- run(future)
[13:19:59.125]                     invisible(future)
[13:19:59.125]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.125]                 }
[13:19:59.125]             }
[13:19:59.125]         }
[13:19:59.125]     })
[13:19:59.125]     if (TRUE) {
[13:19:59.125]         base::sink(type = "output", split = FALSE)
[13:19:59.125]         if (TRUE) {
[13:19:59.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.125]         }
[13:19:59.125]         else {
[13:19:59.125]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.125]         }
[13:19:59.125]         base::close(...future.stdout)
[13:19:59.125]         ...future.stdout <- NULL
[13:19:59.125]     }
[13:19:59.125]     ...future.result$conditions <- ...future.conditions
[13:19:59.125]     ...future.result$finished <- base::Sys.time()
[13:19:59.125]     ...future.result
[13:19:59.125] }
[13:19:59.127] assign_globals() ...
[13:19:59.127] List of 2
[13:19:59.127]  $ x: int [1:2] 1 2
[13:19:59.127]  $ y: num 3
[13:19:59.127]  - attr(*, "where")=List of 2
[13:19:59.127]   ..$ x:<environment: R_EmptyEnv> 
[13:19:59.127]   ..$ y:<environment: R_EmptyEnv> 
[13:19:59.127]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.127]  - attr(*, "resolved")= logi FALSE
[13:19:59.127]  - attr(*, "total_size")= num 112
[13:19:59.127]  - attr(*, "already-done")= logi TRUE
[13:19:59.131] - copied ‘x’ to environment
[13:19:59.131] - copied ‘y’ to environment
[13:19:59.131] assign_globals() ... done
[13:19:59.131] requestCore(): workers = 2
[13:19:59.133] MulticoreFuture started
[13:19:59.134] - Launch lazy future ... done
[13:19:59.134] run() for ‘MulticoreFuture’ ... done
[13:19:59.134] plan(): Setting new future strategy stack:
[13:19:59.135] List of future strategies:
[13:19:59.135] 1. sequential:
[13:19:59.135]    - args: function (..., envir = parent.frame())
[13:19:59.135]    - tweaked: FALSE
[13:19:59.135]    - call: NULL
[13:19:59.136] plan(): nbrOfWorkers() = 1
[13:19:59.138] plan(): Setting new future strategy stack:
[13:19:59.138] List of future strategies:
[13:19:59.138] 1. multicore:
[13:19:59.138]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:59.138]    - tweaked: FALSE
[13:19:59.138]    - call: plan(strategy, substitute = FALSE)
[13:19:59.143] plan(): nbrOfWorkers() = 2
[13:19:59.149] signalConditions() ...
[13:19:59.149]  - include = ‘immediateCondition’
[13:19:59.149]  - exclude = 
[13:19:59.150]  - resignal = FALSE
[13:19:59.150]  - Number of conditions: 1
[13:19:59.150] signalConditions() ... done
[13:19:59.150] signalConditions() ...
[13:19:59.150]  - include = ‘immediateCondition’
[13:19:59.150]  - exclude = 
[13:19:59.150]  - resignal = FALSE
[13:19:59.150]  - Number of conditions: 1
[13:19:59.151] signalConditions() ... done
[13:19:59.151] Future state: ‘finished’
[13:19:59.151] signalConditions() ...
[13:19:59.151]  - include = ‘condition’
[13:19:59.151]  - exclude = ‘immediateCondition’
[13:19:59.151]  - resignal = TRUE
[13:19:59.151]  - Number of conditions: 1
[13:19:59.151]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:19:59.152] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpMY5dtO/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multicore') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x562224c2fea0>
Arguments '...' exists: TRUE
[13:19:59.153] getGlobalsAndPackages() ...
[13:19:59.153] - globals passed as-is: [1] ‘...’
[13:19:59.153] Resolving globals: FALSE
[13:19:59.154] Tweak future expression to call with '...' arguments ...
[13:19:59.154] {
[13:19:59.154]     do.call(function(...) {
[13:19:59.154]         fcn <- function() sum(...)
[13:19:59.154]         fcn()
[13:19:59.154]     }, args = future.call.arguments)
[13:19:59.154] }
[13:19:59.154] Tweak future expression to call with '...' arguments ... DONE
[13:19:59.154] The total size of the 1 globals is 112 bytes (112 bytes)
[13:19:59.155] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[13:19:59.155] - globals: [1] ‘future.call.arguments’
[13:19:59.155] 
[13:19:59.155] getGlobalsAndPackages() ... DONE
[13:19:59.156] run() for ‘Future’ ...
[13:19:59.156] - state: ‘created’
[13:19:59.156] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.160] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:59.160]   - Field: ‘label’
[13:19:59.161]   - Field: ‘local’
[13:19:59.161]   - Field: ‘owner’
[13:19:59.161]   - Field: ‘envir’
[13:19:59.161]   - Field: ‘workers’
[13:19:59.161]   - Field: ‘packages’
[13:19:59.161]   - Field: ‘gc’
[13:19:59.161]   - Field: ‘job’
[13:19:59.161]   - Field: ‘conditions’
[13:19:59.161]   - Field: ‘expr’
[13:19:59.162]   - Field: ‘uuid’
[13:19:59.162]   - Field: ‘seed’
[13:19:59.162]   - Field: ‘version’
[13:19:59.162]   - Field: ‘result’
[13:19:59.162]   - Field: ‘asynchronous’
[13:19:59.162]   - Field: ‘calls’
[13:19:59.162]   - Field: ‘globals’
[13:19:59.162]   - Field: ‘stdout’
[13:19:59.162]   - Field: ‘earlySignal’
[13:19:59.163]   - Field: ‘lazy’
[13:19:59.163]   - Field: ‘state’
[13:19:59.163] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:59.163] - Launch lazy future ...
[13:19:59.163] Packages needed by the future expression (n = 0): <none>
[13:19:59.163] Packages needed by future strategies (n = 0): <none>
[13:19:59.164] {
[13:19:59.164]     {
[13:19:59.164]         {
[13:19:59.164]             ...future.startTime <- base::Sys.time()
[13:19:59.164]             {
[13:19:59.164]                 {
[13:19:59.164]                   {
[13:19:59.164]                     {
[13:19:59.164]                       base::local({
[13:19:59.164]                         has_future <- base::requireNamespace("future", 
[13:19:59.164]                           quietly = TRUE)
[13:19:59.164]                         if (has_future) {
[13:19:59.164]                           ns <- base::getNamespace("future")
[13:19:59.164]                           version <- ns[[".package"]][["version"]]
[13:19:59.164]                           if (is.null(version)) 
[13:19:59.164]                             version <- utils::packageVersion("future")
[13:19:59.164]                         }
[13:19:59.164]                         else {
[13:19:59.164]                           version <- NULL
[13:19:59.164]                         }
[13:19:59.164]                         if (!has_future || version < "1.8.0") {
[13:19:59.164]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.164]                             "", base::R.version$version.string), 
[13:19:59.164]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.164]                               "release", "version")], collapse = " "), 
[13:19:59.164]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.164]                             info)
[13:19:59.164]                           info <- base::paste(info, collapse = "; ")
[13:19:59.164]                           if (!has_future) {
[13:19:59.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.164]                               info)
[13:19:59.164]                           }
[13:19:59.164]                           else {
[13:19:59.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.164]                               info, version)
[13:19:59.164]                           }
[13:19:59.164]                           base::stop(msg)
[13:19:59.164]                         }
[13:19:59.164]                       })
[13:19:59.164]                     }
[13:19:59.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.164]                     base::options(mc.cores = 1L)
[13:19:59.164]                   }
[13:19:59.164]                   options(future.plan = NULL)
[13:19:59.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.164]                 }
[13:19:59.164]                 ...future.workdir <- getwd()
[13:19:59.164]             }
[13:19:59.164]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.164]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.164]         }
[13:19:59.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:59.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.164]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.164]             base::names(...future.oldOptions))
[13:19:59.164]     }
[13:19:59.164]     if (FALSE) {
[13:19:59.164]     }
[13:19:59.164]     else {
[13:19:59.164]         if (TRUE) {
[13:19:59.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.164]                 open = "w")
[13:19:59.164]         }
[13:19:59.164]         else {
[13:19:59.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.164]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.164]         }
[13:19:59.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.164]             base::sink(type = "output", split = FALSE)
[13:19:59.164]             base::close(...future.stdout)
[13:19:59.164]         }, add = TRUE)
[13:19:59.164]     }
[13:19:59.164]     ...future.frame <- base::sys.nframe()
[13:19:59.164]     ...future.conditions <- base::list()
[13:19:59.164]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.164]     if (FALSE) {
[13:19:59.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.164]     }
[13:19:59.164]     ...future.result <- base::tryCatch({
[13:19:59.164]         base::withCallingHandlers({
[13:19:59.164]             ...future.value <- base::withVisible(base::local({
[13:19:59.164]                 withCallingHandlers({
[13:19:59.164]                   {
[13:19:59.164]                     do.call(function(...) {
[13:19:59.164]                       fcn <- function() sum(...)
[13:19:59.164]                       fcn()
[13:19:59.164]                     }, args = future.call.arguments)
[13:19:59.164]                   }
[13:19:59.164]                 }, immediateCondition = function(cond) {
[13:19:59.164]                   save_rds <- function (object, pathname, ...) 
[13:19:59.164]                   {
[13:19:59.164]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:59.164]                     if (file_test("-f", pathname_tmp)) {
[13:19:59.164]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.164]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:59.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.164]                         fi_tmp[["mtime"]])
[13:19:59.164]                     }
[13:19:59.164]                     tryCatch({
[13:19:59.164]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:59.164]                     }, error = function(ex) {
[13:19:59.164]                       msg <- conditionMessage(ex)
[13:19:59.164]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.164]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:59.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.164]                         fi_tmp[["mtime"]], msg)
[13:19:59.164]                       ex$message <- msg
[13:19:59.164]                       stop(ex)
[13:19:59.164]                     })
[13:19:59.164]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:59.164]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:59.164]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:59.164]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.164]                       fi <- file.info(pathname)
[13:19:59.164]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:59.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.164]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:59.164]                         fi[["size"]], fi[["mtime"]])
[13:19:59.164]                       stop(msg)
[13:19:59.164]                     }
[13:19:59.164]                     invisible(pathname)
[13:19:59.164]                   }
[13:19:59.164]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:59.164]                     rootPath = tempdir()) 
[13:19:59.164]                   {
[13:19:59.164]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:59.164]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:59.164]                       tmpdir = path, fileext = ".rds")
[13:19:59.164]                     save_rds(obj, file)
[13:19:59.164]                   }
[13:19:59.164]                   saveImmediateCondition(cond, path = "/tmp/RtmpMY5dtO/.future/immediateConditions")
[13:19:59.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.164]                   {
[13:19:59.164]                     inherits <- base::inherits
[13:19:59.164]                     invokeRestart <- base::invokeRestart
[13:19:59.164]                     is.null <- base::is.null
[13:19:59.164]                     muffled <- FALSE
[13:19:59.164]                     if (inherits(cond, "message")) {
[13:19:59.164]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.164]                       if (muffled) 
[13:19:59.164]                         invokeRestart("muffleMessage")
[13:19:59.164]                     }
[13:19:59.164]                     else if (inherits(cond, "warning")) {
[13:19:59.164]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.164]                       if (muffled) 
[13:19:59.164]                         invokeRestart("muffleWarning")
[13:19:59.164]                     }
[13:19:59.164]                     else if (inherits(cond, "condition")) {
[13:19:59.164]                       if (!is.null(pattern)) {
[13:19:59.164]                         computeRestarts <- base::computeRestarts
[13:19:59.164]                         grepl <- base::grepl
[13:19:59.164]                         restarts <- computeRestarts(cond)
[13:19:59.164]                         for (restart in restarts) {
[13:19:59.164]                           name <- restart$name
[13:19:59.164]                           if (is.null(name)) 
[13:19:59.164]                             next
[13:19:59.164]                           if (!grepl(pattern, name)) 
[13:19:59.164]                             next
[13:19:59.164]                           invokeRestart(restart)
[13:19:59.164]                           muffled <- TRUE
[13:19:59.164]                           break
[13:19:59.164]                         }
[13:19:59.164]                       }
[13:19:59.164]                     }
[13:19:59.164]                     invisible(muffled)
[13:19:59.164]                   }
[13:19:59.164]                   muffleCondition(cond)
[13:19:59.164]                 })
[13:19:59.164]             }))
[13:19:59.164]             future::FutureResult(value = ...future.value$value, 
[13:19:59.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.164]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.164]                     ...future.globalenv.names))
[13:19:59.164]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.164]         }, condition = base::local({
[13:19:59.164]             c <- base::c
[13:19:59.164]             inherits <- base::inherits
[13:19:59.164]             invokeRestart <- base::invokeRestart
[13:19:59.164]             length <- base::length
[13:19:59.164]             list <- base::list
[13:19:59.164]             seq.int <- base::seq.int
[13:19:59.164]             signalCondition <- base::signalCondition
[13:19:59.164]             sys.calls <- base::sys.calls
[13:19:59.164]             `[[` <- base::`[[`
[13:19:59.164]             `+` <- base::`+`
[13:19:59.164]             `<<-` <- base::`<<-`
[13:19:59.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.164]                   3L)]
[13:19:59.164]             }
[13:19:59.164]             function(cond) {
[13:19:59.164]                 is_error <- inherits(cond, "error")
[13:19:59.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.164]                   NULL)
[13:19:59.164]                 if (is_error) {
[13:19:59.164]                   sessionInformation <- function() {
[13:19:59.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.164]                       search = base::search(), system = base::Sys.info())
[13:19:59.164]                   }
[13:19:59.164]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.164]                     cond$call), session = sessionInformation(), 
[13:19:59.164]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.164]                   signalCondition(cond)
[13:19:59.164]                 }
[13:19:59.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.164]                 "immediateCondition"))) {
[13:19:59.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.164]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.164]                   if (TRUE && !signal) {
[13:19:59.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.164]                     {
[13:19:59.164]                       inherits <- base::inherits
[13:19:59.164]                       invokeRestart <- base::invokeRestart
[13:19:59.164]                       is.null <- base::is.null
[13:19:59.164]                       muffled <- FALSE
[13:19:59.164]                       if (inherits(cond, "message")) {
[13:19:59.164]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.164]                         if (muffled) 
[13:19:59.164]                           invokeRestart("muffleMessage")
[13:19:59.164]                       }
[13:19:59.164]                       else if (inherits(cond, "warning")) {
[13:19:59.164]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.164]                         if (muffled) 
[13:19:59.164]                           invokeRestart("muffleWarning")
[13:19:59.164]                       }
[13:19:59.164]                       else if (inherits(cond, "condition")) {
[13:19:59.164]                         if (!is.null(pattern)) {
[13:19:59.164]                           computeRestarts <- base::computeRestarts
[13:19:59.164]                           grepl <- base::grepl
[13:19:59.164]                           restarts <- computeRestarts(cond)
[13:19:59.164]                           for (restart in restarts) {
[13:19:59.164]                             name <- restart$name
[13:19:59.164]                             if (is.null(name)) 
[13:19:59.164]                               next
[13:19:59.164]                             if (!grepl(pattern, name)) 
[13:19:59.164]                               next
[13:19:59.164]                             invokeRestart(restart)
[13:19:59.164]                             muffled <- TRUE
[13:19:59.164]                             break
[13:19:59.164]                           }
[13:19:59.164]                         }
[13:19:59.164]                       }
[13:19:59.164]                       invisible(muffled)
[13:19:59.164]                     }
[13:19:59.164]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.164]                   }
[13:19:59.164]                 }
[13:19:59.164]                 else {
[13:19:59.164]                   if (TRUE) {
[13:19:59.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.164]                     {
[13:19:59.164]                       inherits <- base::inherits
[13:19:59.164]                       invokeRestart <- base::invokeRestart
[13:19:59.164]                       is.null <- base::is.null
[13:19:59.164]                       muffled <- FALSE
[13:19:59.164]                       if (inherits(cond, "message")) {
[13:19:59.164]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.164]                         if (muffled) 
[13:19:59.164]                           invokeRestart("muffleMessage")
[13:19:59.164]                       }
[13:19:59.164]                       else if (inherits(cond, "warning")) {
[13:19:59.164]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.164]                         if (muffled) 
[13:19:59.164]                           invokeRestart("muffleWarning")
[13:19:59.164]                       }
[13:19:59.164]                       else if (inherits(cond, "condition")) {
[13:19:59.164]                         if (!is.null(pattern)) {
[13:19:59.164]                           computeRestarts <- base::computeRestarts
[13:19:59.164]                           grepl <- base::grepl
[13:19:59.164]                           restarts <- computeRestarts(cond)
[13:19:59.164]                           for (restart in restarts) {
[13:19:59.164]                             name <- restart$name
[13:19:59.164]                             if (is.null(name)) 
[13:19:59.164]                               next
[13:19:59.164]                             if (!grepl(pattern, name)) 
[13:19:59.164]                               next
[13:19:59.164]                             invokeRestart(restart)
[13:19:59.164]                             muffled <- TRUE
[13:19:59.164]                             break
[13:19:59.164]                           }
[13:19:59.164]                         }
[13:19:59.164]                       }
[13:19:59.164]                       invisible(muffled)
[13:19:59.164]                     }
[13:19:59.164]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.164]                   }
[13:19:59.164]                 }
[13:19:59.164]             }
[13:19:59.164]         }))
[13:19:59.164]     }, error = function(ex) {
[13:19:59.164]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.164]                 ...future.rng), started = ...future.startTime, 
[13:19:59.164]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.164]             version = "1.8"), class = "FutureResult")
[13:19:59.164]     }, finally = {
[13:19:59.164]         if (!identical(...future.workdir, getwd())) 
[13:19:59.164]             setwd(...future.workdir)
[13:19:59.164]         {
[13:19:59.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.164]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.164]             }
[13:19:59.164]             base::options(...future.oldOptions)
[13:19:59.164]             if (.Platform$OS.type == "windows") {
[13:19:59.164]                 old_names <- names(...future.oldEnvVars)
[13:19:59.164]                 envs <- base::Sys.getenv()
[13:19:59.164]                 names <- names(envs)
[13:19:59.164]                 common <- intersect(names, old_names)
[13:19:59.164]                 added <- setdiff(names, old_names)
[13:19:59.164]                 removed <- setdiff(old_names, names)
[13:19:59.164]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.164]                   envs[common]]
[13:19:59.164]                 NAMES <- toupper(changed)
[13:19:59.164]                 args <- list()
[13:19:59.164]                 for (kk in seq_along(NAMES)) {
[13:19:59.164]                   name <- changed[[kk]]
[13:19:59.164]                   NAME <- NAMES[[kk]]
[13:19:59.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.164]                     next
[13:19:59.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.164]                 }
[13:19:59.164]                 NAMES <- toupper(added)
[13:19:59.164]                 for (kk in seq_along(NAMES)) {
[13:19:59.164]                   name <- added[[kk]]
[13:19:59.164]                   NAME <- NAMES[[kk]]
[13:19:59.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.164]                     next
[13:19:59.164]                   args[[name]] <- ""
[13:19:59.164]                 }
[13:19:59.164]                 NAMES <- toupper(removed)
[13:19:59.164]                 for (kk in seq_along(NAMES)) {
[13:19:59.164]                   name <- removed[[kk]]
[13:19:59.164]                   NAME <- NAMES[[kk]]
[13:19:59.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.164]                     next
[13:19:59.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.164]                 }
[13:19:59.164]                 if (length(args) > 0) 
[13:19:59.164]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.164]             }
[13:19:59.164]             else {
[13:19:59.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.164]             }
[13:19:59.164]             {
[13:19:59.164]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.164]                   0L) {
[13:19:59.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.164]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.164]                   base::options(opts)
[13:19:59.164]                 }
[13:19:59.164]                 {
[13:19:59.164]                   {
[13:19:59.164]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.164]                     NULL
[13:19:59.164]                   }
[13:19:59.164]                   options(future.plan = NULL)
[13:19:59.164]                   if (is.na(NA_character_)) 
[13:19:59.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.164]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:59.164]                     envir = parent.frame()) 
[13:19:59.164]                   {
[13:19:59.164]                     default_workers <- missing(workers)
[13:19:59.164]                     if (is.function(workers)) 
[13:19:59.164]                       workers <- workers()
[13:19:59.164]                     workers <- structure(as.integer(workers), 
[13:19:59.164]                       class = class(workers))
[13:19:59.164]                     stop_if_not(is.finite(workers), workers >= 
[13:19:59.164]                       1L)
[13:19:59.164]                     if ((workers == 1L && !inherits(workers, 
[13:19:59.164]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:59.164]                       if (default_workers) 
[13:19:59.164]                         supportsMulticore(warn = TRUE)
[13:19:59.164]                       return(sequential(..., envir = envir))
[13:19:59.164]                     }
[13:19:59.164]                     oopts <- options(mc.cores = workers)
[13:19:59.164]                     on.exit(options(oopts))
[13:19:59.164]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:59.164]                       envir = envir)
[13:19:59.164]                     if (!future$lazy) 
[13:19:59.164]                       future <- run(future)
[13:19:59.164]                     invisible(future)
[13:19:59.164]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.164]                 }
[13:19:59.164]             }
[13:19:59.164]         }
[13:19:59.164]     })
[13:19:59.164]     if (TRUE) {
[13:19:59.164]         base::sink(type = "output", split = FALSE)
[13:19:59.164]         if (TRUE) {
[13:19:59.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.164]         }
[13:19:59.164]         else {
[13:19:59.164]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.164]         }
[13:19:59.164]         base::close(...future.stdout)
[13:19:59.164]         ...future.stdout <- NULL
[13:19:59.164]     }
[13:19:59.164]     ...future.result$conditions <- ...future.conditions
[13:19:59.164]     ...future.result$finished <- base::Sys.time()
[13:19:59.164]     ...future.result
[13:19:59.164] }
[13:19:59.166] assign_globals() ...
[13:19:59.167] List of 1
[13:19:59.167]  $ future.call.arguments:List of 2
[13:19:59.167]   ..$ : int [1:2] 1 2
[13:19:59.167]   ..$ : num 3
[13:19:59.167]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:59.167]  - attr(*, "where")=List of 1
[13:19:59.167]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[13:19:59.167]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.167]  - attr(*, "resolved")= logi FALSE
[13:19:59.167]  - attr(*, "total_size")= num 112
[13:19:59.167]  - attr(*, "already-done")= logi TRUE
[13:19:59.173] - copied ‘future.call.arguments’ to environment
[13:19:59.173] assign_globals() ... done
[13:19:59.174] requestCore(): workers = 2
[13:19:59.176] MulticoreFuture started
[13:19:59.176] - Launch lazy future ... done
[13:19:59.177] run() for ‘MulticoreFuture’ ... done
[13:19:59.177] plan(): Setting new future strategy stack:
[13:19:59.177] List of future strategies:
[13:19:59.177] 1. sequential:
[13:19:59.177]    - args: function (..., envir = parent.frame())
[13:19:59.177]    - tweaked: FALSE
[13:19:59.177]    - call: NULL
[13:19:59.179] plan(): nbrOfWorkers() = 1
[13:19:59.181] plan(): Setting new future strategy stack:
[13:19:59.181] List of future strategies:
[13:19:59.181] 1. multicore:
[13:19:59.181]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:59.181]    - tweaked: FALSE
[13:19:59.181]    - call: plan(strategy, substitute = FALSE)
[13:19:59.187] plan(): nbrOfWorkers() = 2
[1] 6
** Sum function 'F' with plan('multicore') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x5622250ae1d8>
Using '...' in a formula
[13:19:59.188] getGlobalsAndPackages() ...
[13:19:59.189] Searching for globals...
[13:19:59.193] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[13:19:59.193] Searching for globals ... DONE
[13:19:59.193] Resolving globals: FALSE
[13:19:59.193] Tweak future expression to call with '...' arguments ...
[13:19:59.194] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[13:19:59.195] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[13:19:59.195] - globals: [3] ‘fcn’, ‘x’, ‘y’
[13:19:59.195] 
[13:19:59.195] getGlobalsAndPackages() ... DONE
[13:19:59.195] run() for ‘Future’ ...
[13:19:59.195] - state: ‘created’
[13:19:59.196] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.200] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:59.200]   - Field: ‘label’
[13:19:59.200]   - Field: ‘local’
[13:19:59.200]   - Field: ‘owner’
[13:19:59.200]   - Field: ‘envir’
[13:19:59.201]   - Field: ‘workers’
[13:19:59.201]   - Field: ‘packages’
[13:19:59.201]   - Field: ‘gc’
[13:19:59.201]   - Field: ‘job’
[13:19:59.201]   - Field: ‘conditions’
[13:19:59.201]   - Field: ‘expr’
[13:19:59.201]   - Field: ‘uuid’
[13:19:59.201]   - Field: ‘seed’
[13:19:59.202]   - Field: ‘version’
[13:19:59.202]   - Field: ‘result’
[13:19:59.202]   - Field: ‘asynchronous’
[13:19:59.202]   - Field: ‘calls’
[13:19:59.202]   - Field: ‘globals’
[13:19:59.202]   - Field: ‘stdout’
[13:19:59.202]   - Field: ‘earlySignal’
[13:19:59.202]   - Field: ‘lazy’
[13:19:59.202]   - Field: ‘state’
[13:19:59.203] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:59.203] - Launch lazy future ...
[13:19:59.203] Packages needed by the future expression (n = 0): <none>
[13:19:59.203] Packages needed by future strategies (n = 0): <none>
[13:19:59.204] {
[13:19:59.204]     {
[13:19:59.204]         {
[13:19:59.204]             ...future.startTime <- base::Sys.time()
[13:19:59.204]             {
[13:19:59.204]                 {
[13:19:59.204]                   {
[13:19:59.204]                     {
[13:19:59.204]                       base::local({
[13:19:59.204]                         has_future <- base::requireNamespace("future", 
[13:19:59.204]                           quietly = TRUE)
[13:19:59.204]                         if (has_future) {
[13:19:59.204]                           ns <- base::getNamespace("future")
[13:19:59.204]                           version <- ns[[".package"]][["version"]]
[13:19:59.204]                           if (is.null(version)) 
[13:19:59.204]                             version <- utils::packageVersion("future")
[13:19:59.204]                         }
[13:19:59.204]                         else {
[13:19:59.204]                           version <- NULL
[13:19:59.204]                         }
[13:19:59.204]                         if (!has_future || version < "1.8.0") {
[13:19:59.204]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.204]                             "", base::R.version$version.string), 
[13:19:59.204]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.204]                               "release", "version")], collapse = " "), 
[13:19:59.204]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.204]                             info)
[13:19:59.204]                           info <- base::paste(info, collapse = "; ")
[13:19:59.204]                           if (!has_future) {
[13:19:59.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.204]                               info)
[13:19:59.204]                           }
[13:19:59.204]                           else {
[13:19:59.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.204]                               info, version)
[13:19:59.204]                           }
[13:19:59.204]                           base::stop(msg)
[13:19:59.204]                         }
[13:19:59.204]                       })
[13:19:59.204]                     }
[13:19:59.204]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.204]                     base::options(mc.cores = 1L)
[13:19:59.204]                   }
[13:19:59.204]                   options(future.plan = NULL)
[13:19:59.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.204]                 }
[13:19:59.204]                 ...future.workdir <- getwd()
[13:19:59.204]             }
[13:19:59.204]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.204]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.204]         }
[13:19:59.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:59.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.204]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.204]             base::names(...future.oldOptions))
[13:19:59.204]     }
[13:19:59.204]     if (FALSE) {
[13:19:59.204]     }
[13:19:59.204]     else {
[13:19:59.204]         if (TRUE) {
[13:19:59.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.204]                 open = "w")
[13:19:59.204]         }
[13:19:59.204]         else {
[13:19:59.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.204]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.204]         }
[13:19:59.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.204]             base::sink(type = "output", split = FALSE)
[13:19:59.204]             base::close(...future.stdout)
[13:19:59.204]         }, add = TRUE)
[13:19:59.204]     }
[13:19:59.204]     ...future.frame <- base::sys.nframe()
[13:19:59.204]     ...future.conditions <- base::list()
[13:19:59.204]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.204]     if (FALSE) {
[13:19:59.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.204]     }
[13:19:59.204]     ...future.result <- base::tryCatch({
[13:19:59.204]         base::withCallingHandlers({
[13:19:59.204]             ...future.value <- base::withVisible(base::local({
[13:19:59.204]                 withCallingHandlers({
[13:19:59.204]                   fcn(x, y)
[13:19:59.204]                 }, immediateCondition = function(cond) {
[13:19:59.204]                   save_rds <- function (object, pathname, ...) 
[13:19:59.204]                   {
[13:19:59.204]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:59.204]                     if (file_test("-f", pathname_tmp)) {
[13:19:59.204]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.204]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:59.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.204]                         fi_tmp[["mtime"]])
[13:19:59.204]                     }
[13:19:59.204]                     tryCatch({
[13:19:59.204]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:59.204]                     }, error = function(ex) {
[13:19:59.204]                       msg <- conditionMessage(ex)
[13:19:59.204]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.204]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:59.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.204]                         fi_tmp[["mtime"]], msg)
[13:19:59.204]                       ex$message <- msg
[13:19:59.204]                       stop(ex)
[13:19:59.204]                     })
[13:19:59.204]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:59.204]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:59.204]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:59.204]                       fi_tmp <- file.info(pathname_tmp)
[13:19:59.204]                       fi <- file.info(pathname)
[13:19:59.204]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:59.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:59.204]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:59.204]                         fi[["size"]], fi[["mtime"]])
[13:19:59.204]                       stop(msg)
[13:19:59.204]                     }
[13:19:59.204]                     invisible(pathname)
[13:19:59.204]                   }
[13:19:59.204]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:59.204]                     rootPath = tempdir()) 
[13:19:59.204]                   {
[13:19:59.204]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:59.204]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:59.204]                       tmpdir = path, fileext = ".rds")
[13:19:59.204]                     save_rds(obj, file)
[13:19:59.204]                   }
[13:19:59.204]                   saveImmediateCondition(cond, path = "/tmp/RtmpMY5dtO/.future/immediateConditions")
[13:19:59.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.204]                   {
[13:19:59.204]                     inherits <- base::inherits
[13:19:59.204]                     invokeRestart <- base::invokeRestart
[13:19:59.204]                     is.null <- base::is.null
[13:19:59.204]                     muffled <- FALSE
[13:19:59.204]                     if (inherits(cond, "message")) {
[13:19:59.204]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.204]                       if (muffled) 
[13:19:59.204]                         invokeRestart("muffleMessage")
[13:19:59.204]                     }
[13:19:59.204]                     else if (inherits(cond, "warning")) {
[13:19:59.204]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.204]                       if (muffled) 
[13:19:59.204]                         invokeRestart("muffleWarning")
[13:19:59.204]                     }
[13:19:59.204]                     else if (inherits(cond, "condition")) {
[13:19:59.204]                       if (!is.null(pattern)) {
[13:19:59.204]                         computeRestarts <- base::computeRestarts
[13:19:59.204]                         grepl <- base::grepl
[13:19:59.204]                         restarts <- computeRestarts(cond)
[13:19:59.204]                         for (restart in restarts) {
[13:19:59.204]                           name <- restart$name
[13:19:59.204]                           if (is.null(name)) 
[13:19:59.204]                             next
[13:19:59.204]                           if (!grepl(pattern, name)) 
[13:19:59.204]                             next
[13:19:59.204]                           invokeRestart(restart)
[13:19:59.204]                           muffled <- TRUE
[13:19:59.204]                           break
[13:19:59.204]                         }
[13:19:59.204]                       }
[13:19:59.204]                     }
[13:19:59.204]                     invisible(muffled)
[13:19:59.204]                   }
[13:19:59.204]                   muffleCondition(cond)
[13:19:59.204]                 })
[13:19:59.204]             }))
[13:19:59.204]             future::FutureResult(value = ...future.value$value, 
[13:19:59.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.204]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.204]                     ...future.globalenv.names))
[13:19:59.204]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.204]         }, condition = base::local({
[13:19:59.204]             c <- base::c
[13:19:59.204]             inherits <- base::inherits
[13:19:59.204]             invokeRestart <- base::invokeRestart
[13:19:59.204]             length <- base::length
[13:19:59.204]             list <- base::list
[13:19:59.204]             seq.int <- base::seq.int
[13:19:59.204]             signalCondition <- base::signalCondition
[13:19:59.204]             sys.calls <- base::sys.calls
[13:19:59.204]             `[[` <- base::`[[`
[13:19:59.204]             `+` <- base::`+`
[13:19:59.204]             `<<-` <- base::`<<-`
[13:19:59.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.204]                   3L)]
[13:19:59.204]             }
[13:19:59.204]             function(cond) {
[13:19:59.204]                 is_error <- inherits(cond, "error")
[13:19:59.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.204]                   NULL)
[13:19:59.204]                 if (is_error) {
[13:19:59.204]                   sessionInformation <- function() {
[13:19:59.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.204]                       search = base::search(), system = base::Sys.info())
[13:19:59.204]                   }
[13:19:59.204]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.204]                     cond$call), session = sessionInformation(), 
[13:19:59.204]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.204]                   signalCondition(cond)
[13:19:59.204]                 }
[13:19:59.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.204]                 "immediateCondition"))) {
[13:19:59.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.204]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.204]                   if (TRUE && !signal) {
[13:19:59.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.204]                     {
[13:19:59.204]                       inherits <- base::inherits
[13:19:59.204]                       invokeRestart <- base::invokeRestart
[13:19:59.204]                       is.null <- base::is.null
[13:19:59.204]                       muffled <- FALSE
[13:19:59.204]                       if (inherits(cond, "message")) {
[13:19:59.204]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.204]                         if (muffled) 
[13:19:59.204]                           invokeRestart("muffleMessage")
[13:19:59.204]                       }
[13:19:59.204]                       else if (inherits(cond, "warning")) {
[13:19:59.204]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.204]                         if (muffled) 
[13:19:59.204]                           invokeRestart("muffleWarning")
[13:19:59.204]                       }
[13:19:59.204]                       else if (inherits(cond, "condition")) {
[13:19:59.204]                         if (!is.null(pattern)) {
[13:19:59.204]                           computeRestarts <- base::computeRestarts
[13:19:59.204]                           grepl <- base::grepl
[13:19:59.204]                           restarts <- computeRestarts(cond)
[13:19:59.204]                           for (restart in restarts) {
[13:19:59.204]                             name <- restart$name
[13:19:59.204]                             if (is.null(name)) 
[13:19:59.204]                               next
[13:19:59.204]                             if (!grepl(pattern, name)) 
[13:19:59.204]                               next
[13:19:59.204]                             invokeRestart(restart)
[13:19:59.204]                             muffled <- TRUE
[13:19:59.204]                             break
[13:19:59.204]                           }
[13:19:59.204]                         }
[13:19:59.204]                       }
[13:19:59.204]                       invisible(muffled)
[13:19:59.204]                     }
[13:19:59.204]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.204]                   }
[13:19:59.204]                 }
[13:19:59.204]                 else {
[13:19:59.204]                   if (TRUE) {
[13:19:59.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.204]                     {
[13:19:59.204]                       inherits <- base::inherits
[13:19:59.204]                       invokeRestart <- base::invokeRestart
[13:19:59.204]                       is.null <- base::is.null
[13:19:59.204]                       muffled <- FALSE
[13:19:59.204]                       if (inherits(cond, "message")) {
[13:19:59.204]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.204]                         if (muffled) 
[13:19:59.204]                           invokeRestart("muffleMessage")
[13:19:59.204]                       }
[13:19:59.204]                       else if (inherits(cond, "warning")) {
[13:19:59.204]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.204]                         if (muffled) 
[13:19:59.204]                           invokeRestart("muffleWarning")
[13:19:59.204]                       }
[13:19:59.204]                       else if (inherits(cond, "condition")) {
[13:19:59.204]                         if (!is.null(pattern)) {
[13:19:59.204]                           computeRestarts <- base::computeRestarts
[13:19:59.204]                           grepl <- base::grepl
[13:19:59.204]                           restarts <- computeRestarts(cond)
[13:19:59.204]                           for (restart in restarts) {
[13:19:59.204]                             name <- restart$name
[13:19:59.204]                             if (is.null(name)) 
[13:19:59.204]                               next
[13:19:59.204]                             if (!grepl(pattern, name)) 
[13:19:59.204]                               next
[13:19:59.204]                             invokeRestart(restart)
[13:19:59.204]                             muffled <- TRUE
[13:19:59.204]                             break
[13:19:59.204]                           }
[13:19:59.204]                         }
[13:19:59.204]                       }
[13:19:59.204]                       invisible(muffled)
[13:19:59.204]                     }
[13:19:59.204]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.204]                   }
[13:19:59.204]                 }
[13:19:59.204]             }
[13:19:59.204]         }))
[13:19:59.204]     }, error = function(ex) {
[13:19:59.204]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.204]                 ...future.rng), started = ...future.startTime, 
[13:19:59.204]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.204]             version = "1.8"), class = "FutureResult")
[13:19:59.204]     }, finally = {
[13:19:59.204]         if (!identical(...future.workdir, getwd())) 
[13:19:59.204]             setwd(...future.workdir)
[13:19:59.204]         {
[13:19:59.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.204]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.204]             }
[13:19:59.204]             base::options(...future.oldOptions)
[13:19:59.204]             if (.Platform$OS.type == "windows") {
[13:19:59.204]                 old_names <- names(...future.oldEnvVars)
[13:19:59.204]                 envs <- base::Sys.getenv()
[13:19:59.204]                 names <- names(envs)
[13:19:59.204]                 common <- intersect(names, old_names)
[13:19:59.204]                 added <- setdiff(names, old_names)
[13:19:59.204]                 removed <- setdiff(old_names, names)
[13:19:59.204]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.204]                   envs[common]]
[13:19:59.204]                 NAMES <- toupper(changed)
[13:19:59.204]                 args <- list()
[13:19:59.204]                 for (kk in seq_along(NAMES)) {
[13:19:59.204]                   name <- changed[[kk]]
[13:19:59.204]                   NAME <- NAMES[[kk]]
[13:19:59.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.204]                     next
[13:19:59.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.204]                 }
[13:19:59.204]                 NAMES <- toupper(added)
[13:19:59.204]                 for (kk in seq_along(NAMES)) {
[13:19:59.204]                   name <- added[[kk]]
[13:19:59.204]                   NAME <- NAMES[[kk]]
[13:19:59.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.204]                     next
[13:19:59.204]                   args[[name]] <- ""
[13:19:59.204]                 }
[13:19:59.204]                 NAMES <- toupper(removed)
[13:19:59.204]                 for (kk in seq_along(NAMES)) {
[13:19:59.204]                   name <- removed[[kk]]
[13:19:59.204]                   NAME <- NAMES[[kk]]
[13:19:59.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.204]                     next
[13:19:59.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.204]                 }
[13:19:59.204]                 if (length(args) > 0) 
[13:19:59.204]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.204]             }
[13:19:59.204]             else {
[13:19:59.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.204]             }
[13:19:59.204]             {
[13:19:59.204]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.204]                   0L) {
[13:19:59.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.204]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.204]                   base::options(opts)
[13:19:59.204]                 }
[13:19:59.204]                 {
[13:19:59.204]                   {
[13:19:59.204]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.204]                     NULL
[13:19:59.204]                   }
[13:19:59.204]                   options(future.plan = NULL)
[13:19:59.204]                   if (is.na(NA_character_)) 
[13:19:59.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.204]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:59.204]                     envir = parent.frame()) 
[13:19:59.204]                   {
[13:19:59.204]                     default_workers <- missing(workers)
[13:19:59.204]                     if (is.function(workers)) 
[13:19:59.204]                       workers <- workers()
[13:19:59.204]                     workers <- structure(as.integer(workers), 
[13:19:59.204]                       class = class(workers))
[13:19:59.204]                     stop_if_not(is.finite(workers), workers >= 
[13:19:59.204]                       1L)
[13:19:59.204]                     if ((workers == 1L && !inherits(workers, 
[13:19:59.204]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:59.204]                       if (default_workers) 
[13:19:59.204]                         supportsMulticore(warn = TRUE)
[13:19:59.204]                       return(sequential(..., envir = envir))
[13:19:59.204]                     }
[13:19:59.204]                     oopts <- options(mc.cores = workers)
[13:19:59.204]                     on.exit(options(oopts))
[13:19:59.204]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:59.204]                       envir = envir)
[13:19:59.204]                     if (!future$lazy) 
[13:19:59.204]                       future <- run(future)
[13:19:59.204]                     invisible(future)
[13:19:59.204]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.204]                 }
[13:19:59.204]             }
[13:19:59.204]         }
[13:19:59.204]     })
[13:19:59.204]     if (TRUE) {
[13:19:59.204]         base::sink(type = "output", split = FALSE)
[13:19:59.204]         if (TRUE) {
[13:19:59.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.204]         }
[13:19:59.204]         else {
[13:19:59.204]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.204]         }
[13:19:59.204]         base::close(...future.stdout)
[13:19:59.204]         ...future.stdout <- NULL
[13:19:59.204]     }
[13:19:59.204]     ...future.result$conditions <- ...future.conditions
[13:19:59.204]     ...future.result$finished <- base::Sys.time()
[13:19:59.204]     ...future.result
[13:19:59.204] }
[13:19:59.206] assign_globals() ...
[13:19:59.207] List of 3
[13:19:59.207]  $ fcn:function (x, y)  
[13:19:59.207]  $ x  : int [1:2] 1 2
[13:19:59.207]  $ y  : num 3
[13:19:59.207]  - attr(*, "where")=List of 3
[13:19:59.207]   ..$ fcn:<environment: R_EmptyEnv> 
[13:19:59.207]   ..$ x  :<environment: R_EmptyEnv> 
[13:19:59.207]   ..$ y  :<environment: R_EmptyEnv> 
[13:19:59.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:59.207]  - attr(*, "resolved")= logi FALSE
[13:19:59.207]  - attr(*, "total_size")= num 4280
[13:19:59.207]  - attr(*, "already-done")= logi TRUE
[13:19:59.211] - reassign environment for ‘fcn’
[13:19:59.211] - copied ‘fcn’ to environment
[13:19:59.211] - copied ‘x’ to environment
[13:19:59.211] - copied ‘y’ to environment
[13:19:59.211] assign_globals() ... done
[13:19:59.211] requestCore(): workers = 2
[13:19:59.213] MulticoreFuture started
[13:19:59.214] - Launch lazy future ... done
[13:19:59.214] run() for ‘MulticoreFuture’ ... done
[13:19:59.215] plan(): Setting new future strategy stack:
[13:19:59.215] List of future strategies:
[13:19:59.215] 1. sequential:
[13:19:59.215]    - args: function (..., envir = parent.frame())
[13:19:59.215]    - tweaked: FALSE
[13:19:59.215]    - call: NULL
[13:19:59.216] plan(): nbrOfWorkers() = 1
[13:19:59.218] plan(): Setting new future strategy stack:
[13:19:59.218] List of future strategies:
[13:19:59.218] 1. multicore:
[13:19:59.218]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:59.218]    - tweaked: FALSE
[13:19:59.218]    - call: plan(strategy, substitute = FALSE)
[13:19:59.223] plan(): nbrOfWorkers() = 2
[1] 6
- plan('multisession') ...
[13:19:59.224] plan(): Setting new future strategy stack:
[13:19:59.224] List of future strategies:
[13:19:59.224] 1. multisession:
[13:19:59.224]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:59.224]    - tweaked: FALSE
[13:19:59.224]    - call: plan(strategy, substitute = FALSE)
[13:19:59.225] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:19:59.225] multisession:
[13:19:59.225] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:59.225] - tweaked: FALSE
[13:19:59.225] - call: plan(strategy, substitute = FALSE)
[13:19:59.232] getGlobalsAndPackages() ...
[13:19:59.233] Not searching for globals
[13:19:59.233] - globals: [0] <none>
[13:19:59.233] getGlobalsAndPackages() ... DONE
[13:19:59.236] [local output] makeClusterPSOCK() ...
[13:19:59.277] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:19:59.283] [local output] Base port: 11203
[13:19:59.283] [local output] Getting setup options for 2 cluster nodes ...
[13:19:59.283] [local output]  - Node 1 of 2 ...
[13:19:59.284] [local output] localMachine=TRUE => revtunnel=FALSE

[13:19:59.284] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMY5dtO/worker.rank=1.parallelly.parent=82327.141976ade099b.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpMY5dtO/worker.rank=1.parallelly.parent=82327.141976ade099b.pid")'’
[13:19:59.474] - Possible to infer worker's PID: TRUE
[13:19:59.475] [local output] Rscript port: 11203

[13:19:59.475] [local output]  - Node 2 of 2 ...
[13:19:59.475] [local output] localMachine=TRUE => revtunnel=FALSE

[13:19:59.476] [local output] Rscript port: 11203

[13:19:59.476] [local output] Getting setup options for 2 cluster nodes ... done
[13:19:59.477] [local output]  - Parallel setup requested for some PSOCK nodes
[13:19:59.477] [local output] Setting up PSOCK nodes in parallel
[13:19:59.477] List of 36
[13:19:59.477]  $ worker          : chr "localhost"
[13:19:59.477]   ..- attr(*, "localhost")= logi TRUE
[13:19:59.477]  $ master          : chr "localhost"
[13:19:59.477]  $ port            : int 11203
[13:19:59.477]  $ connectTimeout  : num 120
[13:19:59.477]  $ timeout         : num 2592000
[13:19:59.477]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:19:59.477]  $ homogeneous     : logi TRUE
[13:19:59.477]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:19:59.477]  $ rscript_envs    : NULL
[13:19:59.477]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:19:59.477]  $ rscript_startup : NULL
[13:19:59.477]  $ rscript_sh      : chr "sh"
[13:19:59.477]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:19:59.477]  $ methods         : logi TRUE
[13:19:59.477]  $ socketOptions   : chr "no-delay"
[13:19:59.477]  $ useXDR          : logi FALSE
[13:19:59.477]  $ outfile         : chr "/dev/null"
[13:19:59.477]  $ renice          : int NA
[13:19:59.477]  $ rshcmd          : NULL
[13:19:59.477]  $ user            : chr(0) 
[13:19:59.477]  $ revtunnel       : logi FALSE
[13:19:59.477]  $ rshlogfile      : NULL
[13:19:59.477]  $ rshopts         : chr(0) 
[13:19:59.477]  $ rank            : int 1
[13:19:59.477]  $ manual          : logi FALSE
[13:19:59.477]  $ dryrun          : logi FALSE
[13:19:59.477]  $ quiet           : logi FALSE
[13:19:59.477]  $ setup_strategy  : chr "parallel"
[13:19:59.477]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:19:59.477]  $ pidfile         : chr "/tmp/RtmpMY5dtO/worker.rank=1.parallelly.parent=82327.141976ade099b.pid"
[13:19:59.477]  $ rshcmd_label    : NULL
[13:19:59.477]  $ rsh_call        : NULL
[13:19:59.477]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:19:59.477]  $ localMachine    : logi TRUE
[13:19:59.477]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:19:59.477]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:19:59.477]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:19:59.477]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:19:59.477]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:19:59.477]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:19:59.477]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:19:59.477]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:19:59.477]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:19:59.477]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:19:59.477]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:19:59.477]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:19:59.477]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:19:59.477]  $ arguments       :List of 28
[13:19:59.477]   ..$ worker          : chr "localhost"
[13:19:59.477]   ..$ master          : NULL
[13:19:59.477]   ..$ port            : int 11203
[13:19:59.477]   ..$ connectTimeout  : num 120
[13:19:59.477]   ..$ timeout         : num 2592000
[13:19:59.477]   ..$ rscript         : NULL
[13:19:59.477]   ..$ homogeneous     : NULL
[13:19:59.477]   ..$ rscript_args    : NULL
[13:19:59.477]   ..$ rscript_envs    : NULL
[13:19:59.477]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:19:59.477]   ..$ rscript_startup : NULL
[13:19:59.477]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:19:59.477]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:19:59.477]   ..$ methods         : logi TRUE
[13:19:59.477]   ..$ socketOptions   : chr "no-delay"
[13:19:59.477]   ..$ useXDR          : logi FALSE
[13:19:59.477]   ..$ outfile         : chr "/dev/null"
[13:19:59.477]   ..$ renice          : int NA
[13:19:59.477]   ..$ rshcmd          : NULL
[13:19:59.477]   ..$ user            : NULL
[13:19:59.477]   ..$ revtunnel       : logi NA
[13:19:59.477]   ..$ rshlogfile      : NULL
[13:19:59.477]   ..$ rshopts         : NULL
[13:19:59.477]   ..$ rank            : int 1
[13:19:59.477]   ..$ manual          : logi FALSE
[13:19:59.477]   ..$ dryrun          : logi FALSE
[13:19:59.477]   ..$ quiet           : logi FALSE
[13:19:59.477]   ..$ setup_strategy  : chr "parallel"
[13:19:59.477]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:19:59.494] [local output] System call to launch all workers:
[13:19:59.494] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMY5dtO/worker.rank=1.parallelly.parent=82327.141976ade099b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11203 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:19:59.494] [local output] Starting PSOCK main server
[13:19:59.495] [local output] Workers launched
[13:19:59.496] [local output] Waiting for workers to connect back
[13:19:59.496]  - [local output] 0 workers out of 2 ready
[13:19:59.742]  - [local output] 0 workers out of 2 ready
[13:19:59.743]  - [local output] 1 workers out of 2 ready
[13:19:59.743]  - [local output] 2 workers out of 2 ready
[13:19:59.743] [local output] Launching of workers completed
[13:19:59.743] [local output] Collecting session information from workers
[13:19:59.744] [local output]  - Worker #1 of 2
[13:19:59.745] [local output]  - Worker #2 of 2
[13:19:59.745] [local output] makeClusterPSOCK() ... done
[13:19:59.757] Packages needed by the future expression (n = 0): <none>
[13:19:59.757] Packages needed by future strategies (n = 0): <none>
[13:19:59.758] {
[13:19:59.758]     {
[13:19:59.758]         {
[13:19:59.758]             ...future.startTime <- base::Sys.time()
[13:19:59.758]             {
[13:19:59.758]                 {
[13:19:59.758]                   {
[13:19:59.758]                     {
[13:19:59.758]                       base::local({
[13:19:59.758]                         has_future <- base::requireNamespace("future", 
[13:19:59.758]                           quietly = TRUE)
[13:19:59.758]                         if (has_future) {
[13:19:59.758]                           ns <- base::getNamespace("future")
[13:19:59.758]                           version <- ns[[".package"]][["version"]]
[13:19:59.758]                           if (is.null(version)) 
[13:19:59.758]                             version <- utils::packageVersion("future")
[13:19:59.758]                         }
[13:19:59.758]                         else {
[13:19:59.758]                           version <- NULL
[13:19:59.758]                         }
[13:19:59.758]                         if (!has_future || version < "1.8.0") {
[13:19:59.758]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.758]                             "", base::R.version$version.string), 
[13:19:59.758]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.758]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.758]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.758]                               "release", "version")], collapse = " "), 
[13:19:59.758]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.758]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.758]                             info)
[13:19:59.758]                           info <- base::paste(info, collapse = "; ")
[13:19:59.758]                           if (!has_future) {
[13:19:59.758]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.758]                               info)
[13:19:59.758]                           }
[13:19:59.758]                           else {
[13:19:59.758]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.758]                               info, version)
[13:19:59.758]                           }
[13:19:59.758]                           base::stop(msg)
[13:19:59.758]                         }
[13:19:59.758]                       })
[13:19:59.758]                     }
[13:19:59.758]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.758]                     base::options(mc.cores = 1L)
[13:19:59.758]                   }
[13:19:59.758]                   options(future.plan = NULL)
[13:19:59.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.758]                 }
[13:19:59.758]                 ...future.workdir <- getwd()
[13:19:59.758]             }
[13:19:59.758]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.758]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.758]         }
[13:19:59.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.758]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:59.758]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.758]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.758]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.758]             base::names(...future.oldOptions))
[13:19:59.758]     }
[13:19:59.758]     if (FALSE) {
[13:19:59.758]     }
[13:19:59.758]     else {
[13:19:59.758]         if (TRUE) {
[13:19:59.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.758]                 open = "w")
[13:19:59.758]         }
[13:19:59.758]         else {
[13:19:59.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.758]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.758]         }
[13:19:59.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.758]             base::sink(type = "output", split = FALSE)
[13:19:59.758]             base::close(...future.stdout)
[13:19:59.758]         }, add = TRUE)
[13:19:59.758]     }
[13:19:59.758]     ...future.frame <- base::sys.nframe()
[13:19:59.758]     ...future.conditions <- base::list()
[13:19:59.758]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.758]     if (FALSE) {
[13:19:59.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.758]     }
[13:19:59.758]     ...future.result <- base::tryCatch({
[13:19:59.758]         base::withCallingHandlers({
[13:19:59.758]             ...future.value <- base::withVisible(base::local({
[13:19:59.758]                 ...future.makeSendCondition <- local({
[13:19:59.758]                   sendCondition <- NULL
[13:19:59.758]                   function(frame = 1L) {
[13:19:59.758]                     if (is.function(sendCondition)) 
[13:19:59.758]                       return(sendCondition)
[13:19:59.758]                     ns <- getNamespace("parallel")
[13:19:59.758]                     if (exists("sendData", mode = "function", 
[13:19:59.758]                       envir = ns)) {
[13:19:59.758]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:59.758]                         envir = ns)
[13:19:59.758]                       envir <- sys.frame(frame)
[13:19:59.758]                       master <- NULL
[13:19:59.758]                       while (!identical(envir, .GlobalEnv) && 
[13:19:59.758]                         !identical(envir, emptyenv())) {
[13:19:59.758]                         if (exists("master", mode = "list", envir = envir, 
[13:19:59.758]                           inherits = FALSE)) {
[13:19:59.758]                           master <- get("master", mode = "list", 
[13:19:59.758]                             envir = envir, inherits = FALSE)
[13:19:59.758]                           if (inherits(master, c("SOCKnode", 
[13:19:59.758]                             "SOCK0node"))) {
[13:19:59.758]                             sendCondition <<- function(cond) {
[13:19:59.758]                               data <- list(type = "VALUE", value = cond, 
[13:19:59.758]                                 success = TRUE)
[13:19:59.758]                               parallel_sendData(master, data)
[13:19:59.758]                             }
[13:19:59.758]                             return(sendCondition)
[13:19:59.758]                           }
[13:19:59.758]                         }
[13:19:59.758]                         frame <- frame + 1L
[13:19:59.758]                         envir <- sys.frame(frame)
[13:19:59.758]                       }
[13:19:59.758]                     }
[13:19:59.758]                     sendCondition <<- function(cond) NULL
[13:19:59.758]                   }
[13:19:59.758]                 })
[13:19:59.758]                 withCallingHandlers({
[13:19:59.758]                   NA
[13:19:59.758]                 }, immediateCondition = function(cond) {
[13:19:59.758]                   sendCondition <- ...future.makeSendCondition()
[13:19:59.758]                   sendCondition(cond)
[13:19:59.758]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.758]                   {
[13:19:59.758]                     inherits <- base::inherits
[13:19:59.758]                     invokeRestart <- base::invokeRestart
[13:19:59.758]                     is.null <- base::is.null
[13:19:59.758]                     muffled <- FALSE
[13:19:59.758]                     if (inherits(cond, "message")) {
[13:19:59.758]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.758]                       if (muffled) 
[13:19:59.758]                         invokeRestart("muffleMessage")
[13:19:59.758]                     }
[13:19:59.758]                     else if (inherits(cond, "warning")) {
[13:19:59.758]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.758]                       if (muffled) 
[13:19:59.758]                         invokeRestart("muffleWarning")
[13:19:59.758]                     }
[13:19:59.758]                     else if (inherits(cond, "condition")) {
[13:19:59.758]                       if (!is.null(pattern)) {
[13:19:59.758]                         computeRestarts <- base::computeRestarts
[13:19:59.758]                         grepl <- base::grepl
[13:19:59.758]                         restarts <- computeRestarts(cond)
[13:19:59.758]                         for (restart in restarts) {
[13:19:59.758]                           name <- restart$name
[13:19:59.758]                           if (is.null(name)) 
[13:19:59.758]                             next
[13:19:59.758]                           if (!grepl(pattern, name)) 
[13:19:59.758]                             next
[13:19:59.758]                           invokeRestart(restart)
[13:19:59.758]                           muffled <- TRUE
[13:19:59.758]                           break
[13:19:59.758]                         }
[13:19:59.758]                       }
[13:19:59.758]                     }
[13:19:59.758]                     invisible(muffled)
[13:19:59.758]                   }
[13:19:59.758]                   muffleCondition(cond)
[13:19:59.758]                 })
[13:19:59.758]             }))
[13:19:59.758]             future::FutureResult(value = ...future.value$value, 
[13:19:59.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.758]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.758]                     ...future.globalenv.names))
[13:19:59.758]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.758]         }, condition = base::local({
[13:19:59.758]             c <- base::c
[13:19:59.758]             inherits <- base::inherits
[13:19:59.758]             invokeRestart <- base::invokeRestart
[13:19:59.758]             length <- base::length
[13:19:59.758]             list <- base::list
[13:19:59.758]             seq.int <- base::seq.int
[13:19:59.758]             signalCondition <- base::signalCondition
[13:19:59.758]             sys.calls <- base::sys.calls
[13:19:59.758]             `[[` <- base::`[[`
[13:19:59.758]             `+` <- base::`+`
[13:19:59.758]             `<<-` <- base::`<<-`
[13:19:59.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.758]                   3L)]
[13:19:59.758]             }
[13:19:59.758]             function(cond) {
[13:19:59.758]                 is_error <- inherits(cond, "error")
[13:19:59.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.758]                   NULL)
[13:19:59.758]                 if (is_error) {
[13:19:59.758]                   sessionInformation <- function() {
[13:19:59.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.758]                       search = base::search(), system = base::Sys.info())
[13:19:59.758]                   }
[13:19:59.758]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.758]                     cond$call), session = sessionInformation(), 
[13:19:59.758]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.758]                   signalCondition(cond)
[13:19:59.758]                 }
[13:19:59.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.758]                 "immediateCondition"))) {
[13:19:59.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.758]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.758]                   if (TRUE && !signal) {
[13:19:59.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.758]                     {
[13:19:59.758]                       inherits <- base::inherits
[13:19:59.758]                       invokeRestart <- base::invokeRestart
[13:19:59.758]                       is.null <- base::is.null
[13:19:59.758]                       muffled <- FALSE
[13:19:59.758]                       if (inherits(cond, "message")) {
[13:19:59.758]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.758]                         if (muffled) 
[13:19:59.758]                           invokeRestart("muffleMessage")
[13:19:59.758]                       }
[13:19:59.758]                       else if (inherits(cond, "warning")) {
[13:19:59.758]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.758]                         if (muffled) 
[13:19:59.758]                           invokeRestart("muffleWarning")
[13:19:59.758]                       }
[13:19:59.758]                       else if (inherits(cond, "condition")) {
[13:19:59.758]                         if (!is.null(pattern)) {
[13:19:59.758]                           computeRestarts <- base::computeRestarts
[13:19:59.758]                           grepl <- base::grepl
[13:19:59.758]                           restarts <- computeRestarts(cond)
[13:19:59.758]                           for (restart in restarts) {
[13:19:59.758]                             name <- restart$name
[13:19:59.758]                             if (is.null(name)) 
[13:19:59.758]                               next
[13:19:59.758]                             if (!grepl(pattern, name)) 
[13:19:59.758]                               next
[13:19:59.758]                             invokeRestart(restart)
[13:19:59.758]                             muffled <- TRUE
[13:19:59.758]                             break
[13:19:59.758]                           }
[13:19:59.758]                         }
[13:19:59.758]                       }
[13:19:59.758]                       invisible(muffled)
[13:19:59.758]                     }
[13:19:59.758]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.758]                   }
[13:19:59.758]                 }
[13:19:59.758]                 else {
[13:19:59.758]                   if (TRUE) {
[13:19:59.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.758]                     {
[13:19:59.758]                       inherits <- base::inherits
[13:19:59.758]                       invokeRestart <- base::invokeRestart
[13:19:59.758]                       is.null <- base::is.null
[13:19:59.758]                       muffled <- FALSE
[13:19:59.758]                       if (inherits(cond, "message")) {
[13:19:59.758]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.758]                         if (muffled) 
[13:19:59.758]                           invokeRestart("muffleMessage")
[13:19:59.758]                       }
[13:19:59.758]                       else if (inherits(cond, "warning")) {
[13:19:59.758]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.758]                         if (muffled) 
[13:19:59.758]                           invokeRestart("muffleWarning")
[13:19:59.758]                       }
[13:19:59.758]                       else if (inherits(cond, "condition")) {
[13:19:59.758]                         if (!is.null(pattern)) {
[13:19:59.758]                           computeRestarts <- base::computeRestarts
[13:19:59.758]                           grepl <- base::grepl
[13:19:59.758]                           restarts <- computeRestarts(cond)
[13:19:59.758]                           for (restart in restarts) {
[13:19:59.758]                             name <- restart$name
[13:19:59.758]                             if (is.null(name)) 
[13:19:59.758]                               next
[13:19:59.758]                             if (!grepl(pattern, name)) 
[13:19:59.758]                               next
[13:19:59.758]                             invokeRestart(restart)
[13:19:59.758]                             muffled <- TRUE
[13:19:59.758]                             break
[13:19:59.758]                           }
[13:19:59.758]                         }
[13:19:59.758]                       }
[13:19:59.758]                       invisible(muffled)
[13:19:59.758]                     }
[13:19:59.758]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.758]                   }
[13:19:59.758]                 }
[13:19:59.758]             }
[13:19:59.758]         }))
[13:19:59.758]     }, error = function(ex) {
[13:19:59.758]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.758]                 ...future.rng), started = ...future.startTime, 
[13:19:59.758]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.758]             version = "1.8"), class = "FutureResult")
[13:19:59.758]     }, finally = {
[13:19:59.758]         if (!identical(...future.workdir, getwd())) 
[13:19:59.758]             setwd(...future.workdir)
[13:19:59.758]         {
[13:19:59.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.758]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.758]             }
[13:19:59.758]             base::options(...future.oldOptions)
[13:19:59.758]             if (.Platform$OS.type == "windows") {
[13:19:59.758]                 old_names <- names(...future.oldEnvVars)
[13:19:59.758]                 envs <- base::Sys.getenv()
[13:19:59.758]                 names <- names(envs)
[13:19:59.758]                 common <- intersect(names, old_names)
[13:19:59.758]                 added <- setdiff(names, old_names)
[13:19:59.758]                 removed <- setdiff(old_names, names)
[13:19:59.758]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.758]                   envs[common]]
[13:19:59.758]                 NAMES <- toupper(changed)
[13:19:59.758]                 args <- list()
[13:19:59.758]                 for (kk in seq_along(NAMES)) {
[13:19:59.758]                   name <- changed[[kk]]
[13:19:59.758]                   NAME <- NAMES[[kk]]
[13:19:59.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.758]                     next
[13:19:59.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.758]                 }
[13:19:59.758]                 NAMES <- toupper(added)
[13:19:59.758]                 for (kk in seq_along(NAMES)) {
[13:19:59.758]                   name <- added[[kk]]
[13:19:59.758]                   NAME <- NAMES[[kk]]
[13:19:59.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.758]                     next
[13:19:59.758]                   args[[name]] <- ""
[13:19:59.758]                 }
[13:19:59.758]                 NAMES <- toupper(removed)
[13:19:59.758]                 for (kk in seq_along(NAMES)) {
[13:19:59.758]                   name <- removed[[kk]]
[13:19:59.758]                   NAME <- NAMES[[kk]]
[13:19:59.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.758]                     next
[13:19:59.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.758]                 }
[13:19:59.758]                 if (length(args) > 0) 
[13:19:59.758]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.758]             }
[13:19:59.758]             else {
[13:19:59.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.758]             }
[13:19:59.758]             {
[13:19:59.758]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.758]                   0L) {
[13:19:59.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.758]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.758]                   base::options(opts)
[13:19:59.758]                 }
[13:19:59.758]                 {
[13:19:59.758]                   {
[13:19:59.758]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.758]                     NULL
[13:19:59.758]                   }
[13:19:59.758]                   options(future.plan = NULL)
[13:19:59.758]                   if (is.na(NA_character_)) 
[13:19:59.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.758]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:59.758]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:59.758]                     envir = parent.frame()) 
[13:19:59.758]                   {
[13:19:59.758]                     if (is.function(workers)) 
[13:19:59.758]                       workers <- workers()
[13:19:59.758]                     workers <- structure(as.integer(workers), 
[13:19:59.758]                       class = class(workers))
[13:19:59.758]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:59.758]                       workers >= 1)
[13:19:59.758]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:59.758]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:59.758]                     }
[13:19:59.758]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:59.758]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:59.758]                       envir = envir)
[13:19:59.758]                     if (!future$lazy) 
[13:19:59.758]                       future <- run(future)
[13:19:59.758]                     invisible(future)
[13:19:59.758]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.758]                 }
[13:19:59.758]             }
[13:19:59.758]         }
[13:19:59.758]     })
[13:19:59.758]     if (TRUE) {
[13:19:59.758]         base::sink(type = "output", split = FALSE)
[13:19:59.758]         if (TRUE) {
[13:19:59.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.758]         }
[13:19:59.758]         else {
[13:19:59.758]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.758]         }
[13:19:59.758]         base::close(...future.stdout)
[13:19:59.758]         ...future.stdout <- NULL
[13:19:59.758]     }
[13:19:59.758]     ...future.result$conditions <- ...future.conditions
[13:19:59.758]     ...future.result$finished <- base::Sys.time()
[13:19:59.758]     ...future.result
[13:19:59.758] }
[13:19:59.831] MultisessionFuture started
[13:19:59.831] result() for ClusterFuture ...
[13:19:59.832] receiveMessageFromWorker() for ClusterFuture ...
[13:19:59.832] - Validating connection of MultisessionFuture
[13:19:59.865] - received message: FutureResult
[13:19:59.865] - Received FutureResult
[13:19:59.865] - Erased future from FutureRegistry
[13:19:59.866] result() for ClusterFuture ...
[13:19:59.866] - result already collected: FutureResult
[13:19:59.866] result() for ClusterFuture ... done
[13:19:59.866] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:59.866] result() for ClusterFuture ... done
[13:19:59.866] result() for ClusterFuture ...
[13:19:59.866] - result already collected: FutureResult
[13:19:59.866] result() for ClusterFuture ... done
[13:19:59.867] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:19:59.870] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multisession') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x56222563c7b8>
Arguments '...' exists: TRUE
[13:19:59.871] getGlobalsAndPackages() ...
[13:19:59.871] Searching for globals...
[13:19:59.873] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[13:19:59.873] Searching for globals ... DONE
[13:19:59.873] Resolving globals: FALSE
[13:19:59.873] Tweak future expression to call with '...' arguments ...
[13:19:59.873] {
[13:19:59.873]     do.call(function(...) {
[13:19:59.873]         sum(x, ...)
[13:19:59.873]     }, args = future.call.arguments)
[13:19:59.873] }
[13:19:59.874] Tweak future expression to call with '...' arguments ... DONE
[13:19:59.874] The total size of the 2 globals is 112 bytes (112 bytes)
[13:19:59.875] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[13:19:59.875] - globals: [2] ‘x’, ‘future.call.arguments’
[13:19:59.875] 
[13:19:59.875] getGlobalsAndPackages() ... DONE
[13:19:59.876] run() for ‘Future’ ...
[13:19:59.876] - state: ‘created’
[13:19:59.876] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.891] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.891] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:59.891]   - Field: ‘node’
[13:19:59.891]   - Field: ‘label’
[13:19:59.891]   - Field: ‘local’
[13:19:59.891]   - Field: ‘owner’
[13:19:59.892]   - Field: ‘envir’
[13:19:59.892]   - Field: ‘workers’
[13:19:59.892]   - Field: ‘packages’
[13:19:59.892]   - Field: ‘gc’
[13:19:59.892]   - Field: ‘conditions’
[13:19:59.892]   - Field: ‘persistent’
[13:19:59.892]   - Field: ‘expr’
[13:19:59.892]   - Field: ‘uuid’
[13:19:59.893]   - Field: ‘seed’
[13:19:59.893]   - Field: ‘version’
[13:19:59.893]   - Field: ‘result’
[13:19:59.893]   - Field: ‘asynchronous’
[13:19:59.893]   - Field: ‘calls’
[13:19:59.893]   - Field: ‘globals’
[13:19:59.893]   - Field: ‘stdout’
[13:19:59.894]   - Field: ‘earlySignal’
[13:19:59.894]   - Field: ‘lazy’
[13:19:59.894]   - Field: ‘state’
[13:19:59.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:59.894] - Launch lazy future ...
[13:19:59.895] Packages needed by the future expression (n = 0): <none>
[13:19:59.895] Packages needed by future strategies (n = 0): <none>
[13:19:59.895] {
[13:19:59.895]     {
[13:19:59.895]         {
[13:19:59.895]             ...future.startTime <- base::Sys.time()
[13:19:59.895]             {
[13:19:59.895]                 {
[13:19:59.895]                   {
[13:19:59.895]                     {
[13:19:59.895]                       base::local({
[13:19:59.895]                         has_future <- base::requireNamespace("future", 
[13:19:59.895]                           quietly = TRUE)
[13:19:59.895]                         if (has_future) {
[13:19:59.895]                           ns <- base::getNamespace("future")
[13:19:59.895]                           version <- ns[[".package"]][["version"]]
[13:19:59.895]                           if (is.null(version)) 
[13:19:59.895]                             version <- utils::packageVersion("future")
[13:19:59.895]                         }
[13:19:59.895]                         else {
[13:19:59.895]                           version <- NULL
[13:19:59.895]                         }
[13:19:59.895]                         if (!has_future || version < "1.8.0") {
[13:19:59.895]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.895]                             "", base::R.version$version.string), 
[13:19:59.895]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.895]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.895]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.895]                               "release", "version")], collapse = " "), 
[13:19:59.895]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.895]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.895]                             info)
[13:19:59.895]                           info <- base::paste(info, collapse = "; ")
[13:19:59.895]                           if (!has_future) {
[13:19:59.895]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.895]                               info)
[13:19:59.895]                           }
[13:19:59.895]                           else {
[13:19:59.895]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.895]                               info, version)
[13:19:59.895]                           }
[13:19:59.895]                           base::stop(msg)
[13:19:59.895]                         }
[13:19:59.895]                       })
[13:19:59.895]                     }
[13:19:59.895]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.895]                     base::options(mc.cores = 1L)
[13:19:59.895]                   }
[13:19:59.895]                   options(future.plan = NULL)
[13:19:59.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.895]                 }
[13:19:59.895]                 ...future.workdir <- getwd()
[13:19:59.895]             }
[13:19:59.895]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.895]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.895]         }
[13:19:59.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:59.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.895]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.895]             base::names(...future.oldOptions))
[13:19:59.895]     }
[13:19:59.895]     if (FALSE) {
[13:19:59.895]     }
[13:19:59.895]     else {
[13:19:59.895]         if (TRUE) {
[13:19:59.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.895]                 open = "w")
[13:19:59.895]         }
[13:19:59.895]         else {
[13:19:59.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.895]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.895]         }
[13:19:59.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.895]             base::sink(type = "output", split = FALSE)
[13:19:59.895]             base::close(...future.stdout)
[13:19:59.895]         }, add = TRUE)
[13:19:59.895]     }
[13:19:59.895]     ...future.frame <- base::sys.nframe()
[13:19:59.895]     ...future.conditions <- base::list()
[13:19:59.895]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.895]     if (FALSE) {
[13:19:59.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.895]     }
[13:19:59.895]     ...future.result <- base::tryCatch({
[13:19:59.895]         base::withCallingHandlers({
[13:19:59.895]             ...future.value <- base::withVisible(base::local({
[13:19:59.895]                 ...future.makeSendCondition <- local({
[13:19:59.895]                   sendCondition <- NULL
[13:19:59.895]                   function(frame = 1L) {
[13:19:59.895]                     if (is.function(sendCondition)) 
[13:19:59.895]                       return(sendCondition)
[13:19:59.895]                     ns <- getNamespace("parallel")
[13:19:59.895]                     if (exists("sendData", mode = "function", 
[13:19:59.895]                       envir = ns)) {
[13:19:59.895]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:59.895]                         envir = ns)
[13:19:59.895]                       envir <- sys.frame(frame)
[13:19:59.895]                       master <- NULL
[13:19:59.895]                       while (!identical(envir, .GlobalEnv) && 
[13:19:59.895]                         !identical(envir, emptyenv())) {
[13:19:59.895]                         if (exists("master", mode = "list", envir = envir, 
[13:19:59.895]                           inherits = FALSE)) {
[13:19:59.895]                           master <- get("master", mode = "list", 
[13:19:59.895]                             envir = envir, inherits = FALSE)
[13:19:59.895]                           if (inherits(master, c("SOCKnode", 
[13:19:59.895]                             "SOCK0node"))) {
[13:19:59.895]                             sendCondition <<- function(cond) {
[13:19:59.895]                               data <- list(type = "VALUE", value = cond, 
[13:19:59.895]                                 success = TRUE)
[13:19:59.895]                               parallel_sendData(master, data)
[13:19:59.895]                             }
[13:19:59.895]                             return(sendCondition)
[13:19:59.895]                           }
[13:19:59.895]                         }
[13:19:59.895]                         frame <- frame + 1L
[13:19:59.895]                         envir <- sys.frame(frame)
[13:19:59.895]                       }
[13:19:59.895]                     }
[13:19:59.895]                     sendCondition <<- function(cond) NULL
[13:19:59.895]                   }
[13:19:59.895]                 })
[13:19:59.895]                 withCallingHandlers({
[13:19:59.895]                   {
[13:19:59.895]                     do.call(function(...) {
[13:19:59.895]                       sum(x, ...)
[13:19:59.895]                     }, args = future.call.arguments)
[13:19:59.895]                   }
[13:19:59.895]                 }, immediateCondition = function(cond) {
[13:19:59.895]                   sendCondition <- ...future.makeSendCondition()
[13:19:59.895]                   sendCondition(cond)
[13:19:59.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.895]                   {
[13:19:59.895]                     inherits <- base::inherits
[13:19:59.895]                     invokeRestart <- base::invokeRestart
[13:19:59.895]                     is.null <- base::is.null
[13:19:59.895]                     muffled <- FALSE
[13:19:59.895]                     if (inherits(cond, "message")) {
[13:19:59.895]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.895]                       if (muffled) 
[13:19:59.895]                         invokeRestart("muffleMessage")
[13:19:59.895]                     }
[13:19:59.895]                     else if (inherits(cond, "warning")) {
[13:19:59.895]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.895]                       if (muffled) 
[13:19:59.895]                         invokeRestart("muffleWarning")
[13:19:59.895]                     }
[13:19:59.895]                     else if (inherits(cond, "condition")) {
[13:19:59.895]                       if (!is.null(pattern)) {
[13:19:59.895]                         computeRestarts <- base::computeRestarts
[13:19:59.895]                         grepl <- base::grepl
[13:19:59.895]                         restarts <- computeRestarts(cond)
[13:19:59.895]                         for (restart in restarts) {
[13:19:59.895]                           name <- restart$name
[13:19:59.895]                           if (is.null(name)) 
[13:19:59.895]                             next
[13:19:59.895]                           if (!grepl(pattern, name)) 
[13:19:59.895]                             next
[13:19:59.895]                           invokeRestart(restart)
[13:19:59.895]                           muffled <- TRUE
[13:19:59.895]                           break
[13:19:59.895]                         }
[13:19:59.895]                       }
[13:19:59.895]                     }
[13:19:59.895]                     invisible(muffled)
[13:19:59.895]                   }
[13:19:59.895]                   muffleCondition(cond)
[13:19:59.895]                 })
[13:19:59.895]             }))
[13:19:59.895]             future::FutureResult(value = ...future.value$value, 
[13:19:59.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.895]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.895]                     ...future.globalenv.names))
[13:19:59.895]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.895]         }, condition = base::local({
[13:19:59.895]             c <- base::c
[13:19:59.895]             inherits <- base::inherits
[13:19:59.895]             invokeRestart <- base::invokeRestart
[13:19:59.895]             length <- base::length
[13:19:59.895]             list <- base::list
[13:19:59.895]             seq.int <- base::seq.int
[13:19:59.895]             signalCondition <- base::signalCondition
[13:19:59.895]             sys.calls <- base::sys.calls
[13:19:59.895]             `[[` <- base::`[[`
[13:19:59.895]             `+` <- base::`+`
[13:19:59.895]             `<<-` <- base::`<<-`
[13:19:59.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.895]                   3L)]
[13:19:59.895]             }
[13:19:59.895]             function(cond) {
[13:19:59.895]                 is_error <- inherits(cond, "error")
[13:19:59.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.895]                   NULL)
[13:19:59.895]                 if (is_error) {
[13:19:59.895]                   sessionInformation <- function() {
[13:19:59.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.895]                       search = base::search(), system = base::Sys.info())
[13:19:59.895]                   }
[13:19:59.895]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.895]                     cond$call), session = sessionInformation(), 
[13:19:59.895]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.895]                   signalCondition(cond)
[13:19:59.895]                 }
[13:19:59.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.895]                 "immediateCondition"))) {
[13:19:59.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.895]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.895]                   if (TRUE && !signal) {
[13:19:59.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.895]                     {
[13:19:59.895]                       inherits <- base::inherits
[13:19:59.895]                       invokeRestart <- base::invokeRestart
[13:19:59.895]                       is.null <- base::is.null
[13:19:59.895]                       muffled <- FALSE
[13:19:59.895]                       if (inherits(cond, "message")) {
[13:19:59.895]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.895]                         if (muffled) 
[13:19:59.895]                           invokeRestart("muffleMessage")
[13:19:59.895]                       }
[13:19:59.895]                       else if (inherits(cond, "warning")) {
[13:19:59.895]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.895]                         if (muffled) 
[13:19:59.895]                           invokeRestart("muffleWarning")
[13:19:59.895]                       }
[13:19:59.895]                       else if (inherits(cond, "condition")) {
[13:19:59.895]                         if (!is.null(pattern)) {
[13:19:59.895]                           computeRestarts <- base::computeRestarts
[13:19:59.895]                           grepl <- base::grepl
[13:19:59.895]                           restarts <- computeRestarts(cond)
[13:19:59.895]                           for (restart in restarts) {
[13:19:59.895]                             name <- restart$name
[13:19:59.895]                             if (is.null(name)) 
[13:19:59.895]                               next
[13:19:59.895]                             if (!grepl(pattern, name)) 
[13:19:59.895]                               next
[13:19:59.895]                             invokeRestart(restart)
[13:19:59.895]                             muffled <- TRUE
[13:19:59.895]                             break
[13:19:59.895]                           }
[13:19:59.895]                         }
[13:19:59.895]                       }
[13:19:59.895]                       invisible(muffled)
[13:19:59.895]                     }
[13:19:59.895]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.895]                   }
[13:19:59.895]                 }
[13:19:59.895]                 else {
[13:19:59.895]                   if (TRUE) {
[13:19:59.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.895]                     {
[13:19:59.895]                       inherits <- base::inherits
[13:19:59.895]                       invokeRestart <- base::invokeRestart
[13:19:59.895]                       is.null <- base::is.null
[13:19:59.895]                       muffled <- FALSE
[13:19:59.895]                       if (inherits(cond, "message")) {
[13:19:59.895]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.895]                         if (muffled) 
[13:19:59.895]                           invokeRestart("muffleMessage")
[13:19:59.895]                       }
[13:19:59.895]                       else if (inherits(cond, "warning")) {
[13:19:59.895]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.895]                         if (muffled) 
[13:19:59.895]                           invokeRestart("muffleWarning")
[13:19:59.895]                       }
[13:19:59.895]                       else if (inherits(cond, "condition")) {
[13:19:59.895]                         if (!is.null(pattern)) {
[13:19:59.895]                           computeRestarts <- base::computeRestarts
[13:19:59.895]                           grepl <- base::grepl
[13:19:59.895]                           restarts <- computeRestarts(cond)
[13:19:59.895]                           for (restart in restarts) {
[13:19:59.895]                             name <- restart$name
[13:19:59.895]                             if (is.null(name)) 
[13:19:59.895]                               next
[13:19:59.895]                             if (!grepl(pattern, name)) 
[13:19:59.895]                               next
[13:19:59.895]                             invokeRestart(restart)
[13:19:59.895]                             muffled <- TRUE
[13:19:59.895]                             break
[13:19:59.895]                           }
[13:19:59.895]                         }
[13:19:59.895]                       }
[13:19:59.895]                       invisible(muffled)
[13:19:59.895]                     }
[13:19:59.895]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.895]                   }
[13:19:59.895]                 }
[13:19:59.895]             }
[13:19:59.895]         }))
[13:19:59.895]     }, error = function(ex) {
[13:19:59.895]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.895]                 ...future.rng), started = ...future.startTime, 
[13:19:59.895]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.895]             version = "1.8"), class = "FutureResult")
[13:19:59.895]     }, finally = {
[13:19:59.895]         if (!identical(...future.workdir, getwd())) 
[13:19:59.895]             setwd(...future.workdir)
[13:19:59.895]         {
[13:19:59.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.895]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.895]             }
[13:19:59.895]             base::options(...future.oldOptions)
[13:19:59.895]             if (.Platform$OS.type == "windows") {
[13:19:59.895]                 old_names <- names(...future.oldEnvVars)
[13:19:59.895]                 envs <- base::Sys.getenv()
[13:19:59.895]                 names <- names(envs)
[13:19:59.895]                 common <- intersect(names, old_names)
[13:19:59.895]                 added <- setdiff(names, old_names)
[13:19:59.895]                 removed <- setdiff(old_names, names)
[13:19:59.895]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.895]                   envs[common]]
[13:19:59.895]                 NAMES <- toupper(changed)
[13:19:59.895]                 args <- list()
[13:19:59.895]                 for (kk in seq_along(NAMES)) {
[13:19:59.895]                   name <- changed[[kk]]
[13:19:59.895]                   NAME <- NAMES[[kk]]
[13:19:59.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.895]                     next
[13:19:59.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.895]                 }
[13:19:59.895]                 NAMES <- toupper(added)
[13:19:59.895]                 for (kk in seq_along(NAMES)) {
[13:19:59.895]                   name <- added[[kk]]
[13:19:59.895]                   NAME <- NAMES[[kk]]
[13:19:59.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.895]                     next
[13:19:59.895]                   args[[name]] <- ""
[13:19:59.895]                 }
[13:19:59.895]                 NAMES <- toupper(removed)
[13:19:59.895]                 for (kk in seq_along(NAMES)) {
[13:19:59.895]                   name <- removed[[kk]]
[13:19:59.895]                   NAME <- NAMES[[kk]]
[13:19:59.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.895]                     next
[13:19:59.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.895]                 }
[13:19:59.895]                 if (length(args) > 0) 
[13:19:59.895]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.895]             }
[13:19:59.895]             else {
[13:19:59.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.895]             }
[13:19:59.895]             {
[13:19:59.895]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.895]                   0L) {
[13:19:59.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.895]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.895]                   base::options(opts)
[13:19:59.895]                 }
[13:19:59.895]                 {
[13:19:59.895]                   {
[13:19:59.895]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.895]                     NULL
[13:19:59.895]                   }
[13:19:59.895]                   options(future.plan = NULL)
[13:19:59.895]                   if (is.na(NA_character_)) 
[13:19:59.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.895]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:59.895]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:59.895]                     envir = parent.frame()) 
[13:19:59.895]                   {
[13:19:59.895]                     if (is.function(workers)) 
[13:19:59.895]                       workers <- workers()
[13:19:59.895]                     workers <- structure(as.integer(workers), 
[13:19:59.895]                       class = class(workers))
[13:19:59.895]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:59.895]                       workers >= 1)
[13:19:59.895]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:59.895]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:59.895]                     }
[13:19:59.895]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:59.895]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:59.895]                       envir = envir)
[13:19:59.895]                     if (!future$lazy) 
[13:19:59.895]                       future <- run(future)
[13:19:59.895]                     invisible(future)
[13:19:59.895]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.895]                 }
[13:19:59.895]             }
[13:19:59.895]         }
[13:19:59.895]     })
[13:19:59.895]     if (TRUE) {
[13:19:59.895]         base::sink(type = "output", split = FALSE)
[13:19:59.895]         if (TRUE) {
[13:19:59.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.895]         }
[13:19:59.895]         else {
[13:19:59.895]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.895]         }
[13:19:59.895]         base::close(...future.stdout)
[13:19:59.895]         ...future.stdout <- NULL
[13:19:59.895]     }
[13:19:59.895]     ...future.result$conditions <- ...future.conditions
[13:19:59.895]     ...future.result$finished <- base::Sys.time()
[13:19:59.895]     ...future.result
[13:19:59.895] }
[13:19:59.898] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:19:59.899] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[13:19:59.899] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[13:19:59.899] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[13:19:59.900] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[13:19:59.900] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:19:59.901] MultisessionFuture started
[13:19:59.901] - Launch lazy future ... done
[13:19:59.901] run() for ‘MultisessionFuture’ ... done
[13:19:59.901] result() for ClusterFuture ...
[13:19:59.901] receiveMessageFromWorker() for ClusterFuture ...
[13:19:59.901] - Validating connection of MultisessionFuture
[13:19:59.950] - received message: FutureResult
[13:19:59.950] - Received FutureResult
[13:19:59.950] - Erased future from FutureRegistry
[13:19:59.950] result() for ClusterFuture ...
[13:19:59.950] - result already collected: FutureResult
[13:19:59.950] result() for ClusterFuture ... done
[13:19:59.950] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:59.950] result() for ClusterFuture ... done
[13:19:59.951] result() for ClusterFuture ...
[13:19:59.951] - result already collected: FutureResult
[13:19:59.951] result() for ClusterFuture ... done
[1] 6
** Sum function 'B' with plan('multisession') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x56222593d7d0>
Arguments '...' exists: TRUE
[13:19:59.952] getGlobalsAndPackages() ...
[13:19:59.952] Searching for globals...
[13:19:59.953] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[13:19:59.954] Searching for globals ... DONE
[13:19:59.954] Resolving globals: FALSE
[13:19:59.954] Tweak future expression to call with '...' arguments ...
[13:19:59.954] {
[13:19:59.954]     do.call(function(...) {
[13:19:59.954]         sum(x, ...)
[13:19:59.954]     }, args = future.call.arguments)
[13:19:59.954] }
[13:19:59.954] Tweak future expression to call with '...' arguments ... DONE
[13:19:59.955] The total size of the 2 globals is 112 bytes (112 bytes)
[13:19:59.955] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[13:19:59.955] - globals: [2] ‘x’, ‘future.call.arguments’
[13:19:59.956] 
[13:19:59.956] getGlobalsAndPackages() ... DONE
[13:19:59.956] run() for ‘Future’ ...
[13:19:59.956] - state: ‘created’
[13:19:59.956] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:59.971] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:59.971] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:59.972]   - Field: ‘node’
[13:19:59.972]   - Field: ‘label’
[13:19:59.972]   - Field: ‘local’
[13:19:59.972]   - Field: ‘owner’
[13:19:59.972]   - Field: ‘envir’
[13:19:59.972]   - Field: ‘workers’
[13:19:59.972]   - Field: ‘packages’
[13:19:59.972]   - Field: ‘gc’
[13:19:59.972]   - Field: ‘conditions’
[13:19:59.972]   - Field: ‘persistent’
[13:19:59.973]   - Field: ‘expr’
[13:19:59.973]   - Field: ‘uuid’
[13:19:59.973]   - Field: ‘seed’
[13:19:59.973]   - Field: ‘version’
[13:19:59.973]   - Field: ‘result’
[13:19:59.973]   - Field: ‘asynchronous’
[13:19:59.973]   - Field: ‘calls’
[13:19:59.973]   - Field: ‘globals’
[13:19:59.974]   - Field: ‘stdout’
[13:19:59.974]   - Field: ‘earlySignal’
[13:19:59.974]   - Field: ‘lazy’
[13:19:59.974]   - Field: ‘state’
[13:19:59.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:59.974] - Launch lazy future ...
[13:19:59.974] Packages needed by the future expression (n = 0): <none>
[13:19:59.975] Packages needed by future strategies (n = 0): <none>
[13:19:59.975] {
[13:19:59.975]     {
[13:19:59.975]         {
[13:19:59.975]             ...future.startTime <- base::Sys.time()
[13:19:59.975]             {
[13:19:59.975]                 {
[13:19:59.975]                   {
[13:19:59.975]                     {
[13:19:59.975]                       base::local({
[13:19:59.975]                         has_future <- base::requireNamespace("future", 
[13:19:59.975]                           quietly = TRUE)
[13:19:59.975]                         if (has_future) {
[13:19:59.975]                           ns <- base::getNamespace("future")
[13:19:59.975]                           version <- ns[[".package"]][["version"]]
[13:19:59.975]                           if (is.null(version)) 
[13:19:59.975]                             version <- utils::packageVersion("future")
[13:19:59.975]                         }
[13:19:59.975]                         else {
[13:19:59.975]                           version <- NULL
[13:19:59.975]                         }
[13:19:59.975]                         if (!has_future || version < "1.8.0") {
[13:19:59.975]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:59.975]                             "", base::R.version$version.string), 
[13:19:59.975]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:59.975]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:59.975]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:59.975]                               "release", "version")], collapse = " "), 
[13:19:59.975]                             hostname = base::Sys.info()[["nodename"]])
[13:19:59.975]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:59.975]                             info)
[13:19:59.975]                           info <- base::paste(info, collapse = "; ")
[13:19:59.975]                           if (!has_future) {
[13:19:59.975]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:59.975]                               info)
[13:19:59.975]                           }
[13:19:59.975]                           else {
[13:19:59.975]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:59.975]                               info, version)
[13:19:59.975]                           }
[13:19:59.975]                           base::stop(msg)
[13:19:59.975]                         }
[13:19:59.975]                       })
[13:19:59.975]                     }
[13:19:59.975]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:59.975]                     base::options(mc.cores = 1L)
[13:19:59.975]                   }
[13:19:59.975]                   options(future.plan = NULL)
[13:19:59.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:59.975]                 }
[13:19:59.975]                 ...future.workdir <- getwd()
[13:19:59.975]             }
[13:19:59.975]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:59.975]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:59.975]         }
[13:19:59.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:59.975]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:59.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:59.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:59.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:59.975]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:59.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:59.975]             base::names(...future.oldOptions))
[13:19:59.975]     }
[13:19:59.975]     if (FALSE) {
[13:19:59.975]     }
[13:19:59.975]     else {
[13:19:59.975]         if (TRUE) {
[13:19:59.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:59.975]                 open = "w")
[13:19:59.975]         }
[13:19:59.975]         else {
[13:19:59.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:59.975]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:59.975]         }
[13:19:59.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:59.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:59.975]             base::sink(type = "output", split = FALSE)
[13:19:59.975]             base::close(...future.stdout)
[13:19:59.975]         }, add = TRUE)
[13:19:59.975]     }
[13:19:59.975]     ...future.frame <- base::sys.nframe()
[13:19:59.975]     ...future.conditions <- base::list()
[13:19:59.975]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:59.975]     if (FALSE) {
[13:19:59.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:59.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:59.975]     }
[13:19:59.975]     ...future.result <- base::tryCatch({
[13:19:59.975]         base::withCallingHandlers({
[13:19:59.975]             ...future.value <- base::withVisible(base::local({
[13:19:59.975]                 ...future.makeSendCondition <- local({
[13:19:59.975]                   sendCondition <- NULL
[13:19:59.975]                   function(frame = 1L) {
[13:19:59.975]                     if (is.function(sendCondition)) 
[13:19:59.975]                       return(sendCondition)
[13:19:59.975]                     ns <- getNamespace("parallel")
[13:19:59.975]                     if (exists("sendData", mode = "function", 
[13:19:59.975]                       envir = ns)) {
[13:19:59.975]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:59.975]                         envir = ns)
[13:19:59.975]                       envir <- sys.frame(frame)
[13:19:59.975]                       master <- NULL
[13:19:59.975]                       while (!identical(envir, .GlobalEnv) && 
[13:19:59.975]                         !identical(envir, emptyenv())) {
[13:19:59.975]                         if (exists("master", mode = "list", envir = envir, 
[13:19:59.975]                           inherits = FALSE)) {
[13:19:59.975]                           master <- get("master", mode = "list", 
[13:19:59.975]                             envir = envir, inherits = FALSE)
[13:19:59.975]                           if (inherits(master, c("SOCKnode", 
[13:19:59.975]                             "SOCK0node"))) {
[13:19:59.975]                             sendCondition <<- function(cond) {
[13:19:59.975]                               data <- list(type = "VALUE", value = cond, 
[13:19:59.975]                                 success = TRUE)
[13:19:59.975]                               parallel_sendData(master, data)
[13:19:59.975]                             }
[13:19:59.975]                             return(sendCondition)
[13:19:59.975]                           }
[13:19:59.975]                         }
[13:19:59.975]                         frame <- frame + 1L
[13:19:59.975]                         envir <- sys.frame(frame)
[13:19:59.975]                       }
[13:19:59.975]                     }
[13:19:59.975]                     sendCondition <<- function(cond) NULL
[13:19:59.975]                   }
[13:19:59.975]                 })
[13:19:59.975]                 withCallingHandlers({
[13:19:59.975]                   {
[13:19:59.975]                     do.call(function(...) {
[13:19:59.975]                       sum(x, ...)
[13:19:59.975]                     }, args = future.call.arguments)
[13:19:59.975]                   }
[13:19:59.975]                 }, immediateCondition = function(cond) {
[13:19:59.975]                   sendCondition <- ...future.makeSendCondition()
[13:19:59.975]                   sendCondition(cond)
[13:19:59.975]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.975]                   {
[13:19:59.975]                     inherits <- base::inherits
[13:19:59.975]                     invokeRestart <- base::invokeRestart
[13:19:59.975]                     is.null <- base::is.null
[13:19:59.975]                     muffled <- FALSE
[13:19:59.975]                     if (inherits(cond, "message")) {
[13:19:59.975]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:59.975]                       if (muffled) 
[13:19:59.975]                         invokeRestart("muffleMessage")
[13:19:59.975]                     }
[13:19:59.975]                     else if (inherits(cond, "warning")) {
[13:19:59.975]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:59.975]                       if (muffled) 
[13:19:59.975]                         invokeRestart("muffleWarning")
[13:19:59.975]                     }
[13:19:59.975]                     else if (inherits(cond, "condition")) {
[13:19:59.975]                       if (!is.null(pattern)) {
[13:19:59.975]                         computeRestarts <- base::computeRestarts
[13:19:59.975]                         grepl <- base::grepl
[13:19:59.975]                         restarts <- computeRestarts(cond)
[13:19:59.975]                         for (restart in restarts) {
[13:19:59.975]                           name <- restart$name
[13:19:59.975]                           if (is.null(name)) 
[13:19:59.975]                             next
[13:19:59.975]                           if (!grepl(pattern, name)) 
[13:19:59.975]                             next
[13:19:59.975]                           invokeRestart(restart)
[13:19:59.975]                           muffled <- TRUE
[13:19:59.975]                           break
[13:19:59.975]                         }
[13:19:59.975]                       }
[13:19:59.975]                     }
[13:19:59.975]                     invisible(muffled)
[13:19:59.975]                   }
[13:19:59.975]                   muffleCondition(cond)
[13:19:59.975]                 })
[13:19:59.975]             }))
[13:19:59.975]             future::FutureResult(value = ...future.value$value, 
[13:19:59.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.975]                   ...future.rng), globalenv = if (FALSE) 
[13:19:59.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:59.975]                     ...future.globalenv.names))
[13:19:59.975]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:59.975]         }, condition = base::local({
[13:19:59.975]             c <- base::c
[13:19:59.975]             inherits <- base::inherits
[13:19:59.975]             invokeRestart <- base::invokeRestart
[13:19:59.975]             length <- base::length
[13:19:59.975]             list <- base::list
[13:19:59.975]             seq.int <- base::seq.int
[13:19:59.975]             signalCondition <- base::signalCondition
[13:19:59.975]             sys.calls <- base::sys.calls
[13:19:59.975]             `[[` <- base::`[[`
[13:19:59.975]             `+` <- base::`+`
[13:19:59.975]             `<<-` <- base::`<<-`
[13:19:59.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:59.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:59.975]                   3L)]
[13:19:59.975]             }
[13:19:59.975]             function(cond) {
[13:19:59.975]                 is_error <- inherits(cond, "error")
[13:19:59.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:59.975]                   NULL)
[13:19:59.975]                 if (is_error) {
[13:19:59.975]                   sessionInformation <- function() {
[13:19:59.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:59.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:59.975]                       search = base::search(), system = base::Sys.info())
[13:19:59.975]                   }
[13:19:59.975]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:59.975]                     cond$call), session = sessionInformation(), 
[13:19:59.975]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:59.975]                   signalCondition(cond)
[13:19:59.975]                 }
[13:19:59.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:59.975]                 "immediateCondition"))) {
[13:19:59.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:59.975]                   ...future.conditions[[length(...future.conditions) + 
[13:19:59.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:59.975]                   if (TRUE && !signal) {
[13:19:59.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.975]                     {
[13:19:59.975]                       inherits <- base::inherits
[13:19:59.975]                       invokeRestart <- base::invokeRestart
[13:19:59.975]                       is.null <- base::is.null
[13:19:59.975]                       muffled <- FALSE
[13:19:59.975]                       if (inherits(cond, "message")) {
[13:19:59.975]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.975]                         if (muffled) 
[13:19:59.975]                           invokeRestart("muffleMessage")
[13:19:59.975]                       }
[13:19:59.975]                       else if (inherits(cond, "warning")) {
[13:19:59.975]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.975]                         if (muffled) 
[13:19:59.975]                           invokeRestart("muffleWarning")
[13:19:59.975]                       }
[13:19:59.975]                       else if (inherits(cond, "condition")) {
[13:19:59.975]                         if (!is.null(pattern)) {
[13:19:59.975]                           computeRestarts <- base::computeRestarts
[13:19:59.975]                           grepl <- base::grepl
[13:19:59.975]                           restarts <- computeRestarts(cond)
[13:19:59.975]                           for (restart in restarts) {
[13:19:59.975]                             name <- restart$name
[13:19:59.975]                             if (is.null(name)) 
[13:19:59.975]                               next
[13:19:59.975]                             if (!grepl(pattern, name)) 
[13:19:59.975]                               next
[13:19:59.975]                             invokeRestart(restart)
[13:19:59.975]                             muffled <- TRUE
[13:19:59.975]                             break
[13:19:59.975]                           }
[13:19:59.975]                         }
[13:19:59.975]                       }
[13:19:59.975]                       invisible(muffled)
[13:19:59.975]                     }
[13:19:59.975]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.975]                   }
[13:19:59.975]                 }
[13:19:59.975]                 else {
[13:19:59.975]                   if (TRUE) {
[13:19:59.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:59.975]                     {
[13:19:59.975]                       inherits <- base::inherits
[13:19:59.975]                       invokeRestart <- base::invokeRestart
[13:19:59.975]                       is.null <- base::is.null
[13:19:59.975]                       muffled <- FALSE
[13:19:59.975]                       if (inherits(cond, "message")) {
[13:19:59.975]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:59.975]                         if (muffled) 
[13:19:59.975]                           invokeRestart("muffleMessage")
[13:19:59.975]                       }
[13:19:59.975]                       else if (inherits(cond, "warning")) {
[13:19:59.975]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:59.975]                         if (muffled) 
[13:19:59.975]                           invokeRestart("muffleWarning")
[13:19:59.975]                       }
[13:19:59.975]                       else if (inherits(cond, "condition")) {
[13:19:59.975]                         if (!is.null(pattern)) {
[13:19:59.975]                           computeRestarts <- base::computeRestarts
[13:19:59.975]                           grepl <- base::grepl
[13:19:59.975]                           restarts <- computeRestarts(cond)
[13:19:59.975]                           for (restart in restarts) {
[13:19:59.975]                             name <- restart$name
[13:19:59.975]                             if (is.null(name)) 
[13:19:59.975]                               next
[13:19:59.975]                             if (!grepl(pattern, name)) 
[13:19:59.975]                               next
[13:19:59.975]                             invokeRestart(restart)
[13:19:59.975]                             muffled <- TRUE
[13:19:59.975]                             break
[13:19:59.975]                           }
[13:19:59.975]                         }
[13:19:59.975]                       }
[13:19:59.975]                       invisible(muffled)
[13:19:59.975]                     }
[13:19:59.975]                     muffleCondition(cond, pattern = "^muffle")
[13:19:59.975]                   }
[13:19:59.975]                 }
[13:19:59.975]             }
[13:19:59.975]         }))
[13:19:59.975]     }, error = function(ex) {
[13:19:59.975]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:59.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:59.975]                 ...future.rng), started = ...future.startTime, 
[13:19:59.975]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:59.975]             version = "1.8"), class = "FutureResult")
[13:19:59.975]     }, finally = {
[13:19:59.975]         if (!identical(...future.workdir, getwd())) 
[13:19:59.975]             setwd(...future.workdir)
[13:19:59.975]         {
[13:19:59.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:59.975]                 ...future.oldOptions$nwarnings <- NULL
[13:19:59.975]             }
[13:19:59.975]             base::options(...future.oldOptions)
[13:19:59.975]             if (.Platform$OS.type == "windows") {
[13:19:59.975]                 old_names <- names(...future.oldEnvVars)
[13:19:59.975]                 envs <- base::Sys.getenv()
[13:19:59.975]                 names <- names(envs)
[13:19:59.975]                 common <- intersect(names, old_names)
[13:19:59.975]                 added <- setdiff(names, old_names)
[13:19:59.975]                 removed <- setdiff(old_names, names)
[13:19:59.975]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:59.975]                   envs[common]]
[13:19:59.975]                 NAMES <- toupper(changed)
[13:19:59.975]                 args <- list()
[13:19:59.975]                 for (kk in seq_along(NAMES)) {
[13:19:59.975]                   name <- changed[[kk]]
[13:19:59.975]                   NAME <- NAMES[[kk]]
[13:19:59.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.975]                     next
[13:19:59.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.975]                 }
[13:19:59.975]                 NAMES <- toupper(added)
[13:19:59.975]                 for (kk in seq_along(NAMES)) {
[13:19:59.975]                   name <- added[[kk]]
[13:19:59.975]                   NAME <- NAMES[[kk]]
[13:19:59.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.975]                     next
[13:19:59.975]                   args[[name]] <- ""
[13:19:59.975]                 }
[13:19:59.975]                 NAMES <- toupper(removed)
[13:19:59.975]                 for (kk in seq_along(NAMES)) {
[13:19:59.975]                   name <- removed[[kk]]
[13:19:59.975]                   NAME <- NAMES[[kk]]
[13:19:59.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:59.975]                     next
[13:19:59.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:59.975]                 }
[13:19:59.975]                 if (length(args) > 0) 
[13:19:59.975]                   base::do.call(base::Sys.setenv, args = args)
[13:19:59.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:59.975]             }
[13:19:59.975]             else {
[13:19:59.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:59.975]             }
[13:19:59.975]             {
[13:19:59.975]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:59.975]                   0L) {
[13:19:59.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:59.975]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:59.975]                   base::options(opts)
[13:19:59.975]                 }
[13:19:59.975]                 {
[13:19:59.975]                   {
[13:19:59.975]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:59.975]                     NULL
[13:19:59.975]                   }
[13:19:59.975]                   options(future.plan = NULL)
[13:19:59.975]                   if (is.na(NA_character_)) 
[13:19:59.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:59.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:59.975]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:59.975]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:59.975]                     envir = parent.frame()) 
[13:19:59.975]                   {
[13:19:59.975]                     if (is.function(workers)) 
[13:19:59.975]                       workers <- workers()
[13:19:59.975]                     workers <- structure(as.integer(workers), 
[13:19:59.975]                       class = class(workers))
[13:19:59.975]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:59.975]                       workers >= 1)
[13:19:59.975]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:59.975]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:59.975]                     }
[13:19:59.975]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:59.975]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:59.975]                       envir = envir)
[13:19:59.975]                     if (!future$lazy) 
[13:19:59.975]                       future <- run(future)
[13:19:59.975]                     invisible(future)
[13:19:59.975]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:59.975]                 }
[13:19:59.975]             }
[13:19:59.975]         }
[13:19:59.975]     })
[13:19:59.975]     if (TRUE) {
[13:19:59.975]         base::sink(type = "output", split = FALSE)
[13:19:59.975]         if (TRUE) {
[13:19:59.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:59.975]         }
[13:19:59.975]         else {
[13:19:59.975]             ...future.result["stdout"] <- base::list(NULL)
[13:19:59.975]         }
[13:19:59.975]         base::close(...future.stdout)
[13:19:59.975]         ...future.stdout <- NULL
[13:19:59.975]     }
[13:19:59.975]     ...future.result$conditions <- ...future.conditions
[13:19:59.975]     ...future.result$finished <- base::Sys.time()
[13:19:59.975]     ...future.result
[13:19:59.975] }
[13:19:59.978] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:19:59.978] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[13:19:59.979] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[13:19:59.979] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[13:19:59.979] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[13:19:59.980] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:19:59.980] MultisessionFuture started
[13:19:59.980] - Launch lazy future ... done
[13:19:59.981] run() for ‘MultisessionFuture’ ... done
[13:19:59.981] result() for ClusterFuture ...
[13:19:59.981] receiveMessageFromWorker() for ClusterFuture ...
[13:19:59.981] - Validating connection of MultisessionFuture
[13:20:00.026] - received message: FutureResult
[13:20:00.026] - Received FutureResult
[13:20:00.026] - Erased future from FutureRegistry
[13:20:00.026] result() for ClusterFuture ...
[13:20:00.027] - result already collected: FutureResult
[13:20:00.027] result() for ClusterFuture ... done
[13:20:00.027] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.027] result() for ClusterFuture ... done
[13:20:00.027] result() for ClusterFuture ...
[13:20:00.027] - result already collected: FutureResult
[13:20:00.027] result() for ClusterFuture ... done
[1] 6
** Sum function 'C' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x562225ab6848>
Arguments '...' exists: FALSE
[13:20:00.028] getGlobalsAndPackages() ...
[13:20:00.028] Searching for globals...
[13:20:00.030] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[13:20:00.030] Searching for globals ... DONE
[13:20:00.030] Resolving globals: FALSE
[13:20:00.031] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:00.031] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[13:20:00.031] - globals: [2] ‘x’, ‘y’
[13:20:00.031] 
[13:20:00.031] getGlobalsAndPackages() ... DONE
[13:20:00.032] run() for ‘Future’ ...
[13:20:00.032] - state: ‘created’
[13:20:00.032] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.047] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.048] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.048]   - Field: ‘node’
[13:20:00.048]   - Field: ‘label’
[13:20:00.048]   - Field: ‘local’
[13:20:00.048]   - Field: ‘owner’
[13:20:00.048]   - Field: ‘envir’
[13:20:00.048]   - Field: ‘workers’
[13:20:00.048]   - Field: ‘packages’
[13:20:00.048]   - Field: ‘gc’
[13:20:00.049]   - Field: ‘conditions’
[13:20:00.049]   - Field: ‘persistent’
[13:20:00.049]   - Field: ‘expr’
[13:20:00.049]   - Field: ‘uuid’
[13:20:00.049]   - Field: ‘seed’
[13:20:00.049]   - Field: ‘version’
[13:20:00.049]   - Field: ‘result’
[13:20:00.049]   - Field: ‘asynchronous’
[13:20:00.050]   - Field: ‘calls’
[13:20:00.050]   - Field: ‘globals’
[13:20:00.050]   - Field: ‘stdout’
[13:20:00.050]   - Field: ‘earlySignal’
[13:20:00.050]   - Field: ‘lazy’
[13:20:00.050]   - Field: ‘state’
[13:20:00.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.050] - Launch lazy future ...
[13:20:00.051] Packages needed by the future expression (n = 0): <none>
[13:20:00.051] Packages needed by future strategies (n = 0): <none>
[13:20:00.051] {
[13:20:00.051]     {
[13:20:00.051]         {
[13:20:00.051]             ...future.startTime <- base::Sys.time()
[13:20:00.051]             {
[13:20:00.051]                 {
[13:20:00.051]                   {
[13:20:00.051]                     {
[13:20:00.051]                       base::local({
[13:20:00.051]                         has_future <- base::requireNamespace("future", 
[13:20:00.051]                           quietly = TRUE)
[13:20:00.051]                         if (has_future) {
[13:20:00.051]                           ns <- base::getNamespace("future")
[13:20:00.051]                           version <- ns[[".package"]][["version"]]
[13:20:00.051]                           if (is.null(version)) 
[13:20:00.051]                             version <- utils::packageVersion("future")
[13:20:00.051]                         }
[13:20:00.051]                         else {
[13:20:00.051]                           version <- NULL
[13:20:00.051]                         }
[13:20:00.051]                         if (!has_future || version < "1.8.0") {
[13:20:00.051]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.051]                             "", base::R.version$version.string), 
[13:20:00.051]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.051]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.051]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.051]                               "release", "version")], collapse = " "), 
[13:20:00.051]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.051]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.051]                             info)
[13:20:00.051]                           info <- base::paste(info, collapse = "; ")
[13:20:00.051]                           if (!has_future) {
[13:20:00.051]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.051]                               info)
[13:20:00.051]                           }
[13:20:00.051]                           else {
[13:20:00.051]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.051]                               info, version)
[13:20:00.051]                           }
[13:20:00.051]                           base::stop(msg)
[13:20:00.051]                         }
[13:20:00.051]                       })
[13:20:00.051]                     }
[13:20:00.051]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.051]                     base::options(mc.cores = 1L)
[13:20:00.051]                   }
[13:20:00.051]                   options(future.plan = NULL)
[13:20:00.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.051]                 }
[13:20:00.051]                 ...future.workdir <- getwd()
[13:20:00.051]             }
[13:20:00.051]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.051]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.051]         }
[13:20:00.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:00.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.051]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.051]             base::names(...future.oldOptions))
[13:20:00.051]     }
[13:20:00.051]     if (FALSE) {
[13:20:00.051]     }
[13:20:00.051]     else {
[13:20:00.051]         if (TRUE) {
[13:20:00.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.051]                 open = "w")
[13:20:00.051]         }
[13:20:00.051]         else {
[13:20:00.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.051]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.051]         }
[13:20:00.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.051]             base::sink(type = "output", split = FALSE)
[13:20:00.051]             base::close(...future.stdout)
[13:20:00.051]         }, add = TRUE)
[13:20:00.051]     }
[13:20:00.051]     ...future.frame <- base::sys.nframe()
[13:20:00.051]     ...future.conditions <- base::list()
[13:20:00.051]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.051]     if (FALSE) {
[13:20:00.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.051]     }
[13:20:00.051]     ...future.result <- base::tryCatch({
[13:20:00.051]         base::withCallingHandlers({
[13:20:00.051]             ...future.value <- base::withVisible(base::local({
[13:20:00.051]                 ...future.makeSendCondition <- local({
[13:20:00.051]                   sendCondition <- NULL
[13:20:00.051]                   function(frame = 1L) {
[13:20:00.051]                     if (is.function(sendCondition)) 
[13:20:00.051]                       return(sendCondition)
[13:20:00.051]                     ns <- getNamespace("parallel")
[13:20:00.051]                     if (exists("sendData", mode = "function", 
[13:20:00.051]                       envir = ns)) {
[13:20:00.051]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.051]                         envir = ns)
[13:20:00.051]                       envir <- sys.frame(frame)
[13:20:00.051]                       master <- NULL
[13:20:00.051]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.051]                         !identical(envir, emptyenv())) {
[13:20:00.051]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.051]                           inherits = FALSE)) {
[13:20:00.051]                           master <- get("master", mode = "list", 
[13:20:00.051]                             envir = envir, inherits = FALSE)
[13:20:00.051]                           if (inherits(master, c("SOCKnode", 
[13:20:00.051]                             "SOCK0node"))) {
[13:20:00.051]                             sendCondition <<- function(cond) {
[13:20:00.051]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.051]                                 success = TRUE)
[13:20:00.051]                               parallel_sendData(master, data)
[13:20:00.051]                             }
[13:20:00.051]                             return(sendCondition)
[13:20:00.051]                           }
[13:20:00.051]                         }
[13:20:00.051]                         frame <- frame + 1L
[13:20:00.051]                         envir <- sys.frame(frame)
[13:20:00.051]                       }
[13:20:00.051]                     }
[13:20:00.051]                     sendCondition <<- function(cond) NULL
[13:20:00.051]                   }
[13:20:00.051]                 })
[13:20:00.051]                 withCallingHandlers({
[13:20:00.051]                   {
[13:20:00.051]                     sum(x, y)
[13:20:00.051]                   }
[13:20:00.051]                 }, immediateCondition = function(cond) {
[13:20:00.051]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.051]                   sendCondition(cond)
[13:20:00.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.051]                   {
[13:20:00.051]                     inherits <- base::inherits
[13:20:00.051]                     invokeRestart <- base::invokeRestart
[13:20:00.051]                     is.null <- base::is.null
[13:20:00.051]                     muffled <- FALSE
[13:20:00.051]                     if (inherits(cond, "message")) {
[13:20:00.051]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.051]                       if (muffled) 
[13:20:00.051]                         invokeRestart("muffleMessage")
[13:20:00.051]                     }
[13:20:00.051]                     else if (inherits(cond, "warning")) {
[13:20:00.051]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.051]                       if (muffled) 
[13:20:00.051]                         invokeRestart("muffleWarning")
[13:20:00.051]                     }
[13:20:00.051]                     else if (inherits(cond, "condition")) {
[13:20:00.051]                       if (!is.null(pattern)) {
[13:20:00.051]                         computeRestarts <- base::computeRestarts
[13:20:00.051]                         grepl <- base::grepl
[13:20:00.051]                         restarts <- computeRestarts(cond)
[13:20:00.051]                         for (restart in restarts) {
[13:20:00.051]                           name <- restart$name
[13:20:00.051]                           if (is.null(name)) 
[13:20:00.051]                             next
[13:20:00.051]                           if (!grepl(pattern, name)) 
[13:20:00.051]                             next
[13:20:00.051]                           invokeRestart(restart)
[13:20:00.051]                           muffled <- TRUE
[13:20:00.051]                           break
[13:20:00.051]                         }
[13:20:00.051]                       }
[13:20:00.051]                     }
[13:20:00.051]                     invisible(muffled)
[13:20:00.051]                   }
[13:20:00.051]                   muffleCondition(cond)
[13:20:00.051]                 })
[13:20:00.051]             }))
[13:20:00.051]             future::FutureResult(value = ...future.value$value, 
[13:20:00.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.051]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.051]                     ...future.globalenv.names))
[13:20:00.051]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.051]         }, condition = base::local({
[13:20:00.051]             c <- base::c
[13:20:00.051]             inherits <- base::inherits
[13:20:00.051]             invokeRestart <- base::invokeRestart
[13:20:00.051]             length <- base::length
[13:20:00.051]             list <- base::list
[13:20:00.051]             seq.int <- base::seq.int
[13:20:00.051]             signalCondition <- base::signalCondition
[13:20:00.051]             sys.calls <- base::sys.calls
[13:20:00.051]             `[[` <- base::`[[`
[13:20:00.051]             `+` <- base::`+`
[13:20:00.051]             `<<-` <- base::`<<-`
[13:20:00.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.051]                   3L)]
[13:20:00.051]             }
[13:20:00.051]             function(cond) {
[13:20:00.051]                 is_error <- inherits(cond, "error")
[13:20:00.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.051]                   NULL)
[13:20:00.051]                 if (is_error) {
[13:20:00.051]                   sessionInformation <- function() {
[13:20:00.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.051]                       search = base::search(), system = base::Sys.info())
[13:20:00.051]                   }
[13:20:00.051]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.051]                     cond$call), session = sessionInformation(), 
[13:20:00.051]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.051]                   signalCondition(cond)
[13:20:00.051]                 }
[13:20:00.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.051]                 "immediateCondition"))) {
[13:20:00.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.051]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.051]                   if (TRUE && !signal) {
[13:20:00.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.051]                     {
[13:20:00.051]                       inherits <- base::inherits
[13:20:00.051]                       invokeRestart <- base::invokeRestart
[13:20:00.051]                       is.null <- base::is.null
[13:20:00.051]                       muffled <- FALSE
[13:20:00.051]                       if (inherits(cond, "message")) {
[13:20:00.051]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.051]                         if (muffled) 
[13:20:00.051]                           invokeRestart("muffleMessage")
[13:20:00.051]                       }
[13:20:00.051]                       else if (inherits(cond, "warning")) {
[13:20:00.051]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.051]                         if (muffled) 
[13:20:00.051]                           invokeRestart("muffleWarning")
[13:20:00.051]                       }
[13:20:00.051]                       else if (inherits(cond, "condition")) {
[13:20:00.051]                         if (!is.null(pattern)) {
[13:20:00.051]                           computeRestarts <- base::computeRestarts
[13:20:00.051]                           grepl <- base::grepl
[13:20:00.051]                           restarts <- computeRestarts(cond)
[13:20:00.051]                           for (restart in restarts) {
[13:20:00.051]                             name <- restart$name
[13:20:00.051]                             if (is.null(name)) 
[13:20:00.051]                               next
[13:20:00.051]                             if (!grepl(pattern, name)) 
[13:20:00.051]                               next
[13:20:00.051]                             invokeRestart(restart)
[13:20:00.051]                             muffled <- TRUE
[13:20:00.051]                             break
[13:20:00.051]                           }
[13:20:00.051]                         }
[13:20:00.051]                       }
[13:20:00.051]                       invisible(muffled)
[13:20:00.051]                     }
[13:20:00.051]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.051]                   }
[13:20:00.051]                 }
[13:20:00.051]                 else {
[13:20:00.051]                   if (TRUE) {
[13:20:00.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.051]                     {
[13:20:00.051]                       inherits <- base::inherits
[13:20:00.051]                       invokeRestart <- base::invokeRestart
[13:20:00.051]                       is.null <- base::is.null
[13:20:00.051]                       muffled <- FALSE
[13:20:00.051]                       if (inherits(cond, "message")) {
[13:20:00.051]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.051]                         if (muffled) 
[13:20:00.051]                           invokeRestart("muffleMessage")
[13:20:00.051]                       }
[13:20:00.051]                       else if (inherits(cond, "warning")) {
[13:20:00.051]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.051]                         if (muffled) 
[13:20:00.051]                           invokeRestart("muffleWarning")
[13:20:00.051]                       }
[13:20:00.051]                       else if (inherits(cond, "condition")) {
[13:20:00.051]                         if (!is.null(pattern)) {
[13:20:00.051]                           computeRestarts <- base::computeRestarts
[13:20:00.051]                           grepl <- base::grepl
[13:20:00.051]                           restarts <- computeRestarts(cond)
[13:20:00.051]                           for (restart in restarts) {
[13:20:00.051]                             name <- restart$name
[13:20:00.051]                             if (is.null(name)) 
[13:20:00.051]                               next
[13:20:00.051]                             if (!grepl(pattern, name)) 
[13:20:00.051]                               next
[13:20:00.051]                             invokeRestart(restart)
[13:20:00.051]                             muffled <- TRUE
[13:20:00.051]                             break
[13:20:00.051]                           }
[13:20:00.051]                         }
[13:20:00.051]                       }
[13:20:00.051]                       invisible(muffled)
[13:20:00.051]                     }
[13:20:00.051]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.051]                   }
[13:20:00.051]                 }
[13:20:00.051]             }
[13:20:00.051]         }))
[13:20:00.051]     }, error = function(ex) {
[13:20:00.051]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.051]                 ...future.rng), started = ...future.startTime, 
[13:20:00.051]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.051]             version = "1.8"), class = "FutureResult")
[13:20:00.051]     }, finally = {
[13:20:00.051]         if (!identical(...future.workdir, getwd())) 
[13:20:00.051]             setwd(...future.workdir)
[13:20:00.051]         {
[13:20:00.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.051]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.051]             }
[13:20:00.051]             base::options(...future.oldOptions)
[13:20:00.051]             if (.Platform$OS.type == "windows") {
[13:20:00.051]                 old_names <- names(...future.oldEnvVars)
[13:20:00.051]                 envs <- base::Sys.getenv()
[13:20:00.051]                 names <- names(envs)
[13:20:00.051]                 common <- intersect(names, old_names)
[13:20:00.051]                 added <- setdiff(names, old_names)
[13:20:00.051]                 removed <- setdiff(old_names, names)
[13:20:00.051]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.051]                   envs[common]]
[13:20:00.051]                 NAMES <- toupper(changed)
[13:20:00.051]                 args <- list()
[13:20:00.051]                 for (kk in seq_along(NAMES)) {
[13:20:00.051]                   name <- changed[[kk]]
[13:20:00.051]                   NAME <- NAMES[[kk]]
[13:20:00.051]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.051]                     next
[13:20:00.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.051]                 }
[13:20:00.051]                 NAMES <- toupper(added)
[13:20:00.051]                 for (kk in seq_along(NAMES)) {
[13:20:00.051]                   name <- added[[kk]]
[13:20:00.051]                   NAME <- NAMES[[kk]]
[13:20:00.051]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.051]                     next
[13:20:00.051]                   args[[name]] <- ""
[13:20:00.051]                 }
[13:20:00.051]                 NAMES <- toupper(removed)
[13:20:00.051]                 for (kk in seq_along(NAMES)) {
[13:20:00.051]                   name <- removed[[kk]]
[13:20:00.051]                   NAME <- NAMES[[kk]]
[13:20:00.051]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.051]                     next
[13:20:00.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.051]                 }
[13:20:00.051]                 if (length(args) > 0) 
[13:20:00.051]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.051]             }
[13:20:00.051]             else {
[13:20:00.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.051]             }
[13:20:00.051]             {
[13:20:00.051]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.051]                   0L) {
[13:20:00.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.051]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.051]                   base::options(opts)
[13:20:00.051]                 }
[13:20:00.051]                 {
[13:20:00.051]                   {
[13:20:00.051]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.051]                     NULL
[13:20:00.051]                   }
[13:20:00.051]                   options(future.plan = NULL)
[13:20:00.051]                   if (is.na(NA_character_)) 
[13:20:00.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.051]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.051]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.051]                     envir = parent.frame()) 
[13:20:00.051]                   {
[13:20:00.051]                     if (is.function(workers)) 
[13:20:00.051]                       workers <- workers()
[13:20:00.051]                     workers <- structure(as.integer(workers), 
[13:20:00.051]                       class = class(workers))
[13:20:00.051]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.051]                       workers >= 1)
[13:20:00.051]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.051]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.051]                     }
[13:20:00.051]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.051]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.051]                       envir = envir)
[13:20:00.051]                     if (!future$lazy) 
[13:20:00.051]                       future <- run(future)
[13:20:00.051]                     invisible(future)
[13:20:00.051]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.051]                 }
[13:20:00.051]             }
[13:20:00.051]         }
[13:20:00.051]     })
[13:20:00.051]     if (TRUE) {
[13:20:00.051]         base::sink(type = "output", split = FALSE)
[13:20:00.051]         if (TRUE) {
[13:20:00.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.051]         }
[13:20:00.051]         else {
[13:20:00.051]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.051]         }
[13:20:00.051]         base::close(...future.stdout)
[13:20:00.051]         ...future.stdout <- NULL
[13:20:00.051]     }
[13:20:00.051]     ...future.result$conditions <- ...future.conditions
[13:20:00.051]     ...future.result$finished <- base::Sys.time()
[13:20:00.051]     ...future.result
[13:20:00.051] }
[13:20:00.055] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:20:00.057] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[13:20:00.058] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.058] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[13:20:00.058] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.059] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:20:00.059] MultisessionFuture started
[13:20:00.059] - Launch lazy future ... done
[13:20:00.059] run() for ‘MultisessionFuture’ ... done
[13:20:00.060] result() for ClusterFuture ...
[13:20:00.060] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.060] - Validating connection of MultisessionFuture
[13:20:00.106] - received message: FutureResult
[13:20:00.106] - Received FutureResult
[13:20:00.107] - Erased future from FutureRegistry
[13:20:00.107] result() for ClusterFuture ...
[13:20:00.107] - result already collected: FutureResult
[13:20:00.107] result() for ClusterFuture ... done
[13:20:00.107] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.107] result() for ClusterFuture ... done
[13:20:00.107] result() for ClusterFuture ...
[13:20:00.108] - result already collected: FutureResult
[13:20:00.108] result() for ClusterFuture ... done
[1] 6
** Sum function 'D' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x562223c69dc0>
Arguments '...' exists: FALSE
[13:20:00.108] getGlobalsAndPackages() ...
[13:20:00.108] Searching for globals...
[13:20:00.110] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[13:20:00.110] Searching for globals ... DONE
[13:20:00.110] Resolving globals: FALSE
[13:20:00.110] Tweak future expression to call with '...' arguments ...
[13:20:00.111] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:00.111] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[13:20:00.111] - globals: [2] ‘x’, ‘y’
[13:20:00.111] 
[13:20:00.111] getGlobalsAndPackages() ... DONE
[13:20:00.112] run() for ‘Future’ ...
[13:20:00.112] - state: ‘created’
[13:20:00.112] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.127] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.127] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.127]   - Field: ‘node’
[13:20:00.127]   - Field: ‘label’
[13:20:00.127]   - Field: ‘local’
[13:20:00.127]   - Field: ‘owner’
[13:20:00.127]   - Field: ‘envir’
[13:20:00.127]   - Field: ‘workers’
[13:20:00.127]   - Field: ‘packages’
[13:20:00.127]   - Field: ‘gc’
[13:20:00.128]   - Field: ‘conditions’
[13:20:00.128]   - Field: ‘persistent’
[13:20:00.128]   - Field: ‘expr’
[13:20:00.128]   - Field: ‘uuid’
[13:20:00.128]   - Field: ‘seed’
[13:20:00.128]   - Field: ‘version’
[13:20:00.128]   - Field: ‘result’
[13:20:00.128]   - Field: ‘asynchronous’
[13:20:00.128]   - Field: ‘calls’
[13:20:00.128]   - Field: ‘globals’
[13:20:00.128]   - Field: ‘stdout’
[13:20:00.129]   - Field: ‘earlySignal’
[13:20:00.129]   - Field: ‘lazy’
[13:20:00.129]   - Field: ‘state’
[13:20:00.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.129] - Launch lazy future ...
[13:20:00.129] Packages needed by the future expression (n = 0): <none>
[13:20:00.129] Packages needed by future strategies (n = 0): <none>
[13:20:00.130] {
[13:20:00.130]     {
[13:20:00.130]         {
[13:20:00.130]             ...future.startTime <- base::Sys.time()
[13:20:00.130]             {
[13:20:00.130]                 {
[13:20:00.130]                   {
[13:20:00.130]                     {
[13:20:00.130]                       base::local({
[13:20:00.130]                         has_future <- base::requireNamespace("future", 
[13:20:00.130]                           quietly = TRUE)
[13:20:00.130]                         if (has_future) {
[13:20:00.130]                           ns <- base::getNamespace("future")
[13:20:00.130]                           version <- ns[[".package"]][["version"]]
[13:20:00.130]                           if (is.null(version)) 
[13:20:00.130]                             version <- utils::packageVersion("future")
[13:20:00.130]                         }
[13:20:00.130]                         else {
[13:20:00.130]                           version <- NULL
[13:20:00.130]                         }
[13:20:00.130]                         if (!has_future || version < "1.8.0") {
[13:20:00.130]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.130]                             "", base::R.version$version.string), 
[13:20:00.130]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.130]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.130]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.130]                               "release", "version")], collapse = " "), 
[13:20:00.130]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.130]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.130]                             info)
[13:20:00.130]                           info <- base::paste(info, collapse = "; ")
[13:20:00.130]                           if (!has_future) {
[13:20:00.130]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.130]                               info)
[13:20:00.130]                           }
[13:20:00.130]                           else {
[13:20:00.130]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.130]                               info, version)
[13:20:00.130]                           }
[13:20:00.130]                           base::stop(msg)
[13:20:00.130]                         }
[13:20:00.130]                       })
[13:20:00.130]                     }
[13:20:00.130]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.130]                     base::options(mc.cores = 1L)
[13:20:00.130]                   }
[13:20:00.130]                   options(future.plan = NULL)
[13:20:00.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.130]                 }
[13:20:00.130]                 ...future.workdir <- getwd()
[13:20:00.130]             }
[13:20:00.130]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.130]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.130]         }
[13:20:00.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.130]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:00.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.130]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.130]             base::names(...future.oldOptions))
[13:20:00.130]     }
[13:20:00.130]     if (FALSE) {
[13:20:00.130]     }
[13:20:00.130]     else {
[13:20:00.130]         if (TRUE) {
[13:20:00.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.130]                 open = "w")
[13:20:00.130]         }
[13:20:00.130]         else {
[13:20:00.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.130]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.130]         }
[13:20:00.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.130]             base::sink(type = "output", split = FALSE)
[13:20:00.130]             base::close(...future.stdout)
[13:20:00.130]         }, add = TRUE)
[13:20:00.130]     }
[13:20:00.130]     ...future.frame <- base::sys.nframe()
[13:20:00.130]     ...future.conditions <- base::list()
[13:20:00.130]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.130]     if (FALSE) {
[13:20:00.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.130]     }
[13:20:00.130]     ...future.result <- base::tryCatch({
[13:20:00.130]         base::withCallingHandlers({
[13:20:00.130]             ...future.value <- base::withVisible(base::local({
[13:20:00.130]                 ...future.makeSendCondition <- local({
[13:20:00.130]                   sendCondition <- NULL
[13:20:00.130]                   function(frame = 1L) {
[13:20:00.130]                     if (is.function(sendCondition)) 
[13:20:00.130]                       return(sendCondition)
[13:20:00.130]                     ns <- getNamespace("parallel")
[13:20:00.130]                     if (exists("sendData", mode = "function", 
[13:20:00.130]                       envir = ns)) {
[13:20:00.130]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.130]                         envir = ns)
[13:20:00.130]                       envir <- sys.frame(frame)
[13:20:00.130]                       master <- NULL
[13:20:00.130]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.130]                         !identical(envir, emptyenv())) {
[13:20:00.130]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.130]                           inherits = FALSE)) {
[13:20:00.130]                           master <- get("master", mode = "list", 
[13:20:00.130]                             envir = envir, inherits = FALSE)
[13:20:00.130]                           if (inherits(master, c("SOCKnode", 
[13:20:00.130]                             "SOCK0node"))) {
[13:20:00.130]                             sendCondition <<- function(cond) {
[13:20:00.130]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.130]                                 success = TRUE)
[13:20:00.130]                               parallel_sendData(master, data)
[13:20:00.130]                             }
[13:20:00.130]                             return(sendCondition)
[13:20:00.130]                           }
[13:20:00.130]                         }
[13:20:00.130]                         frame <- frame + 1L
[13:20:00.130]                         envir <- sys.frame(frame)
[13:20:00.130]                       }
[13:20:00.130]                     }
[13:20:00.130]                     sendCondition <<- function(cond) NULL
[13:20:00.130]                   }
[13:20:00.130]                 })
[13:20:00.130]                 withCallingHandlers({
[13:20:00.130]                   {
[13:20:00.130]                     sum(x, y, ...)
[13:20:00.130]                   }
[13:20:00.130]                 }, immediateCondition = function(cond) {
[13:20:00.130]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.130]                   sendCondition(cond)
[13:20:00.130]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.130]                   {
[13:20:00.130]                     inherits <- base::inherits
[13:20:00.130]                     invokeRestart <- base::invokeRestart
[13:20:00.130]                     is.null <- base::is.null
[13:20:00.130]                     muffled <- FALSE
[13:20:00.130]                     if (inherits(cond, "message")) {
[13:20:00.130]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.130]                       if (muffled) 
[13:20:00.130]                         invokeRestart("muffleMessage")
[13:20:00.130]                     }
[13:20:00.130]                     else if (inherits(cond, "warning")) {
[13:20:00.130]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.130]                       if (muffled) 
[13:20:00.130]                         invokeRestart("muffleWarning")
[13:20:00.130]                     }
[13:20:00.130]                     else if (inherits(cond, "condition")) {
[13:20:00.130]                       if (!is.null(pattern)) {
[13:20:00.130]                         computeRestarts <- base::computeRestarts
[13:20:00.130]                         grepl <- base::grepl
[13:20:00.130]                         restarts <- computeRestarts(cond)
[13:20:00.130]                         for (restart in restarts) {
[13:20:00.130]                           name <- restart$name
[13:20:00.130]                           if (is.null(name)) 
[13:20:00.130]                             next
[13:20:00.130]                           if (!grepl(pattern, name)) 
[13:20:00.130]                             next
[13:20:00.130]                           invokeRestart(restart)
[13:20:00.130]                           muffled <- TRUE
[13:20:00.130]                           break
[13:20:00.130]                         }
[13:20:00.130]                       }
[13:20:00.130]                     }
[13:20:00.130]                     invisible(muffled)
[13:20:00.130]                   }
[13:20:00.130]                   muffleCondition(cond)
[13:20:00.130]                 })
[13:20:00.130]             }))
[13:20:00.130]             future::FutureResult(value = ...future.value$value, 
[13:20:00.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.130]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.130]                     ...future.globalenv.names))
[13:20:00.130]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.130]         }, condition = base::local({
[13:20:00.130]             c <- base::c
[13:20:00.130]             inherits <- base::inherits
[13:20:00.130]             invokeRestart <- base::invokeRestart
[13:20:00.130]             length <- base::length
[13:20:00.130]             list <- base::list
[13:20:00.130]             seq.int <- base::seq.int
[13:20:00.130]             signalCondition <- base::signalCondition
[13:20:00.130]             sys.calls <- base::sys.calls
[13:20:00.130]             `[[` <- base::`[[`
[13:20:00.130]             `+` <- base::`+`
[13:20:00.130]             `<<-` <- base::`<<-`
[13:20:00.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.130]                   3L)]
[13:20:00.130]             }
[13:20:00.130]             function(cond) {
[13:20:00.130]                 is_error <- inherits(cond, "error")
[13:20:00.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.130]                   NULL)
[13:20:00.130]                 if (is_error) {
[13:20:00.130]                   sessionInformation <- function() {
[13:20:00.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.130]                       search = base::search(), system = base::Sys.info())
[13:20:00.130]                   }
[13:20:00.130]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.130]                     cond$call), session = sessionInformation(), 
[13:20:00.130]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.130]                   signalCondition(cond)
[13:20:00.130]                 }
[13:20:00.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.130]                 "immediateCondition"))) {
[13:20:00.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.130]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.130]                   if (TRUE && !signal) {
[13:20:00.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.130]                     {
[13:20:00.130]                       inherits <- base::inherits
[13:20:00.130]                       invokeRestart <- base::invokeRestart
[13:20:00.130]                       is.null <- base::is.null
[13:20:00.130]                       muffled <- FALSE
[13:20:00.130]                       if (inherits(cond, "message")) {
[13:20:00.130]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.130]                         if (muffled) 
[13:20:00.130]                           invokeRestart("muffleMessage")
[13:20:00.130]                       }
[13:20:00.130]                       else if (inherits(cond, "warning")) {
[13:20:00.130]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.130]                         if (muffled) 
[13:20:00.130]                           invokeRestart("muffleWarning")
[13:20:00.130]                       }
[13:20:00.130]                       else if (inherits(cond, "condition")) {
[13:20:00.130]                         if (!is.null(pattern)) {
[13:20:00.130]                           computeRestarts <- base::computeRestarts
[13:20:00.130]                           grepl <- base::grepl
[13:20:00.130]                           restarts <- computeRestarts(cond)
[13:20:00.130]                           for (restart in restarts) {
[13:20:00.130]                             name <- restart$name
[13:20:00.130]                             if (is.null(name)) 
[13:20:00.130]                               next
[13:20:00.130]                             if (!grepl(pattern, name)) 
[13:20:00.130]                               next
[13:20:00.130]                             invokeRestart(restart)
[13:20:00.130]                             muffled <- TRUE
[13:20:00.130]                             break
[13:20:00.130]                           }
[13:20:00.130]                         }
[13:20:00.130]                       }
[13:20:00.130]                       invisible(muffled)
[13:20:00.130]                     }
[13:20:00.130]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.130]                   }
[13:20:00.130]                 }
[13:20:00.130]                 else {
[13:20:00.130]                   if (TRUE) {
[13:20:00.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.130]                     {
[13:20:00.130]                       inherits <- base::inherits
[13:20:00.130]                       invokeRestart <- base::invokeRestart
[13:20:00.130]                       is.null <- base::is.null
[13:20:00.130]                       muffled <- FALSE
[13:20:00.130]                       if (inherits(cond, "message")) {
[13:20:00.130]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.130]                         if (muffled) 
[13:20:00.130]                           invokeRestart("muffleMessage")
[13:20:00.130]                       }
[13:20:00.130]                       else if (inherits(cond, "warning")) {
[13:20:00.130]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.130]                         if (muffled) 
[13:20:00.130]                           invokeRestart("muffleWarning")
[13:20:00.130]                       }
[13:20:00.130]                       else if (inherits(cond, "condition")) {
[13:20:00.130]                         if (!is.null(pattern)) {
[13:20:00.130]                           computeRestarts <- base::computeRestarts
[13:20:00.130]                           grepl <- base::grepl
[13:20:00.130]                           restarts <- computeRestarts(cond)
[13:20:00.130]                           for (restart in restarts) {
[13:20:00.130]                             name <- restart$name
[13:20:00.130]                             if (is.null(name)) 
[13:20:00.130]                               next
[13:20:00.130]                             if (!grepl(pattern, name)) 
[13:20:00.130]                               next
[13:20:00.130]                             invokeRestart(restart)
[13:20:00.130]                             muffled <- TRUE
[13:20:00.130]                             break
[13:20:00.130]                           }
[13:20:00.130]                         }
[13:20:00.130]                       }
[13:20:00.130]                       invisible(muffled)
[13:20:00.130]                     }
[13:20:00.130]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.130]                   }
[13:20:00.130]                 }
[13:20:00.130]             }
[13:20:00.130]         }))
[13:20:00.130]     }, error = function(ex) {
[13:20:00.130]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.130]                 ...future.rng), started = ...future.startTime, 
[13:20:00.130]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.130]             version = "1.8"), class = "FutureResult")
[13:20:00.130]     }, finally = {
[13:20:00.130]         if (!identical(...future.workdir, getwd())) 
[13:20:00.130]             setwd(...future.workdir)
[13:20:00.130]         {
[13:20:00.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.130]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.130]             }
[13:20:00.130]             base::options(...future.oldOptions)
[13:20:00.130]             if (.Platform$OS.type == "windows") {
[13:20:00.130]                 old_names <- names(...future.oldEnvVars)
[13:20:00.130]                 envs <- base::Sys.getenv()
[13:20:00.130]                 names <- names(envs)
[13:20:00.130]                 common <- intersect(names, old_names)
[13:20:00.130]                 added <- setdiff(names, old_names)
[13:20:00.130]                 removed <- setdiff(old_names, names)
[13:20:00.130]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.130]                   envs[common]]
[13:20:00.130]                 NAMES <- toupper(changed)
[13:20:00.130]                 args <- list()
[13:20:00.130]                 for (kk in seq_along(NAMES)) {
[13:20:00.130]                   name <- changed[[kk]]
[13:20:00.130]                   NAME <- NAMES[[kk]]
[13:20:00.130]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.130]                     next
[13:20:00.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.130]                 }
[13:20:00.130]                 NAMES <- toupper(added)
[13:20:00.130]                 for (kk in seq_along(NAMES)) {
[13:20:00.130]                   name <- added[[kk]]
[13:20:00.130]                   NAME <- NAMES[[kk]]
[13:20:00.130]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.130]                     next
[13:20:00.130]                   args[[name]] <- ""
[13:20:00.130]                 }
[13:20:00.130]                 NAMES <- toupper(removed)
[13:20:00.130]                 for (kk in seq_along(NAMES)) {
[13:20:00.130]                   name <- removed[[kk]]
[13:20:00.130]                   NAME <- NAMES[[kk]]
[13:20:00.130]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.130]                     next
[13:20:00.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.130]                 }
[13:20:00.130]                 if (length(args) > 0) 
[13:20:00.130]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.130]             }
[13:20:00.130]             else {
[13:20:00.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.130]             }
[13:20:00.130]             {
[13:20:00.130]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.130]                   0L) {
[13:20:00.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.130]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.130]                   base::options(opts)
[13:20:00.130]                 }
[13:20:00.130]                 {
[13:20:00.130]                   {
[13:20:00.130]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.130]                     NULL
[13:20:00.130]                   }
[13:20:00.130]                   options(future.plan = NULL)
[13:20:00.130]                   if (is.na(NA_character_)) 
[13:20:00.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.130]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.130]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.130]                     envir = parent.frame()) 
[13:20:00.130]                   {
[13:20:00.130]                     if (is.function(workers)) 
[13:20:00.130]                       workers <- workers()
[13:20:00.130]                     workers <- structure(as.integer(workers), 
[13:20:00.130]                       class = class(workers))
[13:20:00.130]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.130]                       workers >= 1)
[13:20:00.130]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.130]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.130]                     }
[13:20:00.130]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.130]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.130]                       envir = envir)
[13:20:00.130]                     if (!future$lazy) 
[13:20:00.130]                       future <- run(future)
[13:20:00.130]                     invisible(future)
[13:20:00.130]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.130]                 }
[13:20:00.130]             }
[13:20:00.130]         }
[13:20:00.130]     })
[13:20:00.130]     if (TRUE) {
[13:20:00.130]         base::sink(type = "output", split = FALSE)
[13:20:00.130]         if (TRUE) {
[13:20:00.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.130]         }
[13:20:00.130]         else {
[13:20:00.130]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.130]         }
[13:20:00.130]         base::close(...future.stdout)
[13:20:00.130]         ...future.stdout <- NULL
[13:20:00.130]     }
[13:20:00.130]     ...future.result$conditions <- ...future.conditions
[13:20:00.130]     ...future.result$finished <- base::Sys.time()
[13:20:00.130]     ...future.result
[13:20:00.130] }
[13:20:00.133] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:20:00.133] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[13:20:00.133] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.133] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[13:20:00.134] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.134] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:20:00.134] MultisessionFuture started
[13:20:00.134] - Launch lazy future ... done
[13:20:00.135] run() for ‘MultisessionFuture’ ... done
[13:20:00.135] result() for ClusterFuture ...
[13:20:00.135] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.135] - Validating connection of MultisessionFuture
[13:20:00.183] - received message: FutureResult
[13:20:00.183] - Received FutureResult
[13:20:00.183] - Erased future from FutureRegistry
[13:20:00.184] result() for ClusterFuture ...
[13:20:00.184] - result already collected: FutureResult
[13:20:00.184] result() for ClusterFuture ... done
[13:20:00.184] signalConditions() ...
[13:20:00.184]  - include = ‘immediateCondition’
[13:20:00.184]  - exclude = 
[13:20:00.184]  - resignal = FALSE
[13:20:00.184]  - Number of conditions: 1
[13:20:00.184] signalConditions() ... done
[13:20:00.184] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.184] result() for ClusterFuture ... done
[13:20:00.185] result() for ClusterFuture ...
[13:20:00.185] - result already collected: FutureResult
[13:20:00.185] result() for ClusterFuture ... done
[13:20:00.185] signalConditions() ...
[13:20:00.185]  - include = ‘immediateCondition’
[13:20:00.185]  - exclude = 
[13:20:00.185]  - resignal = FALSE
[13:20:00.185]  - Number of conditions: 1
[13:20:00.185] signalConditions() ... done
[13:20:00.185] Future state: ‘finished’
[13:20:00.186] result() for ClusterFuture ...
[13:20:00.186] - result already collected: FutureResult
[13:20:00.186] result() for ClusterFuture ... done
[13:20:00.186] signalConditions() ...
[13:20:00.186]  - include = ‘condition’
[13:20:00.186]  - exclude = ‘immediateCondition’
[13:20:00.186]  - resignal = TRUE
[13:20:00.186]  - Number of conditions: 1
[13:20:00.186]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:00.186] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multisession') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x562224c2fea0>
Arguments '...' exists: TRUE
[13:20:00.187] getGlobalsAndPackages() ...
[13:20:00.187] - globals passed as-is: [1] ‘...’
[13:20:00.188] Resolving globals: FALSE
[13:20:00.188] Tweak future expression to call with '...' arguments ...
[13:20:00.188] {
[13:20:00.188]     do.call(function(...) {
[13:20:00.188]         fcn <- function() sum(...)
[13:20:00.188]         fcn()
[13:20:00.188]     }, args = future.call.arguments)
[13:20:00.188] }
[13:20:00.188] Tweak future expression to call with '...' arguments ... DONE
[13:20:00.188] The total size of the 1 globals is 112 bytes (112 bytes)
[13:20:00.189] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[13:20:00.189] - globals: [1] ‘future.call.arguments’
[13:20:00.189] 
[13:20:00.189] getGlobalsAndPackages() ... DONE
[13:20:00.189] run() for ‘Future’ ...
[13:20:00.189] - state: ‘created’
[13:20:00.190] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.204] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.204] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.204]   - Field: ‘node’
[13:20:00.205]   - Field: ‘label’
[13:20:00.205]   - Field: ‘local’
[13:20:00.205]   - Field: ‘owner’
[13:20:00.205]   - Field: ‘envir’
[13:20:00.205]   - Field: ‘workers’
[13:20:00.205]   - Field: ‘packages’
[13:20:00.205]   - Field: ‘gc’
[13:20:00.205]   - Field: ‘conditions’
[13:20:00.205]   - Field: ‘persistent’
[13:20:00.205]   - Field: ‘expr’
[13:20:00.206]   - Field: ‘uuid’
[13:20:00.206]   - Field: ‘seed’
[13:20:00.206]   - Field: ‘version’
[13:20:00.206]   - Field: ‘result’
[13:20:00.206]   - Field: ‘asynchronous’
[13:20:00.206]   - Field: ‘calls’
[13:20:00.206]   - Field: ‘globals’
[13:20:00.206]   - Field: ‘stdout’
[13:20:00.206]   - Field: ‘earlySignal’
[13:20:00.206]   - Field: ‘lazy’
[13:20:00.206]   - Field: ‘state’
[13:20:00.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.207] - Launch lazy future ...
[13:20:00.207] Packages needed by the future expression (n = 0): <none>
[13:20:00.207] Packages needed by future strategies (n = 0): <none>
[13:20:00.208] {
[13:20:00.208]     {
[13:20:00.208]         {
[13:20:00.208]             ...future.startTime <- base::Sys.time()
[13:20:00.208]             {
[13:20:00.208]                 {
[13:20:00.208]                   {
[13:20:00.208]                     {
[13:20:00.208]                       base::local({
[13:20:00.208]                         has_future <- base::requireNamespace("future", 
[13:20:00.208]                           quietly = TRUE)
[13:20:00.208]                         if (has_future) {
[13:20:00.208]                           ns <- base::getNamespace("future")
[13:20:00.208]                           version <- ns[[".package"]][["version"]]
[13:20:00.208]                           if (is.null(version)) 
[13:20:00.208]                             version <- utils::packageVersion("future")
[13:20:00.208]                         }
[13:20:00.208]                         else {
[13:20:00.208]                           version <- NULL
[13:20:00.208]                         }
[13:20:00.208]                         if (!has_future || version < "1.8.0") {
[13:20:00.208]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.208]                             "", base::R.version$version.string), 
[13:20:00.208]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.208]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.208]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.208]                               "release", "version")], collapse = " "), 
[13:20:00.208]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.208]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.208]                             info)
[13:20:00.208]                           info <- base::paste(info, collapse = "; ")
[13:20:00.208]                           if (!has_future) {
[13:20:00.208]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.208]                               info)
[13:20:00.208]                           }
[13:20:00.208]                           else {
[13:20:00.208]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.208]                               info, version)
[13:20:00.208]                           }
[13:20:00.208]                           base::stop(msg)
[13:20:00.208]                         }
[13:20:00.208]                       })
[13:20:00.208]                     }
[13:20:00.208]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.208]                     base::options(mc.cores = 1L)
[13:20:00.208]                   }
[13:20:00.208]                   options(future.plan = NULL)
[13:20:00.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.208]                 }
[13:20:00.208]                 ...future.workdir <- getwd()
[13:20:00.208]             }
[13:20:00.208]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.208]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.208]         }
[13:20:00.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.208]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:00.208]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.208]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.208]             base::names(...future.oldOptions))
[13:20:00.208]     }
[13:20:00.208]     if (FALSE) {
[13:20:00.208]     }
[13:20:00.208]     else {
[13:20:00.208]         if (TRUE) {
[13:20:00.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.208]                 open = "w")
[13:20:00.208]         }
[13:20:00.208]         else {
[13:20:00.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.208]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.208]         }
[13:20:00.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.208]             base::sink(type = "output", split = FALSE)
[13:20:00.208]             base::close(...future.stdout)
[13:20:00.208]         }, add = TRUE)
[13:20:00.208]     }
[13:20:00.208]     ...future.frame <- base::sys.nframe()
[13:20:00.208]     ...future.conditions <- base::list()
[13:20:00.208]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.208]     if (FALSE) {
[13:20:00.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.208]     }
[13:20:00.208]     ...future.result <- base::tryCatch({
[13:20:00.208]         base::withCallingHandlers({
[13:20:00.208]             ...future.value <- base::withVisible(base::local({
[13:20:00.208]                 ...future.makeSendCondition <- local({
[13:20:00.208]                   sendCondition <- NULL
[13:20:00.208]                   function(frame = 1L) {
[13:20:00.208]                     if (is.function(sendCondition)) 
[13:20:00.208]                       return(sendCondition)
[13:20:00.208]                     ns <- getNamespace("parallel")
[13:20:00.208]                     if (exists("sendData", mode = "function", 
[13:20:00.208]                       envir = ns)) {
[13:20:00.208]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.208]                         envir = ns)
[13:20:00.208]                       envir <- sys.frame(frame)
[13:20:00.208]                       master <- NULL
[13:20:00.208]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.208]                         !identical(envir, emptyenv())) {
[13:20:00.208]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.208]                           inherits = FALSE)) {
[13:20:00.208]                           master <- get("master", mode = "list", 
[13:20:00.208]                             envir = envir, inherits = FALSE)
[13:20:00.208]                           if (inherits(master, c("SOCKnode", 
[13:20:00.208]                             "SOCK0node"))) {
[13:20:00.208]                             sendCondition <<- function(cond) {
[13:20:00.208]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.208]                                 success = TRUE)
[13:20:00.208]                               parallel_sendData(master, data)
[13:20:00.208]                             }
[13:20:00.208]                             return(sendCondition)
[13:20:00.208]                           }
[13:20:00.208]                         }
[13:20:00.208]                         frame <- frame + 1L
[13:20:00.208]                         envir <- sys.frame(frame)
[13:20:00.208]                       }
[13:20:00.208]                     }
[13:20:00.208]                     sendCondition <<- function(cond) NULL
[13:20:00.208]                   }
[13:20:00.208]                 })
[13:20:00.208]                 withCallingHandlers({
[13:20:00.208]                   {
[13:20:00.208]                     do.call(function(...) {
[13:20:00.208]                       fcn <- function() sum(...)
[13:20:00.208]                       fcn()
[13:20:00.208]                     }, args = future.call.arguments)
[13:20:00.208]                   }
[13:20:00.208]                 }, immediateCondition = function(cond) {
[13:20:00.208]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.208]                   sendCondition(cond)
[13:20:00.208]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.208]                   {
[13:20:00.208]                     inherits <- base::inherits
[13:20:00.208]                     invokeRestart <- base::invokeRestart
[13:20:00.208]                     is.null <- base::is.null
[13:20:00.208]                     muffled <- FALSE
[13:20:00.208]                     if (inherits(cond, "message")) {
[13:20:00.208]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.208]                       if (muffled) 
[13:20:00.208]                         invokeRestart("muffleMessage")
[13:20:00.208]                     }
[13:20:00.208]                     else if (inherits(cond, "warning")) {
[13:20:00.208]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.208]                       if (muffled) 
[13:20:00.208]                         invokeRestart("muffleWarning")
[13:20:00.208]                     }
[13:20:00.208]                     else if (inherits(cond, "condition")) {
[13:20:00.208]                       if (!is.null(pattern)) {
[13:20:00.208]                         computeRestarts <- base::computeRestarts
[13:20:00.208]                         grepl <- base::grepl
[13:20:00.208]                         restarts <- computeRestarts(cond)
[13:20:00.208]                         for (restart in restarts) {
[13:20:00.208]                           name <- restart$name
[13:20:00.208]                           if (is.null(name)) 
[13:20:00.208]                             next
[13:20:00.208]                           if (!grepl(pattern, name)) 
[13:20:00.208]                             next
[13:20:00.208]                           invokeRestart(restart)
[13:20:00.208]                           muffled <- TRUE
[13:20:00.208]                           break
[13:20:00.208]                         }
[13:20:00.208]                       }
[13:20:00.208]                     }
[13:20:00.208]                     invisible(muffled)
[13:20:00.208]                   }
[13:20:00.208]                   muffleCondition(cond)
[13:20:00.208]                 })
[13:20:00.208]             }))
[13:20:00.208]             future::FutureResult(value = ...future.value$value, 
[13:20:00.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.208]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.208]                     ...future.globalenv.names))
[13:20:00.208]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.208]         }, condition = base::local({
[13:20:00.208]             c <- base::c
[13:20:00.208]             inherits <- base::inherits
[13:20:00.208]             invokeRestart <- base::invokeRestart
[13:20:00.208]             length <- base::length
[13:20:00.208]             list <- base::list
[13:20:00.208]             seq.int <- base::seq.int
[13:20:00.208]             signalCondition <- base::signalCondition
[13:20:00.208]             sys.calls <- base::sys.calls
[13:20:00.208]             `[[` <- base::`[[`
[13:20:00.208]             `+` <- base::`+`
[13:20:00.208]             `<<-` <- base::`<<-`
[13:20:00.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.208]                   3L)]
[13:20:00.208]             }
[13:20:00.208]             function(cond) {
[13:20:00.208]                 is_error <- inherits(cond, "error")
[13:20:00.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.208]                   NULL)
[13:20:00.208]                 if (is_error) {
[13:20:00.208]                   sessionInformation <- function() {
[13:20:00.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.208]                       search = base::search(), system = base::Sys.info())
[13:20:00.208]                   }
[13:20:00.208]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.208]                     cond$call), session = sessionInformation(), 
[13:20:00.208]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.208]                   signalCondition(cond)
[13:20:00.208]                 }
[13:20:00.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.208]                 "immediateCondition"))) {
[13:20:00.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.208]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.208]                   if (TRUE && !signal) {
[13:20:00.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.208]                     {
[13:20:00.208]                       inherits <- base::inherits
[13:20:00.208]                       invokeRestart <- base::invokeRestart
[13:20:00.208]                       is.null <- base::is.null
[13:20:00.208]                       muffled <- FALSE
[13:20:00.208]                       if (inherits(cond, "message")) {
[13:20:00.208]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.208]                         if (muffled) 
[13:20:00.208]                           invokeRestart("muffleMessage")
[13:20:00.208]                       }
[13:20:00.208]                       else if (inherits(cond, "warning")) {
[13:20:00.208]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.208]                         if (muffled) 
[13:20:00.208]                           invokeRestart("muffleWarning")
[13:20:00.208]                       }
[13:20:00.208]                       else if (inherits(cond, "condition")) {
[13:20:00.208]                         if (!is.null(pattern)) {
[13:20:00.208]                           computeRestarts <- base::computeRestarts
[13:20:00.208]                           grepl <- base::grepl
[13:20:00.208]                           restarts <- computeRestarts(cond)
[13:20:00.208]                           for (restart in restarts) {
[13:20:00.208]                             name <- restart$name
[13:20:00.208]                             if (is.null(name)) 
[13:20:00.208]                               next
[13:20:00.208]                             if (!grepl(pattern, name)) 
[13:20:00.208]                               next
[13:20:00.208]                             invokeRestart(restart)
[13:20:00.208]                             muffled <- TRUE
[13:20:00.208]                             break
[13:20:00.208]                           }
[13:20:00.208]                         }
[13:20:00.208]                       }
[13:20:00.208]                       invisible(muffled)
[13:20:00.208]                     }
[13:20:00.208]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.208]                   }
[13:20:00.208]                 }
[13:20:00.208]                 else {
[13:20:00.208]                   if (TRUE) {
[13:20:00.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.208]                     {
[13:20:00.208]                       inherits <- base::inherits
[13:20:00.208]                       invokeRestart <- base::invokeRestart
[13:20:00.208]                       is.null <- base::is.null
[13:20:00.208]                       muffled <- FALSE
[13:20:00.208]                       if (inherits(cond, "message")) {
[13:20:00.208]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.208]                         if (muffled) 
[13:20:00.208]                           invokeRestart("muffleMessage")
[13:20:00.208]                       }
[13:20:00.208]                       else if (inherits(cond, "warning")) {
[13:20:00.208]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.208]                         if (muffled) 
[13:20:00.208]                           invokeRestart("muffleWarning")
[13:20:00.208]                       }
[13:20:00.208]                       else if (inherits(cond, "condition")) {
[13:20:00.208]                         if (!is.null(pattern)) {
[13:20:00.208]                           computeRestarts <- base::computeRestarts
[13:20:00.208]                           grepl <- base::grepl
[13:20:00.208]                           restarts <- computeRestarts(cond)
[13:20:00.208]                           for (restart in restarts) {
[13:20:00.208]                             name <- restart$name
[13:20:00.208]                             if (is.null(name)) 
[13:20:00.208]                               next
[13:20:00.208]                             if (!grepl(pattern, name)) 
[13:20:00.208]                               next
[13:20:00.208]                             invokeRestart(restart)
[13:20:00.208]                             muffled <- TRUE
[13:20:00.208]                             break
[13:20:00.208]                           }
[13:20:00.208]                         }
[13:20:00.208]                       }
[13:20:00.208]                       invisible(muffled)
[13:20:00.208]                     }
[13:20:00.208]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.208]                   }
[13:20:00.208]                 }
[13:20:00.208]             }
[13:20:00.208]         }))
[13:20:00.208]     }, error = function(ex) {
[13:20:00.208]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.208]                 ...future.rng), started = ...future.startTime, 
[13:20:00.208]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.208]             version = "1.8"), class = "FutureResult")
[13:20:00.208]     }, finally = {
[13:20:00.208]         if (!identical(...future.workdir, getwd())) 
[13:20:00.208]             setwd(...future.workdir)
[13:20:00.208]         {
[13:20:00.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.208]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.208]             }
[13:20:00.208]             base::options(...future.oldOptions)
[13:20:00.208]             if (.Platform$OS.type == "windows") {
[13:20:00.208]                 old_names <- names(...future.oldEnvVars)
[13:20:00.208]                 envs <- base::Sys.getenv()
[13:20:00.208]                 names <- names(envs)
[13:20:00.208]                 common <- intersect(names, old_names)
[13:20:00.208]                 added <- setdiff(names, old_names)
[13:20:00.208]                 removed <- setdiff(old_names, names)
[13:20:00.208]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.208]                   envs[common]]
[13:20:00.208]                 NAMES <- toupper(changed)
[13:20:00.208]                 args <- list()
[13:20:00.208]                 for (kk in seq_along(NAMES)) {
[13:20:00.208]                   name <- changed[[kk]]
[13:20:00.208]                   NAME <- NAMES[[kk]]
[13:20:00.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.208]                     next
[13:20:00.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.208]                 }
[13:20:00.208]                 NAMES <- toupper(added)
[13:20:00.208]                 for (kk in seq_along(NAMES)) {
[13:20:00.208]                   name <- added[[kk]]
[13:20:00.208]                   NAME <- NAMES[[kk]]
[13:20:00.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.208]                     next
[13:20:00.208]                   args[[name]] <- ""
[13:20:00.208]                 }
[13:20:00.208]                 NAMES <- toupper(removed)
[13:20:00.208]                 for (kk in seq_along(NAMES)) {
[13:20:00.208]                   name <- removed[[kk]]
[13:20:00.208]                   NAME <- NAMES[[kk]]
[13:20:00.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.208]                     next
[13:20:00.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.208]                 }
[13:20:00.208]                 if (length(args) > 0) 
[13:20:00.208]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.208]             }
[13:20:00.208]             else {
[13:20:00.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.208]             }
[13:20:00.208]             {
[13:20:00.208]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.208]                   0L) {
[13:20:00.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.208]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.208]                   base::options(opts)
[13:20:00.208]                 }
[13:20:00.208]                 {
[13:20:00.208]                   {
[13:20:00.208]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.208]                     NULL
[13:20:00.208]                   }
[13:20:00.208]                   options(future.plan = NULL)
[13:20:00.208]                   if (is.na(NA_character_)) 
[13:20:00.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.208]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.208]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.208]                     envir = parent.frame()) 
[13:20:00.208]                   {
[13:20:00.208]                     if (is.function(workers)) 
[13:20:00.208]                       workers <- workers()
[13:20:00.208]                     workers <- structure(as.integer(workers), 
[13:20:00.208]                       class = class(workers))
[13:20:00.208]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.208]                       workers >= 1)
[13:20:00.208]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.208]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.208]                     }
[13:20:00.208]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.208]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.208]                       envir = envir)
[13:20:00.208]                     if (!future$lazy) 
[13:20:00.208]                       future <- run(future)
[13:20:00.208]                     invisible(future)
[13:20:00.208]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.208]                 }
[13:20:00.208]             }
[13:20:00.208]         }
[13:20:00.208]     })
[13:20:00.208]     if (TRUE) {
[13:20:00.208]         base::sink(type = "output", split = FALSE)
[13:20:00.208]         if (TRUE) {
[13:20:00.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.208]         }
[13:20:00.208]         else {
[13:20:00.208]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.208]         }
[13:20:00.208]         base::close(...future.stdout)
[13:20:00.208]         ...future.stdout <- NULL
[13:20:00.208]     }
[13:20:00.208]     ...future.result$conditions <- ...future.conditions
[13:20:00.208]     ...future.result$finished <- base::Sys.time()
[13:20:00.208]     ...future.result
[13:20:00.208] }
[13:20:00.210] Exporting 1 global objects (112 bytes) to cluster node #1 ...
[13:20:00.211] Exporting ‘future.call.arguments’ (112 bytes) to cluster node #1 ...
[13:20:00.211] Exporting ‘future.call.arguments’ (112 bytes) to cluster node #1 ... DONE
[13:20:00.211] Exporting 1 global objects (112 bytes) to cluster node #1 ... DONE
[13:20:00.212] MultisessionFuture started
[13:20:00.212] - Launch lazy future ... done
[13:20:00.212] run() for ‘MultisessionFuture’ ... done
[13:20:00.212] result() for ClusterFuture ...
[13:20:00.212] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.212] - Validating connection of MultisessionFuture
[13:20:00.257] - received message: FutureResult
[13:20:00.258] - Received FutureResult
[13:20:00.258] - Erased future from FutureRegistry
[13:20:00.258] result() for ClusterFuture ...
[13:20:00.258] - result already collected: FutureResult
[13:20:00.258] result() for ClusterFuture ... done
[13:20:00.258] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.258] result() for ClusterFuture ... done
[13:20:00.258] result() for ClusterFuture ...
[13:20:00.258] - result already collected: FutureResult
[13:20:00.258] result() for ClusterFuture ... done
[1] 6
** Sum function 'F' with plan('multisession') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x5622250ae1d8>
Using '...' in a formula
[13:20:00.259] getGlobalsAndPackages() ...
[13:20:00.259] Searching for globals...
[13:20:00.262] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[13:20:00.262] Searching for globals ... DONE
[13:20:00.262] Resolving globals: FALSE
[13:20:00.262] Tweak future expression to call with '...' arguments ...
[13:20:00.262] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[13:20:00.263] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[13:20:00.263] - globals: [3] ‘fcn’, ‘x’, ‘y’
[13:20:00.263] 
[13:20:00.263] getGlobalsAndPackages() ... DONE
[13:20:00.263] run() for ‘Future’ ...
[13:20:00.264] - state: ‘created’
[13:20:00.264] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:00.278] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:00.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:00.278]   - Field: ‘node’
[13:20:00.278]   - Field: ‘label’
[13:20:00.278]   - Field: ‘local’
[13:20:00.278]   - Field: ‘owner’
[13:20:00.279]   - Field: ‘envir’
[13:20:00.279]   - Field: ‘workers’
[13:20:00.279]   - Field: ‘packages’
[13:20:00.279]   - Field: ‘gc’
[13:20:00.279]   - Field: ‘conditions’
[13:20:00.279]   - Field: ‘persistent’
[13:20:00.279]   - Field: ‘expr’
[13:20:00.279]   - Field: ‘uuid’
[13:20:00.279]   - Field: ‘seed’
[13:20:00.279]   - Field: ‘version’
[13:20:00.280]   - Field: ‘result’
[13:20:00.280]   - Field: ‘asynchronous’
[13:20:00.280]   - Field: ‘calls’
[13:20:00.280]   - Field: ‘globals’
[13:20:00.280]   - Field: ‘stdout’
[13:20:00.280]   - Field: ‘earlySignal’
[13:20:00.280]   - Field: ‘lazy’
[13:20:00.280]   - Field: ‘state’
[13:20:00.280] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:00.280] - Launch lazy future ...
[13:20:00.281] Packages needed by the future expression (n = 0): <none>
[13:20:00.281] Packages needed by future strategies (n = 0): <none>
[13:20:00.281] {
[13:20:00.281]     {
[13:20:00.281]         {
[13:20:00.281]             ...future.startTime <- base::Sys.time()
[13:20:00.281]             {
[13:20:00.281]                 {
[13:20:00.281]                   {
[13:20:00.281]                     {
[13:20:00.281]                       base::local({
[13:20:00.281]                         has_future <- base::requireNamespace("future", 
[13:20:00.281]                           quietly = TRUE)
[13:20:00.281]                         if (has_future) {
[13:20:00.281]                           ns <- base::getNamespace("future")
[13:20:00.281]                           version <- ns[[".package"]][["version"]]
[13:20:00.281]                           if (is.null(version)) 
[13:20:00.281]                             version <- utils::packageVersion("future")
[13:20:00.281]                         }
[13:20:00.281]                         else {
[13:20:00.281]                           version <- NULL
[13:20:00.281]                         }
[13:20:00.281]                         if (!has_future || version < "1.8.0") {
[13:20:00.281]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:00.281]                             "", base::R.version$version.string), 
[13:20:00.281]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:00.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:00.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:00.281]                               "release", "version")], collapse = " "), 
[13:20:00.281]                             hostname = base::Sys.info()[["nodename"]])
[13:20:00.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:00.281]                             info)
[13:20:00.281]                           info <- base::paste(info, collapse = "; ")
[13:20:00.281]                           if (!has_future) {
[13:20:00.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:00.281]                               info)
[13:20:00.281]                           }
[13:20:00.281]                           else {
[13:20:00.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:00.281]                               info, version)
[13:20:00.281]                           }
[13:20:00.281]                           base::stop(msg)
[13:20:00.281]                         }
[13:20:00.281]                       })
[13:20:00.281]                     }
[13:20:00.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:00.281]                     base::options(mc.cores = 1L)
[13:20:00.281]                   }
[13:20:00.281]                   options(future.plan = NULL)
[13:20:00.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:00.281]                 }
[13:20:00.281]                 ...future.workdir <- getwd()
[13:20:00.281]             }
[13:20:00.281]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:00.281]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:00.281]         }
[13:20:00.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:00.281]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:00.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:00.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:00.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:00.281]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:00.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:00.281]             base::names(...future.oldOptions))
[13:20:00.281]     }
[13:20:00.281]     if (FALSE) {
[13:20:00.281]     }
[13:20:00.281]     else {
[13:20:00.281]         if (TRUE) {
[13:20:00.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:00.281]                 open = "w")
[13:20:00.281]         }
[13:20:00.281]         else {
[13:20:00.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:00.281]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:00.281]         }
[13:20:00.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:00.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:00.281]             base::sink(type = "output", split = FALSE)
[13:20:00.281]             base::close(...future.stdout)
[13:20:00.281]         }, add = TRUE)
[13:20:00.281]     }
[13:20:00.281]     ...future.frame <- base::sys.nframe()
[13:20:00.281]     ...future.conditions <- base::list()
[13:20:00.281]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:00.281]     if (FALSE) {
[13:20:00.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:00.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:00.281]     }
[13:20:00.281]     ...future.result <- base::tryCatch({
[13:20:00.281]         base::withCallingHandlers({
[13:20:00.281]             ...future.value <- base::withVisible(base::local({
[13:20:00.281]                 ...future.makeSendCondition <- local({
[13:20:00.281]                   sendCondition <- NULL
[13:20:00.281]                   function(frame = 1L) {
[13:20:00.281]                     if (is.function(sendCondition)) 
[13:20:00.281]                       return(sendCondition)
[13:20:00.281]                     ns <- getNamespace("parallel")
[13:20:00.281]                     if (exists("sendData", mode = "function", 
[13:20:00.281]                       envir = ns)) {
[13:20:00.281]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:00.281]                         envir = ns)
[13:20:00.281]                       envir <- sys.frame(frame)
[13:20:00.281]                       master <- NULL
[13:20:00.281]                       while (!identical(envir, .GlobalEnv) && 
[13:20:00.281]                         !identical(envir, emptyenv())) {
[13:20:00.281]                         if (exists("master", mode = "list", envir = envir, 
[13:20:00.281]                           inherits = FALSE)) {
[13:20:00.281]                           master <- get("master", mode = "list", 
[13:20:00.281]                             envir = envir, inherits = FALSE)
[13:20:00.281]                           if (inherits(master, c("SOCKnode", 
[13:20:00.281]                             "SOCK0node"))) {
[13:20:00.281]                             sendCondition <<- function(cond) {
[13:20:00.281]                               data <- list(type = "VALUE", value = cond, 
[13:20:00.281]                                 success = TRUE)
[13:20:00.281]                               parallel_sendData(master, data)
[13:20:00.281]                             }
[13:20:00.281]                             return(sendCondition)
[13:20:00.281]                           }
[13:20:00.281]                         }
[13:20:00.281]                         frame <- frame + 1L
[13:20:00.281]                         envir <- sys.frame(frame)
[13:20:00.281]                       }
[13:20:00.281]                     }
[13:20:00.281]                     sendCondition <<- function(cond) NULL
[13:20:00.281]                   }
[13:20:00.281]                 })
[13:20:00.281]                 withCallingHandlers({
[13:20:00.281]                   fcn(x, y)
[13:20:00.281]                 }, immediateCondition = function(cond) {
[13:20:00.281]                   sendCondition <- ...future.makeSendCondition()
[13:20:00.281]                   sendCondition(cond)
[13:20:00.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.281]                   {
[13:20:00.281]                     inherits <- base::inherits
[13:20:00.281]                     invokeRestart <- base::invokeRestart
[13:20:00.281]                     is.null <- base::is.null
[13:20:00.281]                     muffled <- FALSE
[13:20:00.281]                     if (inherits(cond, "message")) {
[13:20:00.281]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:00.281]                       if (muffled) 
[13:20:00.281]                         invokeRestart("muffleMessage")
[13:20:00.281]                     }
[13:20:00.281]                     else if (inherits(cond, "warning")) {
[13:20:00.281]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:00.281]                       if (muffled) 
[13:20:00.281]                         invokeRestart("muffleWarning")
[13:20:00.281]                     }
[13:20:00.281]                     else if (inherits(cond, "condition")) {
[13:20:00.281]                       if (!is.null(pattern)) {
[13:20:00.281]                         computeRestarts <- base::computeRestarts
[13:20:00.281]                         grepl <- base::grepl
[13:20:00.281]                         restarts <- computeRestarts(cond)
[13:20:00.281]                         for (restart in restarts) {
[13:20:00.281]                           name <- restart$name
[13:20:00.281]                           if (is.null(name)) 
[13:20:00.281]                             next
[13:20:00.281]                           if (!grepl(pattern, name)) 
[13:20:00.281]                             next
[13:20:00.281]                           invokeRestart(restart)
[13:20:00.281]                           muffled <- TRUE
[13:20:00.281]                           break
[13:20:00.281]                         }
[13:20:00.281]                       }
[13:20:00.281]                     }
[13:20:00.281]                     invisible(muffled)
[13:20:00.281]                   }
[13:20:00.281]                   muffleCondition(cond)
[13:20:00.281]                 })
[13:20:00.281]             }))
[13:20:00.281]             future::FutureResult(value = ...future.value$value, 
[13:20:00.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.281]                   ...future.rng), globalenv = if (FALSE) 
[13:20:00.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:00.281]                     ...future.globalenv.names))
[13:20:00.281]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:00.281]         }, condition = base::local({
[13:20:00.281]             c <- base::c
[13:20:00.281]             inherits <- base::inherits
[13:20:00.281]             invokeRestart <- base::invokeRestart
[13:20:00.281]             length <- base::length
[13:20:00.281]             list <- base::list
[13:20:00.281]             seq.int <- base::seq.int
[13:20:00.281]             signalCondition <- base::signalCondition
[13:20:00.281]             sys.calls <- base::sys.calls
[13:20:00.281]             `[[` <- base::`[[`
[13:20:00.281]             `+` <- base::`+`
[13:20:00.281]             `<<-` <- base::`<<-`
[13:20:00.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:00.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:00.281]                   3L)]
[13:20:00.281]             }
[13:20:00.281]             function(cond) {
[13:20:00.281]                 is_error <- inherits(cond, "error")
[13:20:00.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:00.281]                   NULL)
[13:20:00.281]                 if (is_error) {
[13:20:00.281]                   sessionInformation <- function() {
[13:20:00.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:00.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:00.281]                       search = base::search(), system = base::Sys.info())
[13:20:00.281]                   }
[13:20:00.281]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:00.281]                     cond$call), session = sessionInformation(), 
[13:20:00.281]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:00.281]                   signalCondition(cond)
[13:20:00.281]                 }
[13:20:00.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:00.281]                 "immediateCondition"))) {
[13:20:00.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:00.281]                   ...future.conditions[[length(...future.conditions) + 
[13:20:00.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:00.281]                   if (TRUE && !signal) {
[13:20:00.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.281]                     {
[13:20:00.281]                       inherits <- base::inherits
[13:20:00.281]                       invokeRestart <- base::invokeRestart
[13:20:00.281]                       is.null <- base::is.null
[13:20:00.281]                       muffled <- FALSE
[13:20:00.281]                       if (inherits(cond, "message")) {
[13:20:00.281]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.281]                         if (muffled) 
[13:20:00.281]                           invokeRestart("muffleMessage")
[13:20:00.281]                       }
[13:20:00.281]                       else if (inherits(cond, "warning")) {
[13:20:00.281]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.281]                         if (muffled) 
[13:20:00.281]                           invokeRestart("muffleWarning")
[13:20:00.281]                       }
[13:20:00.281]                       else if (inherits(cond, "condition")) {
[13:20:00.281]                         if (!is.null(pattern)) {
[13:20:00.281]                           computeRestarts <- base::computeRestarts
[13:20:00.281]                           grepl <- base::grepl
[13:20:00.281]                           restarts <- computeRestarts(cond)
[13:20:00.281]                           for (restart in restarts) {
[13:20:00.281]                             name <- restart$name
[13:20:00.281]                             if (is.null(name)) 
[13:20:00.281]                               next
[13:20:00.281]                             if (!grepl(pattern, name)) 
[13:20:00.281]                               next
[13:20:00.281]                             invokeRestart(restart)
[13:20:00.281]                             muffled <- TRUE
[13:20:00.281]                             break
[13:20:00.281]                           }
[13:20:00.281]                         }
[13:20:00.281]                       }
[13:20:00.281]                       invisible(muffled)
[13:20:00.281]                     }
[13:20:00.281]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.281]                   }
[13:20:00.281]                 }
[13:20:00.281]                 else {
[13:20:00.281]                   if (TRUE) {
[13:20:00.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:00.281]                     {
[13:20:00.281]                       inherits <- base::inherits
[13:20:00.281]                       invokeRestart <- base::invokeRestart
[13:20:00.281]                       is.null <- base::is.null
[13:20:00.281]                       muffled <- FALSE
[13:20:00.281]                       if (inherits(cond, "message")) {
[13:20:00.281]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:00.281]                         if (muffled) 
[13:20:00.281]                           invokeRestart("muffleMessage")
[13:20:00.281]                       }
[13:20:00.281]                       else if (inherits(cond, "warning")) {
[13:20:00.281]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:00.281]                         if (muffled) 
[13:20:00.281]                           invokeRestart("muffleWarning")
[13:20:00.281]                       }
[13:20:00.281]                       else if (inherits(cond, "condition")) {
[13:20:00.281]                         if (!is.null(pattern)) {
[13:20:00.281]                           computeRestarts <- base::computeRestarts
[13:20:00.281]                           grepl <- base::grepl
[13:20:00.281]                           restarts <- computeRestarts(cond)
[13:20:00.281]                           for (restart in restarts) {
[13:20:00.281]                             name <- restart$name
[13:20:00.281]                             if (is.null(name)) 
[13:20:00.281]                               next
[13:20:00.281]                             if (!grepl(pattern, name)) 
[13:20:00.281]                               next
[13:20:00.281]                             invokeRestart(restart)
[13:20:00.281]                             muffled <- TRUE
[13:20:00.281]                             break
[13:20:00.281]                           }
[13:20:00.281]                         }
[13:20:00.281]                       }
[13:20:00.281]                       invisible(muffled)
[13:20:00.281]                     }
[13:20:00.281]                     muffleCondition(cond, pattern = "^muffle")
[13:20:00.281]                   }
[13:20:00.281]                 }
[13:20:00.281]             }
[13:20:00.281]         }))
[13:20:00.281]     }, error = function(ex) {
[13:20:00.281]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:00.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:00.281]                 ...future.rng), started = ...future.startTime, 
[13:20:00.281]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:00.281]             version = "1.8"), class = "FutureResult")
[13:20:00.281]     }, finally = {
[13:20:00.281]         if (!identical(...future.workdir, getwd())) 
[13:20:00.281]             setwd(...future.workdir)
[13:20:00.281]         {
[13:20:00.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:00.281]                 ...future.oldOptions$nwarnings <- NULL
[13:20:00.281]             }
[13:20:00.281]             base::options(...future.oldOptions)
[13:20:00.281]             if (.Platform$OS.type == "windows") {
[13:20:00.281]                 old_names <- names(...future.oldEnvVars)
[13:20:00.281]                 envs <- base::Sys.getenv()
[13:20:00.281]                 names <- names(envs)
[13:20:00.281]                 common <- intersect(names, old_names)
[13:20:00.281]                 added <- setdiff(names, old_names)
[13:20:00.281]                 removed <- setdiff(old_names, names)
[13:20:00.281]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:00.281]                   envs[common]]
[13:20:00.281]                 NAMES <- toupper(changed)
[13:20:00.281]                 args <- list()
[13:20:00.281]                 for (kk in seq_along(NAMES)) {
[13:20:00.281]                   name <- changed[[kk]]
[13:20:00.281]                   NAME <- NAMES[[kk]]
[13:20:00.281]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.281]                     next
[13:20:00.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.281]                 }
[13:20:00.281]                 NAMES <- toupper(added)
[13:20:00.281]                 for (kk in seq_along(NAMES)) {
[13:20:00.281]                   name <- added[[kk]]
[13:20:00.281]                   NAME <- NAMES[[kk]]
[13:20:00.281]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.281]                     next
[13:20:00.281]                   args[[name]] <- ""
[13:20:00.281]                 }
[13:20:00.281]                 NAMES <- toupper(removed)
[13:20:00.281]                 for (kk in seq_along(NAMES)) {
[13:20:00.281]                   name <- removed[[kk]]
[13:20:00.281]                   NAME <- NAMES[[kk]]
[13:20:00.281]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:00.281]                     next
[13:20:00.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:00.281]                 }
[13:20:00.281]                 if (length(args) > 0) 
[13:20:00.281]                   base::do.call(base::Sys.setenv, args = args)
[13:20:00.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:00.281]             }
[13:20:00.281]             else {
[13:20:00.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:00.281]             }
[13:20:00.281]             {
[13:20:00.281]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:00.281]                   0L) {
[13:20:00.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:00.281]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:00.281]                   base::options(opts)
[13:20:00.281]                 }
[13:20:00.281]                 {
[13:20:00.281]                   {
[13:20:00.281]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:00.281]                     NULL
[13:20:00.281]                   }
[13:20:00.281]                   options(future.plan = NULL)
[13:20:00.281]                   if (is.na(NA_character_)) 
[13:20:00.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:00.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:00.281]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:00.281]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:00.281]                     envir = parent.frame()) 
[13:20:00.281]                   {
[13:20:00.281]                     if (is.function(workers)) 
[13:20:00.281]                       workers <- workers()
[13:20:00.281]                     workers <- structure(as.integer(workers), 
[13:20:00.281]                       class = class(workers))
[13:20:00.281]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:00.281]                       workers >= 1)
[13:20:00.281]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:00.281]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:00.281]                     }
[13:20:00.281]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:00.281]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:00.281]                       envir = envir)
[13:20:00.281]                     if (!future$lazy) 
[13:20:00.281]                       future <- run(future)
[13:20:00.281]                     invisible(future)
[13:20:00.281]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:00.281]                 }
[13:20:00.281]             }
[13:20:00.281]         }
[13:20:00.281]     })
[13:20:00.281]     if (TRUE) {
[13:20:00.281]         base::sink(type = "output", split = FALSE)
[13:20:00.281]         if (TRUE) {
[13:20:00.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:00.281]         }
[13:20:00.281]         else {
[13:20:00.281]             ...future.result["stdout"] <- base::list(NULL)
[13:20:00.281]         }
[13:20:00.281]         base::close(...future.stdout)
[13:20:00.281]         ...future.stdout <- NULL
[13:20:00.281]     }
[13:20:00.281]     ...future.result$conditions <- ...future.conditions
[13:20:00.281]     ...future.result$finished <- base::Sys.time()
[13:20:00.281]     ...future.result
[13:20:00.281] }
[13:20:00.284] Exporting 3 global objects (4.18 KiB) to cluster node #1 ...
[13:20:00.284] Exporting ‘fcn’ (4.07 KiB) to cluster node #1 ...
[13:20:00.284] Exporting ‘fcn’ (4.07 KiB) to cluster node #1 ... DONE
[13:20:00.284] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[13:20:00.285] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.285] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[13:20:00.285] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[13:20:00.285] Exporting 3 global objects (4.18 KiB) to cluster node #1 ... DONE
[13:20:00.286] MultisessionFuture started
[13:20:00.286] - Launch lazy future ... done
[13:20:00.286] run() for ‘MultisessionFuture’ ... done
[13:20:00.286] result() for ClusterFuture ...
[13:20:00.287] receiveMessageFromWorker() for ClusterFuture ...
[13:20:00.287] - Validating connection of MultisessionFuture
[13:20:00.333] - received message: FutureResult
[13:20:00.333] - Received FutureResult
[13:20:00.334] - Erased future from FutureRegistry
[13:20:00.334] result() for ClusterFuture ...
[13:20:00.334] - result already collected: FutureResult
[13:20:00.334] result() for ClusterFuture ... done
[13:20:00.334] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:00.334] result() for ClusterFuture ... done
[13:20:00.334] result() for ClusterFuture ...
[13:20:00.334] - result already collected: FutureResult
[13:20:00.334] result() for ClusterFuture ... done
[1] 6
Testing with 2 cores ... DONE
> 
> message("*** Global argument '...' ... DONE")
*** Global argument '...' ... DONE
> 
> source("incl/end.R")
[13:20:00.335] plan(): Setting new future strategy stack:
[13:20:00.335] List of future strategies:
[13:20:00.335] 1. FutureStrategy:
[13:20:00.335]    - args: function (..., envir = parent.frame())
[13:20:00.335]    - tweaked: FALSE
[13:20:00.335]    - call: future::plan(oplan)
[13:20:00.336] plan(): nbrOfWorkers() = 1
> 
