
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:41:52.852] plan(): Setting new future strategy stack:
[17:41:52.853] List of future strategies:
[17:41:52.853] 1. sequential:
[17:41:52.853]    - args: function (..., envir = parent.frame())
[17:41:52.853]    - tweaked: FALSE
[17:41:52.853]    - call: future::plan("sequential")
[17:41:52.867] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("*** Global argument '...' ...")
+ 
+   sum_fcns <- list()
+ 
+   sum_fcns$A <- function(x, ...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, ...) }
+     y
+   }
+ 
+ 
+   sum_fcns$B <- function(x, ...) {
+     sumt <- function(x) {
+       message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+       y %<-% { sum(x, ...) }
+       y
+     }
+     sumt(x)
+   }
+ 
+   sum_fcns$C <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y) }
+     y
+   }
+ 
+   sum_fcns$D <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y, ...) }
+     y
+   }
+ 
+   ## Issue/PR #400: Emulate how '...' may be used by the 'rlang' package
+   sum_fcns$E <- function(...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+ 
+     ## Grab '...' into a Globals object
+     globals <- globals::globalsByName("...", envir=environment())
+ 
+     ## Evaluate an expression with '...' in an environment that does not
+     ## have an '...' object - hence the parent.frame().  This will produce
+     ## an error unless we pass 'globals' which contains '...'
+     f <- future({
+       fcn <- function() sum(...)
+       fcn()
+     }, envir = parent.frame(), globals = globals)
+     y <- value(f)
+     y
+   }
+ 
+   ## Issue: https://github.com/HenrikBengtsson/globals/issues/72
+   sum_fcns$F <- function(x, y) {
+     message("Using '...' in a formula")
+ 
+     fcn <- function(x, y) {
+       z = ~ list(...)
+       sum(x, y)
+     }
+     
+     f <- future(fcn(x, y))
+     y <- value(f)
+     y
+   }
+ 
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy, substitute = FALSE)
+ 
+     for (name in names(sum_fcns)) {
+       message(sprintf("** Sum function '%s' with plan('%s') ...", name, strategy))
+       sum_fcn <- sum_fcns[[name]]
+       print(sum_fcn)
+       y <- try(sum_fcn(1:2, 3))
+       print(y)
+       if (name %in% c("D")) {
+         stopifnot(inherits(y, "try-error"))
+       } else {
+         stopifnot(y == 6)
+       }
+     }
+   }
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** Global argument '...' ...
- plan('sequential') ...
[17:41:52.917] plan(): Setting new future strategy stack:
[17:41:52.917] List of future strategies:
[17:41:52.917] 1. sequential:
[17:41:52.917]    - args: function (..., envir = parent.frame())
[17:41:52.917]    - tweaked: FALSE
[17:41:52.917]    - call: plan(strategy, substitute = FALSE)
[17:41:52.929] plan(): nbrOfWorkers() = 1
** Sum function 'A' with plan('sequential') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x55bfdb63bea8>
Arguments '...' exists: TRUE
[17:41:52.931] getGlobalsAndPackages() ...
[17:41:52.932] Searching for globals...
[17:41:52.939] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:41:52.939] Searching for globals ... DONE
[17:41:52.939] Resolving globals: FALSE
[17:41:52.939] Tweak future expression to call with '...' arguments ...
[17:41:52.940] {
[17:41:52.940]     do.call(function(...) {
[17:41:52.940]         sum(x, ...)
[17:41:52.940]     }, args = future.call.arguments)
[17:41:52.940] }
[17:41:52.940] Tweak future expression to call with '...' arguments ... DONE
[17:41:52.941] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:52.942] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:41:52.942] - globals: [2] ‘x’, ‘future.call.arguments’
[17:41:52.942] 
[17:41:52.942] getGlobalsAndPackages() ... DONE
[17:41:52.943] run() for ‘Future’ ...
[17:41:52.943] - state: ‘created’
[17:41:52.943] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:52.943] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:52.944] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:52.944]   - Field: ‘label’
[17:41:52.944]   - Field: ‘local’
[17:41:52.944]   - Field: ‘owner’
[17:41:52.944]   - Field: ‘envir’
[17:41:52.944]   - Field: ‘packages’
[17:41:52.944]   - Field: ‘gc’
[17:41:52.944]   - Field: ‘conditions’
[17:41:52.944]   - Field: ‘expr’
[17:41:52.944]   - Field: ‘uuid’
[17:41:52.945]   - Field: ‘seed’
[17:41:52.945]   - Field: ‘version’
[17:41:52.945]   - Field: ‘result’
[17:41:52.945]   - Field: ‘asynchronous’
[17:41:52.945]   - Field: ‘calls’
[17:41:52.945]   - Field: ‘globals’
[17:41:52.945]   - Field: ‘stdout’
[17:41:52.945]   - Field: ‘earlySignal’
[17:41:52.945]   - Field: ‘lazy’
[17:41:52.945]   - Field: ‘state’
[17:41:52.945] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:52.946] - Launch lazy future ...
[17:41:52.946] Packages needed by the future expression (n = 0): <none>
[17:41:52.946] Packages needed by future strategies (n = 0): <none>
[17:41:52.947] {
[17:41:52.947]     {
[17:41:52.947]         {
[17:41:52.947]             ...future.startTime <- base::Sys.time()
[17:41:52.947]             {
[17:41:52.947]                 {
[17:41:52.947]                   {
[17:41:52.947]                     base::local({
[17:41:52.947]                       has_future <- base::requireNamespace("future", 
[17:41:52.947]                         quietly = TRUE)
[17:41:52.947]                       if (has_future) {
[17:41:52.947]                         ns <- base::getNamespace("future")
[17:41:52.947]                         version <- ns[[".package"]][["version"]]
[17:41:52.947]                         if (is.null(version)) 
[17:41:52.947]                           version <- utils::packageVersion("future")
[17:41:52.947]                       }
[17:41:52.947]                       else {
[17:41:52.947]                         version <- NULL
[17:41:52.947]                       }
[17:41:52.947]                       if (!has_future || version < "1.8.0") {
[17:41:52.947]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:52.947]                           "", base::R.version$version.string), 
[17:41:52.947]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:52.947]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:52.947]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:52.947]                             "release", "version")], collapse = " "), 
[17:41:52.947]                           hostname = base::Sys.info()[["nodename"]])
[17:41:52.947]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:52.947]                           info)
[17:41:52.947]                         info <- base::paste(info, collapse = "; ")
[17:41:52.947]                         if (!has_future) {
[17:41:52.947]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:52.947]                             info)
[17:41:52.947]                         }
[17:41:52.947]                         else {
[17:41:52.947]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:52.947]                             info, version)
[17:41:52.947]                         }
[17:41:52.947]                         base::stop(msg)
[17:41:52.947]                       }
[17:41:52.947]                     })
[17:41:52.947]                   }
[17:41:52.947]                   options(future.plan = NULL)
[17:41:52.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:52.947]                 }
[17:41:52.947]                 ...future.workdir <- getwd()
[17:41:52.947]             }
[17:41:52.947]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:52.947]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:52.947]         }
[17:41:52.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:52.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:52.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:52.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:52.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:52.947]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:52.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:52.947]             base::names(...future.oldOptions))
[17:41:52.947]     }
[17:41:52.947]     if (FALSE) {
[17:41:52.947]     }
[17:41:52.947]     else {
[17:41:52.947]         if (TRUE) {
[17:41:52.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:52.947]                 open = "w")
[17:41:52.947]         }
[17:41:52.947]         else {
[17:41:52.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:52.947]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:52.947]         }
[17:41:52.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:52.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:52.947]             base::sink(type = "output", split = FALSE)
[17:41:52.947]             base::close(...future.stdout)
[17:41:52.947]         }, add = TRUE)
[17:41:52.947]     }
[17:41:52.947]     ...future.frame <- base::sys.nframe()
[17:41:52.947]     ...future.conditions <- base::list()
[17:41:52.947]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:52.947]     if (FALSE) {
[17:41:52.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:52.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:52.947]     }
[17:41:52.947]     ...future.result <- base::tryCatch({
[17:41:52.947]         base::withCallingHandlers({
[17:41:52.947]             ...future.value <- base::withVisible(base::local({
[17:41:52.947]                 do.call(function(...) {
[17:41:52.947]                   sum(x, ...)
[17:41:52.947]                 }, args = future.call.arguments)
[17:41:52.947]             }))
[17:41:52.947]             future::FutureResult(value = ...future.value$value, 
[17:41:52.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.947]                   ...future.rng), globalenv = if (FALSE) 
[17:41:52.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:52.947]                     ...future.globalenv.names))
[17:41:52.947]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:52.947]         }, condition = base::local({
[17:41:52.947]             c <- base::c
[17:41:52.947]             inherits <- base::inherits
[17:41:52.947]             invokeRestart <- base::invokeRestart
[17:41:52.947]             length <- base::length
[17:41:52.947]             list <- base::list
[17:41:52.947]             seq.int <- base::seq.int
[17:41:52.947]             signalCondition <- base::signalCondition
[17:41:52.947]             sys.calls <- base::sys.calls
[17:41:52.947]             `[[` <- base::`[[`
[17:41:52.947]             `+` <- base::`+`
[17:41:52.947]             `<<-` <- base::`<<-`
[17:41:52.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:52.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:52.947]                   3L)]
[17:41:52.947]             }
[17:41:52.947]             function(cond) {
[17:41:52.947]                 is_error <- inherits(cond, "error")
[17:41:52.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:52.947]                   NULL)
[17:41:52.947]                 if (is_error) {
[17:41:52.947]                   sessionInformation <- function() {
[17:41:52.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:52.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:52.947]                       search = base::search(), system = base::Sys.info())
[17:41:52.947]                   }
[17:41:52.947]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:52.947]                     cond$call), session = sessionInformation(), 
[17:41:52.947]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:52.947]                   signalCondition(cond)
[17:41:52.947]                 }
[17:41:52.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:52.947]                 "immediateCondition"))) {
[17:41:52.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:52.947]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:52.947]                   if (TRUE && !signal) {
[17:41:52.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.947]                     {
[17:41:52.947]                       inherits <- base::inherits
[17:41:52.947]                       invokeRestart <- base::invokeRestart
[17:41:52.947]                       is.null <- base::is.null
[17:41:52.947]                       muffled <- FALSE
[17:41:52.947]                       if (inherits(cond, "message")) {
[17:41:52.947]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.947]                         if (muffled) 
[17:41:52.947]                           invokeRestart("muffleMessage")
[17:41:52.947]                       }
[17:41:52.947]                       else if (inherits(cond, "warning")) {
[17:41:52.947]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.947]                         if (muffled) 
[17:41:52.947]                           invokeRestart("muffleWarning")
[17:41:52.947]                       }
[17:41:52.947]                       else if (inherits(cond, "condition")) {
[17:41:52.947]                         if (!is.null(pattern)) {
[17:41:52.947]                           computeRestarts <- base::computeRestarts
[17:41:52.947]                           grepl <- base::grepl
[17:41:52.947]                           restarts <- computeRestarts(cond)
[17:41:52.947]                           for (restart in restarts) {
[17:41:52.947]                             name <- restart$name
[17:41:52.947]                             if (is.null(name)) 
[17:41:52.947]                               next
[17:41:52.947]                             if (!grepl(pattern, name)) 
[17:41:52.947]                               next
[17:41:52.947]                             invokeRestart(restart)
[17:41:52.947]                             muffled <- TRUE
[17:41:52.947]                             break
[17:41:52.947]                           }
[17:41:52.947]                         }
[17:41:52.947]                       }
[17:41:52.947]                       invisible(muffled)
[17:41:52.947]                     }
[17:41:52.947]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.947]                   }
[17:41:52.947]                 }
[17:41:52.947]                 else {
[17:41:52.947]                   if (TRUE) {
[17:41:52.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.947]                     {
[17:41:52.947]                       inherits <- base::inherits
[17:41:52.947]                       invokeRestart <- base::invokeRestart
[17:41:52.947]                       is.null <- base::is.null
[17:41:52.947]                       muffled <- FALSE
[17:41:52.947]                       if (inherits(cond, "message")) {
[17:41:52.947]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.947]                         if (muffled) 
[17:41:52.947]                           invokeRestart("muffleMessage")
[17:41:52.947]                       }
[17:41:52.947]                       else if (inherits(cond, "warning")) {
[17:41:52.947]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.947]                         if (muffled) 
[17:41:52.947]                           invokeRestart("muffleWarning")
[17:41:52.947]                       }
[17:41:52.947]                       else if (inherits(cond, "condition")) {
[17:41:52.947]                         if (!is.null(pattern)) {
[17:41:52.947]                           computeRestarts <- base::computeRestarts
[17:41:52.947]                           grepl <- base::grepl
[17:41:52.947]                           restarts <- computeRestarts(cond)
[17:41:52.947]                           for (restart in restarts) {
[17:41:52.947]                             name <- restart$name
[17:41:52.947]                             if (is.null(name)) 
[17:41:52.947]                               next
[17:41:52.947]                             if (!grepl(pattern, name)) 
[17:41:52.947]                               next
[17:41:52.947]                             invokeRestart(restart)
[17:41:52.947]                             muffled <- TRUE
[17:41:52.947]                             break
[17:41:52.947]                           }
[17:41:52.947]                         }
[17:41:52.947]                       }
[17:41:52.947]                       invisible(muffled)
[17:41:52.947]                     }
[17:41:52.947]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.947]                   }
[17:41:52.947]                 }
[17:41:52.947]             }
[17:41:52.947]         }))
[17:41:52.947]     }, error = function(ex) {
[17:41:52.947]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:52.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.947]                 ...future.rng), started = ...future.startTime, 
[17:41:52.947]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:52.947]             version = "1.8"), class = "FutureResult")
[17:41:52.947]     }, finally = {
[17:41:52.947]         if (!identical(...future.workdir, getwd())) 
[17:41:52.947]             setwd(...future.workdir)
[17:41:52.947]         {
[17:41:52.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:52.947]                 ...future.oldOptions$nwarnings <- NULL
[17:41:52.947]             }
[17:41:52.947]             base::options(...future.oldOptions)
[17:41:52.947]             if (.Platform$OS.type == "windows") {
[17:41:52.947]                 old_names <- names(...future.oldEnvVars)
[17:41:52.947]                 envs <- base::Sys.getenv()
[17:41:52.947]                 names <- names(envs)
[17:41:52.947]                 common <- intersect(names, old_names)
[17:41:52.947]                 added <- setdiff(names, old_names)
[17:41:52.947]                 removed <- setdiff(old_names, names)
[17:41:52.947]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:52.947]                   envs[common]]
[17:41:52.947]                 NAMES <- toupper(changed)
[17:41:52.947]                 args <- list()
[17:41:52.947]                 for (kk in seq_along(NAMES)) {
[17:41:52.947]                   name <- changed[[kk]]
[17:41:52.947]                   NAME <- NAMES[[kk]]
[17:41:52.947]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.947]                     next
[17:41:52.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.947]                 }
[17:41:52.947]                 NAMES <- toupper(added)
[17:41:52.947]                 for (kk in seq_along(NAMES)) {
[17:41:52.947]                   name <- added[[kk]]
[17:41:52.947]                   NAME <- NAMES[[kk]]
[17:41:52.947]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.947]                     next
[17:41:52.947]                   args[[name]] <- ""
[17:41:52.947]                 }
[17:41:52.947]                 NAMES <- toupper(removed)
[17:41:52.947]                 for (kk in seq_along(NAMES)) {
[17:41:52.947]                   name <- removed[[kk]]
[17:41:52.947]                   NAME <- NAMES[[kk]]
[17:41:52.947]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.947]                     next
[17:41:52.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.947]                 }
[17:41:52.947]                 if (length(args) > 0) 
[17:41:52.947]                   base::do.call(base::Sys.setenv, args = args)
[17:41:52.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:52.947]             }
[17:41:52.947]             else {
[17:41:52.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:52.947]             }
[17:41:52.947]             {
[17:41:52.947]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:52.947]                   0L) {
[17:41:52.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:52.947]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:52.947]                   base::options(opts)
[17:41:52.947]                 }
[17:41:52.947]                 {
[17:41:52.947]                   {
[17:41:52.947]                     NULL
[17:41:52.947]                     RNGkind("Mersenne-Twister")
[17:41:52.947]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:52.947]                       inherits = FALSE)
[17:41:52.947]                   }
[17:41:52.947]                   options(future.plan = NULL)
[17:41:52.947]                   if (is.na(NA_character_)) 
[17:41:52.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:52.947]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:52.947]                   {
[17:41:52.947]                     future <- SequentialFuture(..., envir = envir)
[17:41:52.947]                     if (!future$lazy) 
[17:41:52.947]                       future <- run(future)
[17:41:52.947]                     invisible(future)
[17:41:52.947]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:52.947]                 }
[17:41:52.947]             }
[17:41:52.947]         }
[17:41:52.947]     })
[17:41:52.947]     if (TRUE) {
[17:41:52.947]         base::sink(type = "output", split = FALSE)
[17:41:52.947]         if (TRUE) {
[17:41:52.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:52.947]         }
[17:41:52.947]         else {
[17:41:52.947]             ...future.result["stdout"] <- base::list(NULL)
[17:41:52.947]         }
[17:41:52.947]         base::close(...future.stdout)
[17:41:52.947]         ...future.stdout <- NULL
[17:41:52.947]     }
[17:41:52.947]     ...future.result$conditions <- ...future.conditions
[17:41:52.947]     ...future.result$finished <- base::Sys.time()
[17:41:52.947]     ...future.result
[17:41:52.947] }
[17:41:52.949] assign_globals() ...
[17:41:52.949] List of 2
[17:41:52.949]  $ x                    : int [1:2] 1 2
[17:41:52.949]  $ future.call.arguments:List of 1
[17:41:52.949]   ..$ : num 3
[17:41:52.949]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:52.949]  - attr(*, "where")=List of 2
[17:41:52.949]   ..$ x                    :<environment: R_EmptyEnv> 
[17:41:52.949]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:41:52.949]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:52.949]  - attr(*, "resolved")= logi FALSE
[17:41:52.949]  - attr(*, "total_size")= num 112
[17:41:52.949]  - attr(*, "already-done")= logi TRUE
[17:41:52.955] - copied ‘x’ to environment
[17:41:52.956] - copied ‘future.call.arguments’ to environment
[17:41:52.956] assign_globals() ... done
[17:41:52.956] plan(): Setting new future strategy stack:
[17:41:52.956] List of future strategies:
[17:41:52.956] 1. sequential:
[17:41:52.956]    - args: function (..., envir = parent.frame())
[17:41:52.956]    - tweaked: FALSE
[17:41:52.956]    - call: NULL
[17:41:52.956] plan(): nbrOfWorkers() = 1
[17:41:52.958] plan(): Setting new future strategy stack:
[17:41:52.958] List of future strategies:
[17:41:52.958] 1. sequential:
[17:41:52.958]    - args: function (..., envir = parent.frame())
[17:41:52.958]    - tweaked: FALSE
[17:41:52.958]    - call: plan(strategy, substitute = FALSE)
[17:41:52.958] plan(): nbrOfWorkers() = 1
[17:41:52.958] SequentialFuture started (and completed)
[17:41:52.959] - Launch lazy future ... done
[17:41:52.959] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'B' with plan('sequential') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x55bfdb93cec0>
Arguments '...' exists: TRUE
[17:41:52.960] getGlobalsAndPackages() ...
[17:41:52.960] Searching for globals...
[17:41:52.961] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:41:52.962] Searching for globals ... DONE
[17:41:52.962] Resolving globals: FALSE
[17:41:52.964] Tweak future expression to call with '...' arguments ...
[17:41:52.964] {
[17:41:52.964]     do.call(function(...) {
[17:41:52.964]         sum(x, ...)
[17:41:52.964]     }, args = future.call.arguments)
[17:41:52.964] }
[17:41:52.965] Tweak future expression to call with '...' arguments ... DONE
[17:41:52.965] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:52.965] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:41:52.966] - globals: [2] ‘x’, ‘future.call.arguments’
[17:41:52.966] 
[17:41:52.966] getGlobalsAndPackages() ... DONE
[17:41:52.966] run() for ‘Future’ ...
[17:41:52.966] - state: ‘created’
[17:41:52.966] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:52.967] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:52.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:52.967]   - Field: ‘label’
[17:41:52.967]   - Field: ‘local’
[17:41:52.967]   - Field: ‘owner’
[17:41:52.967]   - Field: ‘envir’
[17:41:52.967]   - Field: ‘packages’
[17:41:52.967]   - Field: ‘gc’
[17:41:52.967]   - Field: ‘conditions’
[17:41:52.968]   - Field: ‘expr’
[17:41:52.968]   - Field: ‘uuid’
[17:41:52.968]   - Field: ‘seed’
[17:41:52.968]   - Field: ‘version’
[17:41:52.968]   - Field: ‘result’
[17:41:52.968]   - Field: ‘asynchronous’
[17:41:52.968]   - Field: ‘calls’
[17:41:52.968]   - Field: ‘globals’
[17:41:52.968]   - Field: ‘stdout’
[17:41:52.968]   - Field: ‘earlySignal’
[17:41:52.969]   - Field: ‘lazy’
[17:41:52.969]   - Field: ‘state’
[17:41:52.969] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:52.969] - Launch lazy future ...
[17:41:52.969] Packages needed by the future expression (n = 0): <none>
[17:41:52.969] Packages needed by future strategies (n = 0): <none>
[17:41:52.970] {
[17:41:52.970]     {
[17:41:52.970]         {
[17:41:52.970]             ...future.startTime <- base::Sys.time()
[17:41:52.970]             {
[17:41:52.970]                 {
[17:41:52.970]                   {
[17:41:52.970]                     base::local({
[17:41:52.970]                       has_future <- base::requireNamespace("future", 
[17:41:52.970]                         quietly = TRUE)
[17:41:52.970]                       if (has_future) {
[17:41:52.970]                         ns <- base::getNamespace("future")
[17:41:52.970]                         version <- ns[[".package"]][["version"]]
[17:41:52.970]                         if (is.null(version)) 
[17:41:52.970]                           version <- utils::packageVersion("future")
[17:41:52.970]                       }
[17:41:52.970]                       else {
[17:41:52.970]                         version <- NULL
[17:41:52.970]                       }
[17:41:52.970]                       if (!has_future || version < "1.8.0") {
[17:41:52.970]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:52.970]                           "", base::R.version$version.string), 
[17:41:52.970]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:52.970]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:52.970]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:52.970]                             "release", "version")], collapse = " "), 
[17:41:52.970]                           hostname = base::Sys.info()[["nodename"]])
[17:41:52.970]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:52.970]                           info)
[17:41:52.970]                         info <- base::paste(info, collapse = "; ")
[17:41:52.970]                         if (!has_future) {
[17:41:52.970]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:52.970]                             info)
[17:41:52.970]                         }
[17:41:52.970]                         else {
[17:41:52.970]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:52.970]                             info, version)
[17:41:52.970]                         }
[17:41:52.970]                         base::stop(msg)
[17:41:52.970]                       }
[17:41:52.970]                     })
[17:41:52.970]                   }
[17:41:52.970]                   options(future.plan = NULL)
[17:41:52.970]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.970]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:52.970]                 }
[17:41:52.970]                 ...future.workdir <- getwd()
[17:41:52.970]             }
[17:41:52.970]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:52.970]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:52.970]         }
[17:41:52.970]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:52.970]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:52.970]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:52.970]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:52.970]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:52.970]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:52.970]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:52.970]             base::names(...future.oldOptions))
[17:41:52.970]     }
[17:41:52.970]     if (FALSE) {
[17:41:52.970]     }
[17:41:52.970]     else {
[17:41:52.970]         if (TRUE) {
[17:41:52.970]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:52.970]                 open = "w")
[17:41:52.970]         }
[17:41:52.970]         else {
[17:41:52.970]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:52.970]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:52.970]         }
[17:41:52.970]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:52.970]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:52.970]             base::sink(type = "output", split = FALSE)
[17:41:52.970]             base::close(...future.stdout)
[17:41:52.970]         }, add = TRUE)
[17:41:52.970]     }
[17:41:52.970]     ...future.frame <- base::sys.nframe()
[17:41:52.970]     ...future.conditions <- base::list()
[17:41:52.970]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:52.970]     if (FALSE) {
[17:41:52.970]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:52.970]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:52.970]     }
[17:41:52.970]     ...future.result <- base::tryCatch({
[17:41:52.970]         base::withCallingHandlers({
[17:41:52.970]             ...future.value <- base::withVisible(base::local({
[17:41:52.970]                 do.call(function(...) {
[17:41:52.970]                   sum(x, ...)
[17:41:52.970]                 }, args = future.call.arguments)
[17:41:52.970]             }))
[17:41:52.970]             future::FutureResult(value = ...future.value$value, 
[17:41:52.970]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.970]                   ...future.rng), globalenv = if (FALSE) 
[17:41:52.970]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:52.970]                     ...future.globalenv.names))
[17:41:52.970]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:52.970]         }, condition = base::local({
[17:41:52.970]             c <- base::c
[17:41:52.970]             inherits <- base::inherits
[17:41:52.970]             invokeRestart <- base::invokeRestart
[17:41:52.970]             length <- base::length
[17:41:52.970]             list <- base::list
[17:41:52.970]             seq.int <- base::seq.int
[17:41:52.970]             signalCondition <- base::signalCondition
[17:41:52.970]             sys.calls <- base::sys.calls
[17:41:52.970]             `[[` <- base::`[[`
[17:41:52.970]             `+` <- base::`+`
[17:41:52.970]             `<<-` <- base::`<<-`
[17:41:52.970]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:52.970]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:52.970]                   3L)]
[17:41:52.970]             }
[17:41:52.970]             function(cond) {
[17:41:52.970]                 is_error <- inherits(cond, "error")
[17:41:52.970]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:52.970]                   NULL)
[17:41:52.970]                 if (is_error) {
[17:41:52.970]                   sessionInformation <- function() {
[17:41:52.970]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:52.970]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:52.970]                       search = base::search(), system = base::Sys.info())
[17:41:52.970]                   }
[17:41:52.970]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.970]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:52.970]                     cond$call), session = sessionInformation(), 
[17:41:52.970]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:52.970]                   signalCondition(cond)
[17:41:52.970]                 }
[17:41:52.970]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:52.970]                 "immediateCondition"))) {
[17:41:52.970]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:52.970]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.970]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:52.970]                   if (TRUE && !signal) {
[17:41:52.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.970]                     {
[17:41:52.970]                       inherits <- base::inherits
[17:41:52.970]                       invokeRestart <- base::invokeRestart
[17:41:52.970]                       is.null <- base::is.null
[17:41:52.970]                       muffled <- FALSE
[17:41:52.970]                       if (inherits(cond, "message")) {
[17:41:52.970]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.970]                         if (muffled) 
[17:41:52.970]                           invokeRestart("muffleMessage")
[17:41:52.970]                       }
[17:41:52.970]                       else if (inherits(cond, "warning")) {
[17:41:52.970]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.970]                         if (muffled) 
[17:41:52.970]                           invokeRestart("muffleWarning")
[17:41:52.970]                       }
[17:41:52.970]                       else if (inherits(cond, "condition")) {
[17:41:52.970]                         if (!is.null(pattern)) {
[17:41:52.970]                           computeRestarts <- base::computeRestarts
[17:41:52.970]                           grepl <- base::grepl
[17:41:52.970]                           restarts <- computeRestarts(cond)
[17:41:52.970]                           for (restart in restarts) {
[17:41:52.970]                             name <- restart$name
[17:41:52.970]                             if (is.null(name)) 
[17:41:52.970]                               next
[17:41:52.970]                             if (!grepl(pattern, name)) 
[17:41:52.970]                               next
[17:41:52.970]                             invokeRestart(restart)
[17:41:52.970]                             muffled <- TRUE
[17:41:52.970]                             break
[17:41:52.970]                           }
[17:41:52.970]                         }
[17:41:52.970]                       }
[17:41:52.970]                       invisible(muffled)
[17:41:52.970]                     }
[17:41:52.970]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.970]                   }
[17:41:52.970]                 }
[17:41:52.970]                 else {
[17:41:52.970]                   if (TRUE) {
[17:41:52.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.970]                     {
[17:41:52.970]                       inherits <- base::inherits
[17:41:52.970]                       invokeRestart <- base::invokeRestart
[17:41:52.970]                       is.null <- base::is.null
[17:41:52.970]                       muffled <- FALSE
[17:41:52.970]                       if (inherits(cond, "message")) {
[17:41:52.970]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.970]                         if (muffled) 
[17:41:52.970]                           invokeRestart("muffleMessage")
[17:41:52.970]                       }
[17:41:52.970]                       else if (inherits(cond, "warning")) {
[17:41:52.970]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.970]                         if (muffled) 
[17:41:52.970]                           invokeRestart("muffleWarning")
[17:41:52.970]                       }
[17:41:52.970]                       else if (inherits(cond, "condition")) {
[17:41:52.970]                         if (!is.null(pattern)) {
[17:41:52.970]                           computeRestarts <- base::computeRestarts
[17:41:52.970]                           grepl <- base::grepl
[17:41:52.970]                           restarts <- computeRestarts(cond)
[17:41:52.970]                           for (restart in restarts) {
[17:41:52.970]                             name <- restart$name
[17:41:52.970]                             if (is.null(name)) 
[17:41:52.970]                               next
[17:41:52.970]                             if (!grepl(pattern, name)) 
[17:41:52.970]                               next
[17:41:52.970]                             invokeRestart(restart)
[17:41:52.970]                             muffled <- TRUE
[17:41:52.970]                             break
[17:41:52.970]                           }
[17:41:52.970]                         }
[17:41:52.970]                       }
[17:41:52.970]                       invisible(muffled)
[17:41:52.970]                     }
[17:41:52.970]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.970]                   }
[17:41:52.970]                 }
[17:41:52.970]             }
[17:41:52.970]         }))
[17:41:52.970]     }, error = function(ex) {
[17:41:52.970]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:52.970]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.970]                 ...future.rng), started = ...future.startTime, 
[17:41:52.970]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:52.970]             version = "1.8"), class = "FutureResult")
[17:41:52.970]     }, finally = {
[17:41:52.970]         if (!identical(...future.workdir, getwd())) 
[17:41:52.970]             setwd(...future.workdir)
[17:41:52.970]         {
[17:41:52.970]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:52.970]                 ...future.oldOptions$nwarnings <- NULL
[17:41:52.970]             }
[17:41:52.970]             base::options(...future.oldOptions)
[17:41:52.970]             if (.Platform$OS.type == "windows") {
[17:41:52.970]                 old_names <- names(...future.oldEnvVars)
[17:41:52.970]                 envs <- base::Sys.getenv()
[17:41:52.970]                 names <- names(envs)
[17:41:52.970]                 common <- intersect(names, old_names)
[17:41:52.970]                 added <- setdiff(names, old_names)
[17:41:52.970]                 removed <- setdiff(old_names, names)
[17:41:52.970]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:52.970]                   envs[common]]
[17:41:52.970]                 NAMES <- toupper(changed)
[17:41:52.970]                 args <- list()
[17:41:52.970]                 for (kk in seq_along(NAMES)) {
[17:41:52.970]                   name <- changed[[kk]]
[17:41:52.970]                   NAME <- NAMES[[kk]]
[17:41:52.970]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.970]                     next
[17:41:52.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.970]                 }
[17:41:52.970]                 NAMES <- toupper(added)
[17:41:52.970]                 for (kk in seq_along(NAMES)) {
[17:41:52.970]                   name <- added[[kk]]
[17:41:52.970]                   NAME <- NAMES[[kk]]
[17:41:52.970]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.970]                     next
[17:41:52.970]                   args[[name]] <- ""
[17:41:52.970]                 }
[17:41:52.970]                 NAMES <- toupper(removed)
[17:41:52.970]                 for (kk in seq_along(NAMES)) {
[17:41:52.970]                   name <- removed[[kk]]
[17:41:52.970]                   NAME <- NAMES[[kk]]
[17:41:52.970]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.970]                     next
[17:41:52.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.970]                 }
[17:41:52.970]                 if (length(args) > 0) 
[17:41:52.970]                   base::do.call(base::Sys.setenv, args = args)
[17:41:52.970]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:52.970]             }
[17:41:52.970]             else {
[17:41:52.970]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:52.970]             }
[17:41:52.970]             {
[17:41:52.970]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:52.970]                   0L) {
[17:41:52.970]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:52.970]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:52.970]                   base::options(opts)
[17:41:52.970]                 }
[17:41:52.970]                 {
[17:41:52.970]                   {
[17:41:52.970]                     NULL
[17:41:52.970]                     RNGkind("Mersenne-Twister")
[17:41:52.970]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:52.970]                       inherits = FALSE)
[17:41:52.970]                   }
[17:41:52.970]                   options(future.plan = NULL)
[17:41:52.970]                   if (is.na(NA_character_)) 
[17:41:52.970]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.970]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:52.970]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:52.970]                   {
[17:41:52.970]                     future <- SequentialFuture(..., envir = envir)
[17:41:52.970]                     if (!future$lazy) 
[17:41:52.970]                       future <- run(future)
[17:41:52.970]                     invisible(future)
[17:41:52.970]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:52.970]                 }
[17:41:52.970]             }
[17:41:52.970]         }
[17:41:52.970]     })
[17:41:52.970]     if (TRUE) {
[17:41:52.970]         base::sink(type = "output", split = FALSE)
[17:41:52.970]         if (TRUE) {
[17:41:52.970]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:52.970]         }
[17:41:52.970]         else {
[17:41:52.970]             ...future.result["stdout"] <- base::list(NULL)
[17:41:52.970]         }
[17:41:52.970]         base::close(...future.stdout)
[17:41:52.970]         ...future.stdout <- NULL
[17:41:52.970]     }
[17:41:52.970]     ...future.result$conditions <- ...future.conditions
[17:41:52.970]     ...future.result$finished <- base::Sys.time()
[17:41:52.970]     ...future.result
[17:41:52.970] }
[17:41:52.971] assign_globals() ...
[17:41:52.971] List of 2
[17:41:52.971]  $ x                    : int [1:2] 1 2
[17:41:52.971]  $ future.call.arguments:List of 1
[17:41:52.971]   ..$ : num 3
[17:41:52.971]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:52.971]  - attr(*, "where")=List of 2
[17:41:52.971]   ..$ x                    :<environment: R_EmptyEnv> 
[17:41:52.971]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:41:52.971]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:52.971]  - attr(*, "resolved")= logi FALSE
[17:41:52.971]  - attr(*, "total_size")= num 112
[17:41:52.971]  - attr(*, "already-done")= logi TRUE
[17:41:52.975] - copied ‘x’ to environment
[17:41:52.975] - copied ‘future.call.arguments’ to environment
[17:41:52.975] assign_globals() ... done
[17:41:52.976] plan(): Setting new future strategy stack:
[17:41:52.976] List of future strategies:
[17:41:52.976] 1. sequential:
[17:41:52.976]    - args: function (..., envir = parent.frame())
[17:41:52.976]    - tweaked: FALSE
[17:41:52.976]    - call: NULL
[17:41:52.976] plan(): nbrOfWorkers() = 1
[17:41:52.977] plan(): Setting new future strategy stack:
[17:41:52.977] List of future strategies:
[17:41:52.977] 1. sequential:
[17:41:52.977]    - args: function (..., envir = parent.frame())
[17:41:52.977]    - tweaked: FALSE
[17:41:52.977]    - call: plan(strategy, substitute = FALSE)
[17:41:52.977] plan(): nbrOfWorkers() = 1
[17:41:52.978] SequentialFuture started (and completed)
[17:41:52.978] - Launch lazy future ... done
[17:41:52.978] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'C' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55bfdbab5fc0>
Arguments '...' exists: FALSE
[17:41:52.979] getGlobalsAndPackages() ...
[17:41:52.979] Searching for globals...
[17:41:52.980] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[17:41:52.980] Searching for globals ... DONE
[17:41:52.980] Resolving globals: FALSE
[17:41:52.980] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:52.981] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:41:52.981] - globals: [2] ‘x’, ‘y’
[17:41:52.981] 
[17:41:52.981] getGlobalsAndPackages() ... DONE
[17:41:52.981] run() for ‘Future’ ...
[17:41:52.982] - state: ‘created’
[17:41:52.982] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:52.982] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:52.982] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:52.982]   - Field: ‘label’
[17:41:52.982]   - Field: ‘local’
[17:41:52.982]   - Field: ‘owner’
[17:41:52.982]   - Field: ‘envir’
[17:41:52.983]   - Field: ‘packages’
[17:41:52.983]   - Field: ‘gc’
[17:41:52.983]   - Field: ‘conditions’
[17:41:52.983]   - Field: ‘expr’
[17:41:52.983]   - Field: ‘uuid’
[17:41:52.983]   - Field: ‘seed’
[17:41:52.983]   - Field: ‘version’
[17:41:52.983]   - Field: ‘result’
[17:41:52.983]   - Field: ‘asynchronous’
[17:41:52.983]   - Field: ‘calls’
[17:41:52.983]   - Field: ‘globals’
[17:41:52.984]   - Field: ‘stdout’
[17:41:52.984]   - Field: ‘earlySignal’
[17:41:52.984]   - Field: ‘lazy’
[17:41:52.984]   - Field: ‘state’
[17:41:52.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:52.984] - Launch lazy future ...
[17:41:52.984] Packages needed by the future expression (n = 0): <none>
[17:41:52.984] Packages needed by future strategies (n = 0): <none>
[17:41:52.985] {
[17:41:52.985]     {
[17:41:52.985]         {
[17:41:52.985]             ...future.startTime <- base::Sys.time()
[17:41:52.985]             {
[17:41:52.985]                 {
[17:41:52.985]                   {
[17:41:52.985]                     base::local({
[17:41:52.985]                       has_future <- base::requireNamespace("future", 
[17:41:52.985]                         quietly = TRUE)
[17:41:52.985]                       if (has_future) {
[17:41:52.985]                         ns <- base::getNamespace("future")
[17:41:52.985]                         version <- ns[[".package"]][["version"]]
[17:41:52.985]                         if (is.null(version)) 
[17:41:52.985]                           version <- utils::packageVersion("future")
[17:41:52.985]                       }
[17:41:52.985]                       else {
[17:41:52.985]                         version <- NULL
[17:41:52.985]                       }
[17:41:52.985]                       if (!has_future || version < "1.8.0") {
[17:41:52.985]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:52.985]                           "", base::R.version$version.string), 
[17:41:52.985]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:52.985]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:52.985]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:52.985]                             "release", "version")], collapse = " "), 
[17:41:52.985]                           hostname = base::Sys.info()[["nodename"]])
[17:41:52.985]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:52.985]                           info)
[17:41:52.985]                         info <- base::paste(info, collapse = "; ")
[17:41:52.985]                         if (!has_future) {
[17:41:52.985]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:52.985]                             info)
[17:41:52.985]                         }
[17:41:52.985]                         else {
[17:41:52.985]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:52.985]                             info, version)
[17:41:52.985]                         }
[17:41:52.985]                         base::stop(msg)
[17:41:52.985]                       }
[17:41:52.985]                     })
[17:41:52.985]                   }
[17:41:52.985]                   options(future.plan = NULL)
[17:41:52.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:52.985]                 }
[17:41:52.985]                 ...future.workdir <- getwd()
[17:41:52.985]             }
[17:41:52.985]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:52.985]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:52.985]         }
[17:41:52.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:52.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:52.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:52.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:52.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:52.985]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:52.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:52.985]             base::names(...future.oldOptions))
[17:41:52.985]     }
[17:41:52.985]     if (FALSE) {
[17:41:52.985]     }
[17:41:52.985]     else {
[17:41:52.985]         if (TRUE) {
[17:41:52.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:52.985]                 open = "w")
[17:41:52.985]         }
[17:41:52.985]         else {
[17:41:52.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:52.985]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:52.985]         }
[17:41:52.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:52.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:52.985]             base::sink(type = "output", split = FALSE)
[17:41:52.985]             base::close(...future.stdout)
[17:41:52.985]         }, add = TRUE)
[17:41:52.985]     }
[17:41:52.985]     ...future.frame <- base::sys.nframe()
[17:41:52.985]     ...future.conditions <- base::list()
[17:41:52.985]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:52.985]     if (FALSE) {
[17:41:52.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:52.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:52.985]     }
[17:41:52.985]     ...future.result <- base::tryCatch({
[17:41:52.985]         base::withCallingHandlers({
[17:41:52.985]             ...future.value <- base::withVisible(base::local({
[17:41:52.985]                 sum(x, y)
[17:41:52.985]             }))
[17:41:52.985]             future::FutureResult(value = ...future.value$value, 
[17:41:52.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.985]                   ...future.rng), globalenv = if (FALSE) 
[17:41:52.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:52.985]                     ...future.globalenv.names))
[17:41:52.985]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:52.985]         }, condition = base::local({
[17:41:52.985]             c <- base::c
[17:41:52.985]             inherits <- base::inherits
[17:41:52.985]             invokeRestart <- base::invokeRestart
[17:41:52.985]             length <- base::length
[17:41:52.985]             list <- base::list
[17:41:52.985]             seq.int <- base::seq.int
[17:41:52.985]             signalCondition <- base::signalCondition
[17:41:52.985]             sys.calls <- base::sys.calls
[17:41:52.985]             `[[` <- base::`[[`
[17:41:52.985]             `+` <- base::`+`
[17:41:52.985]             `<<-` <- base::`<<-`
[17:41:52.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:52.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:52.985]                   3L)]
[17:41:52.985]             }
[17:41:52.985]             function(cond) {
[17:41:52.985]                 is_error <- inherits(cond, "error")
[17:41:52.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:52.985]                   NULL)
[17:41:52.985]                 if (is_error) {
[17:41:52.985]                   sessionInformation <- function() {
[17:41:52.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:52.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:52.985]                       search = base::search(), system = base::Sys.info())
[17:41:52.985]                   }
[17:41:52.985]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:52.985]                     cond$call), session = sessionInformation(), 
[17:41:52.985]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:52.985]                   signalCondition(cond)
[17:41:52.985]                 }
[17:41:52.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:52.985]                 "immediateCondition"))) {
[17:41:52.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:52.985]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:52.985]                   if (TRUE && !signal) {
[17:41:52.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.985]                     {
[17:41:52.985]                       inherits <- base::inherits
[17:41:52.985]                       invokeRestart <- base::invokeRestart
[17:41:52.985]                       is.null <- base::is.null
[17:41:52.985]                       muffled <- FALSE
[17:41:52.985]                       if (inherits(cond, "message")) {
[17:41:52.985]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.985]                         if (muffled) 
[17:41:52.985]                           invokeRestart("muffleMessage")
[17:41:52.985]                       }
[17:41:52.985]                       else if (inherits(cond, "warning")) {
[17:41:52.985]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.985]                         if (muffled) 
[17:41:52.985]                           invokeRestart("muffleWarning")
[17:41:52.985]                       }
[17:41:52.985]                       else if (inherits(cond, "condition")) {
[17:41:52.985]                         if (!is.null(pattern)) {
[17:41:52.985]                           computeRestarts <- base::computeRestarts
[17:41:52.985]                           grepl <- base::grepl
[17:41:52.985]                           restarts <- computeRestarts(cond)
[17:41:52.985]                           for (restart in restarts) {
[17:41:52.985]                             name <- restart$name
[17:41:52.985]                             if (is.null(name)) 
[17:41:52.985]                               next
[17:41:52.985]                             if (!grepl(pattern, name)) 
[17:41:52.985]                               next
[17:41:52.985]                             invokeRestart(restart)
[17:41:52.985]                             muffled <- TRUE
[17:41:52.985]                             break
[17:41:52.985]                           }
[17:41:52.985]                         }
[17:41:52.985]                       }
[17:41:52.985]                       invisible(muffled)
[17:41:52.985]                     }
[17:41:52.985]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.985]                   }
[17:41:52.985]                 }
[17:41:52.985]                 else {
[17:41:52.985]                   if (TRUE) {
[17:41:52.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.985]                     {
[17:41:52.985]                       inherits <- base::inherits
[17:41:52.985]                       invokeRestart <- base::invokeRestart
[17:41:52.985]                       is.null <- base::is.null
[17:41:52.985]                       muffled <- FALSE
[17:41:52.985]                       if (inherits(cond, "message")) {
[17:41:52.985]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.985]                         if (muffled) 
[17:41:52.985]                           invokeRestart("muffleMessage")
[17:41:52.985]                       }
[17:41:52.985]                       else if (inherits(cond, "warning")) {
[17:41:52.985]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.985]                         if (muffled) 
[17:41:52.985]                           invokeRestart("muffleWarning")
[17:41:52.985]                       }
[17:41:52.985]                       else if (inherits(cond, "condition")) {
[17:41:52.985]                         if (!is.null(pattern)) {
[17:41:52.985]                           computeRestarts <- base::computeRestarts
[17:41:52.985]                           grepl <- base::grepl
[17:41:52.985]                           restarts <- computeRestarts(cond)
[17:41:52.985]                           for (restart in restarts) {
[17:41:52.985]                             name <- restart$name
[17:41:52.985]                             if (is.null(name)) 
[17:41:52.985]                               next
[17:41:52.985]                             if (!grepl(pattern, name)) 
[17:41:52.985]                               next
[17:41:52.985]                             invokeRestart(restart)
[17:41:52.985]                             muffled <- TRUE
[17:41:52.985]                             break
[17:41:52.985]                           }
[17:41:52.985]                         }
[17:41:52.985]                       }
[17:41:52.985]                       invisible(muffled)
[17:41:52.985]                     }
[17:41:52.985]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.985]                   }
[17:41:52.985]                 }
[17:41:52.985]             }
[17:41:52.985]         }))
[17:41:52.985]     }, error = function(ex) {
[17:41:52.985]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:52.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.985]                 ...future.rng), started = ...future.startTime, 
[17:41:52.985]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:52.985]             version = "1.8"), class = "FutureResult")
[17:41:52.985]     }, finally = {
[17:41:52.985]         if (!identical(...future.workdir, getwd())) 
[17:41:52.985]             setwd(...future.workdir)
[17:41:52.985]         {
[17:41:52.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:52.985]                 ...future.oldOptions$nwarnings <- NULL
[17:41:52.985]             }
[17:41:52.985]             base::options(...future.oldOptions)
[17:41:52.985]             if (.Platform$OS.type == "windows") {
[17:41:52.985]                 old_names <- names(...future.oldEnvVars)
[17:41:52.985]                 envs <- base::Sys.getenv()
[17:41:52.985]                 names <- names(envs)
[17:41:52.985]                 common <- intersect(names, old_names)
[17:41:52.985]                 added <- setdiff(names, old_names)
[17:41:52.985]                 removed <- setdiff(old_names, names)
[17:41:52.985]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:52.985]                   envs[common]]
[17:41:52.985]                 NAMES <- toupper(changed)
[17:41:52.985]                 args <- list()
[17:41:52.985]                 for (kk in seq_along(NAMES)) {
[17:41:52.985]                   name <- changed[[kk]]
[17:41:52.985]                   NAME <- NAMES[[kk]]
[17:41:52.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.985]                     next
[17:41:52.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.985]                 }
[17:41:52.985]                 NAMES <- toupper(added)
[17:41:52.985]                 for (kk in seq_along(NAMES)) {
[17:41:52.985]                   name <- added[[kk]]
[17:41:52.985]                   NAME <- NAMES[[kk]]
[17:41:52.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.985]                     next
[17:41:52.985]                   args[[name]] <- ""
[17:41:52.985]                 }
[17:41:52.985]                 NAMES <- toupper(removed)
[17:41:52.985]                 for (kk in seq_along(NAMES)) {
[17:41:52.985]                   name <- removed[[kk]]
[17:41:52.985]                   NAME <- NAMES[[kk]]
[17:41:52.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.985]                     next
[17:41:52.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.985]                 }
[17:41:52.985]                 if (length(args) > 0) 
[17:41:52.985]                   base::do.call(base::Sys.setenv, args = args)
[17:41:52.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:52.985]             }
[17:41:52.985]             else {
[17:41:52.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:52.985]             }
[17:41:52.985]             {
[17:41:52.985]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:52.985]                   0L) {
[17:41:52.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:52.985]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:52.985]                   base::options(opts)
[17:41:52.985]                 }
[17:41:52.985]                 {
[17:41:52.985]                   {
[17:41:52.985]                     NULL
[17:41:52.985]                     RNGkind("Mersenne-Twister")
[17:41:52.985]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:52.985]                       inherits = FALSE)
[17:41:52.985]                   }
[17:41:52.985]                   options(future.plan = NULL)
[17:41:52.985]                   if (is.na(NA_character_)) 
[17:41:52.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:52.985]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:52.985]                   {
[17:41:52.985]                     future <- SequentialFuture(..., envir = envir)
[17:41:52.985]                     if (!future$lazy) 
[17:41:52.985]                       future <- run(future)
[17:41:52.985]                     invisible(future)
[17:41:52.985]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:52.985]                 }
[17:41:52.985]             }
[17:41:52.985]         }
[17:41:52.985]     })
[17:41:52.985]     if (TRUE) {
[17:41:52.985]         base::sink(type = "output", split = FALSE)
[17:41:52.985]         if (TRUE) {
[17:41:52.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:52.985]         }
[17:41:52.985]         else {
[17:41:52.985]             ...future.result["stdout"] <- base::list(NULL)
[17:41:52.985]         }
[17:41:52.985]         base::close(...future.stdout)
[17:41:52.985]         ...future.stdout <- NULL
[17:41:52.985]     }
[17:41:52.985]     ...future.result$conditions <- ...future.conditions
[17:41:52.985]     ...future.result$finished <- base::Sys.time()
[17:41:52.985]     ...future.result
[17:41:52.985] }
[17:41:52.986] assign_globals() ...
[17:41:52.986] List of 2
[17:41:52.986]  $ x: int [1:2] 1 2
[17:41:52.986]  $ y: num 3
[17:41:52.986]  - attr(*, "where")=List of 2
[17:41:52.986]   ..$ x:<environment: R_EmptyEnv> 
[17:41:52.986]   ..$ y:<environment: R_EmptyEnv> 
[17:41:52.986]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:52.986]  - attr(*, "resolved")= logi FALSE
[17:41:52.986]  - attr(*, "total_size")= num 112
[17:41:52.986]  - attr(*, "already-done")= logi TRUE
[17:41:52.990] - copied ‘x’ to environment
[17:41:52.990] - copied ‘y’ to environment
[17:41:52.990] assign_globals() ... done
[17:41:52.990] plan(): Setting new future strategy stack:
[17:41:52.990] List of future strategies:
[17:41:52.990] 1. sequential:
[17:41:52.990]    - args: function (..., envir = parent.frame())
[17:41:52.990]    - tweaked: FALSE
[17:41:52.990]    - call: NULL
[17:41:52.991] plan(): nbrOfWorkers() = 1
[17:41:52.991] plan(): Setting new future strategy stack:
[17:41:52.992] List of future strategies:
[17:41:52.992] 1. sequential:
[17:41:52.992]    - args: function (..., envir = parent.frame())
[17:41:52.992]    - tweaked: FALSE
[17:41:52.992]    - call: plan(strategy, substitute = FALSE)
[17:41:52.992] plan(): nbrOfWorkers() = 1
[17:41:52.992] SequentialFuture started (and completed)
[17:41:52.992] - Launch lazy future ... done
[17:41:52.992] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'D' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x55bfd9c698d0>
Arguments '...' exists: FALSE
[17:41:52.993] getGlobalsAndPackages() ...
[17:41:52.993] Searching for globals...
[17:41:52.996] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[17:41:52.996] Searching for globals ... DONE
[17:41:52.996] Resolving globals: FALSE
[17:41:52.997] Tweak future expression to call with '...' arguments ...
[17:41:52.997] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:52.997] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:41:52.998] - globals: [2] ‘x’, ‘y’
[17:41:52.998] 
[17:41:52.998] getGlobalsAndPackages() ... DONE
[17:41:52.998] run() for ‘Future’ ...
[17:41:52.998] - state: ‘created’
[17:41:52.998] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:52.999] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:52.999] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:52.999]   - Field: ‘label’
[17:41:52.999]   - Field: ‘local’
[17:41:52.999]   - Field: ‘owner’
[17:41:52.999]   - Field: ‘envir’
[17:41:52.999]   - Field: ‘packages’
[17:41:52.999]   - Field: ‘gc’
[17:41:52.999]   - Field: ‘conditions’
[17:41:53.000]   - Field: ‘expr’
[17:41:53.000]   - Field: ‘uuid’
[17:41:53.000]   - Field: ‘seed’
[17:41:53.000]   - Field: ‘version’
[17:41:53.000]   - Field: ‘result’
[17:41:53.000]   - Field: ‘asynchronous’
[17:41:53.000]   - Field: ‘calls’
[17:41:53.000]   - Field: ‘globals’
[17:41:53.000]   - Field: ‘stdout’
[17:41:53.000]   - Field: ‘earlySignal’
[17:41:53.001]   - Field: ‘lazy’
[17:41:53.001]   - Field: ‘state’
[17:41:53.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:53.001] - Launch lazy future ...
[17:41:53.001] Packages needed by the future expression (n = 0): <none>
[17:41:53.001] Packages needed by future strategies (n = 0): <none>
[17:41:53.002] {
[17:41:53.002]     {
[17:41:53.002]         {
[17:41:53.002]             ...future.startTime <- base::Sys.time()
[17:41:53.002]             {
[17:41:53.002]                 {
[17:41:53.002]                   {
[17:41:53.002]                     base::local({
[17:41:53.002]                       has_future <- base::requireNamespace("future", 
[17:41:53.002]                         quietly = TRUE)
[17:41:53.002]                       if (has_future) {
[17:41:53.002]                         ns <- base::getNamespace("future")
[17:41:53.002]                         version <- ns[[".package"]][["version"]]
[17:41:53.002]                         if (is.null(version)) 
[17:41:53.002]                           version <- utils::packageVersion("future")
[17:41:53.002]                       }
[17:41:53.002]                       else {
[17:41:53.002]                         version <- NULL
[17:41:53.002]                       }
[17:41:53.002]                       if (!has_future || version < "1.8.0") {
[17:41:53.002]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:53.002]                           "", base::R.version$version.string), 
[17:41:53.002]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:53.002]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:53.002]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:53.002]                             "release", "version")], collapse = " "), 
[17:41:53.002]                           hostname = base::Sys.info()[["nodename"]])
[17:41:53.002]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:53.002]                           info)
[17:41:53.002]                         info <- base::paste(info, collapse = "; ")
[17:41:53.002]                         if (!has_future) {
[17:41:53.002]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:53.002]                             info)
[17:41:53.002]                         }
[17:41:53.002]                         else {
[17:41:53.002]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:53.002]                             info, version)
[17:41:53.002]                         }
[17:41:53.002]                         base::stop(msg)
[17:41:53.002]                       }
[17:41:53.002]                     })
[17:41:53.002]                   }
[17:41:53.002]                   options(future.plan = NULL)
[17:41:53.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:53.002]                 }
[17:41:53.002]                 ...future.workdir <- getwd()
[17:41:53.002]             }
[17:41:53.002]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:53.002]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:53.002]         }
[17:41:53.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:53.002]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:53.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:53.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:53.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:53.002]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:53.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:53.002]             base::names(...future.oldOptions))
[17:41:53.002]     }
[17:41:53.002]     if (FALSE) {
[17:41:53.002]     }
[17:41:53.002]     else {
[17:41:53.002]         if (TRUE) {
[17:41:53.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:53.002]                 open = "w")
[17:41:53.002]         }
[17:41:53.002]         else {
[17:41:53.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:53.002]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:53.002]         }
[17:41:53.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:53.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:53.002]             base::sink(type = "output", split = FALSE)
[17:41:53.002]             base::close(...future.stdout)
[17:41:53.002]         }, add = TRUE)
[17:41:53.002]     }
[17:41:53.002]     ...future.frame <- base::sys.nframe()
[17:41:53.002]     ...future.conditions <- base::list()
[17:41:53.002]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:53.002]     if (FALSE) {
[17:41:53.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:53.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:53.002]     }
[17:41:53.002]     ...future.result <- base::tryCatch({
[17:41:53.002]         base::withCallingHandlers({
[17:41:53.002]             ...future.value <- base::withVisible(base::local({
[17:41:53.002]                 sum(x, y, ...)
[17:41:53.002]             }))
[17:41:53.002]             future::FutureResult(value = ...future.value$value, 
[17:41:53.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.002]                   ...future.rng), globalenv = if (FALSE) 
[17:41:53.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:53.002]                     ...future.globalenv.names))
[17:41:53.002]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:53.002]         }, condition = base::local({
[17:41:53.002]             c <- base::c
[17:41:53.002]             inherits <- base::inherits
[17:41:53.002]             invokeRestart <- base::invokeRestart
[17:41:53.002]             length <- base::length
[17:41:53.002]             list <- base::list
[17:41:53.002]             seq.int <- base::seq.int
[17:41:53.002]             signalCondition <- base::signalCondition
[17:41:53.002]             sys.calls <- base::sys.calls
[17:41:53.002]             `[[` <- base::`[[`
[17:41:53.002]             `+` <- base::`+`
[17:41:53.002]             `<<-` <- base::`<<-`
[17:41:53.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:53.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:53.002]                   3L)]
[17:41:53.002]             }
[17:41:53.002]             function(cond) {
[17:41:53.002]                 is_error <- inherits(cond, "error")
[17:41:53.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:53.002]                   NULL)
[17:41:53.002]                 if (is_error) {
[17:41:53.002]                   sessionInformation <- function() {
[17:41:53.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:53.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:53.002]                       search = base::search(), system = base::Sys.info())
[17:41:53.002]                   }
[17:41:53.002]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:53.002]                     cond$call), session = sessionInformation(), 
[17:41:53.002]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:53.002]                   signalCondition(cond)
[17:41:53.002]                 }
[17:41:53.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:53.002]                 "immediateCondition"))) {
[17:41:53.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:53.002]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:53.002]                   if (TRUE && !signal) {
[17:41:53.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.002]                     {
[17:41:53.002]                       inherits <- base::inherits
[17:41:53.002]                       invokeRestart <- base::invokeRestart
[17:41:53.002]                       is.null <- base::is.null
[17:41:53.002]                       muffled <- FALSE
[17:41:53.002]                       if (inherits(cond, "message")) {
[17:41:53.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.002]                         if (muffled) 
[17:41:53.002]                           invokeRestart("muffleMessage")
[17:41:53.002]                       }
[17:41:53.002]                       else if (inherits(cond, "warning")) {
[17:41:53.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.002]                         if (muffled) 
[17:41:53.002]                           invokeRestart("muffleWarning")
[17:41:53.002]                       }
[17:41:53.002]                       else if (inherits(cond, "condition")) {
[17:41:53.002]                         if (!is.null(pattern)) {
[17:41:53.002]                           computeRestarts <- base::computeRestarts
[17:41:53.002]                           grepl <- base::grepl
[17:41:53.002]                           restarts <- computeRestarts(cond)
[17:41:53.002]                           for (restart in restarts) {
[17:41:53.002]                             name <- restart$name
[17:41:53.002]                             if (is.null(name)) 
[17:41:53.002]                               next
[17:41:53.002]                             if (!grepl(pattern, name)) 
[17:41:53.002]                               next
[17:41:53.002]                             invokeRestart(restart)
[17:41:53.002]                             muffled <- TRUE
[17:41:53.002]                             break
[17:41:53.002]                           }
[17:41:53.002]                         }
[17:41:53.002]                       }
[17:41:53.002]                       invisible(muffled)
[17:41:53.002]                     }
[17:41:53.002]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.002]                   }
[17:41:53.002]                 }
[17:41:53.002]                 else {
[17:41:53.002]                   if (TRUE) {
[17:41:53.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.002]                     {
[17:41:53.002]                       inherits <- base::inherits
[17:41:53.002]                       invokeRestart <- base::invokeRestart
[17:41:53.002]                       is.null <- base::is.null
[17:41:53.002]                       muffled <- FALSE
[17:41:53.002]                       if (inherits(cond, "message")) {
[17:41:53.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.002]                         if (muffled) 
[17:41:53.002]                           invokeRestart("muffleMessage")
[17:41:53.002]                       }
[17:41:53.002]                       else if (inherits(cond, "warning")) {
[17:41:53.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.002]                         if (muffled) 
[17:41:53.002]                           invokeRestart("muffleWarning")
[17:41:53.002]                       }
[17:41:53.002]                       else if (inherits(cond, "condition")) {
[17:41:53.002]                         if (!is.null(pattern)) {
[17:41:53.002]                           computeRestarts <- base::computeRestarts
[17:41:53.002]                           grepl <- base::grepl
[17:41:53.002]                           restarts <- computeRestarts(cond)
[17:41:53.002]                           for (restart in restarts) {
[17:41:53.002]                             name <- restart$name
[17:41:53.002]                             if (is.null(name)) 
[17:41:53.002]                               next
[17:41:53.002]                             if (!grepl(pattern, name)) 
[17:41:53.002]                               next
[17:41:53.002]                             invokeRestart(restart)
[17:41:53.002]                             muffled <- TRUE
[17:41:53.002]                             break
[17:41:53.002]                           }
[17:41:53.002]                         }
[17:41:53.002]                       }
[17:41:53.002]                       invisible(muffled)
[17:41:53.002]                     }
[17:41:53.002]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.002]                   }
[17:41:53.002]                 }
[17:41:53.002]             }
[17:41:53.002]         }))
[17:41:53.002]     }, error = function(ex) {
[17:41:53.002]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:53.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.002]                 ...future.rng), started = ...future.startTime, 
[17:41:53.002]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:53.002]             version = "1.8"), class = "FutureResult")
[17:41:53.002]     }, finally = {
[17:41:53.002]         if (!identical(...future.workdir, getwd())) 
[17:41:53.002]             setwd(...future.workdir)
[17:41:53.002]         {
[17:41:53.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:53.002]                 ...future.oldOptions$nwarnings <- NULL
[17:41:53.002]             }
[17:41:53.002]             base::options(...future.oldOptions)
[17:41:53.002]             if (.Platform$OS.type == "windows") {
[17:41:53.002]                 old_names <- names(...future.oldEnvVars)
[17:41:53.002]                 envs <- base::Sys.getenv()
[17:41:53.002]                 names <- names(envs)
[17:41:53.002]                 common <- intersect(names, old_names)
[17:41:53.002]                 added <- setdiff(names, old_names)
[17:41:53.002]                 removed <- setdiff(old_names, names)
[17:41:53.002]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:53.002]                   envs[common]]
[17:41:53.002]                 NAMES <- toupper(changed)
[17:41:53.002]                 args <- list()
[17:41:53.002]                 for (kk in seq_along(NAMES)) {
[17:41:53.002]                   name <- changed[[kk]]
[17:41:53.002]                   NAME <- NAMES[[kk]]
[17:41:53.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.002]                     next
[17:41:53.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.002]                 }
[17:41:53.002]                 NAMES <- toupper(added)
[17:41:53.002]                 for (kk in seq_along(NAMES)) {
[17:41:53.002]                   name <- added[[kk]]
[17:41:53.002]                   NAME <- NAMES[[kk]]
[17:41:53.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.002]                     next
[17:41:53.002]                   args[[name]] <- ""
[17:41:53.002]                 }
[17:41:53.002]                 NAMES <- toupper(removed)
[17:41:53.002]                 for (kk in seq_along(NAMES)) {
[17:41:53.002]                   name <- removed[[kk]]
[17:41:53.002]                   NAME <- NAMES[[kk]]
[17:41:53.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.002]                     next
[17:41:53.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.002]                 }
[17:41:53.002]                 if (length(args) > 0) 
[17:41:53.002]                   base::do.call(base::Sys.setenv, args = args)
[17:41:53.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:53.002]             }
[17:41:53.002]             else {
[17:41:53.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:53.002]             }
[17:41:53.002]             {
[17:41:53.002]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:53.002]                   0L) {
[17:41:53.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:53.002]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:53.002]                   base::options(opts)
[17:41:53.002]                 }
[17:41:53.002]                 {
[17:41:53.002]                   {
[17:41:53.002]                     NULL
[17:41:53.002]                     RNGkind("Mersenne-Twister")
[17:41:53.002]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:53.002]                       inherits = FALSE)
[17:41:53.002]                   }
[17:41:53.002]                   options(future.plan = NULL)
[17:41:53.002]                   if (is.na(NA_character_)) 
[17:41:53.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:53.002]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:53.002]                   {
[17:41:53.002]                     future <- SequentialFuture(..., envir = envir)
[17:41:53.002]                     if (!future$lazy) 
[17:41:53.002]                       future <- run(future)
[17:41:53.002]                     invisible(future)
[17:41:53.002]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:53.002]                 }
[17:41:53.002]             }
[17:41:53.002]         }
[17:41:53.002]     })
[17:41:53.002]     if (TRUE) {
[17:41:53.002]         base::sink(type = "output", split = FALSE)
[17:41:53.002]         if (TRUE) {
[17:41:53.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:53.002]         }
[17:41:53.002]         else {
[17:41:53.002]             ...future.result["stdout"] <- base::list(NULL)
[17:41:53.002]         }
[17:41:53.002]         base::close(...future.stdout)
[17:41:53.002]         ...future.stdout <- NULL
[17:41:53.002]     }
[17:41:53.002]     ...future.result$conditions <- ...future.conditions
[17:41:53.002]     ...future.result$finished <- base::Sys.time()
[17:41:53.002]     ...future.result
[17:41:53.002] }
[17:41:53.003] assign_globals() ...
[17:41:53.003] List of 2
[17:41:53.003]  $ x: int [1:2] 1 2
[17:41:53.003]  $ y: num 3
[17:41:53.003]  - attr(*, "where")=List of 2
[17:41:53.003]   ..$ x:<environment: R_EmptyEnv> 
[17:41:53.003]   ..$ y:<environment: R_EmptyEnv> 
[17:41:53.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:53.003]  - attr(*, "resolved")= logi FALSE
[17:41:53.003]  - attr(*, "total_size")= num 112
[17:41:53.003]  - attr(*, "already-done")= logi TRUE
[17:41:53.007] - copied ‘x’ to environment
[17:41:53.007] - copied ‘y’ to environment
[17:41:53.007] assign_globals() ... done
[17:41:53.007] plan(): Setting new future strategy stack:
[17:41:53.007] List of future strategies:
[17:41:53.007] 1. sequential:
[17:41:53.007]    - args: function (..., envir = parent.frame())
[17:41:53.007]    - tweaked: FALSE
[17:41:53.007]    - call: NULL
[17:41:53.008] plan(): nbrOfWorkers() = 1
[17:41:53.009] plan(): Setting new future strategy stack:
[17:41:53.009] List of future strategies:
[17:41:53.009] 1. sequential:
[17:41:53.009]    - args: function (..., envir = parent.frame())
[17:41:53.009]    - tweaked: FALSE
[17:41:53.009]    - call: plan(strategy, substitute = FALSE)
[17:41:53.009] plan(): nbrOfWorkers() = 1
[17:41:53.009] SequentialFuture started (and completed)
[17:41:53.009] signalConditions() ...
[17:41:53.009]  - include = ‘immediateCondition’
[17:41:53.010]  - exclude = 
[17:41:53.010]  - resignal = FALSE
[17:41:53.010]  - Number of conditions: 1
[17:41:53.010] signalConditions() ... done
[17:41:53.010] - Launch lazy future ... done
[17:41:53.010] run() for ‘SequentialFuture’ ... done
[17:41:53.010] signalConditions() ...
[17:41:53.010]  - include = ‘immediateCondition’
[17:41:53.010]  - exclude = 
[17:41:53.010]  - resignal = FALSE
[17:41:53.011]  - Number of conditions: 1
[17:41:53.011] signalConditions() ... done
[17:41:53.011] Future state: ‘finished’
[17:41:53.011] signalConditions() ...
[17:41:53.011]  - include = ‘condition’
[17:41:53.011]  - exclude = ‘immediateCondition’
[17:41:53.011]  - resignal = TRUE
[17:41:53.011]  - Number of conditions: 1
[17:41:53.011]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:41:53.012] signalConditions() ... done
Error in eval(quote({ : '...' used in an incorrect context
[1] "Error in eval(quote({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    sum(x, y, ...)}), new.env()): '...' used in an incorrect context>
** Sum function 'E' with plan('sequential') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x55bfdac31dd0>
Arguments '...' exists: TRUE
[17:41:53.012] getGlobalsAndPackages() ...
[17:41:53.012] - globals passed as-is: [1] ‘...’
[17:41:53.012] Resolving globals: FALSE
[17:41:53.013] Tweak future expression to call with '...' arguments ...
[17:41:53.013] {
[17:41:53.013]     do.call(function(...) {
[17:41:53.013]         fcn <- function() sum(...)
[17:41:53.013]         fcn()
[17:41:53.013]     }, args = future.call.arguments)
[17:41:53.013] }
[17:41:53.013] Tweak future expression to call with '...' arguments ... DONE
[17:41:53.013] The total size of the 1 globals is 112 bytes (112 bytes)
[17:41:53.014] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[17:41:53.014] - globals: [1] ‘future.call.arguments’
[17:41:53.014] 
[17:41:53.014] getGlobalsAndPackages() ... DONE
[17:41:53.014] run() for ‘Future’ ...
[17:41:53.014] - state: ‘created’
[17:41:53.014] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:53.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:53.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:53.015]   - Field: ‘label’
[17:41:53.015]   - Field: ‘local’
[17:41:53.015]   - Field: ‘owner’
[17:41:53.015]   - Field: ‘envir’
[17:41:53.015]   - Field: ‘packages’
[17:41:53.015]   - Field: ‘gc’
[17:41:53.016]   - Field: ‘conditions’
[17:41:53.016]   - Field: ‘expr’
[17:41:53.016]   - Field: ‘uuid’
[17:41:53.016]   - Field: ‘seed’
[17:41:53.016]   - Field: ‘version’
[17:41:53.016]   - Field: ‘result’
[17:41:53.016]   - Field: ‘asynchronous’
[17:41:53.016]   - Field: ‘calls’
[17:41:53.016]   - Field: ‘globals’
[17:41:53.016]   - Field: ‘stdout’
[17:41:53.017]   - Field: ‘earlySignal’
[17:41:53.017]   - Field: ‘lazy’
[17:41:53.017]   - Field: ‘state’
[17:41:53.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:53.017] - Launch lazy future ...
[17:41:53.017] Packages needed by the future expression (n = 0): <none>
[17:41:53.017] Packages needed by future strategies (n = 0): <none>
[17:41:53.018] {
[17:41:53.018]     {
[17:41:53.018]         {
[17:41:53.018]             ...future.startTime <- base::Sys.time()
[17:41:53.018]             {
[17:41:53.018]                 {
[17:41:53.018]                   {
[17:41:53.018]                     base::local({
[17:41:53.018]                       has_future <- base::requireNamespace("future", 
[17:41:53.018]                         quietly = TRUE)
[17:41:53.018]                       if (has_future) {
[17:41:53.018]                         ns <- base::getNamespace("future")
[17:41:53.018]                         version <- ns[[".package"]][["version"]]
[17:41:53.018]                         if (is.null(version)) 
[17:41:53.018]                           version <- utils::packageVersion("future")
[17:41:53.018]                       }
[17:41:53.018]                       else {
[17:41:53.018]                         version <- NULL
[17:41:53.018]                       }
[17:41:53.018]                       if (!has_future || version < "1.8.0") {
[17:41:53.018]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:53.018]                           "", base::R.version$version.string), 
[17:41:53.018]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:53.018]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:53.018]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:53.018]                             "release", "version")], collapse = " "), 
[17:41:53.018]                           hostname = base::Sys.info()[["nodename"]])
[17:41:53.018]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:53.018]                           info)
[17:41:53.018]                         info <- base::paste(info, collapse = "; ")
[17:41:53.018]                         if (!has_future) {
[17:41:53.018]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:53.018]                             info)
[17:41:53.018]                         }
[17:41:53.018]                         else {
[17:41:53.018]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:53.018]                             info, version)
[17:41:53.018]                         }
[17:41:53.018]                         base::stop(msg)
[17:41:53.018]                       }
[17:41:53.018]                     })
[17:41:53.018]                   }
[17:41:53.018]                   options(future.plan = NULL)
[17:41:53.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:53.018]                 }
[17:41:53.018]                 ...future.workdir <- getwd()
[17:41:53.018]             }
[17:41:53.018]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:53.018]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:53.018]         }
[17:41:53.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:53.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:53.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:53.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:53.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:53.018]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:53.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:53.018]             base::names(...future.oldOptions))
[17:41:53.018]     }
[17:41:53.018]     if (FALSE) {
[17:41:53.018]     }
[17:41:53.018]     else {
[17:41:53.018]         if (TRUE) {
[17:41:53.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:53.018]                 open = "w")
[17:41:53.018]         }
[17:41:53.018]         else {
[17:41:53.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:53.018]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:53.018]         }
[17:41:53.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:53.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:53.018]             base::sink(type = "output", split = FALSE)
[17:41:53.018]             base::close(...future.stdout)
[17:41:53.018]         }, add = TRUE)
[17:41:53.018]     }
[17:41:53.018]     ...future.frame <- base::sys.nframe()
[17:41:53.018]     ...future.conditions <- base::list()
[17:41:53.018]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:53.018]     if (FALSE) {
[17:41:53.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:53.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:53.018]     }
[17:41:53.018]     ...future.result <- base::tryCatch({
[17:41:53.018]         base::withCallingHandlers({
[17:41:53.018]             ...future.value <- base::withVisible(base::local({
[17:41:53.018]                 do.call(function(...) {
[17:41:53.018]                   fcn <- function() sum(...)
[17:41:53.018]                   fcn()
[17:41:53.018]                 }, args = future.call.arguments)
[17:41:53.018]             }))
[17:41:53.018]             future::FutureResult(value = ...future.value$value, 
[17:41:53.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.018]                   ...future.rng), globalenv = if (FALSE) 
[17:41:53.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:53.018]                     ...future.globalenv.names))
[17:41:53.018]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:53.018]         }, condition = base::local({
[17:41:53.018]             c <- base::c
[17:41:53.018]             inherits <- base::inherits
[17:41:53.018]             invokeRestart <- base::invokeRestart
[17:41:53.018]             length <- base::length
[17:41:53.018]             list <- base::list
[17:41:53.018]             seq.int <- base::seq.int
[17:41:53.018]             signalCondition <- base::signalCondition
[17:41:53.018]             sys.calls <- base::sys.calls
[17:41:53.018]             `[[` <- base::`[[`
[17:41:53.018]             `+` <- base::`+`
[17:41:53.018]             `<<-` <- base::`<<-`
[17:41:53.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:53.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:53.018]                   3L)]
[17:41:53.018]             }
[17:41:53.018]             function(cond) {
[17:41:53.018]                 is_error <- inherits(cond, "error")
[17:41:53.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:53.018]                   NULL)
[17:41:53.018]                 if (is_error) {
[17:41:53.018]                   sessionInformation <- function() {
[17:41:53.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:53.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:53.018]                       search = base::search(), system = base::Sys.info())
[17:41:53.018]                   }
[17:41:53.018]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:53.018]                     cond$call), session = sessionInformation(), 
[17:41:53.018]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:53.018]                   signalCondition(cond)
[17:41:53.018]                 }
[17:41:53.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:53.018]                 "immediateCondition"))) {
[17:41:53.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:53.018]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:53.018]                   if (TRUE && !signal) {
[17:41:53.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.018]                     {
[17:41:53.018]                       inherits <- base::inherits
[17:41:53.018]                       invokeRestart <- base::invokeRestart
[17:41:53.018]                       is.null <- base::is.null
[17:41:53.018]                       muffled <- FALSE
[17:41:53.018]                       if (inherits(cond, "message")) {
[17:41:53.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.018]                         if (muffled) 
[17:41:53.018]                           invokeRestart("muffleMessage")
[17:41:53.018]                       }
[17:41:53.018]                       else if (inherits(cond, "warning")) {
[17:41:53.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.018]                         if (muffled) 
[17:41:53.018]                           invokeRestart("muffleWarning")
[17:41:53.018]                       }
[17:41:53.018]                       else if (inherits(cond, "condition")) {
[17:41:53.018]                         if (!is.null(pattern)) {
[17:41:53.018]                           computeRestarts <- base::computeRestarts
[17:41:53.018]                           grepl <- base::grepl
[17:41:53.018]                           restarts <- computeRestarts(cond)
[17:41:53.018]                           for (restart in restarts) {
[17:41:53.018]                             name <- restart$name
[17:41:53.018]                             if (is.null(name)) 
[17:41:53.018]                               next
[17:41:53.018]                             if (!grepl(pattern, name)) 
[17:41:53.018]                               next
[17:41:53.018]                             invokeRestart(restart)
[17:41:53.018]                             muffled <- TRUE
[17:41:53.018]                             break
[17:41:53.018]                           }
[17:41:53.018]                         }
[17:41:53.018]                       }
[17:41:53.018]                       invisible(muffled)
[17:41:53.018]                     }
[17:41:53.018]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.018]                   }
[17:41:53.018]                 }
[17:41:53.018]                 else {
[17:41:53.018]                   if (TRUE) {
[17:41:53.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.018]                     {
[17:41:53.018]                       inherits <- base::inherits
[17:41:53.018]                       invokeRestart <- base::invokeRestart
[17:41:53.018]                       is.null <- base::is.null
[17:41:53.018]                       muffled <- FALSE
[17:41:53.018]                       if (inherits(cond, "message")) {
[17:41:53.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.018]                         if (muffled) 
[17:41:53.018]                           invokeRestart("muffleMessage")
[17:41:53.018]                       }
[17:41:53.018]                       else if (inherits(cond, "warning")) {
[17:41:53.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.018]                         if (muffled) 
[17:41:53.018]                           invokeRestart("muffleWarning")
[17:41:53.018]                       }
[17:41:53.018]                       else if (inherits(cond, "condition")) {
[17:41:53.018]                         if (!is.null(pattern)) {
[17:41:53.018]                           computeRestarts <- base::computeRestarts
[17:41:53.018]                           grepl <- base::grepl
[17:41:53.018]                           restarts <- computeRestarts(cond)
[17:41:53.018]                           for (restart in restarts) {
[17:41:53.018]                             name <- restart$name
[17:41:53.018]                             if (is.null(name)) 
[17:41:53.018]                               next
[17:41:53.018]                             if (!grepl(pattern, name)) 
[17:41:53.018]                               next
[17:41:53.018]                             invokeRestart(restart)
[17:41:53.018]                             muffled <- TRUE
[17:41:53.018]                             break
[17:41:53.018]                           }
[17:41:53.018]                         }
[17:41:53.018]                       }
[17:41:53.018]                       invisible(muffled)
[17:41:53.018]                     }
[17:41:53.018]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.018]                   }
[17:41:53.018]                 }
[17:41:53.018]             }
[17:41:53.018]         }))
[17:41:53.018]     }, error = function(ex) {
[17:41:53.018]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:53.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.018]                 ...future.rng), started = ...future.startTime, 
[17:41:53.018]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:53.018]             version = "1.8"), class = "FutureResult")
[17:41:53.018]     }, finally = {
[17:41:53.018]         if (!identical(...future.workdir, getwd())) 
[17:41:53.018]             setwd(...future.workdir)
[17:41:53.018]         {
[17:41:53.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:53.018]                 ...future.oldOptions$nwarnings <- NULL
[17:41:53.018]             }
[17:41:53.018]             base::options(...future.oldOptions)
[17:41:53.018]             if (.Platform$OS.type == "windows") {
[17:41:53.018]                 old_names <- names(...future.oldEnvVars)
[17:41:53.018]                 envs <- base::Sys.getenv()
[17:41:53.018]                 names <- names(envs)
[17:41:53.018]                 common <- intersect(names, old_names)
[17:41:53.018]                 added <- setdiff(names, old_names)
[17:41:53.018]                 removed <- setdiff(old_names, names)
[17:41:53.018]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:53.018]                   envs[common]]
[17:41:53.018]                 NAMES <- toupper(changed)
[17:41:53.018]                 args <- list()
[17:41:53.018]                 for (kk in seq_along(NAMES)) {
[17:41:53.018]                   name <- changed[[kk]]
[17:41:53.018]                   NAME <- NAMES[[kk]]
[17:41:53.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.018]                     next
[17:41:53.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.018]                 }
[17:41:53.018]                 NAMES <- toupper(added)
[17:41:53.018]                 for (kk in seq_along(NAMES)) {
[17:41:53.018]                   name <- added[[kk]]
[17:41:53.018]                   NAME <- NAMES[[kk]]
[17:41:53.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.018]                     next
[17:41:53.018]                   args[[name]] <- ""
[17:41:53.018]                 }
[17:41:53.018]                 NAMES <- toupper(removed)
[17:41:53.018]                 for (kk in seq_along(NAMES)) {
[17:41:53.018]                   name <- removed[[kk]]
[17:41:53.018]                   NAME <- NAMES[[kk]]
[17:41:53.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.018]                     next
[17:41:53.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.018]                 }
[17:41:53.018]                 if (length(args) > 0) 
[17:41:53.018]                   base::do.call(base::Sys.setenv, args = args)
[17:41:53.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:53.018]             }
[17:41:53.018]             else {
[17:41:53.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:53.018]             }
[17:41:53.018]             {
[17:41:53.018]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:53.018]                   0L) {
[17:41:53.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:53.018]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:53.018]                   base::options(opts)
[17:41:53.018]                 }
[17:41:53.018]                 {
[17:41:53.018]                   {
[17:41:53.018]                     NULL
[17:41:53.018]                     RNGkind("Mersenne-Twister")
[17:41:53.018]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:53.018]                       inherits = FALSE)
[17:41:53.018]                   }
[17:41:53.018]                   options(future.plan = NULL)
[17:41:53.018]                   if (is.na(NA_character_)) 
[17:41:53.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:53.018]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:53.018]                   {
[17:41:53.018]                     future <- SequentialFuture(..., envir = envir)
[17:41:53.018]                     if (!future$lazy) 
[17:41:53.018]                       future <- run(future)
[17:41:53.018]                     invisible(future)
[17:41:53.018]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:53.018]                 }
[17:41:53.018]             }
[17:41:53.018]         }
[17:41:53.018]     })
[17:41:53.018]     if (TRUE) {
[17:41:53.018]         base::sink(type = "output", split = FALSE)
[17:41:53.018]         if (TRUE) {
[17:41:53.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:53.018]         }
[17:41:53.018]         else {
[17:41:53.018]             ...future.result["stdout"] <- base::list(NULL)
[17:41:53.018]         }
[17:41:53.018]         base::close(...future.stdout)
[17:41:53.018]         ...future.stdout <- NULL
[17:41:53.018]     }
[17:41:53.018]     ...future.result$conditions <- ...future.conditions
[17:41:53.018]     ...future.result$finished <- base::Sys.time()
[17:41:53.018]     ...future.result
[17:41:53.018] }
[17:41:53.019] assign_globals() ...
[17:41:53.019] List of 1
[17:41:53.019]  $ future.call.arguments:List of 2
[17:41:53.019]   ..$ : int [1:2] 1 2
[17:41:53.019]   ..$ : num 3
[17:41:53.019]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:53.019]  - attr(*, "where")=List of 1
[17:41:53.019]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:41:53.019]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:53.019]  - attr(*, "resolved")= logi FALSE
[17:41:53.019]  - attr(*, "total_size")= num 112
[17:41:53.019]  - attr(*, "already-done")= logi TRUE
[17:41:53.023] - copied ‘future.call.arguments’ to environment
[17:41:53.023] assign_globals() ... done
[17:41:53.023] plan(): Setting new future strategy stack:
[17:41:53.023] List of future strategies:
[17:41:53.023] 1. sequential:
[17:41:53.023]    - args: function (..., envir = parent.frame())
[17:41:53.023]    - tweaked: FALSE
[17:41:53.023]    - call: NULL
[17:41:53.024] plan(): nbrOfWorkers() = 1
[17:41:53.024] plan(): Setting new future strategy stack:
[17:41:53.025] List of future strategies:
[17:41:53.025] 1. sequential:
[17:41:53.025]    - args: function (..., envir = parent.frame())
[17:41:53.025]    - tweaked: FALSE
[17:41:53.025]    - call: plan(strategy, substitute = FALSE)
[17:41:53.027] plan(): nbrOfWorkers() = 1
[17:41:53.027] SequentialFuture started (and completed)
[17:41:53.027] - Launch lazy future ... done
[17:41:53.027] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'F' with plan('sequential') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x55bfdb0ae0f8>
Using '...' in a formula
[17:41:53.028] getGlobalsAndPackages() ...
[17:41:53.028] Searching for globals...
[17:41:53.031] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[17:41:53.031] Searching for globals ... DONE
[17:41:53.031] Resolving globals: FALSE
[17:41:53.031] Tweak future expression to call with '...' arguments ...
[17:41:53.032] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[17:41:53.032] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:41:53.032] - globals: [3] ‘fcn’, ‘x’, ‘y’
[17:41:53.032] 
[17:41:53.033] getGlobalsAndPackages() ... DONE
[17:41:53.033] run() for ‘Future’ ...
[17:41:53.033] - state: ‘created’
[17:41:53.033] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:53.033] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:53.033] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:53.034]   - Field: ‘label’
[17:41:53.034]   - Field: ‘local’
[17:41:53.034]   - Field: ‘owner’
[17:41:53.034]   - Field: ‘envir’
[17:41:53.034]   - Field: ‘packages’
[17:41:53.034]   - Field: ‘gc’
[17:41:53.034]   - Field: ‘conditions’
[17:41:53.034]   - Field: ‘expr’
[17:41:53.034]   - Field: ‘uuid’
[17:41:53.034]   - Field: ‘seed’
[17:41:53.035]   - Field: ‘version’
[17:41:53.035]   - Field: ‘result’
[17:41:53.035]   - Field: ‘asynchronous’
[17:41:53.035]   - Field: ‘calls’
[17:41:53.035]   - Field: ‘globals’
[17:41:53.035]   - Field: ‘stdout’
[17:41:53.035]   - Field: ‘earlySignal’
[17:41:53.035]   - Field: ‘lazy’
[17:41:53.035]   - Field: ‘state’
[17:41:53.035] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:53.036] - Launch lazy future ...
[17:41:53.036] Packages needed by the future expression (n = 0): <none>
[17:41:53.036] Packages needed by future strategies (n = 0): <none>
[17:41:53.036] {
[17:41:53.036]     {
[17:41:53.036]         {
[17:41:53.036]             ...future.startTime <- base::Sys.time()
[17:41:53.036]             {
[17:41:53.036]                 {
[17:41:53.036]                   {
[17:41:53.036]                     base::local({
[17:41:53.036]                       has_future <- base::requireNamespace("future", 
[17:41:53.036]                         quietly = TRUE)
[17:41:53.036]                       if (has_future) {
[17:41:53.036]                         ns <- base::getNamespace("future")
[17:41:53.036]                         version <- ns[[".package"]][["version"]]
[17:41:53.036]                         if (is.null(version)) 
[17:41:53.036]                           version <- utils::packageVersion("future")
[17:41:53.036]                       }
[17:41:53.036]                       else {
[17:41:53.036]                         version <- NULL
[17:41:53.036]                       }
[17:41:53.036]                       if (!has_future || version < "1.8.0") {
[17:41:53.036]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:53.036]                           "", base::R.version$version.string), 
[17:41:53.036]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:53.036]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:53.036]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:53.036]                             "release", "version")], collapse = " "), 
[17:41:53.036]                           hostname = base::Sys.info()[["nodename"]])
[17:41:53.036]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:53.036]                           info)
[17:41:53.036]                         info <- base::paste(info, collapse = "; ")
[17:41:53.036]                         if (!has_future) {
[17:41:53.036]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:53.036]                             info)
[17:41:53.036]                         }
[17:41:53.036]                         else {
[17:41:53.036]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:53.036]                             info, version)
[17:41:53.036]                         }
[17:41:53.036]                         base::stop(msg)
[17:41:53.036]                       }
[17:41:53.036]                     })
[17:41:53.036]                   }
[17:41:53.036]                   options(future.plan = NULL)
[17:41:53.036]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.036]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:53.036]                 }
[17:41:53.036]                 ...future.workdir <- getwd()
[17:41:53.036]             }
[17:41:53.036]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:53.036]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:53.036]         }
[17:41:53.036]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:53.036]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:53.036]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:53.036]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:53.036]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:53.036]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:53.036]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:53.036]             base::names(...future.oldOptions))
[17:41:53.036]     }
[17:41:53.036]     if (FALSE) {
[17:41:53.036]     }
[17:41:53.036]     else {
[17:41:53.036]         if (TRUE) {
[17:41:53.036]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:53.036]                 open = "w")
[17:41:53.036]         }
[17:41:53.036]         else {
[17:41:53.036]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:53.036]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:53.036]         }
[17:41:53.036]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:53.036]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:53.036]             base::sink(type = "output", split = FALSE)
[17:41:53.036]             base::close(...future.stdout)
[17:41:53.036]         }, add = TRUE)
[17:41:53.036]     }
[17:41:53.036]     ...future.frame <- base::sys.nframe()
[17:41:53.036]     ...future.conditions <- base::list()
[17:41:53.036]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:53.036]     if (FALSE) {
[17:41:53.036]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:53.036]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:53.036]     }
[17:41:53.036]     ...future.result <- base::tryCatch({
[17:41:53.036]         base::withCallingHandlers({
[17:41:53.036]             ...future.value <- base::withVisible(base::local(fcn(x, 
[17:41:53.036]                 y)))
[17:41:53.036]             future::FutureResult(value = ...future.value$value, 
[17:41:53.036]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.036]                   ...future.rng), globalenv = if (FALSE) 
[17:41:53.036]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:53.036]                     ...future.globalenv.names))
[17:41:53.036]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:53.036]         }, condition = base::local({
[17:41:53.036]             c <- base::c
[17:41:53.036]             inherits <- base::inherits
[17:41:53.036]             invokeRestart <- base::invokeRestart
[17:41:53.036]             length <- base::length
[17:41:53.036]             list <- base::list
[17:41:53.036]             seq.int <- base::seq.int
[17:41:53.036]             signalCondition <- base::signalCondition
[17:41:53.036]             sys.calls <- base::sys.calls
[17:41:53.036]             `[[` <- base::`[[`
[17:41:53.036]             `+` <- base::`+`
[17:41:53.036]             `<<-` <- base::`<<-`
[17:41:53.036]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:53.036]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:53.036]                   3L)]
[17:41:53.036]             }
[17:41:53.036]             function(cond) {
[17:41:53.036]                 is_error <- inherits(cond, "error")
[17:41:53.036]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:53.036]                   NULL)
[17:41:53.036]                 if (is_error) {
[17:41:53.036]                   sessionInformation <- function() {
[17:41:53.036]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:53.036]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:53.036]                       search = base::search(), system = base::Sys.info())
[17:41:53.036]                   }
[17:41:53.036]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.036]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:53.036]                     cond$call), session = sessionInformation(), 
[17:41:53.036]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:53.036]                   signalCondition(cond)
[17:41:53.036]                 }
[17:41:53.036]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:53.036]                 "immediateCondition"))) {
[17:41:53.036]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:53.036]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.036]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:53.036]                   if (TRUE && !signal) {
[17:41:53.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.036]                     {
[17:41:53.036]                       inherits <- base::inherits
[17:41:53.036]                       invokeRestart <- base::invokeRestart
[17:41:53.036]                       is.null <- base::is.null
[17:41:53.036]                       muffled <- FALSE
[17:41:53.036]                       if (inherits(cond, "message")) {
[17:41:53.036]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.036]                         if (muffled) 
[17:41:53.036]                           invokeRestart("muffleMessage")
[17:41:53.036]                       }
[17:41:53.036]                       else if (inherits(cond, "warning")) {
[17:41:53.036]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.036]                         if (muffled) 
[17:41:53.036]                           invokeRestart("muffleWarning")
[17:41:53.036]                       }
[17:41:53.036]                       else if (inherits(cond, "condition")) {
[17:41:53.036]                         if (!is.null(pattern)) {
[17:41:53.036]                           computeRestarts <- base::computeRestarts
[17:41:53.036]                           grepl <- base::grepl
[17:41:53.036]                           restarts <- computeRestarts(cond)
[17:41:53.036]                           for (restart in restarts) {
[17:41:53.036]                             name <- restart$name
[17:41:53.036]                             if (is.null(name)) 
[17:41:53.036]                               next
[17:41:53.036]                             if (!grepl(pattern, name)) 
[17:41:53.036]                               next
[17:41:53.036]                             invokeRestart(restart)
[17:41:53.036]                             muffled <- TRUE
[17:41:53.036]                             break
[17:41:53.036]                           }
[17:41:53.036]                         }
[17:41:53.036]                       }
[17:41:53.036]                       invisible(muffled)
[17:41:53.036]                     }
[17:41:53.036]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.036]                   }
[17:41:53.036]                 }
[17:41:53.036]                 else {
[17:41:53.036]                   if (TRUE) {
[17:41:53.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.036]                     {
[17:41:53.036]                       inherits <- base::inherits
[17:41:53.036]                       invokeRestart <- base::invokeRestart
[17:41:53.036]                       is.null <- base::is.null
[17:41:53.036]                       muffled <- FALSE
[17:41:53.036]                       if (inherits(cond, "message")) {
[17:41:53.036]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.036]                         if (muffled) 
[17:41:53.036]                           invokeRestart("muffleMessage")
[17:41:53.036]                       }
[17:41:53.036]                       else if (inherits(cond, "warning")) {
[17:41:53.036]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.036]                         if (muffled) 
[17:41:53.036]                           invokeRestart("muffleWarning")
[17:41:53.036]                       }
[17:41:53.036]                       else if (inherits(cond, "condition")) {
[17:41:53.036]                         if (!is.null(pattern)) {
[17:41:53.036]                           computeRestarts <- base::computeRestarts
[17:41:53.036]                           grepl <- base::grepl
[17:41:53.036]                           restarts <- computeRestarts(cond)
[17:41:53.036]                           for (restart in restarts) {
[17:41:53.036]                             name <- restart$name
[17:41:53.036]                             if (is.null(name)) 
[17:41:53.036]                               next
[17:41:53.036]                             if (!grepl(pattern, name)) 
[17:41:53.036]                               next
[17:41:53.036]                             invokeRestart(restart)
[17:41:53.036]                             muffled <- TRUE
[17:41:53.036]                             break
[17:41:53.036]                           }
[17:41:53.036]                         }
[17:41:53.036]                       }
[17:41:53.036]                       invisible(muffled)
[17:41:53.036]                     }
[17:41:53.036]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.036]                   }
[17:41:53.036]                 }
[17:41:53.036]             }
[17:41:53.036]         }))
[17:41:53.036]     }, error = function(ex) {
[17:41:53.036]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:53.036]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.036]                 ...future.rng), started = ...future.startTime, 
[17:41:53.036]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:53.036]             version = "1.8"), class = "FutureResult")
[17:41:53.036]     }, finally = {
[17:41:53.036]         if (!identical(...future.workdir, getwd())) 
[17:41:53.036]             setwd(...future.workdir)
[17:41:53.036]         {
[17:41:53.036]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:53.036]                 ...future.oldOptions$nwarnings <- NULL
[17:41:53.036]             }
[17:41:53.036]             base::options(...future.oldOptions)
[17:41:53.036]             if (.Platform$OS.type == "windows") {
[17:41:53.036]                 old_names <- names(...future.oldEnvVars)
[17:41:53.036]                 envs <- base::Sys.getenv()
[17:41:53.036]                 names <- names(envs)
[17:41:53.036]                 common <- intersect(names, old_names)
[17:41:53.036]                 added <- setdiff(names, old_names)
[17:41:53.036]                 removed <- setdiff(old_names, names)
[17:41:53.036]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:53.036]                   envs[common]]
[17:41:53.036]                 NAMES <- toupper(changed)
[17:41:53.036]                 args <- list()
[17:41:53.036]                 for (kk in seq_along(NAMES)) {
[17:41:53.036]                   name <- changed[[kk]]
[17:41:53.036]                   NAME <- NAMES[[kk]]
[17:41:53.036]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.036]                     next
[17:41:53.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.036]                 }
[17:41:53.036]                 NAMES <- toupper(added)
[17:41:53.036]                 for (kk in seq_along(NAMES)) {
[17:41:53.036]                   name <- added[[kk]]
[17:41:53.036]                   NAME <- NAMES[[kk]]
[17:41:53.036]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.036]                     next
[17:41:53.036]                   args[[name]] <- ""
[17:41:53.036]                 }
[17:41:53.036]                 NAMES <- toupper(removed)
[17:41:53.036]                 for (kk in seq_along(NAMES)) {
[17:41:53.036]                   name <- removed[[kk]]
[17:41:53.036]                   NAME <- NAMES[[kk]]
[17:41:53.036]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.036]                     next
[17:41:53.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.036]                 }
[17:41:53.036]                 if (length(args) > 0) 
[17:41:53.036]                   base::do.call(base::Sys.setenv, args = args)
[17:41:53.036]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:53.036]             }
[17:41:53.036]             else {
[17:41:53.036]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:53.036]             }
[17:41:53.036]             {
[17:41:53.036]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:53.036]                   0L) {
[17:41:53.036]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:53.036]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:53.036]                   base::options(opts)
[17:41:53.036]                 }
[17:41:53.036]                 {
[17:41:53.036]                   {
[17:41:53.036]                     NULL
[17:41:53.036]                     RNGkind("Mersenne-Twister")
[17:41:53.036]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:53.036]                       inherits = FALSE)
[17:41:53.036]                   }
[17:41:53.036]                   options(future.plan = NULL)
[17:41:53.036]                   if (is.na(NA_character_)) 
[17:41:53.036]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.036]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:53.036]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:53.036]                   {
[17:41:53.036]                     future <- SequentialFuture(..., envir = envir)
[17:41:53.036]                     if (!future$lazy) 
[17:41:53.036]                       future <- run(future)
[17:41:53.036]                     invisible(future)
[17:41:53.036]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:53.036]                 }
[17:41:53.036]             }
[17:41:53.036]         }
[17:41:53.036]     })
[17:41:53.036]     if (TRUE) {
[17:41:53.036]         base::sink(type = "output", split = FALSE)
[17:41:53.036]         if (TRUE) {
[17:41:53.036]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:53.036]         }
[17:41:53.036]         else {
[17:41:53.036]             ...future.result["stdout"] <- base::list(NULL)
[17:41:53.036]         }
[17:41:53.036]         base::close(...future.stdout)
[17:41:53.036]         ...future.stdout <- NULL
[17:41:53.036]     }
[17:41:53.036]     ...future.result$conditions <- ...future.conditions
[17:41:53.036]     ...future.result$finished <- base::Sys.time()
[17:41:53.036]     ...future.result
[17:41:53.036] }
[17:41:53.038] assign_globals() ...
[17:41:53.038] List of 3
[17:41:53.038]  $ fcn:function (x, y)  
[17:41:53.038]  $ x  : int [1:2] 1 2
[17:41:53.038]  $ y  : num 3
[17:41:53.038]  - attr(*, "where")=List of 3
[17:41:53.038]   ..$ fcn:<environment: R_EmptyEnv> 
[17:41:53.038]   ..$ x  :<environment: R_EmptyEnv> 
[17:41:53.038]   ..$ y  :<environment: R_EmptyEnv> 
[17:41:53.038]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:53.038]  - attr(*, "resolved")= logi FALSE
[17:41:53.038]  - attr(*, "total_size")= num 4280
[17:41:53.038]  - attr(*, "already-done")= logi TRUE
[17:41:53.042] - reassign environment for ‘fcn’
[17:41:53.042] - copied ‘fcn’ to environment
[17:41:53.042] - copied ‘x’ to environment
[17:41:53.042] - copied ‘y’ to environment
[17:41:53.042] assign_globals() ... done
[17:41:53.043] plan(): Setting new future strategy stack:
[17:41:53.043] List of future strategies:
[17:41:53.043] 1. sequential:
[17:41:53.043]    - args: function (..., envir = parent.frame())
[17:41:53.043]    - tweaked: FALSE
[17:41:53.043]    - call: NULL
[17:41:53.043] plan(): nbrOfWorkers() = 1
[17:41:53.044] plan(): Setting new future strategy stack:
[17:41:53.044] List of future strategies:
[17:41:53.044] 1. sequential:
[17:41:53.044]    - args: function (..., envir = parent.frame())
[17:41:53.044]    - tweaked: FALSE
[17:41:53.044]    - call: plan(strategy, substitute = FALSE)
[17:41:53.044] plan(): nbrOfWorkers() = 1
[17:41:53.045] SequentialFuture started (and completed)
[17:41:53.045] - Launch lazy future ... done
[17:41:53.045] run() for ‘SequentialFuture’ ... done
[1] 6
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** Global argument '...' ...
- plan('multicore') ...
[17:41:53.051] plan(): Setting new future strategy stack:
[17:41:53.051] List of future strategies:
[17:41:53.051] 1. multicore:
[17:41:53.051]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:53.051]    - tweaked: FALSE
[17:41:53.051]    - call: plan(strategy, substitute = FALSE)
[17:41:53.057] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multicore') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x55bfdb63bea8>
Arguments '...' exists: TRUE
[17:41:53.057] getGlobalsAndPackages() ...
[17:41:53.057] Searching for globals...
[17:41:53.059] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:41:53.059] Searching for globals ... DONE
[17:41:53.059] Resolving globals: FALSE
[17:41:53.059] Tweak future expression to call with '...' arguments ...
[17:41:53.059] {
[17:41:53.059]     do.call(function(...) {
[17:41:53.059]         sum(x, ...)
[17:41:53.059]     }, args = future.call.arguments)
[17:41:53.059] }
[17:41:53.059] Tweak future expression to call with '...' arguments ... DONE
[17:41:53.060] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:53.060] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:41:53.060] - globals: [2] ‘x’, ‘future.call.arguments’
[17:41:53.061] 
[17:41:53.061] getGlobalsAndPackages() ... DONE
[17:41:53.061] run() for ‘Future’ ...
[17:41:53.061] - state: ‘created’
[17:41:53.061] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:53.065] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:53.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:53.065]   - Field: ‘label’
[17:41:53.065]   - Field: ‘local’
[17:41:53.065]   - Field: ‘owner’
[17:41:53.066]   - Field: ‘envir’
[17:41:53.066]   - Field: ‘workers’
[17:41:53.066]   - Field: ‘packages’
[17:41:53.066]   - Field: ‘gc’
[17:41:53.066]   - Field: ‘job’
[17:41:53.066]   - Field: ‘conditions’
[17:41:53.066]   - Field: ‘expr’
[17:41:53.066]   - Field: ‘uuid’
[17:41:53.066]   - Field: ‘seed’
[17:41:53.066]   - Field: ‘version’
[17:41:53.067]   - Field: ‘result’
[17:41:53.067]   - Field: ‘asynchronous’
[17:41:53.067]   - Field: ‘calls’
[17:41:53.067]   - Field: ‘globals’
[17:41:53.067]   - Field: ‘stdout’
[17:41:53.067]   - Field: ‘earlySignal’
[17:41:53.067]   - Field: ‘lazy’
[17:41:53.067]   - Field: ‘state’
[17:41:53.067] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:53.067] - Launch lazy future ...
[17:41:53.069] Packages needed by the future expression (n = 0): <none>
[17:41:53.069] Packages needed by future strategies (n = 0): <none>
[17:41:53.069] {
[17:41:53.069]     {
[17:41:53.069]         {
[17:41:53.069]             ...future.startTime <- base::Sys.time()
[17:41:53.069]             {
[17:41:53.069]                 {
[17:41:53.069]                   {
[17:41:53.069]                     {
[17:41:53.069]                       base::local({
[17:41:53.069]                         has_future <- base::requireNamespace("future", 
[17:41:53.069]                           quietly = TRUE)
[17:41:53.069]                         if (has_future) {
[17:41:53.069]                           ns <- base::getNamespace("future")
[17:41:53.069]                           version <- ns[[".package"]][["version"]]
[17:41:53.069]                           if (is.null(version)) 
[17:41:53.069]                             version <- utils::packageVersion("future")
[17:41:53.069]                         }
[17:41:53.069]                         else {
[17:41:53.069]                           version <- NULL
[17:41:53.069]                         }
[17:41:53.069]                         if (!has_future || version < "1.8.0") {
[17:41:53.069]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:53.069]                             "", base::R.version$version.string), 
[17:41:53.069]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:53.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:53.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:53.069]                               "release", "version")], collapse = " "), 
[17:41:53.069]                             hostname = base::Sys.info()[["nodename"]])
[17:41:53.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:53.069]                             info)
[17:41:53.069]                           info <- base::paste(info, collapse = "; ")
[17:41:53.069]                           if (!has_future) {
[17:41:53.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:53.069]                               info)
[17:41:53.069]                           }
[17:41:53.069]                           else {
[17:41:53.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:53.069]                               info, version)
[17:41:53.069]                           }
[17:41:53.069]                           base::stop(msg)
[17:41:53.069]                         }
[17:41:53.069]                       })
[17:41:53.069]                     }
[17:41:53.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:53.069]                     base::options(mc.cores = 1L)
[17:41:53.069]                   }
[17:41:53.069]                   options(future.plan = NULL)
[17:41:53.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:53.069]                 }
[17:41:53.069]                 ...future.workdir <- getwd()
[17:41:53.069]             }
[17:41:53.069]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:53.069]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:53.069]         }
[17:41:53.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:53.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:53.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:53.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:53.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:53.069]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:53.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:53.069]             base::names(...future.oldOptions))
[17:41:53.069]     }
[17:41:53.069]     if (FALSE) {
[17:41:53.069]     }
[17:41:53.069]     else {
[17:41:53.069]         if (TRUE) {
[17:41:53.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:53.069]                 open = "w")
[17:41:53.069]         }
[17:41:53.069]         else {
[17:41:53.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:53.069]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:53.069]         }
[17:41:53.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:53.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:53.069]             base::sink(type = "output", split = FALSE)
[17:41:53.069]             base::close(...future.stdout)
[17:41:53.069]         }, add = TRUE)
[17:41:53.069]     }
[17:41:53.069]     ...future.frame <- base::sys.nframe()
[17:41:53.069]     ...future.conditions <- base::list()
[17:41:53.069]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:53.069]     if (FALSE) {
[17:41:53.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:53.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:53.069]     }
[17:41:53.069]     ...future.result <- base::tryCatch({
[17:41:53.069]         base::withCallingHandlers({
[17:41:53.069]             ...future.value <- base::withVisible(base::local({
[17:41:53.069]                 withCallingHandlers({
[17:41:53.069]                   {
[17:41:53.069]                     do.call(function(...) {
[17:41:53.069]                       sum(x, ...)
[17:41:53.069]                     }, args = future.call.arguments)
[17:41:53.069]                   }
[17:41:53.069]                 }, immediateCondition = function(cond) {
[17:41:53.069]                   save_rds <- function (object, pathname, ...) 
[17:41:53.069]                   {
[17:41:53.069]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:53.069]                     if (file_test("-f", pathname_tmp)) {
[17:41:53.069]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.069]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:53.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.069]                         fi_tmp[["mtime"]])
[17:41:53.069]                     }
[17:41:53.069]                     tryCatch({
[17:41:53.069]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:53.069]                     }, error = function(ex) {
[17:41:53.069]                       msg <- conditionMessage(ex)
[17:41:53.069]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.069]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:53.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.069]                         fi_tmp[["mtime"]], msg)
[17:41:53.069]                       ex$message <- msg
[17:41:53.069]                       stop(ex)
[17:41:53.069]                     })
[17:41:53.069]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:53.069]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:53.069]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:53.069]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.069]                       fi <- file.info(pathname)
[17:41:53.069]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:53.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.069]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:53.069]                         fi[["size"]], fi[["mtime"]])
[17:41:53.069]                       stop(msg)
[17:41:53.069]                     }
[17:41:53.069]                     invisible(pathname)
[17:41:53.069]                   }
[17:41:53.069]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:53.069]                     rootPath = tempdir()) 
[17:41:53.069]                   {
[17:41:53.069]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:53.069]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:53.069]                       tmpdir = path, fileext = ".rds")
[17:41:53.069]                     save_rds(obj, file)
[17:41:53.069]                   }
[17:41:53.069]                   saveImmediateCondition(cond, path = "/tmp/RtmpDeYcUG/.future/immediateConditions")
[17:41:53.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.069]                   {
[17:41:53.069]                     inherits <- base::inherits
[17:41:53.069]                     invokeRestart <- base::invokeRestart
[17:41:53.069]                     is.null <- base::is.null
[17:41:53.069]                     muffled <- FALSE
[17:41:53.069]                     if (inherits(cond, "message")) {
[17:41:53.069]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:53.069]                       if (muffled) 
[17:41:53.069]                         invokeRestart("muffleMessage")
[17:41:53.069]                     }
[17:41:53.069]                     else if (inherits(cond, "warning")) {
[17:41:53.069]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:53.069]                       if (muffled) 
[17:41:53.069]                         invokeRestart("muffleWarning")
[17:41:53.069]                     }
[17:41:53.069]                     else if (inherits(cond, "condition")) {
[17:41:53.069]                       if (!is.null(pattern)) {
[17:41:53.069]                         computeRestarts <- base::computeRestarts
[17:41:53.069]                         grepl <- base::grepl
[17:41:53.069]                         restarts <- computeRestarts(cond)
[17:41:53.069]                         for (restart in restarts) {
[17:41:53.069]                           name <- restart$name
[17:41:53.069]                           if (is.null(name)) 
[17:41:53.069]                             next
[17:41:53.069]                           if (!grepl(pattern, name)) 
[17:41:53.069]                             next
[17:41:53.069]                           invokeRestart(restart)
[17:41:53.069]                           muffled <- TRUE
[17:41:53.069]                           break
[17:41:53.069]                         }
[17:41:53.069]                       }
[17:41:53.069]                     }
[17:41:53.069]                     invisible(muffled)
[17:41:53.069]                   }
[17:41:53.069]                   muffleCondition(cond)
[17:41:53.069]                 })
[17:41:53.069]             }))
[17:41:53.069]             future::FutureResult(value = ...future.value$value, 
[17:41:53.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.069]                   ...future.rng), globalenv = if (FALSE) 
[17:41:53.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:53.069]                     ...future.globalenv.names))
[17:41:53.069]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:53.069]         }, condition = base::local({
[17:41:53.069]             c <- base::c
[17:41:53.069]             inherits <- base::inherits
[17:41:53.069]             invokeRestart <- base::invokeRestart
[17:41:53.069]             length <- base::length
[17:41:53.069]             list <- base::list
[17:41:53.069]             seq.int <- base::seq.int
[17:41:53.069]             signalCondition <- base::signalCondition
[17:41:53.069]             sys.calls <- base::sys.calls
[17:41:53.069]             `[[` <- base::`[[`
[17:41:53.069]             `+` <- base::`+`
[17:41:53.069]             `<<-` <- base::`<<-`
[17:41:53.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:53.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:53.069]                   3L)]
[17:41:53.069]             }
[17:41:53.069]             function(cond) {
[17:41:53.069]                 is_error <- inherits(cond, "error")
[17:41:53.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:53.069]                   NULL)
[17:41:53.069]                 if (is_error) {
[17:41:53.069]                   sessionInformation <- function() {
[17:41:53.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:53.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:53.069]                       search = base::search(), system = base::Sys.info())
[17:41:53.069]                   }
[17:41:53.069]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:53.069]                     cond$call), session = sessionInformation(), 
[17:41:53.069]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:53.069]                   signalCondition(cond)
[17:41:53.069]                 }
[17:41:53.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:53.069]                 "immediateCondition"))) {
[17:41:53.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:53.069]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:53.069]                   if (TRUE && !signal) {
[17:41:53.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.069]                     {
[17:41:53.069]                       inherits <- base::inherits
[17:41:53.069]                       invokeRestart <- base::invokeRestart
[17:41:53.069]                       is.null <- base::is.null
[17:41:53.069]                       muffled <- FALSE
[17:41:53.069]                       if (inherits(cond, "message")) {
[17:41:53.069]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.069]                         if (muffled) 
[17:41:53.069]                           invokeRestart("muffleMessage")
[17:41:53.069]                       }
[17:41:53.069]                       else if (inherits(cond, "warning")) {
[17:41:53.069]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.069]                         if (muffled) 
[17:41:53.069]                           invokeRestart("muffleWarning")
[17:41:53.069]                       }
[17:41:53.069]                       else if (inherits(cond, "condition")) {
[17:41:53.069]                         if (!is.null(pattern)) {
[17:41:53.069]                           computeRestarts <- base::computeRestarts
[17:41:53.069]                           grepl <- base::grepl
[17:41:53.069]                           restarts <- computeRestarts(cond)
[17:41:53.069]                           for (restart in restarts) {
[17:41:53.069]                             name <- restart$name
[17:41:53.069]                             if (is.null(name)) 
[17:41:53.069]                               next
[17:41:53.069]                             if (!grepl(pattern, name)) 
[17:41:53.069]                               next
[17:41:53.069]                             invokeRestart(restart)
[17:41:53.069]                             muffled <- TRUE
[17:41:53.069]                             break
[17:41:53.069]                           }
[17:41:53.069]                         }
[17:41:53.069]                       }
[17:41:53.069]                       invisible(muffled)
[17:41:53.069]                     }
[17:41:53.069]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.069]                   }
[17:41:53.069]                 }
[17:41:53.069]                 else {
[17:41:53.069]                   if (TRUE) {
[17:41:53.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.069]                     {
[17:41:53.069]                       inherits <- base::inherits
[17:41:53.069]                       invokeRestart <- base::invokeRestart
[17:41:53.069]                       is.null <- base::is.null
[17:41:53.069]                       muffled <- FALSE
[17:41:53.069]                       if (inherits(cond, "message")) {
[17:41:53.069]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.069]                         if (muffled) 
[17:41:53.069]                           invokeRestart("muffleMessage")
[17:41:53.069]                       }
[17:41:53.069]                       else if (inherits(cond, "warning")) {
[17:41:53.069]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.069]                         if (muffled) 
[17:41:53.069]                           invokeRestart("muffleWarning")
[17:41:53.069]                       }
[17:41:53.069]                       else if (inherits(cond, "condition")) {
[17:41:53.069]                         if (!is.null(pattern)) {
[17:41:53.069]                           computeRestarts <- base::computeRestarts
[17:41:53.069]                           grepl <- base::grepl
[17:41:53.069]                           restarts <- computeRestarts(cond)
[17:41:53.069]                           for (restart in restarts) {
[17:41:53.069]                             name <- restart$name
[17:41:53.069]                             if (is.null(name)) 
[17:41:53.069]                               next
[17:41:53.069]                             if (!grepl(pattern, name)) 
[17:41:53.069]                               next
[17:41:53.069]                             invokeRestart(restart)
[17:41:53.069]                             muffled <- TRUE
[17:41:53.069]                             break
[17:41:53.069]                           }
[17:41:53.069]                         }
[17:41:53.069]                       }
[17:41:53.069]                       invisible(muffled)
[17:41:53.069]                     }
[17:41:53.069]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.069]                   }
[17:41:53.069]                 }
[17:41:53.069]             }
[17:41:53.069]         }))
[17:41:53.069]     }, error = function(ex) {
[17:41:53.069]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:53.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.069]                 ...future.rng), started = ...future.startTime, 
[17:41:53.069]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:53.069]             version = "1.8"), class = "FutureResult")
[17:41:53.069]     }, finally = {
[17:41:53.069]         if (!identical(...future.workdir, getwd())) 
[17:41:53.069]             setwd(...future.workdir)
[17:41:53.069]         {
[17:41:53.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:53.069]                 ...future.oldOptions$nwarnings <- NULL
[17:41:53.069]             }
[17:41:53.069]             base::options(...future.oldOptions)
[17:41:53.069]             if (.Platform$OS.type == "windows") {
[17:41:53.069]                 old_names <- names(...future.oldEnvVars)
[17:41:53.069]                 envs <- base::Sys.getenv()
[17:41:53.069]                 names <- names(envs)
[17:41:53.069]                 common <- intersect(names, old_names)
[17:41:53.069]                 added <- setdiff(names, old_names)
[17:41:53.069]                 removed <- setdiff(old_names, names)
[17:41:53.069]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:53.069]                   envs[common]]
[17:41:53.069]                 NAMES <- toupper(changed)
[17:41:53.069]                 args <- list()
[17:41:53.069]                 for (kk in seq_along(NAMES)) {
[17:41:53.069]                   name <- changed[[kk]]
[17:41:53.069]                   NAME <- NAMES[[kk]]
[17:41:53.069]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.069]                     next
[17:41:53.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.069]                 }
[17:41:53.069]                 NAMES <- toupper(added)
[17:41:53.069]                 for (kk in seq_along(NAMES)) {
[17:41:53.069]                   name <- added[[kk]]
[17:41:53.069]                   NAME <- NAMES[[kk]]
[17:41:53.069]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.069]                     next
[17:41:53.069]                   args[[name]] <- ""
[17:41:53.069]                 }
[17:41:53.069]                 NAMES <- toupper(removed)
[17:41:53.069]                 for (kk in seq_along(NAMES)) {
[17:41:53.069]                   name <- removed[[kk]]
[17:41:53.069]                   NAME <- NAMES[[kk]]
[17:41:53.069]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.069]                     next
[17:41:53.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.069]                 }
[17:41:53.069]                 if (length(args) > 0) 
[17:41:53.069]                   base::do.call(base::Sys.setenv, args = args)
[17:41:53.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:53.069]             }
[17:41:53.069]             else {
[17:41:53.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:53.069]             }
[17:41:53.069]             {
[17:41:53.069]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:53.069]                   0L) {
[17:41:53.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:53.069]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:53.069]                   base::options(opts)
[17:41:53.069]                 }
[17:41:53.069]                 {
[17:41:53.069]                   {
[17:41:53.069]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:53.069]                     NULL
[17:41:53.069]                   }
[17:41:53.069]                   options(future.plan = NULL)
[17:41:53.069]                   if (is.na(NA_character_)) 
[17:41:53.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:53.069]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:53.069]                     envir = parent.frame()) 
[17:41:53.069]                   {
[17:41:53.069]                     default_workers <- missing(workers)
[17:41:53.069]                     if (is.function(workers)) 
[17:41:53.069]                       workers <- workers()
[17:41:53.069]                     workers <- structure(as.integer(workers), 
[17:41:53.069]                       class = class(workers))
[17:41:53.069]                     stop_if_not(is.finite(workers), workers >= 
[17:41:53.069]                       1L)
[17:41:53.069]                     if ((workers == 1L && !inherits(workers, 
[17:41:53.069]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:53.069]                       if (default_workers) 
[17:41:53.069]                         supportsMulticore(warn = TRUE)
[17:41:53.069]                       return(sequential(..., envir = envir))
[17:41:53.069]                     }
[17:41:53.069]                     oopts <- options(mc.cores = workers)
[17:41:53.069]                     on.exit(options(oopts))
[17:41:53.069]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:53.069]                       envir = envir)
[17:41:53.069]                     if (!future$lazy) 
[17:41:53.069]                       future <- run(future)
[17:41:53.069]                     invisible(future)
[17:41:53.069]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:53.069]                 }
[17:41:53.069]             }
[17:41:53.069]         }
[17:41:53.069]     })
[17:41:53.069]     if (TRUE) {
[17:41:53.069]         base::sink(type = "output", split = FALSE)
[17:41:53.069]         if (TRUE) {
[17:41:53.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:53.069]         }
[17:41:53.069]         else {
[17:41:53.069]             ...future.result["stdout"] <- base::list(NULL)
[17:41:53.069]         }
[17:41:53.069]         base::close(...future.stdout)
[17:41:53.069]         ...future.stdout <- NULL
[17:41:53.069]     }
[17:41:53.069]     ...future.result$conditions <- ...future.conditions
[17:41:53.069]     ...future.result$finished <- base::Sys.time()
[17:41:53.069]     ...future.result
[17:41:53.069] }
[17:41:53.072] assign_globals() ...
[17:41:53.072] List of 2
[17:41:53.072]  $ x                    : int [1:2] 1 2
[17:41:53.072]  $ future.call.arguments:List of 1
[17:41:53.072]   ..$ : num 3
[17:41:53.072]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:53.072]  - attr(*, "where")=List of 2
[17:41:53.072]   ..$ x                    :<environment: R_EmptyEnv> 
[17:41:53.072]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:41:53.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:53.072]  - attr(*, "resolved")= logi FALSE
[17:41:53.072]  - attr(*, "total_size")= num 112
[17:41:53.072]  - attr(*, "already-done")= logi TRUE
[17:41:53.075] - copied ‘x’ to environment
[17:41:53.076] - copied ‘future.call.arguments’ to environment
[17:41:53.076] assign_globals() ... done
[17:41:53.076] requestCore(): workers = 2
[17:41:53.079] MulticoreFuture started
[17:41:53.079] - Launch lazy future ... done
[17:41:53.079] run() for ‘MulticoreFuture’ ... done
[17:41:53.079] plan(): Setting new future strategy stack:
[17:41:53.080] List of future strategies:
[17:41:53.080] 1. sequential:
[17:41:53.080]    - args: function (..., envir = parent.frame())
[17:41:53.080]    - tweaked: FALSE
[17:41:53.080]    - call: NULL
[17:41:53.081] plan(): nbrOfWorkers() = 1
[17:41:53.083] plan(): Setting new future strategy stack:
[17:41:53.083] List of future strategies:
[17:41:53.083] 1. multicore:
[17:41:53.083]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:53.083]    - tweaked: FALSE
[17:41:53.083]    - call: plan(strategy, substitute = FALSE)
[17:41:53.088] plan(): nbrOfWorkers() = 2
[1] 6
** Sum function 'B' with plan('multicore') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x55bfdb93cec0>
Arguments '...' exists: TRUE
[17:41:53.093] getGlobalsAndPackages() ...
[17:41:53.093] Searching for globals...
[17:41:53.095] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:41:53.095] Searching for globals ... DONE
[17:41:53.096] Resolving globals: FALSE
[17:41:53.096] Tweak future expression to call with '...' arguments ...
[17:41:53.096] {
[17:41:53.096]     do.call(function(...) {
[17:41:53.096]         sum(x, ...)
[17:41:53.096]     }, args = future.call.arguments)
[17:41:53.096] }
[17:41:53.096] Tweak future expression to call with '...' arguments ... DONE
[17:41:53.097] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:53.097] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:41:53.097] - globals: [2] ‘x’, ‘future.call.arguments’
[17:41:53.098] 
[17:41:53.098] getGlobalsAndPackages() ... DONE
[17:41:53.098] run() for ‘Future’ ...
[17:41:53.098] - state: ‘created’
[17:41:53.098] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:53.102] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:53.103] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:53.103]   - Field: ‘label’
[17:41:53.103]   - Field: ‘local’
[17:41:53.103]   - Field: ‘owner’
[17:41:53.103]   - Field: ‘envir’
[17:41:53.103]   - Field: ‘workers’
[17:41:53.103]   - Field: ‘packages’
[17:41:53.106]   - Field: ‘gc’
[17:41:53.106]   - Field: ‘job’
[17:41:53.106]   - Field: ‘conditions’
[17:41:53.106]   - Field: ‘expr’
[17:41:53.107]   - Field: ‘uuid’
[17:41:53.107]   - Field: ‘seed’
[17:41:53.107]   - Field: ‘version’
[17:41:53.107]   - Field: ‘result’
[17:41:53.107]   - Field: ‘asynchronous’
[17:41:53.107]   - Field: ‘calls’
[17:41:53.107]   - Field: ‘globals’
[17:41:53.107]   - Field: ‘stdout’
[17:41:53.108]   - Field: ‘earlySignal’
[17:41:53.108]   - Field: ‘lazy’
[17:41:53.108]   - Field: ‘state’
[17:41:53.108] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:53.108] - Launch lazy future ...
[17:41:53.109] Packages needed by the future expression (n = 0): <none>
[17:41:53.109] Packages needed by future strategies (n = 0): <none>
[17:41:53.109] {
[17:41:53.109]     {
[17:41:53.109]         {
[17:41:53.109]             ...future.startTime <- base::Sys.time()
[17:41:53.109]             {
[17:41:53.109]                 {
[17:41:53.109]                   {
[17:41:53.109]                     {
[17:41:53.109]                       base::local({
[17:41:53.109]                         has_future <- base::requireNamespace("future", 
[17:41:53.109]                           quietly = TRUE)
[17:41:53.109]                         if (has_future) {
[17:41:53.109]                           ns <- base::getNamespace("future")
[17:41:53.109]                           version <- ns[[".package"]][["version"]]
[17:41:53.109]                           if (is.null(version)) 
[17:41:53.109]                             version <- utils::packageVersion("future")
[17:41:53.109]                         }
[17:41:53.109]                         else {
[17:41:53.109]                           version <- NULL
[17:41:53.109]                         }
[17:41:53.109]                         if (!has_future || version < "1.8.0") {
[17:41:53.109]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:53.109]                             "", base::R.version$version.string), 
[17:41:53.109]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:53.109]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:53.109]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:53.109]                               "release", "version")], collapse = " "), 
[17:41:53.109]                             hostname = base::Sys.info()[["nodename"]])
[17:41:53.109]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:53.109]                             info)
[17:41:53.109]                           info <- base::paste(info, collapse = "; ")
[17:41:53.109]                           if (!has_future) {
[17:41:53.109]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:53.109]                               info)
[17:41:53.109]                           }
[17:41:53.109]                           else {
[17:41:53.109]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:53.109]                               info, version)
[17:41:53.109]                           }
[17:41:53.109]                           base::stop(msg)
[17:41:53.109]                         }
[17:41:53.109]                       })
[17:41:53.109]                     }
[17:41:53.109]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:53.109]                     base::options(mc.cores = 1L)
[17:41:53.109]                   }
[17:41:53.109]                   options(future.plan = NULL)
[17:41:53.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:53.109]                 }
[17:41:53.109]                 ...future.workdir <- getwd()
[17:41:53.109]             }
[17:41:53.109]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:53.109]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:53.109]         }
[17:41:53.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:53.109]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:53.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:53.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:53.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:53.109]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:53.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:53.109]             base::names(...future.oldOptions))
[17:41:53.109]     }
[17:41:53.109]     if (FALSE) {
[17:41:53.109]     }
[17:41:53.109]     else {
[17:41:53.109]         if (TRUE) {
[17:41:53.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:53.109]                 open = "w")
[17:41:53.109]         }
[17:41:53.109]         else {
[17:41:53.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:53.109]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:53.109]         }
[17:41:53.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:53.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:53.109]             base::sink(type = "output", split = FALSE)
[17:41:53.109]             base::close(...future.stdout)
[17:41:53.109]         }, add = TRUE)
[17:41:53.109]     }
[17:41:53.109]     ...future.frame <- base::sys.nframe()
[17:41:53.109]     ...future.conditions <- base::list()
[17:41:53.109]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:53.109]     if (FALSE) {
[17:41:53.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:53.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:53.109]     }
[17:41:53.109]     ...future.result <- base::tryCatch({
[17:41:53.109]         base::withCallingHandlers({
[17:41:53.109]             ...future.value <- base::withVisible(base::local({
[17:41:53.109]                 withCallingHandlers({
[17:41:53.109]                   {
[17:41:53.109]                     do.call(function(...) {
[17:41:53.109]                       sum(x, ...)
[17:41:53.109]                     }, args = future.call.arguments)
[17:41:53.109]                   }
[17:41:53.109]                 }, immediateCondition = function(cond) {
[17:41:53.109]                   save_rds <- function (object, pathname, ...) 
[17:41:53.109]                   {
[17:41:53.109]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:53.109]                     if (file_test("-f", pathname_tmp)) {
[17:41:53.109]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.109]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:53.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.109]                         fi_tmp[["mtime"]])
[17:41:53.109]                     }
[17:41:53.109]                     tryCatch({
[17:41:53.109]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:53.109]                     }, error = function(ex) {
[17:41:53.109]                       msg <- conditionMessage(ex)
[17:41:53.109]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.109]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:53.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.109]                         fi_tmp[["mtime"]], msg)
[17:41:53.109]                       ex$message <- msg
[17:41:53.109]                       stop(ex)
[17:41:53.109]                     })
[17:41:53.109]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:53.109]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:53.109]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:53.109]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.109]                       fi <- file.info(pathname)
[17:41:53.109]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:53.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.109]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:53.109]                         fi[["size"]], fi[["mtime"]])
[17:41:53.109]                       stop(msg)
[17:41:53.109]                     }
[17:41:53.109]                     invisible(pathname)
[17:41:53.109]                   }
[17:41:53.109]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:53.109]                     rootPath = tempdir()) 
[17:41:53.109]                   {
[17:41:53.109]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:53.109]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:53.109]                       tmpdir = path, fileext = ".rds")
[17:41:53.109]                     save_rds(obj, file)
[17:41:53.109]                   }
[17:41:53.109]                   saveImmediateCondition(cond, path = "/tmp/RtmpDeYcUG/.future/immediateConditions")
[17:41:53.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.109]                   {
[17:41:53.109]                     inherits <- base::inherits
[17:41:53.109]                     invokeRestart <- base::invokeRestart
[17:41:53.109]                     is.null <- base::is.null
[17:41:53.109]                     muffled <- FALSE
[17:41:53.109]                     if (inherits(cond, "message")) {
[17:41:53.109]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:53.109]                       if (muffled) 
[17:41:53.109]                         invokeRestart("muffleMessage")
[17:41:53.109]                     }
[17:41:53.109]                     else if (inherits(cond, "warning")) {
[17:41:53.109]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:53.109]                       if (muffled) 
[17:41:53.109]                         invokeRestart("muffleWarning")
[17:41:53.109]                     }
[17:41:53.109]                     else if (inherits(cond, "condition")) {
[17:41:53.109]                       if (!is.null(pattern)) {
[17:41:53.109]                         computeRestarts <- base::computeRestarts
[17:41:53.109]                         grepl <- base::grepl
[17:41:53.109]                         restarts <- computeRestarts(cond)
[17:41:53.109]                         for (restart in restarts) {
[17:41:53.109]                           name <- restart$name
[17:41:53.109]                           if (is.null(name)) 
[17:41:53.109]                             next
[17:41:53.109]                           if (!grepl(pattern, name)) 
[17:41:53.109]                             next
[17:41:53.109]                           invokeRestart(restart)
[17:41:53.109]                           muffled <- TRUE
[17:41:53.109]                           break
[17:41:53.109]                         }
[17:41:53.109]                       }
[17:41:53.109]                     }
[17:41:53.109]                     invisible(muffled)
[17:41:53.109]                   }
[17:41:53.109]                   muffleCondition(cond)
[17:41:53.109]                 })
[17:41:53.109]             }))
[17:41:53.109]             future::FutureResult(value = ...future.value$value, 
[17:41:53.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.109]                   ...future.rng), globalenv = if (FALSE) 
[17:41:53.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:53.109]                     ...future.globalenv.names))
[17:41:53.109]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:53.109]         }, condition = base::local({
[17:41:53.109]             c <- base::c
[17:41:53.109]             inherits <- base::inherits
[17:41:53.109]             invokeRestart <- base::invokeRestart
[17:41:53.109]             length <- base::length
[17:41:53.109]             list <- base::list
[17:41:53.109]             seq.int <- base::seq.int
[17:41:53.109]             signalCondition <- base::signalCondition
[17:41:53.109]             sys.calls <- base::sys.calls
[17:41:53.109]             `[[` <- base::`[[`
[17:41:53.109]             `+` <- base::`+`
[17:41:53.109]             `<<-` <- base::`<<-`
[17:41:53.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:53.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:53.109]                   3L)]
[17:41:53.109]             }
[17:41:53.109]             function(cond) {
[17:41:53.109]                 is_error <- inherits(cond, "error")
[17:41:53.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:53.109]                   NULL)
[17:41:53.109]                 if (is_error) {
[17:41:53.109]                   sessionInformation <- function() {
[17:41:53.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:53.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:53.109]                       search = base::search(), system = base::Sys.info())
[17:41:53.109]                   }
[17:41:53.109]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:53.109]                     cond$call), session = sessionInformation(), 
[17:41:53.109]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:53.109]                   signalCondition(cond)
[17:41:53.109]                 }
[17:41:53.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:53.109]                 "immediateCondition"))) {
[17:41:53.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:53.109]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:53.109]                   if (TRUE && !signal) {
[17:41:53.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.109]                     {
[17:41:53.109]                       inherits <- base::inherits
[17:41:53.109]                       invokeRestart <- base::invokeRestart
[17:41:53.109]                       is.null <- base::is.null
[17:41:53.109]                       muffled <- FALSE
[17:41:53.109]                       if (inherits(cond, "message")) {
[17:41:53.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.109]                         if (muffled) 
[17:41:53.109]                           invokeRestart("muffleMessage")
[17:41:53.109]                       }
[17:41:53.109]                       else if (inherits(cond, "warning")) {
[17:41:53.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.109]                         if (muffled) 
[17:41:53.109]                           invokeRestart("muffleWarning")
[17:41:53.109]                       }
[17:41:53.109]                       else if (inherits(cond, "condition")) {
[17:41:53.109]                         if (!is.null(pattern)) {
[17:41:53.109]                           computeRestarts <- base::computeRestarts
[17:41:53.109]                           grepl <- base::grepl
[17:41:53.109]                           restarts <- computeRestarts(cond)
[17:41:53.109]                           for (restart in restarts) {
[17:41:53.109]                             name <- restart$name
[17:41:53.109]                             if (is.null(name)) 
[17:41:53.109]                               next
[17:41:53.109]                             if (!grepl(pattern, name)) 
[17:41:53.109]                               next
[17:41:53.109]                             invokeRestart(restart)
[17:41:53.109]                             muffled <- TRUE
[17:41:53.109]                             break
[17:41:53.109]                           }
[17:41:53.109]                         }
[17:41:53.109]                       }
[17:41:53.109]                       invisible(muffled)
[17:41:53.109]                     }
[17:41:53.109]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.109]                   }
[17:41:53.109]                 }
[17:41:53.109]                 else {
[17:41:53.109]                   if (TRUE) {
[17:41:53.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.109]                     {
[17:41:53.109]                       inherits <- base::inherits
[17:41:53.109]                       invokeRestart <- base::invokeRestart
[17:41:53.109]                       is.null <- base::is.null
[17:41:53.109]                       muffled <- FALSE
[17:41:53.109]                       if (inherits(cond, "message")) {
[17:41:53.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.109]                         if (muffled) 
[17:41:53.109]                           invokeRestart("muffleMessage")
[17:41:53.109]                       }
[17:41:53.109]                       else if (inherits(cond, "warning")) {
[17:41:53.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.109]                         if (muffled) 
[17:41:53.109]                           invokeRestart("muffleWarning")
[17:41:53.109]                       }
[17:41:53.109]                       else if (inherits(cond, "condition")) {
[17:41:53.109]                         if (!is.null(pattern)) {
[17:41:53.109]                           computeRestarts <- base::computeRestarts
[17:41:53.109]                           grepl <- base::grepl
[17:41:53.109]                           restarts <- computeRestarts(cond)
[17:41:53.109]                           for (restart in restarts) {
[17:41:53.109]                             name <- restart$name
[17:41:53.109]                             if (is.null(name)) 
[17:41:53.109]                               next
[17:41:53.109]                             if (!grepl(pattern, name)) 
[17:41:53.109]                               next
[17:41:53.109]                             invokeRestart(restart)
[17:41:53.109]                             muffled <- TRUE
[17:41:53.109]                             break
[17:41:53.109]                           }
[17:41:53.109]                         }
[17:41:53.109]                       }
[17:41:53.109]                       invisible(muffled)
[17:41:53.109]                     }
[17:41:53.109]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.109]                   }
[17:41:53.109]                 }
[17:41:53.109]             }
[17:41:53.109]         }))
[17:41:53.109]     }, error = function(ex) {
[17:41:53.109]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:53.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.109]                 ...future.rng), started = ...future.startTime, 
[17:41:53.109]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:53.109]             version = "1.8"), class = "FutureResult")
[17:41:53.109]     }, finally = {
[17:41:53.109]         if (!identical(...future.workdir, getwd())) 
[17:41:53.109]             setwd(...future.workdir)
[17:41:53.109]         {
[17:41:53.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:53.109]                 ...future.oldOptions$nwarnings <- NULL
[17:41:53.109]             }
[17:41:53.109]             base::options(...future.oldOptions)
[17:41:53.109]             if (.Platform$OS.type == "windows") {
[17:41:53.109]                 old_names <- names(...future.oldEnvVars)
[17:41:53.109]                 envs <- base::Sys.getenv()
[17:41:53.109]                 names <- names(envs)
[17:41:53.109]                 common <- intersect(names, old_names)
[17:41:53.109]                 added <- setdiff(names, old_names)
[17:41:53.109]                 removed <- setdiff(old_names, names)
[17:41:53.109]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:53.109]                   envs[common]]
[17:41:53.109]                 NAMES <- toupper(changed)
[17:41:53.109]                 args <- list()
[17:41:53.109]                 for (kk in seq_along(NAMES)) {
[17:41:53.109]                   name <- changed[[kk]]
[17:41:53.109]                   NAME <- NAMES[[kk]]
[17:41:53.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.109]                     next
[17:41:53.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.109]                 }
[17:41:53.109]                 NAMES <- toupper(added)
[17:41:53.109]                 for (kk in seq_along(NAMES)) {
[17:41:53.109]                   name <- added[[kk]]
[17:41:53.109]                   NAME <- NAMES[[kk]]
[17:41:53.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.109]                     next
[17:41:53.109]                   args[[name]] <- ""
[17:41:53.109]                 }
[17:41:53.109]                 NAMES <- toupper(removed)
[17:41:53.109]                 for (kk in seq_along(NAMES)) {
[17:41:53.109]                   name <- removed[[kk]]
[17:41:53.109]                   NAME <- NAMES[[kk]]
[17:41:53.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.109]                     next
[17:41:53.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.109]                 }
[17:41:53.109]                 if (length(args) > 0) 
[17:41:53.109]                   base::do.call(base::Sys.setenv, args = args)
[17:41:53.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:53.109]             }
[17:41:53.109]             else {
[17:41:53.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:53.109]             }
[17:41:53.109]             {
[17:41:53.109]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:53.109]                   0L) {
[17:41:53.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:53.109]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:53.109]                   base::options(opts)
[17:41:53.109]                 }
[17:41:53.109]                 {
[17:41:53.109]                   {
[17:41:53.109]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:53.109]                     NULL
[17:41:53.109]                   }
[17:41:53.109]                   options(future.plan = NULL)
[17:41:53.109]                   if (is.na(NA_character_)) 
[17:41:53.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:53.109]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:53.109]                     envir = parent.frame()) 
[17:41:53.109]                   {
[17:41:53.109]                     default_workers <- missing(workers)
[17:41:53.109]                     if (is.function(workers)) 
[17:41:53.109]                       workers <- workers()
[17:41:53.109]                     workers <- structure(as.integer(workers), 
[17:41:53.109]                       class = class(workers))
[17:41:53.109]                     stop_if_not(is.finite(workers), workers >= 
[17:41:53.109]                       1L)
[17:41:53.109]                     if ((workers == 1L && !inherits(workers, 
[17:41:53.109]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:53.109]                       if (default_workers) 
[17:41:53.109]                         supportsMulticore(warn = TRUE)
[17:41:53.109]                       return(sequential(..., envir = envir))
[17:41:53.109]                     }
[17:41:53.109]                     oopts <- options(mc.cores = workers)
[17:41:53.109]                     on.exit(options(oopts))
[17:41:53.109]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:53.109]                       envir = envir)
[17:41:53.109]                     if (!future$lazy) 
[17:41:53.109]                       future <- run(future)
[17:41:53.109]                     invisible(future)
[17:41:53.109]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:53.109]                 }
[17:41:53.109]             }
[17:41:53.109]         }
[17:41:53.109]     })
[17:41:53.109]     if (TRUE) {
[17:41:53.109]         base::sink(type = "output", split = FALSE)
[17:41:53.109]         if (TRUE) {
[17:41:53.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:53.109]         }
[17:41:53.109]         else {
[17:41:53.109]             ...future.result["stdout"] <- base::list(NULL)
[17:41:53.109]         }
[17:41:53.109]         base::close(...future.stdout)
[17:41:53.109]         ...future.stdout <- NULL
[17:41:53.109]     }
[17:41:53.109]     ...future.result$conditions <- ...future.conditions
[17:41:53.109]     ...future.result$finished <- base::Sys.time()
[17:41:53.109]     ...future.result
[17:41:53.109] }
[17:41:53.112] assign_globals() ...
[17:41:53.112] List of 2
[17:41:53.112]  $ x                    : int [1:2] 1 2
[17:41:53.112]  $ future.call.arguments:List of 1
[17:41:53.112]   ..$ : num 3
[17:41:53.112]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:53.112]  - attr(*, "where")=List of 2
[17:41:53.112]   ..$ x                    :<environment: R_EmptyEnv> 
[17:41:53.112]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:41:53.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:53.112]  - attr(*, "resolved")= logi FALSE
[17:41:53.112]  - attr(*, "total_size")= num 112
[17:41:53.112]  - attr(*, "already-done")= logi TRUE
[17:41:53.117] - copied ‘x’ to environment
[17:41:53.117] - copied ‘future.call.arguments’ to environment
[17:41:53.117] assign_globals() ... done
[17:41:53.117] requestCore(): workers = 2
[17:41:53.119] MulticoreFuture started
[17:41:53.119] - Launch lazy future ... done
[17:41:53.120] run() for ‘MulticoreFuture’ ... done
[17:41:53.120] plan(): Setting new future strategy stack:
[17:41:53.120] List of future strategies:
[17:41:53.120] 1. sequential:
[17:41:53.120]    - args: function (..., envir = parent.frame())
[17:41:53.120]    - tweaked: FALSE
[17:41:53.120]    - call: NULL
[17:41:53.121] plan(): nbrOfWorkers() = 1
[17:41:53.124] plan(): Setting new future strategy stack:
[17:41:53.124] List of future strategies:
[17:41:53.124] 1. multicore:
[17:41:53.124]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:53.124]    - tweaked: FALSE
[17:41:53.124]    - call: plan(strategy, substitute = FALSE)
[17:41:53.129] plan(): nbrOfWorkers() = 2
[1] 6
** Sum function 'C' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55bfdbab5fc0>
Arguments '...' exists: FALSE
[17:41:53.131] getGlobalsAndPackages() ...
[17:41:53.131] Searching for globals...
[17:41:53.133] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[17:41:53.133] Searching for globals ... DONE
[17:41:53.133] Resolving globals: FALSE
[17:41:53.134] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:53.135] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:41:53.135] - globals: [2] ‘x’, ‘y’
[17:41:53.135] 
[17:41:53.135] getGlobalsAndPackages() ... DONE
[17:41:53.135] run() for ‘Future’ ...
[17:41:53.136] - state: ‘created’
[17:41:53.136] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:53.140] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:53.140] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:53.140]   - Field: ‘label’
[17:41:53.140]   - Field: ‘local’
[17:41:53.140]   - Field: ‘owner’
[17:41:53.141]   - Field: ‘envir’
[17:41:53.141]   - Field: ‘workers’
[17:41:53.141]   - Field: ‘packages’
[17:41:53.141]   - Field: ‘gc’
[17:41:53.141]   - Field: ‘job’
[17:41:53.141]   - Field: ‘conditions’
[17:41:53.141]   - Field: ‘expr’
[17:41:53.141]   - Field: ‘uuid’
[17:41:53.142]   - Field: ‘seed’
[17:41:53.142]   - Field: ‘version’
[17:41:53.142]   - Field: ‘result’
[17:41:53.142]   - Field: ‘asynchronous’
[17:41:53.142]   - Field: ‘calls’
[17:41:53.142]   - Field: ‘globals’
[17:41:53.142]   - Field: ‘stdout’
[17:41:53.142]   - Field: ‘earlySignal’
[17:41:53.142]   - Field: ‘lazy’
[17:41:53.143]   - Field: ‘state’
[17:41:53.143] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:53.143] - Launch lazy future ...
[17:41:53.143] Packages needed by the future expression (n = 0): <none>
[17:41:53.143] Packages needed by future strategies (n = 0): <none>
[17:41:53.144] {
[17:41:53.144]     {
[17:41:53.144]         {
[17:41:53.144]             ...future.startTime <- base::Sys.time()
[17:41:53.144]             {
[17:41:53.144]                 {
[17:41:53.144]                   {
[17:41:53.144]                     {
[17:41:53.144]                       base::local({
[17:41:53.144]                         has_future <- base::requireNamespace("future", 
[17:41:53.144]                           quietly = TRUE)
[17:41:53.144]                         if (has_future) {
[17:41:53.144]                           ns <- base::getNamespace("future")
[17:41:53.144]                           version <- ns[[".package"]][["version"]]
[17:41:53.144]                           if (is.null(version)) 
[17:41:53.144]                             version <- utils::packageVersion("future")
[17:41:53.144]                         }
[17:41:53.144]                         else {
[17:41:53.144]                           version <- NULL
[17:41:53.144]                         }
[17:41:53.144]                         if (!has_future || version < "1.8.0") {
[17:41:53.144]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:53.144]                             "", base::R.version$version.string), 
[17:41:53.144]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:53.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:53.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:53.144]                               "release", "version")], collapse = " "), 
[17:41:53.144]                             hostname = base::Sys.info()[["nodename"]])
[17:41:53.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:53.144]                             info)
[17:41:53.144]                           info <- base::paste(info, collapse = "; ")
[17:41:53.144]                           if (!has_future) {
[17:41:53.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:53.144]                               info)
[17:41:53.144]                           }
[17:41:53.144]                           else {
[17:41:53.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:53.144]                               info, version)
[17:41:53.144]                           }
[17:41:53.144]                           base::stop(msg)
[17:41:53.144]                         }
[17:41:53.144]                       })
[17:41:53.144]                     }
[17:41:53.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:53.144]                     base::options(mc.cores = 1L)
[17:41:53.144]                   }
[17:41:53.144]                   options(future.plan = NULL)
[17:41:53.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:53.144]                 }
[17:41:53.144]                 ...future.workdir <- getwd()
[17:41:53.144]             }
[17:41:53.144]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:53.144]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:53.144]         }
[17:41:53.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:53.144]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:53.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:53.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:53.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:53.144]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:53.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:53.144]             base::names(...future.oldOptions))
[17:41:53.144]     }
[17:41:53.144]     if (FALSE) {
[17:41:53.144]     }
[17:41:53.144]     else {
[17:41:53.144]         if (TRUE) {
[17:41:53.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:53.144]                 open = "w")
[17:41:53.144]         }
[17:41:53.144]         else {
[17:41:53.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:53.144]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:53.144]         }
[17:41:53.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:53.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:53.144]             base::sink(type = "output", split = FALSE)
[17:41:53.144]             base::close(...future.stdout)
[17:41:53.144]         }, add = TRUE)
[17:41:53.144]     }
[17:41:53.144]     ...future.frame <- base::sys.nframe()
[17:41:53.144]     ...future.conditions <- base::list()
[17:41:53.144]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:53.144]     if (FALSE) {
[17:41:53.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:53.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:53.144]     }
[17:41:53.144]     ...future.result <- base::tryCatch({
[17:41:53.144]         base::withCallingHandlers({
[17:41:53.144]             ...future.value <- base::withVisible(base::local({
[17:41:53.144]                 withCallingHandlers({
[17:41:53.144]                   {
[17:41:53.144]                     sum(x, y)
[17:41:53.144]                   }
[17:41:53.144]                 }, immediateCondition = function(cond) {
[17:41:53.144]                   save_rds <- function (object, pathname, ...) 
[17:41:53.144]                   {
[17:41:53.144]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:53.144]                     if (file_test("-f", pathname_tmp)) {
[17:41:53.144]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.144]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:53.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.144]                         fi_tmp[["mtime"]])
[17:41:53.144]                     }
[17:41:53.144]                     tryCatch({
[17:41:53.144]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:53.144]                     }, error = function(ex) {
[17:41:53.144]                       msg <- conditionMessage(ex)
[17:41:53.144]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.144]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:53.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.144]                         fi_tmp[["mtime"]], msg)
[17:41:53.144]                       ex$message <- msg
[17:41:53.144]                       stop(ex)
[17:41:53.144]                     })
[17:41:53.144]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:53.144]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:53.144]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:53.144]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.144]                       fi <- file.info(pathname)
[17:41:53.144]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:53.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.144]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:53.144]                         fi[["size"]], fi[["mtime"]])
[17:41:53.144]                       stop(msg)
[17:41:53.144]                     }
[17:41:53.144]                     invisible(pathname)
[17:41:53.144]                   }
[17:41:53.144]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:53.144]                     rootPath = tempdir()) 
[17:41:53.144]                   {
[17:41:53.144]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:53.144]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:53.144]                       tmpdir = path, fileext = ".rds")
[17:41:53.144]                     save_rds(obj, file)
[17:41:53.144]                   }
[17:41:53.144]                   saveImmediateCondition(cond, path = "/tmp/RtmpDeYcUG/.future/immediateConditions")
[17:41:53.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.144]                   {
[17:41:53.144]                     inherits <- base::inherits
[17:41:53.144]                     invokeRestart <- base::invokeRestart
[17:41:53.144]                     is.null <- base::is.null
[17:41:53.144]                     muffled <- FALSE
[17:41:53.144]                     if (inherits(cond, "message")) {
[17:41:53.144]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:53.144]                       if (muffled) 
[17:41:53.144]                         invokeRestart("muffleMessage")
[17:41:53.144]                     }
[17:41:53.144]                     else if (inherits(cond, "warning")) {
[17:41:53.144]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:53.144]                       if (muffled) 
[17:41:53.144]                         invokeRestart("muffleWarning")
[17:41:53.144]                     }
[17:41:53.144]                     else if (inherits(cond, "condition")) {
[17:41:53.144]                       if (!is.null(pattern)) {
[17:41:53.144]                         computeRestarts <- base::computeRestarts
[17:41:53.144]                         grepl <- base::grepl
[17:41:53.144]                         restarts <- computeRestarts(cond)
[17:41:53.144]                         for (restart in restarts) {
[17:41:53.144]                           name <- restart$name
[17:41:53.144]                           if (is.null(name)) 
[17:41:53.144]                             next
[17:41:53.144]                           if (!grepl(pattern, name)) 
[17:41:53.144]                             next
[17:41:53.144]                           invokeRestart(restart)
[17:41:53.144]                           muffled <- TRUE
[17:41:53.144]                           break
[17:41:53.144]                         }
[17:41:53.144]                       }
[17:41:53.144]                     }
[17:41:53.144]                     invisible(muffled)
[17:41:53.144]                   }
[17:41:53.144]                   muffleCondition(cond)
[17:41:53.144]                 })
[17:41:53.144]             }))
[17:41:53.144]             future::FutureResult(value = ...future.value$value, 
[17:41:53.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.144]                   ...future.rng), globalenv = if (FALSE) 
[17:41:53.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:53.144]                     ...future.globalenv.names))
[17:41:53.144]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:53.144]         }, condition = base::local({
[17:41:53.144]             c <- base::c
[17:41:53.144]             inherits <- base::inherits
[17:41:53.144]             invokeRestart <- base::invokeRestart
[17:41:53.144]             length <- base::length
[17:41:53.144]             list <- base::list
[17:41:53.144]             seq.int <- base::seq.int
[17:41:53.144]             signalCondition <- base::signalCondition
[17:41:53.144]             sys.calls <- base::sys.calls
[17:41:53.144]             `[[` <- base::`[[`
[17:41:53.144]             `+` <- base::`+`
[17:41:53.144]             `<<-` <- base::`<<-`
[17:41:53.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:53.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:53.144]                   3L)]
[17:41:53.144]             }
[17:41:53.144]             function(cond) {
[17:41:53.144]                 is_error <- inherits(cond, "error")
[17:41:53.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:53.144]                   NULL)
[17:41:53.144]                 if (is_error) {
[17:41:53.144]                   sessionInformation <- function() {
[17:41:53.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:53.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:53.144]                       search = base::search(), system = base::Sys.info())
[17:41:53.144]                   }
[17:41:53.144]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:53.144]                     cond$call), session = sessionInformation(), 
[17:41:53.144]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:53.144]                   signalCondition(cond)
[17:41:53.144]                 }
[17:41:53.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:53.144]                 "immediateCondition"))) {
[17:41:53.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:53.144]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:53.144]                   if (TRUE && !signal) {
[17:41:53.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.144]                     {
[17:41:53.144]                       inherits <- base::inherits
[17:41:53.144]                       invokeRestart <- base::invokeRestart
[17:41:53.144]                       is.null <- base::is.null
[17:41:53.144]                       muffled <- FALSE
[17:41:53.144]                       if (inherits(cond, "message")) {
[17:41:53.144]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.144]                         if (muffled) 
[17:41:53.144]                           invokeRestart("muffleMessage")
[17:41:53.144]                       }
[17:41:53.144]                       else if (inherits(cond, "warning")) {
[17:41:53.144]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.144]                         if (muffled) 
[17:41:53.144]                           invokeRestart("muffleWarning")
[17:41:53.144]                       }
[17:41:53.144]                       else if (inherits(cond, "condition")) {
[17:41:53.144]                         if (!is.null(pattern)) {
[17:41:53.144]                           computeRestarts <- base::computeRestarts
[17:41:53.144]                           grepl <- base::grepl
[17:41:53.144]                           restarts <- computeRestarts(cond)
[17:41:53.144]                           for (restart in restarts) {
[17:41:53.144]                             name <- restart$name
[17:41:53.144]                             if (is.null(name)) 
[17:41:53.144]                               next
[17:41:53.144]                             if (!grepl(pattern, name)) 
[17:41:53.144]                               next
[17:41:53.144]                             invokeRestart(restart)
[17:41:53.144]                             muffled <- TRUE
[17:41:53.144]                             break
[17:41:53.144]                           }
[17:41:53.144]                         }
[17:41:53.144]                       }
[17:41:53.144]                       invisible(muffled)
[17:41:53.144]                     }
[17:41:53.144]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.144]                   }
[17:41:53.144]                 }
[17:41:53.144]                 else {
[17:41:53.144]                   if (TRUE) {
[17:41:53.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.144]                     {
[17:41:53.144]                       inherits <- base::inherits
[17:41:53.144]                       invokeRestart <- base::invokeRestart
[17:41:53.144]                       is.null <- base::is.null
[17:41:53.144]                       muffled <- FALSE
[17:41:53.144]                       if (inherits(cond, "message")) {
[17:41:53.144]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.144]                         if (muffled) 
[17:41:53.144]                           invokeRestart("muffleMessage")
[17:41:53.144]                       }
[17:41:53.144]                       else if (inherits(cond, "warning")) {
[17:41:53.144]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.144]                         if (muffled) 
[17:41:53.144]                           invokeRestart("muffleWarning")
[17:41:53.144]                       }
[17:41:53.144]                       else if (inherits(cond, "condition")) {
[17:41:53.144]                         if (!is.null(pattern)) {
[17:41:53.144]                           computeRestarts <- base::computeRestarts
[17:41:53.144]                           grepl <- base::grepl
[17:41:53.144]                           restarts <- computeRestarts(cond)
[17:41:53.144]                           for (restart in restarts) {
[17:41:53.144]                             name <- restart$name
[17:41:53.144]                             if (is.null(name)) 
[17:41:53.144]                               next
[17:41:53.144]                             if (!grepl(pattern, name)) 
[17:41:53.144]                               next
[17:41:53.144]                             invokeRestart(restart)
[17:41:53.144]                             muffled <- TRUE
[17:41:53.144]                             break
[17:41:53.144]                           }
[17:41:53.144]                         }
[17:41:53.144]                       }
[17:41:53.144]                       invisible(muffled)
[17:41:53.144]                     }
[17:41:53.144]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.144]                   }
[17:41:53.144]                 }
[17:41:53.144]             }
[17:41:53.144]         }))
[17:41:53.144]     }, error = function(ex) {
[17:41:53.144]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:53.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.144]                 ...future.rng), started = ...future.startTime, 
[17:41:53.144]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:53.144]             version = "1.8"), class = "FutureResult")
[17:41:53.144]     }, finally = {
[17:41:53.144]         if (!identical(...future.workdir, getwd())) 
[17:41:53.144]             setwd(...future.workdir)
[17:41:53.144]         {
[17:41:53.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:53.144]                 ...future.oldOptions$nwarnings <- NULL
[17:41:53.144]             }
[17:41:53.144]             base::options(...future.oldOptions)
[17:41:53.144]             if (.Platform$OS.type == "windows") {
[17:41:53.144]                 old_names <- names(...future.oldEnvVars)
[17:41:53.144]                 envs <- base::Sys.getenv()
[17:41:53.144]                 names <- names(envs)
[17:41:53.144]                 common <- intersect(names, old_names)
[17:41:53.144]                 added <- setdiff(names, old_names)
[17:41:53.144]                 removed <- setdiff(old_names, names)
[17:41:53.144]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:53.144]                   envs[common]]
[17:41:53.144]                 NAMES <- toupper(changed)
[17:41:53.144]                 args <- list()
[17:41:53.144]                 for (kk in seq_along(NAMES)) {
[17:41:53.144]                   name <- changed[[kk]]
[17:41:53.144]                   NAME <- NAMES[[kk]]
[17:41:53.144]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.144]                     next
[17:41:53.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.144]                 }
[17:41:53.144]                 NAMES <- toupper(added)
[17:41:53.144]                 for (kk in seq_along(NAMES)) {
[17:41:53.144]                   name <- added[[kk]]
[17:41:53.144]                   NAME <- NAMES[[kk]]
[17:41:53.144]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.144]                     next
[17:41:53.144]                   args[[name]] <- ""
[17:41:53.144]                 }
[17:41:53.144]                 NAMES <- toupper(removed)
[17:41:53.144]                 for (kk in seq_along(NAMES)) {
[17:41:53.144]                   name <- removed[[kk]]
[17:41:53.144]                   NAME <- NAMES[[kk]]
[17:41:53.144]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.144]                     next
[17:41:53.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.144]                 }
[17:41:53.144]                 if (length(args) > 0) 
[17:41:53.144]                   base::do.call(base::Sys.setenv, args = args)
[17:41:53.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:53.144]             }
[17:41:53.144]             else {
[17:41:53.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:53.144]             }
[17:41:53.144]             {
[17:41:53.144]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:53.144]                   0L) {
[17:41:53.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:53.144]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:53.144]                   base::options(opts)
[17:41:53.144]                 }
[17:41:53.144]                 {
[17:41:53.144]                   {
[17:41:53.144]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:53.144]                     NULL
[17:41:53.144]                   }
[17:41:53.144]                   options(future.plan = NULL)
[17:41:53.144]                   if (is.na(NA_character_)) 
[17:41:53.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:53.144]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:53.144]                     envir = parent.frame()) 
[17:41:53.144]                   {
[17:41:53.144]                     default_workers <- missing(workers)
[17:41:53.144]                     if (is.function(workers)) 
[17:41:53.144]                       workers <- workers()
[17:41:53.144]                     workers <- structure(as.integer(workers), 
[17:41:53.144]                       class = class(workers))
[17:41:53.144]                     stop_if_not(is.finite(workers), workers >= 
[17:41:53.144]                       1L)
[17:41:53.144]                     if ((workers == 1L && !inherits(workers, 
[17:41:53.144]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:53.144]                       if (default_workers) 
[17:41:53.144]                         supportsMulticore(warn = TRUE)
[17:41:53.144]                       return(sequential(..., envir = envir))
[17:41:53.144]                     }
[17:41:53.144]                     oopts <- options(mc.cores = workers)
[17:41:53.144]                     on.exit(options(oopts))
[17:41:53.144]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:53.144]                       envir = envir)
[17:41:53.144]                     if (!future$lazy) 
[17:41:53.144]                       future <- run(future)
[17:41:53.144]                     invisible(future)
[17:41:53.144]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:53.144]                 }
[17:41:53.144]             }
[17:41:53.144]         }
[17:41:53.144]     })
[17:41:53.144]     if (TRUE) {
[17:41:53.144]         base::sink(type = "output", split = FALSE)
[17:41:53.144]         if (TRUE) {
[17:41:53.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:53.144]         }
[17:41:53.144]         else {
[17:41:53.144]             ...future.result["stdout"] <- base::list(NULL)
[17:41:53.144]         }
[17:41:53.144]         base::close(...future.stdout)
[17:41:53.144]         ...future.stdout <- NULL
[17:41:53.144]     }
[17:41:53.144]     ...future.result$conditions <- ...future.conditions
[17:41:53.144]     ...future.result$finished <- base::Sys.time()
[17:41:53.144]     ...future.result
[17:41:53.144] }
[17:41:53.147] assign_globals() ...
[17:41:53.147] List of 2
[17:41:53.147]  $ x: int [1:2] 1 2
[17:41:53.147]  $ y: num 3
[17:41:53.147]  - attr(*, "where")=List of 2
[17:41:53.147]   ..$ x:<environment: R_EmptyEnv> 
[17:41:53.147]   ..$ y:<environment: R_EmptyEnv> 
[17:41:53.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:53.147]  - attr(*, "resolved")= logi FALSE
[17:41:53.147]  - attr(*, "total_size")= num 112
[17:41:53.147]  - attr(*, "already-done")= logi TRUE
[17:41:53.151] - copied ‘x’ to environment
[17:41:53.151] - copied ‘y’ to environment
[17:41:53.151] assign_globals() ... done
[17:41:53.151] requestCore(): workers = 2
[17:41:53.153] MulticoreFuture started
[17:41:53.153] - Launch lazy future ... done
[17:41:53.154] run() for ‘MulticoreFuture’ ... done
[17:41:53.154] plan(): Setting new future strategy stack:
[17:41:53.155] List of future strategies:
[17:41:53.155] 1. sequential:
[17:41:53.155]    - args: function (..., envir = parent.frame())
[17:41:53.155]    - tweaked: FALSE
[17:41:53.155]    - call: NULL
[17:41:53.156] plan(): nbrOfWorkers() = 1
[17:41:53.158] plan(): Setting new future strategy stack:
[17:41:53.158] List of future strategies:
[17:41:53.158] 1. multicore:
[17:41:53.158]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:53.158]    - tweaked: FALSE
[17:41:53.158]    - call: plan(strategy, substitute = FALSE)
[17:41:53.163] plan(): nbrOfWorkers() = 2
[1] 6
** Sum function 'D' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x55bfd9c698d0>
Arguments '...' exists: FALSE
[17:41:53.165] getGlobalsAndPackages() ...
[17:41:53.165] Searching for globals...
[17:41:53.167] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[17:41:53.167] Searching for globals ... DONE
[17:41:53.167] Resolving globals: FALSE
[17:41:53.168] Tweak future expression to call with '...' arguments ...
[17:41:53.168] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:53.169] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:41:53.172] - globals: [2] ‘x’, ‘y’
[17:41:53.172] 
[17:41:53.172] getGlobalsAndPackages() ... DONE
[17:41:53.173] run() for ‘Future’ ...
[17:41:53.173] - state: ‘created’
[17:41:53.173] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:53.177] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:53.178] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:53.178]   - Field: ‘label’
[17:41:53.178]   - Field: ‘local’
[17:41:53.178]   - Field: ‘owner’
[17:41:53.178]   - Field: ‘envir’
[17:41:53.178]   - Field: ‘workers’
[17:41:53.178]   - Field: ‘packages’
[17:41:53.179]   - Field: ‘gc’
[17:41:53.179]   - Field: ‘job’
[17:41:53.179]   - Field: ‘conditions’
[17:41:53.179]   - Field: ‘expr’
[17:41:53.179]   - Field: ‘uuid’
[17:41:53.179]   - Field: ‘seed’
[17:41:53.179]   - Field: ‘version’
[17:41:53.179]   - Field: ‘result’
[17:41:53.180]   - Field: ‘asynchronous’
[17:41:53.180]   - Field: ‘calls’
[17:41:53.180]   - Field: ‘globals’
[17:41:53.180]   - Field: ‘stdout’
[17:41:53.180]   - Field: ‘earlySignal’
[17:41:53.180]   - Field: ‘lazy’
[17:41:53.180]   - Field: ‘state’
[17:41:53.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:53.181] - Launch lazy future ...
[17:41:53.181] Packages needed by the future expression (n = 0): <none>
[17:41:53.181] Packages needed by future strategies (n = 0): <none>
[17:41:53.182] {
[17:41:53.182]     {
[17:41:53.182]         {
[17:41:53.182]             ...future.startTime <- base::Sys.time()
[17:41:53.182]             {
[17:41:53.182]                 {
[17:41:53.182]                   {
[17:41:53.182]                     {
[17:41:53.182]                       base::local({
[17:41:53.182]                         has_future <- base::requireNamespace("future", 
[17:41:53.182]                           quietly = TRUE)
[17:41:53.182]                         if (has_future) {
[17:41:53.182]                           ns <- base::getNamespace("future")
[17:41:53.182]                           version <- ns[[".package"]][["version"]]
[17:41:53.182]                           if (is.null(version)) 
[17:41:53.182]                             version <- utils::packageVersion("future")
[17:41:53.182]                         }
[17:41:53.182]                         else {
[17:41:53.182]                           version <- NULL
[17:41:53.182]                         }
[17:41:53.182]                         if (!has_future || version < "1.8.0") {
[17:41:53.182]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:53.182]                             "", base::R.version$version.string), 
[17:41:53.182]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:53.182]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:53.182]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:53.182]                               "release", "version")], collapse = " "), 
[17:41:53.182]                             hostname = base::Sys.info()[["nodename"]])
[17:41:53.182]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:53.182]                             info)
[17:41:53.182]                           info <- base::paste(info, collapse = "; ")
[17:41:53.182]                           if (!has_future) {
[17:41:53.182]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:53.182]                               info)
[17:41:53.182]                           }
[17:41:53.182]                           else {
[17:41:53.182]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:53.182]                               info, version)
[17:41:53.182]                           }
[17:41:53.182]                           base::stop(msg)
[17:41:53.182]                         }
[17:41:53.182]                       })
[17:41:53.182]                     }
[17:41:53.182]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:53.182]                     base::options(mc.cores = 1L)
[17:41:53.182]                   }
[17:41:53.182]                   options(future.plan = NULL)
[17:41:53.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:53.182]                 }
[17:41:53.182]                 ...future.workdir <- getwd()
[17:41:53.182]             }
[17:41:53.182]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:53.182]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:53.182]         }
[17:41:53.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:53.182]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:53.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:53.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:53.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:53.182]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:53.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:53.182]             base::names(...future.oldOptions))
[17:41:53.182]     }
[17:41:53.182]     if (FALSE) {
[17:41:53.182]     }
[17:41:53.182]     else {
[17:41:53.182]         if (TRUE) {
[17:41:53.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:53.182]                 open = "w")
[17:41:53.182]         }
[17:41:53.182]         else {
[17:41:53.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:53.182]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:53.182]         }
[17:41:53.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:53.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:53.182]             base::sink(type = "output", split = FALSE)
[17:41:53.182]             base::close(...future.stdout)
[17:41:53.182]         }, add = TRUE)
[17:41:53.182]     }
[17:41:53.182]     ...future.frame <- base::sys.nframe()
[17:41:53.182]     ...future.conditions <- base::list()
[17:41:53.182]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:53.182]     if (FALSE) {
[17:41:53.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:53.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:53.182]     }
[17:41:53.182]     ...future.result <- base::tryCatch({
[17:41:53.182]         base::withCallingHandlers({
[17:41:53.182]             ...future.value <- base::withVisible(base::local({
[17:41:53.182]                 withCallingHandlers({
[17:41:53.182]                   {
[17:41:53.182]                     sum(x, y, ...)
[17:41:53.182]                   }
[17:41:53.182]                 }, immediateCondition = function(cond) {
[17:41:53.182]                   save_rds <- function (object, pathname, ...) 
[17:41:53.182]                   {
[17:41:53.182]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:53.182]                     if (file_test("-f", pathname_tmp)) {
[17:41:53.182]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.182]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:53.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.182]                         fi_tmp[["mtime"]])
[17:41:53.182]                     }
[17:41:53.182]                     tryCatch({
[17:41:53.182]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:53.182]                     }, error = function(ex) {
[17:41:53.182]                       msg <- conditionMessage(ex)
[17:41:53.182]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.182]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:53.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.182]                         fi_tmp[["mtime"]], msg)
[17:41:53.182]                       ex$message <- msg
[17:41:53.182]                       stop(ex)
[17:41:53.182]                     })
[17:41:53.182]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:53.182]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:53.182]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:53.182]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.182]                       fi <- file.info(pathname)
[17:41:53.182]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:53.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.182]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:53.182]                         fi[["size"]], fi[["mtime"]])
[17:41:53.182]                       stop(msg)
[17:41:53.182]                     }
[17:41:53.182]                     invisible(pathname)
[17:41:53.182]                   }
[17:41:53.182]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:53.182]                     rootPath = tempdir()) 
[17:41:53.182]                   {
[17:41:53.182]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:53.182]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:53.182]                       tmpdir = path, fileext = ".rds")
[17:41:53.182]                     save_rds(obj, file)
[17:41:53.182]                   }
[17:41:53.182]                   saveImmediateCondition(cond, path = "/tmp/RtmpDeYcUG/.future/immediateConditions")
[17:41:53.182]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.182]                   {
[17:41:53.182]                     inherits <- base::inherits
[17:41:53.182]                     invokeRestart <- base::invokeRestart
[17:41:53.182]                     is.null <- base::is.null
[17:41:53.182]                     muffled <- FALSE
[17:41:53.182]                     if (inherits(cond, "message")) {
[17:41:53.182]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:53.182]                       if (muffled) 
[17:41:53.182]                         invokeRestart("muffleMessage")
[17:41:53.182]                     }
[17:41:53.182]                     else if (inherits(cond, "warning")) {
[17:41:53.182]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:53.182]                       if (muffled) 
[17:41:53.182]                         invokeRestart("muffleWarning")
[17:41:53.182]                     }
[17:41:53.182]                     else if (inherits(cond, "condition")) {
[17:41:53.182]                       if (!is.null(pattern)) {
[17:41:53.182]                         computeRestarts <- base::computeRestarts
[17:41:53.182]                         grepl <- base::grepl
[17:41:53.182]                         restarts <- computeRestarts(cond)
[17:41:53.182]                         for (restart in restarts) {
[17:41:53.182]                           name <- restart$name
[17:41:53.182]                           if (is.null(name)) 
[17:41:53.182]                             next
[17:41:53.182]                           if (!grepl(pattern, name)) 
[17:41:53.182]                             next
[17:41:53.182]                           invokeRestart(restart)
[17:41:53.182]                           muffled <- TRUE
[17:41:53.182]                           break
[17:41:53.182]                         }
[17:41:53.182]                       }
[17:41:53.182]                     }
[17:41:53.182]                     invisible(muffled)
[17:41:53.182]                   }
[17:41:53.182]                   muffleCondition(cond)
[17:41:53.182]                 })
[17:41:53.182]             }))
[17:41:53.182]             future::FutureResult(value = ...future.value$value, 
[17:41:53.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.182]                   ...future.rng), globalenv = if (FALSE) 
[17:41:53.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:53.182]                     ...future.globalenv.names))
[17:41:53.182]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:53.182]         }, condition = base::local({
[17:41:53.182]             c <- base::c
[17:41:53.182]             inherits <- base::inherits
[17:41:53.182]             invokeRestart <- base::invokeRestart
[17:41:53.182]             length <- base::length
[17:41:53.182]             list <- base::list
[17:41:53.182]             seq.int <- base::seq.int
[17:41:53.182]             signalCondition <- base::signalCondition
[17:41:53.182]             sys.calls <- base::sys.calls
[17:41:53.182]             `[[` <- base::`[[`
[17:41:53.182]             `+` <- base::`+`
[17:41:53.182]             `<<-` <- base::`<<-`
[17:41:53.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:53.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:53.182]                   3L)]
[17:41:53.182]             }
[17:41:53.182]             function(cond) {
[17:41:53.182]                 is_error <- inherits(cond, "error")
[17:41:53.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:53.182]                   NULL)
[17:41:53.182]                 if (is_error) {
[17:41:53.182]                   sessionInformation <- function() {
[17:41:53.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:53.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:53.182]                       search = base::search(), system = base::Sys.info())
[17:41:53.182]                   }
[17:41:53.182]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:53.182]                     cond$call), session = sessionInformation(), 
[17:41:53.182]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:53.182]                   signalCondition(cond)
[17:41:53.182]                 }
[17:41:53.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:53.182]                 "immediateCondition"))) {
[17:41:53.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:53.182]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:53.182]                   if (TRUE && !signal) {
[17:41:53.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.182]                     {
[17:41:53.182]                       inherits <- base::inherits
[17:41:53.182]                       invokeRestart <- base::invokeRestart
[17:41:53.182]                       is.null <- base::is.null
[17:41:53.182]                       muffled <- FALSE
[17:41:53.182]                       if (inherits(cond, "message")) {
[17:41:53.182]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.182]                         if (muffled) 
[17:41:53.182]                           invokeRestart("muffleMessage")
[17:41:53.182]                       }
[17:41:53.182]                       else if (inherits(cond, "warning")) {
[17:41:53.182]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.182]                         if (muffled) 
[17:41:53.182]                           invokeRestart("muffleWarning")
[17:41:53.182]                       }
[17:41:53.182]                       else if (inherits(cond, "condition")) {
[17:41:53.182]                         if (!is.null(pattern)) {
[17:41:53.182]                           computeRestarts <- base::computeRestarts
[17:41:53.182]                           grepl <- base::grepl
[17:41:53.182]                           restarts <- computeRestarts(cond)
[17:41:53.182]                           for (restart in restarts) {
[17:41:53.182]                             name <- restart$name
[17:41:53.182]                             if (is.null(name)) 
[17:41:53.182]                               next
[17:41:53.182]                             if (!grepl(pattern, name)) 
[17:41:53.182]                               next
[17:41:53.182]                             invokeRestart(restart)
[17:41:53.182]                             muffled <- TRUE
[17:41:53.182]                             break
[17:41:53.182]                           }
[17:41:53.182]                         }
[17:41:53.182]                       }
[17:41:53.182]                       invisible(muffled)
[17:41:53.182]                     }
[17:41:53.182]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.182]                   }
[17:41:53.182]                 }
[17:41:53.182]                 else {
[17:41:53.182]                   if (TRUE) {
[17:41:53.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.182]                     {
[17:41:53.182]                       inherits <- base::inherits
[17:41:53.182]                       invokeRestart <- base::invokeRestart
[17:41:53.182]                       is.null <- base::is.null
[17:41:53.182]                       muffled <- FALSE
[17:41:53.182]                       if (inherits(cond, "message")) {
[17:41:53.182]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.182]                         if (muffled) 
[17:41:53.182]                           invokeRestart("muffleMessage")
[17:41:53.182]                       }
[17:41:53.182]                       else if (inherits(cond, "warning")) {
[17:41:53.182]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.182]                         if (muffled) 
[17:41:53.182]                           invokeRestart("muffleWarning")
[17:41:53.182]                       }
[17:41:53.182]                       else if (inherits(cond, "condition")) {
[17:41:53.182]                         if (!is.null(pattern)) {
[17:41:53.182]                           computeRestarts <- base::computeRestarts
[17:41:53.182]                           grepl <- base::grepl
[17:41:53.182]                           restarts <- computeRestarts(cond)
[17:41:53.182]                           for (restart in restarts) {
[17:41:53.182]                             name <- restart$name
[17:41:53.182]                             if (is.null(name)) 
[17:41:53.182]                               next
[17:41:53.182]                             if (!grepl(pattern, name)) 
[17:41:53.182]                               next
[17:41:53.182]                             invokeRestart(restart)
[17:41:53.182]                             muffled <- TRUE
[17:41:53.182]                             break
[17:41:53.182]                           }
[17:41:53.182]                         }
[17:41:53.182]                       }
[17:41:53.182]                       invisible(muffled)
[17:41:53.182]                     }
[17:41:53.182]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.182]                   }
[17:41:53.182]                 }
[17:41:53.182]             }
[17:41:53.182]         }))
[17:41:53.182]     }, error = function(ex) {
[17:41:53.182]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:53.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.182]                 ...future.rng), started = ...future.startTime, 
[17:41:53.182]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:53.182]             version = "1.8"), class = "FutureResult")
[17:41:53.182]     }, finally = {
[17:41:53.182]         if (!identical(...future.workdir, getwd())) 
[17:41:53.182]             setwd(...future.workdir)
[17:41:53.182]         {
[17:41:53.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:53.182]                 ...future.oldOptions$nwarnings <- NULL
[17:41:53.182]             }
[17:41:53.182]             base::options(...future.oldOptions)
[17:41:53.182]             if (.Platform$OS.type == "windows") {
[17:41:53.182]                 old_names <- names(...future.oldEnvVars)
[17:41:53.182]                 envs <- base::Sys.getenv()
[17:41:53.182]                 names <- names(envs)
[17:41:53.182]                 common <- intersect(names, old_names)
[17:41:53.182]                 added <- setdiff(names, old_names)
[17:41:53.182]                 removed <- setdiff(old_names, names)
[17:41:53.182]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:53.182]                   envs[common]]
[17:41:53.182]                 NAMES <- toupper(changed)
[17:41:53.182]                 args <- list()
[17:41:53.182]                 for (kk in seq_along(NAMES)) {
[17:41:53.182]                   name <- changed[[kk]]
[17:41:53.182]                   NAME <- NAMES[[kk]]
[17:41:53.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.182]                     next
[17:41:53.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.182]                 }
[17:41:53.182]                 NAMES <- toupper(added)
[17:41:53.182]                 for (kk in seq_along(NAMES)) {
[17:41:53.182]                   name <- added[[kk]]
[17:41:53.182]                   NAME <- NAMES[[kk]]
[17:41:53.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.182]                     next
[17:41:53.182]                   args[[name]] <- ""
[17:41:53.182]                 }
[17:41:53.182]                 NAMES <- toupper(removed)
[17:41:53.182]                 for (kk in seq_along(NAMES)) {
[17:41:53.182]                   name <- removed[[kk]]
[17:41:53.182]                   NAME <- NAMES[[kk]]
[17:41:53.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.182]                     next
[17:41:53.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.182]                 }
[17:41:53.182]                 if (length(args) > 0) 
[17:41:53.182]                   base::do.call(base::Sys.setenv, args = args)
[17:41:53.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:53.182]             }
[17:41:53.182]             else {
[17:41:53.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:53.182]             }
[17:41:53.182]             {
[17:41:53.182]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:53.182]                   0L) {
[17:41:53.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:53.182]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:53.182]                   base::options(opts)
[17:41:53.182]                 }
[17:41:53.182]                 {
[17:41:53.182]                   {
[17:41:53.182]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:53.182]                     NULL
[17:41:53.182]                   }
[17:41:53.182]                   options(future.plan = NULL)
[17:41:53.182]                   if (is.na(NA_character_)) 
[17:41:53.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:53.182]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:53.182]                     envir = parent.frame()) 
[17:41:53.182]                   {
[17:41:53.182]                     default_workers <- missing(workers)
[17:41:53.182]                     if (is.function(workers)) 
[17:41:53.182]                       workers <- workers()
[17:41:53.182]                     workers <- structure(as.integer(workers), 
[17:41:53.182]                       class = class(workers))
[17:41:53.182]                     stop_if_not(is.finite(workers), workers >= 
[17:41:53.182]                       1L)
[17:41:53.182]                     if ((workers == 1L && !inherits(workers, 
[17:41:53.182]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:53.182]                       if (default_workers) 
[17:41:53.182]                         supportsMulticore(warn = TRUE)
[17:41:53.182]                       return(sequential(..., envir = envir))
[17:41:53.182]                     }
[17:41:53.182]                     oopts <- options(mc.cores = workers)
[17:41:53.182]                     on.exit(options(oopts))
[17:41:53.182]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:53.182]                       envir = envir)
[17:41:53.182]                     if (!future$lazy) 
[17:41:53.182]                       future <- run(future)
[17:41:53.182]                     invisible(future)
[17:41:53.182]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:53.182]                 }
[17:41:53.182]             }
[17:41:53.182]         }
[17:41:53.182]     })
[17:41:53.182]     if (TRUE) {
[17:41:53.182]         base::sink(type = "output", split = FALSE)
[17:41:53.182]         if (TRUE) {
[17:41:53.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:53.182]         }
[17:41:53.182]         else {
[17:41:53.182]             ...future.result["stdout"] <- base::list(NULL)
[17:41:53.182]         }
[17:41:53.182]         base::close(...future.stdout)
[17:41:53.182]         ...future.stdout <- NULL
[17:41:53.182]     }
[17:41:53.182]     ...future.result$conditions <- ...future.conditions
[17:41:53.182]     ...future.result$finished <- base::Sys.time()
[17:41:53.182]     ...future.result
[17:41:53.182] }
[17:41:53.184] assign_globals() ...
[17:41:53.184] List of 2
[17:41:53.184]  $ x: int [1:2] 1 2
[17:41:53.184]  $ y: num 3
[17:41:53.184]  - attr(*, "where")=List of 2
[17:41:53.184]   ..$ x:<environment: R_EmptyEnv> 
[17:41:53.184]   ..$ y:<environment: R_EmptyEnv> 
[17:41:53.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:53.184]  - attr(*, "resolved")= logi FALSE
[17:41:53.184]  - attr(*, "total_size")= num 112
[17:41:53.184]  - attr(*, "already-done")= logi TRUE
[17:41:53.188] - copied ‘x’ to environment
[17:41:53.188] - copied ‘y’ to environment
[17:41:53.188] assign_globals() ... done
[17:41:53.189] requestCore(): workers = 2
[17:41:53.191] MulticoreFuture started
[17:41:53.191] - Launch lazy future ... done
[17:41:53.191] run() for ‘MulticoreFuture’ ... done
[17:41:53.192] plan(): Setting new future strategy stack:
[17:41:53.192] List of future strategies:
[17:41:53.192] 1. sequential:
[17:41:53.192]    - args: function (..., envir = parent.frame())
[17:41:53.192]    - tweaked: FALSE
[17:41:53.192]    - call: NULL
[17:41:53.193] plan(): nbrOfWorkers() = 1
[17:41:53.195] plan(): Setting new future strategy stack:
[17:41:53.195] List of future strategies:
[17:41:53.195] 1. multicore:
[17:41:53.195]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:53.195]    - tweaked: FALSE
[17:41:53.195]    - call: plan(strategy, substitute = FALSE)
[17:41:53.201] plan(): nbrOfWorkers() = 2
[17:41:53.207] signalConditions() ...
[17:41:53.207]  - include = ‘immediateCondition’
[17:41:53.207]  - exclude = 
[17:41:53.207]  - resignal = FALSE
[17:41:53.207]  - Number of conditions: 1
[17:41:53.208] signalConditions() ... done
[17:41:53.208] signalConditions() ...
[17:41:53.208]  - include = ‘immediateCondition’
[17:41:53.208]  - exclude = 
[17:41:53.208]  - resignal = FALSE
[17:41:53.208]  - Number of conditions: 1
[17:41:53.208] signalConditions() ... done
[17:41:53.209] Future state: ‘finished’
[17:41:53.209] signalConditions() ...
[17:41:53.209]  - include = ‘condition’
[17:41:53.209]  - exclude = ‘immediateCondition’
[17:41:53.209]  - resignal = TRUE
[17:41:53.209]  - Number of conditions: 1
[17:41:53.209]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:41:53.209] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpDeYcUG/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multicore') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x55bfdac31dd0>
Arguments '...' exists: TRUE
[17:41:53.211] getGlobalsAndPackages() ...
[17:41:53.211] - globals passed as-is: [1] ‘...’
[17:41:53.211] Resolving globals: FALSE
[17:41:53.211] Tweak future expression to call with '...' arguments ...
[17:41:53.211] {
[17:41:53.211]     do.call(function(...) {
[17:41:53.211]         fcn <- function() sum(...)
[17:41:53.211]         fcn()
[17:41:53.211]     }, args = future.call.arguments)
[17:41:53.211] }
[17:41:53.212] Tweak future expression to call with '...' arguments ... DONE
[17:41:53.212] The total size of the 1 globals is 112 bytes (112 bytes)
[17:41:53.213] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[17:41:53.213] - globals: [1] ‘future.call.arguments’
[17:41:53.213] 
[17:41:53.213] getGlobalsAndPackages() ... DONE
[17:41:53.214] run() for ‘Future’ ...
[17:41:53.214] - state: ‘created’
[17:41:53.214] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:53.218] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:53.218] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:53.219]   - Field: ‘label’
[17:41:53.219]   - Field: ‘local’
[17:41:53.219]   - Field: ‘owner’
[17:41:53.219]   - Field: ‘envir’
[17:41:53.219]   - Field: ‘workers’
[17:41:53.219]   - Field: ‘packages’
[17:41:53.219]   - Field: ‘gc’
[17:41:53.220]   - Field: ‘job’
[17:41:53.220]   - Field: ‘conditions’
[17:41:53.220]   - Field: ‘expr’
[17:41:53.220]   - Field: ‘uuid’
[17:41:53.220]   - Field: ‘seed’
[17:41:53.220]   - Field: ‘version’
[17:41:53.220]   - Field: ‘result’
[17:41:53.220]   - Field: ‘asynchronous’
[17:41:53.220]   - Field: ‘calls’
[17:41:53.221]   - Field: ‘globals’
[17:41:53.221]   - Field: ‘stdout’
[17:41:53.221]   - Field: ‘earlySignal’
[17:41:53.221]   - Field: ‘lazy’
[17:41:53.221]   - Field: ‘state’
[17:41:53.221] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:53.221] - Launch lazy future ...
[17:41:53.222] Packages needed by the future expression (n = 0): <none>
[17:41:53.222] Packages needed by future strategies (n = 0): <none>
[17:41:53.222] {
[17:41:53.222]     {
[17:41:53.222]         {
[17:41:53.222]             ...future.startTime <- base::Sys.time()
[17:41:53.222]             {
[17:41:53.222]                 {
[17:41:53.222]                   {
[17:41:53.222]                     {
[17:41:53.222]                       base::local({
[17:41:53.222]                         has_future <- base::requireNamespace("future", 
[17:41:53.222]                           quietly = TRUE)
[17:41:53.222]                         if (has_future) {
[17:41:53.222]                           ns <- base::getNamespace("future")
[17:41:53.222]                           version <- ns[[".package"]][["version"]]
[17:41:53.222]                           if (is.null(version)) 
[17:41:53.222]                             version <- utils::packageVersion("future")
[17:41:53.222]                         }
[17:41:53.222]                         else {
[17:41:53.222]                           version <- NULL
[17:41:53.222]                         }
[17:41:53.222]                         if (!has_future || version < "1.8.0") {
[17:41:53.222]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:53.222]                             "", base::R.version$version.string), 
[17:41:53.222]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:53.222]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:53.222]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:53.222]                               "release", "version")], collapse = " "), 
[17:41:53.222]                             hostname = base::Sys.info()[["nodename"]])
[17:41:53.222]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:53.222]                             info)
[17:41:53.222]                           info <- base::paste(info, collapse = "; ")
[17:41:53.222]                           if (!has_future) {
[17:41:53.222]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:53.222]                               info)
[17:41:53.222]                           }
[17:41:53.222]                           else {
[17:41:53.222]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:53.222]                               info, version)
[17:41:53.222]                           }
[17:41:53.222]                           base::stop(msg)
[17:41:53.222]                         }
[17:41:53.222]                       })
[17:41:53.222]                     }
[17:41:53.222]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:53.222]                     base::options(mc.cores = 1L)
[17:41:53.222]                   }
[17:41:53.222]                   options(future.plan = NULL)
[17:41:53.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.222]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:53.222]                 }
[17:41:53.222]                 ...future.workdir <- getwd()
[17:41:53.222]             }
[17:41:53.222]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:53.222]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:53.222]         }
[17:41:53.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:53.222]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:53.222]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:53.222]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:53.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:53.222]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:53.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:53.222]             base::names(...future.oldOptions))
[17:41:53.222]     }
[17:41:53.222]     if (FALSE) {
[17:41:53.222]     }
[17:41:53.222]     else {
[17:41:53.222]         if (TRUE) {
[17:41:53.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:53.222]                 open = "w")
[17:41:53.222]         }
[17:41:53.222]         else {
[17:41:53.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:53.222]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:53.222]         }
[17:41:53.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:53.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:53.222]             base::sink(type = "output", split = FALSE)
[17:41:53.222]             base::close(...future.stdout)
[17:41:53.222]         }, add = TRUE)
[17:41:53.222]     }
[17:41:53.222]     ...future.frame <- base::sys.nframe()
[17:41:53.222]     ...future.conditions <- base::list()
[17:41:53.222]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:53.222]     if (FALSE) {
[17:41:53.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:53.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:53.222]     }
[17:41:53.222]     ...future.result <- base::tryCatch({
[17:41:53.222]         base::withCallingHandlers({
[17:41:53.222]             ...future.value <- base::withVisible(base::local({
[17:41:53.222]                 withCallingHandlers({
[17:41:53.222]                   {
[17:41:53.222]                     do.call(function(...) {
[17:41:53.222]                       fcn <- function() sum(...)
[17:41:53.222]                       fcn()
[17:41:53.222]                     }, args = future.call.arguments)
[17:41:53.222]                   }
[17:41:53.222]                 }, immediateCondition = function(cond) {
[17:41:53.222]                   save_rds <- function (object, pathname, ...) 
[17:41:53.222]                   {
[17:41:53.222]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:53.222]                     if (file_test("-f", pathname_tmp)) {
[17:41:53.222]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.222]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:53.222]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.222]                         fi_tmp[["mtime"]])
[17:41:53.222]                     }
[17:41:53.222]                     tryCatch({
[17:41:53.222]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:53.222]                     }, error = function(ex) {
[17:41:53.222]                       msg <- conditionMessage(ex)
[17:41:53.222]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.222]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:53.222]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.222]                         fi_tmp[["mtime"]], msg)
[17:41:53.222]                       ex$message <- msg
[17:41:53.222]                       stop(ex)
[17:41:53.222]                     })
[17:41:53.222]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:53.222]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:53.222]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:53.222]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.222]                       fi <- file.info(pathname)
[17:41:53.222]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:53.222]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.222]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:53.222]                         fi[["size"]], fi[["mtime"]])
[17:41:53.222]                       stop(msg)
[17:41:53.222]                     }
[17:41:53.222]                     invisible(pathname)
[17:41:53.222]                   }
[17:41:53.222]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:53.222]                     rootPath = tempdir()) 
[17:41:53.222]                   {
[17:41:53.222]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:53.222]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:53.222]                       tmpdir = path, fileext = ".rds")
[17:41:53.222]                     save_rds(obj, file)
[17:41:53.222]                   }
[17:41:53.222]                   saveImmediateCondition(cond, path = "/tmp/RtmpDeYcUG/.future/immediateConditions")
[17:41:53.222]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.222]                   {
[17:41:53.222]                     inherits <- base::inherits
[17:41:53.222]                     invokeRestart <- base::invokeRestart
[17:41:53.222]                     is.null <- base::is.null
[17:41:53.222]                     muffled <- FALSE
[17:41:53.222]                     if (inherits(cond, "message")) {
[17:41:53.222]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:53.222]                       if (muffled) 
[17:41:53.222]                         invokeRestart("muffleMessage")
[17:41:53.222]                     }
[17:41:53.222]                     else if (inherits(cond, "warning")) {
[17:41:53.222]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:53.222]                       if (muffled) 
[17:41:53.222]                         invokeRestart("muffleWarning")
[17:41:53.222]                     }
[17:41:53.222]                     else if (inherits(cond, "condition")) {
[17:41:53.222]                       if (!is.null(pattern)) {
[17:41:53.222]                         computeRestarts <- base::computeRestarts
[17:41:53.222]                         grepl <- base::grepl
[17:41:53.222]                         restarts <- computeRestarts(cond)
[17:41:53.222]                         for (restart in restarts) {
[17:41:53.222]                           name <- restart$name
[17:41:53.222]                           if (is.null(name)) 
[17:41:53.222]                             next
[17:41:53.222]                           if (!grepl(pattern, name)) 
[17:41:53.222]                             next
[17:41:53.222]                           invokeRestart(restart)
[17:41:53.222]                           muffled <- TRUE
[17:41:53.222]                           break
[17:41:53.222]                         }
[17:41:53.222]                       }
[17:41:53.222]                     }
[17:41:53.222]                     invisible(muffled)
[17:41:53.222]                   }
[17:41:53.222]                   muffleCondition(cond)
[17:41:53.222]                 })
[17:41:53.222]             }))
[17:41:53.222]             future::FutureResult(value = ...future.value$value, 
[17:41:53.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.222]                   ...future.rng), globalenv = if (FALSE) 
[17:41:53.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:53.222]                     ...future.globalenv.names))
[17:41:53.222]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:53.222]         }, condition = base::local({
[17:41:53.222]             c <- base::c
[17:41:53.222]             inherits <- base::inherits
[17:41:53.222]             invokeRestart <- base::invokeRestart
[17:41:53.222]             length <- base::length
[17:41:53.222]             list <- base::list
[17:41:53.222]             seq.int <- base::seq.int
[17:41:53.222]             signalCondition <- base::signalCondition
[17:41:53.222]             sys.calls <- base::sys.calls
[17:41:53.222]             `[[` <- base::`[[`
[17:41:53.222]             `+` <- base::`+`
[17:41:53.222]             `<<-` <- base::`<<-`
[17:41:53.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:53.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:53.222]                   3L)]
[17:41:53.222]             }
[17:41:53.222]             function(cond) {
[17:41:53.222]                 is_error <- inherits(cond, "error")
[17:41:53.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:53.222]                   NULL)
[17:41:53.222]                 if (is_error) {
[17:41:53.222]                   sessionInformation <- function() {
[17:41:53.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:53.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:53.222]                       search = base::search(), system = base::Sys.info())
[17:41:53.222]                   }
[17:41:53.222]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:53.222]                     cond$call), session = sessionInformation(), 
[17:41:53.222]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:53.222]                   signalCondition(cond)
[17:41:53.222]                 }
[17:41:53.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:53.222]                 "immediateCondition"))) {
[17:41:53.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:53.222]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:53.222]                   if (TRUE && !signal) {
[17:41:53.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.222]                     {
[17:41:53.222]                       inherits <- base::inherits
[17:41:53.222]                       invokeRestart <- base::invokeRestart
[17:41:53.222]                       is.null <- base::is.null
[17:41:53.222]                       muffled <- FALSE
[17:41:53.222]                       if (inherits(cond, "message")) {
[17:41:53.222]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.222]                         if (muffled) 
[17:41:53.222]                           invokeRestart("muffleMessage")
[17:41:53.222]                       }
[17:41:53.222]                       else if (inherits(cond, "warning")) {
[17:41:53.222]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.222]                         if (muffled) 
[17:41:53.222]                           invokeRestart("muffleWarning")
[17:41:53.222]                       }
[17:41:53.222]                       else if (inherits(cond, "condition")) {
[17:41:53.222]                         if (!is.null(pattern)) {
[17:41:53.222]                           computeRestarts <- base::computeRestarts
[17:41:53.222]                           grepl <- base::grepl
[17:41:53.222]                           restarts <- computeRestarts(cond)
[17:41:53.222]                           for (restart in restarts) {
[17:41:53.222]                             name <- restart$name
[17:41:53.222]                             if (is.null(name)) 
[17:41:53.222]                               next
[17:41:53.222]                             if (!grepl(pattern, name)) 
[17:41:53.222]                               next
[17:41:53.222]                             invokeRestart(restart)
[17:41:53.222]                             muffled <- TRUE
[17:41:53.222]                             break
[17:41:53.222]                           }
[17:41:53.222]                         }
[17:41:53.222]                       }
[17:41:53.222]                       invisible(muffled)
[17:41:53.222]                     }
[17:41:53.222]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.222]                   }
[17:41:53.222]                 }
[17:41:53.222]                 else {
[17:41:53.222]                   if (TRUE) {
[17:41:53.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.222]                     {
[17:41:53.222]                       inherits <- base::inherits
[17:41:53.222]                       invokeRestart <- base::invokeRestart
[17:41:53.222]                       is.null <- base::is.null
[17:41:53.222]                       muffled <- FALSE
[17:41:53.222]                       if (inherits(cond, "message")) {
[17:41:53.222]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.222]                         if (muffled) 
[17:41:53.222]                           invokeRestart("muffleMessage")
[17:41:53.222]                       }
[17:41:53.222]                       else if (inherits(cond, "warning")) {
[17:41:53.222]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.222]                         if (muffled) 
[17:41:53.222]                           invokeRestart("muffleWarning")
[17:41:53.222]                       }
[17:41:53.222]                       else if (inherits(cond, "condition")) {
[17:41:53.222]                         if (!is.null(pattern)) {
[17:41:53.222]                           computeRestarts <- base::computeRestarts
[17:41:53.222]                           grepl <- base::grepl
[17:41:53.222]                           restarts <- computeRestarts(cond)
[17:41:53.222]                           for (restart in restarts) {
[17:41:53.222]                             name <- restart$name
[17:41:53.222]                             if (is.null(name)) 
[17:41:53.222]                               next
[17:41:53.222]                             if (!grepl(pattern, name)) 
[17:41:53.222]                               next
[17:41:53.222]                             invokeRestart(restart)
[17:41:53.222]                             muffled <- TRUE
[17:41:53.222]                             break
[17:41:53.222]                           }
[17:41:53.222]                         }
[17:41:53.222]                       }
[17:41:53.222]                       invisible(muffled)
[17:41:53.222]                     }
[17:41:53.222]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.222]                   }
[17:41:53.222]                 }
[17:41:53.222]             }
[17:41:53.222]         }))
[17:41:53.222]     }, error = function(ex) {
[17:41:53.222]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:53.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.222]                 ...future.rng), started = ...future.startTime, 
[17:41:53.222]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:53.222]             version = "1.8"), class = "FutureResult")
[17:41:53.222]     }, finally = {
[17:41:53.222]         if (!identical(...future.workdir, getwd())) 
[17:41:53.222]             setwd(...future.workdir)
[17:41:53.222]         {
[17:41:53.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:53.222]                 ...future.oldOptions$nwarnings <- NULL
[17:41:53.222]             }
[17:41:53.222]             base::options(...future.oldOptions)
[17:41:53.222]             if (.Platform$OS.type == "windows") {
[17:41:53.222]                 old_names <- names(...future.oldEnvVars)
[17:41:53.222]                 envs <- base::Sys.getenv()
[17:41:53.222]                 names <- names(envs)
[17:41:53.222]                 common <- intersect(names, old_names)
[17:41:53.222]                 added <- setdiff(names, old_names)
[17:41:53.222]                 removed <- setdiff(old_names, names)
[17:41:53.222]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:53.222]                   envs[common]]
[17:41:53.222]                 NAMES <- toupper(changed)
[17:41:53.222]                 args <- list()
[17:41:53.222]                 for (kk in seq_along(NAMES)) {
[17:41:53.222]                   name <- changed[[kk]]
[17:41:53.222]                   NAME <- NAMES[[kk]]
[17:41:53.222]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.222]                     next
[17:41:53.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.222]                 }
[17:41:53.222]                 NAMES <- toupper(added)
[17:41:53.222]                 for (kk in seq_along(NAMES)) {
[17:41:53.222]                   name <- added[[kk]]
[17:41:53.222]                   NAME <- NAMES[[kk]]
[17:41:53.222]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.222]                     next
[17:41:53.222]                   args[[name]] <- ""
[17:41:53.222]                 }
[17:41:53.222]                 NAMES <- toupper(removed)
[17:41:53.222]                 for (kk in seq_along(NAMES)) {
[17:41:53.222]                   name <- removed[[kk]]
[17:41:53.222]                   NAME <- NAMES[[kk]]
[17:41:53.222]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.222]                     next
[17:41:53.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.222]                 }
[17:41:53.222]                 if (length(args) > 0) 
[17:41:53.222]                   base::do.call(base::Sys.setenv, args = args)
[17:41:53.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:53.222]             }
[17:41:53.222]             else {
[17:41:53.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:53.222]             }
[17:41:53.222]             {
[17:41:53.222]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:53.222]                   0L) {
[17:41:53.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:53.222]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:53.222]                   base::options(opts)
[17:41:53.222]                 }
[17:41:53.222]                 {
[17:41:53.222]                   {
[17:41:53.222]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:53.222]                     NULL
[17:41:53.222]                   }
[17:41:53.222]                   options(future.plan = NULL)
[17:41:53.222]                   if (is.na(NA_character_)) 
[17:41:53.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:53.222]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:53.222]                     envir = parent.frame()) 
[17:41:53.222]                   {
[17:41:53.222]                     default_workers <- missing(workers)
[17:41:53.222]                     if (is.function(workers)) 
[17:41:53.222]                       workers <- workers()
[17:41:53.222]                     workers <- structure(as.integer(workers), 
[17:41:53.222]                       class = class(workers))
[17:41:53.222]                     stop_if_not(is.finite(workers), workers >= 
[17:41:53.222]                       1L)
[17:41:53.222]                     if ((workers == 1L && !inherits(workers, 
[17:41:53.222]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:53.222]                       if (default_workers) 
[17:41:53.222]                         supportsMulticore(warn = TRUE)
[17:41:53.222]                       return(sequential(..., envir = envir))
[17:41:53.222]                     }
[17:41:53.222]                     oopts <- options(mc.cores = workers)
[17:41:53.222]                     on.exit(options(oopts))
[17:41:53.222]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:53.222]                       envir = envir)
[17:41:53.222]                     if (!future$lazy) 
[17:41:53.222]                       future <- run(future)
[17:41:53.222]                     invisible(future)
[17:41:53.222]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:53.222]                 }
[17:41:53.222]             }
[17:41:53.222]         }
[17:41:53.222]     })
[17:41:53.222]     if (TRUE) {
[17:41:53.222]         base::sink(type = "output", split = FALSE)
[17:41:53.222]         if (TRUE) {
[17:41:53.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:53.222]         }
[17:41:53.222]         else {
[17:41:53.222]             ...future.result["stdout"] <- base::list(NULL)
[17:41:53.222]         }
[17:41:53.222]         base::close(...future.stdout)
[17:41:53.222]         ...future.stdout <- NULL
[17:41:53.222]     }
[17:41:53.222]     ...future.result$conditions <- ...future.conditions
[17:41:53.222]     ...future.result$finished <- base::Sys.time()
[17:41:53.222]     ...future.result
[17:41:53.222] }
[17:41:53.225] assign_globals() ...
[17:41:53.225] List of 1
[17:41:53.225]  $ future.call.arguments:List of 2
[17:41:53.225]   ..$ : int [1:2] 1 2
[17:41:53.225]   ..$ : num 3
[17:41:53.225]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:53.225]  - attr(*, "where")=List of 1
[17:41:53.225]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:41:53.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:53.225]  - attr(*, "resolved")= logi FALSE
[17:41:53.225]  - attr(*, "total_size")= num 112
[17:41:53.225]  - attr(*, "already-done")= logi TRUE
[17:41:53.232] - copied ‘future.call.arguments’ to environment
[17:41:53.232] assign_globals() ... done
[17:41:53.232] requestCore(): workers = 2
[17:41:53.235] MulticoreFuture started
[17:41:53.235] - Launch lazy future ... done
[17:41:53.236] run() for ‘MulticoreFuture’ ... done
[17:41:53.236] plan(): Setting new future strategy stack:
[17:41:53.236] List of future strategies:
[17:41:53.236] 1. sequential:
[17:41:53.236]    - args: function (..., envir = parent.frame())
[17:41:53.236]    - tweaked: FALSE
[17:41:53.236]    - call: NULL
[17:41:53.237] plan(): nbrOfWorkers() = 1
[17:41:53.240] plan(): Setting new future strategy stack:
[17:41:53.240] List of future strategies:
[17:41:53.240] 1. multicore:
[17:41:53.240]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:53.240]    - tweaked: FALSE
[17:41:53.240]    - call: plan(strategy, substitute = FALSE)
[17:41:53.245] plan(): nbrOfWorkers() = 2
[1] 6
** Sum function 'F' with plan('multicore') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x55bfdb0ae0f8>
Using '...' in a formula
[17:41:53.247] getGlobalsAndPackages() ...
[17:41:53.247] Searching for globals...
[17:41:53.251] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[17:41:53.252] Searching for globals ... DONE
[17:41:53.252] Resolving globals: FALSE
[17:41:53.252] Tweak future expression to call with '...' arguments ...
[17:41:53.253] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[17:41:53.253] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:41:53.253] - globals: [3] ‘fcn’, ‘x’, ‘y’
[17:41:53.253] 
[17:41:53.254] getGlobalsAndPackages() ... DONE
[17:41:53.254] run() for ‘Future’ ...
[17:41:53.254] - state: ‘created’
[17:41:53.254] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:53.259] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:53.259] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:53.259]   - Field: ‘label’
[17:41:53.259]   - Field: ‘local’
[17:41:53.259]   - Field: ‘owner’
[17:41:53.260]   - Field: ‘envir’
[17:41:53.260]   - Field: ‘workers’
[17:41:53.260]   - Field: ‘packages’
[17:41:53.260]   - Field: ‘gc’
[17:41:53.260]   - Field: ‘job’
[17:41:53.260]   - Field: ‘conditions’
[17:41:53.260]   - Field: ‘expr’
[17:41:53.260]   - Field: ‘uuid’
[17:41:53.261]   - Field: ‘seed’
[17:41:53.261]   - Field: ‘version’
[17:41:53.261]   - Field: ‘result’
[17:41:53.261]   - Field: ‘asynchronous’
[17:41:53.261]   - Field: ‘calls’
[17:41:53.261]   - Field: ‘globals’
[17:41:53.261]   - Field: ‘stdout’
[17:41:53.261]   - Field: ‘earlySignal’
[17:41:53.261]   - Field: ‘lazy’
[17:41:53.262]   - Field: ‘state’
[17:41:53.262] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:53.262] - Launch lazy future ...
[17:41:53.262] Packages needed by the future expression (n = 0): <none>
[17:41:53.262] Packages needed by future strategies (n = 0): <none>
[17:41:53.263] {
[17:41:53.263]     {
[17:41:53.263]         {
[17:41:53.263]             ...future.startTime <- base::Sys.time()
[17:41:53.263]             {
[17:41:53.263]                 {
[17:41:53.263]                   {
[17:41:53.263]                     {
[17:41:53.263]                       base::local({
[17:41:53.263]                         has_future <- base::requireNamespace("future", 
[17:41:53.263]                           quietly = TRUE)
[17:41:53.263]                         if (has_future) {
[17:41:53.263]                           ns <- base::getNamespace("future")
[17:41:53.263]                           version <- ns[[".package"]][["version"]]
[17:41:53.263]                           if (is.null(version)) 
[17:41:53.263]                             version <- utils::packageVersion("future")
[17:41:53.263]                         }
[17:41:53.263]                         else {
[17:41:53.263]                           version <- NULL
[17:41:53.263]                         }
[17:41:53.263]                         if (!has_future || version < "1.8.0") {
[17:41:53.263]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:53.263]                             "", base::R.version$version.string), 
[17:41:53.263]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:53.263]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:53.263]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:53.263]                               "release", "version")], collapse = " "), 
[17:41:53.263]                             hostname = base::Sys.info()[["nodename"]])
[17:41:53.263]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:53.263]                             info)
[17:41:53.263]                           info <- base::paste(info, collapse = "; ")
[17:41:53.263]                           if (!has_future) {
[17:41:53.263]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:53.263]                               info)
[17:41:53.263]                           }
[17:41:53.263]                           else {
[17:41:53.263]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:53.263]                               info, version)
[17:41:53.263]                           }
[17:41:53.263]                           base::stop(msg)
[17:41:53.263]                         }
[17:41:53.263]                       })
[17:41:53.263]                     }
[17:41:53.263]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:53.263]                     base::options(mc.cores = 1L)
[17:41:53.263]                   }
[17:41:53.263]                   options(future.plan = NULL)
[17:41:53.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:53.263]                 }
[17:41:53.263]                 ...future.workdir <- getwd()
[17:41:53.263]             }
[17:41:53.263]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:53.263]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:53.263]         }
[17:41:53.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:53.263]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:53.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:53.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:53.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:53.263]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:53.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:53.263]             base::names(...future.oldOptions))
[17:41:53.263]     }
[17:41:53.263]     if (FALSE) {
[17:41:53.263]     }
[17:41:53.263]     else {
[17:41:53.263]         if (TRUE) {
[17:41:53.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:53.263]                 open = "w")
[17:41:53.263]         }
[17:41:53.263]         else {
[17:41:53.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:53.263]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:53.263]         }
[17:41:53.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:53.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:53.263]             base::sink(type = "output", split = FALSE)
[17:41:53.263]             base::close(...future.stdout)
[17:41:53.263]         }, add = TRUE)
[17:41:53.263]     }
[17:41:53.263]     ...future.frame <- base::sys.nframe()
[17:41:53.263]     ...future.conditions <- base::list()
[17:41:53.263]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:53.263]     if (FALSE) {
[17:41:53.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:53.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:53.263]     }
[17:41:53.263]     ...future.result <- base::tryCatch({
[17:41:53.263]         base::withCallingHandlers({
[17:41:53.263]             ...future.value <- base::withVisible(base::local({
[17:41:53.263]                 withCallingHandlers({
[17:41:53.263]                   fcn(x, y)
[17:41:53.263]                 }, immediateCondition = function(cond) {
[17:41:53.263]                   save_rds <- function (object, pathname, ...) 
[17:41:53.263]                   {
[17:41:53.263]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:53.263]                     if (file_test("-f", pathname_tmp)) {
[17:41:53.263]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.263]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:53.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.263]                         fi_tmp[["mtime"]])
[17:41:53.263]                     }
[17:41:53.263]                     tryCatch({
[17:41:53.263]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:53.263]                     }, error = function(ex) {
[17:41:53.263]                       msg <- conditionMessage(ex)
[17:41:53.263]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.263]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:53.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.263]                         fi_tmp[["mtime"]], msg)
[17:41:53.263]                       ex$message <- msg
[17:41:53.263]                       stop(ex)
[17:41:53.263]                     })
[17:41:53.263]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:53.263]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:53.263]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:53.263]                       fi_tmp <- file.info(pathname_tmp)
[17:41:53.263]                       fi <- file.info(pathname)
[17:41:53.263]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:53.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:53.263]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:53.263]                         fi[["size"]], fi[["mtime"]])
[17:41:53.263]                       stop(msg)
[17:41:53.263]                     }
[17:41:53.263]                     invisible(pathname)
[17:41:53.263]                   }
[17:41:53.263]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:53.263]                     rootPath = tempdir()) 
[17:41:53.263]                   {
[17:41:53.263]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:53.263]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:53.263]                       tmpdir = path, fileext = ".rds")
[17:41:53.263]                     save_rds(obj, file)
[17:41:53.263]                   }
[17:41:53.263]                   saveImmediateCondition(cond, path = "/tmp/RtmpDeYcUG/.future/immediateConditions")
[17:41:53.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.263]                   {
[17:41:53.263]                     inherits <- base::inherits
[17:41:53.263]                     invokeRestart <- base::invokeRestart
[17:41:53.263]                     is.null <- base::is.null
[17:41:53.263]                     muffled <- FALSE
[17:41:53.263]                     if (inherits(cond, "message")) {
[17:41:53.263]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:53.263]                       if (muffled) 
[17:41:53.263]                         invokeRestart("muffleMessage")
[17:41:53.263]                     }
[17:41:53.263]                     else if (inherits(cond, "warning")) {
[17:41:53.263]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:53.263]                       if (muffled) 
[17:41:53.263]                         invokeRestart("muffleWarning")
[17:41:53.263]                     }
[17:41:53.263]                     else if (inherits(cond, "condition")) {
[17:41:53.263]                       if (!is.null(pattern)) {
[17:41:53.263]                         computeRestarts <- base::computeRestarts
[17:41:53.263]                         grepl <- base::grepl
[17:41:53.263]                         restarts <- computeRestarts(cond)
[17:41:53.263]                         for (restart in restarts) {
[17:41:53.263]                           name <- restart$name
[17:41:53.263]                           if (is.null(name)) 
[17:41:53.263]                             next
[17:41:53.263]                           if (!grepl(pattern, name)) 
[17:41:53.263]                             next
[17:41:53.263]                           invokeRestart(restart)
[17:41:53.263]                           muffled <- TRUE
[17:41:53.263]                           break
[17:41:53.263]                         }
[17:41:53.263]                       }
[17:41:53.263]                     }
[17:41:53.263]                     invisible(muffled)
[17:41:53.263]                   }
[17:41:53.263]                   muffleCondition(cond)
[17:41:53.263]                 })
[17:41:53.263]             }))
[17:41:53.263]             future::FutureResult(value = ...future.value$value, 
[17:41:53.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.263]                   ...future.rng), globalenv = if (FALSE) 
[17:41:53.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:53.263]                     ...future.globalenv.names))
[17:41:53.263]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:53.263]         }, condition = base::local({
[17:41:53.263]             c <- base::c
[17:41:53.263]             inherits <- base::inherits
[17:41:53.263]             invokeRestart <- base::invokeRestart
[17:41:53.263]             length <- base::length
[17:41:53.263]             list <- base::list
[17:41:53.263]             seq.int <- base::seq.int
[17:41:53.263]             signalCondition <- base::signalCondition
[17:41:53.263]             sys.calls <- base::sys.calls
[17:41:53.263]             `[[` <- base::`[[`
[17:41:53.263]             `+` <- base::`+`
[17:41:53.263]             `<<-` <- base::`<<-`
[17:41:53.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:53.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:53.263]                   3L)]
[17:41:53.263]             }
[17:41:53.263]             function(cond) {
[17:41:53.263]                 is_error <- inherits(cond, "error")
[17:41:53.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:53.263]                   NULL)
[17:41:53.263]                 if (is_error) {
[17:41:53.263]                   sessionInformation <- function() {
[17:41:53.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:53.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:53.263]                       search = base::search(), system = base::Sys.info())
[17:41:53.263]                   }
[17:41:53.263]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:53.263]                     cond$call), session = sessionInformation(), 
[17:41:53.263]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:53.263]                   signalCondition(cond)
[17:41:53.263]                 }
[17:41:53.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:53.263]                 "immediateCondition"))) {
[17:41:53.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:53.263]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:53.263]                   if (TRUE && !signal) {
[17:41:53.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.263]                     {
[17:41:53.263]                       inherits <- base::inherits
[17:41:53.263]                       invokeRestart <- base::invokeRestart
[17:41:53.263]                       is.null <- base::is.null
[17:41:53.263]                       muffled <- FALSE
[17:41:53.263]                       if (inherits(cond, "message")) {
[17:41:53.263]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.263]                         if (muffled) 
[17:41:53.263]                           invokeRestart("muffleMessage")
[17:41:53.263]                       }
[17:41:53.263]                       else if (inherits(cond, "warning")) {
[17:41:53.263]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.263]                         if (muffled) 
[17:41:53.263]                           invokeRestart("muffleWarning")
[17:41:53.263]                       }
[17:41:53.263]                       else if (inherits(cond, "condition")) {
[17:41:53.263]                         if (!is.null(pattern)) {
[17:41:53.263]                           computeRestarts <- base::computeRestarts
[17:41:53.263]                           grepl <- base::grepl
[17:41:53.263]                           restarts <- computeRestarts(cond)
[17:41:53.263]                           for (restart in restarts) {
[17:41:53.263]                             name <- restart$name
[17:41:53.263]                             if (is.null(name)) 
[17:41:53.263]                               next
[17:41:53.263]                             if (!grepl(pattern, name)) 
[17:41:53.263]                               next
[17:41:53.263]                             invokeRestart(restart)
[17:41:53.263]                             muffled <- TRUE
[17:41:53.263]                             break
[17:41:53.263]                           }
[17:41:53.263]                         }
[17:41:53.263]                       }
[17:41:53.263]                       invisible(muffled)
[17:41:53.263]                     }
[17:41:53.263]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.263]                   }
[17:41:53.263]                 }
[17:41:53.263]                 else {
[17:41:53.263]                   if (TRUE) {
[17:41:53.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.263]                     {
[17:41:53.263]                       inherits <- base::inherits
[17:41:53.263]                       invokeRestart <- base::invokeRestart
[17:41:53.263]                       is.null <- base::is.null
[17:41:53.263]                       muffled <- FALSE
[17:41:53.263]                       if (inherits(cond, "message")) {
[17:41:53.263]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.263]                         if (muffled) 
[17:41:53.263]                           invokeRestart("muffleMessage")
[17:41:53.263]                       }
[17:41:53.263]                       else if (inherits(cond, "warning")) {
[17:41:53.263]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.263]                         if (muffled) 
[17:41:53.263]                           invokeRestart("muffleWarning")
[17:41:53.263]                       }
[17:41:53.263]                       else if (inherits(cond, "condition")) {
[17:41:53.263]                         if (!is.null(pattern)) {
[17:41:53.263]                           computeRestarts <- base::computeRestarts
[17:41:53.263]                           grepl <- base::grepl
[17:41:53.263]                           restarts <- computeRestarts(cond)
[17:41:53.263]                           for (restart in restarts) {
[17:41:53.263]                             name <- restart$name
[17:41:53.263]                             if (is.null(name)) 
[17:41:53.263]                               next
[17:41:53.263]                             if (!grepl(pattern, name)) 
[17:41:53.263]                               next
[17:41:53.263]                             invokeRestart(restart)
[17:41:53.263]                             muffled <- TRUE
[17:41:53.263]                             break
[17:41:53.263]                           }
[17:41:53.263]                         }
[17:41:53.263]                       }
[17:41:53.263]                       invisible(muffled)
[17:41:53.263]                     }
[17:41:53.263]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.263]                   }
[17:41:53.263]                 }
[17:41:53.263]             }
[17:41:53.263]         }))
[17:41:53.263]     }, error = function(ex) {
[17:41:53.263]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:53.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.263]                 ...future.rng), started = ...future.startTime, 
[17:41:53.263]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:53.263]             version = "1.8"), class = "FutureResult")
[17:41:53.263]     }, finally = {
[17:41:53.263]         if (!identical(...future.workdir, getwd())) 
[17:41:53.263]             setwd(...future.workdir)
[17:41:53.263]         {
[17:41:53.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:53.263]                 ...future.oldOptions$nwarnings <- NULL
[17:41:53.263]             }
[17:41:53.263]             base::options(...future.oldOptions)
[17:41:53.263]             if (.Platform$OS.type == "windows") {
[17:41:53.263]                 old_names <- names(...future.oldEnvVars)
[17:41:53.263]                 envs <- base::Sys.getenv()
[17:41:53.263]                 names <- names(envs)
[17:41:53.263]                 common <- intersect(names, old_names)
[17:41:53.263]                 added <- setdiff(names, old_names)
[17:41:53.263]                 removed <- setdiff(old_names, names)
[17:41:53.263]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:53.263]                   envs[common]]
[17:41:53.263]                 NAMES <- toupper(changed)
[17:41:53.263]                 args <- list()
[17:41:53.263]                 for (kk in seq_along(NAMES)) {
[17:41:53.263]                   name <- changed[[kk]]
[17:41:53.263]                   NAME <- NAMES[[kk]]
[17:41:53.263]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.263]                     next
[17:41:53.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.263]                 }
[17:41:53.263]                 NAMES <- toupper(added)
[17:41:53.263]                 for (kk in seq_along(NAMES)) {
[17:41:53.263]                   name <- added[[kk]]
[17:41:53.263]                   NAME <- NAMES[[kk]]
[17:41:53.263]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.263]                     next
[17:41:53.263]                   args[[name]] <- ""
[17:41:53.263]                 }
[17:41:53.263]                 NAMES <- toupper(removed)
[17:41:53.263]                 for (kk in seq_along(NAMES)) {
[17:41:53.263]                   name <- removed[[kk]]
[17:41:53.263]                   NAME <- NAMES[[kk]]
[17:41:53.263]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.263]                     next
[17:41:53.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.263]                 }
[17:41:53.263]                 if (length(args) > 0) 
[17:41:53.263]                   base::do.call(base::Sys.setenv, args = args)
[17:41:53.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:53.263]             }
[17:41:53.263]             else {
[17:41:53.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:53.263]             }
[17:41:53.263]             {
[17:41:53.263]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:53.263]                   0L) {
[17:41:53.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:53.263]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:53.263]                   base::options(opts)
[17:41:53.263]                 }
[17:41:53.263]                 {
[17:41:53.263]                   {
[17:41:53.263]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:53.263]                     NULL
[17:41:53.263]                   }
[17:41:53.263]                   options(future.plan = NULL)
[17:41:53.263]                   if (is.na(NA_character_)) 
[17:41:53.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:53.263]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:53.263]                     envir = parent.frame()) 
[17:41:53.263]                   {
[17:41:53.263]                     default_workers <- missing(workers)
[17:41:53.263]                     if (is.function(workers)) 
[17:41:53.263]                       workers <- workers()
[17:41:53.263]                     workers <- structure(as.integer(workers), 
[17:41:53.263]                       class = class(workers))
[17:41:53.263]                     stop_if_not(is.finite(workers), workers >= 
[17:41:53.263]                       1L)
[17:41:53.263]                     if ((workers == 1L && !inherits(workers, 
[17:41:53.263]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:53.263]                       if (default_workers) 
[17:41:53.263]                         supportsMulticore(warn = TRUE)
[17:41:53.263]                       return(sequential(..., envir = envir))
[17:41:53.263]                     }
[17:41:53.263]                     oopts <- options(mc.cores = workers)
[17:41:53.263]                     on.exit(options(oopts))
[17:41:53.263]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:53.263]                       envir = envir)
[17:41:53.263]                     if (!future$lazy) 
[17:41:53.263]                       future <- run(future)
[17:41:53.263]                     invisible(future)
[17:41:53.263]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:53.263]                 }
[17:41:53.263]             }
[17:41:53.263]         }
[17:41:53.263]     })
[17:41:53.263]     if (TRUE) {
[17:41:53.263]         base::sink(type = "output", split = FALSE)
[17:41:53.263]         if (TRUE) {
[17:41:53.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:53.263]         }
[17:41:53.263]         else {
[17:41:53.263]             ...future.result["stdout"] <- base::list(NULL)
[17:41:53.263]         }
[17:41:53.263]         base::close(...future.stdout)
[17:41:53.263]         ...future.stdout <- NULL
[17:41:53.263]     }
[17:41:53.263]     ...future.result$conditions <- ...future.conditions
[17:41:53.263]     ...future.result$finished <- base::Sys.time()
[17:41:53.263]     ...future.result
[17:41:53.263] }
[17:41:53.266] assign_globals() ...
[17:41:53.266] List of 3
[17:41:53.266]  $ fcn:function (x, y)  
[17:41:53.266]  $ x  : int [1:2] 1 2
[17:41:53.266]  $ y  : num 3
[17:41:53.266]  - attr(*, "where")=List of 3
[17:41:53.266]   ..$ fcn:<environment: R_EmptyEnv> 
[17:41:53.266]   ..$ x  :<environment: R_EmptyEnv> 
[17:41:53.266]   ..$ y  :<environment: R_EmptyEnv> 
[17:41:53.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:53.266]  - attr(*, "resolved")= logi FALSE
[17:41:53.266]  - attr(*, "total_size")= num 4280
[17:41:53.266]  - attr(*, "already-done")= logi TRUE
[17:41:53.270] - reassign environment for ‘fcn’
[17:41:53.270] - copied ‘fcn’ to environment
[17:41:53.270] - copied ‘x’ to environment
[17:41:53.270] - copied ‘y’ to environment
[17:41:53.271] assign_globals() ... done
[17:41:53.271] requestCore(): workers = 2
[17:41:53.273] MulticoreFuture started
[17:41:53.273] - Launch lazy future ... done
[17:41:53.273] run() for ‘MulticoreFuture’ ... done
[17:41:53.274] plan(): Setting new future strategy stack:
[17:41:53.274] List of future strategies:
[17:41:53.274] 1. sequential:
[17:41:53.274]    - args: function (..., envir = parent.frame())
[17:41:53.274]    - tweaked: FALSE
[17:41:53.274]    - call: NULL
[17:41:53.275] plan(): nbrOfWorkers() = 1
[17:41:53.277] plan(): Setting new future strategy stack:
[17:41:53.277] List of future strategies:
[17:41:53.277] 1. multicore:
[17:41:53.277]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:53.277]    - tweaked: FALSE
[17:41:53.277]    - call: plan(strategy, substitute = FALSE)
[17:41:53.283] plan(): nbrOfWorkers() = 2
[1] 6
- plan('multisession') ...
[17:41:53.284] plan(): Setting new future strategy stack:
[17:41:53.285] List of future strategies:
[17:41:53.285] 1. multisession:
[17:41:53.285]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:53.285]    - tweaked: FALSE
[17:41:53.285]    - call: plan(strategy, substitute = FALSE)
[17:41:53.285] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:41:53.285] multisession:
[17:41:53.285] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:53.285] - tweaked: FALSE
[17:41:53.285] - call: plan(strategy, substitute = FALSE)
[17:41:53.292] getGlobalsAndPackages() ...
[17:41:53.292] Not searching for globals
[17:41:53.293] - globals: [0] <none>
[17:41:53.293] getGlobalsAndPackages() ... DONE
[17:41:53.296] [local output] makeClusterPSOCK() ...
[17:41:53.339] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:41:53.345] [local output] Base port: 11146
[17:41:53.345] [local output] Getting setup options for 2 cluster nodes ...
[17:41:53.345] [local output]  - Node 1 of 2 ...
[17:41:53.346] [local output] localMachine=TRUE => revtunnel=FALSE

[17:41:53.347] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpDeYcUG/worker.rank=1.parallelly.parent=42678.a6b630b26ece.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpDeYcUG/worker.rank=1.parallelly.parent=42678.a6b630b26ece.pid")'’
[17:41:53.539] - Possible to infer worker's PID: TRUE
[17:41:53.540] [local output] Rscript port: 11146

[17:41:53.540] [local output]  - Node 2 of 2 ...
[17:41:53.541] [local output] localMachine=TRUE => revtunnel=FALSE

[17:41:53.541] [local output] Rscript port: 11146

[17:41:53.541] [local output] Getting setup options for 2 cluster nodes ... done
[17:41:53.542] [local output]  - Parallel setup requested for some PSOCK nodes
[17:41:53.542] [local output] Setting up PSOCK nodes in parallel
[17:41:53.542] List of 36
[17:41:53.542]  $ worker          : chr "localhost"
[17:41:53.542]   ..- attr(*, "localhost")= logi TRUE
[17:41:53.542]  $ master          : chr "localhost"
[17:41:53.542]  $ port            : int 11146
[17:41:53.542]  $ connectTimeout  : num 120
[17:41:53.542]  $ timeout         : num 2592000
[17:41:53.542]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:41:53.542]  $ homogeneous     : logi TRUE
[17:41:53.542]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:41:53.542]  $ rscript_envs    : NULL
[17:41:53.542]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:41:53.542]  $ rscript_startup : NULL
[17:41:53.542]  $ rscript_sh      : chr "sh"
[17:41:53.542]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:41:53.542]  $ methods         : logi TRUE
[17:41:53.542]  $ socketOptions   : chr "no-delay"
[17:41:53.542]  $ useXDR          : logi FALSE
[17:41:53.542]  $ outfile         : chr "/dev/null"
[17:41:53.542]  $ renice          : int NA
[17:41:53.542]  $ rshcmd          : NULL
[17:41:53.542]  $ user            : chr(0) 
[17:41:53.542]  $ revtunnel       : logi FALSE
[17:41:53.542]  $ rshlogfile      : NULL
[17:41:53.542]  $ rshopts         : chr(0) 
[17:41:53.542]  $ rank            : int 1
[17:41:53.542]  $ manual          : logi FALSE
[17:41:53.542]  $ dryrun          : logi FALSE
[17:41:53.542]  $ quiet           : logi FALSE
[17:41:53.542]  $ setup_strategy  : chr "parallel"
[17:41:53.542]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:41:53.542]  $ pidfile         : chr "/tmp/RtmpDeYcUG/worker.rank=1.parallelly.parent=42678.a6b630b26ece.pid"
[17:41:53.542]  $ rshcmd_label    : NULL
[17:41:53.542]  $ rsh_call        : NULL
[17:41:53.542]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:41:53.542]  $ localMachine    : logi TRUE
[17:41:53.542]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:41:53.542]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:41:53.542]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:41:53.542]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:41:53.542]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:41:53.542]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:41:53.542]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:41:53.542]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:41:53.542]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:41:53.542]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:41:53.542]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:41:53.542]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:41:53.542]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:41:53.542]  $ arguments       :List of 28
[17:41:53.542]   ..$ worker          : chr "localhost"
[17:41:53.542]   ..$ master          : NULL
[17:41:53.542]   ..$ port            : int 11146
[17:41:53.542]   ..$ connectTimeout  : num 120
[17:41:53.542]   ..$ timeout         : num 2592000
[17:41:53.542]   ..$ rscript         : NULL
[17:41:53.542]   ..$ homogeneous     : NULL
[17:41:53.542]   ..$ rscript_args    : NULL
[17:41:53.542]   ..$ rscript_envs    : NULL
[17:41:53.542]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:41:53.542]   ..$ rscript_startup : NULL
[17:41:53.542]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:41:53.542]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:41:53.542]   ..$ methods         : logi TRUE
[17:41:53.542]   ..$ socketOptions   : chr "no-delay"
[17:41:53.542]   ..$ useXDR          : logi FALSE
[17:41:53.542]   ..$ outfile         : chr "/dev/null"
[17:41:53.542]   ..$ renice          : int NA
[17:41:53.542]   ..$ rshcmd          : NULL
[17:41:53.542]   ..$ user            : NULL
[17:41:53.542]   ..$ revtunnel       : logi NA
[17:41:53.542]   ..$ rshlogfile      : NULL
[17:41:53.542]   ..$ rshopts         : NULL
[17:41:53.542]   ..$ rank            : int 1
[17:41:53.542]   ..$ manual          : logi FALSE
[17:41:53.542]   ..$ dryrun          : logi FALSE
[17:41:53.542]   ..$ quiet           : logi FALSE
[17:41:53.542]   ..$ setup_strategy  : chr "parallel"
[17:41:53.542]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:41:53.560] [local output] System call to launch all workers:
[17:41:53.560] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpDeYcUG/worker.rank=1.parallelly.parent=42678.a6b630b26ece.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11146 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:41:53.560] [local output] Starting PSOCK main server
[17:41:53.561] [local output] Workers launched
[17:41:53.561] [local output] Waiting for workers to connect back
[17:41:53.562]  - [local output] 0 workers out of 2 ready
[17:41:53.813]  - [local output] 0 workers out of 2 ready
[17:41:53.813]  - [local output] 1 workers out of 2 ready
[17:41:53.820]  - [local output] 1 workers out of 2 ready
[17:41:53.820]  - [local output] 2 workers out of 2 ready
[17:41:53.820] [local output] Launching of workers completed
[17:41:53.820] [local output] Collecting session information from workers
[17:41:53.821] [local output]  - Worker #1 of 2
[17:41:53.822] [local output]  - Worker #2 of 2
[17:41:53.822] [local output] makeClusterPSOCK() ... done
[17:41:53.834] Packages needed by the future expression (n = 0): <none>
[17:41:53.834] Packages needed by future strategies (n = 0): <none>
[17:41:53.835] {
[17:41:53.835]     {
[17:41:53.835]         {
[17:41:53.835]             ...future.startTime <- base::Sys.time()
[17:41:53.835]             {
[17:41:53.835]                 {
[17:41:53.835]                   {
[17:41:53.835]                     {
[17:41:53.835]                       base::local({
[17:41:53.835]                         has_future <- base::requireNamespace("future", 
[17:41:53.835]                           quietly = TRUE)
[17:41:53.835]                         if (has_future) {
[17:41:53.835]                           ns <- base::getNamespace("future")
[17:41:53.835]                           version <- ns[[".package"]][["version"]]
[17:41:53.835]                           if (is.null(version)) 
[17:41:53.835]                             version <- utils::packageVersion("future")
[17:41:53.835]                         }
[17:41:53.835]                         else {
[17:41:53.835]                           version <- NULL
[17:41:53.835]                         }
[17:41:53.835]                         if (!has_future || version < "1.8.0") {
[17:41:53.835]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:53.835]                             "", base::R.version$version.string), 
[17:41:53.835]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:53.835]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:53.835]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:53.835]                               "release", "version")], collapse = " "), 
[17:41:53.835]                             hostname = base::Sys.info()[["nodename"]])
[17:41:53.835]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:53.835]                             info)
[17:41:53.835]                           info <- base::paste(info, collapse = "; ")
[17:41:53.835]                           if (!has_future) {
[17:41:53.835]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:53.835]                               info)
[17:41:53.835]                           }
[17:41:53.835]                           else {
[17:41:53.835]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:53.835]                               info, version)
[17:41:53.835]                           }
[17:41:53.835]                           base::stop(msg)
[17:41:53.835]                         }
[17:41:53.835]                       })
[17:41:53.835]                     }
[17:41:53.835]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:53.835]                     base::options(mc.cores = 1L)
[17:41:53.835]                   }
[17:41:53.835]                   options(future.plan = NULL)
[17:41:53.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:53.835]                 }
[17:41:53.835]                 ...future.workdir <- getwd()
[17:41:53.835]             }
[17:41:53.835]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:53.835]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:53.835]         }
[17:41:53.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:53.835]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:53.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:53.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:53.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:53.835]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:53.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:53.835]             base::names(...future.oldOptions))
[17:41:53.835]     }
[17:41:53.835]     if (FALSE) {
[17:41:53.835]     }
[17:41:53.835]     else {
[17:41:53.835]         if (TRUE) {
[17:41:53.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:53.835]                 open = "w")
[17:41:53.835]         }
[17:41:53.835]         else {
[17:41:53.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:53.835]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:53.835]         }
[17:41:53.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:53.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:53.835]             base::sink(type = "output", split = FALSE)
[17:41:53.835]             base::close(...future.stdout)
[17:41:53.835]         }, add = TRUE)
[17:41:53.835]     }
[17:41:53.835]     ...future.frame <- base::sys.nframe()
[17:41:53.835]     ...future.conditions <- base::list()
[17:41:53.835]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:53.835]     if (FALSE) {
[17:41:53.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:53.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:53.835]     }
[17:41:53.835]     ...future.result <- base::tryCatch({
[17:41:53.835]         base::withCallingHandlers({
[17:41:53.835]             ...future.value <- base::withVisible(base::local({
[17:41:53.835]                 ...future.makeSendCondition <- local({
[17:41:53.835]                   sendCondition <- NULL
[17:41:53.835]                   function(frame = 1L) {
[17:41:53.835]                     if (is.function(sendCondition)) 
[17:41:53.835]                       return(sendCondition)
[17:41:53.835]                     ns <- getNamespace("parallel")
[17:41:53.835]                     if (exists("sendData", mode = "function", 
[17:41:53.835]                       envir = ns)) {
[17:41:53.835]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:53.835]                         envir = ns)
[17:41:53.835]                       envir <- sys.frame(frame)
[17:41:53.835]                       master <- NULL
[17:41:53.835]                       while (!identical(envir, .GlobalEnv) && 
[17:41:53.835]                         !identical(envir, emptyenv())) {
[17:41:53.835]                         if (exists("master", mode = "list", envir = envir, 
[17:41:53.835]                           inherits = FALSE)) {
[17:41:53.835]                           master <- get("master", mode = "list", 
[17:41:53.835]                             envir = envir, inherits = FALSE)
[17:41:53.835]                           if (inherits(master, c("SOCKnode", 
[17:41:53.835]                             "SOCK0node"))) {
[17:41:53.835]                             sendCondition <<- function(cond) {
[17:41:53.835]                               data <- list(type = "VALUE", value = cond, 
[17:41:53.835]                                 success = TRUE)
[17:41:53.835]                               parallel_sendData(master, data)
[17:41:53.835]                             }
[17:41:53.835]                             return(sendCondition)
[17:41:53.835]                           }
[17:41:53.835]                         }
[17:41:53.835]                         frame <- frame + 1L
[17:41:53.835]                         envir <- sys.frame(frame)
[17:41:53.835]                       }
[17:41:53.835]                     }
[17:41:53.835]                     sendCondition <<- function(cond) NULL
[17:41:53.835]                   }
[17:41:53.835]                 })
[17:41:53.835]                 withCallingHandlers({
[17:41:53.835]                   NA
[17:41:53.835]                 }, immediateCondition = function(cond) {
[17:41:53.835]                   sendCondition <- ...future.makeSendCondition()
[17:41:53.835]                   sendCondition(cond)
[17:41:53.835]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.835]                   {
[17:41:53.835]                     inherits <- base::inherits
[17:41:53.835]                     invokeRestart <- base::invokeRestart
[17:41:53.835]                     is.null <- base::is.null
[17:41:53.835]                     muffled <- FALSE
[17:41:53.835]                     if (inherits(cond, "message")) {
[17:41:53.835]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:53.835]                       if (muffled) 
[17:41:53.835]                         invokeRestart("muffleMessage")
[17:41:53.835]                     }
[17:41:53.835]                     else if (inherits(cond, "warning")) {
[17:41:53.835]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:53.835]                       if (muffled) 
[17:41:53.835]                         invokeRestart("muffleWarning")
[17:41:53.835]                     }
[17:41:53.835]                     else if (inherits(cond, "condition")) {
[17:41:53.835]                       if (!is.null(pattern)) {
[17:41:53.835]                         computeRestarts <- base::computeRestarts
[17:41:53.835]                         grepl <- base::grepl
[17:41:53.835]                         restarts <- computeRestarts(cond)
[17:41:53.835]                         for (restart in restarts) {
[17:41:53.835]                           name <- restart$name
[17:41:53.835]                           if (is.null(name)) 
[17:41:53.835]                             next
[17:41:53.835]                           if (!grepl(pattern, name)) 
[17:41:53.835]                             next
[17:41:53.835]                           invokeRestart(restart)
[17:41:53.835]                           muffled <- TRUE
[17:41:53.835]                           break
[17:41:53.835]                         }
[17:41:53.835]                       }
[17:41:53.835]                     }
[17:41:53.835]                     invisible(muffled)
[17:41:53.835]                   }
[17:41:53.835]                   muffleCondition(cond)
[17:41:53.835]                 })
[17:41:53.835]             }))
[17:41:53.835]             future::FutureResult(value = ...future.value$value, 
[17:41:53.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.835]                   ...future.rng), globalenv = if (FALSE) 
[17:41:53.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:53.835]                     ...future.globalenv.names))
[17:41:53.835]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:53.835]         }, condition = base::local({
[17:41:53.835]             c <- base::c
[17:41:53.835]             inherits <- base::inherits
[17:41:53.835]             invokeRestart <- base::invokeRestart
[17:41:53.835]             length <- base::length
[17:41:53.835]             list <- base::list
[17:41:53.835]             seq.int <- base::seq.int
[17:41:53.835]             signalCondition <- base::signalCondition
[17:41:53.835]             sys.calls <- base::sys.calls
[17:41:53.835]             `[[` <- base::`[[`
[17:41:53.835]             `+` <- base::`+`
[17:41:53.835]             `<<-` <- base::`<<-`
[17:41:53.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:53.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:53.835]                   3L)]
[17:41:53.835]             }
[17:41:53.835]             function(cond) {
[17:41:53.835]                 is_error <- inherits(cond, "error")
[17:41:53.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:53.835]                   NULL)
[17:41:53.835]                 if (is_error) {
[17:41:53.835]                   sessionInformation <- function() {
[17:41:53.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:53.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:53.835]                       search = base::search(), system = base::Sys.info())
[17:41:53.835]                   }
[17:41:53.835]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:53.835]                     cond$call), session = sessionInformation(), 
[17:41:53.835]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:53.835]                   signalCondition(cond)
[17:41:53.835]                 }
[17:41:53.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:53.835]                 "immediateCondition"))) {
[17:41:53.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:53.835]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:53.835]                   if (TRUE && !signal) {
[17:41:53.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.835]                     {
[17:41:53.835]                       inherits <- base::inherits
[17:41:53.835]                       invokeRestart <- base::invokeRestart
[17:41:53.835]                       is.null <- base::is.null
[17:41:53.835]                       muffled <- FALSE
[17:41:53.835]                       if (inherits(cond, "message")) {
[17:41:53.835]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.835]                         if (muffled) 
[17:41:53.835]                           invokeRestart("muffleMessage")
[17:41:53.835]                       }
[17:41:53.835]                       else if (inherits(cond, "warning")) {
[17:41:53.835]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.835]                         if (muffled) 
[17:41:53.835]                           invokeRestart("muffleWarning")
[17:41:53.835]                       }
[17:41:53.835]                       else if (inherits(cond, "condition")) {
[17:41:53.835]                         if (!is.null(pattern)) {
[17:41:53.835]                           computeRestarts <- base::computeRestarts
[17:41:53.835]                           grepl <- base::grepl
[17:41:53.835]                           restarts <- computeRestarts(cond)
[17:41:53.835]                           for (restart in restarts) {
[17:41:53.835]                             name <- restart$name
[17:41:53.835]                             if (is.null(name)) 
[17:41:53.835]                               next
[17:41:53.835]                             if (!grepl(pattern, name)) 
[17:41:53.835]                               next
[17:41:53.835]                             invokeRestart(restart)
[17:41:53.835]                             muffled <- TRUE
[17:41:53.835]                             break
[17:41:53.835]                           }
[17:41:53.835]                         }
[17:41:53.835]                       }
[17:41:53.835]                       invisible(muffled)
[17:41:53.835]                     }
[17:41:53.835]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.835]                   }
[17:41:53.835]                 }
[17:41:53.835]                 else {
[17:41:53.835]                   if (TRUE) {
[17:41:53.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.835]                     {
[17:41:53.835]                       inherits <- base::inherits
[17:41:53.835]                       invokeRestart <- base::invokeRestart
[17:41:53.835]                       is.null <- base::is.null
[17:41:53.835]                       muffled <- FALSE
[17:41:53.835]                       if (inherits(cond, "message")) {
[17:41:53.835]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.835]                         if (muffled) 
[17:41:53.835]                           invokeRestart("muffleMessage")
[17:41:53.835]                       }
[17:41:53.835]                       else if (inherits(cond, "warning")) {
[17:41:53.835]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.835]                         if (muffled) 
[17:41:53.835]                           invokeRestart("muffleWarning")
[17:41:53.835]                       }
[17:41:53.835]                       else if (inherits(cond, "condition")) {
[17:41:53.835]                         if (!is.null(pattern)) {
[17:41:53.835]                           computeRestarts <- base::computeRestarts
[17:41:53.835]                           grepl <- base::grepl
[17:41:53.835]                           restarts <- computeRestarts(cond)
[17:41:53.835]                           for (restart in restarts) {
[17:41:53.835]                             name <- restart$name
[17:41:53.835]                             if (is.null(name)) 
[17:41:53.835]                               next
[17:41:53.835]                             if (!grepl(pattern, name)) 
[17:41:53.835]                               next
[17:41:53.835]                             invokeRestart(restart)
[17:41:53.835]                             muffled <- TRUE
[17:41:53.835]                             break
[17:41:53.835]                           }
[17:41:53.835]                         }
[17:41:53.835]                       }
[17:41:53.835]                       invisible(muffled)
[17:41:53.835]                     }
[17:41:53.835]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.835]                   }
[17:41:53.835]                 }
[17:41:53.835]             }
[17:41:53.835]         }))
[17:41:53.835]     }, error = function(ex) {
[17:41:53.835]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:53.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.835]                 ...future.rng), started = ...future.startTime, 
[17:41:53.835]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:53.835]             version = "1.8"), class = "FutureResult")
[17:41:53.835]     }, finally = {
[17:41:53.835]         if (!identical(...future.workdir, getwd())) 
[17:41:53.835]             setwd(...future.workdir)
[17:41:53.835]         {
[17:41:53.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:53.835]                 ...future.oldOptions$nwarnings <- NULL
[17:41:53.835]             }
[17:41:53.835]             base::options(...future.oldOptions)
[17:41:53.835]             if (.Platform$OS.type == "windows") {
[17:41:53.835]                 old_names <- names(...future.oldEnvVars)
[17:41:53.835]                 envs <- base::Sys.getenv()
[17:41:53.835]                 names <- names(envs)
[17:41:53.835]                 common <- intersect(names, old_names)
[17:41:53.835]                 added <- setdiff(names, old_names)
[17:41:53.835]                 removed <- setdiff(old_names, names)
[17:41:53.835]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:53.835]                   envs[common]]
[17:41:53.835]                 NAMES <- toupper(changed)
[17:41:53.835]                 args <- list()
[17:41:53.835]                 for (kk in seq_along(NAMES)) {
[17:41:53.835]                   name <- changed[[kk]]
[17:41:53.835]                   NAME <- NAMES[[kk]]
[17:41:53.835]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.835]                     next
[17:41:53.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.835]                 }
[17:41:53.835]                 NAMES <- toupper(added)
[17:41:53.835]                 for (kk in seq_along(NAMES)) {
[17:41:53.835]                   name <- added[[kk]]
[17:41:53.835]                   NAME <- NAMES[[kk]]
[17:41:53.835]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.835]                     next
[17:41:53.835]                   args[[name]] <- ""
[17:41:53.835]                 }
[17:41:53.835]                 NAMES <- toupper(removed)
[17:41:53.835]                 for (kk in seq_along(NAMES)) {
[17:41:53.835]                   name <- removed[[kk]]
[17:41:53.835]                   NAME <- NAMES[[kk]]
[17:41:53.835]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.835]                     next
[17:41:53.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.835]                 }
[17:41:53.835]                 if (length(args) > 0) 
[17:41:53.835]                   base::do.call(base::Sys.setenv, args = args)
[17:41:53.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:53.835]             }
[17:41:53.835]             else {
[17:41:53.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:53.835]             }
[17:41:53.835]             {
[17:41:53.835]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:53.835]                   0L) {
[17:41:53.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:53.835]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:53.835]                   base::options(opts)
[17:41:53.835]                 }
[17:41:53.835]                 {
[17:41:53.835]                   {
[17:41:53.835]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:53.835]                     NULL
[17:41:53.835]                   }
[17:41:53.835]                   options(future.plan = NULL)
[17:41:53.835]                   if (is.na(NA_character_)) 
[17:41:53.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:53.835]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:53.835]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:53.835]                     envir = parent.frame()) 
[17:41:53.835]                   {
[17:41:53.835]                     if (is.function(workers)) 
[17:41:53.835]                       workers <- workers()
[17:41:53.835]                     workers <- structure(as.integer(workers), 
[17:41:53.835]                       class = class(workers))
[17:41:53.835]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:53.835]                       workers >= 1)
[17:41:53.835]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:53.835]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:53.835]                     }
[17:41:53.835]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:53.835]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:53.835]                       envir = envir)
[17:41:53.835]                     if (!future$lazy) 
[17:41:53.835]                       future <- run(future)
[17:41:53.835]                     invisible(future)
[17:41:53.835]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:53.835]                 }
[17:41:53.835]             }
[17:41:53.835]         }
[17:41:53.835]     })
[17:41:53.835]     if (TRUE) {
[17:41:53.835]         base::sink(type = "output", split = FALSE)
[17:41:53.835]         if (TRUE) {
[17:41:53.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:53.835]         }
[17:41:53.835]         else {
[17:41:53.835]             ...future.result["stdout"] <- base::list(NULL)
[17:41:53.835]         }
[17:41:53.835]         base::close(...future.stdout)
[17:41:53.835]         ...future.stdout <- NULL
[17:41:53.835]     }
[17:41:53.835]     ...future.result$conditions <- ...future.conditions
[17:41:53.835]     ...future.result$finished <- base::Sys.time()
[17:41:53.835]     ...future.result
[17:41:53.835] }
[17:41:53.909] MultisessionFuture started
[17:41:53.909] result() for ClusterFuture ...
[17:41:53.910] receiveMessageFromWorker() for ClusterFuture ...
[17:41:53.910] - Validating connection of MultisessionFuture
[17:41:53.943] - received message: FutureResult
[17:41:53.944] - Received FutureResult
[17:41:53.944] - Erased future from FutureRegistry
[17:41:53.944] result() for ClusterFuture ...
[17:41:53.944] - result already collected: FutureResult
[17:41:53.944] result() for ClusterFuture ... done
[17:41:53.944] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:53.944] result() for ClusterFuture ... done
[17:41:53.944] result() for ClusterFuture ...
[17:41:53.945] - result already collected: FutureResult
[17:41:53.945] result() for ClusterFuture ... done
[17:41:53.945] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:41:53.949] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multisession') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x55bfdb63bea8>
Arguments '...' exists: TRUE
[17:41:53.949] getGlobalsAndPackages() ...
[17:41:53.949] Searching for globals...
[17:41:53.951] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:41:53.951] Searching for globals ... DONE
[17:41:53.951] Resolving globals: FALSE
[17:41:53.952] Tweak future expression to call with '...' arguments ...
[17:41:53.952] {
[17:41:53.952]     do.call(function(...) {
[17:41:53.952]         sum(x, ...)
[17:41:53.952]     }, args = future.call.arguments)
[17:41:53.952] }
[17:41:53.952] Tweak future expression to call with '...' arguments ... DONE
[17:41:53.953] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:53.953] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:41:53.953] - globals: [2] ‘x’, ‘future.call.arguments’
[17:41:53.953] 
[17:41:53.954] getGlobalsAndPackages() ... DONE
[17:41:53.954] run() for ‘Future’ ...
[17:41:53.954] - state: ‘created’
[17:41:53.954] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:53.969] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:53.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:53.970]   - Field: ‘node’
[17:41:53.970]   - Field: ‘label’
[17:41:53.970]   - Field: ‘local’
[17:41:53.970]   - Field: ‘owner’
[17:41:53.970]   - Field: ‘envir’
[17:41:53.970]   - Field: ‘workers’
[17:41:53.970]   - Field: ‘packages’
[17:41:53.971]   - Field: ‘gc’
[17:41:53.971]   - Field: ‘conditions’
[17:41:53.971]   - Field: ‘persistent’
[17:41:53.971]   - Field: ‘expr’
[17:41:53.971]   - Field: ‘uuid’
[17:41:53.971]   - Field: ‘seed’
[17:41:53.971]   - Field: ‘version’
[17:41:53.971]   - Field: ‘result’
[17:41:53.972]   - Field: ‘asynchronous’
[17:41:53.972]   - Field: ‘calls’
[17:41:53.972]   - Field: ‘globals’
[17:41:53.972]   - Field: ‘stdout’
[17:41:53.972]   - Field: ‘earlySignal’
[17:41:53.972]   - Field: ‘lazy’
[17:41:53.972]   - Field: ‘state’
[17:41:53.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:53.973] - Launch lazy future ...
[17:41:53.973] Packages needed by the future expression (n = 0): <none>
[17:41:53.973] Packages needed by future strategies (n = 0): <none>
[17:41:53.974] {
[17:41:53.974]     {
[17:41:53.974]         {
[17:41:53.974]             ...future.startTime <- base::Sys.time()
[17:41:53.974]             {
[17:41:53.974]                 {
[17:41:53.974]                   {
[17:41:53.974]                     {
[17:41:53.974]                       base::local({
[17:41:53.974]                         has_future <- base::requireNamespace("future", 
[17:41:53.974]                           quietly = TRUE)
[17:41:53.974]                         if (has_future) {
[17:41:53.974]                           ns <- base::getNamespace("future")
[17:41:53.974]                           version <- ns[[".package"]][["version"]]
[17:41:53.974]                           if (is.null(version)) 
[17:41:53.974]                             version <- utils::packageVersion("future")
[17:41:53.974]                         }
[17:41:53.974]                         else {
[17:41:53.974]                           version <- NULL
[17:41:53.974]                         }
[17:41:53.974]                         if (!has_future || version < "1.8.0") {
[17:41:53.974]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:53.974]                             "", base::R.version$version.string), 
[17:41:53.974]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:53.974]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:53.974]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:53.974]                               "release", "version")], collapse = " "), 
[17:41:53.974]                             hostname = base::Sys.info()[["nodename"]])
[17:41:53.974]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:53.974]                             info)
[17:41:53.974]                           info <- base::paste(info, collapse = "; ")
[17:41:53.974]                           if (!has_future) {
[17:41:53.974]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:53.974]                               info)
[17:41:53.974]                           }
[17:41:53.974]                           else {
[17:41:53.974]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:53.974]                               info, version)
[17:41:53.974]                           }
[17:41:53.974]                           base::stop(msg)
[17:41:53.974]                         }
[17:41:53.974]                       })
[17:41:53.974]                     }
[17:41:53.974]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:53.974]                     base::options(mc.cores = 1L)
[17:41:53.974]                   }
[17:41:53.974]                   options(future.plan = NULL)
[17:41:53.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:53.974]                 }
[17:41:53.974]                 ...future.workdir <- getwd()
[17:41:53.974]             }
[17:41:53.974]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:53.974]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:53.974]         }
[17:41:53.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:53.974]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:53.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:53.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:53.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:53.974]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:53.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:53.974]             base::names(...future.oldOptions))
[17:41:53.974]     }
[17:41:53.974]     if (FALSE) {
[17:41:53.974]     }
[17:41:53.974]     else {
[17:41:53.974]         if (TRUE) {
[17:41:53.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:53.974]                 open = "w")
[17:41:53.974]         }
[17:41:53.974]         else {
[17:41:53.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:53.974]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:53.974]         }
[17:41:53.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:53.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:53.974]             base::sink(type = "output", split = FALSE)
[17:41:53.974]             base::close(...future.stdout)
[17:41:53.974]         }, add = TRUE)
[17:41:53.974]     }
[17:41:53.974]     ...future.frame <- base::sys.nframe()
[17:41:53.974]     ...future.conditions <- base::list()
[17:41:53.974]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:53.974]     if (FALSE) {
[17:41:53.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:53.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:53.974]     }
[17:41:53.974]     ...future.result <- base::tryCatch({
[17:41:53.974]         base::withCallingHandlers({
[17:41:53.974]             ...future.value <- base::withVisible(base::local({
[17:41:53.974]                 ...future.makeSendCondition <- local({
[17:41:53.974]                   sendCondition <- NULL
[17:41:53.974]                   function(frame = 1L) {
[17:41:53.974]                     if (is.function(sendCondition)) 
[17:41:53.974]                       return(sendCondition)
[17:41:53.974]                     ns <- getNamespace("parallel")
[17:41:53.974]                     if (exists("sendData", mode = "function", 
[17:41:53.974]                       envir = ns)) {
[17:41:53.974]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:53.974]                         envir = ns)
[17:41:53.974]                       envir <- sys.frame(frame)
[17:41:53.974]                       master <- NULL
[17:41:53.974]                       while (!identical(envir, .GlobalEnv) && 
[17:41:53.974]                         !identical(envir, emptyenv())) {
[17:41:53.974]                         if (exists("master", mode = "list", envir = envir, 
[17:41:53.974]                           inherits = FALSE)) {
[17:41:53.974]                           master <- get("master", mode = "list", 
[17:41:53.974]                             envir = envir, inherits = FALSE)
[17:41:53.974]                           if (inherits(master, c("SOCKnode", 
[17:41:53.974]                             "SOCK0node"))) {
[17:41:53.974]                             sendCondition <<- function(cond) {
[17:41:53.974]                               data <- list(type = "VALUE", value = cond, 
[17:41:53.974]                                 success = TRUE)
[17:41:53.974]                               parallel_sendData(master, data)
[17:41:53.974]                             }
[17:41:53.974]                             return(sendCondition)
[17:41:53.974]                           }
[17:41:53.974]                         }
[17:41:53.974]                         frame <- frame + 1L
[17:41:53.974]                         envir <- sys.frame(frame)
[17:41:53.974]                       }
[17:41:53.974]                     }
[17:41:53.974]                     sendCondition <<- function(cond) NULL
[17:41:53.974]                   }
[17:41:53.974]                 })
[17:41:53.974]                 withCallingHandlers({
[17:41:53.974]                   {
[17:41:53.974]                     do.call(function(...) {
[17:41:53.974]                       sum(x, ...)
[17:41:53.974]                     }, args = future.call.arguments)
[17:41:53.974]                   }
[17:41:53.974]                 }, immediateCondition = function(cond) {
[17:41:53.974]                   sendCondition <- ...future.makeSendCondition()
[17:41:53.974]                   sendCondition(cond)
[17:41:53.974]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.974]                   {
[17:41:53.974]                     inherits <- base::inherits
[17:41:53.974]                     invokeRestart <- base::invokeRestart
[17:41:53.974]                     is.null <- base::is.null
[17:41:53.974]                     muffled <- FALSE
[17:41:53.974]                     if (inherits(cond, "message")) {
[17:41:53.974]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:53.974]                       if (muffled) 
[17:41:53.974]                         invokeRestart("muffleMessage")
[17:41:53.974]                     }
[17:41:53.974]                     else if (inherits(cond, "warning")) {
[17:41:53.974]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:53.974]                       if (muffled) 
[17:41:53.974]                         invokeRestart("muffleWarning")
[17:41:53.974]                     }
[17:41:53.974]                     else if (inherits(cond, "condition")) {
[17:41:53.974]                       if (!is.null(pattern)) {
[17:41:53.974]                         computeRestarts <- base::computeRestarts
[17:41:53.974]                         grepl <- base::grepl
[17:41:53.974]                         restarts <- computeRestarts(cond)
[17:41:53.974]                         for (restart in restarts) {
[17:41:53.974]                           name <- restart$name
[17:41:53.974]                           if (is.null(name)) 
[17:41:53.974]                             next
[17:41:53.974]                           if (!grepl(pattern, name)) 
[17:41:53.974]                             next
[17:41:53.974]                           invokeRestart(restart)
[17:41:53.974]                           muffled <- TRUE
[17:41:53.974]                           break
[17:41:53.974]                         }
[17:41:53.974]                       }
[17:41:53.974]                     }
[17:41:53.974]                     invisible(muffled)
[17:41:53.974]                   }
[17:41:53.974]                   muffleCondition(cond)
[17:41:53.974]                 })
[17:41:53.974]             }))
[17:41:53.974]             future::FutureResult(value = ...future.value$value, 
[17:41:53.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.974]                   ...future.rng), globalenv = if (FALSE) 
[17:41:53.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:53.974]                     ...future.globalenv.names))
[17:41:53.974]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:53.974]         }, condition = base::local({
[17:41:53.974]             c <- base::c
[17:41:53.974]             inherits <- base::inherits
[17:41:53.974]             invokeRestart <- base::invokeRestart
[17:41:53.974]             length <- base::length
[17:41:53.974]             list <- base::list
[17:41:53.974]             seq.int <- base::seq.int
[17:41:53.974]             signalCondition <- base::signalCondition
[17:41:53.974]             sys.calls <- base::sys.calls
[17:41:53.974]             `[[` <- base::`[[`
[17:41:53.974]             `+` <- base::`+`
[17:41:53.974]             `<<-` <- base::`<<-`
[17:41:53.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:53.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:53.974]                   3L)]
[17:41:53.974]             }
[17:41:53.974]             function(cond) {
[17:41:53.974]                 is_error <- inherits(cond, "error")
[17:41:53.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:53.974]                   NULL)
[17:41:53.974]                 if (is_error) {
[17:41:53.974]                   sessionInformation <- function() {
[17:41:53.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:53.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:53.974]                       search = base::search(), system = base::Sys.info())
[17:41:53.974]                   }
[17:41:53.974]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:53.974]                     cond$call), session = sessionInformation(), 
[17:41:53.974]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:53.974]                   signalCondition(cond)
[17:41:53.974]                 }
[17:41:53.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:53.974]                 "immediateCondition"))) {
[17:41:53.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:53.974]                   ...future.conditions[[length(...future.conditions) + 
[17:41:53.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:53.974]                   if (TRUE && !signal) {
[17:41:53.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.974]                     {
[17:41:53.974]                       inherits <- base::inherits
[17:41:53.974]                       invokeRestart <- base::invokeRestart
[17:41:53.974]                       is.null <- base::is.null
[17:41:53.974]                       muffled <- FALSE
[17:41:53.974]                       if (inherits(cond, "message")) {
[17:41:53.974]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.974]                         if (muffled) 
[17:41:53.974]                           invokeRestart("muffleMessage")
[17:41:53.974]                       }
[17:41:53.974]                       else if (inherits(cond, "warning")) {
[17:41:53.974]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.974]                         if (muffled) 
[17:41:53.974]                           invokeRestart("muffleWarning")
[17:41:53.974]                       }
[17:41:53.974]                       else if (inherits(cond, "condition")) {
[17:41:53.974]                         if (!is.null(pattern)) {
[17:41:53.974]                           computeRestarts <- base::computeRestarts
[17:41:53.974]                           grepl <- base::grepl
[17:41:53.974]                           restarts <- computeRestarts(cond)
[17:41:53.974]                           for (restart in restarts) {
[17:41:53.974]                             name <- restart$name
[17:41:53.974]                             if (is.null(name)) 
[17:41:53.974]                               next
[17:41:53.974]                             if (!grepl(pattern, name)) 
[17:41:53.974]                               next
[17:41:53.974]                             invokeRestart(restart)
[17:41:53.974]                             muffled <- TRUE
[17:41:53.974]                             break
[17:41:53.974]                           }
[17:41:53.974]                         }
[17:41:53.974]                       }
[17:41:53.974]                       invisible(muffled)
[17:41:53.974]                     }
[17:41:53.974]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.974]                   }
[17:41:53.974]                 }
[17:41:53.974]                 else {
[17:41:53.974]                   if (TRUE) {
[17:41:53.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:53.974]                     {
[17:41:53.974]                       inherits <- base::inherits
[17:41:53.974]                       invokeRestart <- base::invokeRestart
[17:41:53.974]                       is.null <- base::is.null
[17:41:53.974]                       muffled <- FALSE
[17:41:53.974]                       if (inherits(cond, "message")) {
[17:41:53.974]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:53.974]                         if (muffled) 
[17:41:53.974]                           invokeRestart("muffleMessage")
[17:41:53.974]                       }
[17:41:53.974]                       else if (inherits(cond, "warning")) {
[17:41:53.974]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:53.974]                         if (muffled) 
[17:41:53.974]                           invokeRestart("muffleWarning")
[17:41:53.974]                       }
[17:41:53.974]                       else if (inherits(cond, "condition")) {
[17:41:53.974]                         if (!is.null(pattern)) {
[17:41:53.974]                           computeRestarts <- base::computeRestarts
[17:41:53.974]                           grepl <- base::grepl
[17:41:53.974]                           restarts <- computeRestarts(cond)
[17:41:53.974]                           for (restart in restarts) {
[17:41:53.974]                             name <- restart$name
[17:41:53.974]                             if (is.null(name)) 
[17:41:53.974]                               next
[17:41:53.974]                             if (!grepl(pattern, name)) 
[17:41:53.974]                               next
[17:41:53.974]                             invokeRestart(restart)
[17:41:53.974]                             muffled <- TRUE
[17:41:53.974]                             break
[17:41:53.974]                           }
[17:41:53.974]                         }
[17:41:53.974]                       }
[17:41:53.974]                       invisible(muffled)
[17:41:53.974]                     }
[17:41:53.974]                     muffleCondition(cond, pattern = "^muffle")
[17:41:53.974]                   }
[17:41:53.974]                 }
[17:41:53.974]             }
[17:41:53.974]         }))
[17:41:53.974]     }, error = function(ex) {
[17:41:53.974]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:53.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:53.974]                 ...future.rng), started = ...future.startTime, 
[17:41:53.974]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:53.974]             version = "1.8"), class = "FutureResult")
[17:41:53.974]     }, finally = {
[17:41:53.974]         if (!identical(...future.workdir, getwd())) 
[17:41:53.974]             setwd(...future.workdir)
[17:41:53.974]         {
[17:41:53.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:53.974]                 ...future.oldOptions$nwarnings <- NULL
[17:41:53.974]             }
[17:41:53.974]             base::options(...future.oldOptions)
[17:41:53.974]             if (.Platform$OS.type == "windows") {
[17:41:53.974]                 old_names <- names(...future.oldEnvVars)
[17:41:53.974]                 envs <- base::Sys.getenv()
[17:41:53.974]                 names <- names(envs)
[17:41:53.974]                 common <- intersect(names, old_names)
[17:41:53.974]                 added <- setdiff(names, old_names)
[17:41:53.974]                 removed <- setdiff(old_names, names)
[17:41:53.974]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:53.974]                   envs[common]]
[17:41:53.974]                 NAMES <- toupper(changed)
[17:41:53.974]                 args <- list()
[17:41:53.974]                 for (kk in seq_along(NAMES)) {
[17:41:53.974]                   name <- changed[[kk]]
[17:41:53.974]                   NAME <- NAMES[[kk]]
[17:41:53.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.974]                     next
[17:41:53.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.974]                 }
[17:41:53.974]                 NAMES <- toupper(added)
[17:41:53.974]                 for (kk in seq_along(NAMES)) {
[17:41:53.974]                   name <- added[[kk]]
[17:41:53.974]                   NAME <- NAMES[[kk]]
[17:41:53.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.974]                     next
[17:41:53.974]                   args[[name]] <- ""
[17:41:53.974]                 }
[17:41:53.974]                 NAMES <- toupper(removed)
[17:41:53.974]                 for (kk in seq_along(NAMES)) {
[17:41:53.974]                   name <- removed[[kk]]
[17:41:53.974]                   NAME <- NAMES[[kk]]
[17:41:53.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:53.974]                     next
[17:41:53.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:53.974]                 }
[17:41:53.974]                 if (length(args) > 0) 
[17:41:53.974]                   base::do.call(base::Sys.setenv, args = args)
[17:41:53.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:53.974]             }
[17:41:53.974]             else {
[17:41:53.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:53.974]             }
[17:41:53.974]             {
[17:41:53.974]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:53.974]                   0L) {
[17:41:53.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:53.974]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:53.974]                   base::options(opts)
[17:41:53.974]                 }
[17:41:53.974]                 {
[17:41:53.974]                   {
[17:41:53.974]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:53.974]                     NULL
[17:41:53.974]                   }
[17:41:53.974]                   options(future.plan = NULL)
[17:41:53.974]                   if (is.na(NA_character_)) 
[17:41:53.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:53.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:53.974]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:53.974]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:53.974]                     envir = parent.frame()) 
[17:41:53.974]                   {
[17:41:53.974]                     if (is.function(workers)) 
[17:41:53.974]                       workers <- workers()
[17:41:53.974]                     workers <- structure(as.integer(workers), 
[17:41:53.974]                       class = class(workers))
[17:41:53.974]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:53.974]                       workers >= 1)
[17:41:53.974]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:53.974]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:53.974]                     }
[17:41:53.974]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:53.974]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:53.974]                       envir = envir)
[17:41:53.974]                     if (!future$lazy) 
[17:41:53.974]                       future <- run(future)
[17:41:53.974]                     invisible(future)
[17:41:53.974]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:53.974]                 }
[17:41:53.974]             }
[17:41:53.974]         }
[17:41:53.974]     })
[17:41:53.974]     if (TRUE) {
[17:41:53.974]         base::sink(type = "output", split = FALSE)
[17:41:53.974]         if (TRUE) {
[17:41:53.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:53.974]         }
[17:41:53.974]         else {
[17:41:53.974]             ...future.result["stdout"] <- base::list(NULL)
[17:41:53.974]         }
[17:41:53.974]         base::close(...future.stdout)
[17:41:53.974]         ...future.stdout <- NULL
[17:41:53.974]     }
[17:41:53.974]     ...future.result$conditions <- ...future.conditions
[17:41:53.974]     ...future.result$finished <- base::Sys.time()
[17:41:53.974]     ...future.result
[17:41:53.974] }
[17:41:53.977] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:41:53.977] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:41:53.977] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:41:53.978] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:41:53.978] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:41:53.978] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:41:53.979] MultisessionFuture started
[17:41:53.979] - Launch lazy future ... done
[17:41:53.979] run() for ‘MultisessionFuture’ ... done
[17:41:53.980] result() for ClusterFuture ...
[17:41:53.980] receiveMessageFromWorker() for ClusterFuture ...
[17:41:53.980] - Validating connection of MultisessionFuture
[17:41:54.028] - received message: FutureResult
[17:41:54.029] - Received FutureResult
[17:41:54.029] - Erased future from FutureRegistry
[17:41:54.029] result() for ClusterFuture ...
[17:41:54.029] - result already collected: FutureResult
[17:41:54.029] result() for ClusterFuture ... done
[17:41:54.029] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:54.029] result() for ClusterFuture ... done
[17:41:54.030] result() for ClusterFuture ...
[17:41:54.030] - result already collected: FutureResult
[17:41:54.030] result() for ClusterFuture ... done
[1] 6
** Sum function 'B' with plan('multisession') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x55bfdb93cec0>
Arguments '...' exists: TRUE
[17:41:54.031] getGlobalsAndPackages() ...
[17:41:54.031] Searching for globals...
[17:41:54.032] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:41:54.033] Searching for globals ... DONE
[17:41:54.033] Resolving globals: FALSE
[17:41:54.033] Tweak future expression to call with '...' arguments ...
[17:41:54.033] {
[17:41:54.033]     do.call(function(...) {
[17:41:54.033]         sum(x, ...)
[17:41:54.033]     }, args = future.call.arguments)
[17:41:54.033] }
[17:41:54.033] Tweak future expression to call with '...' arguments ... DONE
[17:41:54.034] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:54.034] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:41:54.035] - globals: [2] ‘x’, ‘future.call.arguments’
[17:41:54.035] 
[17:41:54.035] getGlobalsAndPackages() ... DONE
[17:41:54.035] run() for ‘Future’ ...
[17:41:54.035] - state: ‘created’
[17:41:54.036] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:54.051] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:54.051] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:54.051]   - Field: ‘node’
[17:41:54.051]   - Field: ‘label’
[17:41:54.051]   - Field: ‘local’
[17:41:54.051]   - Field: ‘owner’
[17:41:54.052]   - Field: ‘envir’
[17:41:54.052]   - Field: ‘workers’
[17:41:54.052]   - Field: ‘packages’
[17:41:54.052]   - Field: ‘gc’
[17:41:54.052]   - Field: ‘conditions’
[17:41:54.052]   - Field: ‘persistent’
[17:41:54.052]   - Field: ‘expr’
[17:41:54.052]   - Field: ‘uuid’
[17:41:54.053]   - Field: ‘seed’
[17:41:54.053]   - Field: ‘version’
[17:41:54.053]   - Field: ‘result’
[17:41:54.053]   - Field: ‘asynchronous’
[17:41:54.053]   - Field: ‘calls’
[17:41:54.053]   - Field: ‘globals’
[17:41:54.053]   - Field: ‘stdout’
[17:41:54.053]   - Field: ‘earlySignal’
[17:41:54.054]   - Field: ‘lazy’
[17:41:54.054]   - Field: ‘state’
[17:41:54.054] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:54.054] - Launch lazy future ...
[17:41:54.054] Packages needed by the future expression (n = 0): <none>
[17:41:54.054] Packages needed by future strategies (n = 0): <none>
[17:41:54.055] {
[17:41:54.055]     {
[17:41:54.055]         {
[17:41:54.055]             ...future.startTime <- base::Sys.time()
[17:41:54.055]             {
[17:41:54.055]                 {
[17:41:54.055]                   {
[17:41:54.055]                     {
[17:41:54.055]                       base::local({
[17:41:54.055]                         has_future <- base::requireNamespace("future", 
[17:41:54.055]                           quietly = TRUE)
[17:41:54.055]                         if (has_future) {
[17:41:54.055]                           ns <- base::getNamespace("future")
[17:41:54.055]                           version <- ns[[".package"]][["version"]]
[17:41:54.055]                           if (is.null(version)) 
[17:41:54.055]                             version <- utils::packageVersion("future")
[17:41:54.055]                         }
[17:41:54.055]                         else {
[17:41:54.055]                           version <- NULL
[17:41:54.055]                         }
[17:41:54.055]                         if (!has_future || version < "1.8.0") {
[17:41:54.055]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:54.055]                             "", base::R.version$version.string), 
[17:41:54.055]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:54.055]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:54.055]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:54.055]                               "release", "version")], collapse = " "), 
[17:41:54.055]                             hostname = base::Sys.info()[["nodename"]])
[17:41:54.055]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:54.055]                             info)
[17:41:54.055]                           info <- base::paste(info, collapse = "; ")
[17:41:54.055]                           if (!has_future) {
[17:41:54.055]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:54.055]                               info)
[17:41:54.055]                           }
[17:41:54.055]                           else {
[17:41:54.055]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:54.055]                               info, version)
[17:41:54.055]                           }
[17:41:54.055]                           base::stop(msg)
[17:41:54.055]                         }
[17:41:54.055]                       })
[17:41:54.055]                     }
[17:41:54.055]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:54.055]                     base::options(mc.cores = 1L)
[17:41:54.055]                   }
[17:41:54.055]                   options(future.plan = NULL)
[17:41:54.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:54.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:54.055]                 }
[17:41:54.055]                 ...future.workdir <- getwd()
[17:41:54.055]             }
[17:41:54.055]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:54.055]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:54.055]         }
[17:41:54.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:54.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:54.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:54.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:54.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:54.055]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:54.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:54.055]             base::names(...future.oldOptions))
[17:41:54.055]     }
[17:41:54.055]     if (FALSE) {
[17:41:54.055]     }
[17:41:54.055]     else {
[17:41:54.055]         if (TRUE) {
[17:41:54.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:54.055]                 open = "w")
[17:41:54.055]         }
[17:41:54.055]         else {
[17:41:54.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:54.055]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:54.055]         }
[17:41:54.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:54.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:54.055]             base::sink(type = "output", split = FALSE)
[17:41:54.055]             base::close(...future.stdout)
[17:41:54.055]         }, add = TRUE)
[17:41:54.055]     }
[17:41:54.055]     ...future.frame <- base::sys.nframe()
[17:41:54.055]     ...future.conditions <- base::list()
[17:41:54.055]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:54.055]     if (FALSE) {
[17:41:54.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:54.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:54.055]     }
[17:41:54.055]     ...future.result <- base::tryCatch({
[17:41:54.055]         base::withCallingHandlers({
[17:41:54.055]             ...future.value <- base::withVisible(base::local({
[17:41:54.055]                 ...future.makeSendCondition <- local({
[17:41:54.055]                   sendCondition <- NULL
[17:41:54.055]                   function(frame = 1L) {
[17:41:54.055]                     if (is.function(sendCondition)) 
[17:41:54.055]                       return(sendCondition)
[17:41:54.055]                     ns <- getNamespace("parallel")
[17:41:54.055]                     if (exists("sendData", mode = "function", 
[17:41:54.055]                       envir = ns)) {
[17:41:54.055]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:54.055]                         envir = ns)
[17:41:54.055]                       envir <- sys.frame(frame)
[17:41:54.055]                       master <- NULL
[17:41:54.055]                       while (!identical(envir, .GlobalEnv) && 
[17:41:54.055]                         !identical(envir, emptyenv())) {
[17:41:54.055]                         if (exists("master", mode = "list", envir = envir, 
[17:41:54.055]                           inherits = FALSE)) {
[17:41:54.055]                           master <- get("master", mode = "list", 
[17:41:54.055]                             envir = envir, inherits = FALSE)
[17:41:54.055]                           if (inherits(master, c("SOCKnode", 
[17:41:54.055]                             "SOCK0node"))) {
[17:41:54.055]                             sendCondition <<- function(cond) {
[17:41:54.055]                               data <- list(type = "VALUE", value = cond, 
[17:41:54.055]                                 success = TRUE)
[17:41:54.055]                               parallel_sendData(master, data)
[17:41:54.055]                             }
[17:41:54.055]                             return(sendCondition)
[17:41:54.055]                           }
[17:41:54.055]                         }
[17:41:54.055]                         frame <- frame + 1L
[17:41:54.055]                         envir <- sys.frame(frame)
[17:41:54.055]                       }
[17:41:54.055]                     }
[17:41:54.055]                     sendCondition <<- function(cond) NULL
[17:41:54.055]                   }
[17:41:54.055]                 })
[17:41:54.055]                 withCallingHandlers({
[17:41:54.055]                   {
[17:41:54.055]                     do.call(function(...) {
[17:41:54.055]                       sum(x, ...)
[17:41:54.055]                     }, args = future.call.arguments)
[17:41:54.055]                   }
[17:41:54.055]                 }, immediateCondition = function(cond) {
[17:41:54.055]                   sendCondition <- ...future.makeSendCondition()
[17:41:54.055]                   sendCondition(cond)
[17:41:54.055]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.055]                   {
[17:41:54.055]                     inherits <- base::inherits
[17:41:54.055]                     invokeRestart <- base::invokeRestart
[17:41:54.055]                     is.null <- base::is.null
[17:41:54.055]                     muffled <- FALSE
[17:41:54.055]                     if (inherits(cond, "message")) {
[17:41:54.055]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:54.055]                       if (muffled) 
[17:41:54.055]                         invokeRestart("muffleMessage")
[17:41:54.055]                     }
[17:41:54.055]                     else if (inherits(cond, "warning")) {
[17:41:54.055]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:54.055]                       if (muffled) 
[17:41:54.055]                         invokeRestart("muffleWarning")
[17:41:54.055]                     }
[17:41:54.055]                     else if (inherits(cond, "condition")) {
[17:41:54.055]                       if (!is.null(pattern)) {
[17:41:54.055]                         computeRestarts <- base::computeRestarts
[17:41:54.055]                         grepl <- base::grepl
[17:41:54.055]                         restarts <- computeRestarts(cond)
[17:41:54.055]                         for (restart in restarts) {
[17:41:54.055]                           name <- restart$name
[17:41:54.055]                           if (is.null(name)) 
[17:41:54.055]                             next
[17:41:54.055]                           if (!grepl(pattern, name)) 
[17:41:54.055]                             next
[17:41:54.055]                           invokeRestart(restart)
[17:41:54.055]                           muffled <- TRUE
[17:41:54.055]                           break
[17:41:54.055]                         }
[17:41:54.055]                       }
[17:41:54.055]                     }
[17:41:54.055]                     invisible(muffled)
[17:41:54.055]                   }
[17:41:54.055]                   muffleCondition(cond)
[17:41:54.055]                 })
[17:41:54.055]             }))
[17:41:54.055]             future::FutureResult(value = ...future.value$value, 
[17:41:54.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:54.055]                   ...future.rng), globalenv = if (FALSE) 
[17:41:54.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:54.055]                     ...future.globalenv.names))
[17:41:54.055]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:54.055]         }, condition = base::local({
[17:41:54.055]             c <- base::c
[17:41:54.055]             inherits <- base::inherits
[17:41:54.055]             invokeRestart <- base::invokeRestart
[17:41:54.055]             length <- base::length
[17:41:54.055]             list <- base::list
[17:41:54.055]             seq.int <- base::seq.int
[17:41:54.055]             signalCondition <- base::signalCondition
[17:41:54.055]             sys.calls <- base::sys.calls
[17:41:54.055]             `[[` <- base::`[[`
[17:41:54.055]             `+` <- base::`+`
[17:41:54.055]             `<<-` <- base::`<<-`
[17:41:54.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:54.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:54.055]                   3L)]
[17:41:54.055]             }
[17:41:54.055]             function(cond) {
[17:41:54.055]                 is_error <- inherits(cond, "error")
[17:41:54.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:54.055]                   NULL)
[17:41:54.055]                 if (is_error) {
[17:41:54.055]                   sessionInformation <- function() {
[17:41:54.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:54.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:54.055]                       search = base::search(), system = base::Sys.info())
[17:41:54.055]                   }
[17:41:54.055]                   ...future.conditions[[length(...future.conditions) + 
[17:41:54.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:54.055]                     cond$call), session = sessionInformation(), 
[17:41:54.055]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:54.055]                   signalCondition(cond)
[17:41:54.055]                 }
[17:41:54.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:54.055]                 "immediateCondition"))) {
[17:41:54.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:54.055]                   ...future.conditions[[length(...future.conditions) + 
[17:41:54.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:54.055]                   if (TRUE && !signal) {
[17:41:54.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.055]                     {
[17:41:54.055]                       inherits <- base::inherits
[17:41:54.055]                       invokeRestart <- base::invokeRestart
[17:41:54.055]                       is.null <- base::is.null
[17:41:54.055]                       muffled <- FALSE
[17:41:54.055]                       if (inherits(cond, "message")) {
[17:41:54.055]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:54.055]                         if (muffled) 
[17:41:54.055]                           invokeRestart("muffleMessage")
[17:41:54.055]                       }
[17:41:54.055]                       else if (inherits(cond, "warning")) {
[17:41:54.055]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:54.055]                         if (muffled) 
[17:41:54.055]                           invokeRestart("muffleWarning")
[17:41:54.055]                       }
[17:41:54.055]                       else if (inherits(cond, "condition")) {
[17:41:54.055]                         if (!is.null(pattern)) {
[17:41:54.055]                           computeRestarts <- base::computeRestarts
[17:41:54.055]                           grepl <- base::grepl
[17:41:54.055]                           restarts <- computeRestarts(cond)
[17:41:54.055]                           for (restart in restarts) {
[17:41:54.055]                             name <- restart$name
[17:41:54.055]                             if (is.null(name)) 
[17:41:54.055]                               next
[17:41:54.055]                             if (!grepl(pattern, name)) 
[17:41:54.055]                               next
[17:41:54.055]                             invokeRestart(restart)
[17:41:54.055]                             muffled <- TRUE
[17:41:54.055]                             break
[17:41:54.055]                           }
[17:41:54.055]                         }
[17:41:54.055]                       }
[17:41:54.055]                       invisible(muffled)
[17:41:54.055]                     }
[17:41:54.055]                     muffleCondition(cond, pattern = "^muffle")
[17:41:54.055]                   }
[17:41:54.055]                 }
[17:41:54.055]                 else {
[17:41:54.055]                   if (TRUE) {
[17:41:54.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.055]                     {
[17:41:54.055]                       inherits <- base::inherits
[17:41:54.055]                       invokeRestart <- base::invokeRestart
[17:41:54.055]                       is.null <- base::is.null
[17:41:54.055]                       muffled <- FALSE
[17:41:54.055]                       if (inherits(cond, "message")) {
[17:41:54.055]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:54.055]                         if (muffled) 
[17:41:54.055]                           invokeRestart("muffleMessage")
[17:41:54.055]                       }
[17:41:54.055]                       else if (inherits(cond, "warning")) {
[17:41:54.055]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:54.055]                         if (muffled) 
[17:41:54.055]                           invokeRestart("muffleWarning")
[17:41:54.055]                       }
[17:41:54.055]                       else if (inherits(cond, "condition")) {
[17:41:54.055]                         if (!is.null(pattern)) {
[17:41:54.055]                           computeRestarts <- base::computeRestarts
[17:41:54.055]                           grepl <- base::grepl
[17:41:54.055]                           restarts <- computeRestarts(cond)
[17:41:54.055]                           for (restart in restarts) {
[17:41:54.055]                             name <- restart$name
[17:41:54.055]                             if (is.null(name)) 
[17:41:54.055]                               next
[17:41:54.055]                             if (!grepl(pattern, name)) 
[17:41:54.055]                               next
[17:41:54.055]                             invokeRestart(restart)
[17:41:54.055]                             muffled <- TRUE
[17:41:54.055]                             break
[17:41:54.055]                           }
[17:41:54.055]                         }
[17:41:54.055]                       }
[17:41:54.055]                       invisible(muffled)
[17:41:54.055]                     }
[17:41:54.055]                     muffleCondition(cond, pattern = "^muffle")
[17:41:54.055]                   }
[17:41:54.055]                 }
[17:41:54.055]             }
[17:41:54.055]         }))
[17:41:54.055]     }, error = function(ex) {
[17:41:54.055]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:54.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:54.055]                 ...future.rng), started = ...future.startTime, 
[17:41:54.055]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:54.055]             version = "1.8"), class = "FutureResult")
[17:41:54.055]     }, finally = {
[17:41:54.055]         if (!identical(...future.workdir, getwd())) 
[17:41:54.055]             setwd(...future.workdir)
[17:41:54.055]         {
[17:41:54.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:54.055]                 ...future.oldOptions$nwarnings <- NULL
[17:41:54.055]             }
[17:41:54.055]             base::options(...future.oldOptions)
[17:41:54.055]             if (.Platform$OS.type == "windows") {
[17:41:54.055]                 old_names <- names(...future.oldEnvVars)
[17:41:54.055]                 envs <- base::Sys.getenv()
[17:41:54.055]                 names <- names(envs)
[17:41:54.055]                 common <- intersect(names, old_names)
[17:41:54.055]                 added <- setdiff(names, old_names)
[17:41:54.055]                 removed <- setdiff(old_names, names)
[17:41:54.055]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:54.055]                   envs[common]]
[17:41:54.055]                 NAMES <- toupper(changed)
[17:41:54.055]                 args <- list()
[17:41:54.055]                 for (kk in seq_along(NAMES)) {
[17:41:54.055]                   name <- changed[[kk]]
[17:41:54.055]                   NAME <- NAMES[[kk]]
[17:41:54.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.055]                     next
[17:41:54.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:54.055]                 }
[17:41:54.055]                 NAMES <- toupper(added)
[17:41:54.055]                 for (kk in seq_along(NAMES)) {
[17:41:54.055]                   name <- added[[kk]]
[17:41:54.055]                   NAME <- NAMES[[kk]]
[17:41:54.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.055]                     next
[17:41:54.055]                   args[[name]] <- ""
[17:41:54.055]                 }
[17:41:54.055]                 NAMES <- toupper(removed)
[17:41:54.055]                 for (kk in seq_along(NAMES)) {
[17:41:54.055]                   name <- removed[[kk]]
[17:41:54.055]                   NAME <- NAMES[[kk]]
[17:41:54.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.055]                     next
[17:41:54.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:54.055]                 }
[17:41:54.055]                 if (length(args) > 0) 
[17:41:54.055]                   base::do.call(base::Sys.setenv, args = args)
[17:41:54.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:54.055]             }
[17:41:54.055]             else {
[17:41:54.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:54.055]             }
[17:41:54.055]             {
[17:41:54.055]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:54.055]                   0L) {
[17:41:54.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:54.055]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:54.055]                   base::options(opts)
[17:41:54.055]                 }
[17:41:54.055]                 {
[17:41:54.055]                   {
[17:41:54.055]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:54.055]                     NULL
[17:41:54.055]                   }
[17:41:54.055]                   options(future.plan = NULL)
[17:41:54.055]                   if (is.na(NA_character_)) 
[17:41:54.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:54.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:54.055]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:54.055]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:54.055]                     envir = parent.frame()) 
[17:41:54.055]                   {
[17:41:54.055]                     if (is.function(workers)) 
[17:41:54.055]                       workers <- workers()
[17:41:54.055]                     workers <- structure(as.integer(workers), 
[17:41:54.055]                       class = class(workers))
[17:41:54.055]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:54.055]                       workers >= 1)
[17:41:54.055]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:54.055]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:54.055]                     }
[17:41:54.055]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:54.055]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:54.055]                       envir = envir)
[17:41:54.055]                     if (!future$lazy) 
[17:41:54.055]                       future <- run(future)
[17:41:54.055]                     invisible(future)
[17:41:54.055]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:54.055]                 }
[17:41:54.055]             }
[17:41:54.055]         }
[17:41:54.055]     })
[17:41:54.055]     if (TRUE) {
[17:41:54.055]         base::sink(type = "output", split = FALSE)
[17:41:54.055]         if (TRUE) {
[17:41:54.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:54.055]         }
[17:41:54.055]         else {
[17:41:54.055]             ...future.result["stdout"] <- base::list(NULL)
[17:41:54.055]         }
[17:41:54.055]         base::close(...future.stdout)
[17:41:54.055]         ...future.stdout <- NULL
[17:41:54.055]     }
[17:41:54.055]     ...future.result$conditions <- ...future.conditions
[17:41:54.055]     ...future.result$finished <- base::Sys.time()
[17:41:54.055]     ...future.result
[17:41:54.055] }
[17:41:54.058] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:41:54.058] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:41:54.059] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:41:54.059] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:41:54.060] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:41:54.060] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:41:54.061] MultisessionFuture started
[17:41:54.061] - Launch lazy future ... done
[17:41:54.061] run() for ‘MultisessionFuture’ ... done
[17:41:54.061] result() for ClusterFuture ...
[17:41:54.061] receiveMessageFromWorker() for ClusterFuture ...
[17:41:54.061] - Validating connection of MultisessionFuture
[17:41:54.110] - received message: FutureResult
[17:41:54.110] - Received FutureResult
[17:41:54.110] - Erased future from FutureRegistry
[17:41:54.110] result() for ClusterFuture ...
[17:41:54.110] - result already collected: FutureResult
[17:41:54.111] result() for ClusterFuture ... done
[17:41:54.111] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:54.111] result() for ClusterFuture ... done
[17:41:54.111] result() for ClusterFuture ...
[17:41:54.111] - result already collected: FutureResult
[17:41:54.111] result() for ClusterFuture ... done
[1] 6
** Sum function 'C' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55bfdbab5fc0>
Arguments '...' exists: FALSE
[17:41:54.112] getGlobalsAndPackages() ...
[17:41:54.112] Searching for globals...
[17:41:54.114] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[17:41:54.114] Searching for globals ... DONE
[17:41:54.114] Resolving globals: FALSE
[17:41:54.115] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:54.115] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:41:54.115] - globals: [2] ‘x’, ‘y’
[17:41:54.115] 
[17:41:54.116] getGlobalsAndPackages() ... DONE
[17:41:54.116] run() for ‘Future’ ...
[17:41:54.116] - state: ‘created’
[17:41:54.116] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:54.131] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:54.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:54.132]   - Field: ‘node’
[17:41:54.132]   - Field: ‘label’
[17:41:54.132]   - Field: ‘local’
[17:41:54.132]   - Field: ‘owner’
[17:41:54.132]   - Field: ‘envir’
[17:41:54.132]   - Field: ‘workers’
[17:41:54.132]   - Field: ‘packages’
[17:41:54.132]   - Field: ‘gc’
[17:41:54.133]   - Field: ‘conditions’
[17:41:54.133]   - Field: ‘persistent’
[17:41:54.133]   - Field: ‘expr’
[17:41:54.133]   - Field: ‘uuid’
[17:41:54.133]   - Field: ‘seed’
[17:41:54.133]   - Field: ‘version’
[17:41:54.133]   - Field: ‘result’
[17:41:54.133]   - Field: ‘asynchronous’
[17:41:54.134]   - Field: ‘calls’
[17:41:54.134]   - Field: ‘globals’
[17:41:54.134]   - Field: ‘stdout’
[17:41:54.134]   - Field: ‘earlySignal’
[17:41:54.134]   - Field: ‘lazy’
[17:41:54.134]   - Field: ‘state’
[17:41:54.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:54.134] - Launch lazy future ...
[17:41:54.135] Packages needed by the future expression (n = 0): <none>
[17:41:54.135] Packages needed by future strategies (n = 0): <none>
[17:41:54.136] {
[17:41:54.136]     {
[17:41:54.136]         {
[17:41:54.136]             ...future.startTime <- base::Sys.time()
[17:41:54.136]             {
[17:41:54.136]                 {
[17:41:54.136]                   {
[17:41:54.136]                     {
[17:41:54.136]                       base::local({
[17:41:54.136]                         has_future <- base::requireNamespace("future", 
[17:41:54.136]                           quietly = TRUE)
[17:41:54.136]                         if (has_future) {
[17:41:54.136]                           ns <- base::getNamespace("future")
[17:41:54.136]                           version <- ns[[".package"]][["version"]]
[17:41:54.136]                           if (is.null(version)) 
[17:41:54.136]                             version <- utils::packageVersion("future")
[17:41:54.136]                         }
[17:41:54.136]                         else {
[17:41:54.136]                           version <- NULL
[17:41:54.136]                         }
[17:41:54.136]                         if (!has_future || version < "1.8.0") {
[17:41:54.136]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:54.136]                             "", base::R.version$version.string), 
[17:41:54.136]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:54.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:54.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:54.136]                               "release", "version")], collapse = " "), 
[17:41:54.136]                             hostname = base::Sys.info()[["nodename"]])
[17:41:54.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:54.136]                             info)
[17:41:54.136]                           info <- base::paste(info, collapse = "; ")
[17:41:54.136]                           if (!has_future) {
[17:41:54.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:54.136]                               info)
[17:41:54.136]                           }
[17:41:54.136]                           else {
[17:41:54.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:54.136]                               info, version)
[17:41:54.136]                           }
[17:41:54.136]                           base::stop(msg)
[17:41:54.136]                         }
[17:41:54.136]                       })
[17:41:54.136]                     }
[17:41:54.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:54.136]                     base::options(mc.cores = 1L)
[17:41:54.136]                   }
[17:41:54.136]                   options(future.plan = NULL)
[17:41:54.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:54.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:54.136]                 }
[17:41:54.136]                 ...future.workdir <- getwd()
[17:41:54.136]             }
[17:41:54.136]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:54.136]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:54.136]         }
[17:41:54.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:54.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:54.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:54.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:54.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:54.136]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:54.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:54.136]             base::names(...future.oldOptions))
[17:41:54.136]     }
[17:41:54.136]     if (FALSE) {
[17:41:54.136]     }
[17:41:54.136]     else {
[17:41:54.136]         if (TRUE) {
[17:41:54.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:54.136]                 open = "w")
[17:41:54.136]         }
[17:41:54.136]         else {
[17:41:54.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:54.136]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:54.136]         }
[17:41:54.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:54.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:54.136]             base::sink(type = "output", split = FALSE)
[17:41:54.136]             base::close(...future.stdout)
[17:41:54.136]         }, add = TRUE)
[17:41:54.136]     }
[17:41:54.136]     ...future.frame <- base::sys.nframe()
[17:41:54.136]     ...future.conditions <- base::list()
[17:41:54.136]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:54.136]     if (FALSE) {
[17:41:54.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:54.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:54.136]     }
[17:41:54.136]     ...future.result <- base::tryCatch({
[17:41:54.136]         base::withCallingHandlers({
[17:41:54.136]             ...future.value <- base::withVisible(base::local({
[17:41:54.136]                 ...future.makeSendCondition <- local({
[17:41:54.136]                   sendCondition <- NULL
[17:41:54.136]                   function(frame = 1L) {
[17:41:54.136]                     if (is.function(sendCondition)) 
[17:41:54.136]                       return(sendCondition)
[17:41:54.136]                     ns <- getNamespace("parallel")
[17:41:54.136]                     if (exists("sendData", mode = "function", 
[17:41:54.136]                       envir = ns)) {
[17:41:54.136]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:54.136]                         envir = ns)
[17:41:54.136]                       envir <- sys.frame(frame)
[17:41:54.136]                       master <- NULL
[17:41:54.136]                       while (!identical(envir, .GlobalEnv) && 
[17:41:54.136]                         !identical(envir, emptyenv())) {
[17:41:54.136]                         if (exists("master", mode = "list", envir = envir, 
[17:41:54.136]                           inherits = FALSE)) {
[17:41:54.136]                           master <- get("master", mode = "list", 
[17:41:54.136]                             envir = envir, inherits = FALSE)
[17:41:54.136]                           if (inherits(master, c("SOCKnode", 
[17:41:54.136]                             "SOCK0node"))) {
[17:41:54.136]                             sendCondition <<- function(cond) {
[17:41:54.136]                               data <- list(type = "VALUE", value = cond, 
[17:41:54.136]                                 success = TRUE)
[17:41:54.136]                               parallel_sendData(master, data)
[17:41:54.136]                             }
[17:41:54.136]                             return(sendCondition)
[17:41:54.136]                           }
[17:41:54.136]                         }
[17:41:54.136]                         frame <- frame + 1L
[17:41:54.136]                         envir <- sys.frame(frame)
[17:41:54.136]                       }
[17:41:54.136]                     }
[17:41:54.136]                     sendCondition <<- function(cond) NULL
[17:41:54.136]                   }
[17:41:54.136]                 })
[17:41:54.136]                 withCallingHandlers({
[17:41:54.136]                   {
[17:41:54.136]                     sum(x, y)
[17:41:54.136]                   }
[17:41:54.136]                 }, immediateCondition = function(cond) {
[17:41:54.136]                   sendCondition <- ...future.makeSendCondition()
[17:41:54.136]                   sendCondition(cond)
[17:41:54.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.136]                   {
[17:41:54.136]                     inherits <- base::inherits
[17:41:54.136]                     invokeRestart <- base::invokeRestart
[17:41:54.136]                     is.null <- base::is.null
[17:41:54.136]                     muffled <- FALSE
[17:41:54.136]                     if (inherits(cond, "message")) {
[17:41:54.136]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:54.136]                       if (muffled) 
[17:41:54.136]                         invokeRestart("muffleMessage")
[17:41:54.136]                     }
[17:41:54.136]                     else if (inherits(cond, "warning")) {
[17:41:54.136]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:54.136]                       if (muffled) 
[17:41:54.136]                         invokeRestart("muffleWarning")
[17:41:54.136]                     }
[17:41:54.136]                     else if (inherits(cond, "condition")) {
[17:41:54.136]                       if (!is.null(pattern)) {
[17:41:54.136]                         computeRestarts <- base::computeRestarts
[17:41:54.136]                         grepl <- base::grepl
[17:41:54.136]                         restarts <- computeRestarts(cond)
[17:41:54.136]                         for (restart in restarts) {
[17:41:54.136]                           name <- restart$name
[17:41:54.136]                           if (is.null(name)) 
[17:41:54.136]                             next
[17:41:54.136]                           if (!grepl(pattern, name)) 
[17:41:54.136]                             next
[17:41:54.136]                           invokeRestart(restart)
[17:41:54.136]                           muffled <- TRUE
[17:41:54.136]                           break
[17:41:54.136]                         }
[17:41:54.136]                       }
[17:41:54.136]                     }
[17:41:54.136]                     invisible(muffled)
[17:41:54.136]                   }
[17:41:54.136]                   muffleCondition(cond)
[17:41:54.136]                 })
[17:41:54.136]             }))
[17:41:54.136]             future::FutureResult(value = ...future.value$value, 
[17:41:54.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:54.136]                   ...future.rng), globalenv = if (FALSE) 
[17:41:54.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:54.136]                     ...future.globalenv.names))
[17:41:54.136]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:54.136]         }, condition = base::local({
[17:41:54.136]             c <- base::c
[17:41:54.136]             inherits <- base::inherits
[17:41:54.136]             invokeRestart <- base::invokeRestart
[17:41:54.136]             length <- base::length
[17:41:54.136]             list <- base::list
[17:41:54.136]             seq.int <- base::seq.int
[17:41:54.136]             signalCondition <- base::signalCondition
[17:41:54.136]             sys.calls <- base::sys.calls
[17:41:54.136]             `[[` <- base::`[[`
[17:41:54.136]             `+` <- base::`+`
[17:41:54.136]             `<<-` <- base::`<<-`
[17:41:54.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:54.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:54.136]                   3L)]
[17:41:54.136]             }
[17:41:54.136]             function(cond) {
[17:41:54.136]                 is_error <- inherits(cond, "error")
[17:41:54.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:54.136]                   NULL)
[17:41:54.136]                 if (is_error) {
[17:41:54.136]                   sessionInformation <- function() {
[17:41:54.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:54.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:54.136]                       search = base::search(), system = base::Sys.info())
[17:41:54.136]                   }
[17:41:54.136]                   ...future.conditions[[length(...future.conditions) + 
[17:41:54.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:54.136]                     cond$call), session = sessionInformation(), 
[17:41:54.136]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:54.136]                   signalCondition(cond)
[17:41:54.136]                 }
[17:41:54.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:54.136]                 "immediateCondition"))) {
[17:41:54.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:54.136]                   ...future.conditions[[length(...future.conditions) + 
[17:41:54.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:54.136]                   if (TRUE && !signal) {
[17:41:54.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.136]                     {
[17:41:54.136]                       inherits <- base::inherits
[17:41:54.136]                       invokeRestart <- base::invokeRestart
[17:41:54.136]                       is.null <- base::is.null
[17:41:54.136]                       muffled <- FALSE
[17:41:54.136]                       if (inherits(cond, "message")) {
[17:41:54.136]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:54.136]                         if (muffled) 
[17:41:54.136]                           invokeRestart("muffleMessage")
[17:41:54.136]                       }
[17:41:54.136]                       else if (inherits(cond, "warning")) {
[17:41:54.136]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:54.136]                         if (muffled) 
[17:41:54.136]                           invokeRestart("muffleWarning")
[17:41:54.136]                       }
[17:41:54.136]                       else if (inherits(cond, "condition")) {
[17:41:54.136]                         if (!is.null(pattern)) {
[17:41:54.136]                           computeRestarts <- base::computeRestarts
[17:41:54.136]                           grepl <- base::grepl
[17:41:54.136]                           restarts <- computeRestarts(cond)
[17:41:54.136]                           for (restart in restarts) {
[17:41:54.136]                             name <- restart$name
[17:41:54.136]                             if (is.null(name)) 
[17:41:54.136]                               next
[17:41:54.136]                             if (!grepl(pattern, name)) 
[17:41:54.136]                               next
[17:41:54.136]                             invokeRestart(restart)
[17:41:54.136]                             muffled <- TRUE
[17:41:54.136]                             break
[17:41:54.136]                           }
[17:41:54.136]                         }
[17:41:54.136]                       }
[17:41:54.136]                       invisible(muffled)
[17:41:54.136]                     }
[17:41:54.136]                     muffleCondition(cond, pattern = "^muffle")
[17:41:54.136]                   }
[17:41:54.136]                 }
[17:41:54.136]                 else {
[17:41:54.136]                   if (TRUE) {
[17:41:54.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.136]                     {
[17:41:54.136]                       inherits <- base::inherits
[17:41:54.136]                       invokeRestart <- base::invokeRestart
[17:41:54.136]                       is.null <- base::is.null
[17:41:54.136]                       muffled <- FALSE
[17:41:54.136]                       if (inherits(cond, "message")) {
[17:41:54.136]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:54.136]                         if (muffled) 
[17:41:54.136]                           invokeRestart("muffleMessage")
[17:41:54.136]                       }
[17:41:54.136]                       else if (inherits(cond, "warning")) {
[17:41:54.136]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:54.136]                         if (muffled) 
[17:41:54.136]                           invokeRestart("muffleWarning")
[17:41:54.136]                       }
[17:41:54.136]                       else if (inherits(cond, "condition")) {
[17:41:54.136]                         if (!is.null(pattern)) {
[17:41:54.136]                           computeRestarts <- base::computeRestarts
[17:41:54.136]                           grepl <- base::grepl
[17:41:54.136]                           restarts <- computeRestarts(cond)
[17:41:54.136]                           for (restart in restarts) {
[17:41:54.136]                             name <- restart$name
[17:41:54.136]                             if (is.null(name)) 
[17:41:54.136]                               next
[17:41:54.136]                             if (!grepl(pattern, name)) 
[17:41:54.136]                               next
[17:41:54.136]                             invokeRestart(restart)
[17:41:54.136]                             muffled <- TRUE
[17:41:54.136]                             break
[17:41:54.136]                           }
[17:41:54.136]                         }
[17:41:54.136]                       }
[17:41:54.136]                       invisible(muffled)
[17:41:54.136]                     }
[17:41:54.136]                     muffleCondition(cond, pattern = "^muffle")
[17:41:54.136]                   }
[17:41:54.136]                 }
[17:41:54.136]             }
[17:41:54.136]         }))
[17:41:54.136]     }, error = function(ex) {
[17:41:54.136]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:54.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:54.136]                 ...future.rng), started = ...future.startTime, 
[17:41:54.136]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:54.136]             version = "1.8"), class = "FutureResult")
[17:41:54.136]     }, finally = {
[17:41:54.136]         if (!identical(...future.workdir, getwd())) 
[17:41:54.136]             setwd(...future.workdir)
[17:41:54.136]         {
[17:41:54.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:54.136]                 ...future.oldOptions$nwarnings <- NULL
[17:41:54.136]             }
[17:41:54.136]             base::options(...future.oldOptions)
[17:41:54.136]             if (.Platform$OS.type == "windows") {
[17:41:54.136]                 old_names <- names(...future.oldEnvVars)
[17:41:54.136]                 envs <- base::Sys.getenv()
[17:41:54.136]                 names <- names(envs)
[17:41:54.136]                 common <- intersect(names, old_names)
[17:41:54.136]                 added <- setdiff(names, old_names)
[17:41:54.136]                 removed <- setdiff(old_names, names)
[17:41:54.136]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:54.136]                   envs[common]]
[17:41:54.136]                 NAMES <- toupper(changed)
[17:41:54.136]                 args <- list()
[17:41:54.136]                 for (kk in seq_along(NAMES)) {
[17:41:54.136]                   name <- changed[[kk]]
[17:41:54.136]                   NAME <- NAMES[[kk]]
[17:41:54.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.136]                     next
[17:41:54.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:54.136]                 }
[17:41:54.136]                 NAMES <- toupper(added)
[17:41:54.136]                 for (kk in seq_along(NAMES)) {
[17:41:54.136]                   name <- added[[kk]]
[17:41:54.136]                   NAME <- NAMES[[kk]]
[17:41:54.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.136]                     next
[17:41:54.136]                   args[[name]] <- ""
[17:41:54.136]                 }
[17:41:54.136]                 NAMES <- toupper(removed)
[17:41:54.136]                 for (kk in seq_along(NAMES)) {
[17:41:54.136]                   name <- removed[[kk]]
[17:41:54.136]                   NAME <- NAMES[[kk]]
[17:41:54.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.136]                     next
[17:41:54.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:54.136]                 }
[17:41:54.136]                 if (length(args) > 0) 
[17:41:54.136]                   base::do.call(base::Sys.setenv, args = args)
[17:41:54.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:54.136]             }
[17:41:54.136]             else {
[17:41:54.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:54.136]             }
[17:41:54.136]             {
[17:41:54.136]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:54.136]                   0L) {
[17:41:54.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:54.136]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:54.136]                   base::options(opts)
[17:41:54.136]                 }
[17:41:54.136]                 {
[17:41:54.136]                   {
[17:41:54.136]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:54.136]                     NULL
[17:41:54.136]                   }
[17:41:54.136]                   options(future.plan = NULL)
[17:41:54.136]                   if (is.na(NA_character_)) 
[17:41:54.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:54.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:54.136]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:54.136]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:54.136]                     envir = parent.frame()) 
[17:41:54.136]                   {
[17:41:54.136]                     if (is.function(workers)) 
[17:41:54.136]                       workers <- workers()
[17:41:54.136]                     workers <- structure(as.integer(workers), 
[17:41:54.136]                       class = class(workers))
[17:41:54.136]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:54.136]                       workers >= 1)
[17:41:54.136]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:54.136]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:54.136]                     }
[17:41:54.136]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:54.136]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:54.136]                       envir = envir)
[17:41:54.136]                     if (!future$lazy) 
[17:41:54.136]                       future <- run(future)
[17:41:54.136]                     invisible(future)
[17:41:54.136]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:54.136]                 }
[17:41:54.136]             }
[17:41:54.136]         }
[17:41:54.136]     })
[17:41:54.136]     if (TRUE) {
[17:41:54.136]         base::sink(type = "output", split = FALSE)
[17:41:54.136]         if (TRUE) {
[17:41:54.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:54.136]         }
[17:41:54.136]         else {
[17:41:54.136]             ...future.result["stdout"] <- base::list(NULL)
[17:41:54.136]         }
[17:41:54.136]         base::close(...future.stdout)
[17:41:54.136]         ...future.stdout <- NULL
[17:41:54.136]     }
[17:41:54.136]     ...future.result$conditions <- ...future.conditions
[17:41:54.136]     ...future.result$finished <- base::Sys.time()
[17:41:54.136]     ...future.result
[17:41:54.136] }
[17:41:54.141] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:41:54.141] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:41:54.141] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:41:54.142] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[17:41:54.142] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[17:41:54.142] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:41:54.143] MultisessionFuture started
[17:41:54.143] - Launch lazy future ... done
[17:41:54.143] run() for ‘MultisessionFuture’ ... done
[17:41:54.143] result() for ClusterFuture ...
[17:41:54.143] receiveMessageFromWorker() for ClusterFuture ...
[17:41:54.143] - Validating connection of MultisessionFuture
[17:41:54.188] - received message: FutureResult
[17:41:54.188] - Received FutureResult
[17:41:54.188] - Erased future from FutureRegistry
[17:41:54.189] result() for ClusterFuture ...
[17:41:54.189] - result already collected: FutureResult
[17:41:54.189] result() for ClusterFuture ... done
[17:41:54.189] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:54.189] result() for ClusterFuture ... done
[17:41:54.189] result() for ClusterFuture ...
[17:41:54.189] - result already collected: FutureResult
[17:41:54.189] result() for ClusterFuture ... done
[1] 6
** Sum function 'D' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x55bfd9c698d0>
Arguments '...' exists: FALSE
[17:41:54.190] getGlobalsAndPackages() ...
[17:41:54.190] Searching for globals...
[17:41:54.191] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[17:41:54.192] Searching for globals ... DONE
[17:41:54.192] Resolving globals: FALSE
[17:41:54.192] Tweak future expression to call with '...' arguments ...
[17:41:54.192] The total size of the 2 globals is 112 bytes (112 bytes)
[17:41:54.193] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:41:54.193] - globals: [2] ‘x’, ‘y’
[17:41:54.193] 
[17:41:54.193] getGlobalsAndPackages() ... DONE
[17:41:54.193] run() for ‘Future’ ...
[17:41:54.193] - state: ‘created’
[17:41:54.193] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:54.208] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:54.208] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:54.208]   - Field: ‘node’
[17:41:54.209]   - Field: ‘label’
[17:41:54.209]   - Field: ‘local’
[17:41:54.209]   - Field: ‘owner’
[17:41:54.209]   - Field: ‘envir’
[17:41:54.209]   - Field: ‘workers’
[17:41:54.209]   - Field: ‘packages’
[17:41:54.209]   - Field: ‘gc’
[17:41:54.209]   - Field: ‘conditions’
[17:41:54.209]   - Field: ‘persistent’
[17:41:54.209]   - Field: ‘expr’
[17:41:54.210]   - Field: ‘uuid’
[17:41:54.210]   - Field: ‘seed’
[17:41:54.210]   - Field: ‘version’
[17:41:54.210]   - Field: ‘result’
[17:41:54.210]   - Field: ‘asynchronous’
[17:41:54.210]   - Field: ‘calls’
[17:41:54.210]   - Field: ‘globals’
[17:41:54.210]   - Field: ‘stdout’
[17:41:54.210]   - Field: ‘earlySignal’
[17:41:54.210]   - Field: ‘lazy’
[17:41:54.210]   - Field: ‘state’
[17:41:54.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:54.211] - Launch lazy future ...
[17:41:54.211] Packages needed by the future expression (n = 0): <none>
[17:41:54.211] Packages needed by future strategies (n = 0): <none>
[17:41:54.212] {
[17:41:54.212]     {
[17:41:54.212]         {
[17:41:54.212]             ...future.startTime <- base::Sys.time()
[17:41:54.212]             {
[17:41:54.212]                 {
[17:41:54.212]                   {
[17:41:54.212]                     {
[17:41:54.212]                       base::local({
[17:41:54.212]                         has_future <- base::requireNamespace("future", 
[17:41:54.212]                           quietly = TRUE)
[17:41:54.212]                         if (has_future) {
[17:41:54.212]                           ns <- base::getNamespace("future")
[17:41:54.212]                           version <- ns[[".package"]][["version"]]
[17:41:54.212]                           if (is.null(version)) 
[17:41:54.212]                             version <- utils::packageVersion("future")
[17:41:54.212]                         }
[17:41:54.212]                         else {
[17:41:54.212]                           version <- NULL
[17:41:54.212]                         }
[17:41:54.212]                         if (!has_future || version < "1.8.0") {
[17:41:54.212]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:54.212]                             "", base::R.version$version.string), 
[17:41:54.212]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:54.212]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:54.212]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:54.212]                               "release", "version")], collapse = " "), 
[17:41:54.212]                             hostname = base::Sys.info()[["nodename"]])
[17:41:54.212]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:54.212]                             info)
[17:41:54.212]                           info <- base::paste(info, collapse = "; ")
[17:41:54.212]                           if (!has_future) {
[17:41:54.212]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:54.212]                               info)
[17:41:54.212]                           }
[17:41:54.212]                           else {
[17:41:54.212]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:54.212]                               info, version)
[17:41:54.212]                           }
[17:41:54.212]                           base::stop(msg)
[17:41:54.212]                         }
[17:41:54.212]                       })
[17:41:54.212]                     }
[17:41:54.212]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:54.212]                     base::options(mc.cores = 1L)
[17:41:54.212]                   }
[17:41:54.212]                   options(future.plan = NULL)
[17:41:54.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:54.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:54.212]                 }
[17:41:54.212]                 ...future.workdir <- getwd()
[17:41:54.212]             }
[17:41:54.212]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:54.212]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:54.212]         }
[17:41:54.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:54.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:54.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:54.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:54.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:54.212]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:54.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:54.212]             base::names(...future.oldOptions))
[17:41:54.212]     }
[17:41:54.212]     if (FALSE) {
[17:41:54.212]     }
[17:41:54.212]     else {
[17:41:54.212]         if (TRUE) {
[17:41:54.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:54.212]                 open = "w")
[17:41:54.212]         }
[17:41:54.212]         else {
[17:41:54.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:54.212]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:54.212]         }
[17:41:54.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:54.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:54.212]             base::sink(type = "output", split = FALSE)
[17:41:54.212]             base::close(...future.stdout)
[17:41:54.212]         }, add = TRUE)
[17:41:54.212]     }
[17:41:54.212]     ...future.frame <- base::sys.nframe()
[17:41:54.212]     ...future.conditions <- base::list()
[17:41:54.212]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:54.212]     if (FALSE) {
[17:41:54.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:54.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:54.212]     }
[17:41:54.212]     ...future.result <- base::tryCatch({
[17:41:54.212]         base::withCallingHandlers({
[17:41:54.212]             ...future.value <- base::withVisible(base::local({
[17:41:54.212]                 ...future.makeSendCondition <- local({
[17:41:54.212]                   sendCondition <- NULL
[17:41:54.212]                   function(frame = 1L) {
[17:41:54.212]                     if (is.function(sendCondition)) 
[17:41:54.212]                       return(sendCondition)
[17:41:54.212]                     ns <- getNamespace("parallel")
[17:41:54.212]                     if (exists("sendData", mode = "function", 
[17:41:54.212]                       envir = ns)) {
[17:41:54.212]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:54.212]                         envir = ns)
[17:41:54.212]                       envir <- sys.frame(frame)
[17:41:54.212]                       master <- NULL
[17:41:54.212]                       while (!identical(envir, .GlobalEnv) && 
[17:41:54.212]                         !identical(envir, emptyenv())) {
[17:41:54.212]                         if (exists("master", mode = "list", envir = envir, 
[17:41:54.212]                           inherits = FALSE)) {
[17:41:54.212]                           master <- get("master", mode = "list", 
[17:41:54.212]                             envir = envir, inherits = FALSE)
[17:41:54.212]                           if (inherits(master, c("SOCKnode", 
[17:41:54.212]                             "SOCK0node"))) {
[17:41:54.212]                             sendCondition <<- function(cond) {
[17:41:54.212]                               data <- list(type = "VALUE", value = cond, 
[17:41:54.212]                                 success = TRUE)
[17:41:54.212]                               parallel_sendData(master, data)
[17:41:54.212]                             }
[17:41:54.212]                             return(sendCondition)
[17:41:54.212]                           }
[17:41:54.212]                         }
[17:41:54.212]                         frame <- frame + 1L
[17:41:54.212]                         envir <- sys.frame(frame)
[17:41:54.212]                       }
[17:41:54.212]                     }
[17:41:54.212]                     sendCondition <<- function(cond) NULL
[17:41:54.212]                   }
[17:41:54.212]                 })
[17:41:54.212]                 withCallingHandlers({
[17:41:54.212]                   {
[17:41:54.212]                     sum(x, y, ...)
[17:41:54.212]                   }
[17:41:54.212]                 }, immediateCondition = function(cond) {
[17:41:54.212]                   sendCondition <- ...future.makeSendCondition()
[17:41:54.212]                   sendCondition(cond)
[17:41:54.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.212]                   {
[17:41:54.212]                     inherits <- base::inherits
[17:41:54.212]                     invokeRestart <- base::invokeRestart
[17:41:54.212]                     is.null <- base::is.null
[17:41:54.212]                     muffled <- FALSE
[17:41:54.212]                     if (inherits(cond, "message")) {
[17:41:54.212]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:54.212]                       if (muffled) 
[17:41:54.212]                         invokeRestart("muffleMessage")
[17:41:54.212]                     }
[17:41:54.212]                     else if (inherits(cond, "warning")) {
[17:41:54.212]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:54.212]                       if (muffled) 
[17:41:54.212]                         invokeRestart("muffleWarning")
[17:41:54.212]                     }
[17:41:54.212]                     else if (inherits(cond, "condition")) {
[17:41:54.212]                       if (!is.null(pattern)) {
[17:41:54.212]                         computeRestarts <- base::computeRestarts
[17:41:54.212]                         grepl <- base::grepl
[17:41:54.212]                         restarts <- computeRestarts(cond)
[17:41:54.212]                         for (restart in restarts) {
[17:41:54.212]                           name <- restart$name
[17:41:54.212]                           if (is.null(name)) 
[17:41:54.212]                             next
[17:41:54.212]                           if (!grepl(pattern, name)) 
[17:41:54.212]                             next
[17:41:54.212]                           invokeRestart(restart)
[17:41:54.212]                           muffled <- TRUE
[17:41:54.212]                           break
[17:41:54.212]                         }
[17:41:54.212]                       }
[17:41:54.212]                     }
[17:41:54.212]                     invisible(muffled)
[17:41:54.212]                   }
[17:41:54.212]                   muffleCondition(cond)
[17:41:54.212]                 })
[17:41:54.212]             }))
[17:41:54.212]             future::FutureResult(value = ...future.value$value, 
[17:41:54.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:54.212]                   ...future.rng), globalenv = if (FALSE) 
[17:41:54.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:54.212]                     ...future.globalenv.names))
[17:41:54.212]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:54.212]         }, condition = base::local({
[17:41:54.212]             c <- base::c
[17:41:54.212]             inherits <- base::inherits
[17:41:54.212]             invokeRestart <- base::invokeRestart
[17:41:54.212]             length <- base::length
[17:41:54.212]             list <- base::list
[17:41:54.212]             seq.int <- base::seq.int
[17:41:54.212]             signalCondition <- base::signalCondition
[17:41:54.212]             sys.calls <- base::sys.calls
[17:41:54.212]             `[[` <- base::`[[`
[17:41:54.212]             `+` <- base::`+`
[17:41:54.212]             `<<-` <- base::`<<-`
[17:41:54.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:54.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:54.212]                   3L)]
[17:41:54.212]             }
[17:41:54.212]             function(cond) {
[17:41:54.212]                 is_error <- inherits(cond, "error")
[17:41:54.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:54.212]                   NULL)
[17:41:54.212]                 if (is_error) {
[17:41:54.212]                   sessionInformation <- function() {
[17:41:54.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:54.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:54.212]                       search = base::search(), system = base::Sys.info())
[17:41:54.212]                   }
[17:41:54.212]                   ...future.conditions[[length(...future.conditions) + 
[17:41:54.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:54.212]                     cond$call), session = sessionInformation(), 
[17:41:54.212]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:54.212]                   signalCondition(cond)
[17:41:54.212]                 }
[17:41:54.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:54.212]                 "immediateCondition"))) {
[17:41:54.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:54.212]                   ...future.conditions[[length(...future.conditions) + 
[17:41:54.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:54.212]                   if (TRUE && !signal) {
[17:41:54.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.212]                     {
[17:41:54.212]                       inherits <- base::inherits
[17:41:54.212]                       invokeRestart <- base::invokeRestart
[17:41:54.212]                       is.null <- base::is.null
[17:41:54.212]                       muffled <- FALSE
[17:41:54.212]                       if (inherits(cond, "message")) {
[17:41:54.212]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:54.212]                         if (muffled) 
[17:41:54.212]                           invokeRestart("muffleMessage")
[17:41:54.212]                       }
[17:41:54.212]                       else if (inherits(cond, "warning")) {
[17:41:54.212]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:54.212]                         if (muffled) 
[17:41:54.212]                           invokeRestart("muffleWarning")
[17:41:54.212]                       }
[17:41:54.212]                       else if (inherits(cond, "condition")) {
[17:41:54.212]                         if (!is.null(pattern)) {
[17:41:54.212]                           computeRestarts <- base::computeRestarts
[17:41:54.212]                           grepl <- base::grepl
[17:41:54.212]                           restarts <- computeRestarts(cond)
[17:41:54.212]                           for (restart in restarts) {
[17:41:54.212]                             name <- restart$name
[17:41:54.212]                             if (is.null(name)) 
[17:41:54.212]                               next
[17:41:54.212]                             if (!grepl(pattern, name)) 
[17:41:54.212]                               next
[17:41:54.212]                             invokeRestart(restart)
[17:41:54.212]                             muffled <- TRUE
[17:41:54.212]                             break
[17:41:54.212]                           }
[17:41:54.212]                         }
[17:41:54.212]                       }
[17:41:54.212]                       invisible(muffled)
[17:41:54.212]                     }
[17:41:54.212]                     muffleCondition(cond, pattern = "^muffle")
[17:41:54.212]                   }
[17:41:54.212]                 }
[17:41:54.212]                 else {
[17:41:54.212]                   if (TRUE) {
[17:41:54.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.212]                     {
[17:41:54.212]                       inherits <- base::inherits
[17:41:54.212]                       invokeRestart <- base::invokeRestart
[17:41:54.212]                       is.null <- base::is.null
[17:41:54.212]                       muffled <- FALSE
[17:41:54.212]                       if (inherits(cond, "message")) {
[17:41:54.212]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:54.212]                         if (muffled) 
[17:41:54.212]                           invokeRestart("muffleMessage")
[17:41:54.212]                       }
[17:41:54.212]                       else if (inherits(cond, "warning")) {
[17:41:54.212]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:54.212]                         if (muffled) 
[17:41:54.212]                           invokeRestart("muffleWarning")
[17:41:54.212]                       }
[17:41:54.212]                       else if (inherits(cond, "condition")) {
[17:41:54.212]                         if (!is.null(pattern)) {
[17:41:54.212]                           computeRestarts <- base::computeRestarts
[17:41:54.212]                           grepl <- base::grepl
[17:41:54.212]                           restarts <- computeRestarts(cond)
[17:41:54.212]                           for (restart in restarts) {
[17:41:54.212]                             name <- restart$name
[17:41:54.212]                             if (is.null(name)) 
[17:41:54.212]                               next
[17:41:54.212]                             if (!grepl(pattern, name)) 
[17:41:54.212]                               next
[17:41:54.212]                             invokeRestart(restart)
[17:41:54.212]                             muffled <- TRUE
[17:41:54.212]                             break
[17:41:54.212]                           }
[17:41:54.212]                         }
[17:41:54.212]                       }
[17:41:54.212]                       invisible(muffled)
[17:41:54.212]                     }
[17:41:54.212]                     muffleCondition(cond, pattern = "^muffle")
[17:41:54.212]                   }
[17:41:54.212]                 }
[17:41:54.212]             }
[17:41:54.212]         }))
[17:41:54.212]     }, error = function(ex) {
[17:41:54.212]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:54.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:54.212]                 ...future.rng), started = ...future.startTime, 
[17:41:54.212]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:54.212]             version = "1.8"), class = "FutureResult")
[17:41:54.212]     }, finally = {
[17:41:54.212]         if (!identical(...future.workdir, getwd())) 
[17:41:54.212]             setwd(...future.workdir)
[17:41:54.212]         {
[17:41:54.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:54.212]                 ...future.oldOptions$nwarnings <- NULL
[17:41:54.212]             }
[17:41:54.212]             base::options(...future.oldOptions)
[17:41:54.212]             if (.Platform$OS.type == "windows") {
[17:41:54.212]                 old_names <- names(...future.oldEnvVars)
[17:41:54.212]                 envs <- base::Sys.getenv()
[17:41:54.212]                 names <- names(envs)
[17:41:54.212]                 common <- intersect(names, old_names)
[17:41:54.212]                 added <- setdiff(names, old_names)
[17:41:54.212]                 removed <- setdiff(old_names, names)
[17:41:54.212]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:54.212]                   envs[common]]
[17:41:54.212]                 NAMES <- toupper(changed)
[17:41:54.212]                 args <- list()
[17:41:54.212]                 for (kk in seq_along(NAMES)) {
[17:41:54.212]                   name <- changed[[kk]]
[17:41:54.212]                   NAME <- NAMES[[kk]]
[17:41:54.212]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.212]                     next
[17:41:54.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:54.212]                 }
[17:41:54.212]                 NAMES <- toupper(added)
[17:41:54.212]                 for (kk in seq_along(NAMES)) {
[17:41:54.212]                   name <- added[[kk]]
[17:41:54.212]                   NAME <- NAMES[[kk]]
[17:41:54.212]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.212]                     next
[17:41:54.212]                   args[[name]] <- ""
[17:41:54.212]                 }
[17:41:54.212]                 NAMES <- toupper(removed)
[17:41:54.212]                 for (kk in seq_along(NAMES)) {
[17:41:54.212]                   name <- removed[[kk]]
[17:41:54.212]                   NAME <- NAMES[[kk]]
[17:41:54.212]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.212]                     next
[17:41:54.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:54.212]                 }
[17:41:54.212]                 if (length(args) > 0) 
[17:41:54.212]                   base::do.call(base::Sys.setenv, args = args)
[17:41:54.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:54.212]             }
[17:41:54.212]             else {
[17:41:54.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:54.212]             }
[17:41:54.212]             {
[17:41:54.212]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:54.212]                   0L) {
[17:41:54.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:54.212]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:54.212]                   base::options(opts)
[17:41:54.212]                 }
[17:41:54.212]                 {
[17:41:54.212]                   {
[17:41:54.212]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:54.212]                     NULL
[17:41:54.212]                   }
[17:41:54.212]                   options(future.plan = NULL)
[17:41:54.212]                   if (is.na(NA_character_)) 
[17:41:54.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:54.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:54.212]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:54.212]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:54.212]                     envir = parent.frame()) 
[17:41:54.212]                   {
[17:41:54.212]                     if (is.function(workers)) 
[17:41:54.212]                       workers <- workers()
[17:41:54.212]                     workers <- structure(as.integer(workers), 
[17:41:54.212]                       class = class(workers))
[17:41:54.212]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:54.212]                       workers >= 1)
[17:41:54.212]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:54.212]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:54.212]                     }
[17:41:54.212]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:54.212]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:54.212]                       envir = envir)
[17:41:54.212]                     if (!future$lazy) 
[17:41:54.212]                       future <- run(future)
[17:41:54.212]                     invisible(future)
[17:41:54.212]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:54.212]                 }
[17:41:54.212]             }
[17:41:54.212]         }
[17:41:54.212]     })
[17:41:54.212]     if (TRUE) {
[17:41:54.212]         base::sink(type = "output", split = FALSE)
[17:41:54.212]         if (TRUE) {
[17:41:54.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:54.212]         }
[17:41:54.212]         else {
[17:41:54.212]             ...future.result["stdout"] <- base::list(NULL)
[17:41:54.212]         }
[17:41:54.212]         base::close(...future.stdout)
[17:41:54.212]         ...future.stdout <- NULL
[17:41:54.212]     }
[17:41:54.212]     ...future.result$conditions <- ...future.conditions
[17:41:54.212]     ...future.result$finished <- base::Sys.time()
[17:41:54.212]     ...future.result
[17:41:54.212] }
[17:41:54.214] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:41:54.215] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:41:54.215] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:41:54.215] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[17:41:54.215] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[17:41:54.216] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:41:54.216] MultisessionFuture started
[17:41:54.216] - Launch lazy future ... done
[17:41:54.216] run() for ‘MultisessionFuture’ ... done
[17:41:54.217] result() for ClusterFuture ...
[17:41:54.217] receiveMessageFromWorker() for ClusterFuture ...
[17:41:54.217] - Validating connection of MultisessionFuture
[17:41:54.265] - received message: FutureResult
[17:41:54.266] - Received FutureResult
[17:41:54.266] - Erased future from FutureRegistry
[17:41:54.266] result() for ClusterFuture ...
[17:41:54.266] - result already collected: FutureResult
[17:41:54.266] result() for ClusterFuture ... done
[17:41:54.266] signalConditions() ...
[17:41:54.266]  - include = ‘immediateCondition’
[17:41:54.266]  - exclude = 
[17:41:54.266]  - resignal = FALSE
[17:41:54.266]  - Number of conditions: 1
[17:41:54.267] signalConditions() ... done
[17:41:54.267] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:54.267] result() for ClusterFuture ... done
[17:41:54.267] result() for ClusterFuture ...
[17:41:54.267] - result already collected: FutureResult
[17:41:54.267] result() for ClusterFuture ... done
[17:41:54.267] signalConditions() ...
[17:41:54.267]  - include = ‘immediateCondition’
[17:41:54.267]  - exclude = 
[17:41:54.267]  - resignal = FALSE
[17:41:54.267]  - Number of conditions: 1
[17:41:54.268] signalConditions() ... done
[17:41:54.268] Future state: ‘finished’
[17:41:54.268] result() for ClusterFuture ...
[17:41:54.268] - result already collected: FutureResult
[17:41:54.268] result() for ClusterFuture ... done
[17:41:54.268] signalConditions() ...
[17:41:54.268]  - include = ‘condition’
[17:41:54.268]  - exclude = ‘immediateCondition’
[17:41:54.268]  - resignal = TRUE
[17:41:54.268]  - Number of conditions: 1
[17:41:54.269]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:41:54.269] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multisession') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x55bfdac31dd0>
Arguments '...' exists: TRUE
[17:41:54.270] getGlobalsAndPackages() ...
[17:41:54.270] - globals passed as-is: [1] ‘...’
[17:41:54.270] Resolving globals: FALSE
[17:41:54.270] Tweak future expression to call with '...' arguments ...
[17:41:54.270] {
[17:41:54.270]     do.call(function(...) {
[17:41:54.270]         fcn <- function() sum(...)
[17:41:54.270]         fcn()
[17:41:54.270]     }, args = future.call.arguments)
[17:41:54.270] }
[17:41:54.270] Tweak future expression to call with '...' arguments ... DONE
[17:41:54.271] The total size of the 1 globals is 112 bytes (112 bytes)
[17:41:54.271] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[17:41:54.271] - globals: [1] ‘future.call.arguments’
[17:41:54.271] 
[17:41:54.272] getGlobalsAndPackages() ... DONE
[17:41:54.272] run() for ‘Future’ ...
[17:41:54.272] - state: ‘created’
[17:41:54.272] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:54.287] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:54.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:54.287]   - Field: ‘node’
[17:41:54.288]   - Field: ‘label’
[17:41:54.288]   - Field: ‘local’
[17:41:54.288]   - Field: ‘owner’
[17:41:54.288]   - Field: ‘envir’
[17:41:54.288]   - Field: ‘workers’
[17:41:54.288]   - Field: ‘packages’
[17:41:54.288]   - Field: ‘gc’
[17:41:54.288]   - Field: ‘conditions’
[17:41:54.288]   - Field: ‘persistent’
[17:41:54.288]   - Field: ‘expr’
[17:41:54.288]   - Field: ‘uuid’
[17:41:54.289]   - Field: ‘seed’
[17:41:54.289]   - Field: ‘version’
[17:41:54.289]   - Field: ‘result’
[17:41:54.289]   - Field: ‘asynchronous’
[17:41:54.289]   - Field: ‘calls’
[17:41:54.289]   - Field: ‘globals’
[17:41:54.289]   - Field: ‘stdout’
[17:41:54.289]   - Field: ‘earlySignal’
[17:41:54.289]   - Field: ‘lazy’
[17:41:54.289]   - Field: ‘state’
[17:41:54.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:54.290] - Launch lazy future ...
[17:41:54.290] Packages needed by the future expression (n = 0): <none>
[17:41:54.290] Packages needed by future strategies (n = 0): <none>
[17:41:54.290] {
[17:41:54.290]     {
[17:41:54.290]         {
[17:41:54.290]             ...future.startTime <- base::Sys.time()
[17:41:54.290]             {
[17:41:54.290]                 {
[17:41:54.290]                   {
[17:41:54.290]                     {
[17:41:54.290]                       base::local({
[17:41:54.290]                         has_future <- base::requireNamespace("future", 
[17:41:54.290]                           quietly = TRUE)
[17:41:54.290]                         if (has_future) {
[17:41:54.290]                           ns <- base::getNamespace("future")
[17:41:54.290]                           version <- ns[[".package"]][["version"]]
[17:41:54.290]                           if (is.null(version)) 
[17:41:54.290]                             version <- utils::packageVersion("future")
[17:41:54.290]                         }
[17:41:54.290]                         else {
[17:41:54.290]                           version <- NULL
[17:41:54.290]                         }
[17:41:54.290]                         if (!has_future || version < "1.8.0") {
[17:41:54.290]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:54.290]                             "", base::R.version$version.string), 
[17:41:54.290]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:54.290]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:54.290]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:54.290]                               "release", "version")], collapse = " "), 
[17:41:54.290]                             hostname = base::Sys.info()[["nodename"]])
[17:41:54.290]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:54.290]                             info)
[17:41:54.290]                           info <- base::paste(info, collapse = "; ")
[17:41:54.290]                           if (!has_future) {
[17:41:54.290]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:54.290]                               info)
[17:41:54.290]                           }
[17:41:54.290]                           else {
[17:41:54.290]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:54.290]                               info, version)
[17:41:54.290]                           }
[17:41:54.290]                           base::stop(msg)
[17:41:54.290]                         }
[17:41:54.290]                       })
[17:41:54.290]                     }
[17:41:54.290]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:54.290]                     base::options(mc.cores = 1L)
[17:41:54.290]                   }
[17:41:54.290]                   options(future.plan = NULL)
[17:41:54.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:54.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:54.290]                 }
[17:41:54.290]                 ...future.workdir <- getwd()
[17:41:54.290]             }
[17:41:54.290]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:54.290]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:54.290]         }
[17:41:54.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:54.290]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:54.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:54.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:54.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:54.290]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:54.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:54.290]             base::names(...future.oldOptions))
[17:41:54.290]     }
[17:41:54.290]     if (FALSE) {
[17:41:54.290]     }
[17:41:54.290]     else {
[17:41:54.290]         if (TRUE) {
[17:41:54.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:54.290]                 open = "w")
[17:41:54.290]         }
[17:41:54.290]         else {
[17:41:54.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:54.290]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:54.290]         }
[17:41:54.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:54.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:54.290]             base::sink(type = "output", split = FALSE)
[17:41:54.290]             base::close(...future.stdout)
[17:41:54.290]         }, add = TRUE)
[17:41:54.290]     }
[17:41:54.290]     ...future.frame <- base::sys.nframe()
[17:41:54.290]     ...future.conditions <- base::list()
[17:41:54.290]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:54.290]     if (FALSE) {
[17:41:54.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:54.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:54.290]     }
[17:41:54.290]     ...future.result <- base::tryCatch({
[17:41:54.290]         base::withCallingHandlers({
[17:41:54.290]             ...future.value <- base::withVisible(base::local({
[17:41:54.290]                 ...future.makeSendCondition <- local({
[17:41:54.290]                   sendCondition <- NULL
[17:41:54.290]                   function(frame = 1L) {
[17:41:54.290]                     if (is.function(sendCondition)) 
[17:41:54.290]                       return(sendCondition)
[17:41:54.290]                     ns <- getNamespace("parallel")
[17:41:54.290]                     if (exists("sendData", mode = "function", 
[17:41:54.290]                       envir = ns)) {
[17:41:54.290]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:54.290]                         envir = ns)
[17:41:54.290]                       envir <- sys.frame(frame)
[17:41:54.290]                       master <- NULL
[17:41:54.290]                       while (!identical(envir, .GlobalEnv) && 
[17:41:54.290]                         !identical(envir, emptyenv())) {
[17:41:54.290]                         if (exists("master", mode = "list", envir = envir, 
[17:41:54.290]                           inherits = FALSE)) {
[17:41:54.290]                           master <- get("master", mode = "list", 
[17:41:54.290]                             envir = envir, inherits = FALSE)
[17:41:54.290]                           if (inherits(master, c("SOCKnode", 
[17:41:54.290]                             "SOCK0node"))) {
[17:41:54.290]                             sendCondition <<- function(cond) {
[17:41:54.290]                               data <- list(type = "VALUE", value = cond, 
[17:41:54.290]                                 success = TRUE)
[17:41:54.290]                               parallel_sendData(master, data)
[17:41:54.290]                             }
[17:41:54.290]                             return(sendCondition)
[17:41:54.290]                           }
[17:41:54.290]                         }
[17:41:54.290]                         frame <- frame + 1L
[17:41:54.290]                         envir <- sys.frame(frame)
[17:41:54.290]                       }
[17:41:54.290]                     }
[17:41:54.290]                     sendCondition <<- function(cond) NULL
[17:41:54.290]                   }
[17:41:54.290]                 })
[17:41:54.290]                 withCallingHandlers({
[17:41:54.290]                   {
[17:41:54.290]                     do.call(function(...) {
[17:41:54.290]                       fcn <- function() sum(...)
[17:41:54.290]                       fcn()
[17:41:54.290]                     }, args = future.call.arguments)
[17:41:54.290]                   }
[17:41:54.290]                 }, immediateCondition = function(cond) {
[17:41:54.290]                   sendCondition <- ...future.makeSendCondition()
[17:41:54.290]                   sendCondition(cond)
[17:41:54.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.290]                   {
[17:41:54.290]                     inherits <- base::inherits
[17:41:54.290]                     invokeRestart <- base::invokeRestart
[17:41:54.290]                     is.null <- base::is.null
[17:41:54.290]                     muffled <- FALSE
[17:41:54.290]                     if (inherits(cond, "message")) {
[17:41:54.290]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:54.290]                       if (muffled) 
[17:41:54.290]                         invokeRestart("muffleMessage")
[17:41:54.290]                     }
[17:41:54.290]                     else if (inherits(cond, "warning")) {
[17:41:54.290]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:54.290]                       if (muffled) 
[17:41:54.290]                         invokeRestart("muffleWarning")
[17:41:54.290]                     }
[17:41:54.290]                     else if (inherits(cond, "condition")) {
[17:41:54.290]                       if (!is.null(pattern)) {
[17:41:54.290]                         computeRestarts <- base::computeRestarts
[17:41:54.290]                         grepl <- base::grepl
[17:41:54.290]                         restarts <- computeRestarts(cond)
[17:41:54.290]                         for (restart in restarts) {
[17:41:54.290]                           name <- restart$name
[17:41:54.290]                           if (is.null(name)) 
[17:41:54.290]                             next
[17:41:54.290]                           if (!grepl(pattern, name)) 
[17:41:54.290]                             next
[17:41:54.290]                           invokeRestart(restart)
[17:41:54.290]                           muffled <- TRUE
[17:41:54.290]                           break
[17:41:54.290]                         }
[17:41:54.290]                       }
[17:41:54.290]                     }
[17:41:54.290]                     invisible(muffled)
[17:41:54.290]                   }
[17:41:54.290]                   muffleCondition(cond)
[17:41:54.290]                 })
[17:41:54.290]             }))
[17:41:54.290]             future::FutureResult(value = ...future.value$value, 
[17:41:54.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:54.290]                   ...future.rng), globalenv = if (FALSE) 
[17:41:54.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:54.290]                     ...future.globalenv.names))
[17:41:54.290]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:54.290]         }, condition = base::local({
[17:41:54.290]             c <- base::c
[17:41:54.290]             inherits <- base::inherits
[17:41:54.290]             invokeRestart <- base::invokeRestart
[17:41:54.290]             length <- base::length
[17:41:54.290]             list <- base::list
[17:41:54.290]             seq.int <- base::seq.int
[17:41:54.290]             signalCondition <- base::signalCondition
[17:41:54.290]             sys.calls <- base::sys.calls
[17:41:54.290]             `[[` <- base::`[[`
[17:41:54.290]             `+` <- base::`+`
[17:41:54.290]             `<<-` <- base::`<<-`
[17:41:54.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:54.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:54.290]                   3L)]
[17:41:54.290]             }
[17:41:54.290]             function(cond) {
[17:41:54.290]                 is_error <- inherits(cond, "error")
[17:41:54.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:54.290]                   NULL)
[17:41:54.290]                 if (is_error) {
[17:41:54.290]                   sessionInformation <- function() {
[17:41:54.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:54.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:54.290]                       search = base::search(), system = base::Sys.info())
[17:41:54.290]                   }
[17:41:54.290]                   ...future.conditions[[length(...future.conditions) + 
[17:41:54.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:54.290]                     cond$call), session = sessionInformation(), 
[17:41:54.290]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:54.290]                   signalCondition(cond)
[17:41:54.290]                 }
[17:41:54.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:54.290]                 "immediateCondition"))) {
[17:41:54.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:54.290]                   ...future.conditions[[length(...future.conditions) + 
[17:41:54.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:54.290]                   if (TRUE && !signal) {
[17:41:54.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.290]                     {
[17:41:54.290]                       inherits <- base::inherits
[17:41:54.290]                       invokeRestart <- base::invokeRestart
[17:41:54.290]                       is.null <- base::is.null
[17:41:54.290]                       muffled <- FALSE
[17:41:54.290]                       if (inherits(cond, "message")) {
[17:41:54.290]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:54.290]                         if (muffled) 
[17:41:54.290]                           invokeRestart("muffleMessage")
[17:41:54.290]                       }
[17:41:54.290]                       else if (inherits(cond, "warning")) {
[17:41:54.290]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:54.290]                         if (muffled) 
[17:41:54.290]                           invokeRestart("muffleWarning")
[17:41:54.290]                       }
[17:41:54.290]                       else if (inherits(cond, "condition")) {
[17:41:54.290]                         if (!is.null(pattern)) {
[17:41:54.290]                           computeRestarts <- base::computeRestarts
[17:41:54.290]                           grepl <- base::grepl
[17:41:54.290]                           restarts <- computeRestarts(cond)
[17:41:54.290]                           for (restart in restarts) {
[17:41:54.290]                             name <- restart$name
[17:41:54.290]                             if (is.null(name)) 
[17:41:54.290]                               next
[17:41:54.290]                             if (!grepl(pattern, name)) 
[17:41:54.290]                               next
[17:41:54.290]                             invokeRestart(restart)
[17:41:54.290]                             muffled <- TRUE
[17:41:54.290]                             break
[17:41:54.290]                           }
[17:41:54.290]                         }
[17:41:54.290]                       }
[17:41:54.290]                       invisible(muffled)
[17:41:54.290]                     }
[17:41:54.290]                     muffleCondition(cond, pattern = "^muffle")
[17:41:54.290]                   }
[17:41:54.290]                 }
[17:41:54.290]                 else {
[17:41:54.290]                   if (TRUE) {
[17:41:54.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.290]                     {
[17:41:54.290]                       inherits <- base::inherits
[17:41:54.290]                       invokeRestart <- base::invokeRestart
[17:41:54.290]                       is.null <- base::is.null
[17:41:54.290]                       muffled <- FALSE
[17:41:54.290]                       if (inherits(cond, "message")) {
[17:41:54.290]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:54.290]                         if (muffled) 
[17:41:54.290]                           invokeRestart("muffleMessage")
[17:41:54.290]                       }
[17:41:54.290]                       else if (inherits(cond, "warning")) {
[17:41:54.290]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:54.290]                         if (muffled) 
[17:41:54.290]                           invokeRestart("muffleWarning")
[17:41:54.290]                       }
[17:41:54.290]                       else if (inherits(cond, "condition")) {
[17:41:54.290]                         if (!is.null(pattern)) {
[17:41:54.290]                           computeRestarts <- base::computeRestarts
[17:41:54.290]                           grepl <- base::grepl
[17:41:54.290]                           restarts <- computeRestarts(cond)
[17:41:54.290]                           for (restart in restarts) {
[17:41:54.290]                             name <- restart$name
[17:41:54.290]                             if (is.null(name)) 
[17:41:54.290]                               next
[17:41:54.290]                             if (!grepl(pattern, name)) 
[17:41:54.290]                               next
[17:41:54.290]                             invokeRestart(restart)
[17:41:54.290]                             muffled <- TRUE
[17:41:54.290]                             break
[17:41:54.290]                           }
[17:41:54.290]                         }
[17:41:54.290]                       }
[17:41:54.290]                       invisible(muffled)
[17:41:54.290]                     }
[17:41:54.290]                     muffleCondition(cond, pattern = "^muffle")
[17:41:54.290]                   }
[17:41:54.290]                 }
[17:41:54.290]             }
[17:41:54.290]         }))
[17:41:54.290]     }, error = function(ex) {
[17:41:54.290]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:54.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:54.290]                 ...future.rng), started = ...future.startTime, 
[17:41:54.290]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:54.290]             version = "1.8"), class = "FutureResult")
[17:41:54.290]     }, finally = {
[17:41:54.290]         if (!identical(...future.workdir, getwd())) 
[17:41:54.290]             setwd(...future.workdir)
[17:41:54.290]         {
[17:41:54.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:54.290]                 ...future.oldOptions$nwarnings <- NULL
[17:41:54.290]             }
[17:41:54.290]             base::options(...future.oldOptions)
[17:41:54.290]             if (.Platform$OS.type == "windows") {
[17:41:54.290]                 old_names <- names(...future.oldEnvVars)
[17:41:54.290]                 envs <- base::Sys.getenv()
[17:41:54.290]                 names <- names(envs)
[17:41:54.290]                 common <- intersect(names, old_names)
[17:41:54.290]                 added <- setdiff(names, old_names)
[17:41:54.290]                 removed <- setdiff(old_names, names)
[17:41:54.290]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:54.290]                   envs[common]]
[17:41:54.290]                 NAMES <- toupper(changed)
[17:41:54.290]                 args <- list()
[17:41:54.290]                 for (kk in seq_along(NAMES)) {
[17:41:54.290]                   name <- changed[[kk]]
[17:41:54.290]                   NAME <- NAMES[[kk]]
[17:41:54.290]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.290]                     next
[17:41:54.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:54.290]                 }
[17:41:54.290]                 NAMES <- toupper(added)
[17:41:54.290]                 for (kk in seq_along(NAMES)) {
[17:41:54.290]                   name <- added[[kk]]
[17:41:54.290]                   NAME <- NAMES[[kk]]
[17:41:54.290]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.290]                     next
[17:41:54.290]                   args[[name]] <- ""
[17:41:54.290]                 }
[17:41:54.290]                 NAMES <- toupper(removed)
[17:41:54.290]                 for (kk in seq_along(NAMES)) {
[17:41:54.290]                   name <- removed[[kk]]
[17:41:54.290]                   NAME <- NAMES[[kk]]
[17:41:54.290]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.290]                     next
[17:41:54.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:54.290]                 }
[17:41:54.290]                 if (length(args) > 0) 
[17:41:54.290]                   base::do.call(base::Sys.setenv, args = args)
[17:41:54.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:54.290]             }
[17:41:54.290]             else {
[17:41:54.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:54.290]             }
[17:41:54.290]             {
[17:41:54.290]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:54.290]                   0L) {
[17:41:54.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:54.290]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:54.290]                   base::options(opts)
[17:41:54.290]                 }
[17:41:54.290]                 {
[17:41:54.290]                   {
[17:41:54.290]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:54.290]                     NULL
[17:41:54.290]                   }
[17:41:54.290]                   options(future.plan = NULL)
[17:41:54.290]                   if (is.na(NA_character_)) 
[17:41:54.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:54.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:54.290]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:54.290]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:54.290]                     envir = parent.frame()) 
[17:41:54.290]                   {
[17:41:54.290]                     if (is.function(workers)) 
[17:41:54.290]                       workers <- workers()
[17:41:54.290]                     workers <- structure(as.integer(workers), 
[17:41:54.290]                       class = class(workers))
[17:41:54.290]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:54.290]                       workers >= 1)
[17:41:54.290]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:54.290]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:54.290]                     }
[17:41:54.290]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:54.290]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:54.290]                       envir = envir)
[17:41:54.290]                     if (!future$lazy) 
[17:41:54.290]                       future <- run(future)
[17:41:54.290]                     invisible(future)
[17:41:54.290]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:54.290]                 }
[17:41:54.290]             }
[17:41:54.290]         }
[17:41:54.290]     })
[17:41:54.290]     if (TRUE) {
[17:41:54.290]         base::sink(type = "output", split = FALSE)
[17:41:54.290]         if (TRUE) {
[17:41:54.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:54.290]         }
[17:41:54.290]         else {
[17:41:54.290]             ...future.result["stdout"] <- base::list(NULL)
[17:41:54.290]         }
[17:41:54.290]         base::close(...future.stdout)
[17:41:54.290]         ...future.stdout <- NULL
[17:41:54.290]     }
[17:41:54.290]     ...future.result$conditions <- ...future.conditions
[17:41:54.290]     ...future.result$finished <- base::Sys.time()
[17:41:54.290]     ...future.result
[17:41:54.290] }
[17:41:54.293] Exporting 1 global objects (112 bytes) to cluster node #1 ...
[17:41:54.294] Exporting ‘future.call.arguments’ (112 bytes) to cluster node #1 ...
[17:41:54.294] Exporting ‘future.call.arguments’ (112 bytes) to cluster node #1 ... DONE
[17:41:54.294] Exporting 1 global objects (112 bytes) to cluster node #1 ... DONE
[17:41:54.295] MultisessionFuture started
[17:41:54.295] - Launch lazy future ... done
[17:41:54.295] run() for ‘MultisessionFuture’ ... done
[17:41:54.295] result() for ClusterFuture ...
[17:41:54.296] receiveMessageFromWorker() for ClusterFuture ...
[17:41:54.296] - Validating connection of MultisessionFuture
[17:41:54.340] - received message: FutureResult
[17:41:54.340] - Received FutureResult
[17:41:54.340] - Erased future from FutureRegistry
[17:41:54.341] result() for ClusterFuture ...
[17:41:54.341] - result already collected: FutureResult
[17:41:54.341] result() for ClusterFuture ... done
[17:41:54.341] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:54.341] result() for ClusterFuture ... done
[17:41:54.341] result() for ClusterFuture ...
[17:41:54.341] - result already collected: FutureResult
[17:41:54.341] result() for ClusterFuture ... done
[1] 6
** Sum function 'F' with plan('multisession') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x55bfdb0ae0f8>
Using '...' in a formula
[17:41:54.342] getGlobalsAndPackages() ...
[17:41:54.342] Searching for globals...
[17:41:54.344] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[17:41:54.345] Searching for globals ... DONE
[17:41:54.345] Resolving globals: FALSE
[17:41:54.345] Tweak future expression to call with '...' arguments ...
[17:41:54.345] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[17:41:54.346] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:41:54.346] - globals: [3] ‘fcn’, ‘x’, ‘y’
[17:41:54.346] 
[17:41:54.346] getGlobalsAndPackages() ... DONE
[17:41:54.346] run() for ‘Future’ ...
[17:41:54.347] - state: ‘created’
[17:41:54.347] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:54.361] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:54.361] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:54.361]   - Field: ‘node’
[17:41:54.361]   - Field: ‘label’
[17:41:54.361]   - Field: ‘local’
[17:41:54.361]   - Field: ‘owner’
[17:41:54.362]   - Field: ‘envir’
[17:41:54.362]   - Field: ‘workers’
[17:41:54.362]   - Field: ‘packages’
[17:41:54.362]   - Field: ‘gc’
[17:41:54.362]   - Field: ‘conditions’
[17:41:54.362]   - Field: ‘persistent’
[17:41:54.362]   - Field: ‘expr’
[17:41:54.362]   - Field: ‘uuid’
[17:41:54.362]   - Field: ‘seed’
[17:41:54.363]   - Field: ‘version’
[17:41:54.363]   - Field: ‘result’
[17:41:54.363]   - Field: ‘asynchronous’
[17:41:54.363]   - Field: ‘calls’
[17:41:54.363]   - Field: ‘globals’
[17:41:54.363]   - Field: ‘stdout’
[17:41:54.363]   - Field: ‘earlySignal’
[17:41:54.363]   - Field: ‘lazy’
[17:41:54.363]   - Field: ‘state’
[17:41:54.363] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:54.364] - Launch lazy future ...
[17:41:54.364] Packages needed by the future expression (n = 0): <none>
[17:41:54.364] Packages needed by future strategies (n = 0): <none>
[17:41:54.364] {
[17:41:54.364]     {
[17:41:54.364]         {
[17:41:54.364]             ...future.startTime <- base::Sys.time()
[17:41:54.364]             {
[17:41:54.364]                 {
[17:41:54.364]                   {
[17:41:54.364]                     {
[17:41:54.364]                       base::local({
[17:41:54.364]                         has_future <- base::requireNamespace("future", 
[17:41:54.364]                           quietly = TRUE)
[17:41:54.364]                         if (has_future) {
[17:41:54.364]                           ns <- base::getNamespace("future")
[17:41:54.364]                           version <- ns[[".package"]][["version"]]
[17:41:54.364]                           if (is.null(version)) 
[17:41:54.364]                             version <- utils::packageVersion("future")
[17:41:54.364]                         }
[17:41:54.364]                         else {
[17:41:54.364]                           version <- NULL
[17:41:54.364]                         }
[17:41:54.364]                         if (!has_future || version < "1.8.0") {
[17:41:54.364]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:54.364]                             "", base::R.version$version.string), 
[17:41:54.364]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:54.364]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:54.364]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:54.364]                               "release", "version")], collapse = " "), 
[17:41:54.364]                             hostname = base::Sys.info()[["nodename"]])
[17:41:54.364]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:54.364]                             info)
[17:41:54.364]                           info <- base::paste(info, collapse = "; ")
[17:41:54.364]                           if (!has_future) {
[17:41:54.364]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:54.364]                               info)
[17:41:54.364]                           }
[17:41:54.364]                           else {
[17:41:54.364]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:54.364]                               info, version)
[17:41:54.364]                           }
[17:41:54.364]                           base::stop(msg)
[17:41:54.364]                         }
[17:41:54.364]                       })
[17:41:54.364]                     }
[17:41:54.364]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:54.364]                     base::options(mc.cores = 1L)
[17:41:54.364]                   }
[17:41:54.364]                   options(future.plan = NULL)
[17:41:54.364]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:54.364]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:54.364]                 }
[17:41:54.364]                 ...future.workdir <- getwd()
[17:41:54.364]             }
[17:41:54.364]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:54.364]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:54.364]         }
[17:41:54.364]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:54.364]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:54.364]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:54.364]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:54.364]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:54.364]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:54.364]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:54.364]             base::names(...future.oldOptions))
[17:41:54.364]     }
[17:41:54.364]     if (FALSE) {
[17:41:54.364]     }
[17:41:54.364]     else {
[17:41:54.364]         if (TRUE) {
[17:41:54.364]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:54.364]                 open = "w")
[17:41:54.364]         }
[17:41:54.364]         else {
[17:41:54.364]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:54.364]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:54.364]         }
[17:41:54.364]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:54.364]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:54.364]             base::sink(type = "output", split = FALSE)
[17:41:54.364]             base::close(...future.stdout)
[17:41:54.364]         }, add = TRUE)
[17:41:54.364]     }
[17:41:54.364]     ...future.frame <- base::sys.nframe()
[17:41:54.364]     ...future.conditions <- base::list()
[17:41:54.364]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:54.364]     if (FALSE) {
[17:41:54.364]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:54.364]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:54.364]     }
[17:41:54.364]     ...future.result <- base::tryCatch({
[17:41:54.364]         base::withCallingHandlers({
[17:41:54.364]             ...future.value <- base::withVisible(base::local({
[17:41:54.364]                 ...future.makeSendCondition <- local({
[17:41:54.364]                   sendCondition <- NULL
[17:41:54.364]                   function(frame = 1L) {
[17:41:54.364]                     if (is.function(sendCondition)) 
[17:41:54.364]                       return(sendCondition)
[17:41:54.364]                     ns <- getNamespace("parallel")
[17:41:54.364]                     if (exists("sendData", mode = "function", 
[17:41:54.364]                       envir = ns)) {
[17:41:54.364]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:54.364]                         envir = ns)
[17:41:54.364]                       envir <- sys.frame(frame)
[17:41:54.364]                       master <- NULL
[17:41:54.364]                       while (!identical(envir, .GlobalEnv) && 
[17:41:54.364]                         !identical(envir, emptyenv())) {
[17:41:54.364]                         if (exists("master", mode = "list", envir = envir, 
[17:41:54.364]                           inherits = FALSE)) {
[17:41:54.364]                           master <- get("master", mode = "list", 
[17:41:54.364]                             envir = envir, inherits = FALSE)
[17:41:54.364]                           if (inherits(master, c("SOCKnode", 
[17:41:54.364]                             "SOCK0node"))) {
[17:41:54.364]                             sendCondition <<- function(cond) {
[17:41:54.364]                               data <- list(type = "VALUE", value = cond, 
[17:41:54.364]                                 success = TRUE)
[17:41:54.364]                               parallel_sendData(master, data)
[17:41:54.364]                             }
[17:41:54.364]                             return(sendCondition)
[17:41:54.364]                           }
[17:41:54.364]                         }
[17:41:54.364]                         frame <- frame + 1L
[17:41:54.364]                         envir <- sys.frame(frame)
[17:41:54.364]                       }
[17:41:54.364]                     }
[17:41:54.364]                     sendCondition <<- function(cond) NULL
[17:41:54.364]                   }
[17:41:54.364]                 })
[17:41:54.364]                 withCallingHandlers({
[17:41:54.364]                   fcn(x, y)
[17:41:54.364]                 }, immediateCondition = function(cond) {
[17:41:54.364]                   sendCondition <- ...future.makeSendCondition()
[17:41:54.364]                   sendCondition(cond)
[17:41:54.364]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.364]                   {
[17:41:54.364]                     inherits <- base::inherits
[17:41:54.364]                     invokeRestart <- base::invokeRestart
[17:41:54.364]                     is.null <- base::is.null
[17:41:54.364]                     muffled <- FALSE
[17:41:54.364]                     if (inherits(cond, "message")) {
[17:41:54.364]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:54.364]                       if (muffled) 
[17:41:54.364]                         invokeRestart("muffleMessage")
[17:41:54.364]                     }
[17:41:54.364]                     else if (inherits(cond, "warning")) {
[17:41:54.364]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:54.364]                       if (muffled) 
[17:41:54.364]                         invokeRestart("muffleWarning")
[17:41:54.364]                     }
[17:41:54.364]                     else if (inherits(cond, "condition")) {
[17:41:54.364]                       if (!is.null(pattern)) {
[17:41:54.364]                         computeRestarts <- base::computeRestarts
[17:41:54.364]                         grepl <- base::grepl
[17:41:54.364]                         restarts <- computeRestarts(cond)
[17:41:54.364]                         for (restart in restarts) {
[17:41:54.364]                           name <- restart$name
[17:41:54.364]                           if (is.null(name)) 
[17:41:54.364]                             next
[17:41:54.364]                           if (!grepl(pattern, name)) 
[17:41:54.364]                             next
[17:41:54.364]                           invokeRestart(restart)
[17:41:54.364]                           muffled <- TRUE
[17:41:54.364]                           break
[17:41:54.364]                         }
[17:41:54.364]                       }
[17:41:54.364]                     }
[17:41:54.364]                     invisible(muffled)
[17:41:54.364]                   }
[17:41:54.364]                   muffleCondition(cond)
[17:41:54.364]                 })
[17:41:54.364]             }))
[17:41:54.364]             future::FutureResult(value = ...future.value$value, 
[17:41:54.364]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:54.364]                   ...future.rng), globalenv = if (FALSE) 
[17:41:54.364]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:54.364]                     ...future.globalenv.names))
[17:41:54.364]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:54.364]         }, condition = base::local({
[17:41:54.364]             c <- base::c
[17:41:54.364]             inherits <- base::inherits
[17:41:54.364]             invokeRestart <- base::invokeRestart
[17:41:54.364]             length <- base::length
[17:41:54.364]             list <- base::list
[17:41:54.364]             seq.int <- base::seq.int
[17:41:54.364]             signalCondition <- base::signalCondition
[17:41:54.364]             sys.calls <- base::sys.calls
[17:41:54.364]             `[[` <- base::`[[`
[17:41:54.364]             `+` <- base::`+`
[17:41:54.364]             `<<-` <- base::`<<-`
[17:41:54.364]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:54.364]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:54.364]                   3L)]
[17:41:54.364]             }
[17:41:54.364]             function(cond) {
[17:41:54.364]                 is_error <- inherits(cond, "error")
[17:41:54.364]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:54.364]                   NULL)
[17:41:54.364]                 if (is_error) {
[17:41:54.364]                   sessionInformation <- function() {
[17:41:54.364]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:54.364]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:54.364]                       search = base::search(), system = base::Sys.info())
[17:41:54.364]                   }
[17:41:54.364]                   ...future.conditions[[length(...future.conditions) + 
[17:41:54.364]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:54.364]                     cond$call), session = sessionInformation(), 
[17:41:54.364]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:54.364]                   signalCondition(cond)
[17:41:54.364]                 }
[17:41:54.364]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:54.364]                 "immediateCondition"))) {
[17:41:54.364]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:54.364]                   ...future.conditions[[length(...future.conditions) + 
[17:41:54.364]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:54.364]                   if (TRUE && !signal) {
[17:41:54.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.364]                     {
[17:41:54.364]                       inherits <- base::inherits
[17:41:54.364]                       invokeRestart <- base::invokeRestart
[17:41:54.364]                       is.null <- base::is.null
[17:41:54.364]                       muffled <- FALSE
[17:41:54.364]                       if (inherits(cond, "message")) {
[17:41:54.364]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:54.364]                         if (muffled) 
[17:41:54.364]                           invokeRestart("muffleMessage")
[17:41:54.364]                       }
[17:41:54.364]                       else if (inherits(cond, "warning")) {
[17:41:54.364]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:54.364]                         if (muffled) 
[17:41:54.364]                           invokeRestart("muffleWarning")
[17:41:54.364]                       }
[17:41:54.364]                       else if (inherits(cond, "condition")) {
[17:41:54.364]                         if (!is.null(pattern)) {
[17:41:54.364]                           computeRestarts <- base::computeRestarts
[17:41:54.364]                           grepl <- base::grepl
[17:41:54.364]                           restarts <- computeRestarts(cond)
[17:41:54.364]                           for (restart in restarts) {
[17:41:54.364]                             name <- restart$name
[17:41:54.364]                             if (is.null(name)) 
[17:41:54.364]                               next
[17:41:54.364]                             if (!grepl(pattern, name)) 
[17:41:54.364]                               next
[17:41:54.364]                             invokeRestart(restart)
[17:41:54.364]                             muffled <- TRUE
[17:41:54.364]                             break
[17:41:54.364]                           }
[17:41:54.364]                         }
[17:41:54.364]                       }
[17:41:54.364]                       invisible(muffled)
[17:41:54.364]                     }
[17:41:54.364]                     muffleCondition(cond, pattern = "^muffle")
[17:41:54.364]                   }
[17:41:54.364]                 }
[17:41:54.364]                 else {
[17:41:54.364]                   if (TRUE) {
[17:41:54.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:54.364]                     {
[17:41:54.364]                       inherits <- base::inherits
[17:41:54.364]                       invokeRestart <- base::invokeRestart
[17:41:54.364]                       is.null <- base::is.null
[17:41:54.364]                       muffled <- FALSE
[17:41:54.364]                       if (inherits(cond, "message")) {
[17:41:54.364]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:54.364]                         if (muffled) 
[17:41:54.364]                           invokeRestart("muffleMessage")
[17:41:54.364]                       }
[17:41:54.364]                       else if (inherits(cond, "warning")) {
[17:41:54.364]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:54.364]                         if (muffled) 
[17:41:54.364]                           invokeRestart("muffleWarning")
[17:41:54.364]                       }
[17:41:54.364]                       else if (inherits(cond, "condition")) {
[17:41:54.364]                         if (!is.null(pattern)) {
[17:41:54.364]                           computeRestarts <- base::computeRestarts
[17:41:54.364]                           grepl <- base::grepl
[17:41:54.364]                           restarts <- computeRestarts(cond)
[17:41:54.364]                           for (restart in restarts) {
[17:41:54.364]                             name <- restart$name
[17:41:54.364]                             if (is.null(name)) 
[17:41:54.364]                               next
[17:41:54.364]                             if (!grepl(pattern, name)) 
[17:41:54.364]                               next
[17:41:54.364]                             invokeRestart(restart)
[17:41:54.364]                             muffled <- TRUE
[17:41:54.364]                             break
[17:41:54.364]                           }
[17:41:54.364]                         }
[17:41:54.364]                       }
[17:41:54.364]                       invisible(muffled)
[17:41:54.364]                     }
[17:41:54.364]                     muffleCondition(cond, pattern = "^muffle")
[17:41:54.364]                   }
[17:41:54.364]                 }
[17:41:54.364]             }
[17:41:54.364]         }))
[17:41:54.364]     }, error = function(ex) {
[17:41:54.364]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:54.364]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:54.364]                 ...future.rng), started = ...future.startTime, 
[17:41:54.364]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:54.364]             version = "1.8"), class = "FutureResult")
[17:41:54.364]     }, finally = {
[17:41:54.364]         if (!identical(...future.workdir, getwd())) 
[17:41:54.364]             setwd(...future.workdir)
[17:41:54.364]         {
[17:41:54.364]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:54.364]                 ...future.oldOptions$nwarnings <- NULL
[17:41:54.364]             }
[17:41:54.364]             base::options(...future.oldOptions)
[17:41:54.364]             if (.Platform$OS.type == "windows") {
[17:41:54.364]                 old_names <- names(...future.oldEnvVars)
[17:41:54.364]                 envs <- base::Sys.getenv()
[17:41:54.364]                 names <- names(envs)
[17:41:54.364]                 common <- intersect(names, old_names)
[17:41:54.364]                 added <- setdiff(names, old_names)
[17:41:54.364]                 removed <- setdiff(old_names, names)
[17:41:54.364]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:54.364]                   envs[common]]
[17:41:54.364]                 NAMES <- toupper(changed)
[17:41:54.364]                 args <- list()
[17:41:54.364]                 for (kk in seq_along(NAMES)) {
[17:41:54.364]                   name <- changed[[kk]]
[17:41:54.364]                   NAME <- NAMES[[kk]]
[17:41:54.364]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.364]                     next
[17:41:54.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:54.364]                 }
[17:41:54.364]                 NAMES <- toupper(added)
[17:41:54.364]                 for (kk in seq_along(NAMES)) {
[17:41:54.364]                   name <- added[[kk]]
[17:41:54.364]                   NAME <- NAMES[[kk]]
[17:41:54.364]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.364]                     next
[17:41:54.364]                   args[[name]] <- ""
[17:41:54.364]                 }
[17:41:54.364]                 NAMES <- toupper(removed)
[17:41:54.364]                 for (kk in seq_along(NAMES)) {
[17:41:54.364]                   name <- removed[[kk]]
[17:41:54.364]                   NAME <- NAMES[[kk]]
[17:41:54.364]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:54.364]                     next
[17:41:54.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:54.364]                 }
[17:41:54.364]                 if (length(args) > 0) 
[17:41:54.364]                   base::do.call(base::Sys.setenv, args = args)
[17:41:54.364]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:54.364]             }
[17:41:54.364]             else {
[17:41:54.364]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:54.364]             }
[17:41:54.364]             {
[17:41:54.364]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:54.364]                   0L) {
[17:41:54.364]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:54.364]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:54.364]                   base::options(opts)
[17:41:54.364]                 }
[17:41:54.364]                 {
[17:41:54.364]                   {
[17:41:54.364]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:54.364]                     NULL
[17:41:54.364]                   }
[17:41:54.364]                   options(future.plan = NULL)
[17:41:54.364]                   if (is.na(NA_character_)) 
[17:41:54.364]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:54.364]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:54.364]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:54.364]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:54.364]                     envir = parent.frame()) 
[17:41:54.364]                   {
[17:41:54.364]                     if (is.function(workers)) 
[17:41:54.364]                       workers <- workers()
[17:41:54.364]                     workers <- structure(as.integer(workers), 
[17:41:54.364]                       class = class(workers))
[17:41:54.364]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:54.364]                       workers >= 1)
[17:41:54.364]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:54.364]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:54.364]                     }
[17:41:54.364]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:54.364]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:54.364]                       envir = envir)
[17:41:54.364]                     if (!future$lazy) 
[17:41:54.364]                       future <- run(future)
[17:41:54.364]                     invisible(future)
[17:41:54.364]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:54.364]                 }
[17:41:54.364]             }
[17:41:54.364]         }
[17:41:54.364]     })
[17:41:54.364]     if (TRUE) {
[17:41:54.364]         base::sink(type = "output", split = FALSE)
[17:41:54.364]         if (TRUE) {
[17:41:54.364]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:54.364]         }
[17:41:54.364]         else {
[17:41:54.364]             ...future.result["stdout"] <- base::list(NULL)
[17:41:54.364]         }
[17:41:54.364]         base::close(...future.stdout)
[17:41:54.364]         ...future.stdout <- NULL
[17:41:54.364]     }
[17:41:54.364]     ...future.result$conditions <- ...future.conditions
[17:41:54.364]     ...future.result$finished <- base::Sys.time()
[17:41:54.364]     ...future.result
[17:41:54.364] }
[17:41:54.367] Exporting 3 global objects (4.18 KiB) to cluster node #1 ...
[17:41:54.367] Exporting ‘fcn’ (4.07 KiB) to cluster node #1 ...
[17:41:54.368] Exporting ‘fcn’ (4.07 KiB) to cluster node #1 ... DONE
[17:41:54.368] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:41:54.368] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:41:54.368] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[17:41:54.369] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[17:41:54.369] Exporting 3 global objects (4.18 KiB) to cluster node #1 ... DONE
[17:41:54.369] MultisessionFuture started
[17:41:54.369] - Launch lazy future ... done
[17:41:54.369] run() for ‘MultisessionFuture’ ... done
[17:41:54.370] result() for ClusterFuture ...
[17:41:54.370] receiveMessageFromWorker() for ClusterFuture ...
[17:41:54.370] - Validating connection of MultisessionFuture
[17:41:54.416] - received message: FutureResult
[17:41:54.416] - Received FutureResult
[17:41:54.416] - Erased future from FutureRegistry
[17:41:54.417] result() for ClusterFuture ...
[17:41:54.417] - result already collected: FutureResult
[17:41:54.417] result() for ClusterFuture ... done
[17:41:54.417] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:54.417] result() for ClusterFuture ... done
[17:41:54.417] result() for ClusterFuture ...
[17:41:54.417] - result already collected: FutureResult
[17:41:54.417] result() for ClusterFuture ... done
[1] 6
Testing with 2 cores ... DONE
> 
> message("*** Global argument '...' ... DONE")
*** Global argument '...' ... DONE
> 
> source("incl/end.R")
[17:41:54.418] plan(): Setting new future strategy stack:
[17:41:54.418] List of future strategies:
[17:41:54.418] 1. FutureStrategy:
[17:41:54.418]    - args: function (..., envir = parent.frame())
[17:41:54.418]    - tweaked: FALSE
[17:41:54.418]    - call: future::plan(oplan)
[17:41:54.419] plan(): nbrOfWorkers() = 1
> 
