
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:43:09.879] plan(): Setting new future strategy stack:
[17:43:09.880] List of future strategies:
[17:43:09.880] 1. sequential:
[17:43:09.880]    - args: function (..., envir = parent.frame())
[17:43:09.880]    - tweaked: FALSE
[17:43:09.880]    - call: future::plan("sequential")
[17:43:09.893] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[17:43:09.946] plan(): Setting new future strategy stack:
[17:43:09.946] List of future strategies:
[17:43:09.946] 1. sequential:
[17:43:09.946]    - args: function (..., envir = parent.frame())
[17:43:09.946]    - tweaked: FALSE
[17:43:09.946]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:09.946] 2. sequential:
[17:43:09.946]    - args: function (..., envir = parent.frame())
[17:43:09.946]    - tweaked: FALSE
[17:43:09.946]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:09.958] plan(): nbrOfWorkers() = 1
[17:43:09.960] getGlobalsAndPackages() ...
[17:43:09.960] Searching for globals...
[17:43:09.983] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:43:09.983] Searching for globals ... DONE
[17:43:09.983] Resolving globals: FALSE
[17:43:09.985] The total size of the 2 globals is 22.60 KiB (23144 bytes)
[17:43:09.986] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 22.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (22.48 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:43:09.986] - globals: [2] ‘nested’, ‘strategy2’
[17:43:09.986] - packages: [1] ‘future’
[17:43:09.986] getGlobalsAndPackages() ... DONE
[17:43:09.987] run() for ‘Future’ ...
[17:43:09.987] - state: ‘created’
[17:43:09.987] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:09.987] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:09.987] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:09.988]   - Field: ‘label’
[17:43:09.988]   - Field: ‘local’
[17:43:09.988]   - Field: ‘owner’
[17:43:09.988]   - Field: ‘envir’
[17:43:09.988]   - Field: ‘packages’
[17:43:09.988]   - Field: ‘gc’
[17:43:09.988]   - Field: ‘conditions’
[17:43:09.988]   - Field: ‘expr’
[17:43:09.988]   - Field: ‘uuid’
[17:43:09.988]   - Field: ‘seed’
[17:43:09.988]   - Field: ‘version’
[17:43:09.989]   - Field: ‘result’
[17:43:09.989]   - Field: ‘asynchronous’
[17:43:09.989]   - Field: ‘calls’
[17:43:09.989]   - Field: ‘globals’
[17:43:09.989]   - Field: ‘stdout’
[17:43:09.989]   - Field: ‘earlySignal’
[17:43:09.989]   - Field: ‘lazy’
[17:43:09.989]   - Field: ‘state’
[17:43:09.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:09.989] - Launch lazy future ...
[17:43:09.990] Packages needed by the future expression (n = 1): ‘future’
[17:43:09.990] Packages needed by future strategies (n = 1): ‘future’
[17:43:09.991] {
[17:43:09.991]     {
[17:43:09.991]         {
[17:43:09.991]             ...future.startTime <- base::Sys.time()
[17:43:09.991]             {
[17:43:09.991]                 {
[17:43:09.991]                   {
[17:43:09.991]                     {
[17:43:09.991]                       base::local({
[17:43:09.991]                         has_future <- base::requireNamespace("future", 
[17:43:09.991]                           quietly = TRUE)
[17:43:09.991]                         if (has_future) {
[17:43:09.991]                           ns <- base::getNamespace("future")
[17:43:09.991]                           version <- ns[[".package"]][["version"]]
[17:43:09.991]                           if (is.null(version)) 
[17:43:09.991]                             version <- utils::packageVersion("future")
[17:43:09.991]                         }
[17:43:09.991]                         else {
[17:43:09.991]                           version <- NULL
[17:43:09.991]                         }
[17:43:09.991]                         if (!has_future || version < "1.8.0") {
[17:43:09.991]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:09.991]                             "", base::R.version$version.string), 
[17:43:09.991]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:09.991]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:09.991]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:09.991]                               "release", "version")], collapse = " "), 
[17:43:09.991]                             hostname = base::Sys.info()[["nodename"]])
[17:43:09.991]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:09.991]                             info)
[17:43:09.991]                           info <- base::paste(info, collapse = "; ")
[17:43:09.991]                           if (!has_future) {
[17:43:09.991]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:09.991]                               info)
[17:43:09.991]                           }
[17:43:09.991]                           else {
[17:43:09.991]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:09.991]                               info, version)
[17:43:09.991]                           }
[17:43:09.991]                           base::stop(msg)
[17:43:09.991]                         }
[17:43:09.991]                       })
[17:43:09.991]                     }
[17:43:09.991]                     base::local({
[17:43:09.991]                       for (pkg in "future") {
[17:43:09.991]                         base::loadNamespace(pkg)
[17:43:09.991]                         base::library(pkg, character.only = TRUE)
[17:43:09.991]                       }
[17:43:09.991]                     })
[17:43:09.991]                   }
[17:43:09.991]                   options(future.plan = NULL)
[17:43:09.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:09.991]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:43:09.991]                   {
[17:43:09.991]                     future <- SequentialFuture(..., envir = envir)
[17:43:09.991]                     if (!future$lazy) 
[17:43:09.991]                       future <- run(future)
[17:43:09.991]                     invisible(future)
[17:43:09.991]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:09.991]                 }
[17:43:09.991]                 ...future.workdir <- getwd()
[17:43:09.991]             }
[17:43:09.991]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:09.991]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:09.991]         }
[17:43:09.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:09.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:09.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:09.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:09.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:09.991]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:09.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:09.991]             base::names(...future.oldOptions))
[17:43:09.991]     }
[17:43:09.991]     if (FALSE) {
[17:43:09.991]     }
[17:43:09.991]     else {
[17:43:09.991]         if (TRUE) {
[17:43:09.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:09.991]                 open = "w")
[17:43:09.991]         }
[17:43:09.991]         else {
[17:43:09.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:09.991]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:09.991]         }
[17:43:09.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:09.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:09.991]             base::sink(type = "output", split = FALSE)
[17:43:09.991]             base::close(...future.stdout)
[17:43:09.991]         }, add = TRUE)
[17:43:09.991]     }
[17:43:09.991]     ...future.frame <- base::sys.nframe()
[17:43:09.991]     ...future.conditions <- base::list()
[17:43:09.991]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:09.991]     if (FALSE) {
[17:43:09.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:09.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:09.991]     }
[17:43:09.991]     ...future.result <- base::tryCatch({
[17:43:09.991]         base::withCallingHandlers({
[17:43:09.991]             ...future.value <- base::withVisible(base::local({
[17:43:09.991]                 a <- 1L
[17:43:09.991]                 plan_a <- unclass(future::plan("list"))
[17:43:09.991]                 nested_a <- nested[-1]
[17:43:09.991]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:43:09.991]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:43:09.991]                   strategy2))
[17:43:09.991]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:43:09.991]                   "init") <- NULL
[17:43:09.991]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:43:09.991]                   "init") <- NULL
[17:43:09.991]                 stopifnot(all.equal(plan_a, nested_a))
[17:43:09.991]                 y %<-% {
[17:43:09.991]                   b <- 2L
[17:43:09.991]                   plan_b <- future::plan("list")
[17:43:09.991]                   nested_b <- nested_a[-1]
[17:43:09.991]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:09.991]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:43:09.991]                     "sequential"))
[17:43:09.991]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:09.991]                     b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:09.991]                 }
[17:43:09.991]                 y
[17:43:09.991]             }))
[17:43:09.991]             future::FutureResult(value = ...future.value$value, 
[17:43:09.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:09.991]                   ...future.rng), globalenv = if (FALSE) 
[17:43:09.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:09.991]                     ...future.globalenv.names))
[17:43:09.991]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:09.991]         }, condition = base::local({
[17:43:09.991]             c <- base::c
[17:43:09.991]             inherits <- base::inherits
[17:43:09.991]             invokeRestart <- base::invokeRestart
[17:43:09.991]             length <- base::length
[17:43:09.991]             list <- base::list
[17:43:09.991]             seq.int <- base::seq.int
[17:43:09.991]             signalCondition <- base::signalCondition
[17:43:09.991]             sys.calls <- base::sys.calls
[17:43:09.991]             `[[` <- base::`[[`
[17:43:09.991]             `+` <- base::`+`
[17:43:09.991]             `<<-` <- base::`<<-`
[17:43:09.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:09.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:09.991]                   3L)]
[17:43:09.991]             }
[17:43:09.991]             function(cond) {
[17:43:09.991]                 is_error <- inherits(cond, "error")
[17:43:09.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:09.991]                   NULL)
[17:43:09.991]                 if (is_error) {
[17:43:09.991]                   sessionInformation <- function() {
[17:43:09.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:09.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:09.991]                       search = base::search(), system = base::Sys.info())
[17:43:09.991]                   }
[17:43:09.991]                   ...future.conditions[[length(...future.conditions) + 
[17:43:09.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:09.991]                     cond$call), session = sessionInformation(), 
[17:43:09.991]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:09.991]                   signalCondition(cond)
[17:43:09.991]                 }
[17:43:09.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:09.991]                 "immediateCondition"))) {
[17:43:09.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:09.991]                   ...future.conditions[[length(...future.conditions) + 
[17:43:09.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:09.991]                   if (TRUE && !signal) {
[17:43:09.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:09.991]                     {
[17:43:09.991]                       inherits <- base::inherits
[17:43:09.991]                       invokeRestart <- base::invokeRestart
[17:43:09.991]                       is.null <- base::is.null
[17:43:09.991]                       muffled <- FALSE
[17:43:09.991]                       if (inherits(cond, "message")) {
[17:43:09.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:09.991]                         if (muffled) 
[17:43:09.991]                           invokeRestart("muffleMessage")
[17:43:09.991]                       }
[17:43:09.991]                       else if (inherits(cond, "warning")) {
[17:43:09.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:09.991]                         if (muffled) 
[17:43:09.991]                           invokeRestart("muffleWarning")
[17:43:09.991]                       }
[17:43:09.991]                       else if (inherits(cond, "condition")) {
[17:43:09.991]                         if (!is.null(pattern)) {
[17:43:09.991]                           computeRestarts <- base::computeRestarts
[17:43:09.991]                           grepl <- base::grepl
[17:43:09.991]                           restarts <- computeRestarts(cond)
[17:43:09.991]                           for (restart in restarts) {
[17:43:09.991]                             name <- restart$name
[17:43:09.991]                             if (is.null(name)) 
[17:43:09.991]                               next
[17:43:09.991]                             if (!grepl(pattern, name)) 
[17:43:09.991]                               next
[17:43:09.991]                             invokeRestart(restart)
[17:43:09.991]                             muffled <- TRUE
[17:43:09.991]                             break
[17:43:09.991]                           }
[17:43:09.991]                         }
[17:43:09.991]                       }
[17:43:09.991]                       invisible(muffled)
[17:43:09.991]                     }
[17:43:09.991]                     muffleCondition(cond, pattern = "^muffle")
[17:43:09.991]                   }
[17:43:09.991]                 }
[17:43:09.991]                 else {
[17:43:09.991]                   if (TRUE) {
[17:43:09.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:09.991]                     {
[17:43:09.991]                       inherits <- base::inherits
[17:43:09.991]                       invokeRestart <- base::invokeRestart
[17:43:09.991]                       is.null <- base::is.null
[17:43:09.991]                       muffled <- FALSE
[17:43:09.991]                       if (inherits(cond, "message")) {
[17:43:09.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:09.991]                         if (muffled) 
[17:43:09.991]                           invokeRestart("muffleMessage")
[17:43:09.991]                       }
[17:43:09.991]                       else if (inherits(cond, "warning")) {
[17:43:09.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:09.991]                         if (muffled) 
[17:43:09.991]                           invokeRestart("muffleWarning")
[17:43:09.991]                       }
[17:43:09.991]                       else if (inherits(cond, "condition")) {
[17:43:09.991]                         if (!is.null(pattern)) {
[17:43:09.991]                           computeRestarts <- base::computeRestarts
[17:43:09.991]                           grepl <- base::grepl
[17:43:09.991]                           restarts <- computeRestarts(cond)
[17:43:09.991]                           for (restart in restarts) {
[17:43:09.991]                             name <- restart$name
[17:43:09.991]                             if (is.null(name)) 
[17:43:09.991]                               next
[17:43:09.991]                             if (!grepl(pattern, name)) 
[17:43:09.991]                               next
[17:43:09.991]                             invokeRestart(restart)
[17:43:09.991]                             muffled <- TRUE
[17:43:09.991]                             break
[17:43:09.991]                           }
[17:43:09.991]                         }
[17:43:09.991]                       }
[17:43:09.991]                       invisible(muffled)
[17:43:09.991]                     }
[17:43:09.991]                     muffleCondition(cond, pattern = "^muffle")
[17:43:09.991]                   }
[17:43:09.991]                 }
[17:43:09.991]             }
[17:43:09.991]         }))
[17:43:09.991]     }, error = function(ex) {
[17:43:09.991]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:09.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:09.991]                 ...future.rng), started = ...future.startTime, 
[17:43:09.991]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:09.991]             version = "1.8"), class = "FutureResult")
[17:43:09.991]     }, finally = {
[17:43:09.991]         if (!identical(...future.workdir, getwd())) 
[17:43:09.991]             setwd(...future.workdir)
[17:43:09.991]         {
[17:43:09.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:09.991]                 ...future.oldOptions$nwarnings <- NULL
[17:43:09.991]             }
[17:43:09.991]             base::options(...future.oldOptions)
[17:43:09.991]             if (.Platform$OS.type == "windows") {
[17:43:09.991]                 old_names <- names(...future.oldEnvVars)
[17:43:09.991]                 envs <- base::Sys.getenv()
[17:43:09.991]                 names <- names(envs)
[17:43:09.991]                 common <- intersect(names, old_names)
[17:43:09.991]                 added <- setdiff(names, old_names)
[17:43:09.991]                 removed <- setdiff(old_names, names)
[17:43:09.991]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:09.991]                   envs[common]]
[17:43:09.991]                 NAMES <- toupper(changed)
[17:43:09.991]                 args <- list()
[17:43:09.991]                 for (kk in seq_along(NAMES)) {
[17:43:09.991]                   name <- changed[[kk]]
[17:43:09.991]                   NAME <- NAMES[[kk]]
[17:43:09.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:09.991]                     next
[17:43:09.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:09.991]                 }
[17:43:09.991]                 NAMES <- toupper(added)
[17:43:09.991]                 for (kk in seq_along(NAMES)) {
[17:43:09.991]                   name <- added[[kk]]
[17:43:09.991]                   NAME <- NAMES[[kk]]
[17:43:09.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:09.991]                     next
[17:43:09.991]                   args[[name]] <- ""
[17:43:09.991]                 }
[17:43:09.991]                 NAMES <- toupper(removed)
[17:43:09.991]                 for (kk in seq_along(NAMES)) {
[17:43:09.991]                   name <- removed[[kk]]
[17:43:09.991]                   NAME <- NAMES[[kk]]
[17:43:09.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:09.991]                     next
[17:43:09.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:09.991]                 }
[17:43:09.991]                 if (length(args) > 0) 
[17:43:09.991]                   base::do.call(base::Sys.setenv, args = args)
[17:43:09.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:09.991]             }
[17:43:09.991]             else {
[17:43:09.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:09.991]             }
[17:43:09.991]             {
[17:43:09.991]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:09.991]                   0L) {
[17:43:09.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:09.991]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:09.991]                   base::options(opts)
[17:43:09.991]                 }
[17:43:09.991]                 {
[17:43:09.991]                   {
[17:43:09.991]                     NULL
[17:43:09.991]                     RNGkind("Mersenne-Twister")
[17:43:09.991]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:09.991]                       inherits = FALSE)
[17:43:09.991]                   }
[17:43:09.991]                   options(future.plan = NULL)
[17:43:09.991]                   if (is.na(NA_character_)) 
[17:43:09.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:09.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:09.991]                   future::plan(list(a = function (..., envir = parent.frame()) 
[17:43:09.991]                   {
[17:43:09.991]                     future <- SequentialFuture(..., envir = envir)
[17:43:09.991]                     if (!future$lazy) 
[17:43:09.991]                       future <- run(future)
[17:43:09.991]                     invisible(future)
[17:43:09.991]                   }, b = function (..., envir = parent.frame()) 
[17:43:09.991]                   {
[17:43:09.991]                     future <- SequentialFuture(..., envir = envir)
[17:43:09.991]                     if (!future$lazy) 
[17:43:09.991]                       future <- run(future)
[17:43:09.991]                     invisible(future)
[17:43:09.991]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:09.991]                 }
[17:43:09.991]             }
[17:43:09.991]         }
[17:43:09.991]     })
[17:43:09.991]     if (TRUE) {
[17:43:09.991]         base::sink(type = "output", split = FALSE)
[17:43:09.991]         if (TRUE) {
[17:43:09.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:09.991]         }
[17:43:09.991]         else {
[17:43:09.991]             ...future.result["stdout"] <- base::list(NULL)
[17:43:09.991]         }
[17:43:09.991]         base::close(...future.stdout)
[17:43:09.991]         ...future.stdout <- NULL
[17:43:09.991]     }
[17:43:09.991]     ...future.result$conditions <- ...future.conditions
[17:43:09.991]     ...future.result$finished <- base::Sys.time()
[17:43:09.991]     ...future.result
[17:43:09.991] }
[17:43:09.993] assign_globals() ...
[17:43:09.993] List of 2
[17:43:09.993]  $ nested   :List of 2
[17:43:09.993]   ..$ a:function (..., envir = parent.frame())  
[17:43:09.993]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:43:09.993]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:09.993]   ..$ b:function (..., envir = parent.frame())  
[17:43:09.993]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:43:09.993]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:09.993]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:09.993]  $ strategy2: chr "sequential"
[17:43:09.993]  - attr(*, "where")=List of 2
[17:43:09.993]   ..$ nested   :<environment: R_EmptyEnv> 
[17:43:09.993]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:43:09.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:09.993]  - attr(*, "resolved")= logi FALSE
[17:43:09.993]  - attr(*, "total_size")= num 23144
[17:43:09.993]  - attr(*, "already-done")= logi TRUE
[17:43:10.000] - copied ‘nested’ to environment
[17:43:10.000] - copied ‘strategy2’ to environment
[17:43:10.000] assign_globals() ... done
[17:43:10.001] plan(): Setting new future strategy stack:
[17:43:10.001] List of future strategies:
[17:43:10.001] 1. sequential:
[17:43:10.001]    - args: function (..., envir = parent.frame())
[17:43:10.001]    - tweaked: FALSE
[17:43:10.001]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.001] plan(): nbrOfWorkers() = 1
[17:43:10.041] plan(): Setting new future strategy stack:
[17:43:10.041] List of future strategies:
[17:43:10.041] 1. sequential:
[17:43:10.041]    - args: function (..., envir = parent.frame())
[17:43:10.041]    - tweaked: FALSE
[17:43:10.041]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.041] 2. sequential:
[17:43:10.041]    - args: function (..., envir = parent.frame())
[17:43:10.041]    - tweaked: FALSE
[17:43:10.041]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.042] plan(): nbrOfWorkers() = 1
[17:43:10.042] SequentialFuture started (and completed)
[17:43:10.042] signalConditions() ...
[17:43:10.042]  - include = ‘immediateCondition’
[17:43:10.042]  - exclude = 
[17:43:10.042]  - resignal = FALSE
[17:43:10.042]  - Number of conditions: 54
[17:43:10.043] signalConditions() ... done
[17:43:10.043] - Launch lazy future ... done
[17:43:10.043] run() for ‘SequentialFuture’ ... done
[17:43:10.043] signalConditions() ...
[17:43:10.043]  - include = ‘immediateCondition’
[17:43:10.043]  - exclude = 
[17:43:10.043]  - resignal = FALSE
[17:43:10.044]  - Number of conditions: 54
[17:43:10.044] signalConditions() ... done
[17:43:10.044] Future state: ‘finished’
[17:43:10.044] signalConditions() ...
[17:43:10.044]  - include = ‘condition’
[17:43:10.044]  - exclude = ‘immediateCondition’
[17:43:10.044]  - resignal = TRUE
[17:43:10.044]  - Number of conditions: 54
[17:43:10.044]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.002] getGlobalsAndPackages() ...
[17:43:10.045]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.003] Searching for globals...
[17:43:10.045]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.024] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:43:10.045]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.024] Searching for globals ... DONE
[17:43:10.045]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.024] Resolving globals: FALSE
[17:43:10.045]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.025] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[17:43:10.045]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.025] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:43:10.045]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.025] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:43:10.045]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.025] 
[17:43:10.046]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.025] getGlobalsAndPackages() ... DONE
[17:43:10.046]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.026] run() for ‘Future’ ...
[17:43:10.046]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.026] - state: ‘created’
[17:43:10.046]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.026] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:10.046]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.026] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:10.046]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.026] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:10.046]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.027]   - Field: ‘label’
[17:43:10.047]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.027]   - Field: ‘local’
[17:43:10.047]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.027]   - Field: ‘owner’
[17:43:10.047]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.027]   - Field: ‘envir’
[17:43:10.047]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.027]   - Field: ‘packages’
[17:43:10.047]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.027]   - Field: ‘gc’
[17:43:10.047]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.027]   - Field: ‘conditions’
[17:43:10.047]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.027]   - Field: ‘expr’
[17:43:10.048]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.027]   - Field: ‘uuid’
[17:43:10.048]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.028]   - Field: ‘seed’
[17:43:10.048]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.028]   - Field: ‘version’
[17:43:10.048]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.028]   - Field: ‘result’
[17:43:10.048]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.028]   - Field: ‘asynchronous’
[17:43:10.048]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.028]   - Field: ‘calls’
[17:43:10.048]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.028]   - Field: ‘globals’
[17:43:10.048]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.028]   - Field: ‘stdout’
[17:43:10.049]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.028]   - Field: ‘earlySignal’
[17:43:10.049]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.028]   - Field: ‘lazy’
[17:43:10.049]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.028]   - Field: ‘state’
[17:43:10.049]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.029] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:10.049]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.029] - Launch lazy future ...
[17:43:10.049]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.029] Packages needed by the future expression (n = 0): <none>
[17:43:10.049]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.029] Packages needed by future strategies (n = 0): <none>
[17:43:10.050]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.029] {
[17:43:10.029]     {
[17:43:10.029]         {
[17:43:10.029]             ...future.startTime <- base::Sys.time()
[17:43:10.029]             {
[17:43:10.029]                 {
[17:43:10.029]                   {
[17:43:10.029]                     base::local({
[17:43:10.029]                       has_future <- base::requireNamespace("future", 
[17:43:10.029]                         quietly = TRUE)
[17:43:10.029]                       if (has_future) {
[17:43:10.029]                         ns <- base::getNamespace("future")
[17:43:10.029]                         version <- ns[[".package"]][["version"]]
[17:43:10.029]                         if (is.null(version)) 
[17:43:10.029]                           version <- utils::packageVersion("future")
[17:43:10.029]                       }
[17:43:10.029]                       else {
[17:43:10.029]                         version <- NULL
[17:43:10.029]                       }
[17:43:10.029]                       if (!has_future || version < "1.8.0") {
[17:43:10.029]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:10.029]                           "", base::R.version$version.string), 
[17:43:10.029]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:10.029]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:10.029]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:10.029]                             "release", "version")], collapse = " "), 
[17:43:10.029]                           hostname = base::Sys.info()[["nodename"]])
[17:43:10.029]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:10.029]                           info)
[17:43:10.029]                         info <- base::paste(info, collapse = "; ")
[17:43:10.029]                         if (!has_future) {
[17:43:10.029]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:10.029]                             info)
[17:43:10.029]                         }
[17:43:10.029]                         else {
[17:43:10.029]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:10.029]                             info, version)
[17:43:10.029]                         }
[17:43:10.029]                         base::stop(msg)
[17:43:10.029]                       }
[17:43:10.029]                     })
[17:43:10.029]                   }
[17:43:10.029]                   options(future.plan = NULL)
[17:43:10.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:10.029]                 }
[17:43:10.029]                 ...future.workdir <- getwd()
[17:43:10.029]             }
[17:43:10.029]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:10.029]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:10.029]         }
[17:43:10.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:10.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:10.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:10.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:10.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:10.029]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:10.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:10.029]             base::names(...future.oldOptions))
[17:43:10.029]     }
[17:43:10.029]     if (FALSE) {
[17:43:10.029]     }
[17:43:10.029]     else {
[17:43:10.029]         if (TRUE) {
[17:43:10.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:10.029]                 open = "w")
[17:43:10.029]         }
[17:43:10.029]         else {
[17:43:10.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:10.029]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:10.029]         }
[17:43:10.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:10.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:10.029]             base::sink(type = "output", split = FALSE)
[17:43:10.029]             base::close(...future.stdout)
[17:43:10.029]         }, add = TRUE)
[17:43:10.029]     }
[17:43:10.029]     ...future.frame <- base::sys.nframe()
[17:43:10.029]     ...future.conditions <- base::list()
[17:43:10.029]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:10.029]     if (FALSE) {
[17:43:10.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:10.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:10.029]     }
[17:43:10.029]     ...future.result <- base::tryCatch({
[17:43:10.029]         base::withCallingHandlers({
[17:43:10.029]             ...future.value <- base::withVisible(base::local({
[17:43:10.029]                 b <- 2L
[17:43:10.029]                 plan_b <- future::plan("list")
[17:43:10.029]                 nested_b <- nested_a[-1]
[17:43:10.029]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:10.029]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:43:10.029]                   "sequential"))
[17:43:10.029]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:10.029]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:10.029]             }))
[17:43:10.029]             future::FutureResult(value = ...future.value$value, 
[17:43:10.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.029]                   ...future.rng), globalenv = if (FALSE) 
[17:43:10.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:10.029]                     ...future.globalenv.names))
[17:43:10.029]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:10.029]         }, condition = base::local({
[17:43:10.029]             c <- base::c
[17:43:10.029]             inherits <- base::inherits
[17:43:10.029]             invokeRestart <- base::invokeRestart
[17:43:10.029]             length <- base::length
[17:43:10.029]             list <- base::list
[17:43:10.029]             seq.int <- base::seq.int
[17:43:10.029]             signalCondition <- base::signalCondition
[17:43:10.029]             sys.calls <- base::sys.calls
[17:43:10.029]             `[[` <- base::`[[`
[17:43:10.029]             `+` <- base::`+`
[17:43:10.029]             `<<-` <- base::`<<-`
[17:43:10.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:10.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:10.029]                   3L)]
[17:43:10.029]             }
[17:43:10.029]             function(cond) {
[17:43:10.029]                 is_error <- inherits(cond, "error")
[17:43:10.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:10.029]                   NULL)
[17:43:10.029]                 if (is_error) {
[17:43:10.029]                   sessionInformation <- function() {
[17:43:10.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:10.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:10.029]                       search = base::search(), system = base::Sys.info())
[17:43:10.029]                   }
[17:43:10.029]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:10.029]                     cond$call), session = sessionInformation(), 
[17:43:10.029]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:10.029]                   signalCondition(cond)
[17:43:10.029]                 }
[17:43:10.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:10.029]                 "immediateCondition"))) {
[17:43:10.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:10.029]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:10.029]                   if (TRUE && !signal) {
[17:43:10.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.029]                     {
[17:43:10.029]                       inherits <- base::inherits
[17:43:10.029]                       invokeRestart <- base::invokeRestart
[17:43:10.029]                       is.null <- base::is.null
[17:43:10.029]                       muffled <- FALSE
[17:43:10.029]                       if (inherits(cond, "message")) {
[17:43:10.029]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.029]                         if (muffled) 
[17:43:10.029]                           invokeRestart("muffleMessage")
[17:43:10.029]                       }
[17:43:10.029]                       else if (inherits(cond, "warning")) {
[17:43:10.029]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.029]                         if (muffled) 
[17:43:10.029]                           invokeRestart("muffleWarning")
[17:43:10.029]                       }
[17:43:10.029]                       else if (inherits(cond, "condition")) {
[17:43:10.029]                         if (!is.null(pattern)) {
[17:43:10.029]                           computeRestarts <- base::computeRestarts
[17:43:10.029]                           grepl <- base::grepl
[17:43:10.029]                           restarts <- computeRestarts(cond)
[17:43:10.029]                           for (restart in restarts) {
[17:43:10.029]                             name <- restart$name
[17:43:10.029]                             if (is.null(name)) 
[17:43:10.029]                               next
[17:43:10.029]                             if (!grepl(pattern, name)) 
[17:43:10.029]                               next
[17:43:10.029]                             invokeRestart(restart)
[17:43:10.029]                             muffled <- TRUE
[17:43:10.029]                             break
[17:43:10.029]                           }
[17:43:10.029]                         }
[17:43:10.029]                       }
[17:43:10.029]                       invisible(muffled)
[17:43:10.029]                     }
[17:43:10.029]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.029]                   }
[17:43:10.029]                 }
[17:43:10.029]                 else {
[17:43:10.029]                   if (TRUE) {
[17:43:10.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.029]                     {
[17:43:10.029]                       inherits <- base::inherits
[17:43:10.029]                       invokeRestart <- base::invokeRestart
[17:43:10.029]                       is.null <- base::is.null
[17:43:10.029]                       muffled <- FALSE
[17:43:10.029]                       if (inherits(cond, "message")) {
[17:43:10.029]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.029]                         if (muffled) 
[17:43:10.029]                           invokeRestart("muffleMessage")
[17:43:10.029]                       }
[17:43:10.029]                       else if (inherits(cond, "warning")) {
[17:43:10.029]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.029]                         if (muffled) 
[17:43:10.029]                           invokeRestart("muffleWarning")
[17:43:10.029]                       }
[17:43:10.029]                       else if (inherits(cond, "condition")) {
[17:43:10.029]                         if (!is.null(pattern)) {
[17:43:10.029]                           computeRestarts <- base::computeRestarts
[17:43:10.029]                           grepl <- base::grepl
[17:43:10.029]                           restarts <- computeRestarts(cond)
[17:43:10.029]                           for (restart in restarts) {
[17:43:10.029]                             name <- restart$name
[17:43:10.029]                             if (is.null(name)) 
[17:43:10.029]                               next
[17:43:10.029]                             if (!grepl(pattern, name)) 
[17:43:10.029]                               next
[17:43:10.029]                             invokeRestart(restart)
[17:43:10.029]                             muffled <- TRUE
[17:43:10.029]                             break
[17:43:10.029]                           }
[17:43:10.029]                         }
[17:43:10.029]                       }
[17:43:10.029]                       invisible(muffled)
[17:43:10.029]                     }
[17:43:10.029]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.029]                   }
[17:43:10.029]                 }
[17:43:10.029]             }
[17:43:10.029]         }))
[17:43:10.029]     }, error = function(ex) {
[17:43:10.029]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:10.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.029]                 ...future.rng), started = ...future.startTime, 
[17:43:10.029]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:10.029]             version = "1.8"), class = "FutureResult")
[17:43:10.029]     }, finally = {
[17:43:10.029]         if (!identical(...future.workdir, getwd())) 
[17:43:10.029]             setwd(...future.workdir)
[17:43:10.029]         {
[17:43:10.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:10.029]                 ...future.oldOptions$nwarnings <- NULL
[17:43:10.029]             }
[17:43:10.029]             base::options(...future.oldOptions)
[17:43:10.029]             if (.Platform$OS.type == "windows") {
[17:43:10.029]                 old_names <- names(...future.oldEnvVars)
[17:43:10.029]                 envs <- base::Sys.getenv()
[17:43:10.029]                 names <- names(envs)
[17:43:10.029]                 common <- intersect(names, old_names)
[17:43:10.029]                 added <- setdiff(names, old_names)
[17:43:10.029]                 removed <- setdiff(old_names, names)
[17:43:10.029]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:10.029]                   envs[common]]
[17:43:10.029]                 NAMES <- toupper(changed)
[17:43:10.029]                 args <- list()
[17:43:10.029]                 for (kk in seq_along(NAMES)) {
[17:43:10.029]                   name <- changed[[kk]]
[17:43:10.029]                   NAME <- NAMES[[kk]]
[17:43:10.029]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.029]                     next
[17:43:10.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.029]                 }
[17:43:10.029]                 NAMES <- toupper(added)
[17:43:10.029]                 for (kk in seq_along(NAMES)) {
[17:43:10.029]                   name <- added[[kk]]
[17:43:10.029]                   NAME <- NAMES[[kk]]
[17:43:10.029]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.029]                     next
[17:43:10.029]                   args[[name]] <- ""
[17:43:10.029]                 }
[17:43:10.029]                 NAMES <- toupper(removed)
[17:43:10.029]                 for (kk in seq_along(NAMES)) {
[17:43:10.029]                   name <- removed[[kk]]
[17:43:10.029]                   NAME <- NAMES[[kk]]
[17:43:10.029]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.029]                     next
[17:43:10.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.029]                 }
[17:43:10.029]                 if (length(args) > 0) 
[17:43:10.029]                   base::do.call(base::Sys.setenv, args = args)
[17:43:10.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:10.029]             }
[17:43:10.029]             else {
[17:43:10.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:10.029]             }
[17:43:10.029]             {
[17:43:10.029]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:10.029]                   0L) {
[17:43:10.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:10.029]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:10.029]                   base::options(opts)
[17:43:10.029]                 }
[17:43:10.029]                 {
[17:43:10.029]                   {
[17:43:10.029]                     NULL
[17:43:10.029]                     RNGkind("Mersenne-Twister")
[17:43:10.029]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:10.029]                       inherits = FALSE)
[17:43:10.029]                   }
[17:43:10.029]                   options(future.plan = NULL)
[17:43:10.029]                   if (is.na(NA_character_)) 
[17:43:10.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:10.029]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:43:10.029]                   {
[17:43:10.029]                     future <- SequentialFuture(..., envir = envir)
[17:43:10.029]                     if (!future$lazy) 
[17:43:10.029]                       future <- run(future)
[17:43:10.029]                     invisible(future)
[17:43:10.029]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.029]                 }
[17:43:10.029]             }
[17:43:10.029]         }
[17:43:10.029]     })
[17:43:10.029]     if (TRUE) {
[17:43:10.029]         base::sink(type = "output", split = FALSE)
[17:43:10.029]         if (TRUE) {
[17:43:10.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:10.029]         }
[17:43:10.029]         else {
[17:43:10.029]             ...future.result["stdout"] <- base::list(NULL)
[17:43:10.029]         }
[17:43:10.029]         base::close(...future.stdout)
[17:43:10.029]         ...future.stdout <- NULL
[17:43:10.029]     }
[17:43:10.029]     ...future.result$conditions <- ...future.conditions
[17:43:10.029]     ...future.result$finished <- base::Sys.time()
[17:43:10.029]     ...future.result
[17:43:10.029] }
[17:43:10.050]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.031] assign_globals() ...
[17:43:10.052]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.031] List of 3
[17:43:10.031]  $ nested_a:List of 1
[17:43:10.031]   ..$ b:function (..., envir = parent.frame())  
[17:43:10.031]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:43:10.031]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:10.031]  $ a       : int 1
[17:43:10.031]  $ plan_a  :List of 1
[17:43:10.031]   ..$ b:function (..., envir = parent.frame())  
[17:43:10.031]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:43:10.031]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:10.031]  - attr(*, "where")=List of 3
[17:43:10.031]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:43:10.031]   ..$ a       :<environment: R_EmptyEnv> 
[17:43:10.031]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:43:10.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:10.031]  - attr(*, "resolved")= logi FALSE
[17:43:10.031]  - attr(*, "total_size")= num 23080
[17:43:10.031]  - attr(*, "already-done")= logi TRUE
[17:43:10.052]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.036] - copied ‘nested_a’ to environment
[17:43:10.052]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.036] - copied ‘a’ to environment
[17:43:10.052]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.036] - copied ‘plan_a’ to environment
[17:43:10.052]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.037] assign_globals() ... done
[17:43:10.052]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.037] plan(): Setting new future strategy stack:
[17:43:10.053]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.037] List of future strategies:
[17:43:10.037] 1. sequential:
[17:43:10.037]    - args: function (..., envir = parent.frame())
[17:43:10.037]    - tweaked: FALSE
[17:43:10.037]    - call: NULL
[17:43:10.053]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.037] plan(): nbrOfWorkers() = 1
[17:43:10.053]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.039] plan(): Setting new future strategy stack:
[17:43:10.053]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.039] List of future strategies:
[17:43:10.039] 1. sequential:
[17:43:10.039]    - args: function (..., envir = parent.frame())
[17:43:10.039]    - tweaked: FALSE
[17:43:10.039]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.053]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.039] plan(): nbrOfWorkers() = 1
[17:43:10.053]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.039] SequentialFuture started (and completed)
[17:43:10.053]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.040] - Launch lazy future ... done
[17:43:10.054]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.040] run() for ‘SequentialFuture’ ... done
[17:43:10.054] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:10.059] getGlobalsAndPackages() ...
[17:43:10.059] Searching for globals...
[17:43:10.060] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:10.061] Searching for globals ... DONE
[17:43:10.061] Resolving globals: FALSE
[17:43:10.061] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:10.062] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:10.062] - globals: [1] ‘data’
[17:43:10.062] - packages: [1] ‘future’
[17:43:10.062] getGlobalsAndPackages() ... DONE
[17:43:10.062] run() for ‘Future’ ...
[17:43:10.062] - state: ‘created’
[17:43:10.063] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:10.063] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:10.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:10.063]   - Field: ‘label’
[17:43:10.063]   - Field: ‘local’
[17:43:10.063]   - Field: ‘owner’
[17:43:10.063]   - Field: ‘envir’
[17:43:10.063]   - Field: ‘packages’
[17:43:10.063]   - Field: ‘gc’
[17:43:10.064]   - Field: ‘conditions’
[17:43:10.064]   - Field: ‘expr’
[17:43:10.064]   - Field: ‘uuid’
[17:43:10.064]   - Field: ‘seed’
[17:43:10.064]   - Field: ‘version’
[17:43:10.064]   - Field: ‘result’
[17:43:10.064]   - Field: ‘asynchronous’
[17:43:10.064]   - Field: ‘calls’
[17:43:10.064]   - Field: ‘globals’
[17:43:10.064]   - Field: ‘stdout’
[17:43:10.065]   - Field: ‘earlySignal’
[17:43:10.065]   - Field: ‘lazy’
[17:43:10.065]   - Field: ‘state’
[17:43:10.065] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:10.065] - Launch lazy future ...
[17:43:10.065] Packages needed by the future expression (n = 1): ‘future’
[17:43:10.065] Packages needed by future strategies (n = 1): ‘future’
[17:43:10.066] {
[17:43:10.066]     {
[17:43:10.066]         {
[17:43:10.066]             ...future.startTime <- base::Sys.time()
[17:43:10.066]             {
[17:43:10.066]                 {
[17:43:10.066]                   {
[17:43:10.066]                     {
[17:43:10.066]                       base::local({
[17:43:10.066]                         has_future <- base::requireNamespace("future", 
[17:43:10.066]                           quietly = TRUE)
[17:43:10.066]                         if (has_future) {
[17:43:10.066]                           ns <- base::getNamespace("future")
[17:43:10.066]                           version <- ns[[".package"]][["version"]]
[17:43:10.066]                           if (is.null(version)) 
[17:43:10.066]                             version <- utils::packageVersion("future")
[17:43:10.066]                         }
[17:43:10.066]                         else {
[17:43:10.066]                           version <- NULL
[17:43:10.066]                         }
[17:43:10.066]                         if (!has_future || version < "1.8.0") {
[17:43:10.066]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:10.066]                             "", base::R.version$version.string), 
[17:43:10.066]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:10.066]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:10.066]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:10.066]                               "release", "version")], collapse = " "), 
[17:43:10.066]                             hostname = base::Sys.info()[["nodename"]])
[17:43:10.066]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:10.066]                             info)
[17:43:10.066]                           info <- base::paste(info, collapse = "; ")
[17:43:10.066]                           if (!has_future) {
[17:43:10.066]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:10.066]                               info)
[17:43:10.066]                           }
[17:43:10.066]                           else {
[17:43:10.066]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:10.066]                               info, version)
[17:43:10.066]                           }
[17:43:10.066]                           base::stop(msg)
[17:43:10.066]                         }
[17:43:10.066]                       })
[17:43:10.066]                     }
[17:43:10.066]                     base::local({
[17:43:10.066]                       for (pkg in "future") {
[17:43:10.066]                         base::loadNamespace(pkg)
[17:43:10.066]                         base::library(pkg, character.only = TRUE)
[17:43:10.066]                       }
[17:43:10.066]                     })
[17:43:10.066]                   }
[17:43:10.066]                   options(future.plan = NULL)
[17:43:10.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.066]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:43:10.066]                   {
[17:43:10.066]                     future <- SequentialFuture(..., envir = envir)
[17:43:10.066]                     if (!future$lazy) 
[17:43:10.066]                       future <- run(future)
[17:43:10.066]                     invisible(future)
[17:43:10.066]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.066]                 }
[17:43:10.066]                 ...future.workdir <- getwd()
[17:43:10.066]             }
[17:43:10.066]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:10.066]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:10.066]         }
[17:43:10.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:10.066]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:10.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:10.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:10.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:10.066]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:10.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:10.066]             base::names(...future.oldOptions))
[17:43:10.066]     }
[17:43:10.066]     if (FALSE) {
[17:43:10.066]     }
[17:43:10.066]     else {
[17:43:10.066]         if (TRUE) {
[17:43:10.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:10.066]                 open = "w")
[17:43:10.066]         }
[17:43:10.066]         else {
[17:43:10.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:10.066]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:10.066]         }
[17:43:10.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:10.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:10.066]             base::sink(type = "output", split = FALSE)
[17:43:10.066]             base::close(...future.stdout)
[17:43:10.066]         }, add = TRUE)
[17:43:10.066]     }
[17:43:10.066]     ...future.frame <- base::sys.nframe()
[17:43:10.066]     ...future.conditions <- base::list()
[17:43:10.066]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:10.066]     if (FALSE) {
[17:43:10.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:10.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:10.066]     }
[17:43:10.066]     ...future.result <- base::tryCatch({
[17:43:10.066]         base::withCallingHandlers({
[17:43:10.066]             ...future.value <- base::withVisible(base::local({
[17:43:10.066]                 value(future(subset(data, a == 2)))
[17:43:10.066]             }))
[17:43:10.066]             future::FutureResult(value = ...future.value$value, 
[17:43:10.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.066]                   ...future.rng), globalenv = if (FALSE) 
[17:43:10.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:10.066]                     ...future.globalenv.names))
[17:43:10.066]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:10.066]         }, condition = base::local({
[17:43:10.066]             c <- base::c
[17:43:10.066]             inherits <- base::inherits
[17:43:10.066]             invokeRestart <- base::invokeRestart
[17:43:10.066]             length <- base::length
[17:43:10.066]             list <- base::list
[17:43:10.066]             seq.int <- base::seq.int
[17:43:10.066]             signalCondition <- base::signalCondition
[17:43:10.066]             sys.calls <- base::sys.calls
[17:43:10.066]             `[[` <- base::`[[`
[17:43:10.066]             `+` <- base::`+`
[17:43:10.066]             `<<-` <- base::`<<-`
[17:43:10.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:10.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:10.066]                   3L)]
[17:43:10.066]             }
[17:43:10.066]             function(cond) {
[17:43:10.066]                 is_error <- inherits(cond, "error")
[17:43:10.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:10.066]                   NULL)
[17:43:10.066]                 if (is_error) {
[17:43:10.066]                   sessionInformation <- function() {
[17:43:10.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:10.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:10.066]                       search = base::search(), system = base::Sys.info())
[17:43:10.066]                   }
[17:43:10.066]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:10.066]                     cond$call), session = sessionInformation(), 
[17:43:10.066]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:10.066]                   signalCondition(cond)
[17:43:10.066]                 }
[17:43:10.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:10.066]                 "immediateCondition"))) {
[17:43:10.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:10.066]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:10.066]                   if (TRUE && !signal) {
[17:43:10.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.066]                     {
[17:43:10.066]                       inherits <- base::inherits
[17:43:10.066]                       invokeRestart <- base::invokeRestart
[17:43:10.066]                       is.null <- base::is.null
[17:43:10.066]                       muffled <- FALSE
[17:43:10.066]                       if (inherits(cond, "message")) {
[17:43:10.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.066]                         if (muffled) 
[17:43:10.066]                           invokeRestart("muffleMessage")
[17:43:10.066]                       }
[17:43:10.066]                       else if (inherits(cond, "warning")) {
[17:43:10.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.066]                         if (muffled) 
[17:43:10.066]                           invokeRestart("muffleWarning")
[17:43:10.066]                       }
[17:43:10.066]                       else if (inherits(cond, "condition")) {
[17:43:10.066]                         if (!is.null(pattern)) {
[17:43:10.066]                           computeRestarts <- base::computeRestarts
[17:43:10.066]                           grepl <- base::grepl
[17:43:10.066]                           restarts <- computeRestarts(cond)
[17:43:10.066]                           for (restart in restarts) {
[17:43:10.066]                             name <- restart$name
[17:43:10.066]                             if (is.null(name)) 
[17:43:10.066]                               next
[17:43:10.066]                             if (!grepl(pattern, name)) 
[17:43:10.066]                               next
[17:43:10.066]                             invokeRestart(restart)
[17:43:10.066]                             muffled <- TRUE
[17:43:10.066]                             break
[17:43:10.066]                           }
[17:43:10.066]                         }
[17:43:10.066]                       }
[17:43:10.066]                       invisible(muffled)
[17:43:10.066]                     }
[17:43:10.066]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.066]                   }
[17:43:10.066]                 }
[17:43:10.066]                 else {
[17:43:10.066]                   if (TRUE) {
[17:43:10.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.066]                     {
[17:43:10.066]                       inherits <- base::inherits
[17:43:10.066]                       invokeRestart <- base::invokeRestart
[17:43:10.066]                       is.null <- base::is.null
[17:43:10.066]                       muffled <- FALSE
[17:43:10.066]                       if (inherits(cond, "message")) {
[17:43:10.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.066]                         if (muffled) 
[17:43:10.066]                           invokeRestart("muffleMessage")
[17:43:10.066]                       }
[17:43:10.066]                       else if (inherits(cond, "warning")) {
[17:43:10.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.066]                         if (muffled) 
[17:43:10.066]                           invokeRestart("muffleWarning")
[17:43:10.066]                       }
[17:43:10.066]                       else if (inherits(cond, "condition")) {
[17:43:10.066]                         if (!is.null(pattern)) {
[17:43:10.066]                           computeRestarts <- base::computeRestarts
[17:43:10.066]                           grepl <- base::grepl
[17:43:10.066]                           restarts <- computeRestarts(cond)
[17:43:10.066]                           for (restart in restarts) {
[17:43:10.066]                             name <- restart$name
[17:43:10.066]                             if (is.null(name)) 
[17:43:10.066]                               next
[17:43:10.066]                             if (!grepl(pattern, name)) 
[17:43:10.066]                               next
[17:43:10.066]                             invokeRestart(restart)
[17:43:10.066]                             muffled <- TRUE
[17:43:10.066]                             break
[17:43:10.066]                           }
[17:43:10.066]                         }
[17:43:10.066]                       }
[17:43:10.066]                       invisible(muffled)
[17:43:10.066]                     }
[17:43:10.066]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.066]                   }
[17:43:10.066]                 }
[17:43:10.066]             }
[17:43:10.066]         }))
[17:43:10.066]     }, error = function(ex) {
[17:43:10.066]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:10.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.066]                 ...future.rng), started = ...future.startTime, 
[17:43:10.066]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:10.066]             version = "1.8"), class = "FutureResult")
[17:43:10.066]     }, finally = {
[17:43:10.066]         if (!identical(...future.workdir, getwd())) 
[17:43:10.066]             setwd(...future.workdir)
[17:43:10.066]         {
[17:43:10.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:10.066]                 ...future.oldOptions$nwarnings <- NULL
[17:43:10.066]             }
[17:43:10.066]             base::options(...future.oldOptions)
[17:43:10.066]             if (.Platform$OS.type == "windows") {
[17:43:10.066]                 old_names <- names(...future.oldEnvVars)
[17:43:10.066]                 envs <- base::Sys.getenv()
[17:43:10.066]                 names <- names(envs)
[17:43:10.066]                 common <- intersect(names, old_names)
[17:43:10.066]                 added <- setdiff(names, old_names)
[17:43:10.066]                 removed <- setdiff(old_names, names)
[17:43:10.066]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:10.066]                   envs[common]]
[17:43:10.066]                 NAMES <- toupper(changed)
[17:43:10.066]                 args <- list()
[17:43:10.066]                 for (kk in seq_along(NAMES)) {
[17:43:10.066]                   name <- changed[[kk]]
[17:43:10.066]                   NAME <- NAMES[[kk]]
[17:43:10.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.066]                     next
[17:43:10.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.066]                 }
[17:43:10.066]                 NAMES <- toupper(added)
[17:43:10.066]                 for (kk in seq_along(NAMES)) {
[17:43:10.066]                   name <- added[[kk]]
[17:43:10.066]                   NAME <- NAMES[[kk]]
[17:43:10.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.066]                     next
[17:43:10.066]                   args[[name]] <- ""
[17:43:10.066]                 }
[17:43:10.066]                 NAMES <- toupper(removed)
[17:43:10.066]                 for (kk in seq_along(NAMES)) {
[17:43:10.066]                   name <- removed[[kk]]
[17:43:10.066]                   NAME <- NAMES[[kk]]
[17:43:10.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.066]                     next
[17:43:10.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.066]                 }
[17:43:10.066]                 if (length(args) > 0) 
[17:43:10.066]                   base::do.call(base::Sys.setenv, args = args)
[17:43:10.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:10.066]             }
[17:43:10.066]             else {
[17:43:10.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:10.066]             }
[17:43:10.066]             {
[17:43:10.066]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:10.066]                   0L) {
[17:43:10.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:10.066]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:10.066]                   base::options(opts)
[17:43:10.066]                 }
[17:43:10.066]                 {
[17:43:10.066]                   {
[17:43:10.066]                     NULL
[17:43:10.066]                     RNGkind("Mersenne-Twister")
[17:43:10.066]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:10.066]                       inherits = FALSE)
[17:43:10.066]                   }
[17:43:10.066]                   options(future.plan = NULL)
[17:43:10.066]                   if (is.na(NA_character_)) 
[17:43:10.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:10.066]                   future::plan(list(a = function (..., envir = parent.frame()) 
[17:43:10.066]                   {
[17:43:10.066]                     future <- SequentialFuture(..., envir = envir)
[17:43:10.066]                     if (!future$lazy) 
[17:43:10.066]                       future <- run(future)
[17:43:10.066]                     invisible(future)
[17:43:10.066]                   }, b = function (..., envir = parent.frame()) 
[17:43:10.066]                   {
[17:43:10.066]                     future <- SequentialFuture(..., envir = envir)
[17:43:10.066]                     if (!future$lazy) 
[17:43:10.066]                       future <- run(future)
[17:43:10.066]                     invisible(future)
[17:43:10.066]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.066]                 }
[17:43:10.066]             }
[17:43:10.066]         }
[17:43:10.066]     })
[17:43:10.066]     if (TRUE) {
[17:43:10.066]         base::sink(type = "output", split = FALSE)
[17:43:10.066]         if (TRUE) {
[17:43:10.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:10.066]         }
[17:43:10.066]         else {
[17:43:10.066]             ...future.result["stdout"] <- base::list(NULL)
[17:43:10.066]         }
[17:43:10.066]         base::close(...future.stdout)
[17:43:10.066]         ...future.stdout <- NULL
[17:43:10.066]     }
[17:43:10.066]     ...future.result$conditions <- ...future.conditions
[17:43:10.066]     ...future.result$finished <- base::Sys.time()
[17:43:10.066]     ...future.result
[17:43:10.066] }
[17:43:10.068] assign_globals() ...
[17:43:10.068] List of 1
[17:43:10.068]  $ data:'data.frame':	3 obs. of  2 variables:
[17:43:10.068]   ..$ a: int [1:3] 1 2 3
[17:43:10.068]   ..$ b: int [1:3] 3 2 1
[17:43:10.068]  - attr(*, "where")=List of 1
[17:43:10.068]   ..$ data:<environment: R_EmptyEnv> 
[17:43:10.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:10.068]  - attr(*, "resolved")= logi FALSE
[17:43:10.068]  - attr(*, "total_size")= num 128
[17:43:10.068]  - attr(*, "already-done")= logi TRUE
[17:43:10.071] - copied ‘data’ to environment
[17:43:10.071] assign_globals() ... done
[17:43:10.072] plan(): Setting new future strategy stack:
[17:43:10.072] List of future strategies:
[17:43:10.072] 1. sequential:
[17:43:10.072]    - args: function (..., envir = parent.frame())
[17:43:10.072]    - tweaked: FALSE
[17:43:10.072]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.072] plan(): nbrOfWorkers() = 1
[17:43:10.105] plan(): Setting new future strategy stack:
[17:43:10.105] List of future strategies:
[17:43:10.105] 1. sequential:
[17:43:10.105]    - args: function (..., envir = parent.frame())
[17:43:10.105]    - tweaked: FALSE
[17:43:10.105]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.105] 2. sequential:
[17:43:10.105]    - args: function (..., envir = parent.frame())
[17:43:10.105]    - tweaked: FALSE
[17:43:10.105]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.106] plan(): nbrOfWorkers() = 1
[17:43:10.106] SequentialFuture started (and completed)
[17:43:10.106] signalConditions() ...
[17:43:10.106]  - include = ‘immediateCondition’
[17:43:10.106]  - exclude = 
[17:43:10.106]  - resignal = FALSE
[17:43:10.106]  - Number of conditions: 52
[17:43:10.106] signalConditions() ... done
[17:43:10.107] - Launch lazy future ... done
[17:43:10.107] run() for ‘SequentialFuture’ ... done
[17:43:10.107] signalConditions() ...
[17:43:10.107]  - include = ‘immediateCondition’
[17:43:10.107]  - exclude = 
[17:43:10.107]  - resignal = FALSE
[17:43:10.107]  - Number of conditions: 52
[17:43:10.107] signalConditions() ... done
[17:43:10.107] Future state: ‘finished’
[17:43:10.108] signalConditions() ...
[17:43:10.108]  - include = ‘condition’
[17:43:10.108]  - exclude = ‘immediateCondition’
[17:43:10.108]  - resignal = TRUE
[17:43:10.108]  - Number of conditions: 52
[17:43:10.108]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.073] getGlobalsAndPackages() ...
[17:43:10.108]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.073] Searching for globals...
[17:43:10.108]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.089] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:10.109]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.089] Searching for globals ... DONE
[17:43:10.109]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.090] Resolving globals: FALSE
[17:43:10.109]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.090] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:10.109]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.090] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:10.109]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.091] - globals: [1] ‘data’
[17:43:10.109]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.091] 
[17:43:10.110]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.091] getGlobalsAndPackages() ... DONE
[17:43:10.110]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.091] run() for ‘Future’ ...
[17:43:10.110]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.091] - state: ‘created’
[17:43:10.110]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.091] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:10.110]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.092] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:10.110]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.092] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:10.110]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.092]   - Field: ‘label’
[17:43:10.110]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.092]   - Field: ‘local’
[17:43:10.111]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.092]   - Field: ‘owner’
[17:43:10.111]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.092]   - Field: ‘envir’
[17:43:10.111]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.092]   - Field: ‘packages’
[17:43:10.111]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.093]   - Field: ‘gc’
[17:43:10.111]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.093]   - Field: ‘conditions’
[17:43:10.111]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.093]   - Field: ‘expr’
[17:43:10.111]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.093]   - Field: ‘uuid’
[17:43:10.112]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.093]   - Field: ‘seed’
[17:43:10.112]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.093]   - Field: ‘version’
[17:43:10.112]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.093]   - Field: ‘result’
[17:43:10.112]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.093]   - Field: ‘asynchronous’
[17:43:10.112]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.093]   - Field: ‘calls’
[17:43:10.112]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.093]   - Field: ‘globals’
[17:43:10.112]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.094]   - Field: ‘stdout’
[17:43:10.113]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.094]   - Field: ‘earlySignal’
[17:43:10.113]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.094]   - Field: ‘lazy’
[17:43:10.113]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.094]   - Field: ‘state’
[17:43:10.113]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:10.113]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.094] - Launch lazy future ...
[17:43:10.113]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.094] Packages needed by the future expression (n = 0): <none>
[17:43:10.113]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.094] Packages needed by future strategies (n = 0): <none>
[17:43:10.113]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.095] {
[17:43:10.095]     {
[17:43:10.095]         {
[17:43:10.095]             ...future.startTime <- base::Sys.time()
[17:43:10.095]             {
[17:43:10.095]                 {
[17:43:10.095]                   {
[17:43:10.095]                     base::local({
[17:43:10.095]                       has_future <- base::requireNamespace("future", 
[17:43:10.095]                         quietly = TRUE)
[17:43:10.095]                       if (has_future) {
[17:43:10.095]                         ns <- base::getNamespace("future")
[17:43:10.095]                         version <- ns[[".package"]][["version"]]
[17:43:10.095]                         if (is.null(version)) 
[17:43:10.095]                           version <- utils::packageVersion("future")
[17:43:10.095]                       }
[17:43:10.095]                       else {
[17:43:10.095]                         version <- NULL
[17:43:10.095]                       }
[17:43:10.095]                       if (!has_future || version < "1.8.0") {
[17:43:10.095]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:10.095]                           "", base::R.version$version.string), 
[17:43:10.095]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:10.095]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:10.095]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:10.095]                             "release", "version")], collapse = " "), 
[17:43:10.095]                           hostname = base::Sys.info()[["nodename"]])
[17:43:10.095]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:10.095]                           info)
[17:43:10.095]                         info <- base::paste(info, collapse = "; ")
[17:43:10.095]                         if (!has_future) {
[17:43:10.095]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:10.095]                             info)
[17:43:10.095]                         }
[17:43:10.095]                         else {
[17:43:10.095]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:10.095]                             info, version)
[17:43:10.095]                         }
[17:43:10.095]                         base::stop(msg)
[17:43:10.095]                       }
[17:43:10.095]                     })
[17:43:10.095]                   }
[17:43:10.095]                   options(future.plan = NULL)
[17:43:10.095]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.095]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:10.095]                 }
[17:43:10.095]                 ...future.workdir <- getwd()
[17:43:10.095]             }
[17:43:10.095]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:10.095]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:10.095]         }
[17:43:10.095]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:10.095]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:10.095]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:10.095]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:10.095]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:10.095]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:10.095]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:10.095]             base::names(...future.oldOptions))
[17:43:10.095]     }
[17:43:10.095]     if (FALSE) {
[17:43:10.095]     }
[17:43:10.095]     else {
[17:43:10.095]         if (TRUE) {
[17:43:10.095]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:10.095]                 open = "w")
[17:43:10.095]         }
[17:43:10.095]         else {
[17:43:10.095]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:10.095]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:10.095]         }
[17:43:10.095]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:10.095]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:10.095]             base::sink(type = "output", split = FALSE)
[17:43:10.095]             base::close(...future.stdout)
[17:43:10.095]         }, add = TRUE)
[17:43:10.095]     }
[17:43:10.095]     ...future.frame <- base::sys.nframe()
[17:43:10.095]     ...future.conditions <- base::list()
[17:43:10.095]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:10.095]     if (FALSE) {
[17:43:10.095]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:10.095]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:10.095]     }
[17:43:10.095]     ...future.result <- base::tryCatch({
[17:43:10.095]         base::withCallingHandlers({
[17:43:10.095]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:43:10.095]                 a == 2)))
[17:43:10.095]             future::FutureResult(value = ...future.value$value, 
[17:43:10.095]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.095]                   ...future.rng), globalenv = if (FALSE) 
[17:43:10.095]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:10.095]                     ...future.globalenv.names))
[17:43:10.095]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:10.095]         }, condition = base::local({
[17:43:10.095]             c <- base::c
[17:43:10.095]             inherits <- base::inherits
[17:43:10.095]             invokeRestart <- base::invokeRestart
[17:43:10.095]             length <- base::length
[17:43:10.095]             list <- base::list
[17:43:10.095]             seq.int <- base::seq.int
[17:43:10.095]             signalCondition <- base::signalCondition
[17:43:10.095]             sys.calls <- base::sys.calls
[17:43:10.095]             `[[` <- base::`[[`
[17:43:10.095]             `+` <- base::`+`
[17:43:10.095]             `<<-` <- base::`<<-`
[17:43:10.095]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:10.095]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:10.095]                   3L)]
[17:43:10.095]             }
[17:43:10.095]             function(cond) {
[17:43:10.095]                 is_error <- inherits(cond, "error")
[17:43:10.095]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:10.095]                   NULL)
[17:43:10.095]                 if (is_error) {
[17:43:10.095]                   sessionInformation <- function() {
[17:43:10.095]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:10.095]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:10.095]                       search = base::search(), system = base::Sys.info())
[17:43:10.095]                   }
[17:43:10.095]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.095]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:10.095]                     cond$call), session = sessionInformation(), 
[17:43:10.095]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:10.095]                   signalCondition(cond)
[17:43:10.095]                 }
[17:43:10.095]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:10.095]                 "immediateCondition"))) {
[17:43:10.095]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:10.095]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.095]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:10.095]                   if (TRUE && !signal) {
[17:43:10.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.095]                     {
[17:43:10.095]                       inherits <- base::inherits
[17:43:10.095]                       invokeRestart <- base::invokeRestart
[17:43:10.095]                       is.null <- base::is.null
[17:43:10.095]                       muffled <- FALSE
[17:43:10.095]                       if (inherits(cond, "message")) {
[17:43:10.095]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.095]                         if (muffled) 
[17:43:10.095]                           invokeRestart("muffleMessage")
[17:43:10.095]                       }
[17:43:10.095]                       else if (inherits(cond, "warning")) {
[17:43:10.095]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.095]                         if (muffled) 
[17:43:10.095]                           invokeRestart("muffleWarning")
[17:43:10.095]                       }
[17:43:10.095]                       else if (inherits(cond, "condition")) {
[17:43:10.095]                         if (!is.null(pattern)) {
[17:43:10.095]                           computeRestarts <- base::computeRestarts
[17:43:10.095]                           grepl <- base::grepl
[17:43:10.095]                           restarts <- computeRestarts(cond)
[17:43:10.095]                           for (restart in restarts) {
[17:43:10.095]                             name <- restart$name
[17:43:10.095]                             if (is.null(name)) 
[17:43:10.095]                               next
[17:43:10.095]                             if (!grepl(pattern, name)) 
[17:43:10.095]                               next
[17:43:10.095]                             invokeRestart(restart)
[17:43:10.095]                             muffled <- TRUE
[17:43:10.095]                             break
[17:43:10.095]                           }
[17:43:10.095]                         }
[17:43:10.095]                       }
[17:43:10.095]                       invisible(muffled)
[17:43:10.095]                     }
[17:43:10.095]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.095]                   }
[17:43:10.095]                 }
[17:43:10.095]                 else {
[17:43:10.095]                   if (TRUE) {
[17:43:10.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.095]                     {
[17:43:10.095]                       inherits <- base::inherits
[17:43:10.095]                       invokeRestart <- base::invokeRestart
[17:43:10.095]                       is.null <- base::is.null
[17:43:10.095]                       muffled <- FALSE
[17:43:10.095]                       if (inherits(cond, "message")) {
[17:43:10.095]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.095]                         if (muffled) 
[17:43:10.095]                           invokeRestart("muffleMessage")
[17:43:10.095]                       }
[17:43:10.095]                       else if (inherits(cond, "warning")) {
[17:43:10.095]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.095]                         if (muffled) 
[17:43:10.095]                           invokeRestart("muffleWarning")
[17:43:10.095]                       }
[17:43:10.095]                       else if (inherits(cond, "condition")) {
[17:43:10.095]                         if (!is.null(pattern)) {
[17:43:10.095]                           computeRestarts <- base::computeRestarts
[17:43:10.095]                           grepl <- base::grepl
[17:43:10.095]                           restarts <- computeRestarts(cond)
[17:43:10.095]                           for (restart in restarts) {
[17:43:10.095]                             name <- restart$name
[17:43:10.095]                             if (is.null(name)) 
[17:43:10.095]                               next
[17:43:10.095]                             if (!grepl(pattern, name)) 
[17:43:10.095]                               next
[17:43:10.095]                             invokeRestart(restart)
[17:43:10.095]                             muffled <- TRUE
[17:43:10.095]                             break
[17:43:10.095]                           }
[17:43:10.095]                         }
[17:43:10.095]                       }
[17:43:10.095]                       invisible(muffled)
[17:43:10.095]                     }
[17:43:10.095]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.095]                   }
[17:43:10.095]                 }
[17:43:10.095]             }
[17:43:10.095]         }))
[17:43:10.095]     }, error = function(ex) {
[17:43:10.095]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:10.095]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.095]                 ...future.rng), started = ...future.startTime, 
[17:43:10.095]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:10.095]             version = "1.8"), class = "FutureResult")
[17:43:10.095]     }, finally = {
[17:43:10.095]         if (!identical(...future.workdir, getwd())) 
[17:43:10.095]             setwd(...future.workdir)
[17:43:10.095]         {
[17:43:10.095]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:10.095]                 ...future.oldOptions$nwarnings <- NULL
[17:43:10.095]             }
[17:43:10.095]             base::options(...future.oldOptions)
[17:43:10.095]             if (.Platform$OS.type == "windows") {
[17:43:10.095]                 old_names <- names(...future.oldEnvVars)
[17:43:10.095]                 envs <- base::Sys.getenv()
[17:43:10.095]                 names <- names(envs)
[17:43:10.095]                 common <- intersect(names, old_names)
[17:43:10.095]                 added <- setdiff(names, old_names)
[17:43:10.095]                 removed <- setdiff(old_names, names)
[17:43:10.095]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:10.095]                   envs[common]]
[17:43:10.095]                 NAMES <- toupper(changed)
[17:43:10.095]                 args <- list()
[17:43:10.095]                 for (kk in seq_along(NAMES)) {
[17:43:10.095]                   name <- changed[[kk]]
[17:43:10.095]                   NAME <- NAMES[[kk]]
[17:43:10.095]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.095]                     next
[17:43:10.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.095]                 }
[17:43:10.095]                 NAMES <- toupper(added)
[17:43:10.095]                 for (kk in seq_along(NAMES)) {
[17:43:10.095]                   name <- added[[kk]]
[17:43:10.095]                   NAME <- NAMES[[kk]]
[17:43:10.095]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.095]                     next
[17:43:10.095]                   args[[name]] <- ""
[17:43:10.095]                 }
[17:43:10.095]                 NAMES <- toupper(removed)
[17:43:10.095]                 for (kk in seq_along(NAMES)) {
[17:43:10.095]                   name <- removed[[kk]]
[17:43:10.095]                   NAME <- NAMES[[kk]]
[17:43:10.095]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.095]                     next
[17:43:10.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.095]                 }
[17:43:10.095]                 if (length(args) > 0) 
[17:43:10.095]                   base::do.call(base::Sys.setenv, args = args)
[17:43:10.095]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:10.095]             }
[17:43:10.095]             else {
[17:43:10.095]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:10.095]             }
[17:43:10.095]             {
[17:43:10.095]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:10.095]                   0L) {
[17:43:10.095]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:10.095]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:10.095]                   base::options(opts)
[17:43:10.095]                 }
[17:43:10.095]                 {
[17:43:10.095]                   {
[17:43:10.095]                     NULL
[17:43:10.095]                     RNGkind("Mersenne-Twister")
[17:43:10.095]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:10.095]                       inherits = FALSE)
[17:43:10.095]                   }
[17:43:10.095]                   options(future.plan = NULL)
[17:43:10.095]                   if (is.na(NA_character_)) 
[17:43:10.095]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.095]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:10.095]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:43:10.095]                   {
[17:43:10.095]                     future <- SequentialFuture(..., envir = envir)
[17:43:10.095]                     if (!future$lazy) 
[17:43:10.095]                       future <- run(future)
[17:43:10.095]                     invisible(future)
[17:43:10.095]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.095]                 }
[17:43:10.095]             }
[17:43:10.095]         }
[17:43:10.095]     })
[17:43:10.095]     if (TRUE) {
[17:43:10.095]         base::sink(type = "output", split = FALSE)
[17:43:10.095]         if (TRUE) {
[17:43:10.095]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:10.095]         }
[17:43:10.095]         else {
[17:43:10.095]             ...future.result["stdout"] <- base::list(NULL)
[17:43:10.095]         }
[17:43:10.095]         base::close(...future.stdout)
[17:43:10.095]         ...future.stdout <- NULL
[17:43:10.095]     }
[17:43:10.095]     ...future.result$conditions <- ...future.conditions
[17:43:10.095]     ...future.result$finished <- base::Sys.time()
[17:43:10.095]     ...future.result
[17:43:10.095] }
[17:43:10.114]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.096] assign_globals() ...
[17:43:10.114]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.097] List of 1
[17:43:10.097]  $ data:'data.frame':	3 obs. of  2 variables:
[17:43:10.097]   ..$ a: int [1:3] 1 2 3
[17:43:10.097]   ..$ b: int [1:3] 3 2 1
[17:43:10.097]  - attr(*, "where")=List of 1
[17:43:10.097]   ..$ data:<environment: R_EmptyEnv> 
[17:43:10.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:10.097]  - attr(*, "resolved")= logi FALSE
[17:43:10.097]  - attr(*, "total_size")= num 128
[17:43:10.097]  - attr(*, "already-done")= logi TRUE
[17:43:10.114]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.102] - copied ‘data’ to environment
[17:43:10.114]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.102] assign_globals() ... done
[17:43:10.114]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.102] plan(): Setting new future strategy stack:
[17:43:10.114]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.102] List of future strategies:
[17:43:10.102] 1. sequential:
[17:43:10.102]    - args: function (..., envir = parent.frame())
[17:43:10.102]    - tweaked: FALSE
[17:43:10.102]    - call: NULL
[17:43:10.114]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.103] plan(): nbrOfWorkers() = 1
[17:43:10.115]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.103] plan(): Setting new future strategy stack:
[17:43:10.115]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.104] List of future strategies:
[17:43:10.104] 1. sequential:
[17:43:10.104]    - args: function (..., envir = parent.frame())
[17:43:10.104]    - tweaked: FALSE
[17:43:10.104]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.115]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.104] plan(): nbrOfWorkers() = 1
[17:43:10.115]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.104] SequentialFuture started (and completed)
[17:43:10.115]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.104] - Launch lazy future ... done
[17:43:10.115]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.104] run() for ‘SequentialFuture’ ... done
[17:43:10.115] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[17:43:10.116] plan(): Setting new future strategy stack:
[17:43:10.116] List of future strategies:
[17:43:10.116] 1. sequential:
[17:43:10.116]    - args: function (..., envir = parent.frame())
[17:43:10.116]    - tweaked: FALSE
[17:43:10.116]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.116] 2. multicore:
[17:43:10.116]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:10.116]    - tweaked: FALSE
[17:43:10.116]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.117] plan(): nbrOfWorkers() = 1
[17:43:10.117] getGlobalsAndPackages() ...
[17:43:10.117] Searching for globals...
[17:43:10.135] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:43:10.135] Searching for globals ... DONE
[17:43:10.135] Resolving globals: FALSE
[17:43:10.136] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[17:43:10.137] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:43:10.137] - globals: [2] ‘nested’, ‘strategy2’
[17:43:10.137] - packages: [1] ‘future’
[17:43:10.137] getGlobalsAndPackages() ... DONE
[17:43:10.137] run() for ‘Future’ ...
[17:43:10.138] - state: ‘created’
[17:43:10.138] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:10.138] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:10.138] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:10.138]   - Field: ‘label’
[17:43:10.138]   - Field: ‘local’
[17:43:10.138]   - Field: ‘owner’
[17:43:10.139]   - Field: ‘envir’
[17:43:10.139]   - Field: ‘packages’
[17:43:10.139]   - Field: ‘gc’
[17:43:10.139]   - Field: ‘conditions’
[17:43:10.139]   - Field: ‘expr’
[17:43:10.139]   - Field: ‘uuid’
[17:43:10.139]   - Field: ‘seed’
[17:43:10.139]   - Field: ‘version’
[17:43:10.139]   - Field: ‘result’
[17:43:10.139]   - Field: ‘asynchronous’
[17:43:10.140]   - Field: ‘calls’
[17:43:10.140]   - Field: ‘globals’
[17:43:10.140]   - Field: ‘stdout’
[17:43:10.140]   - Field: ‘earlySignal’
[17:43:10.140]   - Field: ‘lazy’
[17:43:10.140]   - Field: ‘state’
[17:43:10.140] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:10.140] - Launch lazy future ...
[17:43:10.140] Packages needed by the future expression (n = 1): ‘future’
[17:43:10.141] Packages needed by future strategies (n = 1): ‘future’
[17:43:10.141] {
[17:43:10.141]     {
[17:43:10.141]         {
[17:43:10.141]             ...future.startTime <- base::Sys.time()
[17:43:10.141]             {
[17:43:10.141]                 {
[17:43:10.141]                   {
[17:43:10.141]                     {
[17:43:10.141]                       base::local({
[17:43:10.141]                         has_future <- base::requireNamespace("future", 
[17:43:10.141]                           quietly = TRUE)
[17:43:10.141]                         if (has_future) {
[17:43:10.141]                           ns <- base::getNamespace("future")
[17:43:10.141]                           version <- ns[[".package"]][["version"]]
[17:43:10.141]                           if (is.null(version)) 
[17:43:10.141]                             version <- utils::packageVersion("future")
[17:43:10.141]                         }
[17:43:10.141]                         else {
[17:43:10.141]                           version <- NULL
[17:43:10.141]                         }
[17:43:10.141]                         if (!has_future || version < "1.8.0") {
[17:43:10.141]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:10.141]                             "", base::R.version$version.string), 
[17:43:10.141]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:10.141]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:10.141]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:10.141]                               "release", "version")], collapse = " "), 
[17:43:10.141]                             hostname = base::Sys.info()[["nodename"]])
[17:43:10.141]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:10.141]                             info)
[17:43:10.141]                           info <- base::paste(info, collapse = "; ")
[17:43:10.141]                           if (!has_future) {
[17:43:10.141]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:10.141]                               info)
[17:43:10.141]                           }
[17:43:10.141]                           else {
[17:43:10.141]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:10.141]                               info, version)
[17:43:10.141]                           }
[17:43:10.141]                           base::stop(msg)
[17:43:10.141]                         }
[17:43:10.141]                       })
[17:43:10.141]                     }
[17:43:10.141]                     base::local({
[17:43:10.141]                       for (pkg in "future") {
[17:43:10.141]                         base::loadNamespace(pkg)
[17:43:10.141]                         base::library(pkg, character.only = TRUE)
[17:43:10.141]                       }
[17:43:10.141]                     })
[17:43:10.141]                   }
[17:43:10.141]                   options(future.plan = NULL)
[17:43:10.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.141]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:10.141]                     envir = parent.frame()) 
[17:43:10.141]                   {
[17:43:10.141]                     default_workers <- missing(workers)
[17:43:10.141]                     if (is.function(workers)) 
[17:43:10.141]                       workers <- workers()
[17:43:10.141]                     workers <- structure(as.integer(workers), 
[17:43:10.141]                       class = class(workers))
[17:43:10.141]                     stop_if_not(is.finite(workers), workers >= 
[17:43:10.141]                       1L)
[17:43:10.141]                     if ((workers == 1L && !inherits(workers, 
[17:43:10.141]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:10.141]                       if (default_workers) 
[17:43:10.141]                         supportsMulticore(warn = TRUE)
[17:43:10.141]                       return(sequential(..., envir = envir))
[17:43:10.141]                     }
[17:43:10.141]                     oopts <- options(mc.cores = workers)
[17:43:10.141]                     on.exit(options(oopts))
[17:43:10.141]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:10.141]                       envir = envir)
[17:43:10.141]                     if (!future$lazy) 
[17:43:10.141]                       future <- run(future)
[17:43:10.141]                     invisible(future)
[17:43:10.141]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.141]                 }
[17:43:10.141]                 ...future.workdir <- getwd()
[17:43:10.141]             }
[17:43:10.141]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:10.141]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:10.141]         }
[17:43:10.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:10.141]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:10.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:10.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:10.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:10.141]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:10.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:10.141]             base::names(...future.oldOptions))
[17:43:10.141]     }
[17:43:10.141]     if (FALSE) {
[17:43:10.141]     }
[17:43:10.141]     else {
[17:43:10.141]         if (TRUE) {
[17:43:10.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:10.141]                 open = "w")
[17:43:10.141]         }
[17:43:10.141]         else {
[17:43:10.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:10.141]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:10.141]         }
[17:43:10.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:10.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:10.141]             base::sink(type = "output", split = FALSE)
[17:43:10.141]             base::close(...future.stdout)
[17:43:10.141]         }, add = TRUE)
[17:43:10.141]     }
[17:43:10.141]     ...future.frame <- base::sys.nframe()
[17:43:10.141]     ...future.conditions <- base::list()
[17:43:10.141]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:10.141]     if (FALSE) {
[17:43:10.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:10.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:10.141]     }
[17:43:10.141]     ...future.result <- base::tryCatch({
[17:43:10.141]         base::withCallingHandlers({
[17:43:10.141]             ...future.value <- base::withVisible(base::local({
[17:43:10.141]                 a <- 1L
[17:43:10.141]                 plan_a <- unclass(future::plan("list"))
[17:43:10.141]                 nested_a <- nested[-1]
[17:43:10.141]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:43:10.141]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:43:10.141]                   strategy2))
[17:43:10.141]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:43:10.141]                   "init") <- NULL
[17:43:10.141]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:43:10.141]                   "init") <- NULL
[17:43:10.141]                 stopifnot(all.equal(plan_a, nested_a))
[17:43:10.141]                 y %<-% {
[17:43:10.141]                   b <- 2L
[17:43:10.141]                   plan_b <- future::plan("list")
[17:43:10.141]                   nested_b <- nested_a[-1]
[17:43:10.141]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:10.141]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:43:10.141]                     "sequential"))
[17:43:10.141]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:10.141]                     b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:10.141]                 }
[17:43:10.141]                 y
[17:43:10.141]             }))
[17:43:10.141]             future::FutureResult(value = ...future.value$value, 
[17:43:10.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.141]                   ...future.rng), globalenv = if (FALSE) 
[17:43:10.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:10.141]                     ...future.globalenv.names))
[17:43:10.141]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:10.141]         }, condition = base::local({
[17:43:10.141]             c <- base::c
[17:43:10.141]             inherits <- base::inherits
[17:43:10.141]             invokeRestart <- base::invokeRestart
[17:43:10.141]             length <- base::length
[17:43:10.141]             list <- base::list
[17:43:10.141]             seq.int <- base::seq.int
[17:43:10.141]             signalCondition <- base::signalCondition
[17:43:10.141]             sys.calls <- base::sys.calls
[17:43:10.141]             `[[` <- base::`[[`
[17:43:10.141]             `+` <- base::`+`
[17:43:10.141]             `<<-` <- base::`<<-`
[17:43:10.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:10.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:10.141]                   3L)]
[17:43:10.141]             }
[17:43:10.141]             function(cond) {
[17:43:10.141]                 is_error <- inherits(cond, "error")
[17:43:10.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:10.141]                   NULL)
[17:43:10.141]                 if (is_error) {
[17:43:10.141]                   sessionInformation <- function() {
[17:43:10.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:10.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:10.141]                       search = base::search(), system = base::Sys.info())
[17:43:10.141]                   }
[17:43:10.141]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:10.141]                     cond$call), session = sessionInformation(), 
[17:43:10.141]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:10.141]                   signalCondition(cond)
[17:43:10.141]                 }
[17:43:10.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:10.141]                 "immediateCondition"))) {
[17:43:10.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:10.141]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:10.141]                   if (TRUE && !signal) {
[17:43:10.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.141]                     {
[17:43:10.141]                       inherits <- base::inherits
[17:43:10.141]                       invokeRestart <- base::invokeRestart
[17:43:10.141]                       is.null <- base::is.null
[17:43:10.141]                       muffled <- FALSE
[17:43:10.141]                       if (inherits(cond, "message")) {
[17:43:10.141]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.141]                         if (muffled) 
[17:43:10.141]                           invokeRestart("muffleMessage")
[17:43:10.141]                       }
[17:43:10.141]                       else if (inherits(cond, "warning")) {
[17:43:10.141]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.141]                         if (muffled) 
[17:43:10.141]                           invokeRestart("muffleWarning")
[17:43:10.141]                       }
[17:43:10.141]                       else if (inherits(cond, "condition")) {
[17:43:10.141]                         if (!is.null(pattern)) {
[17:43:10.141]                           computeRestarts <- base::computeRestarts
[17:43:10.141]                           grepl <- base::grepl
[17:43:10.141]                           restarts <- computeRestarts(cond)
[17:43:10.141]                           for (restart in restarts) {
[17:43:10.141]                             name <- restart$name
[17:43:10.141]                             if (is.null(name)) 
[17:43:10.141]                               next
[17:43:10.141]                             if (!grepl(pattern, name)) 
[17:43:10.141]                               next
[17:43:10.141]                             invokeRestart(restart)
[17:43:10.141]                             muffled <- TRUE
[17:43:10.141]                             break
[17:43:10.141]                           }
[17:43:10.141]                         }
[17:43:10.141]                       }
[17:43:10.141]                       invisible(muffled)
[17:43:10.141]                     }
[17:43:10.141]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.141]                   }
[17:43:10.141]                 }
[17:43:10.141]                 else {
[17:43:10.141]                   if (TRUE) {
[17:43:10.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.141]                     {
[17:43:10.141]                       inherits <- base::inherits
[17:43:10.141]                       invokeRestart <- base::invokeRestart
[17:43:10.141]                       is.null <- base::is.null
[17:43:10.141]                       muffled <- FALSE
[17:43:10.141]                       if (inherits(cond, "message")) {
[17:43:10.141]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.141]                         if (muffled) 
[17:43:10.141]                           invokeRestart("muffleMessage")
[17:43:10.141]                       }
[17:43:10.141]                       else if (inherits(cond, "warning")) {
[17:43:10.141]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.141]                         if (muffled) 
[17:43:10.141]                           invokeRestart("muffleWarning")
[17:43:10.141]                       }
[17:43:10.141]                       else if (inherits(cond, "condition")) {
[17:43:10.141]                         if (!is.null(pattern)) {
[17:43:10.141]                           computeRestarts <- base::computeRestarts
[17:43:10.141]                           grepl <- base::grepl
[17:43:10.141]                           restarts <- computeRestarts(cond)
[17:43:10.141]                           for (restart in restarts) {
[17:43:10.141]                             name <- restart$name
[17:43:10.141]                             if (is.null(name)) 
[17:43:10.141]                               next
[17:43:10.141]                             if (!grepl(pattern, name)) 
[17:43:10.141]                               next
[17:43:10.141]                             invokeRestart(restart)
[17:43:10.141]                             muffled <- TRUE
[17:43:10.141]                             break
[17:43:10.141]                           }
[17:43:10.141]                         }
[17:43:10.141]                       }
[17:43:10.141]                       invisible(muffled)
[17:43:10.141]                     }
[17:43:10.141]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.141]                   }
[17:43:10.141]                 }
[17:43:10.141]             }
[17:43:10.141]         }))
[17:43:10.141]     }, error = function(ex) {
[17:43:10.141]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:10.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.141]                 ...future.rng), started = ...future.startTime, 
[17:43:10.141]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:10.141]             version = "1.8"), class = "FutureResult")
[17:43:10.141]     }, finally = {
[17:43:10.141]         if (!identical(...future.workdir, getwd())) 
[17:43:10.141]             setwd(...future.workdir)
[17:43:10.141]         {
[17:43:10.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:10.141]                 ...future.oldOptions$nwarnings <- NULL
[17:43:10.141]             }
[17:43:10.141]             base::options(...future.oldOptions)
[17:43:10.141]             if (.Platform$OS.type == "windows") {
[17:43:10.141]                 old_names <- names(...future.oldEnvVars)
[17:43:10.141]                 envs <- base::Sys.getenv()
[17:43:10.141]                 names <- names(envs)
[17:43:10.141]                 common <- intersect(names, old_names)
[17:43:10.141]                 added <- setdiff(names, old_names)
[17:43:10.141]                 removed <- setdiff(old_names, names)
[17:43:10.141]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:10.141]                   envs[common]]
[17:43:10.141]                 NAMES <- toupper(changed)
[17:43:10.141]                 args <- list()
[17:43:10.141]                 for (kk in seq_along(NAMES)) {
[17:43:10.141]                   name <- changed[[kk]]
[17:43:10.141]                   NAME <- NAMES[[kk]]
[17:43:10.141]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.141]                     next
[17:43:10.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.141]                 }
[17:43:10.141]                 NAMES <- toupper(added)
[17:43:10.141]                 for (kk in seq_along(NAMES)) {
[17:43:10.141]                   name <- added[[kk]]
[17:43:10.141]                   NAME <- NAMES[[kk]]
[17:43:10.141]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.141]                     next
[17:43:10.141]                   args[[name]] <- ""
[17:43:10.141]                 }
[17:43:10.141]                 NAMES <- toupper(removed)
[17:43:10.141]                 for (kk in seq_along(NAMES)) {
[17:43:10.141]                   name <- removed[[kk]]
[17:43:10.141]                   NAME <- NAMES[[kk]]
[17:43:10.141]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.141]                     next
[17:43:10.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.141]                 }
[17:43:10.141]                 if (length(args) > 0) 
[17:43:10.141]                   base::do.call(base::Sys.setenv, args = args)
[17:43:10.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:10.141]             }
[17:43:10.141]             else {
[17:43:10.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:10.141]             }
[17:43:10.141]             {
[17:43:10.141]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:10.141]                   0L) {
[17:43:10.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:10.141]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:10.141]                   base::options(opts)
[17:43:10.141]                 }
[17:43:10.141]                 {
[17:43:10.141]                   {
[17:43:10.141]                     NULL
[17:43:10.141]                     RNGkind("Mersenne-Twister")
[17:43:10.141]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:10.141]                       inherits = FALSE)
[17:43:10.141]                   }
[17:43:10.141]                   options(future.plan = NULL)
[17:43:10.141]                   if (is.na(NA_character_)) 
[17:43:10.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:10.141]                   future::plan(list(a = function (..., envir = parent.frame()) 
[17:43:10.141]                   {
[17:43:10.141]                     future <- SequentialFuture(..., envir = envir)
[17:43:10.141]                     if (!future$lazy) 
[17:43:10.141]                       future <- run(future)
[17:43:10.141]                     invisible(future)
[17:43:10.141]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:10.141]                     envir = parent.frame()) 
[17:43:10.141]                   {
[17:43:10.141]                     default_workers <- missing(workers)
[17:43:10.141]                     if (is.function(workers)) 
[17:43:10.141]                       workers <- workers()
[17:43:10.141]                     workers <- structure(as.integer(workers), 
[17:43:10.141]                       class = class(workers))
[17:43:10.141]                     stop_if_not(is.finite(workers), workers >= 
[17:43:10.141]                       1L)
[17:43:10.141]                     if ((workers == 1L && !inherits(workers, 
[17:43:10.141]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:10.141]                       if (default_workers) 
[17:43:10.141]                         supportsMulticore(warn = TRUE)
[17:43:10.141]                       return(sequential(..., envir = envir))
[17:43:10.141]                     }
[17:43:10.141]                     oopts <- options(mc.cores = workers)
[17:43:10.141]                     on.exit(options(oopts))
[17:43:10.141]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:10.141]                       envir = envir)
[17:43:10.141]                     if (!future$lazy) 
[17:43:10.141]                       future <- run(future)
[17:43:10.141]                     invisible(future)
[17:43:10.141]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.141]                 }
[17:43:10.141]             }
[17:43:10.141]         }
[17:43:10.141]     })
[17:43:10.141]     if (TRUE) {
[17:43:10.141]         base::sink(type = "output", split = FALSE)
[17:43:10.141]         if (TRUE) {
[17:43:10.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:10.141]         }
[17:43:10.141]         else {
[17:43:10.141]             ...future.result["stdout"] <- base::list(NULL)
[17:43:10.141]         }
[17:43:10.141]         base::close(...future.stdout)
[17:43:10.141]         ...future.stdout <- NULL
[17:43:10.141]     }
[17:43:10.141]     ...future.result$conditions <- ...future.conditions
[17:43:10.141]     ...future.result$finished <- base::Sys.time()
[17:43:10.141]     ...future.result
[17:43:10.141] }
[17:43:10.143] assign_globals() ...
[17:43:10.143] List of 2
[17:43:10.143]  $ nested   :List of 2
[17:43:10.143]   ..$ a:function (..., envir = parent.frame())  
[17:43:10.143]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:43:10.143]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:10.143]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:43:10.143]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:43:10.143]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:10.143]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:10.143]  $ strategy2: chr "multicore"
[17:43:10.143]  - attr(*, "where")=List of 2
[17:43:10.143]   ..$ nested   :<environment: R_EmptyEnv> 
[17:43:10.143]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:43:10.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:10.143]  - attr(*, "resolved")= logi FALSE
[17:43:10.143]  - attr(*, "total_size")= num 59224
[17:43:10.143]  - attr(*, "already-done")= logi TRUE
[17:43:10.150] - copied ‘nested’ to environment
[17:43:10.150] - copied ‘strategy2’ to environment
[17:43:10.150] assign_globals() ... done
[17:43:10.151] plan(): Setting new future strategy stack:
[17:43:10.151] List of future strategies:
[17:43:10.151] 1. multicore:
[17:43:10.151]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:10.151]    - tweaked: FALSE
[17:43:10.151]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.155] plan(): nbrOfWorkers() = 2
[17:43:10.218] plan(): Setting new future strategy stack:
[17:43:10.219] List of future strategies:
[17:43:10.219] 1. sequential:
[17:43:10.219]    - args: function (..., envir = parent.frame())
[17:43:10.219]    - tweaked: FALSE
[17:43:10.219]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.219] 2. multicore:
[17:43:10.219]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:10.219]    - tweaked: FALSE
[17:43:10.219]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.219] plan(): nbrOfWorkers() = 1
[17:43:10.220] SequentialFuture started (and completed)
[17:43:10.220] signalConditions() ...
[17:43:10.220]  - include = ‘immediateCondition’
[17:43:10.220]  - exclude = 
[17:43:10.220]  - resignal = FALSE
[17:43:10.220]  - Number of conditions: 51
[17:43:10.220] signalConditions() ... done
[17:43:10.221] - Launch lazy future ... done
[17:43:10.221] run() for ‘SequentialFuture’ ... done
[17:43:10.221] signalConditions() ...
[17:43:10.221]  - include = ‘immediateCondition’
[17:43:10.221]  - exclude = 
[17:43:10.221]  - resignal = FALSE
[17:43:10.221]  - Number of conditions: 51
[17:43:10.222] signalConditions() ... done
[17:43:10.222] Future state: ‘finished’
[17:43:10.222] signalConditions() ...
[17:43:10.222]  - include = ‘condition’
[17:43:10.222]  - exclude = ‘immediateCondition’
[17:43:10.222]  - resignal = TRUE
[17:43:10.222]  - Number of conditions: 51
[17:43:10.222]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.156] getGlobalsAndPackages() ...
[17:43:10.223]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.156] Searching for globals...
[17:43:10.223]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.176] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:43:10.223]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.177] Searching for globals ... DONE
[17:43:10.223]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.177] Resolving globals: FALSE
[17:43:10.223]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.177] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[17:43:10.223]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.178] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:43:10.224]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.178] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:43:10.224]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.178] 
[17:43:10.224]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.178] getGlobalsAndPackages() ... DONE
[17:43:10.224]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.179] run() for ‘Future’ ...
[17:43:10.224]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.179] - state: ‘created’
[17:43:10.225]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.179] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:10.225]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.183] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:10.225]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:10.225]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.183]   - Field: ‘label’
[17:43:10.225]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.183]   - Field: ‘local’
[17:43:10.225]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.183]   - Field: ‘owner’
[17:43:10.225]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.184]   - Field: ‘envir’
[17:43:10.226]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.184]   - Field: ‘workers’
[17:43:10.226]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.184]   - Field: ‘packages’
[17:43:10.226]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.184]   - Field: ‘gc’
[17:43:10.226]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.184]   - Field: ‘job’
[17:43:10.226]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.184]   - Field: ‘conditions’
[17:43:10.226]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.184]   - Field: ‘expr’
[17:43:10.227]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.184]   - Field: ‘uuid’
[17:43:10.227]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.184]   - Field: ‘seed’
[17:43:10.227]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.185]   - Field: ‘version’
[17:43:10.227]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.185]   - Field: ‘result’
[17:43:10.227]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.185]   - Field: ‘asynchronous’
[17:43:10.228]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.185]   - Field: ‘calls’
[17:43:10.228]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.185]   - Field: ‘globals’
[17:43:10.228]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.185]   - Field: ‘stdout’
[17:43:10.228]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.185]   - Field: ‘earlySignal’
[17:43:10.228]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.185]   - Field: ‘lazy’
[17:43:10.228]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.185]   - Field: ‘state’
[17:43:10.229]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.185] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:10.229]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.186] - Launch lazy future ...
[17:43:10.229]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.187] Packages needed by the future expression (n = 0): <none>
[17:43:10.229]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.187] Packages needed by future strategies (n = 0): <none>
[17:43:10.229]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.187] {
[17:43:10.187]     {
[17:43:10.187]         {
[17:43:10.187]             ...future.startTime <- base::Sys.time()
[17:43:10.187]             {
[17:43:10.187]                 {
[17:43:10.187]                   {
[17:43:10.187]                     {
[17:43:10.187]                       base::local({
[17:43:10.187]                         has_future <- base::requireNamespace("future", 
[17:43:10.187]                           quietly = TRUE)
[17:43:10.187]                         if (has_future) {
[17:43:10.187]                           ns <- base::getNamespace("future")
[17:43:10.187]                           version <- ns[[".package"]][["version"]]
[17:43:10.187]                           if (is.null(version)) 
[17:43:10.187]                             version <- utils::packageVersion("future")
[17:43:10.187]                         }
[17:43:10.187]                         else {
[17:43:10.187]                           version <- NULL
[17:43:10.187]                         }
[17:43:10.187]                         if (!has_future || version < "1.8.0") {
[17:43:10.187]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:10.187]                             "", base::R.version$version.string), 
[17:43:10.187]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:10.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:10.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:10.187]                               "release", "version")], collapse = " "), 
[17:43:10.187]                             hostname = base::Sys.info()[["nodename"]])
[17:43:10.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:10.187]                             info)
[17:43:10.187]                           info <- base::paste(info, collapse = "; ")
[17:43:10.187]                           if (!has_future) {
[17:43:10.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:10.187]                               info)
[17:43:10.187]                           }
[17:43:10.187]                           else {
[17:43:10.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:10.187]                               info, version)
[17:43:10.187]                           }
[17:43:10.187]                           base::stop(msg)
[17:43:10.187]                         }
[17:43:10.187]                       })
[17:43:10.187]                     }
[17:43:10.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:10.187]                     base::options(mc.cores = 1L)
[17:43:10.187]                   }
[17:43:10.187]                   options(future.plan = NULL)
[17:43:10.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:10.187]                 }
[17:43:10.187]                 ...future.workdir <- getwd()
[17:43:10.187]             }
[17:43:10.187]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:10.187]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:10.187]         }
[17:43:10.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:10.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:10.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:10.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:10.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:10.187]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:10.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:10.187]             base::names(...future.oldOptions))
[17:43:10.187]     }
[17:43:10.187]     if (FALSE) {
[17:43:10.187]     }
[17:43:10.187]     else {
[17:43:10.187]         if (TRUE) {
[17:43:10.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:10.187]                 open = "w")
[17:43:10.187]         }
[17:43:10.187]         else {
[17:43:10.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:10.187]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:10.187]         }
[17:43:10.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:10.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:10.187]             base::sink(type = "output", split = FALSE)
[17:43:10.187]             base::close(...future.stdout)
[17:43:10.187]         }, add = TRUE)
[17:43:10.187]     }
[17:43:10.187]     ...future.frame <- base::sys.nframe()
[17:43:10.187]     ...future.conditions <- base::list()
[17:43:10.187]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:10.187]     if (FALSE) {
[17:43:10.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:10.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:10.187]     }
[17:43:10.187]     ...future.result <- base::tryCatch({
[17:43:10.187]         base::withCallingHandlers({
[17:43:10.187]             ...future.value <- base::withVisible(base::local({
[17:43:10.187]                 withCallingHandlers({
[17:43:10.187]                   {
[17:43:10.187]                     b <- 2L
[17:43:10.187]                     plan_b <- future::plan("list")
[17:43:10.187]                     nested_b <- nested_a[-1]
[17:43:10.187]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:10.187]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:43:10.187]                       "sequential"))
[17:43:10.187]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:10.187]                       b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:10.187]                   }
[17:43:10.187]                 }, immediateCondition = function(cond) {
[17:43:10.187]                   save_rds <- function (object, pathname, ...) 
[17:43:10.187]                   {
[17:43:10.187]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:10.187]                     if (file_test("-f", pathname_tmp)) {
[17:43:10.187]                       fi_tmp <- file.info(pathname_tmp)
[17:43:10.187]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:10.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:10.187]                         fi_tmp[["mtime"]])
[17:43:10.187]                     }
[17:43:10.187]                     tryCatch({
[17:43:10.187]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:10.187]                     }, error = function(ex) {
[17:43:10.187]                       msg <- conditionMessage(ex)
[17:43:10.187]                       fi_tmp <- file.info(pathname_tmp)
[17:43:10.187]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:10.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:10.187]                         fi_tmp[["mtime"]], msg)
[17:43:10.187]                       ex$message <- msg
[17:43:10.187]                       stop(ex)
[17:43:10.187]                     })
[17:43:10.187]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:10.187]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:10.187]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:10.187]                       fi_tmp <- file.info(pathname_tmp)
[17:43:10.187]                       fi <- file.info(pathname)
[17:43:10.187]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:10.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:10.187]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:10.187]                         fi[["size"]], fi[["mtime"]])
[17:43:10.187]                       stop(msg)
[17:43:10.187]                     }
[17:43:10.187]                     invisible(pathname)
[17:43:10.187]                   }
[17:43:10.187]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:10.187]                     rootPath = tempdir()) 
[17:43:10.187]                   {
[17:43:10.187]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:10.187]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:10.187]                       tmpdir = path, fileext = ".rds")
[17:43:10.187]                     save_rds(obj, file)
[17:43:10.187]                   }
[17:43:10.187]                   saveImmediateCondition(cond, path = "/tmp/RtmpzPUCYD/.future/immediateConditions")
[17:43:10.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.187]                   {
[17:43:10.187]                     inherits <- base::inherits
[17:43:10.187]                     invokeRestart <- base::invokeRestart
[17:43:10.187]                     is.null <- base::is.null
[17:43:10.187]                     muffled <- FALSE
[17:43:10.187]                     if (inherits(cond, "message")) {
[17:43:10.187]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:10.187]                       if (muffled) 
[17:43:10.187]                         invokeRestart("muffleMessage")
[17:43:10.187]                     }
[17:43:10.187]                     else if (inherits(cond, "warning")) {
[17:43:10.187]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:10.187]                       if (muffled) 
[17:43:10.187]                         invokeRestart("muffleWarning")
[17:43:10.187]                     }
[17:43:10.187]                     else if (inherits(cond, "condition")) {
[17:43:10.187]                       if (!is.null(pattern)) {
[17:43:10.187]                         computeRestarts <- base::computeRestarts
[17:43:10.187]                         grepl <- base::grepl
[17:43:10.187]                         restarts <- computeRestarts(cond)
[17:43:10.187]                         for (restart in restarts) {
[17:43:10.187]                           name <- restart$name
[17:43:10.187]                           if (is.null(name)) 
[17:43:10.187]                             next
[17:43:10.187]                           if (!grepl(pattern, name)) 
[17:43:10.187]                             next
[17:43:10.187]                           invokeRestart(restart)
[17:43:10.187]                           muffled <- TRUE
[17:43:10.187]                           break
[17:43:10.187]                         }
[17:43:10.187]                       }
[17:43:10.187]                     }
[17:43:10.187]                     invisible(muffled)
[17:43:10.187]                   }
[17:43:10.187]                   muffleCondition(cond)
[17:43:10.187]                 })
[17:43:10.187]             }))
[17:43:10.187]             future::FutureResult(value = ...future.value$value, 
[17:43:10.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.187]                   ...future.rng), globalenv = if (FALSE) 
[17:43:10.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:10.187]                     ...future.globalenv.names))
[17:43:10.187]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:10.187]         }, condition = base::local({
[17:43:10.187]             c <- base::c
[17:43:10.187]             inherits <- base::inherits
[17:43:10.187]             invokeRestart <- base::invokeRestart
[17:43:10.187]             length <- base::length
[17:43:10.187]             list <- base::list
[17:43:10.187]             seq.int <- base::seq.int
[17:43:10.187]             signalCondition <- base::signalCondition
[17:43:10.187]             sys.calls <- base::sys.calls
[17:43:10.187]             `[[` <- base::`[[`
[17:43:10.187]             `+` <- base::`+`
[17:43:10.187]             `<<-` <- base::`<<-`
[17:43:10.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:10.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:10.187]                   3L)]
[17:43:10.187]             }
[17:43:10.187]             function(cond) {
[17:43:10.187]                 is_error <- inherits(cond, "error")
[17:43:10.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:10.187]                   NULL)
[17:43:10.187]                 if (is_error) {
[17:43:10.187]                   sessionInformation <- function() {
[17:43:10.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:10.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:10.187]                       search = base::search(), system = base::Sys.info())
[17:43:10.187]                   }
[17:43:10.187]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:10.187]                     cond$call), session = sessionInformation(), 
[17:43:10.187]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:10.187]                   signalCondition(cond)
[17:43:10.187]                 }
[17:43:10.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:10.187]                 "immediateCondition"))) {
[17:43:10.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:10.187]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:10.187]                   if (TRUE && !signal) {
[17:43:10.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.187]                     {
[17:43:10.187]                       inherits <- base::inherits
[17:43:10.187]                       invokeRestart <- base::invokeRestart
[17:43:10.187]                       is.null <- base::is.null
[17:43:10.187]                       muffled <- FALSE
[17:43:10.187]                       if (inherits(cond, "message")) {
[17:43:10.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.187]                         if (muffled) 
[17:43:10.187]                           invokeRestart("muffleMessage")
[17:43:10.187]                       }
[17:43:10.187]                       else if (inherits(cond, "warning")) {
[17:43:10.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.187]                         if (muffled) 
[17:43:10.187]                           invokeRestart("muffleWarning")
[17:43:10.187]                       }
[17:43:10.187]                       else if (inherits(cond, "condition")) {
[17:43:10.187]                         if (!is.null(pattern)) {
[17:43:10.187]                           computeRestarts <- base::computeRestarts
[17:43:10.187]                           grepl <- base::grepl
[17:43:10.187]                           restarts <- computeRestarts(cond)
[17:43:10.187]                           for (restart in restarts) {
[17:43:10.187]                             name <- restart$name
[17:43:10.187]                             if (is.null(name)) 
[17:43:10.187]                               next
[17:43:10.187]                             if (!grepl(pattern, name)) 
[17:43:10.187]                               next
[17:43:10.187]                             invokeRestart(restart)
[17:43:10.187]                             muffled <- TRUE
[17:43:10.187]                             break
[17:43:10.187]                           }
[17:43:10.187]                         }
[17:43:10.187]                       }
[17:43:10.187]                       invisible(muffled)
[17:43:10.187]                     }
[17:43:10.187]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.187]                   }
[17:43:10.187]                 }
[17:43:10.187]                 else {
[17:43:10.187]                   if (TRUE) {
[17:43:10.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.187]                     {
[17:43:10.187]                       inherits <- base::inherits
[17:43:10.187]                       invokeRestart <- base::invokeRestart
[17:43:10.187]                       is.null <- base::is.null
[17:43:10.187]                       muffled <- FALSE
[17:43:10.187]                       if (inherits(cond, "message")) {
[17:43:10.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.187]                         if (muffled) 
[17:43:10.187]                           invokeRestart("muffleMessage")
[17:43:10.187]                       }
[17:43:10.187]                       else if (inherits(cond, "warning")) {
[17:43:10.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.187]                         if (muffled) 
[17:43:10.187]                           invokeRestart("muffleWarning")
[17:43:10.187]                       }
[17:43:10.187]                       else if (inherits(cond, "condition")) {
[17:43:10.187]                         if (!is.null(pattern)) {
[17:43:10.187]                           computeRestarts <- base::computeRestarts
[17:43:10.187]                           grepl <- base::grepl
[17:43:10.187]                           restarts <- computeRestarts(cond)
[17:43:10.187]                           for (restart in restarts) {
[17:43:10.187]                             name <- restart$name
[17:43:10.187]                             if (is.null(name)) 
[17:43:10.187]                               next
[17:43:10.187]                             if (!grepl(pattern, name)) 
[17:43:10.187]                               next
[17:43:10.187]                             invokeRestart(restart)
[17:43:10.187]                             muffled <- TRUE
[17:43:10.187]                             break
[17:43:10.187]                           }
[17:43:10.187]                         }
[17:43:10.187]                       }
[17:43:10.187]                       invisible(muffled)
[17:43:10.187]                     }
[17:43:10.187]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.187]                   }
[17:43:10.187]                 }
[17:43:10.187]             }
[17:43:10.187]         }))
[17:43:10.187]     }, error = function(ex) {
[17:43:10.187]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:10.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.187]                 ...future.rng), started = ...future.startTime, 
[17:43:10.187]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:10.187]             version = "1.8"), class = "FutureResult")
[17:43:10.187]     }, finally = {
[17:43:10.187]         if (!identical(...future.workdir, getwd())) 
[17:43:10.187]             setwd(...future.workdir)
[17:43:10.187]         {
[17:43:10.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:10.187]                 ...future.oldOptions$nwarnings <- NULL
[17:43:10.187]             }
[17:43:10.187]             base::options(...future.oldOptions)
[17:43:10.187]             if (.Platform$OS.type == "windows") {
[17:43:10.187]                 old_names <- names(...future.oldEnvVars)
[17:43:10.187]                 envs <- base::Sys.getenv()
[17:43:10.187]                 names <- names(envs)
[17:43:10.187]                 common <- intersect(names, old_names)
[17:43:10.187]                 added <- setdiff(names, old_names)
[17:43:10.187]                 removed <- setdiff(old_names, names)
[17:43:10.187]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:10.187]                   envs[common]]
[17:43:10.187]                 NAMES <- toupper(changed)
[17:43:10.187]                 args <- list()
[17:43:10.187]                 for (kk in seq_along(NAMES)) {
[17:43:10.187]                   name <- changed[[kk]]
[17:43:10.187]                   NAME <- NAMES[[kk]]
[17:43:10.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.187]                     next
[17:43:10.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.187]                 }
[17:43:10.187]                 NAMES <- toupper(added)
[17:43:10.187]                 for (kk in seq_along(NAMES)) {
[17:43:10.187]                   name <- added[[kk]]
[17:43:10.187]                   NAME <- NAMES[[kk]]
[17:43:10.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.187]                     next
[17:43:10.187]                   args[[name]] <- ""
[17:43:10.187]                 }
[17:43:10.187]                 NAMES <- toupper(removed)
[17:43:10.187]                 for (kk in seq_along(NAMES)) {
[17:43:10.187]                   name <- removed[[kk]]
[17:43:10.187]                   NAME <- NAMES[[kk]]
[17:43:10.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.187]                     next
[17:43:10.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.187]                 }
[17:43:10.187]                 if (length(args) > 0) 
[17:43:10.187]                   base::do.call(base::Sys.setenv, args = args)
[17:43:10.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:10.187]             }
[17:43:10.187]             else {
[17:43:10.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:10.187]             }
[17:43:10.187]             {
[17:43:10.187]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:10.187]                   0L) {
[17:43:10.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:10.187]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:10.187]                   base::options(opts)
[17:43:10.187]                 }
[17:43:10.187]                 {
[17:43:10.187]                   {
[17:43:10.187]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:10.187]                     NULL
[17:43:10.187]                   }
[17:43:10.187]                   options(future.plan = NULL)
[17:43:10.187]                   if (is.na(NA_character_)) 
[17:43:10.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:10.187]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:10.187]                     envir = parent.frame()) 
[17:43:10.187]                   {
[17:43:10.187]                     default_workers <- missing(workers)
[17:43:10.187]                     if (is.function(workers)) 
[17:43:10.187]                       workers <- workers()
[17:43:10.187]                     workers <- structure(as.integer(workers), 
[17:43:10.187]                       class = class(workers))
[17:43:10.187]                     stop_if_not(is.finite(workers), workers >= 
[17:43:10.187]                       1L)
[17:43:10.187]                     if ((workers == 1L && !inherits(workers, 
[17:43:10.187]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:10.187]                       if (default_workers) 
[17:43:10.187]                         supportsMulticore(warn = TRUE)
[17:43:10.187]                       return(sequential(..., envir = envir))
[17:43:10.187]                     }
[17:43:10.187]                     oopts <- options(mc.cores = workers)
[17:43:10.187]                     on.exit(options(oopts))
[17:43:10.187]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:10.187]                       envir = envir)
[17:43:10.187]                     if (!future$lazy) 
[17:43:10.187]                       future <- run(future)
[17:43:10.187]                     invisible(future)
[17:43:10.187]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.187]                 }
[17:43:10.187]             }
[17:43:10.187]         }
[17:43:10.187]     })
[17:43:10.187]     if (TRUE) {
[17:43:10.187]         base::sink(type = "output", split = FALSE)
[17:43:10.187]         if (TRUE) {
[17:43:10.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:10.187]         }
[17:43:10.187]         else {
[17:43:10.187]             ...future.result["stdout"] <- base::list(NULL)
[17:43:10.187]         }
[17:43:10.187]         base::close(...future.stdout)
[17:43:10.187]         ...future.stdout <- NULL
[17:43:10.187]     }
[17:43:10.187]     ...future.result$conditions <- ...future.conditions
[17:43:10.187]     ...future.result$finished <- base::Sys.time()
[17:43:10.187]     ...future.result
[17:43:10.187] }
[17:43:10.229]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.190] assign_globals() ...
[17:43:10.230]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.190] List of 3
[17:43:10.190]  $ nested_a:List of 1
[17:43:10.190]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:43:10.190]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:43:10.190]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:10.190]  $ a       : int 1
[17:43:10.190]  $ plan_a  :List of 1
[17:43:10.190]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:43:10.190]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:43:10.190]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:10.190]  - attr(*, "where")=List of 3
[17:43:10.190]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:43:10.190]   ..$ a       :<environment: R_EmptyEnv> 
[17:43:10.190]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:43:10.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:10.190]  - attr(*, "resolved")= logi FALSE
[17:43:10.190]  - attr(*, "total_size")= num 95240
[17:43:10.190]  - attr(*, "already-done")= logi TRUE
[17:43:10.230]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.197] - copied ‘nested_a’ to environment
[17:43:10.230]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.197] - copied ‘a’ to environment
[17:43:10.230]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.197] - copied ‘plan_a’ to environment
[17:43:10.230]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.198] assign_globals() ... done
[17:43:10.230]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.198] requestCore(): workers = 2
[17:43:10.231]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.201] MulticoreFuture started
[17:43:10.231]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.202] - Launch lazy future ... done
[17:43:10.231]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.202] run() for ‘MulticoreFuture’ ... done
[17:43:10.231] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:10.237] getGlobalsAndPackages() ...
[17:43:10.237] Searching for globals...
[17:43:10.241] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:10.241] Searching for globals ... DONE
[17:43:10.241] Resolving globals: FALSE
[17:43:10.242] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:10.242] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:10.242] - globals: [1] ‘data’
[17:43:10.243] - packages: [1] ‘future’
[17:43:10.243] getGlobalsAndPackages() ... DONE
[17:43:10.243] run() for ‘Future’ ...
[17:43:10.243] - state: ‘created’
[17:43:10.243] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:10.244] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:10.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:10.244]   - Field: ‘label’
[17:43:10.244]   - Field: ‘local’
[17:43:10.244]   - Field: ‘owner’
[17:43:10.244]   - Field: ‘envir’
[17:43:10.244]   - Field: ‘packages’
[17:43:10.244]   - Field: ‘gc’
[17:43:10.244]   - Field: ‘conditions’
[17:43:10.245]   - Field: ‘expr’
[17:43:10.245]   - Field: ‘uuid’
[17:43:10.245]   - Field: ‘seed’
[17:43:10.245]   - Field: ‘version’
[17:43:10.245]   - Field: ‘result’
[17:43:10.245]   - Field: ‘asynchronous’
[17:43:10.245]   - Field: ‘calls’
[17:43:10.245]   - Field: ‘globals’
[17:43:10.245]   - Field: ‘stdout’
[17:43:10.245]   - Field: ‘earlySignal’
[17:43:10.245]   - Field: ‘lazy’
[17:43:10.246]   - Field: ‘state’
[17:43:10.246] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:10.246] - Launch lazy future ...
[17:43:10.246] Packages needed by the future expression (n = 1): ‘future’
[17:43:10.246] Packages needed by future strategies (n = 1): ‘future’
[17:43:10.247] {
[17:43:10.247]     {
[17:43:10.247]         {
[17:43:10.247]             ...future.startTime <- base::Sys.time()
[17:43:10.247]             {
[17:43:10.247]                 {
[17:43:10.247]                   {
[17:43:10.247]                     {
[17:43:10.247]                       base::local({
[17:43:10.247]                         has_future <- base::requireNamespace("future", 
[17:43:10.247]                           quietly = TRUE)
[17:43:10.247]                         if (has_future) {
[17:43:10.247]                           ns <- base::getNamespace("future")
[17:43:10.247]                           version <- ns[[".package"]][["version"]]
[17:43:10.247]                           if (is.null(version)) 
[17:43:10.247]                             version <- utils::packageVersion("future")
[17:43:10.247]                         }
[17:43:10.247]                         else {
[17:43:10.247]                           version <- NULL
[17:43:10.247]                         }
[17:43:10.247]                         if (!has_future || version < "1.8.0") {
[17:43:10.247]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:10.247]                             "", base::R.version$version.string), 
[17:43:10.247]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:10.247]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:10.247]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:10.247]                               "release", "version")], collapse = " "), 
[17:43:10.247]                             hostname = base::Sys.info()[["nodename"]])
[17:43:10.247]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:10.247]                             info)
[17:43:10.247]                           info <- base::paste(info, collapse = "; ")
[17:43:10.247]                           if (!has_future) {
[17:43:10.247]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:10.247]                               info)
[17:43:10.247]                           }
[17:43:10.247]                           else {
[17:43:10.247]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:10.247]                               info, version)
[17:43:10.247]                           }
[17:43:10.247]                           base::stop(msg)
[17:43:10.247]                         }
[17:43:10.247]                       })
[17:43:10.247]                     }
[17:43:10.247]                     base::local({
[17:43:10.247]                       for (pkg in "future") {
[17:43:10.247]                         base::loadNamespace(pkg)
[17:43:10.247]                         base::library(pkg, character.only = TRUE)
[17:43:10.247]                       }
[17:43:10.247]                     })
[17:43:10.247]                   }
[17:43:10.247]                   options(future.plan = NULL)
[17:43:10.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.247]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:10.247]                     envir = parent.frame()) 
[17:43:10.247]                   {
[17:43:10.247]                     default_workers <- missing(workers)
[17:43:10.247]                     if (is.function(workers)) 
[17:43:10.247]                       workers <- workers()
[17:43:10.247]                     workers <- structure(as.integer(workers), 
[17:43:10.247]                       class = class(workers))
[17:43:10.247]                     stop_if_not(is.finite(workers), workers >= 
[17:43:10.247]                       1L)
[17:43:10.247]                     if ((workers == 1L && !inherits(workers, 
[17:43:10.247]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:10.247]                       if (default_workers) 
[17:43:10.247]                         supportsMulticore(warn = TRUE)
[17:43:10.247]                       return(sequential(..., envir = envir))
[17:43:10.247]                     }
[17:43:10.247]                     oopts <- options(mc.cores = workers)
[17:43:10.247]                     on.exit(options(oopts))
[17:43:10.247]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:10.247]                       envir = envir)
[17:43:10.247]                     if (!future$lazy) 
[17:43:10.247]                       future <- run(future)
[17:43:10.247]                     invisible(future)
[17:43:10.247]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.247]                 }
[17:43:10.247]                 ...future.workdir <- getwd()
[17:43:10.247]             }
[17:43:10.247]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:10.247]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:10.247]         }
[17:43:10.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:10.247]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:10.247]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:10.247]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:10.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:10.247]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:10.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:10.247]             base::names(...future.oldOptions))
[17:43:10.247]     }
[17:43:10.247]     if (FALSE) {
[17:43:10.247]     }
[17:43:10.247]     else {
[17:43:10.247]         if (TRUE) {
[17:43:10.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:10.247]                 open = "w")
[17:43:10.247]         }
[17:43:10.247]         else {
[17:43:10.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:10.247]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:10.247]         }
[17:43:10.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:10.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:10.247]             base::sink(type = "output", split = FALSE)
[17:43:10.247]             base::close(...future.stdout)
[17:43:10.247]         }, add = TRUE)
[17:43:10.247]     }
[17:43:10.247]     ...future.frame <- base::sys.nframe()
[17:43:10.247]     ...future.conditions <- base::list()
[17:43:10.247]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:10.247]     if (FALSE) {
[17:43:10.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:10.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:10.247]     }
[17:43:10.247]     ...future.result <- base::tryCatch({
[17:43:10.247]         base::withCallingHandlers({
[17:43:10.247]             ...future.value <- base::withVisible(base::local({
[17:43:10.247]                 value(future(subset(data, a == 2)))
[17:43:10.247]             }))
[17:43:10.247]             future::FutureResult(value = ...future.value$value, 
[17:43:10.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.247]                   ...future.rng), globalenv = if (FALSE) 
[17:43:10.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:10.247]                     ...future.globalenv.names))
[17:43:10.247]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:10.247]         }, condition = base::local({
[17:43:10.247]             c <- base::c
[17:43:10.247]             inherits <- base::inherits
[17:43:10.247]             invokeRestart <- base::invokeRestart
[17:43:10.247]             length <- base::length
[17:43:10.247]             list <- base::list
[17:43:10.247]             seq.int <- base::seq.int
[17:43:10.247]             signalCondition <- base::signalCondition
[17:43:10.247]             sys.calls <- base::sys.calls
[17:43:10.247]             `[[` <- base::`[[`
[17:43:10.247]             `+` <- base::`+`
[17:43:10.247]             `<<-` <- base::`<<-`
[17:43:10.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:10.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:10.247]                   3L)]
[17:43:10.247]             }
[17:43:10.247]             function(cond) {
[17:43:10.247]                 is_error <- inherits(cond, "error")
[17:43:10.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:10.247]                   NULL)
[17:43:10.247]                 if (is_error) {
[17:43:10.247]                   sessionInformation <- function() {
[17:43:10.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:10.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:10.247]                       search = base::search(), system = base::Sys.info())
[17:43:10.247]                   }
[17:43:10.247]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:10.247]                     cond$call), session = sessionInformation(), 
[17:43:10.247]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:10.247]                   signalCondition(cond)
[17:43:10.247]                 }
[17:43:10.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:10.247]                 "immediateCondition"))) {
[17:43:10.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:10.247]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:10.247]                   if (TRUE && !signal) {
[17:43:10.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.247]                     {
[17:43:10.247]                       inherits <- base::inherits
[17:43:10.247]                       invokeRestart <- base::invokeRestart
[17:43:10.247]                       is.null <- base::is.null
[17:43:10.247]                       muffled <- FALSE
[17:43:10.247]                       if (inherits(cond, "message")) {
[17:43:10.247]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.247]                         if (muffled) 
[17:43:10.247]                           invokeRestart("muffleMessage")
[17:43:10.247]                       }
[17:43:10.247]                       else if (inherits(cond, "warning")) {
[17:43:10.247]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.247]                         if (muffled) 
[17:43:10.247]                           invokeRestart("muffleWarning")
[17:43:10.247]                       }
[17:43:10.247]                       else if (inherits(cond, "condition")) {
[17:43:10.247]                         if (!is.null(pattern)) {
[17:43:10.247]                           computeRestarts <- base::computeRestarts
[17:43:10.247]                           grepl <- base::grepl
[17:43:10.247]                           restarts <- computeRestarts(cond)
[17:43:10.247]                           for (restart in restarts) {
[17:43:10.247]                             name <- restart$name
[17:43:10.247]                             if (is.null(name)) 
[17:43:10.247]                               next
[17:43:10.247]                             if (!grepl(pattern, name)) 
[17:43:10.247]                               next
[17:43:10.247]                             invokeRestart(restart)
[17:43:10.247]                             muffled <- TRUE
[17:43:10.247]                             break
[17:43:10.247]                           }
[17:43:10.247]                         }
[17:43:10.247]                       }
[17:43:10.247]                       invisible(muffled)
[17:43:10.247]                     }
[17:43:10.247]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.247]                   }
[17:43:10.247]                 }
[17:43:10.247]                 else {
[17:43:10.247]                   if (TRUE) {
[17:43:10.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.247]                     {
[17:43:10.247]                       inherits <- base::inherits
[17:43:10.247]                       invokeRestart <- base::invokeRestart
[17:43:10.247]                       is.null <- base::is.null
[17:43:10.247]                       muffled <- FALSE
[17:43:10.247]                       if (inherits(cond, "message")) {
[17:43:10.247]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.247]                         if (muffled) 
[17:43:10.247]                           invokeRestart("muffleMessage")
[17:43:10.247]                       }
[17:43:10.247]                       else if (inherits(cond, "warning")) {
[17:43:10.247]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.247]                         if (muffled) 
[17:43:10.247]                           invokeRestart("muffleWarning")
[17:43:10.247]                       }
[17:43:10.247]                       else if (inherits(cond, "condition")) {
[17:43:10.247]                         if (!is.null(pattern)) {
[17:43:10.247]                           computeRestarts <- base::computeRestarts
[17:43:10.247]                           grepl <- base::grepl
[17:43:10.247]                           restarts <- computeRestarts(cond)
[17:43:10.247]                           for (restart in restarts) {
[17:43:10.247]                             name <- restart$name
[17:43:10.247]                             if (is.null(name)) 
[17:43:10.247]                               next
[17:43:10.247]                             if (!grepl(pattern, name)) 
[17:43:10.247]                               next
[17:43:10.247]                             invokeRestart(restart)
[17:43:10.247]                             muffled <- TRUE
[17:43:10.247]                             break
[17:43:10.247]                           }
[17:43:10.247]                         }
[17:43:10.247]                       }
[17:43:10.247]                       invisible(muffled)
[17:43:10.247]                     }
[17:43:10.247]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.247]                   }
[17:43:10.247]                 }
[17:43:10.247]             }
[17:43:10.247]         }))
[17:43:10.247]     }, error = function(ex) {
[17:43:10.247]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:10.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.247]                 ...future.rng), started = ...future.startTime, 
[17:43:10.247]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:10.247]             version = "1.8"), class = "FutureResult")
[17:43:10.247]     }, finally = {
[17:43:10.247]         if (!identical(...future.workdir, getwd())) 
[17:43:10.247]             setwd(...future.workdir)
[17:43:10.247]         {
[17:43:10.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:10.247]                 ...future.oldOptions$nwarnings <- NULL
[17:43:10.247]             }
[17:43:10.247]             base::options(...future.oldOptions)
[17:43:10.247]             if (.Platform$OS.type == "windows") {
[17:43:10.247]                 old_names <- names(...future.oldEnvVars)
[17:43:10.247]                 envs <- base::Sys.getenv()
[17:43:10.247]                 names <- names(envs)
[17:43:10.247]                 common <- intersect(names, old_names)
[17:43:10.247]                 added <- setdiff(names, old_names)
[17:43:10.247]                 removed <- setdiff(old_names, names)
[17:43:10.247]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:10.247]                   envs[common]]
[17:43:10.247]                 NAMES <- toupper(changed)
[17:43:10.247]                 args <- list()
[17:43:10.247]                 for (kk in seq_along(NAMES)) {
[17:43:10.247]                   name <- changed[[kk]]
[17:43:10.247]                   NAME <- NAMES[[kk]]
[17:43:10.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.247]                     next
[17:43:10.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.247]                 }
[17:43:10.247]                 NAMES <- toupper(added)
[17:43:10.247]                 for (kk in seq_along(NAMES)) {
[17:43:10.247]                   name <- added[[kk]]
[17:43:10.247]                   NAME <- NAMES[[kk]]
[17:43:10.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.247]                     next
[17:43:10.247]                   args[[name]] <- ""
[17:43:10.247]                 }
[17:43:10.247]                 NAMES <- toupper(removed)
[17:43:10.247]                 for (kk in seq_along(NAMES)) {
[17:43:10.247]                   name <- removed[[kk]]
[17:43:10.247]                   NAME <- NAMES[[kk]]
[17:43:10.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.247]                     next
[17:43:10.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.247]                 }
[17:43:10.247]                 if (length(args) > 0) 
[17:43:10.247]                   base::do.call(base::Sys.setenv, args = args)
[17:43:10.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:10.247]             }
[17:43:10.247]             else {
[17:43:10.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:10.247]             }
[17:43:10.247]             {
[17:43:10.247]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:10.247]                   0L) {
[17:43:10.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:10.247]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:10.247]                   base::options(opts)
[17:43:10.247]                 }
[17:43:10.247]                 {
[17:43:10.247]                   {
[17:43:10.247]                     NULL
[17:43:10.247]                     RNGkind("Mersenne-Twister")
[17:43:10.247]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:10.247]                       inherits = FALSE)
[17:43:10.247]                   }
[17:43:10.247]                   options(future.plan = NULL)
[17:43:10.247]                   if (is.na(NA_character_)) 
[17:43:10.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:10.247]                   future::plan(list(a = function (..., envir = parent.frame()) 
[17:43:10.247]                   {
[17:43:10.247]                     future <- SequentialFuture(..., envir = envir)
[17:43:10.247]                     if (!future$lazy) 
[17:43:10.247]                       future <- run(future)
[17:43:10.247]                     invisible(future)
[17:43:10.247]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:10.247]                     envir = parent.frame()) 
[17:43:10.247]                   {
[17:43:10.247]                     default_workers <- missing(workers)
[17:43:10.247]                     if (is.function(workers)) 
[17:43:10.247]                       workers <- workers()
[17:43:10.247]                     workers <- structure(as.integer(workers), 
[17:43:10.247]                       class = class(workers))
[17:43:10.247]                     stop_if_not(is.finite(workers), workers >= 
[17:43:10.247]                       1L)
[17:43:10.247]                     if ((workers == 1L && !inherits(workers, 
[17:43:10.247]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:10.247]                       if (default_workers) 
[17:43:10.247]                         supportsMulticore(warn = TRUE)
[17:43:10.247]                       return(sequential(..., envir = envir))
[17:43:10.247]                     }
[17:43:10.247]                     oopts <- options(mc.cores = workers)
[17:43:10.247]                     on.exit(options(oopts))
[17:43:10.247]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:10.247]                       envir = envir)
[17:43:10.247]                     if (!future$lazy) 
[17:43:10.247]                       future <- run(future)
[17:43:10.247]                     invisible(future)
[17:43:10.247]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.247]                 }
[17:43:10.247]             }
[17:43:10.247]         }
[17:43:10.247]     })
[17:43:10.247]     if (TRUE) {
[17:43:10.247]         base::sink(type = "output", split = FALSE)
[17:43:10.247]         if (TRUE) {
[17:43:10.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:10.247]         }
[17:43:10.247]         else {
[17:43:10.247]             ...future.result["stdout"] <- base::list(NULL)
[17:43:10.247]         }
[17:43:10.247]         base::close(...future.stdout)
[17:43:10.247]         ...future.stdout <- NULL
[17:43:10.247]     }
[17:43:10.247]     ...future.result$conditions <- ...future.conditions
[17:43:10.247]     ...future.result$finished <- base::Sys.time()
[17:43:10.247]     ...future.result
[17:43:10.247] }
[17:43:10.249] assign_globals() ...
[17:43:10.249] List of 1
[17:43:10.249]  $ data:'data.frame':	3 obs. of  2 variables:
[17:43:10.249]   ..$ a: int [1:3] 1 2 3
[17:43:10.249]   ..$ b: int [1:3] 3 2 1
[17:43:10.249]  - attr(*, "where")=List of 1
[17:43:10.249]   ..$ data:<environment: R_EmptyEnv> 
[17:43:10.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:10.249]  - attr(*, "resolved")= logi FALSE
[17:43:10.249]  - attr(*, "total_size")= num 128
[17:43:10.249]  - attr(*, "already-done")= logi TRUE
[17:43:10.252] - copied ‘data’ to environment
[17:43:10.252] assign_globals() ... done
[17:43:10.252] plan(): Setting new future strategy stack:
[17:43:10.253] List of future strategies:
[17:43:10.253] 1. multicore:
[17:43:10.253]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:10.253]    - tweaked: FALSE
[17:43:10.253]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.257] plan(): nbrOfWorkers() = 2
[17:43:10.307] plan(): Setting new future strategy stack:
[17:43:10.307] List of future strategies:
[17:43:10.307] 1. sequential:
[17:43:10.307]    - args: function (..., envir = parent.frame())
[17:43:10.307]    - tweaked: FALSE
[17:43:10.307]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.307] 2. multicore:
[17:43:10.307]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:10.307]    - tweaked: FALSE
[17:43:10.307]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.308] plan(): nbrOfWorkers() = 1
[17:43:10.308] SequentialFuture started (and completed)
[17:43:10.309] signalConditions() ...
[17:43:10.309]  - include = ‘immediateCondition’
[17:43:10.309]  - exclude = 
[17:43:10.309]  - resignal = FALSE
[17:43:10.309]  - Number of conditions: 49
[17:43:10.309] signalConditions() ... done
[17:43:10.309] - Launch lazy future ... done
[17:43:10.310] run() for ‘SequentialFuture’ ... done
[17:43:10.310] signalConditions() ...
[17:43:10.310]  - include = ‘immediateCondition’
[17:43:10.310]  - exclude = 
[17:43:10.310]  - resignal = FALSE
[17:43:10.310]  - Number of conditions: 49
[17:43:10.310] signalConditions() ... done
[17:43:10.311] Future state: ‘finished’
[17:43:10.311] signalConditions() ...
[17:43:10.311]  - include = ‘condition’
[17:43:10.311]  - exclude = ‘immediateCondition’
[17:43:10.311]  - resignal = TRUE
[17:43:10.311]  - Number of conditions: 49
[17:43:10.311]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.257] getGlobalsAndPackages() ...
[17:43:10.312]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.257] Searching for globals...
[17:43:10.312]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.273] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:10.312]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.274] Searching for globals ... DONE
[17:43:10.312]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.274] Resolving globals: FALSE
[17:43:10.312]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.274] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:10.312]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.275] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:10.313]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.275] - globals: [1] ‘data’
[17:43:10.313]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.275] 
[17:43:10.313]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.275] getGlobalsAndPackages() ... DONE
[17:43:10.313]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.275] run() for ‘Future’ ...
[17:43:10.313]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.276] - state: ‘created’
[17:43:10.313]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.276] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:10.314]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.280] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:10.314]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:10.314]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.280]   - Field: ‘label’
[17:43:10.314]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.280]   - Field: ‘local’
[17:43:10.314]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.280]   - Field: ‘owner’
[17:43:10.314]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.280]   - Field: ‘envir’
[17:43:10.315]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.280]   - Field: ‘workers’
[17:43:10.315]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.280]   - Field: ‘packages’
[17:43:10.315]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.281]   - Field: ‘gc’
[17:43:10.315]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.281]   - Field: ‘job’
[17:43:10.315]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.281]   - Field: ‘conditions’
[17:43:10.316]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.281]   - Field: ‘expr’
[17:43:10.316]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.281]   - Field: ‘uuid’
[17:43:10.316]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.281]   - Field: ‘seed’
[17:43:10.316]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.281]   - Field: ‘version’
[17:43:10.317]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.281]   - Field: ‘result’
[17:43:10.317]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.281]   - Field: ‘asynchronous’
[17:43:10.317]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.282]   - Field: ‘calls’
[17:43:10.317]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.282]   - Field: ‘globals’
[17:43:10.317]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.282]   - Field: ‘stdout’
[17:43:10.317]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.282]   - Field: ‘earlySignal’
[17:43:10.318]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.282]   - Field: ‘lazy’
[17:43:10.318]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.282]   - Field: ‘state’
[17:43:10.318]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.282] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:10.318]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.282] - Launch lazy future ...
[17:43:10.318]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.283] Packages needed by the future expression (n = 0): <none>
[17:43:10.318]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.283] Packages needed by future strategies (n = 0): <none>
[17:43:10.318]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.283] {
[17:43:10.283]     {
[17:43:10.283]         {
[17:43:10.283]             ...future.startTime <- base::Sys.time()
[17:43:10.283]             {
[17:43:10.283]                 {
[17:43:10.283]                   {
[17:43:10.283]                     {
[17:43:10.283]                       base::local({
[17:43:10.283]                         has_future <- base::requireNamespace("future", 
[17:43:10.283]                           quietly = TRUE)
[17:43:10.283]                         if (has_future) {
[17:43:10.283]                           ns <- base::getNamespace("future")
[17:43:10.283]                           version <- ns[[".package"]][["version"]]
[17:43:10.283]                           if (is.null(version)) 
[17:43:10.283]                             version <- utils::packageVersion("future")
[17:43:10.283]                         }
[17:43:10.283]                         else {
[17:43:10.283]                           version <- NULL
[17:43:10.283]                         }
[17:43:10.283]                         if (!has_future || version < "1.8.0") {
[17:43:10.283]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:10.283]                             "", base::R.version$version.string), 
[17:43:10.283]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:10.283]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:10.283]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:10.283]                               "release", "version")], collapse = " "), 
[17:43:10.283]                             hostname = base::Sys.info()[["nodename"]])
[17:43:10.283]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:10.283]                             info)
[17:43:10.283]                           info <- base::paste(info, collapse = "; ")
[17:43:10.283]                           if (!has_future) {
[17:43:10.283]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:10.283]                               info)
[17:43:10.283]                           }
[17:43:10.283]                           else {
[17:43:10.283]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:10.283]                               info, version)
[17:43:10.283]                           }
[17:43:10.283]                           base::stop(msg)
[17:43:10.283]                         }
[17:43:10.283]                       })
[17:43:10.283]                     }
[17:43:10.283]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:10.283]                     base::options(mc.cores = 1L)
[17:43:10.283]                   }
[17:43:10.283]                   options(future.plan = NULL)
[17:43:10.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:10.283]                 }
[17:43:10.283]                 ...future.workdir <- getwd()
[17:43:10.283]             }
[17:43:10.283]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:10.283]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:10.283]         }
[17:43:10.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:10.283]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:10.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:10.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:10.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:10.283]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:10.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:10.283]             base::names(...future.oldOptions))
[17:43:10.283]     }
[17:43:10.283]     if (FALSE) {
[17:43:10.283]     }
[17:43:10.283]     else {
[17:43:10.283]         if (TRUE) {
[17:43:10.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:10.283]                 open = "w")
[17:43:10.283]         }
[17:43:10.283]         else {
[17:43:10.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:10.283]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:10.283]         }
[17:43:10.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:10.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:10.283]             base::sink(type = "output", split = FALSE)
[17:43:10.283]             base::close(...future.stdout)
[17:43:10.283]         }, add = TRUE)
[17:43:10.283]     }
[17:43:10.283]     ...future.frame <- base::sys.nframe()
[17:43:10.283]     ...future.conditions <- base::list()
[17:43:10.283]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:10.283]     if (FALSE) {
[17:43:10.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:10.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:10.283]     }
[17:43:10.283]     ...future.result <- base::tryCatch({
[17:43:10.283]         base::withCallingHandlers({
[17:43:10.283]             ...future.value <- base::withVisible(base::local({
[17:43:10.283]                 withCallingHandlers({
[17:43:10.283]                   subset(data, a == 2)
[17:43:10.283]                 }, immediateCondition = function(cond) {
[17:43:10.283]                   save_rds <- function (object, pathname, ...) 
[17:43:10.283]                   {
[17:43:10.283]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:10.283]                     if (file_test("-f", pathname_tmp)) {
[17:43:10.283]                       fi_tmp <- file.info(pathname_tmp)
[17:43:10.283]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:10.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:10.283]                         fi_tmp[["mtime"]])
[17:43:10.283]                     }
[17:43:10.283]                     tryCatch({
[17:43:10.283]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:10.283]                     }, error = function(ex) {
[17:43:10.283]                       msg <- conditionMessage(ex)
[17:43:10.283]                       fi_tmp <- file.info(pathname_tmp)
[17:43:10.283]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:10.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:10.283]                         fi_tmp[["mtime"]], msg)
[17:43:10.283]                       ex$message <- msg
[17:43:10.283]                       stop(ex)
[17:43:10.283]                     })
[17:43:10.283]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:10.283]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:10.283]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:10.283]                       fi_tmp <- file.info(pathname_tmp)
[17:43:10.283]                       fi <- file.info(pathname)
[17:43:10.283]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:10.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:10.283]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:10.283]                         fi[["size"]], fi[["mtime"]])
[17:43:10.283]                       stop(msg)
[17:43:10.283]                     }
[17:43:10.283]                     invisible(pathname)
[17:43:10.283]                   }
[17:43:10.283]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:10.283]                     rootPath = tempdir()) 
[17:43:10.283]                   {
[17:43:10.283]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:10.283]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:10.283]                       tmpdir = path, fileext = ".rds")
[17:43:10.283]                     save_rds(obj, file)
[17:43:10.283]                   }
[17:43:10.283]                   saveImmediateCondition(cond, path = "/tmp/RtmpzPUCYD/.future/immediateConditions")
[17:43:10.283]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.283]                   {
[17:43:10.283]                     inherits <- base::inherits
[17:43:10.283]                     invokeRestart <- base::invokeRestart
[17:43:10.283]                     is.null <- base::is.null
[17:43:10.283]                     muffled <- FALSE
[17:43:10.283]                     if (inherits(cond, "message")) {
[17:43:10.283]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:10.283]                       if (muffled) 
[17:43:10.283]                         invokeRestart("muffleMessage")
[17:43:10.283]                     }
[17:43:10.283]                     else if (inherits(cond, "warning")) {
[17:43:10.283]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:10.283]                       if (muffled) 
[17:43:10.283]                         invokeRestart("muffleWarning")
[17:43:10.283]                     }
[17:43:10.283]                     else if (inherits(cond, "condition")) {
[17:43:10.283]                       if (!is.null(pattern)) {
[17:43:10.283]                         computeRestarts <- base::computeRestarts
[17:43:10.283]                         grepl <- base::grepl
[17:43:10.283]                         restarts <- computeRestarts(cond)
[17:43:10.283]                         for (restart in restarts) {
[17:43:10.283]                           name <- restart$name
[17:43:10.283]                           if (is.null(name)) 
[17:43:10.283]                             next
[17:43:10.283]                           if (!grepl(pattern, name)) 
[17:43:10.283]                             next
[17:43:10.283]                           invokeRestart(restart)
[17:43:10.283]                           muffled <- TRUE
[17:43:10.283]                           break
[17:43:10.283]                         }
[17:43:10.283]                       }
[17:43:10.283]                     }
[17:43:10.283]                     invisible(muffled)
[17:43:10.283]                   }
[17:43:10.283]                   muffleCondition(cond)
[17:43:10.283]                 })
[17:43:10.283]             }))
[17:43:10.283]             future::FutureResult(value = ...future.value$value, 
[17:43:10.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.283]                   ...future.rng), globalenv = if (FALSE) 
[17:43:10.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:10.283]                     ...future.globalenv.names))
[17:43:10.283]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:10.283]         }, condition = base::local({
[17:43:10.283]             c <- base::c
[17:43:10.283]             inherits <- base::inherits
[17:43:10.283]             invokeRestart <- base::invokeRestart
[17:43:10.283]             length <- base::length
[17:43:10.283]             list <- base::list
[17:43:10.283]             seq.int <- base::seq.int
[17:43:10.283]             signalCondition <- base::signalCondition
[17:43:10.283]             sys.calls <- base::sys.calls
[17:43:10.283]             `[[` <- base::`[[`
[17:43:10.283]             `+` <- base::`+`
[17:43:10.283]             `<<-` <- base::`<<-`
[17:43:10.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:10.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:10.283]                   3L)]
[17:43:10.283]             }
[17:43:10.283]             function(cond) {
[17:43:10.283]                 is_error <- inherits(cond, "error")
[17:43:10.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:10.283]                   NULL)
[17:43:10.283]                 if (is_error) {
[17:43:10.283]                   sessionInformation <- function() {
[17:43:10.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:10.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:10.283]                       search = base::search(), system = base::Sys.info())
[17:43:10.283]                   }
[17:43:10.283]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:10.283]                     cond$call), session = sessionInformation(), 
[17:43:10.283]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:10.283]                   signalCondition(cond)
[17:43:10.283]                 }
[17:43:10.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:10.283]                 "immediateCondition"))) {
[17:43:10.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:10.283]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:10.283]                   if (TRUE && !signal) {
[17:43:10.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.283]                     {
[17:43:10.283]                       inherits <- base::inherits
[17:43:10.283]                       invokeRestart <- base::invokeRestart
[17:43:10.283]                       is.null <- base::is.null
[17:43:10.283]                       muffled <- FALSE
[17:43:10.283]                       if (inherits(cond, "message")) {
[17:43:10.283]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.283]                         if (muffled) 
[17:43:10.283]                           invokeRestart("muffleMessage")
[17:43:10.283]                       }
[17:43:10.283]                       else if (inherits(cond, "warning")) {
[17:43:10.283]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.283]                         if (muffled) 
[17:43:10.283]                           invokeRestart("muffleWarning")
[17:43:10.283]                       }
[17:43:10.283]                       else if (inherits(cond, "condition")) {
[17:43:10.283]                         if (!is.null(pattern)) {
[17:43:10.283]                           computeRestarts <- base::computeRestarts
[17:43:10.283]                           grepl <- base::grepl
[17:43:10.283]                           restarts <- computeRestarts(cond)
[17:43:10.283]                           for (restart in restarts) {
[17:43:10.283]                             name <- restart$name
[17:43:10.283]                             if (is.null(name)) 
[17:43:10.283]                               next
[17:43:10.283]                             if (!grepl(pattern, name)) 
[17:43:10.283]                               next
[17:43:10.283]                             invokeRestart(restart)
[17:43:10.283]                             muffled <- TRUE
[17:43:10.283]                             break
[17:43:10.283]                           }
[17:43:10.283]                         }
[17:43:10.283]                       }
[17:43:10.283]                       invisible(muffled)
[17:43:10.283]                     }
[17:43:10.283]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.283]                   }
[17:43:10.283]                 }
[17:43:10.283]                 else {
[17:43:10.283]                   if (TRUE) {
[17:43:10.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.283]                     {
[17:43:10.283]                       inherits <- base::inherits
[17:43:10.283]                       invokeRestart <- base::invokeRestart
[17:43:10.283]                       is.null <- base::is.null
[17:43:10.283]                       muffled <- FALSE
[17:43:10.283]                       if (inherits(cond, "message")) {
[17:43:10.283]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.283]                         if (muffled) 
[17:43:10.283]                           invokeRestart("muffleMessage")
[17:43:10.283]                       }
[17:43:10.283]                       else if (inherits(cond, "warning")) {
[17:43:10.283]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.283]                         if (muffled) 
[17:43:10.283]                           invokeRestart("muffleWarning")
[17:43:10.283]                       }
[17:43:10.283]                       else if (inherits(cond, "condition")) {
[17:43:10.283]                         if (!is.null(pattern)) {
[17:43:10.283]                           computeRestarts <- base::computeRestarts
[17:43:10.283]                           grepl <- base::grepl
[17:43:10.283]                           restarts <- computeRestarts(cond)
[17:43:10.283]                           for (restart in restarts) {
[17:43:10.283]                             name <- restart$name
[17:43:10.283]                             if (is.null(name)) 
[17:43:10.283]                               next
[17:43:10.283]                             if (!grepl(pattern, name)) 
[17:43:10.283]                               next
[17:43:10.283]                             invokeRestart(restart)
[17:43:10.283]                             muffled <- TRUE
[17:43:10.283]                             break
[17:43:10.283]                           }
[17:43:10.283]                         }
[17:43:10.283]                       }
[17:43:10.283]                       invisible(muffled)
[17:43:10.283]                     }
[17:43:10.283]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.283]                   }
[17:43:10.283]                 }
[17:43:10.283]             }
[17:43:10.283]         }))
[17:43:10.283]     }, error = function(ex) {
[17:43:10.283]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:10.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.283]                 ...future.rng), started = ...future.startTime, 
[17:43:10.283]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:10.283]             version = "1.8"), class = "FutureResult")
[17:43:10.283]     }, finally = {
[17:43:10.283]         if (!identical(...future.workdir, getwd())) 
[17:43:10.283]             setwd(...future.workdir)
[17:43:10.283]         {
[17:43:10.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:10.283]                 ...future.oldOptions$nwarnings <- NULL
[17:43:10.283]             }
[17:43:10.283]             base::options(...future.oldOptions)
[17:43:10.283]             if (.Platform$OS.type == "windows") {
[17:43:10.283]                 old_names <- names(...future.oldEnvVars)
[17:43:10.283]                 envs <- base::Sys.getenv()
[17:43:10.283]                 names <- names(envs)
[17:43:10.283]                 common <- intersect(names, old_names)
[17:43:10.283]                 added <- setdiff(names, old_names)
[17:43:10.283]                 removed <- setdiff(old_names, names)
[17:43:10.283]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:10.283]                   envs[common]]
[17:43:10.283]                 NAMES <- toupper(changed)
[17:43:10.283]                 args <- list()
[17:43:10.283]                 for (kk in seq_along(NAMES)) {
[17:43:10.283]                   name <- changed[[kk]]
[17:43:10.283]                   NAME <- NAMES[[kk]]
[17:43:10.283]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.283]                     next
[17:43:10.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.283]                 }
[17:43:10.283]                 NAMES <- toupper(added)
[17:43:10.283]                 for (kk in seq_along(NAMES)) {
[17:43:10.283]                   name <- added[[kk]]
[17:43:10.283]                   NAME <- NAMES[[kk]]
[17:43:10.283]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.283]                     next
[17:43:10.283]                   args[[name]] <- ""
[17:43:10.283]                 }
[17:43:10.283]                 NAMES <- toupper(removed)
[17:43:10.283]                 for (kk in seq_along(NAMES)) {
[17:43:10.283]                   name <- removed[[kk]]
[17:43:10.283]                   NAME <- NAMES[[kk]]
[17:43:10.283]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.283]                     next
[17:43:10.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.283]                 }
[17:43:10.283]                 if (length(args) > 0) 
[17:43:10.283]                   base::do.call(base::Sys.setenv, args = args)
[17:43:10.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:10.283]             }
[17:43:10.283]             else {
[17:43:10.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:10.283]             }
[17:43:10.283]             {
[17:43:10.283]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:10.283]                   0L) {
[17:43:10.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:10.283]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:10.283]                   base::options(opts)
[17:43:10.283]                 }
[17:43:10.283]                 {
[17:43:10.283]                   {
[17:43:10.283]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:10.283]                     NULL
[17:43:10.283]                   }
[17:43:10.283]                   options(future.plan = NULL)
[17:43:10.283]                   if (is.na(NA_character_)) 
[17:43:10.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:10.283]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:10.283]                     envir = parent.frame()) 
[17:43:10.283]                   {
[17:43:10.283]                     default_workers <- missing(workers)
[17:43:10.283]                     if (is.function(workers)) 
[17:43:10.283]                       workers <- workers()
[17:43:10.283]                     workers <- structure(as.integer(workers), 
[17:43:10.283]                       class = class(workers))
[17:43:10.283]                     stop_if_not(is.finite(workers), workers >= 
[17:43:10.283]                       1L)
[17:43:10.283]                     if ((workers == 1L && !inherits(workers, 
[17:43:10.283]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:10.283]                       if (default_workers) 
[17:43:10.283]                         supportsMulticore(warn = TRUE)
[17:43:10.283]                       return(sequential(..., envir = envir))
[17:43:10.283]                     }
[17:43:10.283]                     oopts <- options(mc.cores = workers)
[17:43:10.283]                     on.exit(options(oopts))
[17:43:10.283]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:10.283]                       envir = envir)
[17:43:10.283]                     if (!future$lazy) 
[17:43:10.283]                       future <- run(future)
[17:43:10.283]                     invisible(future)
[17:43:10.283]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.283]                 }
[17:43:10.283]             }
[17:43:10.283]         }
[17:43:10.283]     })
[17:43:10.283]     if (TRUE) {
[17:43:10.283]         base::sink(type = "output", split = FALSE)
[17:43:10.283]         if (TRUE) {
[17:43:10.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:10.283]         }
[17:43:10.283]         else {
[17:43:10.283]             ...future.result["stdout"] <- base::list(NULL)
[17:43:10.283]         }
[17:43:10.283]         base::close(...future.stdout)
[17:43:10.283]         ...future.stdout <- NULL
[17:43:10.283]     }
[17:43:10.283]     ...future.result$conditions <- ...future.conditions
[17:43:10.283]     ...future.result$finished <- base::Sys.time()
[17:43:10.283]     ...future.result
[17:43:10.283] }
[17:43:10.319]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.286] assign_globals() ...
[17:43:10.319]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.286] List of 1
[17:43:10.286]  $ data:'data.frame':	3 obs. of  2 variables:
[17:43:10.286]   ..$ a: int [1:3] 1 2 3
[17:43:10.286]   ..$ b: int [1:3] 3 2 1
[17:43:10.286]  - attr(*, "where")=List of 1
[17:43:10.286]   ..$ data:<environment: R_EmptyEnv> 
[17:43:10.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:10.286]  - attr(*, "resolved")= logi FALSE
[17:43:10.286]  - attr(*, "total_size")= num 128
[17:43:10.286]  - attr(*, "already-done")= logi TRUE
[17:43:10.319]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.289] - copied ‘data’ to environment
[17:43:10.319]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.289] assign_globals() ... done
[17:43:10.319]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.289] requestCore(): workers = 2
[17:43:10.320]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.291] MulticoreFuture started
[17:43:10.320]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.292] - Launch lazy future ... done
[17:43:10.320]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.292] run() for ‘MulticoreFuture’ ... done
[17:43:10.320] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[17:43:10.321] plan(): Setting new future strategy stack:
[17:43:10.321] List of future strategies:
[17:43:10.321] 1. sequential:
[17:43:10.321]    - args: function (..., envir = parent.frame())
[17:43:10.321]    - tweaked: FALSE
[17:43:10.321]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.321] 2. multisession:
[17:43:10.321]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:10.321]    - tweaked: FALSE
[17:43:10.321]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.321] plan(): nbrOfWorkers() = 1
[17:43:10.322] getGlobalsAndPackages() ...
[17:43:10.322] Searching for globals...
[17:43:10.341] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:43:10.341] Searching for globals ... DONE
[17:43:10.342] Resolving globals: FALSE
[17:43:10.343] The total size of the 2 globals is 55.41 KiB (56736 bytes)
[17:43:10.343] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.29 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:43:10.343] - globals: [2] ‘nested’, ‘strategy2’
[17:43:10.343] - packages: [1] ‘future’
[17:43:10.344] getGlobalsAndPackages() ... DONE
[17:43:10.344] run() for ‘Future’ ...
[17:43:10.344] - state: ‘created’
[17:43:10.344] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:10.344] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:10.344] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:10.345]   - Field: ‘label’
[17:43:10.345]   - Field: ‘local’
[17:43:10.345]   - Field: ‘owner’
[17:43:10.345]   - Field: ‘envir’
[17:43:10.345]   - Field: ‘packages’
[17:43:10.345]   - Field: ‘gc’
[17:43:10.345]   - Field: ‘conditions’
[17:43:10.345]   - Field: ‘expr’
[17:43:10.345]   - Field: ‘uuid’
[17:43:10.346]   - Field: ‘seed’
[17:43:10.346]   - Field: ‘version’
[17:43:10.346]   - Field: ‘result’
[17:43:10.346]   - Field: ‘asynchronous’
[17:43:10.346]   - Field: ‘calls’
[17:43:10.346]   - Field: ‘globals’
[17:43:10.346]   - Field: ‘stdout’
[17:43:10.346]   - Field: ‘earlySignal’
[17:43:10.346]   - Field: ‘lazy’
[17:43:10.347]   - Field: ‘state’
[17:43:10.348] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:10.348] - Launch lazy future ...
[17:43:10.349] Packages needed by the future expression (n = 1): ‘future’
[17:43:10.349] Packages needed by future strategies (n = 1): ‘future’
[17:43:10.350] {
[17:43:10.350]     {
[17:43:10.350]         {
[17:43:10.350]             ...future.startTime <- base::Sys.time()
[17:43:10.350]             {
[17:43:10.350]                 {
[17:43:10.350]                   {
[17:43:10.350]                     {
[17:43:10.350]                       base::local({
[17:43:10.350]                         has_future <- base::requireNamespace("future", 
[17:43:10.350]                           quietly = TRUE)
[17:43:10.350]                         if (has_future) {
[17:43:10.350]                           ns <- base::getNamespace("future")
[17:43:10.350]                           version <- ns[[".package"]][["version"]]
[17:43:10.350]                           if (is.null(version)) 
[17:43:10.350]                             version <- utils::packageVersion("future")
[17:43:10.350]                         }
[17:43:10.350]                         else {
[17:43:10.350]                           version <- NULL
[17:43:10.350]                         }
[17:43:10.350]                         if (!has_future || version < "1.8.0") {
[17:43:10.350]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:10.350]                             "", base::R.version$version.string), 
[17:43:10.350]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:10.350]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:10.350]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:10.350]                               "release", "version")], collapse = " "), 
[17:43:10.350]                             hostname = base::Sys.info()[["nodename"]])
[17:43:10.350]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:10.350]                             info)
[17:43:10.350]                           info <- base::paste(info, collapse = "; ")
[17:43:10.350]                           if (!has_future) {
[17:43:10.350]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:10.350]                               info)
[17:43:10.350]                           }
[17:43:10.350]                           else {
[17:43:10.350]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:10.350]                               info, version)
[17:43:10.350]                           }
[17:43:10.350]                           base::stop(msg)
[17:43:10.350]                         }
[17:43:10.350]                       })
[17:43:10.350]                     }
[17:43:10.350]                     base::local({
[17:43:10.350]                       for (pkg in "future") {
[17:43:10.350]                         base::loadNamespace(pkg)
[17:43:10.350]                         base::library(pkg, character.only = TRUE)
[17:43:10.350]                       }
[17:43:10.350]                     })
[17:43:10.350]                   }
[17:43:10.350]                   options(future.plan = NULL)
[17:43:10.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.350]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:43:10.350]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:10.350]                     envir = parent.frame()) 
[17:43:10.350]                   {
[17:43:10.350]                     if (is.function(workers)) 
[17:43:10.350]                       workers <- workers()
[17:43:10.350]                     workers <- structure(as.integer(workers), 
[17:43:10.350]                       class = class(workers))
[17:43:10.350]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:10.350]                       workers >= 1)
[17:43:10.350]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:10.350]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:10.350]                     }
[17:43:10.350]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:10.350]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:10.350]                       envir = envir)
[17:43:10.350]                     if (!future$lazy) 
[17:43:10.350]                       future <- run(future)
[17:43:10.350]                     invisible(future)
[17:43:10.350]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.350]                 }
[17:43:10.350]                 ...future.workdir <- getwd()
[17:43:10.350]             }
[17:43:10.350]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:10.350]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:10.350]         }
[17:43:10.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:10.350]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:10.350]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:10.350]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:10.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:10.350]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:10.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:10.350]             base::names(...future.oldOptions))
[17:43:10.350]     }
[17:43:10.350]     if (FALSE) {
[17:43:10.350]     }
[17:43:10.350]     else {
[17:43:10.350]         if (TRUE) {
[17:43:10.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:10.350]                 open = "w")
[17:43:10.350]         }
[17:43:10.350]         else {
[17:43:10.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:10.350]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:10.350]         }
[17:43:10.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:10.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:10.350]             base::sink(type = "output", split = FALSE)
[17:43:10.350]             base::close(...future.stdout)
[17:43:10.350]         }, add = TRUE)
[17:43:10.350]     }
[17:43:10.350]     ...future.frame <- base::sys.nframe()
[17:43:10.350]     ...future.conditions <- base::list()
[17:43:10.350]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:10.350]     if (FALSE) {
[17:43:10.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:10.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:10.350]     }
[17:43:10.350]     ...future.result <- base::tryCatch({
[17:43:10.350]         base::withCallingHandlers({
[17:43:10.350]             ...future.value <- base::withVisible(base::local({
[17:43:10.350]                 a <- 1L
[17:43:10.350]                 plan_a <- unclass(future::plan("list"))
[17:43:10.350]                 nested_a <- nested[-1]
[17:43:10.350]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:43:10.350]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:43:10.350]                   strategy2))
[17:43:10.350]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:43:10.350]                   "init") <- NULL
[17:43:10.350]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:43:10.350]                   "init") <- NULL
[17:43:10.350]                 stopifnot(all.equal(plan_a, nested_a))
[17:43:10.350]                 y %<-% {
[17:43:10.350]                   b <- 2L
[17:43:10.350]                   plan_b <- future::plan("list")
[17:43:10.350]                   nested_b <- nested_a[-1]
[17:43:10.350]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:10.350]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:43:10.350]                     "sequential"))
[17:43:10.350]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:10.350]                     b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:10.350]                 }
[17:43:10.350]                 y
[17:43:10.350]             }))
[17:43:10.350]             future::FutureResult(value = ...future.value$value, 
[17:43:10.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.350]                   ...future.rng), globalenv = if (FALSE) 
[17:43:10.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:10.350]                     ...future.globalenv.names))
[17:43:10.350]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:10.350]         }, condition = base::local({
[17:43:10.350]             c <- base::c
[17:43:10.350]             inherits <- base::inherits
[17:43:10.350]             invokeRestart <- base::invokeRestart
[17:43:10.350]             length <- base::length
[17:43:10.350]             list <- base::list
[17:43:10.350]             seq.int <- base::seq.int
[17:43:10.350]             signalCondition <- base::signalCondition
[17:43:10.350]             sys.calls <- base::sys.calls
[17:43:10.350]             `[[` <- base::`[[`
[17:43:10.350]             `+` <- base::`+`
[17:43:10.350]             `<<-` <- base::`<<-`
[17:43:10.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:10.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:10.350]                   3L)]
[17:43:10.350]             }
[17:43:10.350]             function(cond) {
[17:43:10.350]                 is_error <- inherits(cond, "error")
[17:43:10.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:10.350]                   NULL)
[17:43:10.350]                 if (is_error) {
[17:43:10.350]                   sessionInformation <- function() {
[17:43:10.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:10.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:10.350]                       search = base::search(), system = base::Sys.info())
[17:43:10.350]                   }
[17:43:10.350]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:10.350]                     cond$call), session = sessionInformation(), 
[17:43:10.350]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:10.350]                   signalCondition(cond)
[17:43:10.350]                 }
[17:43:10.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:10.350]                 "immediateCondition"))) {
[17:43:10.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:10.350]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:10.350]                   if (TRUE && !signal) {
[17:43:10.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.350]                     {
[17:43:10.350]                       inherits <- base::inherits
[17:43:10.350]                       invokeRestart <- base::invokeRestart
[17:43:10.350]                       is.null <- base::is.null
[17:43:10.350]                       muffled <- FALSE
[17:43:10.350]                       if (inherits(cond, "message")) {
[17:43:10.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.350]                         if (muffled) 
[17:43:10.350]                           invokeRestart("muffleMessage")
[17:43:10.350]                       }
[17:43:10.350]                       else if (inherits(cond, "warning")) {
[17:43:10.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.350]                         if (muffled) 
[17:43:10.350]                           invokeRestart("muffleWarning")
[17:43:10.350]                       }
[17:43:10.350]                       else if (inherits(cond, "condition")) {
[17:43:10.350]                         if (!is.null(pattern)) {
[17:43:10.350]                           computeRestarts <- base::computeRestarts
[17:43:10.350]                           grepl <- base::grepl
[17:43:10.350]                           restarts <- computeRestarts(cond)
[17:43:10.350]                           for (restart in restarts) {
[17:43:10.350]                             name <- restart$name
[17:43:10.350]                             if (is.null(name)) 
[17:43:10.350]                               next
[17:43:10.350]                             if (!grepl(pattern, name)) 
[17:43:10.350]                               next
[17:43:10.350]                             invokeRestart(restart)
[17:43:10.350]                             muffled <- TRUE
[17:43:10.350]                             break
[17:43:10.350]                           }
[17:43:10.350]                         }
[17:43:10.350]                       }
[17:43:10.350]                       invisible(muffled)
[17:43:10.350]                     }
[17:43:10.350]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.350]                   }
[17:43:10.350]                 }
[17:43:10.350]                 else {
[17:43:10.350]                   if (TRUE) {
[17:43:10.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.350]                     {
[17:43:10.350]                       inherits <- base::inherits
[17:43:10.350]                       invokeRestart <- base::invokeRestart
[17:43:10.350]                       is.null <- base::is.null
[17:43:10.350]                       muffled <- FALSE
[17:43:10.350]                       if (inherits(cond, "message")) {
[17:43:10.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.350]                         if (muffled) 
[17:43:10.350]                           invokeRestart("muffleMessage")
[17:43:10.350]                       }
[17:43:10.350]                       else if (inherits(cond, "warning")) {
[17:43:10.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.350]                         if (muffled) 
[17:43:10.350]                           invokeRestart("muffleWarning")
[17:43:10.350]                       }
[17:43:10.350]                       else if (inherits(cond, "condition")) {
[17:43:10.350]                         if (!is.null(pattern)) {
[17:43:10.350]                           computeRestarts <- base::computeRestarts
[17:43:10.350]                           grepl <- base::grepl
[17:43:10.350]                           restarts <- computeRestarts(cond)
[17:43:10.350]                           for (restart in restarts) {
[17:43:10.350]                             name <- restart$name
[17:43:10.350]                             if (is.null(name)) 
[17:43:10.350]                               next
[17:43:10.350]                             if (!grepl(pattern, name)) 
[17:43:10.350]                               next
[17:43:10.350]                             invokeRestart(restart)
[17:43:10.350]                             muffled <- TRUE
[17:43:10.350]                             break
[17:43:10.350]                           }
[17:43:10.350]                         }
[17:43:10.350]                       }
[17:43:10.350]                       invisible(muffled)
[17:43:10.350]                     }
[17:43:10.350]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.350]                   }
[17:43:10.350]                 }
[17:43:10.350]             }
[17:43:10.350]         }))
[17:43:10.350]     }, error = function(ex) {
[17:43:10.350]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:10.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.350]                 ...future.rng), started = ...future.startTime, 
[17:43:10.350]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:10.350]             version = "1.8"), class = "FutureResult")
[17:43:10.350]     }, finally = {
[17:43:10.350]         if (!identical(...future.workdir, getwd())) 
[17:43:10.350]             setwd(...future.workdir)
[17:43:10.350]         {
[17:43:10.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:10.350]                 ...future.oldOptions$nwarnings <- NULL
[17:43:10.350]             }
[17:43:10.350]             base::options(...future.oldOptions)
[17:43:10.350]             if (.Platform$OS.type == "windows") {
[17:43:10.350]                 old_names <- names(...future.oldEnvVars)
[17:43:10.350]                 envs <- base::Sys.getenv()
[17:43:10.350]                 names <- names(envs)
[17:43:10.350]                 common <- intersect(names, old_names)
[17:43:10.350]                 added <- setdiff(names, old_names)
[17:43:10.350]                 removed <- setdiff(old_names, names)
[17:43:10.350]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:10.350]                   envs[common]]
[17:43:10.350]                 NAMES <- toupper(changed)
[17:43:10.350]                 args <- list()
[17:43:10.350]                 for (kk in seq_along(NAMES)) {
[17:43:10.350]                   name <- changed[[kk]]
[17:43:10.350]                   NAME <- NAMES[[kk]]
[17:43:10.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.350]                     next
[17:43:10.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.350]                 }
[17:43:10.350]                 NAMES <- toupper(added)
[17:43:10.350]                 for (kk in seq_along(NAMES)) {
[17:43:10.350]                   name <- added[[kk]]
[17:43:10.350]                   NAME <- NAMES[[kk]]
[17:43:10.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.350]                     next
[17:43:10.350]                   args[[name]] <- ""
[17:43:10.350]                 }
[17:43:10.350]                 NAMES <- toupper(removed)
[17:43:10.350]                 for (kk in seq_along(NAMES)) {
[17:43:10.350]                   name <- removed[[kk]]
[17:43:10.350]                   NAME <- NAMES[[kk]]
[17:43:10.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.350]                     next
[17:43:10.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.350]                 }
[17:43:10.350]                 if (length(args) > 0) 
[17:43:10.350]                   base::do.call(base::Sys.setenv, args = args)
[17:43:10.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:10.350]             }
[17:43:10.350]             else {
[17:43:10.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:10.350]             }
[17:43:10.350]             {
[17:43:10.350]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:10.350]                   0L) {
[17:43:10.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:10.350]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:10.350]                   base::options(opts)
[17:43:10.350]                 }
[17:43:10.350]                 {
[17:43:10.350]                   {
[17:43:10.350]                     NULL
[17:43:10.350]                     RNGkind("Mersenne-Twister")
[17:43:10.350]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:10.350]                       inherits = FALSE)
[17:43:10.350]                   }
[17:43:10.350]                   options(future.plan = NULL)
[17:43:10.350]                   if (is.na(NA_character_)) 
[17:43:10.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:10.350]                   future::plan(list(a = function (..., envir = parent.frame()) 
[17:43:10.350]                   {
[17:43:10.350]                     future <- SequentialFuture(..., envir = envir)
[17:43:10.350]                     if (!future$lazy) 
[17:43:10.350]                       future <- run(future)
[17:43:10.350]                     invisible(future)
[17:43:10.350]                   }, b = function (..., workers = availableCores(), 
[17:43:10.350]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:10.350]                     envir = parent.frame()) 
[17:43:10.350]                   {
[17:43:10.350]                     if (is.function(workers)) 
[17:43:10.350]                       workers <- workers()
[17:43:10.350]                     workers <- structure(as.integer(workers), 
[17:43:10.350]                       class = class(workers))
[17:43:10.350]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:10.350]                       workers >= 1)
[17:43:10.350]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:10.350]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:10.350]                     }
[17:43:10.350]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:10.350]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:10.350]                       envir = envir)
[17:43:10.350]                     if (!future$lazy) 
[17:43:10.350]                       future <- run(future)
[17:43:10.350]                     invisible(future)
[17:43:10.350]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.350]                 }
[17:43:10.350]             }
[17:43:10.350]         }
[17:43:10.350]     })
[17:43:10.350]     if (TRUE) {
[17:43:10.350]         base::sink(type = "output", split = FALSE)
[17:43:10.350]         if (TRUE) {
[17:43:10.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:10.350]         }
[17:43:10.350]         else {
[17:43:10.350]             ...future.result["stdout"] <- base::list(NULL)
[17:43:10.350]         }
[17:43:10.350]         base::close(...future.stdout)
[17:43:10.350]         ...future.stdout <- NULL
[17:43:10.350]     }
[17:43:10.350]     ...future.result$conditions <- ...future.conditions
[17:43:10.350]     ...future.result$finished <- base::Sys.time()
[17:43:10.350]     ...future.result
[17:43:10.350] }
[17:43:10.352] assign_globals() ...
[17:43:10.352] List of 2
[17:43:10.352]  $ nested   :List of 2
[17:43:10.352]   ..$ a:function (..., envir = parent.frame())  
[17:43:10.352]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:43:10.352]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:10.352]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:10.352]     envir = parent.frame())  
[17:43:10.352]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:43:10.352]   .. ..- attr(*, "init")= logi TRUE
[17:43:10.352]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:43:10.352]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:10.352]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:10.352]  $ strategy2: chr "multisession"
[17:43:10.352]  - attr(*, "where")=List of 2
[17:43:10.352]   ..$ nested   :<environment: R_EmptyEnv> 
[17:43:10.352]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:43:10.352]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:10.352]  - attr(*, "resolved")= logi FALSE
[17:43:10.352]  - attr(*, "total_size")= num 56736
[17:43:10.352]  - attr(*, "already-done")= logi TRUE
[17:43:10.357] - copied ‘nested’ to environment
[17:43:10.357] - copied ‘strategy2’ to environment
[17:43:10.357] assign_globals() ... done
[17:43:10.358] plan(): Setting new future strategy stack:
[17:43:10.358] List of future strategies:
[17:43:10.358] 1. multisession:
[17:43:10.358]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:10.358]    - tweaked: FALSE
[17:43:10.358]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:10.362] plan(): nbrOfWorkers() = 2
[17:43:11.155] plan(): Setting new future strategy stack:
[17:43:11.156] List of future strategies:
[17:43:11.156] 1. sequential:
[17:43:11.156]    - args: function (..., envir = parent.frame())
[17:43:11.156]    - tweaked: FALSE
[17:43:11.156]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.156] 2. multisession:
[17:43:11.156]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.156]    - tweaked: FALSE
[17:43:11.156]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.156] plan(): nbrOfWorkers() = 1
[17:43:11.157] SequentialFuture started (and completed)
[17:43:11.157] signalConditions() ...
[17:43:11.157]  - include = ‘immediateCondition’
[17:43:11.157]  - exclude = 
[17:43:11.157]  - resignal = FALSE
[17:43:11.157]  - Number of conditions: 98
[17:43:11.157] signalConditions() ... done
[17:43:11.158] - Launch lazy future ... done
[17:43:11.158] run() for ‘SequentialFuture’ ... done
[17:43:11.158] signalConditions() ...
[17:43:11.158]  - include = ‘immediateCondition’
[17:43:11.158]  - exclude = 
[17:43:11.158]  - resignal = FALSE
[17:43:11.158]  - Number of conditions: 98
[17:43:11.159] signalConditions() ... done
[17:43:11.159] Future state: ‘finished’
[17:43:11.159] signalConditions() ...
[17:43:11.159]  - include = ‘condition’
[17:43:11.159]  - exclude = ‘immediateCondition’
[17:43:11.159]  - resignal = TRUE
[17:43:11.159]  - Number of conditions: 98
[17:43:11.159]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.363] getGlobalsAndPackages() ...
[17:43:11.160]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.363] Searching for globals...
[17:43:11.160]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.383] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:43:11.160]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.383] Searching for globals ... DONE
[17:43:11.160]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.383] Resolving globals: FALSE
[17:43:11.160]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.384] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[17:43:11.161]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.384] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:43:11.161]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.384] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:43:11.161]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.385] 
[17:43:11.161]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.385] getGlobalsAndPackages() ... DONE
[17:43:11.161]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.385] run() for ‘Future’ ...
[17:43:11.161]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.385] - state: ‘created’
[17:43:11.162]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.385] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.162]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.391] [local output] makeClusterPSOCK() ...
[17:43:11.162]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.448] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:43:11.162]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.454] [local output] Base port: 11458
[17:43:11.162]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.454] [local output] Getting setup options for 2 cluster nodes ...
[17:43:11.162]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.454] [local output]  - Node 1 of 2 ...
[17:43:11.163]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.454] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:11.163]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.455] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpzPUCYD/worker.rank=1.parallelly.parent=50370.c4c25d202e3e.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpzPUCYD/worker.rank=1.parallelly.parent=50370.c4c25d202e3e.pid")'’
[17:43:11.163]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.648] - Possible to infer worker's PID: TRUE
[17:43:11.163]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.648] [local output] Rscript port: 11458

[17:43:11.163]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.649] [local output]  - Node 2 of 2 ...
[17:43:11.164]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.649] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:11.164]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.650] [local output] Rscript port: 11458

[17:43:11.164]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.650] [local output] Getting setup options for 2 cluster nodes ... done
[17:43:11.164]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.650] [local output]  - Parallel setup requested for some PSOCK nodes
[17:43:11.164]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.651] [local output] Setting up PSOCK nodes in parallel
[17:43:11.164]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.651] List of 36
[17:43:10.651]  $ worker          : chr "localhost"
[17:43:10.651]   ..- attr(*, "localhost")= logi TRUE
[17:43:10.651]  $ master          : chr "localhost"
[17:43:10.651]  $ port            : int 11458
[17:43:10.651]  $ connectTimeout  : num 120
[17:43:10.651]  $ timeout         : num 2592000
[17:43:10.651]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:43:10.651]  $ homogeneous     : logi TRUE
[17:43:10.651]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:43:10.651]  $ rscript_envs    : NULL
[17:43:10.651]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:10.651]  $ rscript_startup : NULL
[17:43:10.651]  $ rscript_sh      : chr "sh"
[17:43:10.651]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:10.651]  $ methods         : logi TRUE
[17:43:10.651]  $ socketOptions   : chr "no-delay"
[17:43:10.651]  $ useXDR          : logi FALSE
[17:43:10.651]  $ outfile         : chr "/dev/null"
[17:43:10.651]  $ renice          : int NA
[17:43:10.651]  $ rshcmd          : NULL
[17:43:10.651]  $ user            : chr(0) 
[17:43:10.651]  $ revtunnel       : logi FALSE
[17:43:10.651]  $ rshlogfile      : NULL
[17:43:10.651]  $ rshopts         : chr(0) 
[17:43:10.651]  $ rank            : int 1
[17:43:10.651]  $ manual          : logi FALSE
[17:43:10.651]  $ dryrun          : logi FALSE
[17:43:10.651]  $ quiet           : logi FALSE
[17:43:10.651]  $ setup_strategy  : chr "parallel"
[17:43:10.651]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:10.651]  $ pidfile         : chr "/tmp/RtmpzPUCYD/worker.rank=1.parallelly.parent=50370.c4c25d202e3e.pid"
[17:43:10.651]  $ rshcmd_label    : NULL
[17:43:10.651]  $ rsh_call        : NULL
[17:43:10.651]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:10.651]  $ localMachine    : logi TRUE
[17:43:10.651]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:43:10.651]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:43:10.651]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:43:10.651]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:43:10.651]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:43:10.651]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:43:10.651]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:43:10.651]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:43:10.651]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:43:10.651]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:43:10.651]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:43:10.651]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:43:10.651]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:43:10.651]  $ arguments       :List of 28
[17:43:10.651]   ..$ worker          : chr "localhost"
[17:43:10.651]   ..$ master          : NULL
[17:43:10.651]   ..$ port            : int 11458
[17:43:10.651]   ..$ connectTimeout  : num 120
[17:43:10.651]   ..$ timeout         : num 2592000
[17:43:10.651]   ..$ rscript         : NULL
[17:43:10.651]   ..$ homogeneous     : NULL
[17:43:10.651]   ..$ rscript_args    : NULL
[17:43:10.651]   ..$ rscript_envs    : NULL
[17:43:10.651]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:10.651]   ..$ rscript_startup : NULL
[17:43:10.651]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:43:10.651]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:10.651]   ..$ methods         : logi TRUE
[17:43:10.651]   ..$ socketOptions   : chr "no-delay"
[17:43:10.651]   ..$ useXDR          : logi FALSE
[17:43:10.651]   ..$ outfile         : chr "/dev/null"
[17:43:10.651]   ..$ renice          : int NA
[17:43:10.651]   ..$ rshcmd          : NULL
[17:43:10.651]   ..$ user            : NULL
[17:43:10.651]   ..$ revtunnel       : logi NA
[17:43:10.651]   ..$ rshlogfile      : NULL
[17:43:10.651]   ..$ rshopts         : NULL
[17:43:10.651]   ..$ rank            : int 1
[17:43:10.651]   ..$ manual          : logi FALSE
[17:43:10.651]   ..$ dryrun          : logi FALSE
[17:43:10.651]   ..$ quiet           : logi FALSE
[17:43:10.651]   ..$ setup_strategy  : chr "parallel"
[17:43:10.651]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:43:11.165]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.668] [local output] System call to launch all workers:
[17:43:11.165]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.668] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpzPUCYD/worker.rank=1.parallelly.parent=50370.c4c25d202e3e.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11458 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:43:11.165]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.668] [local output] Starting PSOCK main server
[17:43:11.165]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.670] [local output] Workers launched
[17:43:11.165]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.670] [local output] Waiting for workers to connect back
[17:43:11.165]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.670]  - [local output] 0 workers out of 2 ready
[17:43:11.166]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.936]  - [local output] 0 workers out of 2 ready
[17:43:11.166]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.937]  - [local output] 1 workers out of 2 ready
[17:43:11.166]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.937]  - [local output] 1 workers out of 2 ready
[17:43:11.166]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.938]  - [local output] 2 workers out of 2 ready
[17:43:11.166]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.938] [local output] Launching of workers completed
[17:43:11.166]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.938] [local output] Collecting session information from workers
[17:43:11.167]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.939] [local output]  - Worker #1 of 2
[17:43:11.167]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.940] [local output]  - Worker #2 of 2
[17:43:11.167]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.940] [local output] makeClusterPSOCK() ... done
[17:43:11.167]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.952] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:11.167]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.952] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:11.168]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.952]   - Field: ‘node’
[17:43:11.168]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.952]   - Field: ‘label’
[17:43:11.168]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.952]   - Field: ‘local’
[17:43:11.168]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.952]   - Field: ‘owner’
[17:43:11.168]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.952]   - Field: ‘envir’
[17:43:11.168]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.952]   - Field: ‘workers’
[17:43:11.169]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.953]   - Field: ‘packages’
[17:43:11.169]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.953]   - Field: ‘gc’
[17:43:11.169]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.953]   - Field: ‘conditions’
[17:43:11.169]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.953]   - Field: ‘persistent’
[17:43:11.169]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.953]   - Field: ‘expr’
[17:43:11.169]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.953]   - Field: ‘uuid’
[17:43:11.170]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.953]   - Field: ‘seed’
[17:43:11.170]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.954]   - Field: ‘version’
[17:43:11.170]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.954]   - Field: ‘result’
[17:43:11.170]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.954]   - Field: ‘asynchronous’
[17:43:11.170]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.954]   - Field: ‘calls’
[17:43:11.170]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.954]   - Field: ‘globals’
[17:43:11.171]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.954]   - Field: ‘stdout’
[17:43:11.171]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.954]   - Field: ‘earlySignal’
[17:43:11.171]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.955]   - Field: ‘lazy’
[17:43:11.172]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.955]   - Field: ‘state’
[17:43:11.172]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:11.172]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.955] - Launch lazy future ...
[17:43:11.172]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.956] Packages needed by the future expression (n = 0): <none>
[17:43:11.172]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.956] Packages needed by future strategies (n = 0): <none>
[17:43:11.172]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:10.957] {
[17:43:10.957]     {
[17:43:10.957]         {
[17:43:10.957]             ...future.startTime <- base::Sys.time()
[17:43:10.957]             {
[17:43:10.957]                 {
[17:43:10.957]                   {
[17:43:10.957]                     {
[17:43:10.957]                       base::local({
[17:43:10.957]                         has_future <- base::requireNamespace("future", 
[17:43:10.957]                           quietly = TRUE)
[17:43:10.957]                         if (has_future) {
[17:43:10.957]                           ns <- base::getNamespace("future")
[17:43:10.957]                           version <- ns[[".package"]][["version"]]
[17:43:10.957]                           if (is.null(version)) 
[17:43:10.957]                             version <- utils::packageVersion("future")
[17:43:10.957]                         }
[17:43:10.957]                         else {
[17:43:10.957]                           version <- NULL
[17:43:10.957]                         }
[17:43:10.957]                         if (!has_future || version < "1.8.0") {
[17:43:10.957]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:10.957]                             "", base::R.version$version.string), 
[17:43:10.957]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:10.957]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:10.957]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:10.957]                               "release", "version")], collapse = " "), 
[17:43:10.957]                             hostname = base::Sys.info()[["nodename"]])
[17:43:10.957]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:10.957]                             info)
[17:43:10.957]                           info <- base::paste(info, collapse = "; ")
[17:43:10.957]                           if (!has_future) {
[17:43:10.957]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:10.957]                               info)
[17:43:10.957]                           }
[17:43:10.957]                           else {
[17:43:10.957]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:10.957]                               info, version)
[17:43:10.957]                           }
[17:43:10.957]                           base::stop(msg)
[17:43:10.957]                         }
[17:43:10.957]                       })
[17:43:10.957]                     }
[17:43:10.957]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:10.957]                     base::options(mc.cores = 1L)
[17:43:10.957]                   }
[17:43:10.957]                   options(future.plan = NULL)
[17:43:10.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:10.957]                 }
[17:43:10.957]                 ...future.workdir <- getwd()
[17:43:10.957]             }
[17:43:10.957]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:10.957]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:10.957]         }
[17:43:10.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:10.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:10.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:10.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:10.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:10.957]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:10.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:10.957]             base::names(...future.oldOptions))
[17:43:10.957]     }
[17:43:10.957]     if (FALSE) {
[17:43:10.957]     }
[17:43:10.957]     else {
[17:43:10.957]         if (TRUE) {
[17:43:10.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:10.957]                 open = "w")
[17:43:10.957]         }
[17:43:10.957]         else {
[17:43:10.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:10.957]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:10.957]         }
[17:43:10.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:10.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:10.957]             base::sink(type = "output", split = FALSE)
[17:43:10.957]             base::close(...future.stdout)
[17:43:10.957]         }, add = TRUE)
[17:43:10.957]     }
[17:43:10.957]     ...future.frame <- base::sys.nframe()
[17:43:10.957]     ...future.conditions <- base::list()
[17:43:10.957]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:10.957]     if (FALSE) {
[17:43:10.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:10.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:10.957]     }
[17:43:10.957]     ...future.result <- base::tryCatch({
[17:43:10.957]         base::withCallingHandlers({
[17:43:10.957]             ...future.value <- base::withVisible(base::local({
[17:43:10.957]                 ...future.makeSendCondition <- local({
[17:43:10.957]                   sendCondition <- NULL
[17:43:10.957]                   function(frame = 1L) {
[17:43:10.957]                     if (is.function(sendCondition)) 
[17:43:10.957]                       return(sendCondition)
[17:43:10.957]                     ns <- getNamespace("parallel")
[17:43:10.957]                     if (exists("sendData", mode = "function", 
[17:43:10.957]                       envir = ns)) {
[17:43:10.957]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:10.957]                         envir = ns)
[17:43:10.957]                       envir <- sys.frame(frame)
[17:43:10.957]                       master <- NULL
[17:43:10.957]                       while (!identical(envir, .GlobalEnv) && 
[17:43:10.957]                         !identical(envir, emptyenv())) {
[17:43:10.957]                         if (exists("master", mode = "list", envir = envir, 
[17:43:10.957]                           inherits = FALSE)) {
[17:43:10.957]                           master <- get("master", mode = "list", 
[17:43:10.957]                             envir = envir, inherits = FALSE)
[17:43:10.957]                           if (inherits(master, c("SOCKnode", 
[17:43:10.957]                             "SOCK0node"))) {
[17:43:10.957]                             sendCondition <<- function(cond) {
[17:43:10.957]                               data <- list(type = "VALUE", value = cond, 
[17:43:10.957]                                 success = TRUE)
[17:43:10.957]                               parallel_sendData(master, data)
[17:43:10.957]                             }
[17:43:10.957]                             return(sendCondition)
[17:43:10.957]                           }
[17:43:10.957]                         }
[17:43:10.957]                         frame <- frame + 1L
[17:43:10.957]                         envir <- sys.frame(frame)
[17:43:10.957]                       }
[17:43:10.957]                     }
[17:43:10.957]                     sendCondition <<- function(cond) NULL
[17:43:10.957]                   }
[17:43:10.957]                 })
[17:43:10.957]                 withCallingHandlers({
[17:43:10.957]                   {
[17:43:10.957]                     b <- 2L
[17:43:10.957]                     plan_b <- future::plan("list")
[17:43:10.957]                     nested_b <- nested_a[-1]
[17:43:10.957]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:10.957]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:43:10.957]                       "sequential"))
[17:43:10.957]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:10.957]                       b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:10.957]                   }
[17:43:10.957]                 }, immediateCondition = function(cond) {
[17:43:10.957]                   sendCondition <- ...future.makeSendCondition()
[17:43:10.957]                   sendCondition(cond)
[17:43:10.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.957]                   {
[17:43:10.957]                     inherits <- base::inherits
[17:43:10.957]                     invokeRestart <- base::invokeRestart
[17:43:10.957]                     is.null <- base::is.null
[17:43:10.957]                     muffled <- FALSE
[17:43:10.957]                     if (inherits(cond, "message")) {
[17:43:10.957]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:10.957]                       if (muffled) 
[17:43:10.957]                         invokeRestart("muffleMessage")
[17:43:10.957]                     }
[17:43:10.957]                     else if (inherits(cond, "warning")) {
[17:43:10.957]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:10.957]                       if (muffled) 
[17:43:10.957]                         invokeRestart("muffleWarning")
[17:43:10.957]                     }
[17:43:10.957]                     else if (inherits(cond, "condition")) {
[17:43:10.957]                       if (!is.null(pattern)) {
[17:43:10.957]                         computeRestarts <- base::computeRestarts
[17:43:10.957]                         grepl <- base::grepl
[17:43:10.957]                         restarts <- computeRestarts(cond)
[17:43:10.957]                         for (restart in restarts) {
[17:43:10.957]                           name <- restart$name
[17:43:10.957]                           if (is.null(name)) 
[17:43:10.957]                             next
[17:43:10.957]                           if (!grepl(pattern, name)) 
[17:43:10.957]                             next
[17:43:10.957]                           invokeRestart(restart)
[17:43:10.957]                           muffled <- TRUE
[17:43:10.957]                           break
[17:43:10.957]                         }
[17:43:10.957]                       }
[17:43:10.957]                     }
[17:43:10.957]                     invisible(muffled)
[17:43:10.957]                   }
[17:43:10.957]                   muffleCondition(cond)
[17:43:10.957]                 })
[17:43:10.957]             }))
[17:43:10.957]             future::FutureResult(value = ...future.value$value, 
[17:43:10.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.957]                   ...future.rng), globalenv = if (FALSE) 
[17:43:10.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:10.957]                     ...future.globalenv.names))
[17:43:10.957]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:10.957]         }, condition = base::local({
[17:43:10.957]             c <- base::c
[17:43:10.957]             inherits <- base::inherits
[17:43:10.957]             invokeRestart <- base::invokeRestart
[17:43:10.957]             length <- base::length
[17:43:10.957]             list <- base::list
[17:43:10.957]             seq.int <- base::seq.int
[17:43:10.957]             signalCondition <- base::signalCondition
[17:43:10.957]             sys.calls <- base::sys.calls
[17:43:10.957]             `[[` <- base::`[[`
[17:43:10.957]             `+` <- base::`+`
[17:43:10.957]             `<<-` <- base::`<<-`
[17:43:10.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:10.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:10.957]                   3L)]
[17:43:10.957]             }
[17:43:10.957]             function(cond) {
[17:43:10.957]                 is_error <- inherits(cond, "error")
[17:43:10.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:10.957]                   NULL)
[17:43:10.957]                 if (is_error) {
[17:43:10.957]                   sessionInformation <- function() {
[17:43:10.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:10.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:10.957]                       search = base::search(), system = base::Sys.info())
[17:43:10.957]                   }
[17:43:10.957]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:10.957]                     cond$call), session = sessionInformation(), 
[17:43:10.957]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:10.957]                   signalCondition(cond)
[17:43:10.957]                 }
[17:43:10.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:10.957]                 "immediateCondition"))) {
[17:43:10.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:10.957]                   ...future.conditions[[length(...future.conditions) + 
[17:43:10.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:10.957]                   if (TRUE && !signal) {
[17:43:10.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.957]                     {
[17:43:10.957]                       inherits <- base::inherits
[17:43:10.957]                       invokeRestart <- base::invokeRestart
[17:43:10.957]                       is.null <- base::is.null
[17:43:10.957]                       muffled <- FALSE
[17:43:10.957]                       if (inherits(cond, "message")) {
[17:43:10.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.957]                         if (muffled) 
[17:43:10.957]                           invokeRestart("muffleMessage")
[17:43:10.957]                       }
[17:43:10.957]                       else if (inherits(cond, "warning")) {
[17:43:10.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.957]                         if (muffled) 
[17:43:10.957]                           invokeRestart("muffleWarning")
[17:43:10.957]                       }
[17:43:10.957]                       else if (inherits(cond, "condition")) {
[17:43:10.957]                         if (!is.null(pattern)) {
[17:43:10.957]                           computeRestarts <- base::computeRestarts
[17:43:10.957]                           grepl <- base::grepl
[17:43:10.957]                           restarts <- computeRestarts(cond)
[17:43:10.957]                           for (restart in restarts) {
[17:43:10.957]                             name <- restart$name
[17:43:10.957]                             if (is.null(name)) 
[17:43:10.957]                               next
[17:43:10.957]                             if (!grepl(pattern, name)) 
[17:43:10.957]                               next
[17:43:10.957]                             invokeRestart(restart)
[17:43:10.957]                             muffled <- TRUE
[17:43:10.957]                             break
[17:43:10.957]                           }
[17:43:10.957]                         }
[17:43:10.957]                       }
[17:43:10.957]                       invisible(muffled)
[17:43:10.957]                     }
[17:43:10.957]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.957]                   }
[17:43:10.957]                 }
[17:43:10.957]                 else {
[17:43:10.957]                   if (TRUE) {
[17:43:10.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:10.957]                     {
[17:43:10.957]                       inherits <- base::inherits
[17:43:10.957]                       invokeRestart <- base::invokeRestart
[17:43:10.957]                       is.null <- base::is.null
[17:43:10.957]                       muffled <- FALSE
[17:43:10.957]                       if (inherits(cond, "message")) {
[17:43:10.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:10.957]                         if (muffled) 
[17:43:10.957]                           invokeRestart("muffleMessage")
[17:43:10.957]                       }
[17:43:10.957]                       else if (inherits(cond, "warning")) {
[17:43:10.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:10.957]                         if (muffled) 
[17:43:10.957]                           invokeRestart("muffleWarning")
[17:43:10.957]                       }
[17:43:10.957]                       else if (inherits(cond, "condition")) {
[17:43:10.957]                         if (!is.null(pattern)) {
[17:43:10.957]                           computeRestarts <- base::computeRestarts
[17:43:10.957]                           grepl <- base::grepl
[17:43:10.957]                           restarts <- computeRestarts(cond)
[17:43:10.957]                           for (restart in restarts) {
[17:43:10.957]                             name <- restart$name
[17:43:10.957]                             if (is.null(name)) 
[17:43:10.957]                               next
[17:43:10.957]                             if (!grepl(pattern, name)) 
[17:43:10.957]                               next
[17:43:10.957]                             invokeRestart(restart)
[17:43:10.957]                             muffled <- TRUE
[17:43:10.957]                             break
[17:43:10.957]                           }
[17:43:10.957]                         }
[17:43:10.957]                       }
[17:43:10.957]                       invisible(muffled)
[17:43:10.957]                     }
[17:43:10.957]                     muffleCondition(cond, pattern = "^muffle")
[17:43:10.957]                   }
[17:43:10.957]                 }
[17:43:10.957]             }
[17:43:10.957]         }))
[17:43:10.957]     }, error = function(ex) {
[17:43:10.957]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:10.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:10.957]                 ...future.rng), started = ...future.startTime, 
[17:43:10.957]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:10.957]             version = "1.8"), class = "FutureResult")
[17:43:10.957]     }, finally = {
[17:43:10.957]         if (!identical(...future.workdir, getwd())) 
[17:43:10.957]             setwd(...future.workdir)
[17:43:10.957]         {
[17:43:10.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:10.957]                 ...future.oldOptions$nwarnings <- NULL
[17:43:10.957]             }
[17:43:10.957]             base::options(...future.oldOptions)
[17:43:10.957]             if (.Platform$OS.type == "windows") {
[17:43:10.957]                 old_names <- names(...future.oldEnvVars)
[17:43:10.957]                 envs <- base::Sys.getenv()
[17:43:10.957]                 names <- names(envs)
[17:43:10.957]                 common <- intersect(names, old_names)
[17:43:10.957]                 added <- setdiff(names, old_names)
[17:43:10.957]                 removed <- setdiff(old_names, names)
[17:43:10.957]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:10.957]                   envs[common]]
[17:43:10.957]                 NAMES <- toupper(changed)
[17:43:10.957]                 args <- list()
[17:43:10.957]                 for (kk in seq_along(NAMES)) {
[17:43:10.957]                   name <- changed[[kk]]
[17:43:10.957]                   NAME <- NAMES[[kk]]
[17:43:10.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.957]                     next
[17:43:10.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.957]                 }
[17:43:10.957]                 NAMES <- toupper(added)
[17:43:10.957]                 for (kk in seq_along(NAMES)) {
[17:43:10.957]                   name <- added[[kk]]
[17:43:10.957]                   NAME <- NAMES[[kk]]
[17:43:10.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.957]                     next
[17:43:10.957]                   args[[name]] <- ""
[17:43:10.957]                 }
[17:43:10.957]                 NAMES <- toupper(removed)
[17:43:10.957]                 for (kk in seq_along(NAMES)) {
[17:43:10.957]                   name <- removed[[kk]]
[17:43:10.957]                   NAME <- NAMES[[kk]]
[17:43:10.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:10.957]                     next
[17:43:10.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:10.957]                 }
[17:43:10.957]                 if (length(args) > 0) 
[17:43:10.957]                   base::do.call(base::Sys.setenv, args = args)
[17:43:10.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:10.957]             }
[17:43:10.957]             else {
[17:43:10.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:10.957]             }
[17:43:10.957]             {
[17:43:10.957]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:10.957]                   0L) {
[17:43:10.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:10.957]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:10.957]                   base::options(opts)
[17:43:10.957]                 }
[17:43:10.957]                 {
[17:43:10.957]                   {
[17:43:10.957]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:10.957]                     NULL
[17:43:10.957]                   }
[17:43:10.957]                   options(future.plan = NULL)
[17:43:10.957]                   if (is.na(NA_character_)) 
[17:43:10.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:10.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:10.957]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:43:10.957]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:10.957]                     envir = parent.frame()) 
[17:43:10.957]                   {
[17:43:10.957]                     if (is.function(workers)) 
[17:43:10.957]                       workers <- workers()
[17:43:10.957]                     workers <- structure(as.integer(workers), 
[17:43:10.957]                       class = class(workers))
[17:43:10.957]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:10.957]                       workers >= 1)
[17:43:10.957]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:10.957]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:10.957]                     }
[17:43:10.957]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:10.957]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:10.957]                       envir = envir)
[17:43:10.957]                     if (!future$lazy) 
[17:43:10.957]                       future <- run(future)
[17:43:10.957]                     invisible(future)
[17:43:10.957]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:10.957]                 }
[17:43:10.957]             }
[17:43:10.957]         }
[17:43:10.957]     })
[17:43:10.957]     if (TRUE) {
[17:43:10.957]         base::sink(type = "output", split = FALSE)
[17:43:10.957]         if (TRUE) {
[17:43:10.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:10.957]         }
[17:43:10.957]         else {
[17:43:10.957]             ...future.result["stdout"] <- base::list(NULL)
[17:43:10.957]         }
[17:43:10.957]         base::close(...future.stdout)
[17:43:10.957]         ...future.stdout <- NULL
[17:43:10.957]     }
[17:43:10.957]     ...future.result$conditions <- ...future.conditions
[17:43:10.957]     ...future.result$finished <- base::Sys.time()
[17:43:10.957]     ...future.result
[17:43:10.957] }
[17:43:11.173]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.029] Exporting 3 global objects (87.82 KiB) to cluster node #1 ...
[17:43:11.173]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.030] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ...
[17:43:11.173]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.030] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ... DONE
[17:43:11.173]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.031] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:43:11.173]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.031] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:43:11.173]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.031] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ...
[17:43:11.174]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.075] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ... DONE
[17:43:11.174]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.075] Exporting 3 global objects (87.82 KiB) to cluster node #1 ... DONE
[17:43:11.174]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.076] MultisessionFuture started
[17:43:11.174]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.077] - Launch lazy future ... done
[17:43:11.174]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.077] run() for ‘MultisessionFuture’ ... done
[17:43:11.174]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.077] result() for ClusterFuture ...
[17:43:11.175]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.078] receiveMessageFromWorker() for ClusterFuture ...
[17:43:11.175]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.078] - Validating connection of MultisessionFuture
[17:43:11.175]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.153] - received message: FutureResult
[17:43:11.175]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.153] - Received FutureResult
[17:43:11.175]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.154] - Erased future from FutureRegistry
[17:43:11.175]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.154] result() for ClusterFuture ...
[17:43:11.176]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.154] - result already collected: FutureResult
[17:43:11.176]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.154] result() for ClusterFuture ... done
[17:43:11.176]  - Condition #94: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.154] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:11.176]  - Condition #95: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.154] result() for ClusterFuture ... done
[17:43:11.176]  - Condition #96: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.155] result() for ClusterFuture ...
[17:43:11.176]  - Condition #97: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.155] - result already collected: FutureResult
[17:43:11.177]  - Condition #98: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.155] result() for ClusterFuture ... done
[17:43:11.177] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:11.184] getGlobalsAndPackages() ...
[17:43:11.184] Searching for globals...
[17:43:11.186] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:11.186] Searching for globals ... DONE
[17:43:11.186] Resolving globals: FALSE
[17:43:11.187] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:11.187] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:11.187] - globals: [1] ‘data’
[17:43:11.187] - packages: [1] ‘future’
[17:43:11.187] getGlobalsAndPackages() ... DONE
[17:43:11.188] run() for ‘Future’ ...
[17:43:11.188] - state: ‘created’
[17:43:11.188] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:11.188] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:11.189] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:11.189]   - Field: ‘label’
[17:43:11.189]   - Field: ‘local’
[17:43:11.189]   - Field: ‘owner’
[17:43:11.189]   - Field: ‘envir’
[17:43:11.189]   - Field: ‘packages’
[17:43:11.189]   - Field: ‘gc’
[17:43:11.189]   - Field: ‘conditions’
[17:43:11.190]   - Field: ‘expr’
[17:43:11.190]   - Field: ‘uuid’
[17:43:11.190]   - Field: ‘seed’
[17:43:11.190]   - Field: ‘version’
[17:43:11.190]   - Field: ‘result’
[17:43:11.190]   - Field: ‘asynchronous’
[17:43:11.190]   - Field: ‘calls’
[17:43:11.190]   - Field: ‘globals’
[17:43:11.190]   - Field: ‘stdout’
[17:43:11.191]   - Field: ‘earlySignal’
[17:43:11.191]   - Field: ‘lazy’
[17:43:11.191]   - Field: ‘state’
[17:43:11.191] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:11.191] - Launch lazy future ...
[17:43:11.191] Packages needed by the future expression (n = 1): ‘future’
[17:43:11.192] Packages needed by future strategies (n = 1): ‘future’
[17:43:11.192] {
[17:43:11.192]     {
[17:43:11.192]         {
[17:43:11.192]             ...future.startTime <- base::Sys.time()
[17:43:11.192]             {
[17:43:11.192]                 {
[17:43:11.192]                   {
[17:43:11.192]                     {
[17:43:11.192]                       base::local({
[17:43:11.192]                         has_future <- base::requireNamespace("future", 
[17:43:11.192]                           quietly = TRUE)
[17:43:11.192]                         if (has_future) {
[17:43:11.192]                           ns <- base::getNamespace("future")
[17:43:11.192]                           version <- ns[[".package"]][["version"]]
[17:43:11.192]                           if (is.null(version)) 
[17:43:11.192]                             version <- utils::packageVersion("future")
[17:43:11.192]                         }
[17:43:11.192]                         else {
[17:43:11.192]                           version <- NULL
[17:43:11.192]                         }
[17:43:11.192]                         if (!has_future || version < "1.8.0") {
[17:43:11.192]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.192]                             "", base::R.version$version.string), 
[17:43:11.192]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:11.192]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:11.192]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.192]                               "release", "version")], collapse = " "), 
[17:43:11.192]                             hostname = base::Sys.info()[["nodename"]])
[17:43:11.192]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.192]                             info)
[17:43:11.192]                           info <- base::paste(info, collapse = "; ")
[17:43:11.192]                           if (!has_future) {
[17:43:11.192]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.192]                               info)
[17:43:11.192]                           }
[17:43:11.192]                           else {
[17:43:11.192]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.192]                               info, version)
[17:43:11.192]                           }
[17:43:11.192]                           base::stop(msg)
[17:43:11.192]                         }
[17:43:11.192]                       })
[17:43:11.192]                     }
[17:43:11.192]                     base::local({
[17:43:11.192]                       for (pkg in "future") {
[17:43:11.192]                         base::loadNamespace(pkg)
[17:43:11.192]                         base::library(pkg, character.only = TRUE)
[17:43:11.192]                       }
[17:43:11.192]                     })
[17:43:11.192]                   }
[17:43:11.192]                   options(future.plan = NULL)
[17:43:11.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.192]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:43:11.192]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.192]                     envir = parent.frame()) 
[17:43:11.192]                   {
[17:43:11.192]                     if (is.function(workers)) 
[17:43:11.192]                       workers <- workers()
[17:43:11.192]                     workers <- structure(as.integer(workers), 
[17:43:11.192]                       class = class(workers))
[17:43:11.192]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:11.192]                       workers >= 1)
[17:43:11.192]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:11.192]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:11.192]                     }
[17:43:11.192]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:11.192]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:11.192]                       envir = envir)
[17:43:11.192]                     if (!future$lazy) 
[17:43:11.192]                       future <- run(future)
[17:43:11.192]                     invisible(future)
[17:43:11.192]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.192]                 }
[17:43:11.192]                 ...future.workdir <- getwd()
[17:43:11.192]             }
[17:43:11.192]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.192]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.192]         }
[17:43:11.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.192]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.192]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.192]             base::names(...future.oldOptions))
[17:43:11.192]     }
[17:43:11.192]     if (FALSE) {
[17:43:11.192]     }
[17:43:11.192]     else {
[17:43:11.192]         if (TRUE) {
[17:43:11.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.192]                 open = "w")
[17:43:11.192]         }
[17:43:11.192]         else {
[17:43:11.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.192]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.192]         }
[17:43:11.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.192]             base::sink(type = "output", split = FALSE)
[17:43:11.192]             base::close(...future.stdout)
[17:43:11.192]         }, add = TRUE)
[17:43:11.192]     }
[17:43:11.192]     ...future.frame <- base::sys.nframe()
[17:43:11.192]     ...future.conditions <- base::list()
[17:43:11.192]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.192]     if (FALSE) {
[17:43:11.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.192]     }
[17:43:11.192]     ...future.result <- base::tryCatch({
[17:43:11.192]         base::withCallingHandlers({
[17:43:11.192]             ...future.value <- base::withVisible(base::local({
[17:43:11.192]                 value(future(subset(data, a == 2)))
[17:43:11.192]             }))
[17:43:11.192]             future::FutureResult(value = ...future.value$value, 
[17:43:11.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.192]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.192]                     ...future.globalenv.names))
[17:43:11.192]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.192]         }, condition = base::local({
[17:43:11.192]             c <- base::c
[17:43:11.192]             inherits <- base::inherits
[17:43:11.192]             invokeRestart <- base::invokeRestart
[17:43:11.192]             length <- base::length
[17:43:11.192]             list <- base::list
[17:43:11.192]             seq.int <- base::seq.int
[17:43:11.192]             signalCondition <- base::signalCondition
[17:43:11.192]             sys.calls <- base::sys.calls
[17:43:11.192]             `[[` <- base::`[[`
[17:43:11.192]             `+` <- base::`+`
[17:43:11.192]             `<<-` <- base::`<<-`
[17:43:11.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.192]                   3L)]
[17:43:11.192]             }
[17:43:11.192]             function(cond) {
[17:43:11.192]                 is_error <- inherits(cond, "error")
[17:43:11.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.192]                   NULL)
[17:43:11.192]                 if (is_error) {
[17:43:11.192]                   sessionInformation <- function() {
[17:43:11.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.192]                       search = base::search(), system = base::Sys.info())
[17:43:11.192]                   }
[17:43:11.192]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.192]                     cond$call), session = sessionInformation(), 
[17:43:11.192]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.192]                   signalCondition(cond)
[17:43:11.192]                 }
[17:43:11.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.192]                 "immediateCondition"))) {
[17:43:11.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.192]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.192]                   if (TRUE && !signal) {
[17:43:11.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.192]                     {
[17:43:11.192]                       inherits <- base::inherits
[17:43:11.192]                       invokeRestart <- base::invokeRestart
[17:43:11.192]                       is.null <- base::is.null
[17:43:11.192]                       muffled <- FALSE
[17:43:11.192]                       if (inherits(cond, "message")) {
[17:43:11.192]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.192]                         if (muffled) 
[17:43:11.192]                           invokeRestart("muffleMessage")
[17:43:11.192]                       }
[17:43:11.192]                       else if (inherits(cond, "warning")) {
[17:43:11.192]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.192]                         if (muffled) 
[17:43:11.192]                           invokeRestart("muffleWarning")
[17:43:11.192]                       }
[17:43:11.192]                       else if (inherits(cond, "condition")) {
[17:43:11.192]                         if (!is.null(pattern)) {
[17:43:11.192]                           computeRestarts <- base::computeRestarts
[17:43:11.192]                           grepl <- base::grepl
[17:43:11.192]                           restarts <- computeRestarts(cond)
[17:43:11.192]                           for (restart in restarts) {
[17:43:11.192]                             name <- restart$name
[17:43:11.192]                             if (is.null(name)) 
[17:43:11.192]                               next
[17:43:11.192]                             if (!grepl(pattern, name)) 
[17:43:11.192]                               next
[17:43:11.192]                             invokeRestart(restart)
[17:43:11.192]                             muffled <- TRUE
[17:43:11.192]                             break
[17:43:11.192]                           }
[17:43:11.192]                         }
[17:43:11.192]                       }
[17:43:11.192]                       invisible(muffled)
[17:43:11.192]                     }
[17:43:11.192]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.192]                   }
[17:43:11.192]                 }
[17:43:11.192]                 else {
[17:43:11.192]                   if (TRUE) {
[17:43:11.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.192]                     {
[17:43:11.192]                       inherits <- base::inherits
[17:43:11.192]                       invokeRestart <- base::invokeRestart
[17:43:11.192]                       is.null <- base::is.null
[17:43:11.192]                       muffled <- FALSE
[17:43:11.192]                       if (inherits(cond, "message")) {
[17:43:11.192]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.192]                         if (muffled) 
[17:43:11.192]                           invokeRestart("muffleMessage")
[17:43:11.192]                       }
[17:43:11.192]                       else if (inherits(cond, "warning")) {
[17:43:11.192]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.192]                         if (muffled) 
[17:43:11.192]                           invokeRestart("muffleWarning")
[17:43:11.192]                       }
[17:43:11.192]                       else if (inherits(cond, "condition")) {
[17:43:11.192]                         if (!is.null(pattern)) {
[17:43:11.192]                           computeRestarts <- base::computeRestarts
[17:43:11.192]                           grepl <- base::grepl
[17:43:11.192]                           restarts <- computeRestarts(cond)
[17:43:11.192]                           for (restart in restarts) {
[17:43:11.192]                             name <- restart$name
[17:43:11.192]                             if (is.null(name)) 
[17:43:11.192]                               next
[17:43:11.192]                             if (!grepl(pattern, name)) 
[17:43:11.192]                               next
[17:43:11.192]                             invokeRestart(restart)
[17:43:11.192]                             muffled <- TRUE
[17:43:11.192]                             break
[17:43:11.192]                           }
[17:43:11.192]                         }
[17:43:11.192]                       }
[17:43:11.192]                       invisible(muffled)
[17:43:11.192]                     }
[17:43:11.192]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.192]                   }
[17:43:11.192]                 }
[17:43:11.192]             }
[17:43:11.192]         }))
[17:43:11.192]     }, error = function(ex) {
[17:43:11.192]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.192]                 ...future.rng), started = ...future.startTime, 
[17:43:11.192]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.192]             version = "1.8"), class = "FutureResult")
[17:43:11.192]     }, finally = {
[17:43:11.192]         if (!identical(...future.workdir, getwd())) 
[17:43:11.192]             setwd(...future.workdir)
[17:43:11.192]         {
[17:43:11.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.192]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.192]             }
[17:43:11.192]             base::options(...future.oldOptions)
[17:43:11.192]             if (.Platform$OS.type == "windows") {
[17:43:11.192]                 old_names <- names(...future.oldEnvVars)
[17:43:11.192]                 envs <- base::Sys.getenv()
[17:43:11.192]                 names <- names(envs)
[17:43:11.192]                 common <- intersect(names, old_names)
[17:43:11.192]                 added <- setdiff(names, old_names)
[17:43:11.192]                 removed <- setdiff(old_names, names)
[17:43:11.192]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.192]                   envs[common]]
[17:43:11.192]                 NAMES <- toupper(changed)
[17:43:11.192]                 args <- list()
[17:43:11.192]                 for (kk in seq_along(NAMES)) {
[17:43:11.192]                   name <- changed[[kk]]
[17:43:11.192]                   NAME <- NAMES[[kk]]
[17:43:11.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.192]                     next
[17:43:11.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.192]                 }
[17:43:11.192]                 NAMES <- toupper(added)
[17:43:11.192]                 for (kk in seq_along(NAMES)) {
[17:43:11.192]                   name <- added[[kk]]
[17:43:11.192]                   NAME <- NAMES[[kk]]
[17:43:11.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.192]                     next
[17:43:11.192]                   args[[name]] <- ""
[17:43:11.192]                 }
[17:43:11.192]                 NAMES <- toupper(removed)
[17:43:11.192]                 for (kk in seq_along(NAMES)) {
[17:43:11.192]                   name <- removed[[kk]]
[17:43:11.192]                   NAME <- NAMES[[kk]]
[17:43:11.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.192]                     next
[17:43:11.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.192]                 }
[17:43:11.192]                 if (length(args) > 0) 
[17:43:11.192]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.192]             }
[17:43:11.192]             else {
[17:43:11.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.192]             }
[17:43:11.192]             {
[17:43:11.192]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.192]                   0L) {
[17:43:11.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.192]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.192]                   base::options(opts)
[17:43:11.192]                 }
[17:43:11.192]                 {
[17:43:11.192]                   {
[17:43:11.192]                     NULL
[17:43:11.192]                     RNGkind("Mersenne-Twister")
[17:43:11.192]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:11.192]                       inherits = FALSE)
[17:43:11.192]                   }
[17:43:11.192]                   options(future.plan = NULL)
[17:43:11.192]                   if (is.na(NA_character_)) 
[17:43:11.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.192]                   future::plan(list(a = function (..., envir = parent.frame()) 
[17:43:11.192]                   {
[17:43:11.192]                     future <- SequentialFuture(..., envir = envir)
[17:43:11.192]                     if (!future$lazy) 
[17:43:11.192]                       future <- run(future)
[17:43:11.192]                     invisible(future)
[17:43:11.192]                   }, b = function (..., workers = availableCores(), 
[17:43:11.192]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.192]                     envir = parent.frame()) 
[17:43:11.192]                   {
[17:43:11.192]                     if (is.function(workers)) 
[17:43:11.192]                       workers <- workers()
[17:43:11.192]                     workers <- structure(as.integer(workers), 
[17:43:11.192]                       class = class(workers))
[17:43:11.192]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:11.192]                       workers >= 1)
[17:43:11.192]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:11.192]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:11.192]                     }
[17:43:11.192]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:11.192]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:11.192]                       envir = envir)
[17:43:11.192]                     if (!future$lazy) 
[17:43:11.192]                       future <- run(future)
[17:43:11.192]                     invisible(future)
[17:43:11.192]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.192]                 }
[17:43:11.192]             }
[17:43:11.192]         }
[17:43:11.192]     })
[17:43:11.192]     if (TRUE) {
[17:43:11.192]         base::sink(type = "output", split = FALSE)
[17:43:11.192]         if (TRUE) {
[17:43:11.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.192]         }
[17:43:11.192]         else {
[17:43:11.192]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.192]         }
[17:43:11.192]         base::close(...future.stdout)
[17:43:11.192]         ...future.stdout <- NULL
[17:43:11.192]     }
[17:43:11.192]     ...future.result$conditions <- ...future.conditions
[17:43:11.192]     ...future.result$finished <- base::Sys.time()
[17:43:11.192]     ...future.result
[17:43:11.192] }
[17:43:11.194] assign_globals() ...
[17:43:11.194] List of 1
[17:43:11.194]  $ data:'data.frame':	3 obs. of  2 variables:
[17:43:11.194]   ..$ a: int [1:3] 1 2 3
[17:43:11.194]   ..$ b: int [1:3] 3 2 1
[17:43:11.194]  - attr(*, "where")=List of 1
[17:43:11.194]   ..$ data:<environment: R_EmptyEnv> 
[17:43:11.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.194]  - attr(*, "resolved")= logi FALSE
[17:43:11.194]  - attr(*, "total_size")= num 128
[17:43:11.194]  - attr(*, "already-done")= logi TRUE
[17:43:11.200] - copied ‘data’ to environment
[17:43:11.200] assign_globals() ... done
[17:43:11.201] plan(): Setting new future strategy stack:
[17:43:11.201] List of future strategies:
[17:43:11.201] 1. multisession:
[17:43:11.201]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.201]    - tweaked: FALSE
[17:43:11.201]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.205] plan(): nbrOfWorkers() = 2
[17:43:11.294] plan(): Setting new future strategy stack:
[17:43:11.294] List of future strategies:
[17:43:11.294] 1. sequential:
[17:43:11.294]    - args: function (..., envir = parent.frame())
[17:43:11.294]    - tweaked: FALSE
[17:43:11.294]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.294] 2. multisession:
[17:43:11.294]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.294]    - tweaked: FALSE
[17:43:11.294]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.294] plan(): nbrOfWorkers() = 1
[17:43:11.294] SequentialFuture started (and completed)
[17:43:11.295] signalConditions() ...
[17:43:11.295]  - include = ‘immediateCondition’
[17:43:11.295]  - exclude = 
[17:43:11.295]  - resignal = FALSE
[17:43:11.295]  - Number of conditions: 63
[17:43:11.295] signalConditions() ... done
[17:43:11.295] - Launch lazy future ... done
[17:43:11.295] run() for ‘SequentialFuture’ ... done
[17:43:11.295] signalConditions() ...
[17:43:11.295]  - include = ‘immediateCondition’
[17:43:11.296]  - exclude = 
[17:43:11.296]  - resignal = FALSE
[17:43:11.296]  - Number of conditions: 63
[17:43:11.296] signalConditions() ... done
[17:43:11.296] Future state: ‘finished’
[17:43:11.296] signalConditions() ...
[17:43:11.296]  - include = ‘condition’
[17:43:11.296]  - exclude = ‘immediateCondition’
[17:43:11.296]  - resignal = TRUE
[17:43:11.296]  - Number of conditions: 63
[17:43:11.297]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.205] getGlobalsAndPackages() ...
[17:43:11.297]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.206] Searching for globals...
[17:43:11.297]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.219] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:11.297]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.219] Searching for globals ... DONE
[17:43:11.297]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.219] Resolving globals: FALSE
[17:43:11.297]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.220] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:11.297]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.220] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:11.298]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.220] - globals: [1] ‘data’
[17:43:11.298]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.220] 
[17:43:11.298]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.220] getGlobalsAndPackages() ... DONE
[17:43:11.298]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.221] run() for ‘Future’ ...
[17:43:11.298]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.221] - state: ‘created’
[17:43:11.298]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.221] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.298]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.235] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:11.298]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:11.299]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.236]   - Field: ‘node’
[17:43:11.299]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.236]   - Field: ‘label’
[17:43:11.299]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.236]   - Field: ‘local’
[17:43:11.299]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.236]   - Field: ‘owner’
[17:43:11.299]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.236]   - Field: ‘envir’
[17:43:11.299]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.236]   - Field: ‘workers’
[17:43:11.299]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.236]   - Field: ‘packages’
[17:43:11.300]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.236]   - Field: ‘gc’
[17:43:11.300]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.237]   - Field: ‘conditions’
[17:43:11.300]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.237]   - Field: ‘persistent’
[17:43:11.300]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.237]   - Field: ‘expr’
[17:43:11.300]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.237]   - Field: ‘uuid’
[17:43:11.300]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.237]   - Field: ‘seed’
[17:43:11.300]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.237]   - Field: ‘version’
[17:43:11.300]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.237]   - Field: ‘result’
[17:43:11.301]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.237]   - Field: ‘asynchronous’
[17:43:11.301]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.237]   - Field: ‘calls’
[17:43:11.301]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.238]   - Field: ‘globals’
[17:43:11.301]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.238]   - Field: ‘stdout’
[17:43:11.301]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.238]   - Field: ‘earlySignal’
[17:43:11.301]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.238]   - Field: ‘lazy’
[17:43:11.301]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.238]   - Field: ‘state’
[17:43:11.302]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.238] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:11.302]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.238] - Launch lazy future ...
[17:43:11.302]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.238] Packages needed by the future expression (n = 0): <none>
[17:43:11.302]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.239] Packages needed by future strategies (n = 0): <none>
[17:43:11.302]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.239] {
[17:43:11.239]     {
[17:43:11.239]         {
[17:43:11.239]             ...future.startTime <- base::Sys.time()
[17:43:11.239]             {
[17:43:11.239]                 {
[17:43:11.239]                   {
[17:43:11.239]                     {
[17:43:11.239]                       base::local({
[17:43:11.239]                         has_future <- base::requireNamespace("future", 
[17:43:11.239]                           quietly = TRUE)
[17:43:11.239]                         if (has_future) {
[17:43:11.239]                           ns <- base::getNamespace("future")
[17:43:11.239]                           version <- ns[[".package"]][["version"]]
[17:43:11.239]                           if (is.null(version)) 
[17:43:11.239]                             version <- utils::packageVersion("future")
[17:43:11.239]                         }
[17:43:11.239]                         else {
[17:43:11.239]                           version <- NULL
[17:43:11.239]                         }
[17:43:11.239]                         if (!has_future || version < "1.8.0") {
[17:43:11.239]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.239]                             "", base::R.version$version.string), 
[17:43:11.239]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:11.239]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:11.239]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.239]                               "release", "version")], collapse = " "), 
[17:43:11.239]                             hostname = base::Sys.info()[["nodename"]])
[17:43:11.239]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.239]                             info)
[17:43:11.239]                           info <- base::paste(info, collapse = "; ")
[17:43:11.239]                           if (!has_future) {
[17:43:11.239]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.239]                               info)
[17:43:11.239]                           }
[17:43:11.239]                           else {
[17:43:11.239]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.239]                               info, version)
[17:43:11.239]                           }
[17:43:11.239]                           base::stop(msg)
[17:43:11.239]                         }
[17:43:11.239]                       })
[17:43:11.239]                     }
[17:43:11.239]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:11.239]                     base::options(mc.cores = 1L)
[17:43:11.239]                   }
[17:43:11.239]                   options(future.plan = NULL)
[17:43:11.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:11.239]                 }
[17:43:11.239]                 ...future.workdir <- getwd()
[17:43:11.239]             }
[17:43:11.239]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.239]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.239]         }
[17:43:11.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.239]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.239]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.239]             base::names(...future.oldOptions))
[17:43:11.239]     }
[17:43:11.239]     if (FALSE) {
[17:43:11.239]     }
[17:43:11.239]     else {
[17:43:11.239]         if (TRUE) {
[17:43:11.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.239]                 open = "w")
[17:43:11.239]         }
[17:43:11.239]         else {
[17:43:11.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.239]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.239]         }
[17:43:11.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.239]             base::sink(type = "output", split = FALSE)
[17:43:11.239]             base::close(...future.stdout)
[17:43:11.239]         }, add = TRUE)
[17:43:11.239]     }
[17:43:11.239]     ...future.frame <- base::sys.nframe()
[17:43:11.239]     ...future.conditions <- base::list()
[17:43:11.239]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.239]     if (FALSE) {
[17:43:11.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.239]     }
[17:43:11.239]     ...future.result <- base::tryCatch({
[17:43:11.239]         base::withCallingHandlers({
[17:43:11.239]             ...future.value <- base::withVisible(base::local({
[17:43:11.239]                 ...future.makeSendCondition <- local({
[17:43:11.239]                   sendCondition <- NULL
[17:43:11.239]                   function(frame = 1L) {
[17:43:11.239]                     if (is.function(sendCondition)) 
[17:43:11.239]                       return(sendCondition)
[17:43:11.239]                     ns <- getNamespace("parallel")
[17:43:11.239]                     if (exists("sendData", mode = "function", 
[17:43:11.239]                       envir = ns)) {
[17:43:11.239]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:11.239]                         envir = ns)
[17:43:11.239]                       envir <- sys.frame(frame)
[17:43:11.239]                       master <- NULL
[17:43:11.239]                       while (!identical(envir, .GlobalEnv) && 
[17:43:11.239]                         !identical(envir, emptyenv())) {
[17:43:11.239]                         if (exists("master", mode = "list", envir = envir, 
[17:43:11.239]                           inherits = FALSE)) {
[17:43:11.239]                           master <- get("master", mode = "list", 
[17:43:11.239]                             envir = envir, inherits = FALSE)
[17:43:11.239]                           if (inherits(master, c("SOCKnode", 
[17:43:11.239]                             "SOCK0node"))) {
[17:43:11.239]                             sendCondition <<- function(cond) {
[17:43:11.239]                               data <- list(type = "VALUE", value = cond, 
[17:43:11.239]                                 success = TRUE)
[17:43:11.239]                               parallel_sendData(master, data)
[17:43:11.239]                             }
[17:43:11.239]                             return(sendCondition)
[17:43:11.239]                           }
[17:43:11.239]                         }
[17:43:11.239]                         frame <- frame + 1L
[17:43:11.239]                         envir <- sys.frame(frame)
[17:43:11.239]                       }
[17:43:11.239]                     }
[17:43:11.239]                     sendCondition <<- function(cond) NULL
[17:43:11.239]                   }
[17:43:11.239]                 })
[17:43:11.239]                 withCallingHandlers({
[17:43:11.239]                   subset(data, a == 2)
[17:43:11.239]                 }, immediateCondition = function(cond) {
[17:43:11.239]                   sendCondition <- ...future.makeSendCondition()
[17:43:11.239]                   sendCondition(cond)
[17:43:11.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.239]                   {
[17:43:11.239]                     inherits <- base::inherits
[17:43:11.239]                     invokeRestart <- base::invokeRestart
[17:43:11.239]                     is.null <- base::is.null
[17:43:11.239]                     muffled <- FALSE
[17:43:11.239]                     if (inherits(cond, "message")) {
[17:43:11.239]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:11.239]                       if (muffled) 
[17:43:11.239]                         invokeRestart("muffleMessage")
[17:43:11.239]                     }
[17:43:11.239]                     else if (inherits(cond, "warning")) {
[17:43:11.239]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:11.239]                       if (muffled) 
[17:43:11.239]                         invokeRestart("muffleWarning")
[17:43:11.239]                     }
[17:43:11.239]                     else if (inherits(cond, "condition")) {
[17:43:11.239]                       if (!is.null(pattern)) {
[17:43:11.239]                         computeRestarts <- base::computeRestarts
[17:43:11.239]                         grepl <- base::grepl
[17:43:11.239]                         restarts <- computeRestarts(cond)
[17:43:11.239]                         for (restart in restarts) {
[17:43:11.239]                           name <- restart$name
[17:43:11.239]                           if (is.null(name)) 
[17:43:11.239]                             next
[17:43:11.239]                           if (!grepl(pattern, name)) 
[17:43:11.239]                             next
[17:43:11.239]                           invokeRestart(restart)
[17:43:11.239]                           muffled <- TRUE
[17:43:11.239]                           break
[17:43:11.239]                         }
[17:43:11.239]                       }
[17:43:11.239]                     }
[17:43:11.239]                     invisible(muffled)
[17:43:11.239]                   }
[17:43:11.239]                   muffleCondition(cond)
[17:43:11.239]                 })
[17:43:11.239]             }))
[17:43:11.239]             future::FutureResult(value = ...future.value$value, 
[17:43:11.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.239]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.239]                     ...future.globalenv.names))
[17:43:11.239]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.239]         }, condition = base::local({
[17:43:11.239]             c <- base::c
[17:43:11.239]             inherits <- base::inherits
[17:43:11.239]             invokeRestart <- base::invokeRestart
[17:43:11.239]             length <- base::length
[17:43:11.239]             list <- base::list
[17:43:11.239]             seq.int <- base::seq.int
[17:43:11.239]             signalCondition <- base::signalCondition
[17:43:11.239]             sys.calls <- base::sys.calls
[17:43:11.239]             `[[` <- base::`[[`
[17:43:11.239]             `+` <- base::`+`
[17:43:11.239]             `<<-` <- base::`<<-`
[17:43:11.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.239]                   3L)]
[17:43:11.239]             }
[17:43:11.239]             function(cond) {
[17:43:11.239]                 is_error <- inherits(cond, "error")
[17:43:11.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.239]                   NULL)
[17:43:11.239]                 if (is_error) {
[17:43:11.239]                   sessionInformation <- function() {
[17:43:11.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.239]                       search = base::search(), system = base::Sys.info())
[17:43:11.239]                   }
[17:43:11.239]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.239]                     cond$call), session = sessionInformation(), 
[17:43:11.239]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.239]                   signalCondition(cond)
[17:43:11.239]                 }
[17:43:11.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.239]                 "immediateCondition"))) {
[17:43:11.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.239]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.239]                   if (TRUE && !signal) {
[17:43:11.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.239]                     {
[17:43:11.239]                       inherits <- base::inherits
[17:43:11.239]                       invokeRestart <- base::invokeRestart
[17:43:11.239]                       is.null <- base::is.null
[17:43:11.239]                       muffled <- FALSE
[17:43:11.239]                       if (inherits(cond, "message")) {
[17:43:11.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.239]                         if (muffled) 
[17:43:11.239]                           invokeRestart("muffleMessage")
[17:43:11.239]                       }
[17:43:11.239]                       else if (inherits(cond, "warning")) {
[17:43:11.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.239]                         if (muffled) 
[17:43:11.239]                           invokeRestart("muffleWarning")
[17:43:11.239]                       }
[17:43:11.239]                       else if (inherits(cond, "condition")) {
[17:43:11.239]                         if (!is.null(pattern)) {
[17:43:11.239]                           computeRestarts <- base::computeRestarts
[17:43:11.239]                           grepl <- base::grepl
[17:43:11.239]                           restarts <- computeRestarts(cond)
[17:43:11.239]                           for (restart in restarts) {
[17:43:11.239]                             name <- restart$name
[17:43:11.239]                             if (is.null(name)) 
[17:43:11.239]                               next
[17:43:11.239]                             if (!grepl(pattern, name)) 
[17:43:11.239]                               next
[17:43:11.239]                             invokeRestart(restart)
[17:43:11.239]                             muffled <- TRUE
[17:43:11.239]                             break
[17:43:11.239]                           }
[17:43:11.239]                         }
[17:43:11.239]                       }
[17:43:11.239]                       invisible(muffled)
[17:43:11.239]                     }
[17:43:11.239]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.239]                   }
[17:43:11.239]                 }
[17:43:11.239]                 else {
[17:43:11.239]                   if (TRUE) {
[17:43:11.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.239]                     {
[17:43:11.239]                       inherits <- base::inherits
[17:43:11.239]                       invokeRestart <- base::invokeRestart
[17:43:11.239]                       is.null <- base::is.null
[17:43:11.239]                       muffled <- FALSE
[17:43:11.239]                       if (inherits(cond, "message")) {
[17:43:11.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.239]                         if (muffled) 
[17:43:11.239]                           invokeRestart("muffleMessage")
[17:43:11.239]                       }
[17:43:11.239]                       else if (inherits(cond, "warning")) {
[17:43:11.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.239]                         if (muffled) 
[17:43:11.239]                           invokeRestart("muffleWarning")
[17:43:11.239]                       }
[17:43:11.239]                       else if (inherits(cond, "condition")) {
[17:43:11.239]                         if (!is.null(pattern)) {
[17:43:11.239]                           computeRestarts <- base::computeRestarts
[17:43:11.239]                           grepl <- base::grepl
[17:43:11.239]                           restarts <- computeRestarts(cond)
[17:43:11.239]                           for (restart in restarts) {
[17:43:11.239]                             name <- restart$name
[17:43:11.239]                             if (is.null(name)) 
[17:43:11.239]                               next
[17:43:11.239]                             if (!grepl(pattern, name)) 
[17:43:11.239]                               next
[17:43:11.239]                             invokeRestart(restart)
[17:43:11.239]                             muffled <- TRUE
[17:43:11.239]                             break
[17:43:11.239]                           }
[17:43:11.239]                         }
[17:43:11.239]                       }
[17:43:11.239]                       invisible(muffled)
[17:43:11.239]                     }
[17:43:11.239]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.239]                   }
[17:43:11.239]                 }
[17:43:11.239]             }
[17:43:11.239]         }))
[17:43:11.239]     }, error = function(ex) {
[17:43:11.239]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.239]                 ...future.rng), started = ...future.startTime, 
[17:43:11.239]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.239]             version = "1.8"), class = "FutureResult")
[17:43:11.239]     }, finally = {
[17:43:11.239]         if (!identical(...future.workdir, getwd())) 
[17:43:11.239]             setwd(...future.workdir)
[17:43:11.239]         {
[17:43:11.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.239]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.239]             }
[17:43:11.239]             base::options(...future.oldOptions)
[17:43:11.239]             if (.Platform$OS.type == "windows") {
[17:43:11.239]                 old_names <- names(...future.oldEnvVars)
[17:43:11.239]                 envs <- base::Sys.getenv()
[17:43:11.239]                 names <- names(envs)
[17:43:11.239]                 common <- intersect(names, old_names)
[17:43:11.239]                 added <- setdiff(names, old_names)
[17:43:11.239]                 removed <- setdiff(old_names, names)
[17:43:11.239]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.239]                   envs[common]]
[17:43:11.239]                 NAMES <- toupper(changed)
[17:43:11.239]                 args <- list()
[17:43:11.239]                 for (kk in seq_along(NAMES)) {
[17:43:11.239]                   name <- changed[[kk]]
[17:43:11.239]                   NAME <- NAMES[[kk]]
[17:43:11.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.239]                     next
[17:43:11.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.239]                 }
[17:43:11.239]                 NAMES <- toupper(added)
[17:43:11.239]                 for (kk in seq_along(NAMES)) {
[17:43:11.239]                   name <- added[[kk]]
[17:43:11.239]                   NAME <- NAMES[[kk]]
[17:43:11.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.239]                     next
[17:43:11.239]                   args[[name]] <- ""
[17:43:11.239]                 }
[17:43:11.239]                 NAMES <- toupper(removed)
[17:43:11.239]                 for (kk in seq_along(NAMES)) {
[17:43:11.239]                   name <- removed[[kk]]
[17:43:11.239]                   NAME <- NAMES[[kk]]
[17:43:11.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.239]                     next
[17:43:11.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.239]                 }
[17:43:11.239]                 if (length(args) > 0) 
[17:43:11.239]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.239]             }
[17:43:11.239]             else {
[17:43:11.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.239]             }
[17:43:11.239]             {
[17:43:11.239]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.239]                   0L) {
[17:43:11.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.239]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.239]                   base::options(opts)
[17:43:11.239]                 }
[17:43:11.239]                 {
[17:43:11.239]                   {
[17:43:11.239]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:11.239]                     NULL
[17:43:11.239]                   }
[17:43:11.239]                   options(future.plan = NULL)
[17:43:11.239]                   if (is.na(NA_character_)) 
[17:43:11.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.239]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:43:11.239]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.239]                     envir = parent.frame()) 
[17:43:11.239]                   {
[17:43:11.239]                     if (is.function(workers)) 
[17:43:11.239]                       workers <- workers()
[17:43:11.239]                     workers <- structure(as.integer(workers), 
[17:43:11.239]                       class = class(workers))
[17:43:11.239]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:11.239]                       workers >= 1)
[17:43:11.239]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:11.239]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:11.239]                     }
[17:43:11.239]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:11.239]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:11.239]                       envir = envir)
[17:43:11.239]                     if (!future$lazy) 
[17:43:11.239]                       future <- run(future)
[17:43:11.239]                     invisible(future)
[17:43:11.239]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.239]                 }
[17:43:11.239]             }
[17:43:11.239]         }
[17:43:11.239]     })
[17:43:11.239]     if (TRUE) {
[17:43:11.239]         base::sink(type = "output", split = FALSE)
[17:43:11.239]         if (TRUE) {
[17:43:11.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.239]         }
[17:43:11.239]         else {
[17:43:11.239]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.239]         }
[17:43:11.239]         base::close(...future.stdout)
[17:43:11.239]         ...future.stdout <- NULL
[17:43:11.239]     }
[17:43:11.239]     ...future.result$conditions <- ...future.conditions
[17:43:11.239]     ...future.result$finished <- base::Sys.time()
[17:43:11.239]     ...future.result
[17:43:11.239] }
[17:43:11.302]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.242] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:43:11.302]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.242] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:43:11.302]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.243] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:43:11.303]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.243] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:43:11.303]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.243] MultisessionFuture started
[17:43:11.303]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.243] - Launch lazy future ... done
[17:43:11.303]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.244] run() for ‘MultisessionFuture’ ... done
[17:43:11.303]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.244] result() for ClusterFuture ...
[17:43:11.303]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.244] receiveMessageFromWorker() for ClusterFuture ...
[17:43:11.303]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.244] - Validating connection of MultisessionFuture
[17:43:11.304]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.292] - received message: FutureResult
[17:43:11.304]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.292] - Received FutureResult
[17:43:11.304]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.292] - Erased future from FutureRegistry
[17:43:11.304]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.292] result() for ClusterFuture ...
[17:43:11.304]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.292] - result already collected: FutureResult
[17:43:11.304]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.293] result() for ClusterFuture ... done
[17:43:11.304]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.293] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:11.304]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.293] result() for ClusterFuture ... done
[17:43:11.305]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.293] result() for ClusterFuture ...
[17:43:11.305]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.293] - result already collected: FutureResult
[17:43:11.305]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.293] result() for ClusterFuture ... done
[17:43:11.305] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[17:43:11.305] plan(): Setting new future strategy stack:
[17:43:11.305] List of future strategies:
[17:43:11.305] 1. multicore:
[17:43:11.305]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.305]    - tweaked: FALSE
[17:43:11.305]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.305] 2. sequential:
[17:43:11.305]    - args: function (..., envir = parent.frame())
[17:43:11.305]    - tweaked: FALSE
[17:43:11.305]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.311] plan(): nbrOfWorkers() = 2
[17:43:11.311] getGlobalsAndPackages() ...
[17:43:11.311] Searching for globals...
[17:43:11.339] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:43:11.339] Searching for globals ... DONE
[17:43:11.339] Resolving globals: FALSE
[17:43:11.340] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[17:43:11.340] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:43:11.341] - globals: [2] ‘nested’, ‘strategy2’
[17:43:11.341] - packages: [1] ‘future’
[17:43:11.341] getGlobalsAndPackages() ... DONE
[17:43:11.341] run() for ‘Future’ ...
[17:43:11.341] - state: ‘created’
[17:43:11.341] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.345] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:11.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:11.345]   - Field: ‘label’
[17:43:11.345]   - Field: ‘local’
[17:43:11.345]   - Field: ‘owner’
[17:43:11.345]   - Field: ‘envir’
[17:43:11.345]   - Field: ‘workers’
[17:43:11.345]   - Field: ‘packages’
[17:43:11.346]   - Field: ‘gc’
[17:43:11.346]   - Field: ‘job’
[17:43:11.346]   - Field: ‘conditions’
[17:43:11.346]   - Field: ‘expr’
[17:43:11.346]   - Field: ‘uuid’
[17:43:11.346]   - Field: ‘seed’
[17:43:11.346]   - Field: ‘version’
[17:43:11.346]   - Field: ‘result’
[17:43:11.346]   - Field: ‘asynchronous’
[17:43:11.346]   - Field: ‘calls’
[17:43:11.346]   - Field: ‘globals’
[17:43:11.347]   - Field: ‘stdout’
[17:43:11.347]   - Field: ‘earlySignal’
[17:43:11.347]   - Field: ‘lazy’
[17:43:11.347]   - Field: ‘state’
[17:43:11.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:11.347] - Launch lazy future ...
[17:43:11.347] Packages needed by the future expression (n = 1): ‘future’
[17:43:11.347] Packages needed by future strategies (n = 1): ‘future’
[17:43:11.348] {
[17:43:11.348]     {
[17:43:11.348]         {
[17:43:11.348]             ...future.startTime <- base::Sys.time()
[17:43:11.348]             {
[17:43:11.348]                 {
[17:43:11.348]                   {
[17:43:11.348]                     {
[17:43:11.348]                       {
[17:43:11.348]                         base::local({
[17:43:11.348]                           has_future <- base::requireNamespace("future", 
[17:43:11.348]                             quietly = TRUE)
[17:43:11.348]                           if (has_future) {
[17:43:11.348]                             ns <- base::getNamespace("future")
[17:43:11.348]                             version <- ns[[".package"]][["version"]]
[17:43:11.348]                             if (is.null(version)) 
[17:43:11.348]                               version <- utils::packageVersion("future")
[17:43:11.348]                           }
[17:43:11.348]                           else {
[17:43:11.348]                             version <- NULL
[17:43:11.348]                           }
[17:43:11.348]                           if (!has_future || version < "1.8.0") {
[17:43:11.348]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.348]                               "", base::R.version$version.string), 
[17:43:11.348]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:11.348]                                 base::R.version$platform, 8 * 
[17:43:11.348]                                   base::.Machine$sizeof.pointer), 
[17:43:11.348]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.348]                                 "release", "version")], collapse = " "), 
[17:43:11.348]                               hostname = base::Sys.info()[["nodename"]])
[17:43:11.348]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.348]                               info)
[17:43:11.348]                             info <- base::paste(info, collapse = "; ")
[17:43:11.348]                             if (!has_future) {
[17:43:11.348]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.348]                                 info)
[17:43:11.348]                             }
[17:43:11.348]                             else {
[17:43:11.348]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.348]                                 info, version)
[17:43:11.348]                             }
[17:43:11.348]                             base::stop(msg)
[17:43:11.348]                           }
[17:43:11.348]                         })
[17:43:11.348]                       }
[17:43:11.348]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:11.348]                       base::options(mc.cores = 1L)
[17:43:11.348]                     }
[17:43:11.348]                     base::local({
[17:43:11.348]                       for (pkg in "future") {
[17:43:11.348]                         base::loadNamespace(pkg)
[17:43:11.348]                         base::library(pkg, character.only = TRUE)
[17:43:11.348]                       }
[17:43:11.348]                     })
[17:43:11.348]                   }
[17:43:11.348]                   options(future.plan = NULL)
[17:43:11.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.348]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:43:11.348]                   {
[17:43:11.348]                     future <- SequentialFuture(..., envir = envir)
[17:43:11.348]                     if (!future$lazy) 
[17:43:11.348]                       future <- run(future)
[17:43:11.348]                     invisible(future)
[17:43:11.348]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.348]                 }
[17:43:11.348]                 ...future.workdir <- getwd()
[17:43:11.348]             }
[17:43:11.348]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.348]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.348]         }
[17:43:11.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.348]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.348]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.348]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.348]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.348]             base::names(...future.oldOptions))
[17:43:11.348]     }
[17:43:11.348]     if (FALSE) {
[17:43:11.348]     }
[17:43:11.348]     else {
[17:43:11.348]         if (TRUE) {
[17:43:11.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.348]                 open = "w")
[17:43:11.348]         }
[17:43:11.348]         else {
[17:43:11.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.348]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.348]         }
[17:43:11.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.348]             base::sink(type = "output", split = FALSE)
[17:43:11.348]             base::close(...future.stdout)
[17:43:11.348]         }, add = TRUE)
[17:43:11.348]     }
[17:43:11.348]     ...future.frame <- base::sys.nframe()
[17:43:11.348]     ...future.conditions <- base::list()
[17:43:11.348]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.348]     if (FALSE) {
[17:43:11.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.348]     }
[17:43:11.348]     ...future.result <- base::tryCatch({
[17:43:11.348]         base::withCallingHandlers({
[17:43:11.348]             ...future.value <- base::withVisible(base::local({
[17:43:11.348]                 withCallingHandlers({
[17:43:11.348]                   {
[17:43:11.348]                     a <- 1L
[17:43:11.348]                     plan_a <- unclass(future::plan("list"))
[17:43:11.348]                     nested_a <- nested[-1]
[17:43:11.348]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:43:11.348]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:43:11.348]                       strategy2))
[17:43:11.348]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:43:11.348]                       "init") <- NULL
[17:43:11.348]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:43:11.348]                       "init") <- NULL
[17:43:11.348]                     stopifnot(all.equal(plan_a, nested_a))
[17:43:11.348]                     y %<-% {
[17:43:11.348]                       b <- 2L
[17:43:11.348]                       plan_b <- future::plan("list")
[17:43:11.348]                       nested_b <- nested_a[-1]
[17:43:11.348]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:11.348]                         1L, inherits(plan_b[[1]], "future"), 
[17:43:11.348]                         inherits(future::plan("next"), "sequential"))
[17:43:11.348]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:11.348]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:11.348]                     }
[17:43:11.348]                     y
[17:43:11.348]                   }
[17:43:11.348]                 }, immediateCondition = function(cond) {
[17:43:11.348]                   save_rds <- function (object, pathname, ...) 
[17:43:11.348]                   {
[17:43:11.348]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:11.348]                     if (file_test("-f", pathname_tmp)) {
[17:43:11.348]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.348]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:11.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.348]                         fi_tmp[["mtime"]])
[17:43:11.348]                     }
[17:43:11.348]                     tryCatch({
[17:43:11.348]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:11.348]                     }, error = function(ex) {
[17:43:11.348]                       msg <- conditionMessage(ex)
[17:43:11.348]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.348]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:11.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.348]                         fi_tmp[["mtime"]], msg)
[17:43:11.348]                       ex$message <- msg
[17:43:11.348]                       stop(ex)
[17:43:11.348]                     })
[17:43:11.348]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:11.348]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:11.348]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:11.348]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.348]                       fi <- file.info(pathname)
[17:43:11.348]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:11.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.348]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:11.348]                         fi[["size"]], fi[["mtime"]])
[17:43:11.348]                       stop(msg)
[17:43:11.348]                     }
[17:43:11.348]                     invisible(pathname)
[17:43:11.348]                   }
[17:43:11.348]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:11.348]                     rootPath = tempdir()) 
[17:43:11.348]                   {
[17:43:11.348]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:11.348]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:11.348]                       tmpdir = path, fileext = ".rds")
[17:43:11.348]                     save_rds(obj, file)
[17:43:11.348]                   }
[17:43:11.348]                   saveImmediateCondition(cond, path = "/tmp/RtmpzPUCYD/.future/immediateConditions")
[17:43:11.348]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.348]                   {
[17:43:11.348]                     inherits <- base::inherits
[17:43:11.348]                     invokeRestart <- base::invokeRestart
[17:43:11.348]                     is.null <- base::is.null
[17:43:11.348]                     muffled <- FALSE
[17:43:11.348]                     if (inherits(cond, "message")) {
[17:43:11.348]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:11.348]                       if (muffled) 
[17:43:11.348]                         invokeRestart("muffleMessage")
[17:43:11.348]                     }
[17:43:11.348]                     else if (inherits(cond, "warning")) {
[17:43:11.348]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:11.348]                       if (muffled) 
[17:43:11.348]                         invokeRestart("muffleWarning")
[17:43:11.348]                     }
[17:43:11.348]                     else if (inherits(cond, "condition")) {
[17:43:11.348]                       if (!is.null(pattern)) {
[17:43:11.348]                         computeRestarts <- base::computeRestarts
[17:43:11.348]                         grepl <- base::grepl
[17:43:11.348]                         restarts <- computeRestarts(cond)
[17:43:11.348]                         for (restart in restarts) {
[17:43:11.348]                           name <- restart$name
[17:43:11.348]                           if (is.null(name)) 
[17:43:11.348]                             next
[17:43:11.348]                           if (!grepl(pattern, name)) 
[17:43:11.348]                             next
[17:43:11.348]                           invokeRestart(restart)
[17:43:11.348]                           muffled <- TRUE
[17:43:11.348]                           break
[17:43:11.348]                         }
[17:43:11.348]                       }
[17:43:11.348]                     }
[17:43:11.348]                     invisible(muffled)
[17:43:11.348]                   }
[17:43:11.348]                   muffleCondition(cond)
[17:43:11.348]                 })
[17:43:11.348]             }))
[17:43:11.348]             future::FutureResult(value = ...future.value$value, 
[17:43:11.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.348]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.348]                     ...future.globalenv.names))
[17:43:11.348]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.348]         }, condition = base::local({
[17:43:11.348]             c <- base::c
[17:43:11.348]             inherits <- base::inherits
[17:43:11.348]             invokeRestart <- base::invokeRestart
[17:43:11.348]             length <- base::length
[17:43:11.348]             list <- base::list
[17:43:11.348]             seq.int <- base::seq.int
[17:43:11.348]             signalCondition <- base::signalCondition
[17:43:11.348]             sys.calls <- base::sys.calls
[17:43:11.348]             `[[` <- base::`[[`
[17:43:11.348]             `+` <- base::`+`
[17:43:11.348]             `<<-` <- base::`<<-`
[17:43:11.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.348]                   3L)]
[17:43:11.348]             }
[17:43:11.348]             function(cond) {
[17:43:11.348]                 is_error <- inherits(cond, "error")
[17:43:11.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.348]                   NULL)
[17:43:11.348]                 if (is_error) {
[17:43:11.348]                   sessionInformation <- function() {
[17:43:11.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.348]                       search = base::search(), system = base::Sys.info())
[17:43:11.348]                   }
[17:43:11.348]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.348]                     cond$call), session = sessionInformation(), 
[17:43:11.348]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.348]                   signalCondition(cond)
[17:43:11.348]                 }
[17:43:11.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.348]                 "immediateCondition"))) {
[17:43:11.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.348]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.348]                   if (TRUE && !signal) {
[17:43:11.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.348]                     {
[17:43:11.348]                       inherits <- base::inherits
[17:43:11.348]                       invokeRestart <- base::invokeRestart
[17:43:11.348]                       is.null <- base::is.null
[17:43:11.348]                       muffled <- FALSE
[17:43:11.348]                       if (inherits(cond, "message")) {
[17:43:11.348]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.348]                         if (muffled) 
[17:43:11.348]                           invokeRestart("muffleMessage")
[17:43:11.348]                       }
[17:43:11.348]                       else if (inherits(cond, "warning")) {
[17:43:11.348]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.348]                         if (muffled) 
[17:43:11.348]                           invokeRestart("muffleWarning")
[17:43:11.348]                       }
[17:43:11.348]                       else if (inherits(cond, "condition")) {
[17:43:11.348]                         if (!is.null(pattern)) {
[17:43:11.348]                           computeRestarts <- base::computeRestarts
[17:43:11.348]                           grepl <- base::grepl
[17:43:11.348]                           restarts <- computeRestarts(cond)
[17:43:11.348]                           for (restart in restarts) {
[17:43:11.348]                             name <- restart$name
[17:43:11.348]                             if (is.null(name)) 
[17:43:11.348]                               next
[17:43:11.348]                             if (!grepl(pattern, name)) 
[17:43:11.348]                               next
[17:43:11.348]                             invokeRestart(restart)
[17:43:11.348]                             muffled <- TRUE
[17:43:11.348]                             break
[17:43:11.348]                           }
[17:43:11.348]                         }
[17:43:11.348]                       }
[17:43:11.348]                       invisible(muffled)
[17:43:11.348]                     }
[17:43:11.348]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.348]                   }
[17:43:11.348]                 }
[17:43:11.348]                 else {
[17:43:11.348]                   if (TRUE) {
[17:43:11.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.348]                     {
[17:43:11.348]                       inherits <- base::inherits
[17:43:11.348]                       invokeRestart <- base::invokeRestart
[17:43:11.348]                       is.null <- base::is.null
[17:43:11.348]                       muffled <- FALSE
[17:43:11.348]                       if (inherits(cond, "message")) {
[17:43:11.348]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.348]                         if (muffled) 
[17:43:11.348]                           invokeRestart("muffleMessage")
[17:43:11.348]                       }
[17:43:11.348]                       else if (inherits(cond, "warning")) {
[17:43:11.348]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.348]                         if (muffled) 
[17:43:11.348]                           invokeRestart("muffleWarning")
[17:43:11.348]                       }
[17:43:11.348]                       else if (inherits(cond, "condition")) {
[17:43:11.348]                         if (!is.null(pattern)) {
[17:43:11.348]                           computeRestarts <- base::computeRestarts
[17:43:11.348]                           grepl <- base::grepl
[17:43:11.348]                           restarts <- computeRestarts(cond)
[17:43:11.348]                           for (restart in restarts) {
[17:43:11.348]                             name <- restart$name
[17:43:11.348]                             if (is.null(name)) 
[17:43:11.348]                               next
[17:43:11.348]                             if (!grepl(pattern, name)) 
[17:43:11.348]                               next
[17:43:11.348]                             invokeRestart(restart)
[17:43:11.348]                             muffled <- TRUE
[17:43:11.348]                             break
[17:43:11.348]                           }
[17:43:11.348]                         }
[17:43:11.348]                       }
[17:43:11.348]                       invisible(muffled)
[17:43:11.348]                     }
[17:43:11.348]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.348]                   }
[17:43:11.348]                 }
[17:43:11.348]             }
[17:43:11.348]         }))
[17:43:11.348]     }, error = function(ex) {
[17:43:11.348]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.348]                 ...future.rng), started = ...future.startTime, 
[17:43:11.348]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.348]             version = "1.8"), class = "FutureResult")
[17:43:11.348]     }, finally = {
[17:43:11.348]         if (!identical(...future.workdir, getwd())) 
[17:43:11.348]             setwd(...future.workdir)
[17:43:11.348]         {
[17:43:11.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.348]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.348]             }
[17:43:11.348]             base::options(...future.oldOptions)
[17:43:11.348]             if (.Platform$OS.type == "windows") {
[17:43:11.348]                 old_names <- names(...future.oldEnvVars)
[17:43:11.348]                 envs <- base::Sys.getenv()
[17:43:11.348]                 names <- names(envs)
[17:43:11.348]                 common <- intersect(names, old_names)
[17:43:11.348]                 added <- setdiff(names, old_names)
[17:43:11.348]                 removed <- setdiff(old_names, names)
[17:43:11.348]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.348]                   envs[common]]
[17:43:11.348]                 NAMES <- toupper(changed)
[17:43:11.348]                 args <- list()
[17:43:11.348]                 for (kk in seq_along(NAMES)) {
[17:43:11.348]                   name <- changed[[kk]]
[17:43:11.348]                   NAME <- NAMES[[kk]]
[17:43:11.348]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.348]                     next
[17:43:11.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.348]                 }
[17:43:11.348]                 NAMES <- toupper(added)
[17:43:11.348]                 for (kk in seq_along(NAMES)) {
[17:43:11.348]                   name <- added[[kk]]
[17:43:11.348]                   NAME <- NAMES[[kk]]
[17:43:11.348]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.348]                     next
[17:43:11.348]                   args[[name]] <- ""
[17:43:11.348]                 }
[17:43:11.348]                 NAMES <- toupper(removed)
[17:43:11.348]                 for (kk in seq_along(NAMES)) {
[17:43:11.348]                   name <- removed[[kk]]
[17:43:11.348]                   NAME <- NAMES[[kk]]
[17:43:11.348]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.348]                     next
[17:43:11.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.348]                 }
[17:43:11.348]                 if (length(args) > 0) 
[17:43:11.348]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.348]             }
[17:43:11.348]             else {
[17:43:11.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.348]             }
[17:43:11.348]             {
[17:43:11.348]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.348]                   0L) {
[17:43:11.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.348]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.348]                   base::options(opts)
[17:43:11.348]                 }
[17:43:11.348]                 {
[17:43:11.348]                   {
[17:43:11.348]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:11.348]                     NULL
[17:43:11.348]                   }
[17:43:11.348]                   options(future.plan = NULL)
[17:43:11.348]                   if (is.na(NA_character_)) 
[17:43:11.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.348]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.348]                     envir = parent.frame()) 
[17:43:11.348]                   {
[17:43:11.348]                     default_workers <- missing(workers)
[17:43:11.348]                     if (is.function(workers)) 
[17:43:11.348]                       workers <- workers()
[17:43:11.348]                     workers <- structure(as.integer(workers), 
[17:43:11.348]                       class = class(workers))
[17:43:11.348]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.348]                       1L)
[17:43:11.348]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.348]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.348]                       if (default_workers) 
[17:43:11.348]                         supportsMulticore(warn = TRUE)
[17:43:11.348]                       return(sequential(..., envir = envir))
[17:43:11.348]                     }
[17:43:11.348]                     oopts <- options(mc.cores = workers)
[17:43:11.348]                     on.exit(options(oopts))
[17:43:11.348]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.348]                       envir = envir)
[17:43:11.348]                     if (!future$lazy) 
[17:43:11.348]                       future <- run(future)
[17:43:11.348]                     invisible(future)
[17:43:11.348]                   }, b = function (..., envir = parent.frame()) 
[17:43:11.348]                   {
[17:43:11.348]                     future <- SequentialFuture(..., envir = envir)
[17:43:11.348]                     if (!future$lazy) 
[17:43:11.348]                       future <- run(future)
[17:43:11.348]                     invisible(future)
[17:43:11.348]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.348]                 }
[17:43:11.348]             }
[17:43:11.348]         }
[17:43:11.348]     })
[17:43:11.348]     if (TRUE) {
[17:43:11.348]         base::sink(type = "output", split = FALSE)
[17:43:11.348]         if (TRUE) {
[17:43:11.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.348]         }
[17:43:11.348]         else {
[17:43:11.348]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.348]         }
[17:43:11.348]         base::close(...future.stdout)
[17:43:11.348]         ...future.stdout <- NULL
[17:43:11.348]     }
[17:43:11.348]     ...future.result$conditions <- ...future.conditions
[17:43:11.348]     ...future.result$finished <- base::Sys.time()
[17:43:11.348]     ...future.result
[17:43:11.348] }
[17:43:11.350] assign_globals() ...
[17:43:11.351] List of 2
[17:43:11.351]  $ nested   :List of 2
[17:43:11.351]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:43:11.351]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:43:11.351]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.351]   ..$ b:function (..., envir = parent.frame())  
[17:43:11.351]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:43:11.351]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.351]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:11.351]  $ strategy2: chr "sequential"
[17:43:11.351]  - attr(*, "where")=List of 2
[17:43:11.351]   ..$ nested   :<environment: R_EmptyEnv> 
[17:43:11.351]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:43:11.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.351]  - attr(*, "resolved")= logi FALSE
[17:43:11.351]  - attr(*, "total_size")= num 59224
[17:43:11.351]  - attr(*, "already-done")= logi TRUE
[17:43:11.356] - copied ‘nested’ to environment
[17:43:11.356] - copied ‘strategy2’ to environment
[17:43:11.356] assign_globals() ... done
[17:43:11.356] requestCore(): workers = 2
[17:43:11.359] MulticoreFuture started
[17:43:11.359] - Launch lazy future ... done
[17:43:11.359] run() for ‘MulticoreFuture’ ... done
[17:43:11.360] plan(): Setting new future strategy stack:
[17:43:11.360] List of future strategies:
[17:43:11.360] 1. sequential:
[17:43:11.360]    - args: function (..., envir = parent.frame())
[17:43:11.360]    - tweaked: FALSE
[17:43:11.360]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.361] plan(): nbrOfWorkers() = 1
[17:43:11.399] plan(): Setting new future strategy stack:
[17:43:11.399] List of future strategies:
[17:43:11.399] 1. multicore:
[17:43:11.399]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.399]    - tweaked: FALSE
[17:43:11.399]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.399] 2. sequential:
[17:43:11.399]    - args: function (..., envir = parent.frame())
[17:43:11.399]    - tweaked: FALSE
[17:43:11.399]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.404] plan(): nbrOfWorkers() = 2
[17:43:11.405] signalConditions() ...
[17:43:11.405]  - include = ‘immediateCondition’
[17:43:11.405]  - exclude = 
[17:43:11.405]  - resignal = FALSE
[17:43:11.406]  - Number of conditions: 54
[17:43:11.406] signalConditions() ... done
[17:43:11.406] signalConditions() ...
[17:43:11.406]  - include = ‘immediateCondition’
[17:43:11.406]  - exclude = 
[17:43:11.406]  - resignal = FALSE
[17:43:11.406]  - Number of conditions: 54
[17:43:11.407] signalConditions() ... done
[17:43:11.407] Future state: ‘finished’
[17:43:11.407] signalConditions() ...
[17:43:11.407]  - include = ‘condition’
[17:43:11.407]  - exclude = ‘immediateCondition’
[17:43:11.407]  - resignal = TRUE
[17:43:11.408]  - Number of conditions: 54
[17:43:11.408]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.363] getGlobalsAndPackages() ...
[17:43:11.408]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.363] Searching for globals...
[17:43:11.408]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.373] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:43:11.408]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.374] Searching for globals ... DONE
[17:43:11.408]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.374] Resolving globals: FALSE
[17:43:11.409]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.376] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[17:43:11.409]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.377] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:43:11.409]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.377] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:43:11.409]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.377] 
[17:43:11.409]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.377] getGlobalsAndPackages() ... DONE
[17:43:11.410]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.378] run() for ‘Future’ ...
[17:43:11.410]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.378] - state: ‘created’
[17:43:11.410]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.379] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:11.410]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.379] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:11.410]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.379] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:11.411]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.380]   - Field: ‘label’
[17:43:11.411]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.380]   - Field: ‘local’
[17:43:11.411]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.380]   - Field: ‘owner’
[17:43:11.411]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.380]   - Field: ‘envir’
[17:43:11.411]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.380]   - Field: ‘packages’
[17:43:11.412]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.381]   - Field: ‘gc’
[17:43:11.412]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.381]   - Field: ‘conditions’
[17:43:11.412]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.381]   - Field: ‘expr’
[17:43:11.412]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.381]   - Field: ‘uuid’
[17:43:11.412]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.381]   - Field: ‘seed’
[17:43:11.412]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.381]   - Field: ‘version’
[17:43:11.413]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.382]   - Field: ‘result’
[17:43:11.413]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.382]   - Field: ‘asynchronous’
[17:43:11.413]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.382]   - Field: ‘calls’
[17:43:11.413]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.382]   - Field: ‘globals’
[17:43:11.413]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.382]   - Field: ‘stdout’
[17:43:11.413]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.382]   - Field: ‘earlySignal’
[17:43:11.414]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.382]   - Field: ‘lazy’
[17:43:11.414]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.383]   - Field: ‘state’
[17:43:11.414]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.383] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:11.414]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.383] - Launch lazy future ...
[17:43:11.414]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.383] Packages needed by the future expression (n = 0): <none>
[17:43:11.414]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.384] Packages needed by future strategies (n = 0): <none>
[17:43:11.415]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.384] {
[17:43:11.384]     {
[17:43:11.384]         {
[17:43:11.384]             ...future.startTime <- base::Sys.time()
[17:43:11.384]             {
[17:43:11.384]                 {
[17:43:11.384]                   {
[17:43:11.384]                     base::local({
[17:43:11.384]                       has_future <- base::requireNamespace("future", 
[17:43:11.384]                         quietly = TRUE)
[17:43:11.384]                       if (has_future) {
[17:43:11.384]                         ns <- base::getNamespace("future")
[17:43:11.384]                         version <- ns[[".package"]][["version"]]
[17:43:11.384]                         if (is.null(version)) 
[17:43:11.384]                           version <- utils::packageVersion("future")
[17:43:11.384]                       }
[17:43:11.384]                       else {
[17:43:11.384]                         version <- NULL
[17:43:11.384]                       }
[17:43:11.384]                       if (!has_future || version < "1.8.0") {
[17:43:11.384]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.384]                           "", base::R.version$version.string), 
[17:43:11.384]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:11.384]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:11.384]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.384]                             "release", "version")], collapse = " "), 
[17:43:11.384]                           hostname = base::Sys.info()[["nodename"]])
[17:43:11.384]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.384]                           info)
[17:43:11.384]                         info <- base::paste(info, collapse = "; ")
[17:43:11.384]                         if (!has_future) {
[17:43:11.384]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.384]                             info)
[17:43:11.384]                         }
[17:43:11.384]                         else {
[17:43:11.384]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.384]                             info, version)
[17:43:11.384]                         }
[17:43:11.384]                         base::stop(msg)
[17:43:11.384]                       }
[17:43:11.384]                     })
[17:43:11.384]                   }
[17:43:11.384]                   options(future.plan = NULL)
[17:43:11.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:11.384]                 }
[17:43:11.384]                 ...future.workdir <- getwd()
[17:43:11.384]             }
[17:43:11.384]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.384]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.384]         }
[17:43:11.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.384]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.384]             base::names(...future.oldOptions))
[17:43:11.384]     }
[17:43:11.384]     if (FALSE) {
[17:43:11.384]     }
[17:43:11.384]     else {
[17:43:11.384]         if (TRUE) {
[17:43:11.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.384]                 open = "w")
[17:43:11.384]         }
[17:43:11.384]         else {
[17:43:11.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.384]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.384]         }
[17:43:11.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.384]             base::sink(type = "output", split = FALSE)
[17:43:11.384]             base::close(...future.stdout)
[17:43:11.384]         }, add = TRUE)
[17:43:11.384]     }
[17:43:11.384]     ...future.frame <- base::sys.nframe()
[17:43:11.384]     ...future.conditions <- base::list()
[17:43:11.384]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.384]     if (FALSE) {
[17:43:11.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.384]     }
[17:43:11.384]     ...future.result <- base::tryCatch({
[17:43:11.384]         base::withCallingHandlers({
[17:43:11.384]             ...future.value <- base::withVisible(base::local({
[17:43:11.384]                 b <- 2L
[17:43:11.384]                 plan_b <- future::plan("list")
[17:43:11.384]                 nested_b <- nested_a[-1]
[17:43:11.384]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:11.384]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:43:11.384]                   "sequential"))
[17:43:11.384]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:11.384]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:11.384]             }))
[17:43:11.384]             future::FutureResult(value = ...future.value$value, 
[17:43:11.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.384]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.384]                     ...future.globalenv.names))
[17:43:11.384]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.384]         }, condition = base::local({
[17:43:11.384]             c <- base::c
[17:43:11.384]             inherits <- base::inherits
[17:43:11.384]             invokeRestart <- base::invokeRestart
[17:43:11.384]             length <- base::length
[17:43:11.384]             list <- base::list
[17:43:11.384]             seq.int <- base::seq.int
[17:43:11.384]             signalCondition <- base::signalCondition
[17:43:11.384]             sys.calls <- base::sys.calls
[17:43:11.384]             `[[` <- base::`[[`
[17:43:11.384]             `+` <- base::`+`
[17:43:11.384]             `<<-` <- base::`<<-`
[17:43:11.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.384]                   3L)]
[17:43:11.384]             }
[17:43:11.384]             function(cond) {
[17:43:11.384]                 is_error <- inherits(cond, "error")
[17:43:11.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.384]                   NULL)
[17:43:11.384]                 if (is_error) {
[17:43:11.384]                   sessionInformation <- function() {
[17:43:11.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.384]                       search = base::search(), system = base::Sys.info())
[17:43:11.384]                   }
[17:43:11.384]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.384]                     cond$call), session = sessionInformation(), 
[17:43:11.384]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.384]                   signalCondition(cond)
[17:43:11.384]                 }
[17:43:11.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.384]                 "immediateCondition"))) {
[17:43:11.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.384]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.384]                   if (TRUE && !signal) {
[17:43:11.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.384]                     {
[17:43:11.384]                       inherits <- base::inherits
[17:43:11.384]                       invokeRestart <- base::invokeRestart
[17:43:11.384]                       is.null <- base::is.null
[17:43:11.384]                       muffled <- FALSE
[17:43:11.384]                       if (inherits(cond, "message")) {
[17:43:11.384]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.384]                         if (muffled) 
[17:43:11.384]                           invokeRestart("muffleMessage")
[17:43:11.384]                       }
[17:43:11.384]                       else if (inherits(cond, "warning")) {
[17:43:11.384]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.384]                         if (muffled) 
[17:43:11.384]                           invokeRestart("muffleWarning")
[17:43:11.384]                       }
[17:43:11.384]                       else if (inherits(cond, "condition")) {
[17:43:11.384]                         if (!is.null(pattern)) {
[17:43:11.384]                           computeRestarts <- base::computeRestarts
[17:43:11.384]                           grepl <- base::grepl
[17:43:11.384]                           restarts <- computeRestarts(cond)
[17:43:11.384]                           for (restart in restarts) {
[17:43:11.384]                             name <- restart$name
[17:43:11.384]                             if (is.null(name)) 
[17:43:11.384]                               next
[17:43:11.384]                             if (!grepl(pattern, name)) 
[17:43:11.384]                               next
[17:43:11.384]                             invokeRestart(restart)
[17:43:11.384]                             muffled <- TRUE
[17:43:11.384]                             break
[17:43:11.384]                           }
[17:43:11.384]                         }
[17:43:11.384]                       }
[17:43:11.384]                       invisible(muffled)
[17:43:11.384]                     }
[17:43:11.384]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.384]                   }
[17:43:11.384]                 }
[17:43:11.384]                 else {
[17:43:11.384]                   if (TRUE) {
[17:43:11.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.384]                     {
[17:43:11.384]                       inherits <- base::inherits
[17:43:11.384]                       invokeRestart <- base::invokeRestart
[17:43:11.384]                       is.null <- base::is.null
[17:43:11.384]                       muffled <- FALSE
[17:43:11.384]                       if (inherits(cond, "message")) {
[17:43:11.384]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.384]                         if (muffled) 
[17:43:11.384]                           invokeRestart("muffleMessage")
[17:43:11.384]                       }
[17:43:11.384]                       else if (inherits(cond, "warning")) {
[17:43:11.384]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.384]                         if (muffled) 
[17:43:11.384]                           invokeRestart("muffleWarning")
[17:43:11.384]                       }
[17:43:11.384]                       else if (inherits(cond, "condition")) {
[17:43:11.384]                         if (!is.null(pattern)) {
[17:43:11.384]                           computeRestarts <- base::computeRestarts
[17:43:11.384]                           grepl <- base::grepl
[17:43:11.384]                           restarts <- computeRestarts(cond)
[17:43:11.384]                           for (restart in restarts) {
[17:43:11.384]                             name <- restart$name
[17:43:11.384]                             if (is.null(name)) 
[17:43:11.384]                               next
[17:43:11.384]                             if (!grepl(pattern, name)) 
[17:43:11.384]                               next
[17:43:11.384]                             invokeRestart(restart)
[17:43:11.384]                             muffled <- TRUE
[17:43:11.384]                             break
[17:43:11.384]                           }
[17:43:11.384]                         }
[17:43:11.384]                       }
[17:43:11.384]                       invisible(muffled)
[17:43:11.384]                     }
[17:43:11.384]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.384]                   }
[17:43:11.384]                 }
[17:43:11.384]             }
[17:43:11.384]         }))
[17:43:11.384]     }, error = function(ex) {
[17:43:11.384]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.384]                 ...future.rng), started = ...future.startTime, 
[17:43:11.384]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.384]             version = "1.8"), class = "FutureResult")
[17:43:11.384]     }, finally = {
[17:43:11.384]         if (!identical(...future.workdir, getwd())) 
[17:43:11.384]             setwd(...future.workdir)
[17:43:11.384]         {
[17:43:11.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.384]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.384]             }
[17:43:11.384]             base::options(...future.oldOptions)
[17:43:11.384]             if (.Platform$OS.type == "windows") {
[17:43:11.384]                 old_names <- names(...future.oldEnvVars)
[17:43:11.384]                 envs <- base::Sys.getenv()
[17:43:11.384]                 names <- names(envs)
[17:43:11.384]                 common <- intersect(names, old_names)
[17:43:11.384]                 added <- setdiff(names, old_names)
[17:43:11.384]                 removed <- setdiff(old_names, names)
[17:43:11.384]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.384]                   envs[common]]
[17:43:11.384]                 NAMES <- toupper(changed)
[17:43:11.384]                 args <- list()
[17:43:11.384]                 for (kk in seq_along(NAMES)) {
[17:43:11.384]                   name <- changed[[kk]]
[17:43:11.384]                   NAME <- NAMES[[kk]]
[17:43:11.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.384]                     next
[17:43:11.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.384]                 }
[17:43:11.384]                 NAMES <- toupper(added)
[17:43:11.384]                 for (kk in seq_along(NAMES)) {
[17:43:11.384]                   name <- added[[kk]]
[17:43:11.384]                   NAME <- NAMES[[kk]]
[17:43:11.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.384]                     next
[17:43:11.384]                   args[[name]] <- ""
[17:43:11.384]                 }
[17:43:11.384]                 NAMES <- toupper(removed)
[17:43:11.384]                 for (kk in seq_along(NAMES)) {
[17:43:11.384]                   name <- removed[[kk]]
[17:43:11.384]                   NAME <- NAMES[[kk]]
[17:43:11.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.384]                     next
[17:43:11.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.384]                 }
[17:43:11.384]                 if (length(args) > 0) 
[17:43:11.384]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.384]             }
[17:43:11.384]             else {
[17:43:11.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.384]             }
[17:43:11.384]             {
[17:43:11.384]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.384]                   0L) {
[17:43:11.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.384]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.384]                   base::options(opts)
[17:43:11.384]                 }
[17:43:11.384]                 {
[17:43:11.384]                   {
[17:43:11.384]                     NULL
[17:43:11.384]                     RNGkind("Mersenne-Twister")
[17:43:11.384]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:11.384]                       inherits = FALSE)
[17:43:11.384]                   }
[17:43:11.384]                   options(future.plan = NULL)
[17:43:11.384]                   if (is.na(NA_character_)) 
[17:43:11.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.384]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:43:11.384]                   {
[17:43:11.384]                     future <- SequentialFuture(..., envir = envir)
[17:43:11.384]                     if (!future$lazy) 
[17:43:11.384]                       future <- run(future)
[17:43:11.384]                     invisible(future)
[17:43:11.384]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.384]                 }
[17:43:11.384]             }
[17:43:11.384]         }
[17:43:11.384]     })
[17:43:11.384]     if (TRUE) {
[17:43:11.384]         base::sink(type = "output", split = FALSE)
[17:43:11.384]         if (TRUE) {
[17:43:11.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.384]         }
[17:43:11.384]         else {
[17:43:11.384]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.384]         }
[17:43:11.384]         base::close(...future.stdout)
[17:43:11.384]         ...future.stdout <- NULL
[17:43:11.384]     }
[17:43:11.384]     ...future.result$conditions <- ...future.conditions
[17:43:11.384]     ...future.result$finished <- base::Sys.time()
[17:43:11.384]     ...future.result
[17:43:11.384] }
[17:43:11.415]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.387] assign_globals() ...
[17:43:11.416]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.387] List of 3
[17:43:11.387]  $ nested_a:List of 1
[17:43:11.387]   ..$ b:function (..., envir = parent.frame())  
[17:43:11.387]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:43:11.387]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.387]  $ a       : int 1
[17:43:11.387]  $ plan_a  :List of 1
[17:43:11.387]   ..$ b:function (..., envir = parent.frame())  
[17:43:11.387]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:43:11.387]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.387]  - attr(*, "where")=List of 3
[17:43:11.387]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:43:11.387]   ..$ a       :<environment: R_EmptyEnv> 
[17:43:11.387]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:43:11.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.387]  - attr(*, "resolved")= logi FALSE
[17:43:11.387]  - attr(*, "total_size")= num 23080
[17:43:11.387]  - attr(*, "already-done")= logi TRUE
[17:43:11.416]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.394] - copied ‘nested_a’ to environment
[17:43:11.416]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.395] - copied ‘a’ to environment
[17:43:11.416]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.395] - copied ‘plan_a’ to environment
[17:43:11.416]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.395] assign_globals() ... done
[17:43:11.417]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.395] plan(): Setting new future strategy stack:
[17:43:11.417]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.395] List of future strategies:
[17:43:11.395] 1. sequential:
[17:43:11.395]    - args: function (..., envir = parent.frame())
[17:43:11.395]    - tweaked: FALSE
[17:43:11.395]    - call: NULL
[17:43:11.417]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.396] plan(): nbrOfWorkers() = 1
[17:43:11.417]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.397] plan(): Setting new future strategy stack:
[17:43:11.417]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.397] List of future strategies:
[17:43:11.397] 1. sequential:
[17:43:11.397]    - args: function (..., envir = parent.frame())
[17:43:11.397]    - tweaked: FALSE
[17:43:11.397]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.418]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.398] plan(): nbrOfWorkers() = 1
[17:43:11.418]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.398] SequentialFuture started (and completed)
[17:43:11.418]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.398] - Launch lazy future ... done
[17:43:11.418]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.398] run() for ‘SequentialFuture’ ... done
[17:43:11.418] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:11.424] getGlobalsAndPackages() ...
[17:43:11.425] Searching for globals...
[17:43:11.426] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:11.426] Searching for globals ... DONE
[17:43:11.427] Resolving globals: FALSE
[17:43:11.427] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:11.428] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:11.428] - globals: [1] ‘data’
[17:43:11.428] - packages: [1] ‘future’
[17:43:11.428] getGlobalsAndPackages() ... DONE
[17:43:11.429] run() for ‘Future’ ...
[17:43:11.429] - state: ‘created’
[17:43:11.429] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.434] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:11.434] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:11.434]   - Field: ‘label’
[17:43:11.434]   - Field: ‘local’
[17:43:11.434]   - Field: ‘owner’
[17:43:11.434]   - Field: ‘envir’
[17:43:11.435]   - Field: ‘workers’
[17:43:11.435]   - Field: ‘packages’
[17:43:11.435]   - Field: ‘gc’
[17:43:11.435]   - Field: ‘job’
[17:43:11.435]   - Field: ‘conditions’
[17:43:11.435]   - Field: ‘expr’
[17:43:11.435]   - Field: ‘uuid’
[17:43:11.435]   - Field: ‘seed’
[17:43:11.435]   - Field: ‘version’
[17:43:11.436]   - Field: ‘result’
[17:43:11.436]   - Field: ‘asynchronous’
[17:43:11.436]   - Field: ‘calls’
[17:43:11.436]   - Field: ‘globals’
[17:43:11.436]   - Field: ‘stdout’
[17:43:11.436]   - Field: ‘earlySignal’
[17:43:11.436]   - Field: ‘lazy’
[17:43:11.436]   - Field: ‘state’
[17:43:11.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:11.437] - Launch lazy future ...
[17:43:11.437] Packages needed by the future expression (n = 1): ‘future’
[17:43:11.437] Packages needed by future strategies (n = 1): ‘future’
[17:43:11.438] {
[17:43:11.438]     {
[17:43:11.438]         {
[17:43:11.438]             ...future.startTime <- base::Sys.time()
[17:43:11.438]             {
[17:43:11.438]                 {
[17:43:11.438]                   {
[17:43:11.438]                     {
[17:43:11.438]                       {
[17:43:11.438]                         base::local({
[17:43:11.438]                           has_future <- base::requireNamespace("future", 
[17:43:11.438]                             quietly = TRUE)
[17:43:11.438]                           if (has_future) {
[17:43:11.438]                             ns <- base::getNamespace("future")
[17:43:11.438]                             version <- ns[[".package"]][["version"]]
[17:43:11.438]                             if (is.null(version)) 
[17:43:11.438]                               version <- utils::packageVersion("future")
[17:43:11.438]                           }
[17:43:11.438]                           else {
[17:43:11.438]                             version <- NULL
[17:43:11.438]                           }
[17:43:11.438]                           if (!has_future || version < "1.8.0") {
[17:43:11.438]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.438]                               "", base::R.version$version.string), 
[17:43:11.438]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:11.438]                                 base::R.version$platform, 8 * 
[17:43:11.438]                                   base::.Machine$sizeof.pointer), 
[17:43:11.438]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.438]                                 "release", "version")], collapse = " "), 
[17:43:11.438]                               hostname = base::Sys.info()[["nodename"]])
[17:43:11.438]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.438]                               info)
[17:43:11.438]                             info <- base::paste(info, collapse = "; ")
[17:43:11.438]                             if (!has_future) {
[17:43:11.438]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.438]                                 info)
[17:43:11.438]                             }
[17:43:11.438]                             else {
[17:43:11.438]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.438]                                 info, version)
[17:43:11.438]                             }
[17:43:11.438]                             base::stop(msg)
[17:43:11.438]                           }
[17:43:11.438]                         })
[17:43:11.438]                       }
[17:43:11.438]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:11.438]                       base::options(mc.cores = 1L)
[17:43:11.438]                     }
[17:43:11.438]                     base::local({
[17:43:11.438]                       for (pkg in "future") {
[17:43:11.438]                         base::loadNamespace(pkg)
[17:43:11.438]                         base::library(pkg, character.only = TRUE)
[17:43:11.438]                       }
[17:43:11.438]                     })
[17:43:11.438]                   }
[17:43:11.438]                   options(future.plan = NULL)
[17:43:11.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.438]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:43:11.438]                   {
[17:43:11.438]                     future <- SequentialFuture(..., envir = envir)
[17:43:11.438]                     if (!future$lazy) 
[17:43:11.438]                       future <- run(future)
[17:43:11.438]                     invisible(future)
[17:43:11.438]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.438]                 }
[17:43:11.438]                 ...future.workdir <- getwd()
[17:43:11.438]             }
[17:43:11.438]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.438]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.438]         }
[17:43:11.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.438]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.438]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.438]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.438]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.438]             base::names(...future.oldOptions))
[17:43:11.438]     }
[17:43:11.438]     if (FALSE) {
[17:43:11.438]     }
[17:43:11.438]     else {
[17:43:11.438]         if (TRUE) {
[17:43:11.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.438]                 open = "w")
[17:43:11.438]         }
[17:43:11.438]         else {
[17:43:11.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.438]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.438]         }
[17:43:11.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.438]             base::sink(type = "output", split = FALSE)
[17:43:11.438]             base::close(...future.stdout)
[17:43:11.438]         }, add = TRUE)
[17:43:11.438]     }
[17:43:11.438]     ...future.frame <- base::sys.nframe()
[17:43:11.438]     ...future.conditions <- base::list()
[17:43:11.438]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.438]     if (FALSE) {
[17:43:11.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.438]     }
[17:43:11.438]     ...future.result <- base::tryCatch({
[17:43:11.438]         base::withCallingHandlers({
[17:43:11.438]             ...future.value <- base::withVisible(base::local({
[17:43:11.438]                 withCallingHandlers({
[17:43:11.438]                   {
[17:43:11.438]                     value(future(subset(data, a == 2)))
[17:43:11.438]                   }
[17:43:11.438]                 }, immediateCondition = function(cond) {
[17:43:11.438]                   save_rds <- function (object, pathname, ...) 
[17:43:11.438]                   {
[17:43:11.438]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:11.438]                     if (file_test("-f", pathname_tmp)) {
[17:43:11.438]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.438]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:11.438]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.438]                         fi_tmp[["mtime"]])
[17:43:11.438]                     }
[17:43:11.438]                     tryCatch({
[17:43:11.438]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:11.438]                     }, error = function(ex) {
[17:43:11.438]                       msg <- conditionMessage(ex)
[17:43:11.438]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.438]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:11.438]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.438]                         fi_tmp[["mtime"]], msg)
[17:43:11.438]                       ex$message <- msg
[17:43:11.438]                       stop(ex)
[17:43:11.438]                     })
[17:43:11.438]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:11.438]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:11.438]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:11.438]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.438]                       fi <- file.info(pathname)
[17:43:11.438]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:11.438]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.438]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:11.438]                         fi[["size"]], fi[["mtime"]])
[17:43:11.438]                       stop(msg)
[17:43:11.438]                     }
[17:43:11.438]                     invisible(pathname)
[17:43:11.438]                   }
[17:43:11.438]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:11.438]                     rootPath = tempdir()) 
[17:43:11.438]                   {
[17:43:11.438]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:11.438]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:11.438]                       tmpdir = path, fileext = ".rds")
[17:43:11.438]                     save_rds(obj, file)
[17:43:11.438]                   }
[17:43:11.438]                   saveImmediateCondition(cond, path = "/tmp/RtmpzPUCYD/.future/immediateConditions")
[17:43:11.438]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.438]                   {
[17:43:11.438]                     inherits <- base::inherits
[17:43:11.438]                     invokeRestart <- base::invokeRestart
[17:43:11.438]                     is.null <- base::is.null
[17:43:11.438]                     muffled <- FALSE
[17:43:11.438]                     if (inherits(cond, "message")) {
[17:43:11.438]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:11.438]                       if (muffled) 
[17:43:11.438]                         invokeRestart("muffleMessage")
[17:43:11.438]                     }
[17:43:11.438]                     else if (inherits(cond, "warning")) {
[17:43:11.438]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:11.438]                       if (muffled) 
[17:43:11.438]                         invokeRestart("muffleWarning")
[17:43:11.438]                     }
[17:43:11.438]                     else if (inherits(cond, "condition")) {
[17:43:11.438]                       if (!is.null(pattern)) {
[17:43:11.438]                         computeRestarts <- base::computeRestarts
[17:43:11.438]                         grepl <- base::grepl
[17:43:11.438]                         restarts <- computeRestarts(cond)
[17:43:11.438]                         for (restart in restarts) {
[17:43:11.438]                           name <- restart$name
[17:43:11.438]                           if (is.null(name)) 
[17:43:11.438]                             next
[17:43:11.438]                           if (!grepl(pattern, name)) 
[17:43:11.438]                             next
[17:43:11.438]                           invokeRestart(restart)
[17:43:11.438]                           muffled <- TRUE
[17:43:11.438]                           break
[17:43:11.438]                         }
[17:43:11.438]                       }
[17:43:11.438]                     }
[17:43:11.438]                     invisible(muffled)
[17:43:11.438]                   }
[17:43:11.438]                   muffleCondition(cond)
[17:43:11.438]                 })
[17:43:11.438]             }))
[17:43:11.438]             future::FutureResult(value = ...future.value$value, 
[17:43:11.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.438]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.438]                     ...future.globalenv.names))
[17:43:11.438]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.438]         }, condition = base::local({
[17:43:11.438]             c <- base::c
[17:43:11.438]             inherits <- base::inherits
[17:43:11.438]             invokeRestart <- base::invokeRestart
[17:43:11.438]             length <- base::length
[17:43:11.438]             list <- base::list
[17:43:11.438]             seq.int <- base::seq.int
[17:43:11.438]             signalCondition <- base::signalCondition
[17:43:11.438]             sys.calls <- base::sys.calls
[17:43:11.438]             `[[` <- base::`[[`
[17:43:11.438]             `+` <- base::`+`
[17:43:11.438]             `<<-` <- base::`<<-`
[17:43:11.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.438]                   3L)]
[17:43:11.438]             }
[17:43:11.438]             function(cond) {
[17:43:11.438]                 is_error <- inherits(cond, "error")
[17:43:11.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.438]                   NULL)
[17:43:11.438]                 if (is_error) {
[17:43:11.438]                   sessionInformation <- function() {
[17:43:11.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.438]                       search = base::search(), system = base::Sys.info())
[17:43:11.438]                   }
[17:43:11.438]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.438]                     cond$call), session = sessionInformation(), 
[17:43:11.438]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.438]                   signalCondition(cond)
[17:43:11.438]                 }
[17:43:11.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.438]                 "immediateCondition"))) {
[17:43:11.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.438]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.438]                   if (TRUE && !signal) {
[17:43:11.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.438]                     {
[17:43:11.438]                       inherits <- base::inherits
[17:43:11.438]                       invokeRestart <- base::invokeRestart
[17:43:11.438]                       is.null <- base::is.null
[17:43:11.438]                       muffled <- FALSE
[17:43:11.438]                       if (inherits(cond, "message")) {
[17:43:11.438]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.438]                         if (muffled) 
[17:43:11.438]                           invokeRestart("muffleMessage")
[17:43:11.438]                       }
[17:43:11.438]                       else if (inherits(cond, "warning")) {
[17:43:11.438]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.438]                         if (muffled) 
[17:43:11.438]                           invokeRestart("muffleWarning")
[17:43:11.438]                       }
[17:43:11.438]                       else if (inherits(cond, "condition")) {
[17:43:11.438]                         if (!is.null(pattern)) {
[17:43:11.438]                           computeRestarts <- base::computeRestarts
[17:43:11.438]                           grepl <- base::grepl
[17:43:11.438]                           restarts <- computeRestarts(cond)
[17:43:11.438]                           for (restart in restarts) {
[17:43:11.438]                             name <- restart$name
[17:43:11.438]                             if (is.null(name)) 
[17:43:11.438]                               next
[17:43:11.438]                             if (!grepl(pattern, name)) 
[17:43:11.438]                               next
[17:43:11.438]                             invokeRestart(restart)
[17:43:11.438]                             muffled <- TRUE
[17:43:11.438]                             break
[17:43:11.438]                           }
[17:43:11.438]                         }
[17:43:11.438]                       }
[17:43:11.438]                       invisible(muffled)
[17:43:11.438]                     }
[17:43:11.438]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.438]                   }
[17:43:11.438]                 }
[17:43:11.438]                 else {
[17:43:11.438]                   if (TRUE) {
[17:43:11.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.438]                     {
[17:43:11.438]                       inherits <- base::inherits
[17:43:11.438]                       invokeRestart <- base::invokeRestart
[17:43:11.438]                       is.null <- base::is.null
[17:43:11.438]                       muffled <- FALSE
[17:43:11.438]                       if (inherits(cond, "message")) {
[17:43:11.438]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.438]                         if (muffled) 
[17:43:11.438]                           invokeRestart("muffleMessage")
[17:43:11.438]                       }
[17:43:11.438]                       else if (inherits(cond, "warning")) {
[17:43:11.438]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.438]                         if (muffled) 
[17:43:11.438]                           invokeRestart("muffleWarning")
[17:43:11.438]                       }
[17:43:11.438]                       else if (inherits(cond, "condition")) {
[17:43:11.438]                         if (!is.null(pattern)) {
[17:43:11.438]                           computeRestarts <- base::computeRestarts
[17:43:11.438]                           grepl <- base::grepl
[17:43:11.438]                           restarts <- computeRestarts(cond)
[17:43:11.438]                           for (restart in restarts) {
[17:43:11.438]                             name <- restart$name
[17:43:11.438]                             if (is.null(name)) 
[17:43:11.438]                               next
[17:43:11.438]                             if (!grepl(pattern, name)) 
[17:43:11.438]                               next
[17:43:11.438]                             invokeRestart(restart)
[17:43:11.438]                             muffled <- TRUE
[17:43:11.438]                             break
[17:43:11.438]                           }
[17:43:11.438]                         }
[17:43:11.438]                       }
[17:43:11.438]                       invisible(muffled)
[17:43:11.438]                     }
[17:43:11.438]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.438]                   }
[17:43:11.438]                 }
[17:43:11.438]             }
[17:43:11.438]         }))
[17:43:11.438]     }, error = function(ex) {
[17:43:11.438]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.438]                 ...future.rng), started = ...future.startTime, 
[17:43:11.438]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.438]             version = "1.8"), class = "FutureResult")
[17:43:11.438]     }, finally = {
[17:43:11.438]         if (!identical(...future.workdir, getwd())) 
[17:43:11.438]             setwd(...future.workdir)
[17:43:11.438]         {
[17:43:11.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.438]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.438]             }
[17:43:11.438]             base::options(...future.oldOptions)
[17:43:11.438]             if (.Platform$OS.type == "windows") {
[17:43:11.438]                 old_names <- names(...future.oldEnvVars)
[17:43:11.438]                 envs <- base::Sys.getenv()
[17:43:11.438]                 names <- names(envs)
[17:43:11.438]                 common <- intersect(names, old_names)
[17:43:11.438]                 added <- setdiff(names, old_names)
[17:43:11.438]                 removed <- setdiff(old_names, names)
[17:43:11.438]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.438]                   envs[common]]
[17:43:11.438]                 NAMES <- toupper(changed)
[17:43:11.438]                 args <- list()
[17:43:11.438]                 for (kk in seq_along(NAMES)) {
[17:43:11.438]                   name <- changed[[kk]]
[17:43:11.438]                   NAME <- NAMES[[kk]]
[17:43:11.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.438]                     next
[17:43:11.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.438]                 }
[17:43:11.438]                 NAMES <- toupper(added)
[17:43:11.438]                 for (kk in seq_along(NAMES)) {
[17:43:11.438]                   name <- added[[kk]]
[17:43:11.438]                   NAME <- NAMES[[kk]]
[17:43:11.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.438]                     next
[17:43:11.438]                   args[[name]] <- ""
[17:43:11.438]                 }
[17:43:11.438]                 NAMES <- toupper(removed)
[17:43:11.438]                 for (kk in seq_along(NAMES)) {
[17:43:11.438]                   name <- removed[[kk]]
[17:43:11.438]                   NAME <- NAMES[[kk]]
[17:43:11.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.438]                     next
[17:43:11.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.438]                 }
[17:43:11.438]                 if (length(args) > 0) 
[17:43:11.438]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.438]             }
[17:43:11.438]             else {
[17:43:11.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.438]             }
[17:43:11.438]             {
[17:43:11.438]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.438]                   0L) {
[17:43:11.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.438]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.438]                   base::options(opts)
[17:43:11.438]                 }
[17:43:11.438]                 {
[17:43:11.438]                   {
[17:43:11.438]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:11.438]                     NULL
[17:43:11.438]                   }
[17:43:11.438]                   options(future.plan = NULL)
[17:43:11.438]                   if (is.na(NA_character_)) 
[17:43:11.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.438]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.438]                     envir = parent.frame()) 
[17:43:11.438]                   {
[17:43:11.438]                     default_workers <- missing(workers)
[17:43:11.438]                     if (is.function(workers)) 
[17:43:11.438]                       workers <- workers()
[17:43:11.438]                     workers <- structure(as.integer(workers), 
[17:43:11.438]                       class = class(workers))
[17:43:11.438]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.438]                       1L)
[17:43:11.438]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.438]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.438]                       if (default_workers) 
[17:43:11.438]                         supportsMulticore(warn = TRUE)
[17:43:11.438]                       return(sequential(..., envir = envir))
[17:43:11.438]                     }
[17:43:11.438]                     oopts <- options(mc.cores = workers)
[17:43:11.438]                     on.exit(options(oopts))
[17:43:11.438]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.438]                       envir = envir)
[17:43:11.438]                     if (!future$lazy) 
[17:43:11.438]                       future <- run(future)
[17:43:11.438]                     invisible(future)
[17:43:11.438]                   }, b = function (..., envir = parent.frame()) 
[17:43:11.438]                   {
[17:43:11.438]                     future <- SequentialFuture(..., envir = envir)
[17:43:11.438]                     if (!future$lazy) 
[17:43:11.438]                       future <- run(future)
[17:43:11.438]                     invisible(future)
[17:43:11.438]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.438]                 }
[17:43:11.438]             }
[17:43:11.438]         }
[17:43:11.438]     })
[17:43:11.438]     if (TRUE) {
[17:43:11.438]         base::sink(type = "output", split = FALSE)
[17:43:11.438]         if (TRUE) {
[17:43:11.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.438]         }
[17:43:11.438]         else {
[17:43:11.438]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.438]         }
[17:43:11.438]         base::close(...future.stdout)
[17:43:11.438]         ...future.stdout <- NULL
[17:43:11.438]     }
[17:43:11.438]     ...future.result$conditions <- ...future.conditions
[17:43:11.438]     ...future.result$finished <- base::Sys.time()
[17:43:11.438]     ...future.result
[17:43:11.438] }
[17:43:11.441] assign_globals() ...
[17:43:11.441] List of 1
[17:43:11.441]  $ data:'data.frame':	3 obs. of  2 variables:
[17:43:11.441]   ..$ a: int [1:3] 1 2 3
[17:43:11.441]   ..$ b: int [1:3] 3 2 1
[17:43:11.441]  - attr(*, "where")=List of 1
[17:43:11.441]   ..$ data:<environment: R_EmptyEnv> 
[17:43:11.441]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.441]  - attr(*, "resolved")= logi FALSE
[17:43:11.441]  - attr(*, "total_size")= num 128
[17:43:11.441]  - attr(*, "already-done")= logi TRUE
[17:43:11.445] - copied ‘data’ to environment
[17:43:11.445] assign_globals() ... done
[17:43:11.445] requestCore(): workers = 2
[17:43:11.448] MulticoreFuture started
[17:43:11.448] - Launch lazy future ... done
[17:43:11.448] run() for ‘MulticoreFuture’ ... done
[17:43:11.449] plan(): Setting new future strategy stack:
[17:43:11.449] List of future strategies:
[17:43:11.449] 1. sequential:
[17:43:11.449]    - args: function (..., envir = parent.frame())
[17:43:11.449]    - tweaked: FALSE
[17:43:11.449]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.450] plan(): nbrOfWorkers() = 1
[17:43:11.474] plan(): Setting new future strategy stack:
[17:43:11.474] List of future strategies:
[17:43:11.474] 1. multicore:
[17:43:11.474]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.474]    - tweaked: FALSE
[17:43:11.474]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.474] 2. sequential:
[17:43:11.474]    - args: function (..., envir = parent.frame())
[17:43:11.474]    - tweaked: FALSE
[17:43:11.474]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.479] plan(): nbrOfWorkers() = 2
[17:43:11.480] signalConditions() ...
[17:43:11.481]  - include = ‘immediateCondition’
[17:43:11.481]  - exclude = 
[17:43:11.481]  - resignal = FALSE
[17:43:11.481]  - Number of conditions: 52
[17:43:11.481] signalConditions() ... done
[17:43:11.481] signalConditions() ...
[17:43:11.481]  - include = ‘immediateCondition’
[17:43:11.481]  - exclude = 
[17:43:11.482]  - resignal = FALSE
[17:43:11.482]  - Number of conditions: 52
[17:43:11.482] signalConditions() ... done
[17:43:11.482] Future state: ‘finished’
[17:43:11.482] signalConditions() ...
[17:43:11.482]  - include = ‘condition’
[17:43:11.482]  - exclude = ‘immediateCondition’
[17:43:11.482]  - resignal = TRUE
[17:43:11.483]  - Number of conditions: 52
[17:43:11.483]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.451] getGlobalsAndPackages() ...
[17:43:11.483]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.452] Searching for globals...
[17:43:11.483]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.453] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:11.483]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.454] Searching for globals ... DONE
[17:43:11.483]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.454] Resolving globals: FALSE
[17:43:11.484]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.455] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:11.484]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.456] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:11.484]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.456] - globals: [1] ‘data’
[17:43:11.484]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.456] 
[17:43:11.484]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.456] getGlobalsAndPackages() ... DONE
[17:43:11.484]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.457] run() for ‘Future’ ...
[17:43:11.485]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.457] - state: ‘created’
[17:43:11.485]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.457] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:11.485]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.458] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:11.485]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.458] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:11.485]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.458]   - Field: ‘label’
[17:43:11.485]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.458]   - Field: ‘local’
[17:43:11.486]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.458]   - Field: ‘owner’
[17:43:11.486]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.459]   - Field: ‘envir’
[17:43:11.486]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.459]   - Field: ‘packages’
[17:43:11.486]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.459]   - Field: ‘gc’
[17:43:11.486]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.459]   - Field: ‘conditions’
[17:43:11.486]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.459]   - Field: ‘expr’
[17:43:11.487]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.459]   - Field: ‘uuid’
[17:43:11.487]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.460]   - Field: ‘seed’
[17:43:11.487]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.460]   - Field: ‘version’
[17:43:11.487]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.460]   - Field: ‘result’
[17:43:11.487]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.460]   - Field: ‘asynchronous’
[17:43:11.487]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.460]   - Field: ‘calls’
[17:43:11.487]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.460]   - Field: ‘globals’
[17:43:11.488]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.460]   - Field: ‘stdout’
[17:43:11.488]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.461]   - Field: ‘earlySignal’
[17:43:11.488]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.461]   - Field: ‘lazy’
[17:43:11.488]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.461]   - Field: ‘state’
[17:43:11.488]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.461] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:11.488]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.461] - Launch lazy future ...
[17:43:11.489]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.462] Packages needed by the future expression (n = 0): <none>
[17:43:11.489]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.462] Packages needed by future strategies (n = 0): <none>
[17:43:11.489]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.462] {
[17:43:11.462]     {
[17:43:11.462]         {
[17:43:11.462]             ...future.startTime <- base::Sys.time()
[17:43:11.462]             {
[17:43:11.462]                 {
[17:43:11.462]                   {
[17:43:11.462]                     base::local({
[17:43:11.462]                       has_future <- base::requireNamespace("future", 
[17:43:11.462]                         quietly = TRUE)
[17:43:11.462]                       if (has_future) {
[17:43:11.462]                         ns <- base::getNamespace("future")
[17:43:11.462]                         version <- ns[[".package"]][["version"]]
[17:43:11.462]                         if (is.null(version)) 
[17:43:11.462]                           version <- utils::packageVersion("future")
[17:43:11.462]                       }
[17:43:11.462]                       else {
[17:43:11.462]                         version <- NULL
[17:43:11.462]                       }
[17:43:11.462]                       if (!has_future || version < "1.8.0") {
[17:43:11.462]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.462]                           "", base::R.version$version.string), 
[17:43:11.462]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:11.462]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:11.462]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.462]                             "release", "version")], collapse = " "), 
[17:43:11.462]                           hostname = base::Sys.info()[["nodename"]])
[17:43:11.462]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.462]                           info)
[17:43:11.462]                         info <- base::paste(info, collapse = "; ")
[17:43:11.462]                         if (!has_future) {
[17:43:11.462]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.462]                             info)
[17:43:11.462]                         }
[17:43:11.462]                         else {
[17:43:11.462]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.462]                             info, version)
[17:43:11.462]                         }
[17:43:11.462]                         base::stop(msg)
[17:43:11.462]                       }
[17:43:11.462]                     })
[17:43:11.462]                   }
[17:43:11.462]                   options(future.plan = NULL)
[17:43:11.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:11.462]                 }
[17:43:11.462]                 ...future.workdir <- getwd()
[17:43:11.462]             }
[17:43:11.462]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.462]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.462]         }
[17:43:11.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.462]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.462]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.462]             base::names(...future.oldOptions))
[17:43:11.462]     }
[17:43:11.462]     if (FALSE) {
[17:43:11.462]     }
[17:43:11.462]     else {
[17:43:11.462]         if (TRUE) {
[17:43:11.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.462]                 open = "w")
[17:43:11.462]         }
[17:43:11.462]         else {
[17:43:11.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.462]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.462]         }
[17:43:11.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.462]             base::sink(type = "output", split = FALSE)
[17:43:11.462]             base::close(...future.stdout)
[17:43:11.462]         }, add = TRUE)
[17:43:11.462]     }
[17:43:11.462]     ...future.frame <- base::sys.nframe()
[17:43:11.462]     ...future.conditions <- base::list()
[17:43:11.462]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.462]     if (FALSE) {
[17:43:11.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.462]     }
[17:43:11.462]     ...future.result <- base::tryCatch({
[17:43:11.462]         base::withCallingHandlers({
[17:43:11.462]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:43:11.462]                 a == 2)))
[17:43:11.462]             future::FutureResult(value = ...future.value$value, 
[17:43:11.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.462]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.462]                     ...future.globalenv.names))
[17:43:11.462]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.462]         }, condition = base::local({
[17:43:11.462]             c <- base::c
[17:43:11.462]             inherits <- base::inherits
[17:43:11.462]             invokeRestart <- base::invokeRestart
[17:43:11.462]             length <- base::length
[17:43:11.462]             list <- base::list
[17:43:11.462]             seq.int <- base::seq.int
[17:43:11.462]             signalCondition <- base::signalCondition
[17:43:11.462]             sys.calls <- base::sys.calls
[17:43:11.462]             `[[` <- base::`[[`
[17:43:11.462]             `+` <- base::`+`
[17:43:11.462]             `<<-` <- base::`<<-`
[17:43:11.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.462]                   3L)]
[17:43:11.462]             }
[17:43:11.462]             function(cond) {
[17:43:11.462]                 is_error <- inherits(cond, "error")
[17:43:11.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.462]                   NULL)
[17:43:11.462]                 if (is_error) {
[17:43:11.462]                   sessionInformation <- function() {
[17:43:11.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.462]                       search = base::search(), system = base::Sys.info())
[17:43:11.462]                   }
[17:43:11.462]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.462]                     cond$call), session = sessionInformation(), 
[17:43:11.462]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.462]                   signalCondition(cond)
[17:43:11.462]                 }
[17:43:11.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.462]                 "immediateCondition"))) {
[17:43:11.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.462]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.462]                   if (TRUE && !signal) {
[17:43:11.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.462]                     {
[17:43:11.462]                       inherits <- base::inherits
[17:43:11.462]                       invokeRestart <- base::invokeRestart
[17:43:11.462]                       is.null <- base::is.null
[17:43:11.462]                       muffled <- FALSE
[17:43:11.462]                       if (inherits(cond, "message")) {
[17:43:11.462]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.462]                         if (muffled) 
[17:43:11.462]                           invokeRestart("muffleMessage")
[17:43:11.462]                       }
[17:43:11.462]                       else if (inherits(cond, "warning")) {
[17:43:11.462]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.462]                         if (muffled) 
[17:43:11.462]                           invokeRestart("muffleWarning")
[17:43:11.462]                       }
[17:43:11.462]                       else if (inherits(cond, "condition")) {
[17:43:11.462]                         if (!is.null(pattern)) {
[17:43:11.462]                           computeRestarts <- base::computeRestarts
[17:43:11.462]                           grepl <- base::grepl
[17:43:11.462]                           restarts <- computeRestarts(cond)
[17:43:11.462]                           for (restart in restarts) {
[17:43:11.462]                             name <- restart$name
[17:43:11.462]                             if (is.null(name)) 
[17:43:11.462]                               next
[17:43:11.462]                             if (!grepl(pattern, name)) 
[17:43:11.462]                               next
[17:43:11.462]                             invokeRestart(restart)
[17:43:11.462]                             muffled <- TRUE
[17:43:11.462]                             break
[17:43:11.462]                           }
[17:43:11.462]                         }
[17:43:11.462]                       }
[17:43:11.462]                       invisible(muffled)
[17:43:11.462]                     }
[17:43:11.462]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.462]                   }
[17:43:11.462]                 }
[17:43:11.462]                 else {
[17:43:11.462]                   if (TRUE) {
[17:43:11.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.462]                     {
[17:43:11.462]                       inherits <- base::inherits
[17:43:11.462]                       invokeRestart <- base::invokeRestart
[17:43:11.462]                       is.null <- base::is.null
[17:43:11.462]                       muffled <- FALSE
[17:43:11.462]                       if (inherits(cond, "message")) {
[17:43:11.462]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.462]                         if (muffled) 
[17:43:11.462]                           invokeRestart("muffleMessage")
[17:43:11.462]                       }
[17:43:11.462]                       else if (inherits(cond, "warning")) {
[17:43:11.462]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.462]                         if (muffled) 
[17:43:11.462]                           invokeRestart("muffleWarning")
[17:43:11.462]                       }
[17:43:11.462]                       else if (inherits(cond, "condition")) {
[17:43:11.462]                         if (!is.null(pattern)) {
[17:43:11.462]                           computeRestarts <- base::computeRestarts
[17:43:11.462]                           grepl <- base::grepl
[17:43:11.462]                           restarts <- computeRestarts(cond)
[17:43:11.462]                           for (restart in restarts) {
[17:43:11.462]                             name <- restart$name
[17:43:11.462]                             if (is.null(name)) 
[17:43:11.462]                               next
[17:43:11.462]                             if (!grepl(pattern, name)) 
[17:43:11.462]                               next
[17:43:11.462]                             invokeRestart(restart)
[17:43:11.462]                             muffled <- TRUE
[17:43:11.462]                             break
[17:43:11.462]                           }
[17:43:11.462]                         }
[17:43:11.462]                       }
[17:43:11.462]                       invisible(muffled)
[17:43:11.462]                     }
[17:43:11.462]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.462]                   }
[17:43:11.462]                 }
[17:43:11.462]             }
[17:43:11.462]         }))
[17:43:11.462]     }, error = function(ex) {
[17:43:11.462]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.462]                 ...future.rng), started = ...future.startTime, 
[17:43:11.462]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.462]             version = "1.8"), class = "FutureResult")
[17:43:11.462]     }, finally = {
[17:43:11.462]         if (!identical(...future.workdir, getwd())) 
[17:43:11.462]             setwd(...future.workdir)
[17:43:11.462]         {
[17:43:11.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.462]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.462]             }
[17:43:11.462]             base::options(...future.oldOptions)
[17:43:11.462]             if (.Platform$OS.type == "windows") {
[17:43:11.462]                 old_names <- names(...future.oldEnvVars)
[17:43:11.462]                 envs <- base::Sys.getenv()
[17:43:11.462]                 names <- names(envs)
[17:43:11.462]                 common <- intersect(names, old_names)
[17:43:11.462]                 added <- setdiff(names, old_names)
[17:43:11.462]                 removed <- setdiff(old_names, names)
[17:43:11.462]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.462]                   envs[common]]
[17:43:11.462]                 NAMES <- toupper(changed)
[17:43:11.462]                 args <- list()
[17:43:11.462]                 for (kk in seq_along(NAMES)) {
[17:43:11.462]                   name <- changed[[kk]]
[17:43:11.462]                   NAME <- NAMES[[kk]]
[17:43:11.462]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.462]                     next
[17:43:11.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.462]                 }
[17:43:11.462]                 NAMES <- toupper(added)
[17:43:11.462]                 for (kk in seq_along(NAMES)) {
[17:43:11.462]                   name <- added[[kk]]
[17:43:11.462]                   NAME <- NAMES[[kk]]
[17:43:11.462]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.462]                     next
[17:43:11.462]                   args[[name]] <- ""
[17:43:11.462]                 }
[17:43:11.462]                 NAMES <- toupper(removed)
[17:43:11.462]                 for (kk in seq_along(NAMES)) {
[17:43:11.462]                   name <- removed[[kk]]
[17:43:11.462]                   NAME <- NAMES[[kk]]
[17:43:11.462]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.462]                     next
[17:43:11.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.462]                 }
[17:43:11.462]                 if (length(args) > 0) 
[17:43:11.462]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.462]             }
[17:43:11.462]             else {
[17:43:11.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.462]             }
[17:43:11.462]             {
[17:43:11.462]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.462]                   0L) {
[17:43:11.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.462]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.462]                   base::options(opts)
[17:43:11.462]                 }
[17:43:11.462]                 {
[17:43:11.462]                   {
[17:43:11.462]                     NULL
[17:43:11.462]                     RNGkind("Mersenne-Twister")
[17:43:11.462]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:11.462]                       inherits = FALSE)
[17:43:11.462]                   }
[17:43:11.462]                   options(future.plan = NULL)
[17:43:11.462]                   if (is.na(NA_character_)) 
[17:43:11.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.462]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:43:11.462]                   {
[17:43:11.462]                     future <- SequentialFuture(..., envir = envir)
[17:43:11.462]                     if (!future$lazy) 
[17:43:11.462]                       future <- run(future)
[17:43:11.462]                     invisible(future)
[17:43:11.462]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.462]                 }
[17:43:11.462]             }
[17:43:11.462]         }
[17:43:11.462]     })
[17:43:11.462]     if (TRUE) {
[17:43:11.462]         base::sink(type = "output", split = FALSE)
[17:43:11.462]         if (TRUE) {
[17:43:11.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.462]         }
[17:43:11.462]         else {
[17:43:11.462]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.462]         }
[17:43:11.462]         base::close(...future.stdout)
[17:43:11.462]         ...future.stdout <- NULL
[17:43:11.462]     }
[17:43:11.462]     ...future.result$conditions <- ...future.conditions
[17:43:11.462]     ...future.result$finished <- base::Sys.time()
[17:43:11.462]     ...future.result
[17:43:11.462] }
[17:43:11.489]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.465] assign_globals() ...
[17:43:11.489]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.465] List of 1
[17:43:11.465]  $ data:'data.frame':	3 obs. of  2 variables:
[17:43:11.465]   ..$ a: int [1:3] 1 2 3
[17:43:11.465]   ..$ b: int [1:3] 3 2 1
[17:43:11.465]  - attr(*, "where")=List of 1
[17:43:11.465]   ..$ data:<environment: R_EmptyEnv> 
[17:43:11.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.465]  - attr(*, "resolved")= logi FALSE
[17:43:11.465]  - attr(*, "total_size")= num 128
[17:43:11.465]  - attr(*, "already-done")= logi TRUE
[17:43:11.489]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.470] - copied ‘data’ to environment
[17:43:11.490]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.470] assign_globals() ... done
[17:43:11.490]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.470] plan(): Setting new future strategy stack:
[17:43:11.490]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.470] List of future strategies:
[17:43:11.470] 1. sequential:
[17:43:11.470]    - args: function (..., envir = parent.frame())
[17:43:11.470]    - tweaked: FALSE
[17:43:11.470]    - call: NULL
[17:43:11.490]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.471] plan(): nbrOfWorkers() = 1
[17:43:11.490]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.472] plan(): Setting new future strategy stack:
[17:43:11.490]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.472] List of future strategies:
[17:43:11.472] 1. sequential:
[17:43:11.472]    - args: function (..., envir = parent.frame())
[17:43:11.472]    - tweaked: FALSE
[17:43:11.472]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.490]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.473] plan(): nbrOfWorkers() = 1
[17:43:11.491]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.473] SequentialFuture started (and completed)
[17:43:11.491]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.473] - Launch lazy future ... done
[17:43:11.491]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.473] run() for ‘SequentialFuture’ ... done
[17:43:11.491] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[17:43:11.492] plan(): Setting new future strategy stack:
[17:43:11.492] List of future strategies:
[17:43:11.492] 1. multicore:
[17:43:11.492]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.492]    - tweaked: FALSE
[17:43:11.492]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.492] 2. multicore:
[17:43:11.492]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.492]    - tweaked: FALSE
[17:43:11.492]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.496] plan(): nbrOfWorkers() = 2
[17:43:11.497] getGlobalsAndPackages() ...
[17:43:11.497] Searching for globals...
[17:43:11.520] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:43:11.520] Searching for globals ... DONE
[17:43:11.520] Resolving globals: FALSE
[17:43:11.521] The total size of the 2 globals is 93.07 KiB (95304 bytes)
[17:43:11.522] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 93.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (92.95 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:43:11.522] - globals: [2] ‘nested’, ‘strategy2’
[17:43:11.522] - packages: [1] ‘future’
[17:43:11.522] getGlobalsAndPackages() ... DONE
[17:43:11.522] run() for ‘Future’ ...
[17:43:11.523] - state: ‘created’
[17:43:11.523] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.527] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:11.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:11.527]   - Field: ‘label’
[17:43:11.527]   - Field: ‘local’
[17:43:11.527]   - Field: ‘owner’
[17:43:11.527]   - Field: ‘envir’
[17:43:11.527]   - Field: ‘workers’
[17:43:11.528]   - Field: ‘packages’
[17:43:11.528]   - Field: ‘gc’
[17:43:11.528]   - Field: ‘job’
[17:43:11.528]   - Field: ‘conditions’
[17:43:11.528]   - Field: ‘expr’
[17:43:11.528]   - Field: ‘uuid’
[17:43:11.528]   - Field: ‘seed’
[17:43:11.528]   - Field: ‘version’
[17:43:11.528]   - Field: ‘result’
[17:43:11.529]   - Field: ‘asynchronous’
[17:43:11.529]   - Field: ‘calls’
[17:43:11.529]   - Field: ‘globals’
[17:43:11.529]   - Field: ‘stdout’
[17:43:11.529]   - Field: ‘earlySignal’
[17:43:11.529]   - Field: ‘lazy’
[17:43:11.529]   - Field: ‘state’
[17:43:11.529] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:11.530] - Launch lazy future ...
[17:43:11.530] Packages needed by the future expression (n = 1): ‘future’
[17:43:11.530] Packages needed by future strategies (n = 1): ‘future’
[17:43:11.531] {
[17:43:11.531]     {
[17:43:11.531]         {
[17:43:11.531]             ...future.startTime <- base::Sys.time()
[17:43:11.531]             {
[17:43:11.531]                 {
[17:43:11.531]                   {
[17:43:11.531]                     {
[17:43:11.531]                       {
[17:43:11.531]                         base::local({
[17:43:11.531]                           has_future <- base::requireNamespace("future", 
[17:43:11.531]                             quietly = TRUE)
[17:43:11.531]                           if (has_future) {
[17:43:11.531]                             ns <- base::getNamespace("future")
[17:43:11.531]                             version <- ns[[".package"]][["version"]]
[17:43:11.531]                             if (is.null(version)) 
[17:43:11.531]                               version <- utils::packageVersion("future")
[17:43:11.531]                           }
[17:43:11.531]                           else {
[17:43:11.531]                             version <- NULL
[17:43:11.531]                           }
[17:43:11.531]                           if (!has_future || version < "1.8.0") {
[17:43:11.531]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.531]                               "", base::R.version$version.string), 
[17:43:11.531]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:11.531]                                 base::R.version$platform, 8 * 
[17:43:11.531]                                   base::.Machine$sizeof.pointer), 
[17:43:11.531]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.531]                                 "release", "version")], collapse = " "), 
[17:43:11.531]                               hostname = base::Sys.info()[["nodename"]])
[17:43:11.531]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.531]                               info)
[17:43:11.531]                             info <- base::paste(info, collapse = "; ")
[17:43:11.531]                             if (!has_future) {
[17:43:11.531]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.531]                                 info)
[17:43:11.531]                             }
[17:43:11.531]                             else {
[17:43:11.531]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.531]                                 info, version)
[17:43:11.531]                             }
[17:43:11.531]                             base::stop(msg)
[17:43:11.531]                           }
[17:43:11.531]                         })
[17:43:11.531]                       }
[17:43:11.531]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:11.531]                       base::options(mc.cores = 1L)
[17:43:11.531]                     }
[17:43:11.531]                     base::local({
[17:43:11.531]                       for (pkg in "future") {
[17:43:11.531]                         base::loadNamespace(pkg)
[17:43:11.531]                         base::library(pkg, character.only = TRUE)
[17:43:11.531]                       }
[17:43:11.531]                     })
[17:43:11.531]                   }
[17:43:11.531]                   options(future.plan = NULL)
[17:43:11.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.531]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.531]                     envir = parent.frame()) 
[17:43:11.531]                   {
[17:43:11.531]                     default_workers <- missing(workers)
[17:43:11.531]                     if (is.function(workers)) 
[17:43:11.531]                       workers <- workers()
[17:43:11.531]                     workers <- structure(as.integer(workers), 
[17:43:11.531]                       class = class(workers))
[17:43:11.531]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.531]                       1L)
[17:43:11.531]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.531]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.531]                       if (default_workers) 
[17:43:11.531]                         supportsMulticore(warn = TRUE)
[17:43:11.531]                       return(sequential(..., envir = envir))
[17:43:11.531]                     }
[17:43:11.531]                     oopts <- options(mc.cores = workers)
[17:43:11.531]                     on.exit(options(oopts))
[17:43:11.531]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.531]                       envir = envir)
[17:43:11.531]                     if (!future$lazy) 
[17:43:11.531]                       future <- run(future)
[17:43:11.531]                     invisible(future)
[17:43:11.531]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.531]                 }
[17:43:11.531]                 ...future.workdir <- getwd()
[17:43:11.531]             }
[17:43:11.531]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.531]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.531]         }
[17:43:11.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.531]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.531]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.531]             base::names(...future.oldOptions))
[17:43:11.531]     }
[17:43:11.531]     if (FALSE) {
[17:43:11.531]     }
[17:43:11.531]     else {
[17:43:11.531]         if (TRUE) {
[17:43:11.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.531]                 open = "w")
[17:43:11.531]         }
[17:43:11.531]         else {
[17:43:11.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.531]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.531]         }
[17:43:11.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.531]             base::sink(type = "output", split = FALSE)
[17:43:11.531]             base::close(...future.stdout)
[17:43:11.531]         }, add = TRUE)
[17:43:11.531]     }
[17:43:11.531]     ...future.frame <- base::sys.nframe()
[17:43:11.531]     ...future.conditions <- base::list()
[17:43:11.531]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.531]     if (FALSE) {
[17:43:11.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.531]     }
[17:43:11.531]     ...future.result <- base::tryCatch({
[17:43:11.531]         base::withCallingHandlers({
[17:43:11.531]             ...future.value <- base::withVisible(base::local({
[17:43:11.531]                 withCallingHandlers({
[17:43:11.531]                   {
[17:43:11.531]                     a <- 1L
[17:43:11.531]                     plan_a <- unclass(future::plan("list"))
[17:43:11.531]                     nested_a <- nested[-1]
[17:43:11.531]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:43:11.531]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:43:11.531]                       strategy2))
[17:43:11.531]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:43:11.531]                       "init") <- NULL
[17:43:11.531]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:43:11.531]                       "init") <- NULL
[17:43:11.531]                     stopifnot(all.equal(plan_a, nested_a))
[17:43:11.531]                     y %<-% {
[17:43:11.531]                       b <- 2L
[17:43:11.531]                       plan_b <- future::plan("list")
[17:43:11.531]                       nested_b <- nested_a[-1]
[17:43:11.531]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:11.531]                         1L, inherits(plan_b[[1]], "future"), 
[17:43:11.531]                         inherits(future::plan("next"), "sequential"))
[17:43:11.531]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:11.531]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:11.531]                     }
[17:43:11.531]                     y
[17:43:11.531]                   }
[17:43:11.531]                 }, immediateCondition = function(cond) {
[17:43:11.531]                   save_rds <- function (object, pathname, ...) 
[17:43:11.531]                   {
[17:43:11.531]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:11.531]                     if (file_test("-f", pathname_tmp)) {
[17:43:11.531]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.531]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:11.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.531]                         fi_tmp[["mtime"]])
[17:43:11.531]                     }
[17:43:11.531]                     tryCatch({
[17:43:11.531]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:11.531]                     }, error = function(ex) {
[17:43:11.531]                       msg <- conditionMessage(ex)
[17:43:11.531]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.531]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:11.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.531]                         fi_tmp[["mtime"]], msg)
[17:43:11.531]                       ex$message <- msg
[17:43:11.531]                       stop(ex)
[17:43:11.531]                     })
[17:43:11.531]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:11.531]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:11.531]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:11.531]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.531]                       fi <- file.info(pathname)
[17:43:11.531]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:11.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.531]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:11.531]                         fi[["size"]], fi[["mtime"]])
[17:43:11.531]                       stop(msg)
[17:43:11.531]                     }
[17:43:11.531]                     invisible(pathname)
[17:43:11.531]                   }
[17:43:11.531]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:11.531]                     rootPath = tempdir()) 
[17:43:11.531]                   {
[17:43:11.531]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:11.531]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:11.531]                       tmpdir = path, fileext = ".rds")
[17:43:11.531]                     save_rds(obj, file)
[17:43:11.531]                   }
[17:43:11.531]                   saveImmediateCondition(cond, path = "/tmp/RtmpzPUCYD/.future/immediateConditions")
[17:43:11.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.531]                   {
[17:43:11.531]                     inherits <- base::inherits
[17:43:11.531]                     invokeRestart <- base::invokeRestart
[17:43:11.531]                     is.null <- base::is.null
[17:43:11.531]                     muffled <- FALSE
[17:43:11.531]                     if (inherits(cond, "message")) {
[17:43:11.531]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:11.531]                       if (muffled) 
[17:43:11.531]                         invokeRestart("muffleMessage")
[17:43:11.531]                     }
[17:43:11.531]                     else if (inherits(cond, "warning")) {
[17:43:11.531]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:11.531]                       if (muffled) 
[17:43:11.531]                         invokeRestart("muffleWarning")
[17:43:11.531]                     }
[17:43:11.531]                     else if (inherits(cond, "condition")) {
[17:43:11.531]                       if (!is.null(pattern)) {
[17:43:11.531]                         computeRestarts <- base::computeRestarts
[17:43:11.531]                         grepl <- base::grepl
[17:43:11.531]                         restarts <- computeRestarts(cond)
[17:43:11.531]                         for (restart in restarts) {
[17:43:11.531]                           name <- restart$name
[17:43:11.531]                           if (is.null(name)) 
[17:43:11.531]                             next
[17:43:11.531]                           if (!grepl(pattern, name)) 
[17:43:11.531]                             next
[17:43:11.531]                           invokeRestart(restart)
[17:43:11.531]                           muffled <- TRUE
[17:43:11.531]                           break
[17:43:11.531]                         }
[17:43:11.531]                       }
[17:43:11.531]                     }
[17:43:11.531]                     invisible(muffled)
[17:43:11.531]                   }
[17:43:11.531]                   muffleCondition(cond)
[17:43:11.531]                 })
[17:43:11.531]             }))
[17:43:11.531]             future::FutureResult(value = ...future.value$value, 
[17:43:11.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.531]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.531]                     ...future.globalenv.names))
[17:43:11.531]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.531]         }, condition = base::local({
[17:43:11.531]             c <- base::c
[17:43:11.531]             inherits <- base::inherits
[17:43:11.531]             invokeRestart <- base::invokeRestart
[17:43:11.531]             length <- base::length
[17:43:11.531]             list <- base::list
[17:43:11.531]             seq.int <- base::seq.int
[17:43:11.531]             signalCondition <- base::signalCondition
[17:43:11.531]             sys.calls <- base::sys.calls
[17:43:11.531]             `[[` <- base::`[[`
[17:43:11.531]             `+` <- base::`+`
[17:43:11.531]             `<<-` <- base::`<<-`
[17:43:11.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.531]                   3L)]
[17:43:11.531]             }
[17:43:11.531]             function(cond) {
[17:43:11.531]                 is_error <- inherits(cond, "error")
[17:43:11.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.531]                   NULL)
[17:43:11.531]                 if (is_error) {
[17:43:11.531]                   sessionInformation <- function() {
[17:43:11.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.531]                       search = base::search(), system = base::Sys.info())
[17:43:11.531]                   }
[17:43:11.531]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.531]                     cond$call), session = sessionInformation(), 
[17:43:11.531]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.531]                   signalCondition(cond)
[17:43:11.531]                 }
[17:43:11.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.531]                 "immediateCondition"))) {
[17:43:11.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.531]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.531]                   if (TRUE && !signal) {
[17:43:11.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.531]                     {
[17:43:11.531]                       inherits <- base::inherits
[17:43:11.531]                       invokeRestart <- base::invokeRestart
[17:43:11.531]                       is.null <- base::is.null
[17:43:11.531]                       muffled <- FALSE
[17:43:11.531]                       if (inherits(cond, "message")) {
[17:43:11.531]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.531]                         if (muffled) 
[17:43:11.531]                           invokeRestart("muffleMessage")
[17:43:11.531]                       }
[17:43:11.531]                       else if (inherits(cond, "warning")) {
[17:43:11.531]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.531]                         if (muffled) 
[17:43:11.531]                           invokeRestart("muffleWarning")
[17:43:11.531]                       }
[17:43:11.531]                       else if (inherits(cond, "condition")) {
[17:43:11.531]                         if (!is.null(pattern)) {
[17:43:11.531]                           computeRestarts <- base::computeRestarts
[17:43:11.531]                           grepl <- base::grepl
[17:43:11.531]                           restarts <- computeRestarts(cond)
[17:43:11.531]                           for (restart in restarts) {
[17:43:11.531]                             name <- restart$name
[17:43:11.531]                             if (is.null(name)) 
[17:43:11.531]                               next
[17:43:11.531]                             if (!grepl(pattern, name)) 
[17:43:11.531]                               next
[17:43:11.531]                             invokeRestart(restart)
[17:43:11.531]                             muffled <- TRUE
[17:43:11.531]                             break
[17:43:11.531]                           }
[17:43:11.531]                         }
[17:43:11.531]                       }
[17:43:11.531]                       invisible(muffled)
[17:43:11.531]                     }
[17:43:11.531]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.531]                   }
[17:43:11.531]                 }
[17:43:11.531]                 else {
[17:43:11.531]                   if (TRUE) {
[17:43:11.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.531]                     {
[17:43:11.531]                       inherits <- base::inherits
[17:43:11.531]                       invokeRestart <- base::invokeRestart
[17:43:11.531]                       is.null <- base::is.null
[17:43:11.531]                       muffled <- FALSE
[17:43:11.531]                       if (inherits(cond, "message")) {
[17:43:11.531]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.531]                         if (muffled) 
[17:43:11.531]                           invokeRestart("muffleMessage")
[17:43:11.531]                       }
[17:43:11.531]                       else if (inherits(cond, "warning")) {
[17:43:11.531]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.531]                         if (muffled) 
[17:43:11.531]                           invokeRestart("muffleWarning")
[17:43:11.531]                       }
[17:43:11.531]                       else if (inherits(cond, "condition")) {
[17:43:11.531]                         if (!is.null(pattern)) {
[17:43:11.531]                           computeRestarts <- base::computeRestarts
[17:43:11.531]                           grepl <- base::grepl
[17:43:11.531]                           restarts <- computeRestarts(cond)
[17:43:11.531]                           for (restart in restarts) {
[17:43:11.531]                             name <- restart$name
[17:43:11.531]                             if (is.null(name)) 
[17:43:11.531]                               next
[17:43:11.531]                             if (!grepl(pattern, name)) 
[17:43:11.531]                               next
[17:43:11.531]                             invokeRestart(restart)
[17:43:11.531]                             muffled <- TRUE
[17:43:11.531]                             break
[17:43:11.531]                           }
[17:43:11.531]                         }
[17:43:11.531]                       }
[17:43:11.531]                       invisible(muffled)
[17:43:11.531]                     }
[17:43:11.531]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.531]                   }
[17:43:11.531]                 }
[17:43:11.531]             }
[17:43:11.531]         }))
[17:43:11.531]     }, error = function(ex) {
[17:43:11.531]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.531]                 ...future.rng), started = ...future.startTime, 
[17:43:11.531]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.531]             version = "1.8"), class = "FutureResult")
[17:43:11.531]     }, finally = {
[17:43:11.531]         if (!identical(...future.workdir, getwd())) 
[17:43:11.531]             setwd(...future.workdir)
[17:43:11.531]         {
[17:43:11.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.531]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.531]             }
[17:43:11.531]             base::options(...future.oldOptions)
[17:43:11.531]             if (.Platform$OS.type == "windows") {
[17:43:11.531]                 old_names <- names(...future.oldEnvVars)
[17:43:11.531]                 envs <- base::Sys.getenv()
[17:43:11.531]                 names <- names(envs)
[17:43:11.531]                 common <- intersect(names, old_names)
[17:43:11.531]                 added <- setdiff(names, old_names)
[17:43:11.531]                 removed <- setdiff(old_names, names)
[17:43:11.531]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.531]                   envs[common]]
[17:43:11.531]                 NAMES <- toupper(changed)
[17:43:11.531]                 args <- list()
[17:43:11.531]                 for (kk in seq_along(NAMES)) {
[17:43:11.531]                   name <- changed[[kk]]
[17:43:11.531]                   NAME <- NAMES[[kk]]
[17:43:11.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.531]                     next
[17:43:11.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.531]                 }
[17:43:11.531]                 NAMES <- toupper(added)
[17:43:11.531]                 for (kk in seq_along(NAMES)) {
[17:43:11.531]                   name <- added[[kk]]
[17:43:11.531]                   NAME <- NAMES[[kk]]
[17:43:11.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.531]                     next
[17:43:11.531]                   args[[name]] <- ""
[17:43:11.531]                 }
[17:43:11.531]                 NAMES <- toupper(removed)
[17:43:11.531]                 for (kk in seq_along(NAMES)) {
[17:43:11.531]                   name <- removed[[kk]]
[17:43:11.531]                   NAME <- NAMES[[kk]]
[17:43:11.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.531]                     next
[17:43:11.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.531]                 }
[17:43:11.531]                 if (length(args) > 0) 
[17:43:11.531]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.531]             }
[17:43:11.531]             else {
[17:43:11.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.531]             }
[17:43:11.531]             {
[17:43:11.531]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.531]                   0L) {
[17:43:11.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.531]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.531]                   base::options(opts)
[17:43:11.531]                 }
[17:43:11.531]                 {
[17:43:11.531]                   {
[17:43:11.531]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:11.531]                     NULL
[17:43:11.531]                   }
[17:43:11.531]                   options(future.plan = NULL)
[17:43:11.531]                   if (is.na(NA_character_)) 
[17:43:11.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.531]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.531]                     envir = parent.frame()) 
[17:43:11.531]                   {
[17:43:11.531]                     default_workers <- missing(workers)
[17:43:11.531]                     if (is.function(workers)) 
[17:43:11.531]                       workers <- workers()
[17:43:11.531]                     workers <- structure(as.integer(workers), 
[17:43:11.531]                       class = class(workers))
[17:43:11.531]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.531]                       1L)
[17:43:11.531]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.531]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.531]                       if (default_workers) 
[17:43:11.531]                         supportsMulticore(warn = TRUE)
[17:43:11.531]                       return(sequential(..., envir = envir))
[17:43:11.531]                     }
[17:43:11.531]                     oopts <- options(mc.cores = workers)
[17:43:11.531]                     on.exit(options(oopts))
[17:43:11.531]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.531]                       envir = envir)
[17:43:11.531]                     if (!future$lazy) 
[17:43:11.531]                       future <- run(future)
[17:43:11.531]                     invisible(future)
[17:43:11.531]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.531]                     envir = parent.frame()) 
[17:43:11.531]                   {
[17:43:11.531]                     default_workers <- missing(workers)
[17:43:11.531]                     if (is.function(workers)) 
[17:43:11.531]                       workers <- workers()
[17:43:11.531]                     workers <- structure(as.integer(workers), 
[17:43:11.531]                       class = class(workers))
[17:43:11.531]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.531]                       1L)
[17:43:11.531]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.531]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.531]                       if (default_workers) 
[17:43:11.531]                         supportsMulticore(warn = TRUE)
[17:43:11.531]                       return(sequential(..., envir = envir))
[17:43:11.531]                     }
[17:43:11.531]                     oopts <- options(mc.cores = workers)
[17:43:11.531]                     on.exit(options(oopts))
[17:43:11.531]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.531]                       envir = envir)
[17:43:11.531]                     if (!future$lazy) 
[17:43:11.531]                       future <- run(future)
[17:43:11.531]                     invisible(future)
[17:43:11.531]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.531]                 }
[17:43:11.531]             }
[17:43:11.531]         }
[17:43:11.531]     })
[17:43:11.531]     if (TRUE) {
[17:43:11.531]         base::sink(type = "output", split = FALSE)
[17:43:11.531]         if (TRUE) {
[17:43:11.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.531]         }
[17:43:11.531]         else {
[17:43:11.531]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.531]         }
[17:43:11.531]         base::close(...future.stdout)
[17:43:11.531]         ...future.stdout <- NULL
[17:43:11.531]     }
[17:43:11.531]     ...future.result$conditions <- ...future.conditions
[17:43:11.531]     ...future.result$finished <- base::Sys.time()
[17:43:11.531]     ...future.result
[17:43:11.531] }
[17:43:11.534] assign_globals() ...
[17:43:11.534] List of 2
[17:43:11.534]  $ nested   :List of 2
[17:43:11.534]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:43:11.534]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:43:11.534]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.534]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:43:11.534]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:43:11.534]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.534]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:11.534]  $ strategy2: chr "multicore"
[17:43:11.534]  - attr(*, "where")=List of 2
[17:43:11.534]   ..$ nested   :<environment: R_EmptyEnv> 
[17:43:11.534]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:43:11.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.534]  - attr(*, "resolved")= logi FALSE
[17:43:11.534]  - attr(*, "total_size")= num 95304
[17:43:11.534]  - attr(*, "already-done")= logi TRUE
[17:43:11.540] - copied ‘nested’ to environment
[17:43:11.540] - copied ‘strategy2’ to environment
[17:43:11.540] assign_globals() ... done
[17:43:11.540] requestCore(): workers = 2
[17:43:11.543] MulticoreFuture started
[17:43:11.543] - Launch lazy future ... done
[17:43:11.543] run() for ‘MulticoreFuture’ ... done
[17:43:11.544] plan(): Setting new future strategy stack:
[17:43:11.545] List of future strategies:
[17:43:11.545] 1. multicore:
[17:43:11.545]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.545]    - tweaked: FALSE
[17:43:11.545]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.551] plan(): nbrOfWorkers() = 1
[17:43:11.593] plan(): Setting new future strategy stack:
[17:43:11.594] List of future strategies:
[17:43:11.594] 1. multicore:
[17:43:11.594]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.594]    - tweaked: FALSE
[17:43:11.594]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.594] 2. multicore:
[17:43:11.594]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.594]    - tweaked: FALSE
[17:43:11.594]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.598] plan(): nbrOfWorkers() = 2
[17:43:11.599] signalConditions() ...
[17:43:11.600]  - include = ‘immediateCondition’
[17:43:11.600]  - exclude = 
[17:43:11.600]  - resignal = FALSE
[17:43:11.600]  - Number of conditions: 54
[17:43:11.600] signalConditions() ... done
[17:43:11.601] signalConditions() ...
[17:43:11.601]  - include = ‘immediateCondition’
[17:43:11.601]  - exclude = 
[17:43:11.601]  - resignal = FALSE
[17:43:11.601]  - Number of conditions: 54
[17:43:11.601] signalConditions() ... done
[17:43:11.601] Future state: ‘finished’
[17:43:11.602] signalConditions() ...
[17:43:11.602]  - include = ‘condition’
[17:43:11.602]  - exclude = ‘immediateCondition’
[17:43:11.602]  - resignal = TRUE
[17:43:11.602]  - Number of conditions: 54
[17:43:11.602]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.552] getGlobalsAndPackages() ...
[17:43:11.603]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.553] Searching for globals...
[17:43:11.603]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.561] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:43:11.603]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.562] Searching for globals ... DONE
[17:43:11.603]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.562] Resolving globals: FALSE
[17:43:11.603]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.563] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[17:43:11.604]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.564] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:43:11.604]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.564] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:43:11.604]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.564] 
[17:43:11.604]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.564] getGlobalsAndPackages() ... DONE
[17:43:11.604]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.565] run() for ‘Future’ ...
[17:43:11.604]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.565] - state: ‘created’
[17:43:11.605]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.565] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.605]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.570] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:11.605]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.570] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:11.605]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.570]   - Field: ‘label’
[17:43:11.605]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.570]   - Field: ‘local’
[17:43:11.605]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.570]   - Field: ‘owner’
[17:43:11.606]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.571]   - Field: ‘envir’
[17:43:11.606]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.571]   - Field: ‘packages’
[17:43:11.606]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.571]   - Field: ‘gc’
[17:43:11.606]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.571]   - Field: ‘conditions’
[17:43:11.606]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.571]   - Field: ‘expr’
[17:43:11.606]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.571]   - Field: ‘uuid’
[17:43:11.607]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.572]   - Field: ‘seed’
[17:43:11.607]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.572]   - Field: ‘version’
[17:43:11.607]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.572]   - Field: ‘result’
[17:43:11.607]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.572]   - Field: ‘asynchronous’
[17:43:11.607]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.572]   - Field: ‘calls’
[17:43:11.607]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.572]   - Field: ‘globals’
[17:43:11.608]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.573]   - Field: ‘stdout’
[17:43:11.608]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.573]   - Field: ‘earlySignal’
[17:43:11.608]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.573]   - Field: ‘lazy’
[17:43:11.608]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.573]   - Field: ‘state’
[17:43:11.608]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.573] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:11.608]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.573] - Launch lazy future ...
[17:43:11.609]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.574] Packages needed by the future expression (n = 0): <none>
[17:43:11.609]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.574] Packages needed by future strategies (n = 0): <none>
[17:43:11.609]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.575] {
[17:43:11.575]     {
[17:43:11.575]         {
[17:43:11.575]             ...future.startTime <- base::Sys.time()
[17:43:11.575]             {
[17:43:11.575]                 {
[17:43:11.575]                   {
[17:43:11.575]                     base::local({
[17:43:11.575]                       has_future <- base::requireNamespace("future", 
[17:43:11.575]                         quietly = TRUE)
[17:43:11.575]                       if (has_future) {
[17:43:11.575]                         ns <- base::getNamespace("future")
[17:43:11.575]                         version <- ns[[".package"]][["version"]]
[17:43:11.575]                         if (is.null(version)) 
[17:43:11.575]                           version <- utils::packageVersion("future")
[17:43:11.575]                       }
[17:43:11.575]                       else {
[17:43:11.575]                         version <- NULL
[17:43:11.575]                       }
[17:43:11.575]                       if (!has_future || version < "1.8.0") {
[17:43:11.575]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.575]                           "", base::R.version$version.string), 
[17:43:11.575]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:11.575]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:11.575]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.575]                             "release", "version")], collapse = " "), 
[17:43:11.575]                           hostname = base::Sys.info()[["nodename"]])
[17:43:11.575]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.575]                           info)
[17:43:11.575]                         info <- base::paste(info, collapse = "; ")
[17:43:11.575]                         if (!has_future) {
[17:43:11.575]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.575]                             info)
[17:43:11.575]                         }
[17:43:11.575]                         else {
[17:43:11.575]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.575]                             info, version)
[17:43:11.575]                         }
[17:43:11.575]                         base::stop(msg)
[17:43:11.575]                       }
[17:43:11.575]                     })
[17:43:11.575]                   }
[17:43:11.575]                   options(future.plan = NULL)
[17:43:11.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:11.575]                 }
[17:43:11.575]                 ...future.workdir <- getwd()
[17:43:11.575]             }
[17:43:11.575]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.575]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.575]         }
[17:43:11.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.575]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.575]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.575]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.575]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.575]             base::names(...future.oldOptions))
[17:43:11.575]     }
[17:43:11.575]     if (FALSE) {
[17:43:11.575]     }
[17:43:11.575]     else {
[17:43:11.575]         if (TRUE) {
[17:43:11.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.575]                 open = "w")
[17:43:11.575]         }
[17:43:11.575]         else {
[17:43:11.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.575]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.575]         }
[17:43:11.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.575]             base::sink(type = "output", split = FALSE)
[17:43:11.575]             base::close(...future.stdout)
[17:43:11.575]         }, add = TRUE)
[17:43:11.575]     }
[17:43:11.575]     ...future.frame <- base::sys.nframe()
[17:43:11.575]     ...future.conditions <- base::list()
[17:43:11.575]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.575]     if (FALSE) {
[17:43:11.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.575]     }
[17:43:11.575]     ...future.result <- base::tryCatch({
[17:43:11.575]         base::withCallingHandlers({
[17:43:11.575]             ...future.value <- base::withVisible(base::local({
[17:43:11.575]                 b <- 2L
[17:43:11.575]                 plan_b <- future::plan("list")
[17:43:11.575]                 nested_b <- nested_a[-1]
[17:43:11.575]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:11.575]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:43:11.575]                   "sequential"))
[17:43:11.575]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:11.575]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:11.575]             }))
[17:43:11.575]             future::FutureResult(value = ...future.value$value, 
[17:43:11.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.575]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.575]                     ...future.globalenv.names))
[17:43:11.575]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.575]         }, condition = base::local({
[17:43:11.575]             c <- base::c
[17:43:11.575]             inherits <- base::inherits
[17:43:11.575]             invokeRestart <- base::invokeRestart
[17:43:11.575]             length <- base::length
[17:43:11.575]             list <- base::list
[17:43:11.575]             seq.int <- base::seq.int
[17:43:11.575]             signalCondition <- base::signalCondition
[17:43:11.575]             sys.calls <- base::sys.calls
[17:43:11.575]             `[[` <- base::`[[`
[17:43:11.575]             `+` <- base::`+`
[17:43:11.575]             `<<-` <- base::`<<-`
[17:43:11.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.575]                   3L)]
[17:43:11.575]             }
[17:43:11.575]             function(cond) {
[17:43:11.575]                 is_error <- inherits(cond, "error")
[17:43:11.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.575]                   NULL)
[17:43:11.575]                 if (is_error) {
[17:43:11.575]                   sessionInformation <- function() {
[17:43:11.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.575]                       search = base::search(), system = base::Sys.info())
[17:43:11.575]                   }
[17:43:11.575]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.575]                     cond$call), session = sessionInformation(), 
[17:43:11.575]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.575]                   signalCondition(cond)
[17:43:11.575]                 }
[17:43:11.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.575]                 "immediateCondition"))) {
[17:43:11.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.575]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.575]                   if (TRUE && !signal) {
[17:43:11.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.575]                     {
[17:43:11.575]                       inherits <- base::inherits
[17:43:11.575]                       invokeRestart <- base::invokeRestart
[17:43:11.575]                       is.null <- base::is.null
[17:43:11.575]                       muffled <- FALSE
[17:43:11.575]                       if (inherits(cond, "message")) {
[17:43:11.575]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.575]                         if (muffled) 
[17:43:11.575]                           invokeRestart("muffleMessage")
[17:43:11.575]                       }
[17:43:11.575]                       else if (inherits(cond, "warning")) {
[17:43:11.575]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.575]                         if (muffled) 
[17:43:11.575]                           invokeRestart("muffleWarning")
[17:43:11.575]                       }
[17:43:11.575]                       else if (inherits(cond, "condition")) {
[17:43:11.575]                         if (!is.null(pattern)) {
[17:43:11.575]                           computeRestarts <- base::computeRestarts
[17:43:11.575]                           grepl <- base::grepl
[17:43:11.575]                           restarts <- computeRestarts(cond)
[17:43:11.575]                           for (restart in restarts) {
[17:43:11.575]                             name <- restart$name
[17:43:11.575]                             if (is.null(name)) 
[17:43:11.575]                               next
[17:43:11.575]                             if (!grepl(pattern, name)) 
[17:43:11.575]                               next
[17:43:11.575]                             invokeRestart(restart)
[17:43:11.575]                             muffled <- TRUE
[17:43:11.575]                             break
[17:43:11.575]                           }
[17:43:11.575]                         }
[17:43:11.575]                       }
[17:43:11.575]                       invisible(muffled)
[17:43:11.575]                     }
[17:43:11.575]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.575]                   }
[17:43:11.575]                 }
[17:43:11.575]                 else {
[17:43:11.575]                   if (TRUE) {
[17:43:11.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.575]                     {
[17:43:11.575]                       inherits <- base::inherits
[17:43:11.575]                       invokeRestart <- base::invokeRestart
[17:43:11.575]                       is.null <- base::is.null
[17:43:11.575]                       muffled <- FALSE
[17:43:11.575]                       if (inherits(cond, "message")) {
[17:43:11.575]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.575]                         if (muffled) 
[17:43:11.575]                           invokeRestart("muffleMessage")
[17:43:11.575]                       }
[17:43:11.575]                       else if (inherits(cond, "warning")) {
[17:43:11.575]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.575]                         if (muffled) 
[17:43:11.575]                           invokeRestart("muffleWarning")
[17:43:11.575]                       }
[17:43:11.575]                       else if (inherits(cond, "condition")) {
[17:43:11.575]                         if (!is.null(pattern)) {
[17:43:11.575]                           computeRestarts <- base::computeRestarts
[17:43:11.575]                           grepl <- base::grepl
[17:43:11.575]                           restarts <- computeRestarts(cond)
[17:43:11.575]                           for (restart in restarts) {
[17:43:11.575]                             name <- restart$name
[17:43:11.575]                             if (is.null(name)) 
[17:43:11.575]                               next
[17:43:11.575]                             if (!grepl(pattern, name)) 
[17:43:11.575]                               next
[17:43:11.575]                             invokeRestart(restart)
[17:43:11.575]                             muffled <- TRUE
[17:43:11.575]                             break
[17:43:11.575]                           }
[17:43:11.575]                         }
[17:43:11.575]                       }
[17:43:11.575]                       invisible(muffled)
[17:43:11.575]                     }
[17:43:11.575]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.575]                   }
[17:43:11.575]                 }
[17:43:11.575]             }
[17:43:11.575]         }))
[17:43:11.575]     }, error = function(ex) {
[17:43:11.575]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.575]                 ...future.rng), started = ...future.startTime, 
[17:43:11.575]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.575]             version = "1.8"), class = "FutureResult")
[17:43:11.575]     }, finally = {
[17:43:11.575]         if (!identical(...future.workdir, getwd())) 
[17:43:11.575]             setwd(...future.workdir)
[17:43:11.575]         {
[17:43:11.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.575]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.575]             }
[17:43:11.575]             base::options(...future.oldOptions)
[17:43:11.575]             if (.Platform$OS.type == "windows") {
[17:43:11.575]                 old_names <- names(...future.oldEnvVars)
[17:43:11.575]                 envs <- base::Sys.getenv()
[17:43:11.575]                 names <- names(envs)
[17:43:11.575]                 common <- intersect(names, old_names)
[17:43:11.575]                 added <- setdiff(names, old_names)
[17:43:11.575]                 removed <- setdiff(old_names, names)
[17:43:11.575]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.575]                   envs[common]]
[17:43:11.575]                 NAMES <- toupper(changed)
[17:43:11.575]                 args <- list()
[17:43:11.575]                 for (kk in seq_along(NAMES)) {
[17:43:11.575]                   name <- changed[[kk]]
[17:43:11.575]                   NAME <- NAMES[[kk]]
[17:43:11.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.575]                     next
[17:43:11.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.575]                 }
[17:43:11.575]                 NAMES <- toupper(added)
[17:43:11.575]                 for (kk in seq_along(NAMES)) {
[17:43:11.575]                   name <- added[[kk]]
[17:43:11.575]                   NAME <- NAMES[[kk]]
[17:43:11.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.575]                     next
[17:43:11.575]                   args[[name]] <- ""
[17:43:11.575]                 }
[17:43:11.575]                 NAMES <- toupper(removed)
[17:43:11.575]                 for (kk in seq_along(NAMES)) {
[17:43:11.575]                   name <- removed[[kk]]
[17:43:11.575]                   NAME <- NAMES[[kk]]
[17:43:11.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.575]                     next
[17:43:11.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.575]                 }
[17:43:11.575]                 if (length(args) > 0) 
[17:43:11.575]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.575]             }
[17:43:11.575]             else {
[17:43:11.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.575]             }
[17:43:11.575]             {
[17:43:11.575]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.575]                   0L) {
[17:43:11.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.575]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.575]                   base::options(opts)
[17:43:11.575]                 }
[17:43:11.575]                 {
[17:43:11.575]                   {
[17:43:11.575]                     NULL
[17:43:11.575]                     RNGkind("Mersenne-Twister")
[17:43:11.575]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:11.575]                       inherits = FALSE)
[17:43:11.575]                   }
[17:43:11.575]                   options(future.plan = NULL)
[17:43:11.575]                   if (is.na(NA_character_)) 
[17:43:11.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.575]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.575]                     envir = parent.frame()) 
[17:43:11.575]                   {
[17:43:11.575]                     default_workers <- missing(workers)
[17:43:11.575]                     if (is.function(workers)) 
[17:43:11.575]                       workers <- workers()
[17:43:11.575]                     workers <- structure(as.integer(workers), 
[17:43:11.575]                       class = class(workers))
[17:43:11.575]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.575]                       1L)
[17:43:11.575]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.575]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.575]                       if (default_workers) 
[17:43:11.575]                         supportsMulticore(warn = TRUE)
[17:43:11.575]                       return(sequential(..., envir = envir))
[17:43:11.575]                     }
[17:43:11.575]                     oopts <- options(mc.cores = workers)
[17:43:11.575]                     on.exit(options(oopts))
[17:43:11.575]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.575]                       envir = envir)
[17:43:11.575]                     if (!future$lazy) 
[17:43:11.575]                       future <- run(future)
[17:43:11.575]                     invisible(future)
[17:43:11.575]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.575]                 }
[17:43:11.575]             }
[17:43:11.575]         }
[17:43:11.575]     })
[17:43:11.575]     if (TRUE) {
[17:43:11.575]         base::sink(type = "output", split = FALSE)
[17:43:11.575]         if (TRUE) {
[17:43:11.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.575]         }
[17:43:11.575]         else {
[17:43:11.575]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.575]         }
[17:43:11.575]         base::close(...future.stdout)
[17:43:11.575]         ...future.stdout <- NULL
[17:43:11.575]     }
[17:43:11.575]     ...future.result$conditions <- ...future.conditions
[17:43:11.575]     ...future.result$finished <- base::Sys.time()
[17:43:11.575]     ...future.result
[17:43:11.575] }
[17:43:11.609]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.577] assign_globals() ...
[17:43:11.609]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.577] List of 3
[17:43:11.577]  $ nested_a:List of 1
[17:43:11.577]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:43:11.577]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:43:11.577]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.577]  $ a       : int 1
[17:43:11.577]  $ plan_a  :List of 1
[17:43:11.577]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:43:11.577]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:43:11.577]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.577]  - attr(*, "where")=List of 3
[17:43:11.577]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:43:11.577]   ..$ a       :<environment: R_EmptyEnv> 
[17:43:11.577]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:43:11.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.577]  - attr(*, "resolved")= logi FALSE
[17:43:11.577]  - attr(*, "total_size")= num 95240
[17:43:11.577]  - attr(*, "already-done")= logi TRUE
[17:43:11.609]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.585] - copied ‘nested_a’ to environment
[17:43:11.610]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.585] - copied ‘a’ to environment
[17:43:11.610]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.585] - copied ‘plan_a’ to environment
[17:43:11.610]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.585] assign_globals() ... done
[17:43:11.610]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.586] plan(): Setting new future strategy stack:
[17:43:11.610]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.586] List of future strategies:
[17:43:11.586] 1. sequential:
[17:43:11.586]    - args: function (..., envir = parent.frame())
[17:43:11.586]    - tweaked: FALSE
[17:43:11.586]    - call: NULL
[17:43:11.611]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.586] plan(): nbrOfWorkers() = 1
[17:43:11.611]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.587] plan(): Setting new future strategy stack:
[17:43:11.611]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.587] List of future strategies:
[17:43:11.587] 1. multicore:
[17:43:11.587]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.587]    - tweaked: FALSE
[17:43:11.587]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.611]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.592] plan(): nbrOfWorkers() = 1
[17:43:11.611]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.592] SequentialFuture started (and completed)
[17:43:11.612]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.592] - Launch lazy future ... done
[17:43:11.612]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.593] run() for ‘SequentialFuture’ ... done
[17:43:11.612] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:11.618] getGlobalsAndPackages() ...
[17:43:11.618] Searching for globals...
[17:43:11.620] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:11.620] Searching for globals ... DONE
[17:43:11.620] Resolving globals: FALSE
[17:43:11.621] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:11.622] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:11.622] - globals: [1] ‘data’
[17:43:11.622] - packages: [1] ‘future’
[17:43:11.622] getGlobalsAndPackages() ... DONE
[17:43:11.622] run() for ‘Future’ ...
[17:43:11.623] - state: ‘created’
[17:43:11.623] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.627] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:11.627] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:11.628]   - Field: ‘label’
[17:43:11.628]   - Field: ‘local’
[17:43:11.628]   - Field: ‘owner’
[17:43:11.628]   - Field: ‘envir’
[17:43:11.628]   - Field: ‘workers’
[17:43:11.628]   - Field: ‘packages’
[17:43:11.628]   - Field: ‘gc’
[17:43:11.629]   - Field: ‘job’
[17:43:11.629]   - Field: ‘conditions’
[17:43:11.629]   - Field: ‘expr’
[17:43:11.629]   - Field: ‘uuid’
[17:43:11.629]   - Field: ‘seed’
[17:43:11.629]   - Field: ‘version’
[17:43:11.629]   - Field: ‘result’
[17:43:11.629]   - Field: ‘asynchronous’
[17:43:11.629]   - Field: ‘calls’
[17:43:11.630]   - Field: ‘globals’
[17:43:11.630]   - Field: ‘stdout’
[17:43:11.630]   - Field: ‘earlySignal’
[17:43:11.630]   - Field: ‘lazy’
[17:43:11.630]   - Field: ‘state’
[17:43:11.630] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:11.630] - Launch lazy future ...
[17:43:11.631] Packages needed by the future expression (n = 1): ‘future’
[17:43:11.631] Packages needed by future strategies (n = 1): ‘future’
[17:43:11.631] {
[17:43:11.631]     {
[17:43:11.631]         {
[17:43:11.631]             ...future.startTime <- base::Sys.time()
[17:43:11.631]             {
[17:43:11.631]                 {
[17:43:11.631]                   {
[17:43:11.631]                     {
[17:43:11.631]                       {
[17:43:11.631]                         base::local({
[17:43:11.631]                           has_future <- base::requireNamespace("future", 
[17:43:11.631]                             quietly = TRUE)
[17:43:11.631]                           if (has_future) {
[17:43:11.631]                             ns <- base::getNamespace("future")
[17:43:11.631]                             version <- ns[[".package"]][["version"]]
[17:43:11.631]                             if (is.null(version)) 
[17:43:11.631]                               version <- utils::packageVersion("future")
[17:43:11.631]                           }
[17:43:11.631]                           else {
[17:43:11.631]                             version <- NULL
[17:43:11.631]                           }
[17:43:11.631]                           if (!has_future || version < "1.8.0") {
[17:43:11.631]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.631]                               "", base::R.version$version.string), 
[17:43:11.631]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:11.631]                                 base::R.version$platform, 8 * 
[17:43:11.631]                                   base::.Machine$sizeof.pointer), 
[17:43:11.631]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.631]                                 "release", "version")], collapse = " "), 
[17:43:11.631]                               hostname = base::Sys.info()[["nodename"]])
[17:43:11.631]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.631]                               info)
[17:43:11.631]                             info <- base::paste(info, collapse = "; ")
[17:43:11.631]                             if (!has_future) {
[17:43:11.631]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.631]                                 info)
[17:43:11.631]                             }
[17:43:11.631]                             else {
[17:43:11.631]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.631]                                 info, version)
[17:43:11.631]                             }
[17:43:11.631]                             base::stop(msg)
[17:43:11.631]                           }
[17:43:11.631]                         })
[17:43:11.631]                       }
[17:43:11.631]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:11.631]                       base::options(mc.cores = 1L)
[17:43:11.631]                     }
[17:43:11.631]                     base::local({
[17:43:11.631]                       for (pkg in "future") {
[17:43:11.631]                         base::loadNamespace(pkg)
[17:43:11.631]                         base::library(pkg, character.only = TRUE)
[17:43:11.631]                       }
[17:43:11.631]                     })
[17:43:11.631]                   }
[17:43:11.631]                   options(future.plan = NULL)
[17:43:11.631]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.631]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.631]                     envir = parent.frame()) 
[17:43:11.631]                   {
[17:43:11.631]                     default_workers <- missing(workers)
[17:43:11.631]                     if (is.function(workers)) 
[17:43:11.631]                       workers <- workers()
[17:43:11.631]                     workers <- structure(as.integer(workers), 
[17:43:11.631]                       class = class(workers))
[17:43:11.631]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.631]                       1L)
[17:43:11.631]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.631]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.631]                       if (default_workers) 
[17:43:11.631]                         supportsMulticore(warn = TRUE)
[17:43:11.631]                       return(sequential(..., envir = envir))
[17:43:11.631]                     }
[17:43:11.631]                     oopts <- options(mc.cores = workers)
[17:43:11.631]                     on.exit(options(oopts))
[17:43:11.631]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.631]                       envir = envir)
[17:43:11.631]                     if (!future$lazy) 
[17:43:11.631]                       future <- run(future)
[17:43:11.631]                     invisible(future)
[17:43:11.631]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.631]                 }
[17:43:11.631]                 ...future.workdir <- getwd()
[17:43:11.631]             }
[17:43:11.631]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.631]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.631]         }
[17:43:11.631]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.631]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.631]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.631]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.631]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.631]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.631]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.631]             base::names(...future.oldOptions))
[17:43:11.631]     }
[17:43:11.631]     if (FALSE) {
[17:43:11.631]     }
[17:43:11.631]     else {
[17:43:11.631]         if (TRUE) {
[17:43:11.631]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.631]                 open = "w")
[17:43:11.631]         }
[17:43:11.631]         else {
[17:43:11.631]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.631]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.631]         }
[17:43:11.631]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.631]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.631]             base::sink(type = "output", split = FALSE)
[17:43:11.631]             base::close(...future.stdout)
[17:43:11.631]         }, add = TRUE)
[17:43:11.631]     }
[17:43:11.631]     ...future.frame <- base::sys.nframe()
[17:43:11.631]     ...future.conditions <- base::list()
[17:43:11.631]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.631]     if (FALSE) {
[17:43:11.631]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.631]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.631]     }
[17:43:11.631]     ...future.result <- base::tryCatch({
[17:43:11.631]         base::withCallingHandlers({
[17:43:11.631]             ...future.value <- base::withVisible(base::local({
[17:43:11.631]                 withCallingHandlers({
[17:43:11.631]                   {
[17:43:11.631]                     value(future(subset(data, a == 2)))
[17:43:11.631]                   }
[17:43:11.631]                 }, immediateCondition = function(cond) {
[17:43:11.631]                   save_rds <- function (object, pathname, ...) 
[17:43:11.631]                   {
[17:43:11.631]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:11.631]                     if (file_test("-f", pathname_tmp)) {
[17:43:11.631]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.631]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:11.631]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.631]                         fi_tmp[["mtime"]])
[17:43:11.631]                     }
[17:43:11.631]                     tryCatch({
[17:43:11.631]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:11.631]                     }, error = function(ex) {
[17:43:11.631]                       msg <- conditionMessage(ex)
[17:43:11.631]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.631]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:11.631]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.631]                         fi_tmp[["mtime"]], msg)
[17:43:11.631]                       ex$message <- msg
[17:43:11.631]                       stop(ex)
[17:43:11.631]                     })
[17:43:11.631]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:11.631]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:11.631]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:11.631]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.631]                       fi <- file.info(pathname)
[17:43:11.631]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:11.631]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.631]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:11.631]                         fi[["size"]], fi[["mtime"]])
[17:43:11.631]                       stop(msg)
[17:43:11.631]                     }
[17:43:11.631]                     invisible(pathname)
[17:43:11.631]                   }
[17:43:11.631]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:11.631]                     rootPath = tempdir()) 
[17:43:11.631]                   {
[17:43:11.631]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:11.631]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:11.631]                       tmpdir = path, fileext = ".rds")
[17:43:11.631]                     save_rds(obj, file)
[17:43:11.631]                   }
[17:43:11.631]                   saveImmediateCondition(cond, path = "/tmp/RtmpzPUCYD/.future/immediateConditions")
[17:43:11.631]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.631]                   {
[17:43:11.631]                     inherits <- base::inherits
[17:43:11.631]                     invokeRestart <- base::invokeRestart
[17:43:11.631]                     is.null <- base::is.null
[17:43:11.631]                     muffled <- FALSE
[17:43:11.631]                     if (inherits(cond, "message")) {
[17:43:11.631]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:11.631]                       if (muffled) 
[17:43:11.631]                         invokeRestart("muffleMessage")
[17:43:11.631]                     }
[17:43:11.631]                     else if (inherits(cond, "warning")) {
[17:43:11.631]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:11.631]                       if (muffled) 
[17:43:11.631]                         invokeRestart("muffleWarning")
[17:43:11.631]                     }
[17:43:11.631]                     else if (inherits(cond, "condition")) {
[17:43:11.631]                       if (!is.null(pattern)) {
[17:43:11.631]                         computeRestarts <- base::computeRestarts
[17:43:11.631]                         grepl <- base::grepl
[17:43:11.631]                         restarts <- computeRestarts(cond)
[17:43:11.631]                         for (restart in restarts) {
[17:43:11.631]                           name <- restart$name
[17:43:11.631]                           if (is.null(name)) 
[17:43:11.631]                             next
[17:43:11.631]                           if (!grepl(pattern, name)) 
[17:43:11.631]                             next
[17:43:11.631]                           invokeRestart(restart)
[17:43:11.631]                           muffled <- TRUE
[17:43:11.631]                           break
[17:43:11.631]                         }
[17:43:11.631]                       }
[17:43:11.631]                     }
[17:43:11.631]                     invisible(muffled)
[17:43:11.631]                   }
[17:43:11.631]                   muffleCondition(cond)
[17:43:11.631]                 })
[17:43:11.631]             }))
[17:43:11.631]             future::FutureResult(value = ...future.value$value, 
[17:43:11.631]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.631]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.631]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.631]                     ...future.globalenv.names))
[17:43:11.631]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.631]         }, condition = base::local({
[17:43:11.631]             c <- base::c
[17:43:11.631]             inherits <- base::inherits
[17:43:11.631]             invokeRestart <- base::invokeRestart
[17:43:11.631]             length <- base::length
[17:43:11.631]             list <- base::list
[17:43:11.631]             seq.int <- base::seq.int
[17:43:11.631]             signalCondition <- base::signalCondition
[17:43:11.631]             sys.calls <- base::sys.calls
[17:43:11.631]             `[[` <- base::`[[`
[17:43:11.631]             `+` <- base::`+`
[17:43:11.631]             `<<-` <- base::`<<-`
[17:43:11.631]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.631]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.631]                   3L)]
[17:43:11.631]             }
[17:43:11.631]             function(cond) {
[17:43:11.631]                 is_error <- inherits(cond, "error")
[17:43:11.631]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.631]                   NULL)
[17:43:11.631]                 if (is_error) {
[17:43:11.631]                   sessionInformation <- function() {
[17:43:11.631]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.631]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.631]                       search = base::search(), system = base::Sys.info())
[17:43:11.631]                   }
[17:43:11.631]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.631]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.631]                     cond$call), session = sessionInformation(), 
[17:43:11.631]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.631]                   signalCondition(cond)
[17:43:11.631]                 }
[17:43:11.631]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.631]                 "immediateCondition"))) {
[17:43:11.631]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.631]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.631]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.631]                   if (TRUE && !signal) {
[17:43:11.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.631]                     {
[17:43:11.631]                       inherits <- base::inherits
[17:43:11.631]                       invokeRestart <- base::invokeRestart
[17:43:11.631]                       is.null <- base::is.null
[17:43:11.631]                       muffled <- FALSE
[17:43:11.631]                       if (inherits(cond, "message")) {
[17:43:11.631]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.631]                         if (muffled) 
[17:43:11.631]                           invokeRestart("muffleMessage")
[17:43:11.631]                       }
[17:43:11.631]                       else if (inherits(cond, "warning")) {
[17:43:11.631]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.631]                         if (muffled) 
[17:43:11.631]                           invokeRestart("muffleWarning")
[17:43:11.631]                       }
[17:43:11.631]                       else if (inherits(cond, "condition")) {
[17:43:11.631]                         if (!is.null(pattern)) {
[17:43:11.631]                           computeRestarts <- base::computeRestarts
[17:43:11.631]                           grepl <- base::grepl
[17:43:11.631]                           restarts <- computeRestarts(cond)
[17:43:11.631]                           for (restart in restarts) {
[17:43:11.631]                             name <- restart$name
[17:43:11.631]                             if (is.null(name)) 
[17:43:11.631]                               next
[17:43:11.631]                             if (!grepl(pattern, name)) 
[17:43:11.631]                               next
[17:43:11.631]                             invokeRestart(restart)
[17:43:11.631]                             muffled <- TRUE
[17:43:11.631]                             break
[17:43:11.631]                           }
[17:43:11.631]                         }
[17:43:11.631]                       }
[17:43:11.631]                       invisible(muffled)
[17:43:11.631]                     }
[17:43:11.631]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.631]                   }
[17:43:11.631]                 }
[17:43:11.631]                 else {
[17:43:11.631]                   if (TRUE) {
[17:43:11.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.631]                     {
[17:43:11.631]                       inherits <- base::inherits
[17:43:11.631]                       invokeRestart <- base::invokeRestart
[17:43:11.631]                       is.null <- base::is.null
[17:43:11.631]                       muffled <- FALSE
[17:43:11.631]                       if (inherits(cond, "message")) {
[17:43:11.631]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.631]                         if (muffled) 
[17:43:11.631]                           invokeRestart("muffleMessage")
[17:43:11.631]                       }
[17:43:11.631]                       else if (inherits(cond, "warning")) {
[17:43:11.631]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.631]                         if (muffled) 
[17:43:11.631]                           invokeRestart("muffleWarning")
[17:43:11.631]                       }
[17:43:11.631]                       else if (inherits(cond, "condition")) {
[17:43:11.631]                         if (!is.null(pattern)) {
[17:43:11.631]                           computeRestarts <- base::computeRestarts
[17:43:11.631]                           grepl <- base::grepl
[17:43:11.631]                           restarts <- computeRestarts(cond)
[17:43:11.631]                           for (restart in restarts) {
[17:43:11.631]                             name <- restart$name
[17:43:11.631]                             if (is.null(name)) 
[17:43:11.631]                               next
[17:43:11.631]                             if (!grepl(pattern, name)) 
[17:43:11.631]                               next
[17:43:11.631]                             invokeRestart(restart)
[17:43:11.631]                             muffled <- TRUE
[17:43:11.631]                             break
[17:43:11.631]                           }
[17:43:11.631]                         }
[17:43:11.631]                       }
[17:43:11.631]                       invisible(muffled)
[17:43:11.631]                     }
[17:43:11.631]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.631]                   }
[17:43:11.631]                 }
[17:43:11.631]             }
[17:43:11.631]         }))
[17:43:11.631]     }, error = function(ex) {
[17:43:11.631]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.631]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.631]                 ...future.rng), started = ...future.startTime, 
[17:43:11.631]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.631]             version = "1.8"), class = "FutureResult")
[17:43:11.631]     }, finally = {
[17:43:11.631]         if (!identical(...future.workdir, getwd())) 
[17:43:11.631]             setwd(...future.workdir)
[17:43:11.631]         {
[17:43:11.631]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.631]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.631]             }
[17:43:11.631]             base::options(...future.oldOptions)
[17:43:11.631]             if (.Platform$OS.type == "windows") {
[17:43:11.631]                 old_names <- names(...future.oldEnvVars)
[17:43:11.631]                 envs <- base::Sys.getenv()
[17:43:11.631]                 names <- names(envs)
[17:43:11.631]                 common <- intersect(names, old_names)
[17:43:11.631]                 added <- setdiff(names, old_names)
[17:43:11.631]                 removed <- setdiff(old_names, names)
[17:43:11.631]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.631]                   envs[common]]
[17:43:11.631]                 NAMES <- toupper(changed)
[17:43:11.631]                 args <- list()
[17:43:11.631]                 for (kk in seq_along(NAMES)) {
[17:43:11.631]                   name <- changed[[kk]]
[17:43:11.631]                   NAME <- NAMES[[kk]]
[17:43:11.631]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.631]                     next
[17:43:11.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.631]                 }
[17:43:11.631]                 NAMES <- toupper(added)
[17:43:11.631]                 for (kk in seq_along(NAMES)) {
[17:43:11.631]                   name <- added[[kk]]
[17:43:11.631]                   NAME <- NAMES[[kk]]
[17:43:11.631]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.631]                     next
[17:43:11.631]                   args[[name]] <- ""
[17:43:11.631]                 }
[17:43:11.631]                 NAMES <- toupper(removed)
[17:43:11.631]                 for (kk in seq_along(NAMES)) {
[17:43:11.631]                   name <- removed[[kk]]
[17:43:11.631]                   NAME <- NAMES[[kk]]
[17:43:11.631]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.631]                     next
[17:43:11.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.631]                 }
[17:43:11.631]                 if (length(args) > 0) 
[17:43:11.631]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.631]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.631]             }
[17:43:11.631]             else {
[17:43:11.631]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.631]             }
[17:43:11.631]             {
[17:43:11.631]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.631]                   0L) {
[17:43:11.631]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.631]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.631]                   base::options(opts)
[17:43:11.631]                 }
[17:43:11.631]                 {
[17:43:11.631]                   {
[17:43:11.631]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:11.631]                     NULL
[17:43:11.631]                   }
[17:43:11.631]                   options(future.plan = NULL)
[17:43:11.631]                   if (is.na(NA_character_)) 
[17:43:11.631]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.631]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.631]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.631]                     envir = parent.frame()) 
[17:43:11.631]                   {
[17:43:11.631]                     default_workers <- missing(workers)
[17:43:11.631]                     if (is.function(workers)) 
[17:43:11.631]                       workers <- workers()
[17:43:11.631]                     workers <- structure(as.integer(workers), 
[17:43:11.631]                       class = class(workers))
[17:43:11.631]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.631]                       1L)
[17:43:11.631]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.631]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.631]                       if (default_workers) 
[17:43:11.631]                         supportsMulticore(warn = TRUE)
[17:43:11.631]                       return(sequential(..., envir = envir))
[17:43:11.631]                     }
[17:43:11.631]                     oopts <- options(mc.cores = workers)
[17:43:11.631]                     on.exit(options(oopts))
[17:43:11.631]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.631]                       envir = envir)
[17:43:11.631]                     if (!future$lazy) 
[17:43:11.631]                       future <- run(future)
[17:43:11.631]                     invisible(future)
[17:43:11.631]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.631]                     envir = parent.frame()) 
[17:43:11.631]                   {
[17:43:11.631]                     default_workers <- missing(workers)
[17:43:11.631]                     if (is.function(workers)) 
[17:43:11.631]                       workers <- workers()
[17:43:11.631]                     workers <- structure(as.integer(workers), 
[17:43:11.631]                       class = class(workers))
[17:43:11.631]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.631]                       1L)
[17:43:11.631]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.631]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.631]                       if (default_workers) 
[17:43:11.631]                         supportsMulticore(warn = TRUE)
[17:43:11.631]                       return(sequential(..., envir = envir))
[17:43:11.631]                     }
[17:43:11.631]                     oopts <- options(mc.cores = workers)
[17:43:11.631]                     on.exit(options(oopts))
[17:43:11.631]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.631]                       envir = envir)
[17:43:11.631]                     if (!future$lazy) 
[17:43:11.631]                       future <- run(future)
[17:43:11.631]                     invisible(future)
[17:43:11.631]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.631]                 }
[17:43:11.631]             }
[17:43:11.631]         }
[17:43:11.631]     })
[17:43:11.631]     if (TRUE) {
[17:43:11.631]         base::sink(type = "output", split = FALSE)
[17:43:11.631]         if (TRUE) {
[17:43:11.631]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.631]         }
[17:43:11.631]         else {
[17:43:11.631]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.631]         }
[17:43:11.631]         base::close(...future.stdout)
[17:43:11.631]         ...future.stdout <- NULL
[17:43:11.631]     }
[17:43:11.631]     ...future.result$conditions <- ...future.conditions
[17:43:11.631]     ...future.result$finished <- base::Sys.time()
[17:43:11.631]     ...future.result
[17:43:11.631] }
[17:43:11.635] assign_globals() ...
[17:43:11.635] List of 1
[17:43:11.635]  $ data:'data.frame':	3 obs. of  2 variables:
[17:43:11.635]   ..$ a: int [1:3] 1 2 3
[17:43:11.635]   ..$ b: int [1:3] 3 2 1
[17:43:11.635]  - attr(*, "where")=List of 1
[17:43:11.635]   ..$ data:<environment: R_EmptyEnv> 
[17:43:11.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.635]  - attr(*, "resolved")= logi FALSE
[17:43:11.635]  - attr(*, "total_size")= num 128
[17:43:11.635]  - attr(*, "already-done")= logi TRUE
[17:43:11.639] - copied ‘data’ to environment
[17:43:11.639] assign_globals() ... done
[17:43:11.639] requestCore(): workers = 2
[17:43:11.642] MulticoreFuture started
[17:43:11.642] - Launch lazy future ... done
[17:43:11.642] run() for ‘MulticoreFuture’ ... done
[17:43:11.643] plan(): Setting new future strategy stack:
[17:43:11.643] List of future strategies:
[17:43:11.643] 1. multicore:
[17:43:11.643]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.643]    - tweaked: FALSE
[17:43:11.643]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.650] plan(): nbrOfWorkers() = 1
[17:43:11.686] plan(): Setting new future strategy stack:
[17:43:11.686] List of future strategies:
[17:43:11.686] 1. multicore:
[17:43:11.686]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.686]    - tweaked: FALSE
[17:43:11.686]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.686] 2. multicore:
[17:43:11.686]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.686]    - tweaked: FALSE
[17:43:11.686]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.690] plan(): nbrOfWorkers() = 2
[17:43:11.691] signalConditions() ...
[17:43:11.691]  - include = ‘immediateCondition’
[17:43:11.691]  - exclude = 
[17:43:11.691]  - resignal = FALSE
[17:43:11.692]  - Number of conditions: 52
[17:43:11.692] signalConditions() ... done
[17:43:11.692] signalConditions() ...
[17:43:11.692]  - include = ‘immediateCondition’
[17:43:11.692]  - exclude = 
[17:43:11.692]  - resignal = FALSE
[17:43:11.692]  - Number of conditions: 52
[17:43:11.693] signalConditions() ... done
[17:43:11.693] Future state: ‘finished’
[17:43:11.693] signalConditions() ...
[17:43:11.693]  - include = ‘condition’
[17:43:11.693]  - exclude = ‘immediateCondition’
[17:43:11.694]  - resignal = TRUE
[17:43:11.694]  - Number of conditions: 52
[17:43:11.694]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.650] getGlobalsAndPackages() ...
[17:43:11.694]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.651] Searching for globals...
[17:43:11.694]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.653] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:11.694]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.653] Searching for globals ... DONE
[17:43:11.694]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.653] Resolving globals: FALSE
[17:43:11.695]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.654] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:11.695]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.654] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:11.695]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.655] - globals: [1] ‘data’
[17:43:11.695]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.655] 
[17:43:11.695]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.655] getGlobalsAndPackages() ... DONE
[17:43:11.695]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.656] run() for ‘Future’ ...
[17:43:11.696]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.656] - state: ‘created’
[17:43:11.696]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.656] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.696]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.660] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:11.696]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.660] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:11.696]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.661]   - Field: ‘label’
[17:43:11.696]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.661]   - Field: ‘local’
[17:43:11.697]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.661]   - Field: ‘owner’
[17:43:11.697]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.661]   - Field: ‘envir’
[17:43:11.697]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.661]   - Field: ‘packages’
[17:43:11.697]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.662]   - Field: ‘gc’
[17:43:11.697]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.662]   - Field: ‘conditions’
[17:43:11.697]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.662]   - Field: ‘expr’
[17:43:11.698]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.662]   - Field: ‘uuid’
[17:43:11.698]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.662]   - Field: ‘seed’
[17:43:11.698]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.662]   - Field: ‘version’
[17:43:11.698]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.662]   - Field: ‘result’
[17:43:11.698]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.663]   - Field: ‘asynchronous’
[17:43:11.698]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.663]   - Field: ‘calls’
[17:43:11.699]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.663]   - Field: ‘globals’
[17:43:11.699]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.663]   - Field: ‘stdout’
[17:43:11.699]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.663]   - Field: ‘earlySignal’
[17:43:11.699]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.663]   - Field: ‘lazy’
[17:43:11.699]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.664]   - Field: ‘state’
[17:43:11.699]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.664] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:11.699]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.664] - Launch lazy future ...
[17:43:11.700]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.664] Packages needed by the future expression (n = 0): <none>
[17:43:11.700]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.664] Packages needed by future strategies (n = 0): <none>
[17:43:11.700]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.665] {
[17:43:11.665]     {
[17:43:11.665]         {
[17:43:11.665]             ...future.startTime <- base::Sys.time()
[17:43:11.665]             {
[17:43:11.665]                 {
[17:43:11.665]                   {
[17:43:11.665]                     base::local({
[17:43:11.665]                       has_future <- base::requireNamespace("future", 
[17:43:11.665]                         quietly = TRUE)
[17:43:11.665]                       if (has_future) {
[17:43:11.665]                         ns <- base::getNamespace("future")
[17:43:11.665]                         version <- ns[[".package"]][["version"]]
[17:43:11.665]                         if (is.null(version)) 
[17:43:11.665]                           version <- utils::packageVersion("future")
[17:43:11.665]                       }
[17:43:11.665]                       else {
[17:43:11.665]                         version <- NULL
[17:43:11.665]                       }
[17:43:11.665]                       if (!has_future || version < "1.8.0") {
[17:43:11.665]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.665]                           "", base::R.version$version.string), 
[17:43:11.665]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:11.665]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:11.665]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.665]                             "release", "version")], collapse = " "), 
[17:43:11.665]                           hostname = base::Sys.info()[["nodename"]])
[17:43:11.665]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.665]                           info)
[17:43:11.665]                         info <- base::paste(info, collapse = "; ")
[17:43:11.665]                         if (!has_future) {
[17:43:11.665]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.665]                             info)
[17:43:11.665]                         }
[17:43:11.665]                         else {
[17:43:11.665]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.665]                             info, version)
[17:43:11.665]                         }
[17:43:11.665]                         base::stop(msg)
[17:43:11.665]                       }
[17:43:11.665]                     })
[17:43:11.665]                   }
[17:43:11.665]                   options(future.plan = NULL)
[17:43:11.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:11.665]                 }
[17:43:11.665]                 ...future.workdir <- getwd()
[17:43:11.665]             }
[17:43:11.665]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.665]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.665]         }
[17:43:11.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.665]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.665]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.665]             base::names(...future.oldOptions))
[17:43:11.665]     }
[17:43:11.665]     if (FALSE) {
[17:43:11.665]     }
[17:43:11.665]     else {
[17:43:11.665]         if (TRUE) {
[17:43:11.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.665]                 open = "w")
[17:43:11.665]         }
[17:43:11.665]         else {
[17:43:11.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.665]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.665]         }
[17:43:11.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.665]             base::sink(type = "output", split = FALSE)
[17:43:11.665]             base::close(...future.stdout)
[17:43:11.665]         }, add = TRUE)
[17:43:11.665]     }
[17:43:11.665]     ...future.frame <- base::sys.nframe()
[17:43:11.665]     ...future.conditions <- base::list()
[17:43:11.665]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.665]     if (FALSE) {
[17:43:11.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.665]     }
[17:43:11.665]     ...future.result <- base::tryCatch({
[17:43:11.665]         base::withCallingHandlers({
[17:43:11.665]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:43:11.665]                 a == 2)))
[17:43:11.665]             future::FutureResult(value = ...future.value$value, 
[17:43:11.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.665]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.665]                     ...future.globalenv.names))
[17:43:11.665]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.665]         }, condition = base::local({
[17:43:11.665]             c <- base::c
[17:43:11.665]             inherits <- base::inherits
[17:43:11.665]             invokeRestart <- base::invokeRestart
[17:43:11.665]             length <- base::length
[17:43:11.665]             list <- base::list
[17:43:11.665]             seq.int <- base::seq.int
[17:43:11.665]             signalCondition <- base::signalCondition
[17:43:11.665]             sys.calls <- base::sys.calls
[17:43:11.665]             `[[` <- base::`[[`
[17:43:11.665]             `+` <- base::`+`
[17:43:11.665]             `<<-` <- base::`<<-`
[17:43:11.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.665]                   3L)]
[17:43:11.665]             }
[17:43:11.665]             function(cond) {
[17:43:11.665]                 is_error <- inherits(cond, "error")
[17:43:11.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.665]                   NULL)
[17:43:11.665]                 if (is_error) {
[17:43:11.665]                   sessionInformation <- function() {
[17:43:11.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.665]                       search = base::search(), system = base::Sys.info())
[17:43:11.665]                   }
[17:43:11.665]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.665]                     cond$call), session = sessionInformation(), 
[17:43:11.665]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.665]                   signalCondition(cond)
[17:43:11.665]                 }
[17:43:11.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.665]                 "immediateCondition"))) {
[17:43:11.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.665]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.665]                   if (TRUE && !signal) {
[17:43:11.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.665]                     {
[17:43:11.665]                       inherits <- base::inherits
[17:43:11.665]                       invokeRestart <- base::invokeRestart
[17:43:11.665]                       is.null <- base::is.null
[17:43:11.665]                       muffled <- FALSE
[17:43:11.665]                       if (inherits(cond, "message")) {
[17:43:11.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.665]                         if (muffled) 
[17:43:11.665]                           invokeRestart("muffleMessage")
[17:43:11.665]                       }
[17:43:11.665]                       else if (inherits(cond, "warning")) {
[17:43:11.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.665]                         if (muffled) 
[17:43:11.665]                           invokeRestart("muffleWarning")
[17:43:11.665]                       }
[17:43:11.665]                       else if (inherits(cond, "condition")) {
[17:43:11.665]                         if (!is.null(pattern)) {
[17:43:11.665]                           computeRestarts <- base::computeRestarts
[17:43:11.665]                           grepl <- base::grepl
[17:43:11.665]                           restarts <- computeRestarts(cond)
[17:43:11.665]                           for (restart in restarts) {
[17:43:11.665]                             name <- restart$name
[17:43:11.665]                             if (is.null(name)) 
[17:43:11.665]                               next
[17:43:11.665]                             if (!grepl(pattern, name)) 
[17:43:11.665]                               next
[17:43:11.665]                             invokeRestart(restart)
[17:43:11.665]                             muffled <- TRUE
[17:43:11.665]                             break
[17:43:11.665]                           }
[17:43:11.665]                         }
[17:43:11.665]                       }
[17:43:11.665]                       invisible(muffled)
[17:43:11.665]                     }
[17:43:11.665]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.665]                   }
[17:43:11.665]                 }
[17:43:11.665]                 else {
[17:43:11.665]                   if (TRUE) {
[17:43:11.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.665]                     {
[17:43:11.665]                       inherits <- base::inherits
[17:43:11.665]                       invokeRestart <- base::invokeRestart
[17:43:11.665]                       is.null <- base::is.null
[17:43:11.665]                       muffled <- FALSE
[17:43:11.665]                       if (inherits(cond, "message")) {
[17:43:11.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.665]                         if (muffled) 
[17:43:11.665]                           invokeRestart("muffleMessage")
[17:43:11.665]                       }
[17:43:11.665]                       else if (inherits(cond, "warning")) {
[17:43:11.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.665]                         if (muffled) 
[17:43:11.665]                           invokeRestart("muffleWarning")
[17:43:11.665]                       }
[17:43:11.665]                       else if (inherits(cond, "condition")) {
[17:43:11.665]                         if (!is.null(pattern)) {
[17:43:11.665]                           computeRestarts <- base::computeRestarts
[17:43:11.665]                           grepl <- base::grepl
[17:43:11.665]                           restarts <- computeRestarts(cond)
[17:43:11.665]                           for (restart in restarts) {
[17:43:11.665]                             name <- restart$name
[17:43:11.665]                             if (is.null(name)) 
[17:43:11.665]                               next
[17:43:11.665]                             if (!grepl(pattern, name)) 
[17:43:11.665]                               next
[17:43:11.665]                             invokeRestart(restart)
[17:43:11.665]                             muffled <- TRUE
[17:43:11.665]                             break
[17:43:11.665]                           }
[17:43:11.665]                         }
[17:43:11.665]                       }
[17:43:11.665]                       invisible(muffled)
[17:43:11.665]                     }
[17:43:11.665]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.665]                   }
[17:43:11.665]                 }
[17:43:11.665]             }
[17:43:11.665]         }))
[17:43:11.665]     }, error = function(ex) {
[17:43:11.665]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.665]                 ...future.rng), started = ...future.startTime, 
[17:43:11.665]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.665]             version = "1.8"), class = "FutureResult")
[17:43:11.665]     }, finally = {
[17:43:11.665]         if (!identical(...future.workdir, getwd())) 
[17:43:11.665]             setwd(...future.workdir)
[17:43:11.665]         {
[17:43:11.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.665]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.665]             }
[17:43:11.665]             base::options(...future.oldOptions)
[17:43:11.665]             if (.Platform$OS.type == "windows") {
[17:43:11.665]                 old_names <- names(...future.oldEnvVars)
[17:43:11.665]                 envs <- base::Sys.getenv()
[17:43:11.665]                 names <- names(envs)
[17:43:11.665]                 common <- intersect(names, old_names)
[17:43:11.665]                 added <- setdiff(names, old_names)
[17:43:11.665]                 removed <- setdiff(old_names, names)
[17:43:11.665]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.665]                   envs[common]]
[17:43:11.665]                 NAMES <- toupper(changed)
[17:43:11.665]                 args <- list()
[17:43:11.665]                 for (kk in seq_along(NAMES)) {
[17:43:11.665]                   name <- changed[[kk]]
[17:43:11.665]                   NAME <- NAMES[[kk]]
[17:43:11.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.665]                     next
[17:43:11.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.665]                 }
[17:43:11.665]                 NAMES <- toupper(added)
[17:43:11.665]                 for (kk in seq_along(NAMES)) {
[17:43:11.665]                   name <- added[[kk]]
[17:43:11.665]                   NAME <- NAMES[[kk]]
[17:43:11.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.665]                     next
[17:43:11.665]                   args[[name]] <- ""
[17:43:11.665]                 }
[17:43:11.665]                 NAMES <- toupper(removed)
[17:43:11.665]                 for (kk in seq_along(NAMES)) {
[17:43:11.665]                   name <- removed[[kk]]
[17:43:11.665]                   NAME <- NAMES[[kk]]
[17:43:11.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.665]                     next
[17:43:11.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.665]                 }
[17:43:11.665]                 if (length(args) > 0) 
[17:43:11.665]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.665]             }
[17:43:11.665]             else {
[17:43:11.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.665]             }
[17:43:11.665]             {
[17:43:11.665]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.665]                   0L) {
[17:43:11.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.665]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.665]                   base::options(opts)
[17:43:11.665]                 }
[17:43:11.665]                 {
[17:43:11.665]                   {
[17:43:11.665]                     NULL
[17:43:11.665]                     RNGkind("Mersenne-Twister")
[17:43:11.665]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:11.665]                       inherits = FALSE)
[17:43:11.665]                   }
[17:43:11.665]                   options(future.plan = NULL)
[17:43:11.665]                   if (is.na(NA_character_)) 
[17:43:11.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.665]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.665]                     envir = parent.frame()) 
[17:43:11.665]                   {
[17:43:11.665]                     default_workers <- missing(workers)
[17:43:11.665]                     if (is.function(workers)) 
[17:43:11.665]                       workers <- workers()
[17:43:11.665]                     workers <- structure(as.integer(workers), 
[17:43:11.665]                       class = class(workers))
[17:43:11.665]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.665]                       1L)
[17:43:11.665]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.665]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.665]                       if (default_workers) 
[17:43:11.665]                         supportsMulticore(warn = TRUE)
[17:43:11.665]                       return(sequential(..., envir = envir))
[17:43:11.665]                     }
[17:43:11.665]                     oopts <- options(mc.cores = workers)
[17:43:11.665]                     on.exit(options(oopts))
[17:43:11.665]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.665]                       envir = envir)
[17:43:11.665]                     if (!future$lazy) 
[17:43:11.665]                       future <- run(future)
[17:43:11.665]                     invisible(future)
[17:43:11.665]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.665]                 }
[17:43:11.665]             }
[17:43:11.665]         }
[17:43:11.665]     })
[17:43:11.665]     if (TRUE) {
[17:43:11.665]         base::sink(type = "output", split = FALSE)
[17:43:11.665]         if (TRUE) {
[17:43:11.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.665]         }
[17:43:11.665]         else {
[17:43:11.665]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.665]         }
[17:43:11.665]         base::close(...future.stdout)
[17:43:11.665]         ...future.stdout <- NULL
[17:43:11.665]     }
[17:43:11.665]     ...future.result$conditions <- ...future.conditions
[17:43:11.665]     ...future.result$finished <- base::Sys.time()
[17:43:11.665]     ...future.result
[17:43:11.665] }
[17:43:11.700]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.667] assign_globals() ...
[17:43:11.700]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.668] List of 1
[17:43:11.668]  $ data:'data.frame':	3 obs. of  2 variables:
[17:43:11.668]   ..$ a: int [1:3] 1 2 3
[17:43:11.668]   ..$ b: int [1:3] 3 2 1
[17:43:11.668]  - attr(*, "where")=List of 1
[17:43:11.668]   ..$ data:<environment: R_EmptyEnv> 
[17:43:11.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.668]  - attr(*, "resolved")= logi FALSE
[17:43:11.668]  - attr(*, "total_size")= num 128
[17:43:11.668]  - attr(*, "already-done")= logi TRUE
[17:43:11.700]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.673] - copied ‘data’ to environment
[17:43:11.701]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.673] assign_globals() ... done
[17:43:11.701]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.673] plan(): Setting new future strategy stack:
[17:43:11.701]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.673] List of future strategies:
[17:43:11.673] 1. sequential:
[17:43:11.673]    - args: function (..., envir = parent.frame())
[17:43:11.673]    - tweaked: FALSE
[17:43:11.673]    - call: NULL
[17:43:11.701]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.674] plan(): nbrOfWorkers() = 1
[17:43:11.701]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.680] plan(): Setting new future strategy stack:
[17:43:11.701]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.680] List of future strategies:
[17:43:11.680] 1. multicore:
[17:43:11.680]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.680]    - tweaked: FALSE
[17:43:11.680]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.702]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.684] plan(): nbrOfWorkers() = 1
[17:43:11.702]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.685] SequentialFuture started (and completed)
[17:43:11.702]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.685] - Launch lazy future ... done
[17:43:11.702]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.685] run() for ‘SequentialFuture’ ... done
[17:43:11.702] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[17:43:11.703] plan(): Setting new future strategy stack:
[17:43:11.703] List of future strategies:
[17:43:11.703] 1. multicore:
[17:43:11.703]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.703]    - tweaked: FALSE
[17:43:11.703]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.703] 2. multisession:
[17:43:11.703]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.703]    - tweaked: FALSE
[17:43:11.703]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.708] plan(): nbrOfWorkers() = 2
[17:43:11.708] getGlobalsAndPackages() ...
[17:43:11.708] Searching for globals...
[17:43:11.732] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:43:11.732] Searching for globals ... DONE
[17:43:11.732] Resolving globals: FALSE
[17:43:11.733] The total size of the 2 globals is 90.64 KiB (92816 bytes)
[17:43:11.734] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.52 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:43:11.734] - globals: [2] ‘nested’, ‘strategy2’
[17:43:11.734] - packages: [1] ‘future’
[17:43:11.734] getGlobalsAndPackages() ... DONE
[17:43:11.735] run() for ‘Future’ ...
[17:43:11.735] - state: ‘created’
[17:43:11.735] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.739] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:11.739] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:11.740]   - Field: ‘label’
[17:43:11.740]   - Field: ‘local’
[17:43:11.740]   - Field: ‘owner’
[17:43:11.740]   - Field: ‘envir’
[17:43:11.740]   - Field: ‘workers’
[17:43:11.740]   - Field: ‘packages’
[17:43:11.740]   - Field: ‘gc’
[17:43:11.740]   - Field: ‘job’
[17:43:11.741]   - Field: ‘conditions’
[17:43:11.741]   - Field: ‘expr’
[17:43:11.741]   - Field: ‘uuid’
[17:43:11.741]   - Field: ‘seed’
[17:43:11.741]   - Field: ‘version’
[17:43:11.741]   - Field: ‘result’
[17:43:11.741]   - Field: ‘asynchronous’
[17:43:11.741]   - Field: ‘calls’
[17:43:11.741]   - Field: ‘globals’
[17:43:11.741]   - Field: ‘stdout’
[17:43:11.742]   - Field: ‘earlySignal’
[17:43:11.742]   - Field: ‘lazy’
[17:43:11.742]   - Field: ‘state’
[17:43:11.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:11.742] - Launch lazy future ...
[17:43:11.742] Packages needed by the future expression (n = 1): ‘future’
[17:43:11.743] Packages needed by future strategies (n = 1): ‘future’
[17:43:11.743] {
[17:43:11.743]     {
[17:43:11.743]         {
[17:43:11.743]             ...future.startTime <- base::Sys.time()
[17:43:11.743]             {
[17:43:11.743]                 {
[17:43:11.743]                   {
[17:43:11.743]                     {
[17:43:11.743]                       {
[17:43:11.743]                         base::local({
[17:43:11.743]                           has_future <- base::requireNamespace("future", 
[17:43:11.743]                             quietly = TRUE)
[17:43:11.743]                           if (has_future) {
[17:43:11.743]                             ns <- base::getNamespace("future")
[17:43:11.743]                             version <- ns[[".package"]][["version"]]
[17:43:11.743]                             if (is.null(version)) 
[17:43:11.743]                               version <- utils::packageVersion("future")
[17:43:11.743]                           }
[17:43:11.743]                           else {
[17:43:11.743]                             version <- NULL
[17:43:11.743]                           }
[17:43:11.743]                           if (!has_future || version < "1.8.0") {
[17:43:11.743]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.743]                               "", base::R.version$version.string), 
[17:43:11.743]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:11.743]                                 base::R.version$platform, 8 * 
[17:43:11.743]                                   base::.Machine$sizeof.pointer), 
[17:43:11.743]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.743]                                 "release", "version")], collapse = " "), 
[17:43:11.743]                               hostname = base::Sys.info()[["nodename"]])
[17:43:11.743]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.743]                               info)
[17:43:11.743]                             info <- base::paste(info, collapse = "; ")
[17:43:11.743]                             if (!has_future) {
[17:43:11.743]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.743]                                 info)
[17:43:11.743]                             }
[17:43:11.743]                             else {
[17:43:11.743]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.743]                                 info, version)
[17:43:11.743]                             }
[17:43:11.743]                             base::stop(msg)
[17:43:11.743]                           }
[17:43:11.743]                         })
[17:43:11.743]                       }
[17:43:11.743]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:11.743]                       base::options(mc.cores = 1L)
[17:43:11.743]                     }
[17:43:11.743]                     base::local({
[17:43:11.743]                       for (pkg in "future") {
[17:43:11.743]                         base::loadNamespace(pkg)
[17:43:11.743]                         base::library(pkg, character.only = TRUE)
[17:43:11.743]                       }
[17:43:11.743]                     })
[17:43:11.743]                   }
[17:43:11.743]                   options(future.plan = NULL)
[17:43:11.743]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.743]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:43:11.743]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.743]                     envir = parent.frame()) 
[17:43:11.743]                   {
[17:43:11.743]                     if (is.function(workers)) 
[17:43:11.743]                       workers <- workers()
[17:43:11.743]                     workers <- structure(as.integer(workers), 
[17:43:11.743]                       class = class(workers))
[17:43:11.743]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:11.743]                       workers >= 1)
[17:43:11.743]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:11.743]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:11.743]                     }
[17:43:11.743]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:11.743]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:11.743]                       envir = envir)
[17:43:11.743]                     if (!future$lazy) 
[17:43:11.743]                       future <- run(future)
[17:43:11.743]                     invisible(future)
[17:43:11.743]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.743]                 }
[17:43:11.743]                 ...future.workdir <- getwd()
[17:43:11.743]             }
[17:43:11.743]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.743]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.743]         }
[17:43:11.743]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.743]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.743]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.743]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.743]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.743]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.743]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.743]             base::names(...future.oldOptions))
[17:43:11.743]     }
[17:43:11.743]     if (FALSE) {
[17:43:11.743]     }
[17:43:11.743]     else {
[17:43:11.743]         if (TRUE) {
[17:43:11.743]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.743]                 open = "w")
[17:43:11.743]         }
[17:43:11.743]         else {
[17:43:11.743]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.743]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.743]         }
[17:43:11.743]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.743]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.743]             base::sink(type = "output", split = FALSE)
[17:43:11.743]             base::close(...future.stdout)
[17:43:11.743]         }, add = TRUE)
[17:43:11.743]     }
[17:43:11.743]     ...future.frame <- base::sys.nframe()
[17:43:11.743]     ...future.conditions <- base::list()
[17:43:11.743]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.743]     if (FALSE) {
[17:43:11.743]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.743]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.743]     }
[17:43:11.743]     ...future.result <- base::tryCatch({
[17:43:11.743]         base::withCallingHandlers({
[17:43:11.743]             ...future.value <- base::withVisible(base::local({
[17:43:11.743]                 withCallingHandlers({
[17:43:11.743]                   {
[17:43:11.743]                     a <- 1L
[17:43:11.743]                     plan_a <- unclass(future::plan("list"))
[17:43:11.743]                     nested_a <- nested[-1]
[17:43:11.743]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:43:11.743]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:43:11.743]                       strategy2))
[17:43:11.743]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:43:11.743]                       "init") <- NULL
[17:43:11.743]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:43:11.743]                       "init") <- NULL
[17:43:11.743]                     stopifnot(all.equal(plan_a, nested_a))
[17:43:11.743]                     y %<-% {
[17:43:11.743]                       b <- 2L
[17:43:11.743]                       plan_b <- future::plan("list")
[17:43:11.743]                       nested_b <- nested_a[-1]
[17:43:11.743]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:11.743]                         1L, inherits(plan_b[[1]], "future"), 
[17:43:11.743]                         inherits(future::plan("next"), "sequential"))
[17:43:11.743]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:11.743]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:11.743]                     }
[17:43:11.743]                     y
[17:43:11.743]                   }
[17:43:11.743]                 }, immediateCondition = function(cond) {
[17:43:11.743]                   save_rds <- function (object, pathname, ...) 
[17:43:11.743]                   {
[17:43:11.743]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:11.743]                     if (file_test("-f", pathname_tmp)) {
[17:43:11.743]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.743]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:11.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.743]                         fi_tmp[["mtime"]])
[17:43:11.743]                     }
[17:43:11.743]                     tryCatch({
[17:43:11.743]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:11.743]                     }, error = function(ex) {
[17:43:11.743]                       msg <- conditionMessage(ex)
[17:43:11.743]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.743]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:11.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.743]                         fi_tmp[["mtime"]], msg)
[17:43:11.743]                       ex$message <- msg
[17:43:11.743]                       stop(ex)
[17:43:11.743]                     })
[17:43:11.743]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:11.743]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:11.743]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:11.743]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.743]                       fi <- file.info(pathname)
[17:43:11.743]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:11.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.743]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:11.743]                         fi[["size"]], fi[["mtime"]])
[17:43:11.743]                       stop(msg)
[17:43:11.743]                     }
[17:43:11.743]                     invisible(pathname)
[17:43:11.743]                   }
[17:43:11.743]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:11.743]                     rootPath = tempdir()) 
[17:43:11.743]                   {
[17:43:11.743]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:11.743]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:11.743]                       tmpdir = path, fileext = ".rds")
[17:43:11.743]                     save_rds(obj, file)
[17:43:11.743]                   }
[17:43:11.743]                   saveImmediateCondition(cond, path = "/tmp/RtmpzPUCYD/.future/immediateConditions")
[17:43:11.743]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.743]                   {
[17:43:11.743]                     inherits <- base::inherits
[17:43:11.743]                     invokeRestart <- base::invokeRestart
[17:43:11.743]                     is.null <- base::is.null
[17:43:11.743]                     muffled <- FALSE
[17:43:11.743]                     if (inherits(cond, "message")) {
[17:43:11.743]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:11.743]                       if (muffled) 
[17:43:11.743]                         invokeRestart("muffleMessage")
[17:43:11.743]                     }
[17:43:11.743]                     else if (inherits(cond, "warning")) {
[17:43:11.743]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:11.743]                       if (muffled) 
[17:43:11.743]                         invokeRestart("muffleWarning")
[17:43:11.743]                     }
[17:43:11.743]                     else if (inherits(cond, "condition")) {
[17:43:11.743]                       if (!is.null(pattern)) {
[17:43:11.743]                         computeRestarts <- base::computeRestarts
[17:43:11.743]                         grepl <- base::grepl
[17:43:11.743]                         restarts <- computeRestarts(cond)
[17:43:11.743]                         for (restart in restarts) {
[17:43:11.743]                           name <- restart$name
[17:43:11.743]                           if (is.null(name)) 
[17:43:11.743]                             next
[17:43:11.743]                           if (!grepl(pattern, name)) 
[17:43:11.743]                             next
[17:43:11.743]                           invokeRestart(restart)
[17:43:11.743]                           muffled <- TRUE
[17:43:11.743]                           break
[17:43:11.743]                         }
[17:43:11.743]                       }
[17:43:11.743]                     }
[17:43:11.743]                     invisible(muffled)
[17:43:11.743]                   }
[17:43:11.743]                   muffleCondition(cond)
[17:43:11.743]                 })
[17:43:11.743]             }))
[17:43:11.743]             future::FutureResult(value = ...future.value$value, 
[17:43:11.743]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.743]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.743]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.743]                     ...future.globalenv.names))
[17:43:11.743]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.743]         }, condition = base::local({
[17:43:11.743]             c <- base::c
[17:43:11.743]             inherits <- base::inherits
[17:43:11.743]             invokeRestart <- base::invokeRestart
[17:43:11.743]             length <- base::length
[17:43:11.743]             list <- base::list
[17:43:11.743]             seq.int <- base::seq.int
[17:43:11.743]             signalCondition <- base::signalCondition
[17:43:11.743]             sys.calls <- base::sys.calls
[17:43:11.743]             `[[` <- base::`[[`
[17:43:11.743]             `+` <- base::`+`
[17:43:11.743]             `<<-` <- base::`<<-`
[17:43:11.743]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.743]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.743]                   3L)]
[17:43:11.743]             }
[17:43:11.743]             function(cond) {
[17:43:11.743]                 is_error <- inherits(cond, "error")
[17:43:11.743]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.743]                   NULL)
[17:43:11.743]                 if (is_error) {
[17:43:11.743]                   sessionInformation <- function() {
[17:43:11.743]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.743]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.743]                       search = base::search(), system = base::Sys.info())
[17:43:11.743]                   }
[17:43:11.743]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.743]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.743]                     cond$call), session = sessionInformation(), 
[17:43:11.743]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.743]                   signalCondition(cond)
[17:43:11.743]                 }
[17:43:11.743]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.743]                 "immediateCondition"))) {
[17:43:11.743]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.743]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.743]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.743]                   if (TRUE && !signal) {
[17:43:11.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.743]                     {
[17:43:11.743]                       inherits <- base::inherits
[17:43:11.743]                       invokeRestart <- base::invokeRestart
[17:43:11.743]                       is.null <- base::is.null
[17:43:11.743]                       muffled <- FALSE
[17:43:11.743]                       if (inherits(cond, "message")) {
[17:43:11.743]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.743]                         if (muffled) 
[17:43:11.743]                           invokeRestart("muffleMessage")
[17:43:11.743]                       }
[17:43:11.743]                       else if (inherits(cond, "warning")) {
[17:43:11.743]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.743]                         if (muffled) 
[17:43:11.743]                           invokeRestart("muffleWarning")
[17:43:11.743]                       }
[17:43:11.743]                       else if (inherits(cond, "condition")) {
[17:43:11.743]                         if (!is.null(pattern)) {
[17:43:11.743]                           computeRestarts <- base::computeRestarts
[17:43:11.743]                           grepl <- base::grepl
[17:43:11.743]                           restarts <- computeRestarts(cond)
[17:43:11.743]                           for (restart in restarts) {
[17:43:11.743]                             name <- restart$name
[17:43:11.743]                             if (is.null(name)) 
[17:43:11.743]                               next
[17:43:11.743]                             if (!grepl(pattern, name)) 
[17:43:11.743]                               next
[17:43:11.743]                             invokeRestart(restart)
[17:43:11.743]                             muffled <- TRUE
[17:43:11.743]                             break
[17:43:11.743]                           }
[17:43:11.743]                         }
[17:43:11.743]                       }
[17:43:11.743]                       invisible(muffled)
[17:43:11.743]                     }
[17:43:11.743]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.743]                   }
[17:43:11.743]                 }
[17:43:11.743]                 else {
[17:43:11.743]                   if (TRUE) {
[17:43:11.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.743]                     {
[17:43:11.743]                       inherits <- base::inherits
[17:43:11.743]                       invokeRestart <- base::invokeRestart
[17:43:11.743]                       is.null <- base::is.null
[17:43:11.743]                       muffled <- FALSE
[17:43:11.743]                       if (inherits(cond, "message")) {
[17:43:11.743]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.743]                         if (muffled) 
[17:43:11.743]                           invokeRestart("muffleMessage")
[17:43:11.743]                       }
[17:43:11.743]                       else if (inherits(cond, "warning")) {
[17:43:11.743]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.743]                         if (muffled) 
[17:43:11.743]                           invokeRestart("muffleWarning")
[17:43:11.743]                       }
[17:43:11.743]                       else if (inherits(cond, "condition")) {
[17:43:11.743]                         if (!is.null(pattern)) {
[17:43:11.743]                           computeRestarts <- base::computeRestarts
[17:43:11.743]                           grepl <- base::grepl
[17:43:11.743]                           restarts <- computeRestarts(cond)
[17:43:11.743]                           for (restart in restarts) {
[17:43:11.743]                             name <- restart$name
[17:43:11.743]                             if (is.null(name)) 
[17:43:11.743]                               next
[17:43:11.743]                             if (!grepl(pattern, name)) 
[17:43:11.743]                               next
[17:43:11.743]                             invokeRestart(restart)
[17:43:11.743]                             muffled <- TRUE
[17:43:11.743]                             break
[17:43:11.743]                           }
[17:43:11.743]                         }
[17:43:11.743]                       }
[17:43:11.743]                       invisible(muffled)
[17:43:11.743]                     }
[17:43:11.743]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.743]                   }
[17:43:11.743]                 }
[17:43:11.743]             }
[17:43:11.743]         }))
[17:43:11.743]     }, error = function(ex) {
[17:43:11.743]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.743]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.743]                 ...future.rng), started = ...future.startTime, 
[17:43:11.743]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.743]             version = "1.8"), class = "FutureResult")
[17:43:11.743]     }, finally = {
[17:43:11.743]         if (!identical(...future.workdir, getwd())) 
[17:43:11.743]             setwd(...future.workdir)
[17:43:11.743]         {
[17:43:11.743]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.743]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.743]             }
[17:43:11.743]             base::options(...future.oldOptions)
[17:43:11.743]             if (.Platform$OS.type == "windows") {
[17:43:11.743]                 old_names <- names(...future.oldEnvVars)
[17:43:11.743]                 envs <- base::Sys.getenv()
[17:43:11.743]                 names <- names(envs)
[17:43:11.743]                 common <- intersect(names, old_names)
[17:43:11.743]                 added <- setdiff(names, old_names)
[17:43:11.743]                 removed <- setdiff(old_names, names)
[17:43:11.743]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.743]                   envs[common]]
[17:43:11.743]                 NAMES <- toupper(changed)
[17:43:11.743]                 args <- list()
[17:43:11.743]                 for (kk in seq_along(NAMES)) {
[17:43:11.743]                   name <- changed[[kk]]
[17:43:11.743]                   NAME <- NAMES[[kk]]
[17:43:11.743]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.743]                     next
[17:43:11.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.743]                 }
[17:43:11.743]                 NAMES <- toupper(added)
[17:43:11.743]                 for (kk in seq_along(NAMES)) {
[17:43:11.743]                   name <- added[[kk]]
[17:43:11.743]                   NAME <- NAMES[[kk]]
[17:43:11.743]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.743]                     next
[17:43:11.743]                   args[[name]] <- ""
[17:43:11.743]                 }
[17:43:11.743]                 NAMES <- toupper(removed)
[17:43:11.743]                 for (kk in seq_along(NAMES)) {
[17:43:11.743]                   name <- removed[[kk]]
[17:43:11.743]                   NAME <- NAMES[[kk]]
[17:43:11.743]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.743]                     next
[17:43:11.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.743]                 }
[17:43:11.743]                 if (length(args) > 0) 
[17:43:11.743]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.743]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.743]             }
[17:43:11.743]             else {
[17:43:11.743]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.743]             }
[17:43:11.743]             {
[17:43:11.743]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.743]                   0L) {
[17:43:11.743]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.743]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.743]                   base::options(opts)
[17:43:11.743]                 }
[17:43:11.743]                 {
[17:43:11.743]                   {
[17:43:11.743]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:11.743]                     NULL
[17:43:11.743]                   }
[17:43:11.743]                   options(future.plan = NULL)
[17:43:11.743]                   if (is.na(NA_character_)) 
[17:43:11.743]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.743]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.743]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.743]                     envir = parent.frame()) 
[17:43:11.743]                   {
[17:43:11.743]                     default_workers <- missing(workers)
[17:43:11.743]                     if (is.function(workers)) 
[17:43:11.743]                       workers <- workers()
[17:43:11.743]                     workers <- structure(as.integer(workers), 
[17:43:11.743]                       class = class(workers))
[17:43:11.743]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.743]                       1L)
[17:43:11.743]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.743]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.743]                       if (default_workers) 
[17:43:11.743]                         supportsMulticore(warn = TRUE)
[17:43:11.743]                       return(sequential(..., envir = envir))
[17:43:11.743]                     }
[17:43:11.743]                     oopts <- options(mc.cores = workers)
[17:43:11.743]                     on.exit(options(oopts))
[17:43:11.743]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.743]                       envir = envir)
[17:43:11.743]                     if (!future$lazy) 
[17:43:11.743]                       future <- run(future)
[17:43:11.743]                     invisible(future)
[17:43:11.743]                   }, b = function (..., workers = availableCores(), 
[17:43:11.743]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.743]                     envir = parent.frame()) 
[17:43:11.743]                   {
[17:43:11.743]                     if (is.function(workers)) 
[17:43:11.743]                       workers <- workers()
[17:43:11.743]                     workers <- structure(as.integer(workers), 
[17:43:11.743]                       class = class(workers))
[17:43:11.743]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:11.743]                       workers >= 1)
[17:43:11.743]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:11.743]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:11.743]                     }
[17:43:11.743]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:11.743]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:11.743]                       envir = envir)
[17:43:11.743]                     if (!future$lazy) 
[17:43:11.743]                       future <- run(future)
[17:43:11.743]                     invisible(future)
[17:43:11.743]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.743]                 }
[17:43:11.743]             }
[17:43:11.743]         }
[17:43:11.743]     })
[17:43:11.743]     if (TRUE) {
[17:43:11.743]         base::sink(type = "output", split = FALSE)
[17:43:11.743]         if (TRUE) {
[17:43:11.743]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.743]         }
[17:43:11.743]         else {
[17:43:11.743]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.743]         }
[17:43:11.743]         base::close(...future.stdout)
[17:43:11.743]         ...future.stdout <- NULL
[17:43:11.743]     }
[17:43:11.743]     ...future.result$conditions <- ...future.conditions
[17:43:11.743]     ...future.result$finished <- base::Sys.time()
[17:43:11.743]     ...future.result
[17:43:11.743] }
[17:43:11.746] assign_globals() ...
[17:43:11.746] List of 2
[17:43:11.746]  $ nested   :List of 2
[17:43:11.746]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:43:11.746]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:43:11.746]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.746]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.746]     envir = parent.frame())  
[17:43:11.746]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:43:11.746]   .. ..- attr(*, "init")= logi TRUE
[17:43:11.746]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:43:11.746]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.746]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:11.746]  $ strategy2: chr "multisession"
[17:43:11.746]  - attr(*, "where")=List of 2
[17:43:11.746]   ..$ nested   :<environment: R_EmptyEnv> 
[17:43:11.746]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:43:11.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.746]  - attr(*, "resolved")= logi FALSE
[17:43:11.746]  - attr(*, "total_size")= num 92816
[17:43:11.746]  - attr(*, "already-done")= logi TRUE
[17:43:11.753] - copied ‘nested’ to environment
[17:43:11.753] - copied ‘strategy2’ to environment
[17:43:11.753] assign_globals() ... done
[17:43:11.753] requestCore(): workers = 2
[17:43:11.756] MulticoreFuture started
[17:43:11.756] - Launch lazy future ... done
[17:43:11.756] run() for ‘MulticoreFuture’ ... done
[17:43:11.757] plan(): Setting new future strategy stack:
[17:43:11.757] List of future strategies:
[17:43:11.757] 1. multisession:
[17:43:11.757]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.757]    - tweaked: FALSE
[17:43:11.757]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.763] plan(): nbrOfWorkers() = 1
[17:43:11.806] plan(): Setting new future strategy stack:
[17:43:11.806] List of future strategies:
[17:43:11.806] 1. multicore:
[17:43:11.806]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.806]    - tweaked: FALSE
[17:43:11.806]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.806] 2. multisession:
[17:43:11.806]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.806]    - tweaked: FALSE
[17:43:11.806]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.810] plan(): nbrOfWorkers() = 2
[17:43:11.812] signalConditions() ...
[17:43:11.812]  - include = ‘immediateCondition’
[17:43:11.812]  - exclude = 
[17:43:11.812]  - resignal = FALSE
[17:43:11.812]  - Number of conditions: 54
[17:43:11.812] signalConditions() ... done
[17:43:11.813] signalConditions() ...
[17:43:11.813]  - include = ‘immediateCondition’
[17:43:11.813]  - exclude = 
[17:43:11.813]  - resignal = FALSE
[17:43:11.813]  - Number of conditions: 54
[17:43:11.814] signalConditions() ... done
[17:43:11.814] Future state: ‘finished’
[17:43:11.814] signalConditions() ...
[17:43:11.814]  - include = ‘condition’
[17:43:11.814]  - exclude = ‘immediateCondition’
[17:43:11.814]  - resignal = TRUE
[17:43:11.815]  - Number of conditions: 54
[17:43:11.815]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.765] getGlobalsAndPackages() ...
[17:43:11.815]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.766] Searching for globals...
[17:43:11.815]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.773] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:43:11.816]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.774] Searching for globals ... DONE
[17:43:11.816]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.774] Resolving globals: FALSE
[17:43:11.816]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.775] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[17:43:11.817]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.776] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:43:11.817]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.776] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:43:11.817]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.776] 
[17:43:11.817]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.776] getGlobalsAndPackages() ... DONE
[17:43:11.817]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.777] run() for ‘Future’ ...
[17:43:11.817]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.777] - state: ‘created’
[17:43:11.818]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.778] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.818]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.782] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:11.818]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.782] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:11.818]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.783]   - Field: ‘label’
[17:43:11.818]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.783]   - Field: ‘local’
[17:43:11.818]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.783]   - Field: ‘owner’
[17:43:11.819]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.783]   - Field: ‘envir’
[17:43:11.819]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.783]   - Field: ‘packages’
[17:43:11.819]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.784]   - Field: ‘gc’
[17:43:11.819]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.784]   - Field: ‘conditions’
[17:43:11.819]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.784]   - Field: ‘expr’
[17:43:11.819]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.784]   - Field: ‘uuid’
[17:43:11.820]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.784]   - Field: ‘seed’
[17:43:11.820]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.784]   - Field: ‘version’
[17:43:11.820]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.785]   - Field: ‘result’
[17:43:11.820]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.785]   - Field: ‘asynchronous’
[17:43:11.820]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.785]   - Field: ‘calls’
[17:43:11.820]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.785]   - Field: ‘globals’
[17:43:11.820]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.785]   - Field: ‘stdout’
[17:43:11.821]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.785]   - Field: ‘earlySignal’
[17:43:11.821]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.785]   - Field: ‘lazy’
[17:43:11.821]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.786]   - Field: ‘state’
[17:43:11.821]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.786] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:11.821]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.786] - Launch lazy future ...
[17:43:11.821]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.786] Packages needed by the future expression (n = 0): <none>
[17:43:11.822]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.787] Packages needed by future strategies (n = 0): <none>
[17:43:11.822]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.787] {
[17:43:11.787]     {
[17:43:11.787]         {
[17:43:11.787]             ...future.startTime <- base::Sys.time()
[17:43:11.787]             {
[17:43:11.787]                 {
[17:43:11.787]                   {
[17:43:11.787]                     base::local({
[17:43:11.787]                       has_future <- base::requireNamespace("future", 
[17:43:11.787]                         quietly = TRUE)
[17:43:11.787]                       if (has_future) {
[17:43:11.787]                         ns <- base::getNamespace("future")
[17:43:11.787]                         version <- ns[[".package"]][["version"]]
[17:43:11.787]                         if (is.null(version)) 
[17:43:11.787]                           version <- utils::packageVersion("future")
[17:43:11.787]                       }
[17:43:11.787]                       else {
[17:43:11.787]                         version <- NULL
[17:43:11.787]                       }
[17:43:11.787]                       if (!has_future || version < "1.8.0") {
[17:43:11.787]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.787]                           "", base::R.version$version.string), 
[17:43:11.787]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:11.787]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:11.787]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.787]                             "release", "version")], collapse = " "), 
[17:43:11.787]                           hostname = base::Sys.info()[["nodename"]])
[17:43:11.787]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.787]                           info)
[17:43:11.787]                         info <- base::paste(info, collapse = "; ")
[17:43:11.787]                         if (!has_future) {
[17:43:11.787]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.787]                             info)
[17:43:11.787]                         }
[17:43:11.787]                         else {
[17:43:11.787]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.787]                             info, version)
[17:43:11.787]                         }
[17:43:11.787]                         base::stop(msg)
[17:43:11.787]                       }
[17:43:11.787]                     })
[17:43:11.787]                   }
[17:43:11.787]                   options(future.plan = NULL)
[17:43:11.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:11.787]                 }
[17:43:11.787]                 ...future.workdir <- getwd()
[17:43:11.787]             }
[17:43:11.787]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.787]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.787]         }
[17:43:11.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.787]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.787]             base::names(...future.oldOptions))
[17:43:11.787]     }
[17:43:11.787]     if (FALSE) {
[17:43:11.787]     }
[17:43:11.787]     else {
[17:43:11.787]         if (TRUE) {
[17:43:11.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.787]                 open = "w")
[17:43:11.787]         }
[17:43:11.787]         else {
[17:43:11.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.787]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.787]         }
[17:43:11.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.787]             base::sink(type = "output", split = FALSE)
[17:43:11.787]             base::close(...future.stdout)
[17:43:11.787]         }, add = TRUE)
[17:43:11.787]     }
[17:43:11.787]     ...future.frame <- base::sys.nframe()
[17:43:11.787]     ...future.conditions <- base::list()
[17:43:11.787]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.787]     if (FALSE) {
[17:43:11.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.787]     }
[17:43:11.787]     ...future.result <- base::tryCatch({
[17:43:11.787]         base::withCallingHandlers({
[17:43:11.787]             ...future.value <- base::withVisible(base::local({
[17:43:11.787]                 b <- 2L
[17:43:11.787]                 plan_b <- future::plan("list")
[17:43:11.787]                 nested_b <- nested_a[-1]
[17:43:11.787]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:11.787]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:43:11.787]                   "sequential"))
[17:43:11.787]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:11.787]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:11.787]             }))
[17:43:11.787]             future::FutureResult(value = ...future.value$value, 
[17:43:11.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.787]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.787]                     ...future.globalenv.names))
[17:43:11.787]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.787]         }, condition = base::local({
[17:43:11.787]             c <- base::c
[17:43:11.787]             inherits <- base::inherits
[17:43:11.787]             invokeRestart <- base::invokeRestart
[17:43:11.787]             length <- base::length
[17:43:11.787]             list <- base::list
[17:43:11.787]             seq.int <- base::seq.int
[17:43:11.787]             signalCondition <- base::signalCondition
[17:43:11.787]             sys.calls <- base::sys.calls
[17:43:11.787]             `[[` <- base::`[[`
[17:43:11.787]             `+` <- base::`+`
[17:43:11.787]             `<<-` <- base::`<<-`
[17:43:11.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.787]                   3L)]
[17:43:11.787]             }
[17:43:11.787]             function(cond) {
[17:43:11.787]                 is_error <- inherits(cond, "error")
[17:43:11.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.787]                   NULL)
[17:43:11.787]                 if (is_error) {
[17:43:11.787]                   sessionInformation <- function() {
[17:43:11.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.787]                       search = base::search(), system = base::Sys.info())
[17:43:11.787]                   }
[17:43:11.787]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.787]                     cond$call), session = sessionInformation(), 
[17:43:11.787]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.787]                   signalCondition(cond)
[17:43:11.787]                 }
[17:43:11.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.787]                 "immediateCondition"))) {
[17:43:11.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.787]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.787]                   if (TRUE && !signal) {
[17:43:11.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.787]                     {
[17:43:11.787]                       inherits <- base::inherits
[17:43:11.787]                       invokeRestart <- base::invokeRestart
[17:43:11.787]                       is.null <- base::is.null
[17:43:11.787]                       muffled <- FALSE
[17:43:11.787]                       if (inherits(cond, "message")) {
[17:43:11.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.787]                         if (muffled) 
[17:43:11.787]                           invokeRestart("muffleMessage")
[17:43:11.787]                       }
[17:43:11.787]                       else if (inherits(cond, "warning")) {
[17:43:11.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.787]                         if (muffled) 
[17:43:11.787]                           invokeRestart("muffleWarning")
[17:43:11.787]                       }
[17:43:11.787]                       else if (inherits(cond, "condition")) {
[17:43:11.787]                         if (!is.null(pattern)) {
[17:43:11.787]                           computeRestarts <- base::computeRestarts
[17:43:11.787]                           grepl <- base::grepl
[17:43:11.787]                           restarts <- computeRestarts(cond)
[17:43:11.787]                           for (restart in restarts) {
[17:43:11.787]                             name <- restart$name
[17:43:11.787]                             if (is.null(name)) 
[17:43:11.787]                               next
[17:43:11.787]                             if (!grepl(pattern, name)) 
[17:43:11.787]                               next
[17:43:11.787]                             invokeRestart(restart)
[17:43:11.787]                             muffled <- TRUE
[17:43:11.787]                             break
[17:43:11.787]                           }
[17:43:11.787]                         }
[17:43:11.787]                       }
[17:43:11.787]                       invisible(muffled)
[17:43:11.787]                     }
[17:43:11.787]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.787]                   }
[17:43:11.787]                 }
[17:43:11.787]                 else {
[17:43:11.787]                   if (TRUE) {
[17:43:11.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.787]                     {
[17:43:11.787]                       inherits <- base::inherits
[17:43:11.787]                       invokeRestart <- base::invokeRestart
[17:43:11.787]                       is.null <- base::is.null
[17:43:11.787]                       muffled <- FALSE
[17:43:11.787]                       if (inherits(cond, "message")) {
[17:43:11.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.787]                         if (muffled) 
[17:43:11.787]                           invokeRestart("muffleMessage")
[17:43:11.787]                       }
[17:43:11.787]                       else if (inherits(cond, "warning")) {
[17:43:11.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.787]                         if (muffled) 
[17:43:11.787]                           invokeRestart("muffleWarning")
[17:43:11.787]                       }
[17:43:11.787]                       else if (inherits(cond, "condition")) {
[17:43:11.787]                         if (!is.null(pattern)) {
[17:43:11.787]                           computeRestarts <- base::computeRestarts
[17:43:11.787]                           grepl <- base::grepl
[17:43:11.787]                           restarts <- computeRestarts(cond)
[17:43:11.787]                           for (restart in restarts) {
[17:43:11.787]                             name <- restart$name
[17:43:11.787]                             if (is.null(name)) 
[17:43:11.787]                               next
[17:43:11.787]                             if (!grepl(pattern, name)) 
[17:43:11.787]                               next
[17:43:11.787]                             invokeRestart(restart)
[17:43:11.787]                             muffled <- TRUE
[17:43:11.787]                             break
[17:43:11.787]                           }
[17:43:11.787]                         }
[17:43:11.787]                       }
[17:43:11.787]                       invisible(muffled)
[17:43:11.787]                     }
[17:43:11.787]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.787]                   }
[17:43:11.787]                 }
[17:43:11.787]             }
[17:43:11.787]         }))
[17:43:11.787]     }, error = function(ex) {
[17:43:11.787]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.787]                 ...future.rng), started = ...future.startTime, 
[17:43:11.787]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.787]             version = "1.8"), class = "FutureResult")
[17:43:11.787]     }, finally = {
[17:43:11.787]         if (!identical(...future.workdir, getwd())) 
[17:43:11.787]             setwd(...future.workdir)
[17:43:11.787]         {
[17:43:11.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.787]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.787]             }
[17:43:11.787]             base::options(...future.oldOptions)
[17:43:11.787]             if (.Platform$OS.type == "windows") {
[17:43:11.787]                 old_names <- names(...future.oldEnvVars)
[17:43:11.787]                 envs <- base::Sys.getenv()
[17:43:11.787]                 names <- names(envs)
[17:43:11.787]                 common <- intersect(names, old_names)
[17:43:11.787]                 added <- setdiff(names, old_names)
[17:43:11.787]                 removed <- setdiff(old_names, names)
[17:43:11.787]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.787]                   envs[common]]
[17:43:11.787]                 NAMES <- toupper(changed)
[17:43:11.787]                 args <- list()
[17:43:11.787]                 for (kk in seq_along(NAMES)) {
[17:43:11.787]                   name <- changed[[kk]]
[17:43:11.787]                   NAME <- NAMES[[kk]]
[17:43:11.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.787]                     next
[17:43:11.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.787]                 }
[17:43:11.787]                 NAMES <- toupper(added)
[17:43:11.787]                 for (kk in seq_along(NAMES)) {
[17:43:11.787]                   name <- added[[kk]]
[17:43:11.787]                   NAME <- NAMES[[kk]]
[17:43:11.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.787]                     next
[17:43:11.787]                   args[[name]] <- ""
[17:43:11.787]                 }
[17:43:11.787]                 NAMES <- toupper(removed)
[17:43:11.787]                 for (kk in seq_along(NAMES)) {
[17:43:11.787]                   name <- removed[[kk]]
[17:43:11.787]                   NAME <- NAMES[[kk]]
[17:43:11.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.787]                     next
[17:43:11.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.787]                 }
[17:43:11.787]                 if (length(args) > 0) 
[17:43:11.787]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.787]             }
[17:43:11.787]             else {
[17:43:11.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.787]             }
[17:43:11.787]             {
[17:43:11.787]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.787]                   0L) {
[17:43:11.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.787]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.787]                   base::options(opts)
[17:43:11.787]                 }
[17:43:11.787]                 {
[17:43:11.787]                   {
[17:43:11.787]                     NULL
[17:43:11.787]                     RNGkind("Mersenne-Twister")
[17:43:11.787]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:11.787]                       inherits = FALSE)
[17:43:11.787]                   }
[17:43:11.787]                   options(future.plan = NULL)
[17:43:11.787]                   if (is.na(NA_character_)) 
[17:43:11.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.787]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:43:11.787]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.787]                     envir = parent.frame()) 
[17:43:11.787]                   {
[17:43:11.787]                     if (is.function(workers)) 
[17:43:11.787]                       workers <- workers()
[17:43:11.787]                     workers <- structure(as.integer(workers), 
[17:43:11.787]                       class = class(workers))
[17:43:11.787]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:11.787]                       workers >= 1)
[17:43:11.787]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:11.787]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:11.787]                     }
[17:43:11.787]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:11.787]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:11.787]                       envir = envir)
[17:43:11.787]                     if (!future$lazy) 
[17:43:11.787]                       future <- run(future)
[17:43:11.787]                     invisible(future)
[17:43:11.787]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.787]                 }
[17:43:11.787]             }
[17:43:11.787]         }
[17:43:11.787]     })
[17:43:11.787]     if (TRUE) {
[17:43:11.787]         base::sink(type = "output", split = FALSE)
[17:43:11.787]         if (TRUE) {
[17:43:11.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.787]         }
[17:43:11.787]         else {
[17:43:11.787]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.787]         }
[17:43:11.787]         base::close(...future.stdout)
[17:43:11.787]         ...future.stdout <- NULL
[17:43:11.787]     }
[17:43:11.787]     ...future.result$conditions <- ...future.conditions
[17:43:11.787]     ...future.result$finished <- base::Sys.time()
[17:43:11.787]     ...future.result
[17:43:11.787] }
[17:43:11.822]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.790] assign_globals() ...
[17:43:11.822]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.790] List of 3
[17:43:11.790]  $ nested_a:List of 1
[17:43:11.790]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.790]     envir = parent.frame())  
[17:43:11.790]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:43:11.790]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:43:11.790]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.790]  $ a       : int 1
[17:43:11.790]  $ plan_a  :List of 1
[17:43:11.790]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.790]     envir = parent.frame())  
[17:43:11.790]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:43:11.790]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:43:11.790]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:43:11.790]  - attr(*, "where")=List of 3
[17:43:11.790]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:43:11.790]   ..$ a       :<environment: R_EmptyEnv> 
[17:43:11.790]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:43:11.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.790]  - attr(*, "resolved")= logi FALSE
[17:43:11.790]  - attr(*, "total_size")= num 89928
[17:43:11.790]  - attr(*, "already-done")= logi TRUE
[17:43:11.822]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.798] - copied ‘nested_a’ to environment
[17:43:11.822]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.798] - copied ‘a’ to environment
[17:43:11.823]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.798] - copied ‘plan_a’ to environment
[17:43:11.823]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.798] assign_globals() ... done
[17:43:11.823]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.799] plan(): Setting new future strategy stack:
[17:43:11.823]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.799] List of future strategies:
[17:43:11.799] 1. sequential:
[17:43:11.799]    - args: function (..., envir = parent.frame())
[17:43:11.799]    - tweaked: FALSE
[17:43:11.799]    - call: NULL
[17:43:11.823]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.799] plan(): nbrOfWorkers() = 1
[17:43:11.823]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.800] plan(): Setting new future strategy stack:
[17:43:11.824]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.801] List of future strategies:
[17:43:11.801] 1. multisession:
[17:43:11.801]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.801]    - tweaked: FALSE
[17:43:11.801]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.824]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.805] plan(): nbrOfWorkers() = 1
[17:43:11.824]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.805] SequentialFuture started (and completed)
[17:43:11.824]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.805] - Launch lazy future ... done
[17:43:11.824]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.805] run() for ‘SequentialFuture’ ... done
[17:43:11.824] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:11.831] getGlobalsAndPackages() ...
[17:43:11.831] Searching for globals...
[17:43:11.833] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:11.833] Searching for globals ... DONE
[17:43:11.833] Resolving globals: FALSE
[17:43:11.834] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:11.835] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:11.835] - globals: [1] ‘data’
[17:43:11.835] - packages: [1] ‘future’
[17:43:11.835] getGlobalsAndPackages() ... DONE
[17:43:11.836] run() for ‘Future’ ...
[17:43:11.836] - state: ‘created’
[17:43:11.836] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.841] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:11.841] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:11.841]   - Field: ‘label’
[17:43:11.841]   - Field: ‘local’
[17:43:11.841]   - Field: ‘owner’
[17:43:11.841]   - Field: ‘envir’
[17:43:11.841]   - Field: ‘workers’
[17:43:11.842]   - Field: ‘packages’
[17:43:11.842]   - Field: ‘gc’
[17:43:11.842]   - Field: ‘job’
[17:43:11.842]   - Field: ‘conditions’
[17:43:11.842]   - Field: ‘expr’
[17:43:11.842]   - Field: ‘uuid’
[17:43:11.842]   - Field: ‘seed’
[17:43:11.842]   - Field: ‘version’
[17:43:11.842]   - Field: ‘result’
[17:43:11.843]   - Field: ‘asynchronous’
[17:43:11.843]   - Field: ‘calls’
[17:43:11.843]   - Field: ‘globals’
[17:43:11.843]   - Field: ‘stdout’
[17:43:11.843]   - Field: ‘earlySignal’
[17:43:11.843]   - Field: ‘lazy’
[17:43:11.843]   - Field: ‘state’
[17:43:11.843] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:11.844] - Launch lazy future ...
[17:43:11.844] Packages needed by the future expression (n = 1): ‘future’
[17:43:11.844] Packages needed by future strategies (n = 1): ‘future’
[17:43:11.845] {
[17:43:11.845]     {
[17:43:11.845]         {
[17:43:11.845]             ...future.startTime <- base::Sys.time()
[17:43:11.845]             {
[17:43:11.845]                 {
[17:43:11.845]                   {
[17:43:11.845]                     {
[17:43:11.845]                       {
[17:43:11.845]                         base::local({
[17:43:11.845]                           has_future <- base::requireNamespace("future", 
[17:43:11.845]                             quietly = TRUE)
[17:43:11.845]                           if (has_future) {
[17:43:11.845]                             ns <- base::getNamespace("future")
[17:43:11.845]                             version <- ns[[".package"]][["version"]]
[17:43:11.845]                             if (is.null(version)) 
[17:43:11.845]                               version <- utils::packageVersion("future")
[17:43:11.845]                           }
[17:43:11.845]                           else {
[17:43:11.845]                             version <- NULL
[17:43:11.845]                           }
[17:43:11.845]                           if (!has_future || version < "1.8.0") {
[17:43:11.845]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.845]                               "", base::R.version$version.string), 
[17:43:11.845]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:11.845]                                 base::R.version$platform, 8 * 
[17:43:11.845]                                   base::.Machine$sizeof.pointer), 
[17:43:11.845]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.845]                                 "release", "version")], collapse = " "), 
[17:43:11.845]                               hostname = base::Sys.info()[["nodename"]])
[17:43:11.845]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.845]                               info)
[17:43:11.845]                             info <- base::paste(info, collapse = "; ")
[17:43:11.845]                             if (!has_future) {
[17:43:11.845]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.845]                                 info)
[17:43:11.845]                             }
[17:43:11.845]                             else {
[17:43:11.845]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.845]                                 info, version)
[17:43:11.845]                             }
[17:43:11.845]                             base::stop(msg)
[17:43:11.845]                           }
[17:43:11.845]                         })
[17:43:11.845]                       }
[17:43:11.845]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:11.845]                       base::options(mc.cores = 1L)
[17:43:11.845]                     }
[17:43:11.845]                     base::local({
[17:43:11.845]                       for (pkg in "future") {
[17:43:11.845]                         base::loadNamespace(pkg)
[17:43:11.845]                         base::library(pkg, character.only = TRUE)
[17:43:11.845]                       }
[17:43:11.845]                     })
[17:43:11.845]                   }
[17:43:11.845]                   options(future.plan = NULL)
[17:43:11.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.845]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:43:11.845]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.845]                     envir = parent.frame()) 
[17:43:11.845]                   {
[17:43:11.845]                     if (is.function(workers)) 
[17:43:11.845]                       workers <- workers()
[17:43:11.845]                     workers <- structure(as.integer(workers), 
[17:43:11.845]                       class = class(workers))
[17:43:11.845]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:11.845]                       workers >= 1)
[17:43:11.845]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:11.845]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:11.845]                     }
[17:43:11.845]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:11.845]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:11.845]                       envir = envir)
[17:43:11.845]                     if (!future$lazy) 
[17:43:11.845]                       future <- run(future)
[17:43:11.845]                     invisible(future)
[17:43:11.845]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.845]                 }
[17:43:11.845]                 ...future.workdir <- getwd()
[17:43:11.845]             }
[17:43:11.845]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.845]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.845]         }
[17:43:11.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.845]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.845]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.845]             base::names(...future.oldOptions))
[17:43:11.845]     }
[17:43:11.845]     if (FALSE) {
[17:43:11.845]     }
[17:43:11.845]     else {
[17:43:11.845]         if (TRUE) {
[17:43:11.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.845]                 open = "w")
[17:43:11.845]         }
[17:43:11.845]         else {
[17:43:11.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.845]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.845]         }
[17:43:11.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.845]             base::sink(type = "output", split = FALSE)
[17:43:11.845]             base::close(...future.stdout)
[17:43:11.845]         }, add = TRUE)
[17:43:11.845]     }
[17:43:11.845]     ...future.frame <- base::sys.nframe()
[17:43:11.845]     ...future.conditions <- base::list()
[17:43:11.845]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.845]     if (FALSE) {
[17:43:11.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.845]     }
[17:43:11.845]     ...future.result <- base::tryCatch({
[17:43:11.845]         base::withCallingHandlers({
[17:43:11.845]             ...future.value <- base::withVisible(base::local({
[17:43:11.845]                 withCallingHandlers({
[17:43:11.845]                   {
[17:43:11.845]                     value(future(subset(data, a == 2)))
[17:43:11.845]                   }
[17:43:11.845]                 }, immediateCondition = function(cond) {
[17:43:11.845]                   save_rds <- function (object, pathname, ...) 
[17:43:11.845]                   {
[17:43:11.845]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:11.845]                     if (file_test("-f", pathname_tmp)) {
[17:43:11.845]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.845]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:11.845]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.845]                         fi_tmp[["mtime"]])
[17:43:11.845]                     }
[17:43:11.845]                     tryCatch({
[17:43:11.845]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:11.845]                     }, error = function(ex) {
[17:43:11.845]                       msg <- conditionMessage(ex)
[17:43:11.845]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.845]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:11.845]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.845]                         fi_tmp[["mtime"]], msg)
[17:43:11.845]                       ex$message <- msg
[17:43:11.845]                       stop(ex)
[17:43:11.845]                     })
[17:43:11.845]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:11.845]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:11.845]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:11.845]                       fi_tmp <- file.info(pathname_tmp)
[17:43:11.845]                       fi <- file.info(pathname)
[17:43:11.845]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:11.845]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:11.845]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:11.845]                         fi[["size"]], fi[["mtime"]])
[17:43:11.845]                       stop(msg)
[17:43:11.845]                     }
[17:43:11.845]                     invisible(pathname)
[17:43:11.845]                   }
[17:43:11.845]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:11.845]                     rootPath = tempdir()) 
[17:43:11.845]                   {
[17:43:11.845]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:11.845]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:11.845]                       tmpdir = path, fileext = ".rds")
[17:43:11.845]                     save_rds(obj, file)
[17:43:11.845]                   }
[17:43:11.845]                   saveImmediateCondition(cond, path = "/tmp/RtmpzPUCYD/.future/immediateConditions")
[17:43:11.845]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.845]                   {
[17:43:11.845]                     inherits <- base::inherits
[17:43:11.845]                     invokeRestart <- base::invokeRestart
[17:43:11.845]                     is.null <- base::is.null
[17:43:11.845]                     muffled <- FALSE
[17:43:11.845]                     if (inherits(cond, "message")) {
[17:43:11.845]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:11.845]                       if (muffled) 
[17:43:11.845]                         invokeRestart("muffleMessage")
[17:43:11.845]                     }
[17:43:11.845]                     else if (inherits(cond, "warning")) {
[17:43:11.845]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:11.845]                       if (muffled) 
[17:43:11.845]                         invokeRestart("muffleWarning")
[17:43:11.845]                     }
[17:43:11.845]                     else if (inherits(cond, "condition")) {
[17:43:11.845]                       if (!is.null(pattern)) {
[17:43:11.845]                         computeRestarts <- base::computeRestarts
[17:43:11.845]                         grepl <- base::grepl
[17:43:11.845]                         restarts <- computeRestarts(cond)
[17:43:11.845]                         for (restart in restarts) {
[17:43:11.845]                           name <- restart$name
[17:43:11.845]                           if (is.null(name)) 
[17:43:11.845]                             next
[17:43:11.845]                           if (!grepl(pattern, name)) 
[17:43:11.845]                             next
[17:43:11.845]                           invokeRestart(restart)
[17:43:11.845]                           muffled <- TRUE
[17:43:11.845]                           break
[17:43:11.845]                         }
[17:43:11.845]                       }
[17:43:11.845]                     }
[17:43:11.845]                     invisible(muffled)
[17:43:11.845]                   }
[17:43:11.845]                   muffleCondition(cond)
[17:43:11.845]                 })
[17:43:11.845]             }))
[17:43:11.845]             future::FutureResult(value = ...future.value$value, 
[17:43:11.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.845]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.845]                     ...future.globalenv.names))
[17:43:11.845]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.845]         }, condition = base::local({
[17:43:11.845]             c <- base::c
[17:43:11.845]             inherits <- base::inherits
[17:43:11.845]             invokeRestart <- base::invokeRestart
[17:43:11.845]             length <- base::length
[17:43:11.845]             list <- base::list
[17:43:11.845]             seq.int <- base::seq.int
[17:43:11.845]             signalCondition <- base::signalCondition
[17:43:11.845]             sys.calls <- base::sys.calls
[17:43:11.845]             `[[` <- base::`[[`
[17:43:11.845]             `+` <- base::`+`
[17:43:11.845]             `<<-` <- base::`<<-`
[17:43:11.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.845]                   3L)]
[17:43:11.845]             }
[17:43:11.845]             function(cond) {
[17:43:11.845]                 is_error <- inherits(cond, "error")
[17:43:11.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.845]                   NULL)
[17:43:11.845]                 if (is_error) {
[17:43:11.845]                   sessionInformation <- function() {
[17:43:11.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.845]                       search = base::search(), system = base::Sys.info())
[17:43:11.845]                   }
[17:43:11.845]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.845]                     cond$call), session = sessionInformation(), 
[17:43:11.845]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.845]                   signalCondition(cond)
[17:43:11.845]                 }
[17:43:11.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.845]                 "immediateCondition"))) {
[17:43:11.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.845]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.845]                   if (TRUE && !signal) {
[17:43:11.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.845]                     {
[17:43:11.845]                       inherits <- base::inherits
[17:43:11.845]                       invokeRestart <- base::invokeRestart
[17:43:11.845]                       is.null <- base::is.null
[17:43:11.845]                       muffled <- FALSE
[17:43:11.845]                       if (inherits(cond, "message")) {
[17:43:11.845]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.845]                         if (muffled) 
[17:43:11.845]                           invokeRestart("muffleMessage")
[17:43:11.845]                       }
[17:43:11.845]                       else if (inherits(cond, "warning")) {
[17:43:11.845]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.845]                         if (muffled) 
[17:43:11.845]                           invokeRestart("muffleWarning")
[17:43:11.845]                       }
[17:43:11.845]                       else if (inherits(cond, "condition")) {
[17:43:11.845]                         if (!is.null(pattern)) {
[17:43:11.845]                           computeRestarts <- base::computeRestarts
[17:43:11.845]                           grepl <- base::grepl
[17:43:11.845]                           restarts <- computeRestarts(cond)
[17:43:11.845]                           for (restart in restarts) {
[17:43:11.845]                             name <- restart$name
[17:43:11.845]                             if (is.null(name)) 
[17:43:11.845]                               next
[17:43:11.845]                             if (!grepl(pattern, name)) 
[17:43:11.845]                               next
[17:43:11.845]                             invokeRestart(restart)
[17:43:11.845]                             muffled <- TRUE
[17:43:11.845]                             break
[17:43:11.845]                           }
[17:43:11.845]                         }
[17:43:11.845]                       }
[17:43:11.845]                       invisible(muffled)
[17:43:11.845]                     }
[17:43:11.845]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.845]                   }
[17:43:11.845]                 }
[17:43:11.845]                 else {
[17:43:11.845]                   if (TRUE) {
[17:43:11.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.845]                     {
[17:43:11.845]                       inherits <- base::inherits
[17:43:11.845]                       invokeRestart <- base::invokeRestart
[17:43:11.845]                       is.null <- base::is.null
[17:43:11.845]                       muffled <- FALSE
[17:43:11.845]                       if (inherits(cond, "message")) {
[17:43:11.845]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.845]                         if (muffled) 
[17:43:11.845]                           invokeRestart("muffleMessage")
[17:43:11.845]                       }
[17:43:11.845]                       else if (inherits(cond, "warning")) {
[17:43:11.845]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.845]                         if (muffled) 
[17:43:11.845]                           invokeRestart("muffleWarning")
[17:43:11.845]                       }
[17:43:11.845]                       else if (inherits(cond, "condition")) {
[17:43:11.845]                         if (!is.null(pattern)) {
[17:43:11.845]                           computeRestarts <- base::computeRestarts
[17:43:11.845]                           grepl <- base::grepl
[17:43:11.845]                           restarts <- computeRestarts(cond)
[17:43:11.845]                           for (restart in restarts) {
[17:43:11.845]                             name <- restart$name
[17:43:11.845]                             if (is.null(name)) 
[17:43:11.845]                               next
[17:43:11.845]                             if (!grepl(pattern, name)) 
[17:43:11.845]                               next
[17:43:11.845]                             invokeRestart(restart)
[17:43:11.845]                             muffled <- TRUE
[17:43:11.845]                             break
[17:43:11.845]                           }
[17:43:11.845]                         }
[17:43:11.845]                       }
[17:43:11.845]                       invisible(muffled)
[17:43:11.845]                     }
[17:43:11.845]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.845]                   }
[17:43:11.845]                 }
[17:43:11.845]             }
[17:43:11.845]         }))
[17:43:11.845]     }, error = function(ex) {
[17:43:11.845]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.845]                 ...future.rng), started = ...future.startTime, 
[17:43:11.845]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.845]             version = "1.8"), class = "FutureResult")
[17:43:11.845]     }, finally = {
[17:43:11.845]         if (!identical(...future.workdir, getwd())) 
[17:43:11.845]             setwd(...future.workdir)
[17:43:11.845]         {
[17:43:11.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.845]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.845]             }
[17:43:11.845]             base::options(...future.oldOptions)
[17:43:11.845]             if (.Platform$OS.type == "windows") {
[17:43:11.845]                 old_names <- names(...future.oldEnvVars)
[17:43:11.845]                 envs <- base::Sys.getenv()
[17:43:11.845]                 names <- names(envs)
[17:43:11.845]                 common <- intersect(names, old_names)
[17:43:11.845]                 added <- setdiff(names, old_names)
[17:43:11.845]                 removed <- setdiff(old_names, names)
[17:43:11.845]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.845]                   envs[common]]
[17:43:11.845]                 NAMES <- toupper(changed)
[17:43:11.845]                 args <- list()
[17:43:11.845]                 for (kk in seq_along(NAMES)) {
[17:43:11.845]                   name <- changed[[kk]]
[17:43:11.845]                   NAME <- NAMES[[kk]]
[17:43:11.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.845]                     next
[17:43:11.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.845]                 }
[17:43:11.845]                 NAMES <- toupper(added)
[17:43:11.845]                 for (kk in seq_along(NAMES)) {
[17:43:11.845]                   name <- added[[kk]]
[17:43:11.845]                   NAME <- NAMES[[kk]]
[17:43:11.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.845]                     next
[17:43:11.845]                   args[[name]] <- ""
[17:43:11.845]                 }
[17:43:11.845]                 NAMES <- toupper(removed)
[17:43:11.845]                 for (kk in seq_along(NAMES)) {
[17:43:11.845]                   name <- removed[[kk]]
[17:43:11.845]                   NAME <- NAMES[[kk]]
[17:43:11.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.845]                     next
[17:43:11.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.845]                 }
[17:43:11.845]                 if (length(args) > 0) 
[17:43:11.845]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.845]             }
[17:43:11.845]             else {
[17:43:11.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.845]             }
[17:43:11.845]             {
[17:43:11.845]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.845]                   0L) {
[17:43:11.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.845]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.845]                   base::options(opts)
[17:43:11.845]                 }
[17:43:11.845]                 {
[17:43:11.845]                   {
[17:43:11.845]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:11.845]                     NULL
[17:43:11.845]                   }
[17:43:11.845]                   options(future.plan = NULL)
[17:43:11.845]                   if (is.na(NA_character_)) 
[17:43:11.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.845]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:11.845]                     envir = parent.frame()) 
[17:43:11.845]                   {
[17:43:11.845]                     default_workers <- missing(workers)
[17:43:11.845]                     if (is.function(workers)) 
[17:43:11.845]                       workers <- workers()
[17:43:11.845]                     workers <- structure(as.integer(workers), 
[17:43:11.845]                       class = class(workers))
[17:43:11.845]                     stop_if_not(is.finite(workers), workers >= 
[17:43:11.845]                       1L)
[17:43:11.845]                     if ((workers == 1L && !inherits(workers, 
[17:43:11.845]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:11.845]                       if (default_workers) 
[17:43:11.845]                         supportsMulticore(warn = TRUE)
[17:43:11.845]                       return(sequential(..., envir = envir))
[17:43:11.845]                     }
[17:43:11.845]                     oopts <- options(mc.cores = workers)
[17:43:11.845]                     on.exit(options(oopts))
[17:43:11.845]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:11.845]                       envir = envir)
[17:43:11.845]                     if (!future$lazy) 
[17:43:11.845]                       future <- run(future)
[17:43:11.845]                     invisible(future)
[17:43:11.845]                   }, b = function (..., workers = availableCores(), 
[17:43:11.845]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.845]                     envir = parent.frame()) 
[17:43:11.845]                   {
[17:43:11.845]                     if (is.function(workers)) 
[17:43:11.845]                       workers <- workers()
[17:43:11.845]                     workers <- structure(as.integer(workers), 
[17:43:11.845]                       class = class(workers))
[17:43:11.845]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:11.845]                       workers >= 1)
[17:43:11.845]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:11.845]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:11.845]                     }
[17:43:11.845]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:11.845]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:11.845]                       envir = envir)
[17:43:11.845]                     if (!future$lazy) 
[17:43:11.845]                       future <- run(future)
[17:43:11.845]                     invisible(future)
[17:43:11.845]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.845]                 }
[17:43:11.845]             }
[17:43:11.845]         }
[17:43:11.845]     })
[17:43:11.845]     if (TRUE) {
[17:43:11.845]         base::sink(type = "output", split = FALSE)
[17:43:11.845]         if (TRUE) {
[17:43:11.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.845]         }
[17:43:11.845]         else {
[17:43:11.845]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.845]         }
[17:43:11.845]         base::close(...future.stdout)
[17:43:11.845]         ...future.stdout <- NULL
[17:43:11.845]     }
[17:43:11.845]     ...future.result$conditions <- ...future.conditions
[17:43:11.845]     ...future.result$finished <- base::Sys.time()
[17:43:11.845]     ...future.result
[17:43:11.845] }
[17:43:11.848] assign_globals() ...
[17:43:11.848] List of 1
[17:43:11.848]  $ data:'data.frame':	3 obs. of  2 variables:
[17:43:11.848]   ..$ a: int [1:3] 1 2 3
[17:43:11.848]   ..$ b: int [1:3] 3 2 1
[17:43:11.848]  - attr(*, "where")=List of 1
[17:43:11.848]   ..$ data:<environment: R_EmptyEnv> 
[17:43:11.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.848]  - attr(*, "resolved")= logi FALSE
[17:43:11.848]  - attr(*, "total_size")= num 128
[17:43:11.848]  - attr(*, "already-done")= logi TRUE
[17:43:11.852] - copied ‘data’ to environment
[17:43:11.852] assign_globals() ... done
[17:43:11.852] requestCore(): workers = 2
[17:43:11.855] MulticoreFuture started
[17:43:11.855] - Launch lazy future ... done
[17:43:11.855] run() for ‘MulticoreFuture’ ... done
[17:43:11.856] plan(): Setting new future strategy stack:
[17:43:11.857] List of future strategies:
[17:43:11.857] 1. multisession:
[17:43:11.857]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.857]    - tweaked: FALSE
[17:43:11.857]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.863] plan(): nbrOfWorkers() = 1
[17:43:11.901] plan(): Setting new future strategy stack:
[17:43:11.901] List of future strategies:
[17:43:11.901] 1. multicore:
[17:43:11.901]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:11.901]    - tweaked: FALSE
[17:43:11.901]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.901] 2. multisession:
[17:43:11.901]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.901]    - tweaked: FALSE
[17:43:11.901]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.905] plan(): nbrOfWorkers() = 2
[17:43:11.906] signalConditions() ...
[17:43:11.907]  - include = ‘immediateCondition’
[17:43:11.907]  - exclude = 
[17:43:11.907]  - resignal = FALSE
[17:43:11.907]  - Number of conditions: 52
[17:43:11.908] signalConditions() ... done
[17:43:11.908] signalConditions() ...
[17:43:11.908]  - include = ‘immediateCondition’
[17:43:11.908]  - exclude = 
[17:43:11.908]  - resignal = FALSE
[17:43:11.908]  - Number of conditions: 52
[17:43:11.908] signalConditions() ... done
[17:43:11.909] Future state: ‘finished’
[17:43:11.909] signalConditions() ...
[17:43:11.909]  - include = ‘condition’
[17:43:11.909]  - exclude = ‘immediateCondition’
[17:43:11.909]  - resignal = TRUE
[17:43:11.909]  - Number of conditions: 52
[17:43:11.909]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.864] getGlobalsAndPackages() ...
[17:43:11.909]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.864] Searching for globals...
[17:43:11.910]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.866] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:11.910]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.866] Searching for globals ... DONE
[17:43:11.910]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.866] Resolving globals: FALSE
[17:43:11.910]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.873] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:11.913]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.874] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:11.914]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.874] - globals: [1] ‘data’
[17:43:11.914]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.874] 
[17:43:11.914]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.874] getGlobalsAndPackages() ... DONE
[17:43:11.914]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.875] run() for ‘Future’ ...
[17:43:11.914]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.875] - state: ‘created’
[17:43:11.914]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.876] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:11.915]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.880] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:11.915]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.880] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:11.915]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.881]   - Field: ‘label’
[17:43:11.915]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.881]   - Field: ‘local’
[17:43:11.915]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.881]   - Field: ‘owner’
[17:43:11.915]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.881]   - Field: ‘envir’
[17:43:11.916]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.881]   - Field: ‘packages’
[17:43:11.916]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.882]   - Field: ‘gc’
[17:43:11.916]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.882]   - Field: ‘conditions’
[17:43:11.916]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.882]   - Field: ‘expr’
[17:43:11.916]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.882]   - Field: ‘uuid’
[17:43:11.916]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.882]   - Field: ‘seed’
[17:43:11.916]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.882]   - Field: ‘version’
[17:43:11.917]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.883]   - Field: ‘result’
[17:43:11.917]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.883]   - Field: ‘asynchronous’
[17:43:11.917]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.883]   - Field: ‘calls’
[17:43:11.917]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.883]   - Field: ‘globals’
[17:43:11.917]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.883]   - Field: ‘stdout’
[17:43:11.917]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.883]   - Field: ‘earlySignal’
[17:43:11.917]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.884]   - Field: ‘lazy’
[17:43:11.918]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.884]   - Field: ‘state’
[17:43:11.918]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.884] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:11.918]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.884] - Launch lazy future ...
[17:43:11.918]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.885] Packages needed by the future expression (n = 0): <none>
[17:43:11.918]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.885] Packages needed by future strategies (n = 0): <none>
[17:43:11.918]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.886] {
[17:43:11.886]     {
[17:43:11.886]         {
[17:43:11.886]             ...future.startTime <- base::Sys.time()
[17:43:11.886]             {
[17:43:11.886]                 {
[17:43:11.886]                   {
[17:43:11.886]                     base::local({
[17:43:11.886]                       has_future <- base::requireNamespace("future", 
[17:43:11.886]                         quietly = TRUE)
[17:43:11.886]                       if (has_future) {
[17:43:11.886]                         ns <- base::getNamespace("future")
[17:43:11.886]                         version <- ns[[".package"]][["version"]]
[17:43:11.886]                         if (is.null(version)) 
[17:43:11.886]                           version <- utils::packageVersion("future")
[17:43:11.886]                       }
[17:43:11.886]                       else {
[17:43:11.886]                         version <- NULL
[17:43:11.886]                       }
[17:43:11.886]                       if (!has_future || version < "1.8.0") {
[17:43:11.886]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:11.886]                           "", base::R.version$version.string), 
[17:43:11.886]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:11.886]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:11.886]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:11.886]                             "release", "version")], collapse = " "), 
[17:43:11.886]                           hostname = base::Sys.info()[["nodename"]])
[17:43:11.886]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:11.886]                           info)
[17:43:11.886]                         info <- base::paste(info, collapse = "; ")
[17:43:11.886]                         if (!has_future) {
[17:43:11.886]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:11.886]                             info)
[17:43:11.886]                         }
[17:43:11.886]                         else {
[17:43:11.886]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:11.886]                             info, version)
[17:43:11.886]                         }
[17:43:11.886]                         base::stop(msg)
[17:43:11.886]                       }
[17:43:11.886]                     })
[17:43:11.886]                   }
[17:43:11.886]                   options(future.plan = NULL)
[17:43:11.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:11.886]                 }
[17:43:11.886]                 ...future.workdir <- getwd()
[17:43:11.886]             }
[17:43:11.886]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:11.886]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:11.886]         }
[17:43:11.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:11.886]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:11.886]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:11.886]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:11.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:11.886]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:11.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:11.886]             base::names(...future.oldOptions))
[17:43:11.886]     }
[17:43:11.886]     if (FALSE) {
[17:43:11.886]     }
[17:43:11.886]     else {
[17:43:11.886]         if (TRUE) {
[17:43:11.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:11.886]                 open = "w")
[17:43:11.886]         }
[17:43:11.886]         else {
[17:43:11.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:11.886]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:11.886]         }
[17:43:11.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:11.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:11.886]             base::sink(type = "output", split = FALSE)
[17:43:11.886]             base::close(...future.stdout)
[17:43:11.886]         }, add = TRUE)
[17:43:11.886]     }
[17:43:11.886]     ...future.frame <- base::sys.nframe()
[17:43:11.886]     ...future.conditions <- base::list()
[17:43:11.886]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:11.886]     if (FALSE) {
[17:43:11.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:11.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:11.886]     }
[17:43:11.886]     ...future.result <- base::tryCatch({
[17:43:11.886]         base::withCallingHandlers({
[17:43:11.886]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:43:11.886]                 a == 2)))
[17:43:11.886]             future::FutureResult(value = ...future.value$value, 
[17:43:11.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.886]                   ...future.rng), globalenv = if (FALSE) 
[17:43:11.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:11.886]                     ...future.globalenv.names))
[17:43:11.886]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:11.886]         }, condition = base::local({
[17:43:11.886]             c <- base::c
[17:43:11.886]             inherits <- base::inherits
[17:43:11.886]             invokeRestart <- base::invokeRestart
[17:43:11.886]             length <- base::length
[17:43:11.886]             list <- base::list
[17:43:11.886]             seq.int <- base::seq.int
[17:43:11.886]             signalCondition <- base::signalCondition
[17:43:11.886]             sys.calls <- base::sys.calls
[17:43:11.886]             `[[` <- base::`[[`
[17:43:11.886]             `+` <- base::`+`
[17:43:11.886]             `<<-` <- base::`<<-`
[17:43:11.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:11.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:11.886]                   3L)]
[17:43:11.886]             }
[17:43:11.886]             function(cond) {
[17:43:11.886]                 is_error <- inherits(cond, "error")
[17:43:11.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:11.886]                   NULL)
[17:43:11.886]                 if (is_error) {
[17:43:11.886]                   sessionInformation <- function() {
[17:43:11.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:11.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:11.886]                       search = base::search(), system = base::Sys.info())
[17:43:11.886]                   }
[17:43:11.886]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:11.886]                     cond$call), session = sessionInformation(), 
[17:43:11.886]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:11.886]                   signalCondition(cond)
[17:43:11.886]                 }
[17:43:11.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:11.886]                 "immediateCondition"))) {
[17:43:11.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:11.886]                   ...future.conditions[[length(...future.conditions) + 
[17:43:11.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:11.886]                   if (TRUE && !signal) {
[17:43:11.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.886]                     {
[17:43:11.886]                       inherits <- base::inherits
[17:43:11.886]                       invokeRestart <- base::invokeRestart
[17:43:11.886]                       is.null <- base::is.null
[17:43:11.886]                       muffled <- FALSE
[17:43:11.886]                       if (inherits(cond, "message")) {
[17:43:11.886]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.886]                         if (muffled) 
[17:43:11.886]                           invokeRestart("muffleMessage")
[17:43:11.886]                       }
[17:43:11.886]                       else if (inherits(cond, "warning")) {
[17:43:11.886]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.886]                         if (muffled) 
[17:43:11.886]                           invokeRestart("muffleWarning")
[17:43:11.886]                       }
[17:43:11.886]                       else if (inherits(cond, "condition")) {
[17:43:11.886]                         if (!is.null(pattern)) {
[17:43:11.886]                           computeRestarts <- base::computeRestarts
[17:43:11.886]                           grepl <- base::grepl
[17:43:11.886]                           restarts <- computeRestarts(cond)
[17:43:11.886]                           for (restart in restarts) {
[17:43:11.886]                             name <- restart$name
[17:43:11.886]                             if (is.null(name)) 
[17:43:11.886]                               next
[17:43:11.886]                             if (!grepl(pattern, name)) 
[17:43:11.886]                               next
[17:43:11.886]                             invokeRestart(restart)
[17:43:11.886]                             muffled <- TRUE
[17:43:11.886]                             break
[17:43:11.886]                           }
[17:43:11.886]                         }
[17:43:11.886]                       }
[17:43:11.886]                       invisible(muffled)
[17:43:11.886]                     }
[17:43:11.886]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.886]                   }
[17:43:11.886]                 }
[17:43:11.886]                 else {
[17:43:11.886]                   if (TRUE) {
[17:43:11.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:11.886]                     {
[17:43:11.886]                       inherits <- base::inherits
[17:43:11.886]                       invokeRestart <- base::invokeRestart
[17:43:11.886]                       is.null <- base::is.null
[17:43:11.886]                       muffled <- FALSE
[17:43:11.886]                       if (inherits(cond, "message")) {
[17:43:11.886]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:11.886]                         if (muffled) 
[17:43:11.886]                           invokeRestart("muffleMessage")
[17:43:11.886]                       }
[17:43:11.886]                       else if (inherits(cond, "warning")) {
[17:43:11.886]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:11.886]                         if (muffled) 
[17:43:11.886]                           invokeRestart("muffleWarning")
[17:43:11.886]                       }
[17:43:11.886]                       else if (inherits(cond, "condition")) {
[17:43:11.886]                         if (!is.null(pattern)) {
[17:43:11.886]                           computeRestarts <- base::computeRestarts
[17:43:11.886]                           grepl <- base::grepl
[17:43:11.886]                           restarts <- computeRestarts(cond)
[17:43:11.886]                           for (restart in restarts) {
[17:43:11.886]                             name <- restart$name
[17:43:11.886]                             if (is.null(name)) 
[17:43:11.886]                               next
[17:43:11.886]                             if (!grepl(pattern, name)) 
[17:43:11.886]                               next
[17:43:11.886]                             invokeRestart(restart)
[17:43:11.886]                             muffled <- TRUE
[17:43:11.886]                             break
[17:43:11.886]                           }
[17:43:11.886]                         }
[17:43:11.886]                       }
[17:43:11.886]                       invisible(muffled)
[17:43:11.886]                     }
[17:43:11.886]                     muffleCondition(cond, pattern = "^muffle")
[17:43:11.886]                   }
[17:43:11.886]                 }
[17:43:11.886]             }
[17:43:11.886]         }))
[17:43:11.886]     }, error = function(ex) {
[17:43:11.886]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:11.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:11.886]                 ...future.rng), started = ...future.startTime, 
[17:43:11.886]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:11.886]             version = "1.8"), class = "FutureResult")
[17:43:11.886]     }, finally = {
[17:43:11.886]         if (!identical(...future.workdir, getwd())) 
[17:43:11.886]             setwd(...future.workdir)
[17:43:11.886]         {
[17:43:11.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:11.886]                 ...future.oldOptions$nwarnings <- NULL
[17:43:11.886]             }
[17:43:11.886]             base::options(...future.oldOptions)
[17:43:11.886]             if (.Platform$OS.type == "windows") {
[17:43:11.886]                 old_names <- names(...future.oldEnvVars)
[17:43:11.886]                 envs <- base::Sys.getenv()
[17:43:11.886]                 names <- names(envs)
[17:43:11.886]                 common <- intersect(names, old_names)
[17:43:11.886]                 added <- setdiff(names, old_names)
[17:43:11.886]                 removed <- setdiff(old_names, names)
[17:43:11.886]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:11.886]                   envs[common]]
[17:43:11.886]                 NAMES <- toupper(changed)
[17:43:11.886]                 args <- list()
[17:43:11.886]                 for (kk in seq_along(NAMES)) {
[17:43:11.886]                   name <- changed[[kk]]
[17:43:11.886]                   NAME <- NAMES[[kk]]
[17:43:11.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.886]                     next
[17:43:11.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.886]                 }
[17:43:11.886]                 NAMES <- toupper(added)
[17:43:11.886]                 for (kk in seq_along(NAMES)) {
[17:43:11.886]                   name <- added[[kk]]
[17:43:11.886]                   NAME <- NAMES[[kk]]
[17:43:11.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.886]                     next
[17:43:11.886]                   args[[name]] <- ""
[17:43:11.886]                 }
[17:43:11.886]                 NAMES <- toupper(removed)
[17:43:11.886]                 for (kk in seq_along(NAMES)) {
[17:43:11.886]                   name <- removed[[kk]]
[17:43:11.886]                   NAME <- NAMES[[kk]]
[17:43:11.886]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:11.886]                     next
[17:43:11.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:11.886]                 }
[17:43:11.886]                 if (length(args) > 0) 
[17:43:11.886]                   base::do.call(base::Sys.setenv, args = args)
[17:43:11.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:11.886]             }
[17:43:11.886]             else {
[17:43:11.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:11.886]             }
[17:43:11.886]             {
[17:43:11.886]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:11.886]                   0L) {
[17:43:11.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:11.886]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:11.886]                   base::options(opts)
[17:43:11.886]                 }
[17:43:11.886]                 {
[17:43:11.886]                   {
[17:43:11.886]                     NULL
[17:43:11.886]                     RNGkind("Mersenne-Twister")
[17:43:11.886]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:11.886]                       inherits = FALSE)
[17:43:11.886]                   }
[17:43:11.886]                   options(future.plan = NULL)
[17:43:11.886]                   if (is.na(NA_character_)) 
[17:43:11.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:11.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:11.886]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:43:11.886]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:11.886]                     envir = parent.frame()) 
[17:43:11.886]                   {
[17:43:11.886]                     if (is.function(workers)) 
[17:43:11.886]                       workers <- workers()
[17:43:11.886]                     workers <- structure(as.integer(workers), 
[17:43:11.886]                       class = class(workers))
[17:43:11.886]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:11.886]                       workers >= 1)
[17:43:11.886]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:11.886]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:11.886]                     }
[17:43:11.886]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:11.886]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:11.886]                       envir = envir)
[17:43:11.886]                     if (!future$lazy) 
[17:43:11.886]                       future <- run(future)
[17:43:11.886]                     invisible(future)
[17:43:11.886]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:11.886]                 }
[17:43:11.886]             }
[17:43:11.886]         }
[17:43:11.886]     })
[17:43:11.886]     if (TRUE) {
[17:43:11.886]         base::sink(type = "output", split = FALSE)
[17:43:11.886]         if (TRUE) {
[17:43:11.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:11.886]         }
[17:43:11.886]         else {
[17:43:11.886]             ...future.result["stdout"] <- base::list(NULL)
[17:43:11.886]         }
[17:43:11.886]         base::close(...future.stdout)
[17:43:11.886]         ...future.stdout <- NULL
[17:43:11.886]     }
[17:43:11.886]     ...future.result$conditions <- ...future.conditions
[17:43:11.886]     ...future.result$finished <- base::Sys.time()
[17:43:11.886]     ...future.result
[17:43:11.886] }
[17:43:11.919]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.888] assign_globals() ...
[17:43:11.919]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.888] List of 1
[17:43:11.888]  $ data:'data.frame':	3 obs. of  2 variables:
[17:43:11.888]   ..$ a: int [1:3] 1 2 3
[17:43:11.888]   ..$ b: int [1:3] 3 2 1
[17:43:11.888]  - attr(*, "where")=List of 1
[17:43:11.888]   ..$ data:<environment: R_EmptyEnv> 
[17:43:11.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:11.888]  - attr(*, "resolved")= logi FALSE
[17:43:11.888]  - attr(*, "total_size")= num 128
[17:43:11.888]  - attr(*, "already-done")= logi TRUE
[17:43:11.919]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.893] - copied ‘data’ to environment
[17:43:11.919]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.893] assign_globals() ... done
[17:43:11.919]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.893] plan(): Setting new future strategy stack:
[17:43:11.919]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.894] List of future strategies:
[17:43:11.894] 1. sequential:
[17:43:11.894]    - args: function (..., envir = parent.frame())
[17:43:11.894]    - tweaked: FALSE
[17:43:11.894]    - call: NULL
[17:43:11.920]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.894] plan(): nbrOfWorkers() = 1
[17:43:11.920]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.895] plan(): Setting new future strategy stack:
[17:43:11.920]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.896] List of future strategies:
[17:43:11.896] 1. multisession:
[17:43:11.896]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.896]    - tweaked: FALSE
[17:43:11.896]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.920]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.900] plan(): nbrOfWorkers() = 1
[17:43:11.920]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.900] SequentialFuture started (and completed)
[17:43:11.920]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.900] - Launch lazy future ... done
[17:43:11.921]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:43:11.900] run() for ‘SequentialFuture’ ... done
[17:43:11.921] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[17:43:11.921] plan(): Setting new future strategy stack:
[17:43:11.921] List of future strategies:
[17:43:11.921] 1. multisession:
[17:43:11.921]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.921]    - tweaked: FALSE
[17:43:11.921]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.921] 2. sequential:
[17:43:11.921]    - args: function (..., envir = parent.frame())
[17:43:11.921]    - tweaked: FALSE
[17:43:11.921]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.922] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:43:11.922] multisession:
[17:43:11.922] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:11.922] - tweaked: FALSE
[17:43:11.922] - call: plan(list(a = strategy1, b = strategy2))
[17:43:11.927] getGlobalsAndPackages() ...
[17:43:11.927] Not searching for globals
[17:43:11.928] - globals: [0] <none>
[17:43:11.928] getGlobalsAndPackages() ... DONE
[17:43:11.928] [local output] makeClusterPSOCK() ...
[17:43:11.928] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:43:11.929] [local output] Base port: 11119
[17:43:11.929] [local output] Getting setup options for 2 cluster nodes ...
[17:43:11.929] [local output]  - Node 1 of 2 ...
[17:43:11.930] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:11.930] [local output] Rscript port: 11119

[17:43:11.931] [local output]  - Node 2 of 2 ...
[17:43:11.931] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:11.932] [local output] Rscript port: 11119

[17:43:11.932] [local output] Getting setup options for 2 cluster nodes ... done
[17:43:11.932] [local output]  - Parallel setup requested for some PSOCK nodes
[17:43:11.933] [local output] Setting up PSOCK nodes in parallel
[17:43:11.933] List of 36
[17:43:11.933]  $ worker          : chr "localhost"
[17:43:11.933]   ..- attr(*, "localhost")= logi TRUE
[17:43:11.933]  $ master          : chr "localhost"
[17:43:11.933]  $ port            : int 11119
[17:43:11.933]  $ connectTimeout  : num 120
[17:43:11.933]  $ timeout         : num 2592000
[17:43:11.933]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:43:11.933]  $ homogeneous     : logi TRUE
[17:43:11.933]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:43:11.933]  $ rscript_envs    : NULL
[17:43:11.933]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:11.933]  $ rscript_startup : NULL
[17:43:11.933]  $ rscript_sh      : chr "sh"
[17:43:11.933]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:11.933]  $ methods         : logi TRUE
[17:43:11.933]  $ socketOptions   : chr "no-delay"
[17:43:11.933]  $ useXDR          : logi FALSE
[17:43:11.933]  $ outfile         : chr "/dev/null"
[17:43:11.933]  $ renice          : int NA
[17:43:11.933]  $ rshcmd          : NULL
[17:43:11.933]  $ user            : chr(0) 
[17:43:11.933]  $ revtunnel       : logi FALSE
[17:43:11.933]  $ rshlogfile      : NULL
[17:43:11.933]  $ rshopts         : chr(0) 
[17:43:11.933]  $ rank            : int 1
[17:43:11.933]  $ manual          : logi FALSE
[17:43:11.933]  $ dryrun          : logi FALSE
[17:43:11.933]  $ quiet           : logi FALSE
[17:43:11.933]  $ setup_strategy  : chr "parallel"
[17:43:11.933]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:11.933]  $ pidfile         : chr "/tmp/RtmpzPUCYD/worker.rank=1.parallelly.parent=50370.c4c26ce07aa9.pid"
[17:43:11.933]  $ rshcmd_label    : NULL
[17:43:11.933]  $ rsh_call        : NULL
[17:43:11.933]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:11.933]  $ localMachine    : logi TRUE
[17:43:11.933]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:43:11.933]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:43:11.933]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:43:11.933]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:43:11.933]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:43:11.933]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:43:11.933]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:43:11.933]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:43:11.933]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:43:11.933]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:43:11.933]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:43:11.933]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:43:11.933]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:43:11.933]  $ arguments       :List of 28
[17:43:11.933]   ..$ worker          : chr "localhost"
[17:43:11.933]   ..$ master          : NULL
[17:43:11.933]   ..$ port            : int 11119
[17:43:11.933]   ..$ connectTimeout  : num 120
[17:43:11.933]   ..$ timeout         : num 2592000
[17:43:11.933]   ..$ rscript         : NULL
[17:43:11.933]   ..$ homogeneous     : NULL
[17:43:11.933]   ..$ rscript_args    : NULL
[17:43:11.933]   ..$ rscript_envs    : NULL
[17:43:11.933]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:11.933]   ..$ rscript_startup : NULL
[17:43:11.933]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:43:11.933]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:11.933]   ..$ methods         : logi TRUE
[17:43:11.933]   ..$ socketOptions   : chr "no-delay"
[17:43:11.933]   ..$ useXDR          : logi FALSE
[17:43:11.933]   ..$ outfile         : chr "/dev/null"
[17:43:11.933]   ..$ renice          : int NA
[17:43:11.933]   ..$ rshcmd          : NULL
[17:43:11.933]   ..$ user            : NULL
[17:43:11.933]   ..$ revtunnel       : logi NA
[17:43:11.933]   ..$ rshlogfile      : NULL
[17:43:11.933]   ..$ rshopts         : NULL
[17:43:11.933]   ..$ rank            : int 1
[17:43:11.933]   ..$ manual          : logi FALSE
[17:43:11.933]   ..$ dryrun          : logi FALSE
[17:43:11.933]   ..$ quiet           : logi FALSE
[17:43:11.933]   ..$ setup_strategy  : chr "parallel"
[17:43:11.933]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:43:11.956] [local output] System call to launch all workers:
[17:43:11.956] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpzPUCYD/worker.rank=1.parallelly.parent=50370.c4c26ce07aa9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11119 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:43:11.956] [local output] Starting PSOCK main server
[17:43:11.957] [local output] Workers launched
[17:43:11.958] [local output] Waiting for workers to connect back
[17:43:11.958]  - [local output] 0 workers out of 2 ready
[17:43:12.204]  - [local output] 0 workers out of 2 ready
[17:43:12.205]  - [local output] 1 workers out of 2 ready
[17:43:12.207]  - [local output] 1 workers out of 2 ready
[17:43:12.207]  - [local output] 2 workers out of 2 ready
[17:43:12.207] [local output] Launching of workers completed
[17:43:12.207] [local output] Collecting session information from workers
[17:43:12.208] [local output]  - Worker #1 of 2
[17:43:12.209] [local output]  - Worker #2 of 2
[17:43:12.209] [local output] makeClusterPSOCK() ... done
[17:43:12.221] Packages needed by the future expression (n = 0): <none>
[17:43:12.221] Packages needed by future strategies (n = 1): ‘future’
[17:43:12.222] {
[17:43:12.222]     {
[17:43:12.222]         {
[17:43:12.222]             ...future.startTime <- base::Sys.time()
[17:43:12.222]             {
[17:43:12.222]                 {
[17:43:12.222]                   {
[17:43:12.222]                     {
[17:43:12.222]                       {
[17:43:12.222]                         base::local({
[17:43:12.222]                           has_future <- base::requireNamespace("future", 
[17:43:12.222]                             quietly = TRUE)
[17:43:12.222]                           if (has_future) {
[17:43:12.222]                             ns <- base::getNamespace("future")
[17:43:12.222]                             version <- ns[[".package"]][["version"]]
[17:43:12.222]                             if (is.null(version)) 
[17:43:12.222]                               version <- utils::packageVersion("future")
[17:43:12.222]                           }
[17:43:12.222]                           else {
[17:43:12.222]                             version <- NULL
[17:43:12.222]                           }
[17:43:12.222]                           if (!has_future || version < "1.8.0") {
[17:43:12.222]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:12.222]                               "", base::R.version$version.string), 
[17:43:12.222]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:12.222]                                 base::R.version$platform, 8 * 
[17:43:12.222]                                   base::.Machine$sizeof.pointer), 
[17:43:12.222]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:12.222]                                 "release", "version")], collapse = " "), 
[17:43:12.222]                               hostname = base::Sys.info()[["nodename"]])
[17:43:12.222]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:12.222]                               info)
[17:43:12.222]                             info <- base::paste(info, collapse = "; ")
[17:43:12.222]                             if (!has_future) {
[17:43:12.222]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:12.222]                                 info)
[17:43:12.222]                             }
[17:43:12.222]                             else {
[17:43:12.222]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:12.222]                                 info, version)
[17:43:12.222]                             }
[17:43:12.222]                             base::stop(msg)
[17:43:12.222]                           }
[17:43:12.222]                         })
[17:43:12.222]                       }
[17:43:12.222]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:12.222]                       base::options(mc.cores = 1L)
[17:43:12.222]                     }
[17:43:12.222]                     base::local({
[17:43:12.222]                       for (pkg in "future") {
[17:43:12.222]                         base::loadNamespace(pkg)
[17:43:12.222]                         base::library(pkg, character.only = TRUE)
[17:43:12.222]                       }
[17:43:12.222]                     })
[17:43:12.222]                   }
[17:43:12.222]                   options(future.plan = NULL)
[17:43:12.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:12.222]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:43:12.222]                   {
[17:43:12.222]                     future <- SequentialFuture(..., envir = envir)
[17:43:12.222]                     if (!future$lazy) 
[17:43:12.222]                       future <- run(future)
[17:43:12.222]                     invisible(future)
[17:43:12.222]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:12.222]                 }
[17:43:12.222]                 ...future.workdir <- getwd()
[17:43:12.222]             }
[17:43:12.222]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:12.222]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:12.222]         }
[17:43:12.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:12.222]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:12.222]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:12.222]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:12.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:12.222]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:12.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:12.222]             base::names(...future.oldOptions))
[17:43:12.222]     }
[17:43:12.222]     if (FALSE) {
[17:43:12.222]     }
[17:43:12.222]     else {
[17:43:12.222]         if (TRUE) {
[17:43:12.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:12.222]                 open = "w")
[17:43:12.222]         }
[17:43:12.222]         else {
[17:43:12.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:12.222]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:12.222]         }
[17:43:12.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:12.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:12.222]             base::sink(type = "output", split = FALSE)
[17:43:12.222]             base::close(...future.stdout)
[17:43:12.222]         }, add = TRUE)
[17:43:12.222]     }
[17:43:12.222]     ...future.frame <- base::sys.nframe()
[17:43:12.222]     ...future.conditions <- base::list()
[17:43:12.222]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:12.222]     if (FALSE) {
[17:43:12.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:12.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:12.222]     }
[17:43:12.222]     ...future.result <- base::tryCatch({
[17:43:12.222]         base::withCallingHandlers({
[17:43:12.222]             ...future.value <- base::withVisible(base::local({
[17:43:12.222]                 ...future.makeSendCondition <- local({
[17:43:12.222]                   sendCondition <- NULL
[17:43:12.222]                   function(frame = 1L) {
[17:43:12.222]                     if (is.function(sendCondition)) 
[17:43:12.222]                       return(sendCondition)
[17:43:12.222]                     ns <- getNamespace("parallel")
[17:43:12.222]                     if (exists("sendData", mode = "function", 
[17:43:12.222]                       envir = ns)) {
[17:43:12.222]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:12.222]                         envir = ns)
[17:43:12.222]                       envir <- sys.frame(frame)
[17:43:12.222]                       master <- NULL
[17:43:12.222]                       while (!identical(envir, .GlobalEnv) && 
[17:43:12.222]                         !identical(envir, emptyenv())) {
[17:43:12.222]                         if (exists("master", mode = "list", envir = envir, 
[17:43:12.222]                           inherits = FALSE)) {
[17:43:12.222]                           master <- get("master", mode = "list", 
[17:43:12.222]                             envir = envir, inherits = FALSE)
[17:43:12.222]                           if (inherits(master, c("SOCKnode", 
[17:43:12.222]                             "SOCK0node"))) {
[17:43:12.222]                             sendCondition <<- function(cond) {
[17:43:12.222]                               data <- list(type = "VALUE", value = cond, 
[17:43:12.222]                                 success = TRUE)
[17:43:12.222]                               parallel_sendData(master, data)
[17:43:12.222]                             }
[17:43:12.222]                             return(sendCondition)
[17:43:12.222]                           }
[17:43:12.222]                         }
[17:43:12.222]                         frame <- frame + 1L
[17:43:12.222]                         envir <- sys.frame(frame)
[17:43:12.222]                       }
[17:43:12.222]                     }
[17:43:12.222]                     sendCondition <<- function(cond) NULL
[17:43:12.222]                   }
[17:43:12.222]                 })
[17:43:12.222]                 withCallingHandlers({
[17:43:12.222]                   NA
[17:43:12.222]                 }, immediateCondition = function(cond) {
[17:43:12.222]                   sendCondition <- ...future.makeSendCondition()
[17:43:12.222]                   sendCondition(cond)
[17:43:12.222]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.222]                   {
[17:43:12.222]                     inherits <- base::inherits
[17:43:12.222]                     invokeRestart <- base::invokeRestart
[17:43:12.222]                     is.null <- base::is.null
[17:43:12.222]                     muffled <- FALSE
[17:43:12.222]                     if (inherits(cond, "message")) {
[17:43:12.222]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:12.222]                       if (muffled) 
[17:43:12.222]                         invokeRestart("muffleMessage")
[17:43:12.222]                     }
[17:43:12.222]                     else if (inherits(cond, "warning")) {
[17:43:12.222]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:12.222]                       if (muffled) 
[17:43:12.222]                         invokeRestart("muffleWarning")
[17:43:12.222]                     }
[17:43:12.222]                     else if (inherits(cond, "condition")) {
[17:43:12.222]                       if (!is.null(pattern)) {
[17:43:12.222]                         computeRestarts <- base::computeRestarts
[17:43:12.222]                         grepl <- base::grepl
[17:43:12.222]                         restarts <- computeRestarts(cond)
[17:43:12.222]                         for (restart in restarts) {
[17:43:12.222]                           name <- restart$name
[17:43:12.222]                           if (is.null(name)) 
[17:43:12.222]                             next
[17:43:12.222]                           if (!grepl(pattern, name)) 
[17:43:12.222]                             next
[17:43:12.222]                           invokeRestart(restart)
[17:43:12.222]                           muffled <- TRUE
[17:43:12.222]                           break
[17:43:12.222]                         }
[17:43:12.222]                       }
[17:43:12.222]                     }
[17:43:12.222]                     invisible(muffled)
[17:43:12.222]                   }
[17:43:12.222]                   muffleCondition(cond)
[17:43:12.222]                 })
[17:43:12.222]             }))
[17:43:12.222]             future::FutureResult(value = ...future.value$value, 
[17:43:12.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:12.222]                   ...future.rng), globalenv = if (FALSE) 
[17:43:12.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:12.222]                     ...future.globalenv.names))
[17:43:12.222]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:12.222]         }, condition = base::local({
[17:43:12.222]             c <- base::c
[17:43:12.222]             inherits <- base::inherits
[17:43:12.222]             invokeRestart <- base::invokeRestart
[17:43:12.222]             length <- base::length
[17:43:12.222]             list <- base::list
[17:43:12.222]             seq.int <- base::seq.int
[17:43:12.222]             signalCondition <- base::signalCondition
[17:43:12.222]             sys.calls <- base::sys.calls
[17:43:12.222]             `[[` <- base::`[[`
[17:43:12.222]             `+` <- base::`+`
[17:43:12.222]             `<<-` <- base::`<<-`
[17:43:12.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:12.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:12.222]                   3L)]
[17:43:12.222]             }
[17:43:12.222]             function(cond) {
[17:43:12.222]                 is_error <- inherits(cond, "error")
[17:43:12.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:12.222]                   NULL)
[17:43:12.222]                 if (is_error) {
[17:43:12.222]                   sessionInformation <- function() {
[17:43:12.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:12.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:12.222]                       search = base::search(), system = base::Sys.info())
[17:43:12.222]                   }
[17:43:12.222]                   ...future.conditions[[length(...future.conditions) + 
[17:43:12.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:12.222]                     cond$call), session = sessionInformation(), 
[17:43:12.222]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:12.222]                   signalCondition(cond)
[17:43:12.222]                 }
[17:43:12.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:12.222]                 "immediateCondition"))) {
[17:43:12.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:12.222]                   ...future.conditions[[length(...future.conditions) + 
[17:43:12.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:12.222]                   if (TRUE && !signal) {
[17:43:12.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.222]                     {
[17:43:12.222]                       inherits <- base::inherits
[17:43:12.222]                       invokeRestart <- base::invokeRestart
[17:43:12.222]                       is.null <- base::is.null
[17:43:12.222]                       muffled <- FALSE
[17:43:12.222]                       if (inherits(cond, "message")) {
[17:43:12.222]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:12.222]                         if (muffled) 
[17:43:12.222]                           invokeRestart("muffleMessage")
[17:43:12.222]                       }
[17:43:12.222]                       else if (inherits(cond, "warning")) {
[17:43:12.222]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:12.222]                         if (muffled) 
[17:43:12.222]                           invokeRestart("muffleWarning")
[17:43:12.222]                       }
[17:43:12.222]                       else if (inherits(cond, "condition")) {
[17:43:12.222]                         if (!is.null(pattern)) {
[17:43:12.222]                           computeRestarts <- base::computeRestarts
[17:43:12.222]                           grepl <- base::grepl
[17:43:12.222]                           restarts <- computeRestarts(cond)
[17:43:12.222]                           for (restart in restarts) {
[17:43:12.222]                             name <- restart$name
[17:43:12.222]                             if (is.null(name)) 
[17:43:12.222]                               next
[17:43:12.222]                             if (!grepl(pattern, name)) 
[17:43:12.222]                               next
[17:43:12.222]                             invokeRestart(restart)
[17:43:12.222]                             muffled <- TRUE
[17:43:12.222]                             break
[17:43:12.222]                           }
[17:43:12.222]                         }
[17:43:12.222]                       }
[17:43:12.222]                       invisible(muffled)
[17:43:12.222]                     }
[17:43:12.222]                     muffleCondition(cond, pattern = "^muffle")
[17:43:12.222]                   }
[17:43:12.222]                 }
[17:43:12.222]                 else {
[17:43:12.222]                   if (TRUE) {
[17:43:12.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.222]                     {
[17:43:12.222]                       inherits <- base::inherits
[17:43:12.222]                       invokeRestart <- base::invokeRestart
[17:43:12.222]                       is.null <- base::is.null
[17:43:12.222]                       muffled <- FALSE
[17:43:12.222]                       if (inherits(cond, "message")) {
[17:43:12.222]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:12.222]                         if (muffled) 
[17:43:12.222]                           invokeRestart("muffleMessage")
[17:43:12.222]                       }
[17:43:12.222]                       else if (inherits(cond, "warning")) {
[17:43:12.222]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:12.222]                         if (muffled) 
[17:43:12.222]                           invokeRestart("muffleWarning")
[17:43:12.222]                       }
[17:43:12.222]                       else if (inherits(cond, "condition")) {
[17:43:12.222]                         if (!is.null(pattern)) {
[17:43:12.222]                           computeRestarts <- base::computeRestarts
[17:43:12.222]                           grepl <- base::grepl
[17:43:12.222]                           restarts <- computeRestarts(cond)
[17:43:12.222]                           for (restart in restarts) {
[17:43:12.222]                             name <- restart$name
[17:43:12.222]                             if (is.null(name)) 
[17:43:12.222]                               next
[17:43:12.222]                             if (!grepl(pattern, name)) 
[17:43:12.222]                               next
[17:43:12.222]                             invokeRestart(restart)
[17:43:12.222]                             muffled <- TRUE
[17:43:12.222]                             break
[17:43:12.222]                           }
[17:43:12.222]                         }
[17:43:12.222]                       }
[17:43:12.222]                       invisible(muffled)
[17:43:12.222]                     }
[17:43:12.222]                     muffleCondition(cond, pattern = "^muffle")
[17:43:12.222]                   }
[17:43:12.222]                 }
[17:43:12.222]             }
[17:43:12.222]         }))
[17:43:12.222]     }, error = function(ex) {
[17:43:12.222]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:12.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:12.222]                 ...future.rng), started = ...future.startTime, 
[17:43:12.222]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:12.222]             version = "1.8"), class = "FutureResult")
[17:43:12.222]     }, finally = {
[17:43:12.222]         if (!identical(...future.workdir, getwd())) 
[17:43:12.222]             setwd(...future.workdir)
[17:43:12.222]         {
[17:43:12.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:12.222]                 ...future.oldOptions$nwarnings <- NULL
[17:43:12.222]             }
[17:43:12.222]             base::options(...future.oldOptions)
[17:43:12.222]             if (.Platform$OS.type == "windows") {
[17:43:12.222]                 old_names <- names(...future.oldEnvVars)
[17:43:12.222]                 envs <- base::Sys.getenv()
[17:43:12.222]                 names <- names(envs)
[17:43:12.222]                 common <- intersect(names, old_names)
[17:43:12.222]                 added <- setdiff(names, old_names)
[17:43:12.222]                 removed <- setdiff(old_names, names)
[17:43:12.222]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:12.222]                   envs[common]]
[17:43:12.222]                 NAMES <- toupper(changed)
[17:43:12.222]                 args <- list()
[17:43:12.222]                 for (kk in seq_along(NAMES)) {
[17:43:12.222]                   name <- changed[[kk]]
[17:43:12.222]                   NAME <- NAMES[[kk]]
[17:43:12.222]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.222]                     next
[17:43:12.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:12.222]                 }
[17:43:12.222]                 NAMES <- toupper(added)
[17:43:12.222]                 for (kk in seq_along(NAMES)) {
[17:43:12.222]                   name <- added[[kk]]
[17:43:12.222]                   NAME <- NAMES[[kk]]
[17:43:12.222]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.222]                     next
[17:43:12.222]                   args[[name]] <- ""
[17:43:12.222]                 }
[17:43:12.222]                 NAMES <- toupper(removed)
[17:43:12.222]                 for (kk in seq_along(NAMES)) {
[17:43:12.222]                   name <- removed[[kk]]
[17:43:12.222]                   NAME <- NAMES[[kk]]
[17:43:12.222]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.222]                     next
[17:43:12.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:12.222]                 }
[17:43:12.222]                 if (length(args) > 0) 
[17:43:12.222]                   base::do.call(base::Sys.setenv, args = args)
[17:43:12.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:12.222]             }
[17:43:12.222]             else {
[17:43:12.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:12.222]             }
[17:43:12.222]             {
[17:43:12.222]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:12.222]                   0L) {
[17:43:12.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:12.222]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:12.222]                   base::options(opts)
[17:43:12.222]                 }
[17:43:12.222]                 {
[17:43:12.222]                   {
[17:43:12.222]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:12.222]                     NULL
[17:43:12.222]                   }
[17:43:12.222]                   options(future.plan = NULL)
[17:43:12.222]                   if (is.na(NA_character_)) 
[17:43:12.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:12.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:12.222]                   future::plan(list(a = function (..., workers = availableCores(), 
[17:43:12.222]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:12.222]                     envir = parent.frame()) 
[17:43:12.222]                   {
[17:43:12.222]                     if (is.function(workers)) 
[17:43:12.222]                       workers <- workers()
[17:43:12.222]                     workers <- structure(as.integer(workers), 
[17:43:12.222]                       class = class(workers))
[17:43:12.222]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:12.222]                       workers >= 1)
[17:43:12.222]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:12.222]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:12.222]                     }
[17:43:12.222]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:12.222]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:12.222]                       envir = envir)
[17:43:12.222]                     if (!future$lazy) 
[17:43:12.222]                       future <- run(future)
[17:43:12.222]                     invisible(future)
[17:43:12.222]                   }, b = function (..., envir = parent.frame()) 
[17:43:12.222]                   {
[17:43:12.222]                     future <- SequentialFuture(..., envir = envir)
[17:43:12.222]                     if (!future$lazy) 
[17:43:12.222]                       future <- run(future)
[17:43:12.222]                     invisible(future)
[17:43:12.222]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:12.222]                 }
[17:43:12.222]             }
[17:43:12.222]         }
[17:43:12.222]     })
[17:43:12.222]     if (TRUE) {
[17:43:12.222]         base::sink(type = "output", split = FALSE)
[17:43:12.222]         if (TRUE) {
[17:43:12.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:12.222]         }
[17:43:12.222]         else {
[17:43:12.222]             ...future.result["stdout"] <- base::list(NULL)
[17:43:12.222]         }
[17:43:12.222]         base::close(...future.stdout)
[17:43:12.222]         ...future.stdout <- NULL
[17:43:12.222]     }
[17:43:12.222]     ...future.result$conditions <- ...future.conditions
[17:43:12.222]     ...future.result$finished <- base::Sys.time()
[17:43:12.222]     ...future.result
[17:43:12.222] }
[17:43:12.297] MultisessionFuture started
[17:43:12.297] result() for ClusterFuture ...
[17:43:12.297] receiveMessageFromWorker() for ClusterFuture ...
[17:43:12.297] - Validating connection of MultisessionFuture
[17:43:12.333] - received message: FutureResult
[17:43:12.333] - Received FutureResult
[17:43:12.333] - Erased future from FutureRegistry
[17:43:12.334] result() for ClusterFuture ...
[17:43:12.334] - result already collected: FutureResult
[17:43:12.334] result() for ClusterFuture ... done
[17:43:12.334] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:12.334] result() for ClusterFuture ... done
[17:43:12.334] result() for ClusterFuture ...
[17:43:12.334] - result already collected: FutureResult
[17:43:12.334] result() for ClusterFuture ... done
[17:43:12.335] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:43:12.338] plan(): nbrOfWorkers() = 2
[17:43:12.339] getGlobalsAndPackages() ...
[17:43:12.339] Searching for globals...
[17:43:12.357] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:43:12.358] Searching for globals ... DONE
[17:43:12.358] Resolving globals: FALSE
[17:43:12.359] The total size of the 2 globals is 55.46 KiB (56792 bytes)
[17:43:12.359] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.34 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:43:12.359] - globals: [2] ‘nested’, ‘strategy2’
[17:43:12.360] - packages: [1] ‘future’
[17:43:12.360] getGlobalsAndPackages() ... DONE
[17:43:12.360] run() for ‘Future’ ...
[17:43:12.360] - state: ‘created’
[17:43:12.360] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:12.377] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:12.377] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:12.377]   - Field: ‘node’
[17:43:12.377]   - Field: ‘label’
[17:43:12.377]   - Field: ‘local’
[17:43:12.377]   - Field: ‘owner’
[17:43:12.377]   - Field: ‘envir’
[17:43:12.377]   - Field: ‘workers’
[17:43:12.377]   - Field: ‘packages’
[17:43:12.378]   - Field: ‘gc’
[17:43:12.378]   - Field: ‘conditions’
[17:43:12.378]   - Field: ‘persistent’
[17:43:12.378]   - Field: ‘expr’
[17:43:12.378]   - Field: ‘uuid’
[17:43:12.378]   - Field: ‘seed’
[17:43:12.378]   - Field: ‘version’
[17:43:12.378]   - Field: ‘result’
[17:43:12.378]   - Field: ‘asynchronous’
[17:43:12.378]   - Field: ‘calls’
[17:43:12.378]   - Field: ‘globals’
[17:43:12.379]   - Field: ‘stdout’
[17:43:12.379]   - Field: ‘earlySignal’
[17:43:12.379]   - Field: ‘lazy’
[17:43:12.379]   - Field: ‘state’
[17:43:12.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:12.379] - Launch lazy future ...
[17:43:12.379] Packages needed by the future expression (n = 1): ‘future’
[17:43:12.380] Packages needed by future strategies (n = 1): ‘future’
[17:43:12.380] {
[17:43:12.380]     {
[17:43:12.380]         {
[17:43:12.380]             ...future.startTime <- base::Sys.time()
[17:43:12.380]             {
[17:43:12.380]                 {
[17:43:12.380]                   {
[17:43:12.380]                     {
[17:43:12.380]                       {
[17:43:12.380]                         base::local({
[17:43:12.380]                           has_future <- base::requireNamespace("future", 
[17:43:12.380]                             quietly = TRUE)
[17:43:12.380]                           if (has_future) {
[17:43:12.380]                             ns <- base::getNamespace("future")
[17:43:12.380]                             version <- ns[[".package"]][["version"]]
[17:43:12.380]                             if (is.null(version)) 
[17:43:12.380]                               version <- utils::packageVersion("future")
[17:43:12.380]                           }
[17:43:12.380]                           else {
[17:43:12.380]                             version <- NULL
[17:43:12.380]                           }
[17:43:12.380]                           if (!has_future || version < "1.8.0") {
[17:43:12.380]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:12.380]                               "", base::R.version$version.string), 
[17:43:12.380]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:12.380]                                 base::R.version$platform, 8 * 
[17:43:12.380]                                   base::.Machine$sizeof.pointer), 
[17:43:12.380]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:12.380]                                 "release", "version")], collapse = " "), 
[17:43:12.380]                               hostname = base::Sys.info()[["nodename"]])
[17:43:12.380]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:12.380]                               info)
[17:43:12.380]                             info <- base::paste(info, collapse = "; ")
[17:43:12.380]                             if (!has_future) {
[17:43:12.380]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:12.380]                                 info)
[17:43:12.380]                             }
[17:43:12.380]                             else {
[17:43:12.380]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:12.380]                                 info, version)
[17:43:12.380]                             }
[17:43:12.380]                             base::stop(msg)
[17:43:12.380]                           }
[17:43:12.380]                         })
[17:43:12.380]                       }
[17:43:12.380]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:12.380]                       base::options(mc.cores = 1L)
[17:43:12.380]                     }
[17:43:12.380]                     base::local({
[17:43:12.380]                       for (pkg in "future") {
[17:43:12.380]                         base::loadNamespace(pkg)
[17:43:12.380]                         base::library(pkg, character.only = TRUE)
[17:43:12.380]                       }
[17:43:12.380]                     })
[17:43:12.380]                   }
[17:43:12.380]                   options(future.plan = NULL)
[17:43:12.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:12.380]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:43:12.380]                   {
[17:43:12.380]                     future <- SequentialFuture(..., envir = envir)
[17:43:12.380]                     if (!future$lazy) 
[17:43:12.380]                       future <- run(future)
[17:43:12.380]                     invisible(future)
[17:43:12.380]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:12.380]                 }
[17:43:12.380]                 ...future.workdir <- getwd()
[17:43:12.380]             }
[17:43:12.380]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:12.380]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:12.380]         }
[17:43:12.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:12.380]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:12.380]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:12.380]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:12.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:12.380]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:12.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:12.380]             base::names(...future.oldOptions))
[17:43:12.380]     }
[17:43:12.380]     if (FALSE) {
[17:43:12.380]     }
[17:43:12.380]     else {
[17:43:12.380]         if (TRUE) {
[17:43:12.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:12.380]                 open = "w")
[17:43:12.380]         }
[17:43:12.380]         else {
[17:43:12.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:12.380]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:12.380]         }
[17:43:12.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:12.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:12.380]             base::sink(type = "output", split = FALSE)
[17:43:12.380]             base::close(...future.stdout)
[17:43:12.380]         }, add = TRUE)
[17:43:12.380]     }
[17:43:12.380]     ...future.frame <- base::sys.nframe()
[17:43:12.380]     ...future.conditions <- base::list()
[17:43:12.380]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:12.380]     if (FALSE) {
[17:43:12.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:12.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:12.380]     }
[17:43:12.380]     ...future.result <- base::tryCatch({
[17:43:12.380]         base::withCallingHandlers({
[17:43:12.380]             ...future.value <- base::withVisible(base::local({
[17:43:12.380]                 ...future.makeSendCondition <- local({
[17:43:12.380]                   sendCondition <- NULL
[17:43:12.380]                   function(frame = 1L) {
[17:43:12.380]                     if (is.function(sendCondition)) 
[17:43:12.380]                       return(sendCondition)
[17:43:12.380]                     ns <- getNamespace("parallel")
[17:43:12.380]                     if (exists("sendData", mode = "function", 
[17:43:12.380]                       envir = ns)) {
[17:43:12.380]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:12.380]                         envir = ns)
[17:43:12.380]                       envir <- sys.frame(frame)
[17:43:12.380]                       master <- NULL
[17:43:12.380]                       while (!identical(envir, .GlobalEnv) && 
[17:43:12.380]                         !identical(envir, emptyenv())) {
[17:43:12.380]                         if (exists("master", mode = "list", envir = envir, 
[17:43:12.380]                           inherits = FALSE)) {
[17:43:12.380]                           master <- get("master", mode = "list", 
[17:43:12.380]                             envir = envir, inherits = FALSE)
[17:43:12.380]                           if (inherits(master, c("SOCKnode", 
[17:43:12.380]                             "SOCK0node"))) {
[17:43:12.380]                             sendCondition <<- function(cond) {
[17:43:12.380]                               data <- list(type = "VALUE", value = cond, 
[17:43:12.380]                                 success = TRUE)
[17:43:12.380]                               parallel_sendData(master, data)
[17:43:12.380]                             }
[17:43:12.380]                             return(sendCondition)
[17:43:12.380]                           }
[17:43:12.380]                         }
[17:43:12.380]                         frame <- frame + 1L
[17:43:12.380]                         envir <- sys.frame(frame)
[17:43:12.380]                       }
[17:43:12.380]                     }
[17:43:12.380]                     sendCondition <<- function(cond) NULL
[17:43:12.380]                   }
[17:43:12.380]                 })
[17:43:12.380]                 withCallingHandlers({
[17:43:12.380]                   {
[17:43:12.380]                     a <- 1L
[17:43:12.380]                     plan_a <- unclass(future::plan("list"))
[17:43:12.380]                     nested_a <- nested[-1]
[17:43:12.380]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:43:12.380]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:43:12.380]                       strategy2))
[17:43:12.380]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:43:12.380]                       "init") <- NULL
[17:43:12.380]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:43:12.380]                       "init") <- NULL
[17:43:12.380]                     stopifnot(all.equal(plan_a, nested_a))
[17:43:12.380]                     y %<-% {
[17:43:12.380]                       b <- 2L
[17:43:12.380]                       plan_b <- future::plan("list")
[17:43:12.380]                       nested_b <- nested_a[-1]
[17:43:12.380]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:12.380]                         1L, inherits(plan_b[[1]], "future"), 
[17:43:12.380]                         inherits(future::plan("next"), "sequential"))
[17:43:12.380]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:12.380]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:12.380]                     }
[17:43:12.380]                     y
[17:43:12.380]                   }
[17:43:12.380]                 }, immediateCondition = function(cond) {
[17:43:12.380]                   sendCondition <- ...future.makeSendCondition()
[17:43:12.380]                   sendCondition(cond)
[17:43:12.380]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.380]                   {
[17:43:12.380]                     inherits <- base::inherits
[17:43:12.380]                     invokeRestart <- base::invokeRestart
[17:43:12.380]                     is.null <- base::is.null
[17:43:12.380]                     muffled <- FALSE
[17:43:12.380]                     if (inherits(cond, "message")) {
[17:43:12.380]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:12.380]                       if (muffled) 
[17:43:12.380]                         invokeRestart("muffleMessage")
[17:43:12.380]                     }
[17:43:12.380]                     else if (inherits(cond, "warning")) {
[17:43:12.380]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:12.380]                       if (muffled) 
[17:43:12.380]                         invokeRestart("muffleWarning")
[17:43:12.380]                     }
[17:43:12.380]                     else if (inherits(cond, "condition")) {
[17:43:12.380]                       if (!is.null(pattern)) {
[17:43:12.380]                         computeRestarts <- base::computeRestarts
[17:43:12.380]                         grepl <- base::grepl
[17:43:12.380]                         restarts <- computeRestarts(cond)
[17:43:12.380]                         for (restart in restarts) {
[17:43:12.380]                           name <- restart$name
[17:43:12.380]                           if (is.null(name)) 
[17:43:12.380]                             next
[17:43:12.380]                           if (!grepl(pattern, name)) 
[17:43:12.380]                             next
[17:43:12.380]                           invokeRestart(restart)
[17:43:12.380]                           muffled <- TRUE
[17:43:12.380]                           break
[17:43:12.380]                         }
[17:43:12.380]                       }
[17:43:12.380]                     }
[17:43:12.380]                     invisible(muffled)
[17:43:12.380]                   }
[17:43:12.380]                   muffleCondition(cond)
[17:43:12.380]                 })
[17:43:12.380]             }))
[17:43:12.380]             future::FutureResult(value = ...future.value$value, 
[17:43:12.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:12.380]                   ...future.rng), globalenv = if (FALSE) 
[17:43:12.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:12.380]                     ...future.globalenv.names))
[17:43:12.380]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:12.380]         }, condition = base::local({
[17:43:12.380]             c <- base::c
[17:43:12.380]             inherits <- base::inherits
[17:43:12.380]             invokeRestart <- base::invokeRestart
[17:43:12.380]             length <- base::length
[17:43:12.380]             list <- base::list
[17:43:12.380]             seq.int <- base::seq.int
[17:43:12.380]             signalCondition <- base::signalCondition
[17:43:12.380]             sys.calls <- base::sys.calls
[17:43:12.380]             `[[` <- base::`[[`
[17:43:12.380]             `+` <- base::`+`
[17:43:12.380]             `<<-` <- base::`<<-`
[17:43:12.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:12.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:12.380]                   3L)]
[17:43:12.380]             }
[17:43:12.380]             function(cond) {
[17:43:12.380]                 is_error <- inherits(cond, "error")
[17:43:12.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:12.380]                   NULL)
[17:43:12.380]                 if (is_error) {
[17:43:12.380]                   sessionInformation <- function() {
[17:43:12.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:12.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:12.380]                       search = base::search(), system = base::Sys.info())
[17:43:12.380]                   }
[17:43:12.380]                   ...future.conditions[[length(...future.conditions) + 
[17:43:12.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:12.380]                     cond$call), session = sessionInformation(), 
[17:43:12.380]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:12.380]                   signalCondition(cond)
[17:43:12.380]                 }
[17:43:12.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:12.380]                 "immediateCondition"))) {
[17:43:12.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:12.380]                   ...future.conditions[[length(...future.conditions) + 
[17:43:12.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:12.380]                   if (TRUE && !signal) {
[17:43:12.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.380]                     {
[17:43:12.380]                       inherits <- base::inherits
[17:43:12.380]                       invokeRestart <- base::invokeRestart
[17:43:12.380]                       is.null <- base::is.null
[17:43:12.380]                       muffled <- FALSE
[17:43:12.380]                       if (inherits(cond, "message")) {
[17:43:12.380]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:12.380]                         if (muffled) 
[17:43:12.380]                           invokeRestart("muffleMessage")
[17:43:12.380]                       }
[17:43:12.380]                       else if (inherits(cond, "warning")) {
[17:43:12.380]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:12.380]                         if (muffled) 
[17:43:12.380]                           invokeRestart("muffleWarning")
[17:43:12.380]                       }
[17:43:12.380]                       else if (inherits(cond, "condition")) {
[17:43:12.380]                         if (!is.null(pattern)) {
[17:43:12.380]                           computeRestarts <- base::computeRestarts
[17:43:12.380]                           grepl <- base::grepl
[17:43:12.380]                           restarts <- computeRestarts(cond)
[17:43:12.380]                           for (restart in restarts) {
[17:43:12.380]                             name <- restart$name
[17:43:12.380]                             if (is.null(name)) 
[17:43:12.380]                               next
[17:43:12.380]                             if (!grepl(pattern, name)) 
[17:43:12.380]                               next
[17:43:12.380]                             invokeRestart(restart)
[17:43:12.380]                             muffled <- TRUE
[17:43:12.380]                             break
[17:43:12.380]                           }
[17:43:12.380]                         }
[17:43:12.380]                       }
[17:43:12.380]                       invisible(muffled)
[17:43:12.380]                     }
[17:43:12.380]                     muffleCondition(cond, pattern = "^muffle")
[17:43:12.380]                   }
[17:43:12.380]                 }
[17:43:12.380]                 else {
[17:43:12.380]                   if (TRUE) {
[17:43:12.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.380]                     {
[17:43:12.380]                       inherits <- base::inherits
[17:43:12.380]                       invokeRestart <- base::invokeRestart
[17:43:12.380]                       is.null <- base::is.null
[17:43:12.380]                       muffled <- FALSE
[17:43:12.380]                       if (inherits(cond, "message")) {
[17:43:12.380]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:12.380]                         if (muffled) 
[17:43:12.380]                           invokeRestart("muffleMessage")
[17:43:12.380]                       }
[17:43:12.380]                       else if (inherits(cond, "warning")) {
[17:43:12.380]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:12.380]                         if (muffled) 
[17:43:12.380]                           invokeRestart("muffleWarning")
[17:43:12.380]                       }
[17:43:12.380]                       else if (inherits(cond, "condition")) {
[17:43:12.380]                         if (!is.null(pattern)) {
[17:43:12.380]                           computeRestarts <- base::computeRestarts
[17:43:12.380]                           grepl <- base::grepl
[17:43:12.380]                           restarts <- computeRestarts(cond)
[17:43:12.380]                           for (restart in restarts) {
[17:43:12.380]                             name <- restart$name
[17:43:12.380]                             if (is.null(name)) 
[17:43:12.380]                               next
[17:43:12.380]                             if (!grepl(pattern, name)) 
[17:43:12.380]                               next
[17:43:12.380]                             invokeRestart(restart)
[17:43:12.380]                             muffled <- TRUE
[17:43:12.380]                             break
[17:43:12.380]                           }
[17:43:12.380]                         }
[17:43:12.380]                       }
[17:43:12.380]                       invisible(muffled)
[17:43:12.380]                     }
[17:43:12.380]                     muffleCondition(cond, pattern = "^muffle")
[17:43:12.380]                   }
[17:43:12.380]                 }
[17:43:12.380]             }
[17:43:12.380]         }))
[17:43:12.380]     }, error = function(ex) {
[17:43:12.380]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:12.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:12.380]                 ...future.rng), started = ...future.startTime, 
[17:43:12.380]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:12.380]             version = "1.8"), class = "FutureResult")
[17:43:12.380]     }, finally = {
[17:43:12.380]         if (!identical(...future.workdir, getwd())) 
[17:43:12.380]             setwd(...future.workdir)
[17:43:12.380]         {
[17:43:12.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:12.380]                 ...future.oldOptions$nwarnings <- NULL
[17:43:12.380]             }
[17:43:12.380]             base::options(...future.oldOptions)
[17:43:12.380]             if (.Platform$OS.type == "windows") {
[17:43:12.380]                 old_names <- names(...future.oldEnvVars)
[17:43:12.380]                 envs <- base::Sys.getenv()
[17:43:12.380]                 names <- names(envs)
[17:43:12.380]                 common <- intersect(names, old_names)
[17:43:12.380]                 added <- setdiff(names, old_names)
[17:43:12.380]                 removed <- setdiff(old_names, names)
[17:43:12.380]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:12.380]                   envs[common]]
[17:43:12.380]                 NAMES <- toupper(changed)
[17:43:12.380]                 args <- list()
[17:43:12.380]                 for (kk in seq_along(NAMES)) {
[17:43:12.380]                   name <- changed[[kk]]
[17:43:12.380]                   NAME <- NAMES[[kk]]
[17:43:12.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.380]                     next
[17:43:12.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:12.380]                 }
[17:43:12.380]                 NAMES <- toupper(added)
[17:43:12.380]                 for (kk in seq_along(NAMES)) {
[17:43:12.380]                   name <- added[[kk]]
[17:43:12.380]                   NAME <- NAMES[[kk]]
[17:43:12.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.380]                     next
[17:43:12.380]                   args[[name]] <- ""
[17:43:12.380]                 }
[17:43:12.380]                 NAMES <- toupper(removed)
[17:43:12.380]                 for (kk in seq_along(NAMES)) {
[17:43:12.380]                   name <- removed[[kk]]
[17:43:12.380]                   NAME <- NAMES[[kk]]
[17:43:12.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.380]                     next
[17:43:12.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:12.380]                 }
[17:43:12.380]                 if (length(args) > 0) 
[17:43:12.380]                   base::do.call(base::Sys.setenv, args = args)
[17:43:12.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:12.380]             }
[17:43:12.380]             else {
[17:43:12.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:12.380]             }
[17:43:12.380]             {
[17:43:12.380]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:12.380]                   0L) {
[17:43:12.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:12.380]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:12.380]                   base::options(opts)
[17:43:12.380]                 }
[17:43:12.380]                 {
[17:43:12.380]                   {
[17:43:12.380]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:12.380]                     NULL
[17:43:12.380]                   }
[17:43:12.380]                   options(future.plan = NULL)
[17:43:12.380]                   if (is.na(NA_character_)) 
[17:43:12.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:12.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:12.380]                   future::plan(list(a = function (..., workers = availableCores(), 
[17:43:12.380]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:12.380]                     envir = parent.frame()) 
[17:43:12.380]                   {
[17:43:12.380]                     if (is.function(workers)) 
[17:43:12.380]                       workers <- workers()
[17:43:12.380]                     workers <- structure(as.integer(workers), 
[17:43:12.380]                       class = class(workers))
[17:43:12.380]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:12.380]                       workers >= 1)
[17:43:12.380]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:12.380]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:12.380]                     }
[17:43:12.380]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:12.380]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:12.380]                       envir = envir)
[17:43:12.380]                     if (!future$lazy) 
[17:43:12.380]                       future <- run(future)
[17:43:12.380]                     invisible(future)
[17:43:12.380]                   }, b = function (..., envir = parent.frame()) 
[17:43:12.380]                   {
[17:43:12.380]                     future <- SequentialFuture(..., envir = envir)
[17:43:12.380]                     if (!future$lazy) 
[17:43:12.380]                       future <- run(future)
[17:43:12.380]                     invisible(future)
[17:43:12.380]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:12.380]                 }
[17:43:12.380]             }
[17:43:12.380]         }
[17:43:12.380]     })
[17:43:12.380]     if (TRUE) {
[17:43:12.380]         base::sink(type = "output", split = FALSE)
[17:43:12.380]         if (TRUE) {
[17:43:12.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:12.380]         }
[17:43:12.380]         else {
[17:43:12.380]             ...future.result["stdout"] <- base::list(NULL)
[17:43:12.380]         }
[17:43:12.380]         base::close(...future.stdout)
[17:43:12.380]         ...future.stdout <- NULL
[17:43:12.380]     }
[17:43:12.380]     ...future.result$conditions <- ...future.conditions
[17:43:12.380]     ...future.result$finished <- base::Sys.time()
[17:43:12.380]     ...future.result
[17:43:12.380] }
[17:43:12.383] Exporting 2 global objects (55.46 KiB) to cluster node #1 ...
[17:43:12.383] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ...
[17:43:12.427] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ... DONE
[17:43:12.427] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[17:43:12.428] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[17:43:12.428] Exporting 2 global objects (55.46 KiB) to cluster node #1 ... DONE
[17:43:12.429] MultisessionFuture started
[17:43:12.429] - Launch lazy future ... done
[17:43:12.429] run() for ‘MultisessionFuture’ ... done
[17:43:12.429] result() for ClusterFuture ...
[17:43:12.429] receiveMessageFromWorker() for ClusterFuture ...
[17:43:12.430] - Validating connection of MultisessionFuture
[17:43:12.496] - received message: FutureResult
[17:43:12.496] - Received FutureResult
[17:43:12.496] - Erased future from FutureRegistry
[17:43:12.496] result() for ClusterFuture ...
[17:43:12.496] - result already collected: FutureResult
[17:43:12.497] result() for ClusterFuture ... done
[17:43:12.497] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:12.497] result() for ClusterFuture ... done
[17:43:12.497] result() for ClusterFuture ...
[17:43:12.497] - result already collected: FutureResult
[17:43:12.497] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:12.502] getGlobalsAndPackages() ...
[17:43:12.502] Searching for globals...
[17:43:12.504] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:12.504] Searching for globals ... DONE
[17:43:12.504] Resolving globals: FALSE
[17:43:12.504] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:12.505] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:12.505] - globals: [1] ‘data’
[17:43:12.505] - packages: [1] ‘future’
[17:43:12.505] getGlobalsAndPackages() ... DONE
[17:43:12.506] run() for ‘Future’ ...
[17:43:12.506] - state: ‘created’
[17:43:12.506] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:12.521] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:12.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:12.522]   - Field: ‘node’
[17:43:12.522]   - Field: ‘label’
[17:43:12.522]   - Field: ‘local’
[17:43:12.522]   - Field: ‘owner’
[17:43:12.522]   - Field: ‘envir’
[17:43:12.522]   - Field: ‘workers’
[17:43:12.522]   - Field: ‘packages’
[17:43:12.522]   - Field: ‘gc’
[17:43:12.523]   - Field: ‘conditions’
[17:43:12.523]   - Field: ‘persistent’
[17:43:12.523]   - Field: ‘expr’
[17:43:12.523]   - Field: ‘uuid’
[17:43:12.523]   - Field: ‘seed’
[17:43:12.523]   - Field: ‘version’
[17:43:12.523]   - Field: ‘result’
[17:43:12.523]   - Field: ‘asynchronous’
[17:43:12.523]   - Field: ‘calls’
[17:43:12.523]   - Field: ‘globals’
[17:43:12.524]   - Field: ‘stdout’
[17:43:12.524]   - Field: ‘earlySignal’
[17:43:12.524]   - Field: ‘lazy’
[17:43:12.524]   - Field: ‘state’
[17:43:12.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:12.524] - Launch lazy future ...
[17:43:12.524] Packages needed by the future expression (n = 1): ‘future’
[17:43:12.524] Packages needed by future strategies (n = 1): ‘future’
[17:43:12.525] {
[17:43:12.525]     {
[17:43:12.525]         {
[17:43:12.525]             ...future.startTime <- base::Sys.time()
[17:43:12.525]             {
[17:43:12.525]                 {
[17:43:12.525]                   {
[17:43:12.525]                     {
[17:43:12.525]                       {
[17:43:12.525]                         base::local({
[17:43:12.525]                           has_future <- base::requireNamespace("future", 
[17:43:12.525]                             quietly = TRUE)
[17:43:12.525]                           if (has_future) {
[17:43:12.525]                             ns <- base::getNamespace("future")
[17:43:12.525]                             version <- ns[[".package"]][["version"]]
[17:43:12.525]                             if (is.null(version)) 
[17:43:12.525]                               version <- utils::packageVersion("future")
[17:43:12.525]                           }
[17:43:12.525]                           else {
[17:43:12.525]                             version <- NULL
[17:43:12.525]                           }
[17:43:12.525]                           if (!has_future || version < "1.8.0") {
[17:43:12.525]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:12.525]                               "", base::R.version$version.string), 
[17:43:12.525]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:12.525]                                 base::R.version$platform, 8 * 
[17:43:12.525]                                   base::.Machine$sizeof.pointer), 
[17:43:12.525]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:12.525]                                 "release", "version")], collapse = " "), 
[17:43:12.525]                               hostname = base::Sys.info()[["nodename"]])
[17:43:12.525]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:12.525]                               info)
[17:43:12.525]                             info <- base::paste(info, collapse = "; ")
[17:43:12.525]                             if (!has_future) {
[17:43:12.525]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:12.525]                                 info)
[17:43:12.525]                             }
[17:43:12.525]                             else {
[17:43:12.525]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:12.525]                                 info, version)
[17:43:12.525]                             }
[17:43:12.525]                             base::stop(msg)
[17:43:12.525]                           }
[17:43:12.525]                         })
[17:43:12.525]                       }
[17:43:12.525]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:12.525]                       base::options(mc.cores = 1L)
[17:43:12.525]                     }
[17:43:12.525]                     base::local({
[17:43:12.525]                       for (pkg in "future") {
[17:43:12.525]                         base::loadNamespace(pkg)
[17:43:12.525]                         base::library(pkg, character.only = TRUE)
[17:43:12.525]                       }
[17:43:12.525]                     })
[17:43:12.525]                   }
[17:43:12.525]                   options(future.plan = NULL)
[17:43:12.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:12.525]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:43:12.525]                   {
[17:43:12.525]                     future <- SequentialFuture(..., envir = envir)
[17:43:12.525]                     if (!future$lazy) 
[17:43:12.525]                       future <- run(future)
[17:43:12.525]                     invisible(future)
[17:43:12.525]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:12.525]                 }
[17:43:12.525]                 ...future.workdir <- getwd()
[17:43:12.525]             }
[17:43:12.525]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:12.525]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:12.525]         }
[17:43:12.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:12.525]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:12.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:12.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:12.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:12.525]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:12.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:12.525]             base::names(...future.oldOptions))
[17:43:12.525]     }
[17:43:12.525]     if (FALSE) {
[17:43:12.525]     }
[17:43:12.525]     else {
[17:43:12.525]         if (TRUE) {
[17:43:12.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:12.525]                 open = "w")
[17:43:12.525]         }
[17:43:12.525]         else {
[17:43:12.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:12.525]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:12.525]         }
[17:43:12.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:12.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:12.525]             base::sink(type = "output", split = FALSE)
[17:43:12.525]             base::close(...future.stdout)
[17:43:12.525]         }, add = TRUE)
[17:43:12.525]     }
[17:43:12.525]     ...future.frame <- base::sys.nframe()
[17:43:12.525]     ...future.conditions <- base::list()
[17:43:12.525]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:12.525]     if (FALSE) {
[17:43:12.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:12.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:12.525]     }
[17:43:12.525]     ...future.result <- base::tryCatch({
[17:43:12.525]         base::withCallingHandlers({
[17:43:12.525]             ...future.value <- base::withVisible(base::local({
[17:43:12.525]                 ...future.makeSendCondition <- local({
[17:43:12.525]                   sendCondition <- NULL
[17:43:12.525]                   function(frame = 1L) {
[17:43:12.525]                     if (is.function(sendCondition)) 
[17:43:12.525]                       return(sendCondition)
[17:43:12.525]                     ns <- getNamespace("parallel")
[17:43:12.525]                     if (exists("sendData", mode = "function", 
[17:43:12.525]                       envir = ns)) {
[17:43:12.525]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:12.525]                         envir = ns)
[17:43:12.525]                       envir <- sys.frame(frame)
[17:43:12.525]                       master <- NULL
[17:43:12.525]                       while (!identical(envir, .GlobalEnv) && 
[17:43:12.525]                         !identical(envir, emptyenv())) {
[17:43:12.525]                         if (exists("master", mode = "list", envir = envir, 
[17:43:12.525]                           inherits = FALSE)) {
[17:43:12.525]                           master <- get("master", mode = "list", 
[17:43:12.525]                             envir = envir, inherits = FALSE)
[17:43:12.525]                           if (inherits(master, c("SOCKnode", 
[17:43:12.525]                             "SOCK0node"))) {
[17:43:12.525]                             sendCondition <<- function(cond) {
[17:43:12.525]                               data <- list(type = "VALUE", value = cond, 
[17:43:12.525]                                 success = TRUE)
[17:43:12.525]                               parallel_sendData(master, data)
[17:43:12.525]                             }
[17:43:12.525]                             return(sendCondition)
[17:43:12.525]                           }
[17:43:12.525]                         }
[17:43:12.525]                         frame <- frame + 1L
[17:43:12.525]                         envir <- sys.frame(frame)
[17:43:12.525]                       }
[17:43:12.525]                     }
[17:43:12.525]                     sendCondition <<- function(cond) NULL
[17:43:12.525]                   }
[17:43:12.525]                 })
[17:43:12.525]                 withCallingHandlers({
[17:43:12.525]                   {
[17:43:12.525]                     value(future(subset(data, a == 2)))
[17:43:12.525]                   }
[17:43:12.525]                 }, immediateCondition = function(cond) {
[17:43:12.525]                   sendCondition <- ...future.makeSendCondition()
[17:43:12.525]                   sendCondition(cond)
[17:43:12.525]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.525]                   {
[17:43:12.525]                     inherits <- base::inherits
[17:43:12.525]                     invokeRestart <- base::invokeRestart
[17:43:12.525]                     is.null <- base::is.null
[17:43:12.525]                     muffled <- FALSE
[17:43:12.525]                     if (inherits(cond, "message")) {
[17:43:12.525]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:12.525]                       if (muffled) 
[17:43:12.525]                         invokeRestart("muffleMessage")
[17:43:12.525]                     }
[17:43:12.525]                     else if (inherits(cond, "warning")) {
[17:43:12.525]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:12.525]                       if (muffled) 
[17:43:12.525]                         invokeRestart("muffleWarning")
[17:43:12.525]                     }
[17:43:12.525]                     else if (inherits(cond, "condition")) {
[17:43:12.525]                       if (!is.null(pattern)) {
[17:43:12.525]                         computeRestarts <- base::computeRestarts
[17:43:12.525]                         grepl <- base::grepl
[17:43:12.525]                         restarts <- computeRestarts(cond)
[17:43:12.525]                         for (restart in restarts) {
[17:43:12.525]                           name <- restart$name
[17:43:12.525]                           if (is.null(name)) 
[17:43:12.525]                             next
[17:43:12.525]                           if (!grepl(pattern, name)) 
[17:43:12.525]                             next
[17:43:12.525]                           invokeRestart(restart)
[17:43:12.525]                           muffled <- TRUE
[17:43:12.525]                           break
[17:43:12.525]                         }
[17:43:12.525]                       }
[17:43:12.525]                     }
[17:43:12.525]                     invisible(muffled)
[17:43:12.525]                   }
[17:43:12.525]                   muffleCondition(cond)
[17:43:12.525]                 })
[17:43:12.525]             }))
[17:43:12.525]             future::FutureResult(value = ...future.value$value, 
[17:43:12.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:12.525]                   ...future.rng), globalenv = if (FALSE) 
[17:43:12.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:12.525]                     ...future.globalenv.names))
[17:43:12.525]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:12.525]         }, condition = base::local({
[17:43:12.525]             c <- base::c
[17:43:12.525]             inherits <- base::inherits
[17:43:12.525]             invokeRestart <- base::invokeRestart
[17:43:12.525]             length <- base::length
[17:43:12.525]             list <- base::list
[17:43:12.525]             seq.int <- base::seq.int
[17:43:12.525]             signalCondition <- base::signalCondition
[17:43:12.525]             sys.calls <- base::sys.calls
[17:43:12.525]             `[[` <- base::`[[`
[17:43:12.525]             `+` <- base::`+`
[17:43:12.525]             `<<-` <- base::`<<-`
[17:43:12.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:12.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:12.525]                   3L)]
[17:43:12.525]             }
[17:43:12.525]             function(cond) {
[17:43:12.525]                 is_error <- inherits(cond, "error")
[17:43:12.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:12.525]                   NULL)
[17:43:12.525]                 if (is_error) {
[17:43:12.525]                   sessionInformation <- function() {
[17:43:12.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:12.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:12.525]                       search = base::search(), system = base::Sys.info())
[17:43:12.525]                   }
[17:43:12.525]                   ...future.conditions[[length(...future.conditions) + 
[17:43:12.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:12.525]                     cond$call), session = sessionInformation(), 
[17:43:12.525]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:12.525]                   signalCondition(cond)
[17:43:12.525]                 }
[17:43:12.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:12.525]                 "immediateCondition"))) {
[17:43:12.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:12.525]                   ...future.conditions[[length(...future.conditions) + 
[17:43:12.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:12.525]                   if (TRUE && !signal) {
[17:43:12.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.525]                     {
[17:43:12.525]                       inherits <- base::inherits
[17:43:12.525]                       invokeRestart <- base::invokeRestart
[17:43:12.525]                       is.null <- base::is.null
[17:43:12.525]                       muffled <- FALSE
[17:43:12.525]                       if (inherits(cond, "message")) {
[17:43:12.525]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:12.525]                         if (muffled) 
[17:43:12.525]                           invokeRestart("muffleMessage")
[17:43:12.525]                       }
[17:43:12.525]                       else if (inherits(cond, "warning")) {
[17:43:12.525]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:12.525]                         if (muffled) 
[17:43:12.525]                           invokeRestart("muffleWarning")
[17:43:12.525]                       }
[17:43:12.525]                       else if (inherits(cond, "condition")) {
[17:43:12.525]                         if (!is.null(pattern)) {
[17:43:12.525]                           computeRestarts <- base::computeRestarts
[17:43:12.525]                           grepl <- base::grepl
[17:43:12.525]                           restarts <- computeRestarts(cond)
[17:43:12.525]                           for (restart in restarts) {
[17:43:12.525]                             name <- restart$name
[17:43:12.525]                             if (is.null(name)) 
[17:43:12.525]                               next
[17:43:12.525]                             if (!grepl(pattern, name)) 
[17:43:12.525]                               next
[17:43:12.525]                             invokeRestart(restart)
[17:43:12.525]                             muffled <- TRUE
[17:43:12.525]                             break
[17:43:12.525]                           }
[17:43:12.525]                         }
[17:43:12.525]                       }
[17:43:12.525]                       invisible(muffled)
[17:43:12.525]                     }
[17:43:12.525]                     muffleCondition(cond, pattern = "^muffle")
[17:43:12.525]                   }
[17:43:12.525]                 }
[17:43:12.525]                 else {
[17:43:12.525]                   if (TRUE) {
[17:43:12.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.525]                     {
[17:43:12.525]                       inherits <- base::inherits
[17:43:12.525]                       invokeRestart <- base::invokeRestart
[17:43:12.525]                       is.null <- base::is.null
[17:43:12.525]                       muffled <- FALSE
[17:43:12.525]                       if (inherits(cond, "message")) {
[17:43:12.525]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:12.525]                         if (muffled) 
[17:43:12.525]                           invokeRestart("muffleMessage")
[17:43:12.525]                       }
[17:43:12.525]                       else if (inherits(cond, "warning")) {
[17:43:12.525]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:12.525]                         if (muffled) 
[17:43:12.525]                           invokeRestart("muffleWarning")
[17:43:12.525]                       }
[17:43:12.525]                       else if (inherits(cond, "condition")) {
[17:43:12.525]                         if (!is.null(pattern)) {
[17:43:12.525]                           computeRestarts <- base::computeRestarts
[17:43:12.525]                           grepl <- base::grepl
[17:43:12.525]                           restarts <- computeRestarts(cond)
[17:43:12.525]                           for (restart in restarts) {
[17:43:12.525]                             name <- restart$name
[17:43:12.525]                             if (is.null(name)) 
[17:43:12.525]                               next
[17:43:12.525]                             if (!grepl(pattern, name)) 
[17:43:12.525]                               next
[17:43:12.525]                             invokeRestart(restart)
[17:43:12.525]                             muffled <- TRUE
[17:43:12.525]                             break
[17:43:12.525]                           }
[17:43:12.525]                         }
[17:43:12.525]                       }
[17:43:12.525]                       invisible(muffled)
[17:43:12.525]                     }
[17:43:12.525]                     muffleCondition(cond, pattern = "^muffle")
[17:43:12.525]                   }
[17:43:12.525]                 }
[17:43:12.525]             }
[17:43:12.525]         }))
[17:43:12.525]     }, error = function(ex) {
[17:43:12.525]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:12.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:12.525]                 ...future.rng), started = ...future.startTime, 
[17:43:12.525]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:12.525]             version = "1.8"), class = "FutureResult")
[17:43:12.525]     }, finally = {
[17:43:12.525]         if (!identical(...future.workdir, getwd())) 
[17:43:12.525]             setwd(...future.workdir)
[17:43:12.525]         {
[17:43:12.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:12.525]                 ...future.oldOptions$nwarnings <- NULL
[17:43:12.525]             }
[17:43:12.525]             base::options(...future.oldOptions)
[17:43:12.525]             if (.Platform$OS.type == "windows") {
[17:43:12.525]                 old_names <- names(...future.oldEnvVars)
[17:43:12.525]                 envs <- base::Sys.getenv()
[17:43:12.525]                 names <- names(envs)
[17:43:12.525]                 common <- intersect(names, old_names)
[17:43:12.525]                 added <- setdiff(names, old_names)
[17:43:12.525]                 removed <- setdiff(old_names, names)
[17:43:12.525]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:12.525]                   envs[common]]
[17:43:12.525]                 NAMES <- toupper(changed)
[17:43:12.525]                 args <- list()
[17:43:12.525]                 for (kk in seq_along(NAMES)) {
[17:43:12.525]                   name <- changed[[kk]]
[17:43:12.525]                   NAME <- NAMES[[kk]]
[17:43:12.525]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.525]                     next
[17:43:12.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:12.525]                 }
[17:43:12.525]                 NAMES <- toupper(added)
[17:43:12.525]                 for (kk in seq_along(NAMES)) {
[17:43:12.525]                   name <- added[[kk]]
[17:43:12.525]                   NAME <- NAMES[[kk]]
[17:43:12.525]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.525]                     next
[17:43:12.525]                   args[[name]] <- ""
[17:43:12.525]                 }
[17:43:12.525]                 NAMES <- toupper(removed)
[17:43:12.525]                 for (kk in seq_along(NAMES)) {
[17:43:12.525]                   name <- removed[[kk]]
[17:43:12.525]                   NAME <- NAMES[[kk]]
[17:43:12.525]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.525]                     next
[17:43:12.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:12.525]                 }
[17:43:12.525]                 if (length(args) > 0) 
[17:43:12.525]                   base::do.call(base::Sys.setenv, args = args)
[17:43:12.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:12.525]             }
[17:43:12.525]             else {
[17:43:12.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:12.525]             }
[17:43:12.525]             {
[17:43:12.525]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:12.525]                   0L) {
[17:43:12.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:12.525]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:12.525]                   base::options(opts)
[17:43:12.525]                 }
[17:43:12.525]                 {
[17:43:12.525]                   {
[17:43:12.525]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:12.525]                     NULL
[17:43:12.525]                   }
[17:43:12.525]                   options(future.plan = NULL)
[17:43:12.525]                   if (is.na(NA_character_)) 
[17:43:12.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:12.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:12.525]                   future::plan(list(a = function (..., workers = availableCores(), 
[17:43:12.525]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:12.525]                     envir = parent.frame()) 
[17:43:12.525]                   {
[17:43:12.525]                     if (is.function(workers)) 
[17:43:12.525]                       workers <- workers()
[17:43:12.525]                     workers <- structure(as.integer(workers), 
[17:43:12.525]                       class = class(workers))
[17:43:12.525]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:12.525]                       workers >= 1)
[17:43:12.525]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:12.525]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:12.525]                     }
[17:43:12.525]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:12.525]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:12.525]                       envir = envir)
[17:43:12.525]                     if (!future$lazy) 
[17:43:12.525]                       future <- run(future)
[17:43:12.525]                     invisible(future)
[17:43:12.525]                   }, b = function (..., envir = parent.frame()) 
[17:43:12.525]                   {
[17:43:12.525]                     future <- SequentialFuture(..., envir = envir)
[17:43:12.525]                     if (!future$lazy) 
[17:43:12.525]                       future <- run(future)
[17:43:12.525]                     invisible(future)
[17:43:12.525]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:12.525]                 }
[17:43:12.525]             }
[17:43:12.525]         }
[17:43:12.525]     })
[17:43:12.525]     if (TRUE) {
[17:43:12.525]         base::sink(type = "output", split = FALSE)
[17:43:12.525]         if (TRUE) {
[17:43:12.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:12.525]         }
[17:43:12.525]         else {
[17:43:12.525]             ...future.result["stdout"] <- base::list(NULL)
[17:43:12.525]         }
[17:43:12.525]         base::close(...future.stdout)
[17:43:12.525]         ...future.stdout <- NULL
[17:43:12.525]     }
[17:43:12.525]     ...future.result$conditions <- ...future.conditions
[17:43:12.525]     ...future.result$finished <- base::Sys.time()
[17:43:12.525]     ...future.result
[17:43:12.525] }
[17:43:12.528] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:43:12.529] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:43:12.529] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:43:12.529] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:43:12.530] MultisessionFuture started
[17:43:12.530] - Launch lazy future ... done
[17:43:12.530] run() for ‘MultisessionFuture’ ... done
[17:43:12.530] result() for ClusterFuture ...
[17:43:12.530] receiveMessageFromWorker() for ClusterFuture ...
[17:43:12.530] - Validating connection of MultisessionFuture
[17:43:12.583] - received message: FutureResult
[17:43:12.583] - Received FutureResult
[17:43:12.583] - Erased future from FutureRegistry
[17:43:12.583] result() for ClusterFuture ...
[17:43:12.583] - result already collected: FutureResult
[17:43:12.583] result() for ClusterFuture ... done
[17:43:12.583] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:12.584] result() for ClusterFuture ... done
[17:43:12.584] result() for ClusterFuture ...
[17:43:12.584] - result already collected: FutureResult
[17:43:12.584] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[17:43:12.584] plan(): Setting new future strategy stack:
[17:43:12.584] List of future strategies:
[17:43:12.584] 1. multisession:
[17:43:12.584]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:12.584]    - tweaked: FALSE
[17:43:12.584]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:12.584] 2. multicore:
[17:43:12.584]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:12.584]    - tweaked: FALSE
[17:43:12.584]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:12.585] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:43:12.585] multisession:
[17:43:12.585] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:12.585] - tweaked: FALSE
[17:43:12.585] - call: plan(list(a = strategy1, b = strategy2))
[17:43:12.590] getGlobalsAndPackages() ...
[17:43:12.591] Not searching for globals
[17:43:12.591] - globals: [0] <none>
[17:43:12.591] getGlobalsAndPackages() ... DONE
[17:43:12.591] [local output] makeClusterPSOCK() ...
[17:43:12.592] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:43:12.593] [local output] Base port: 11299
[17:43:12.593] [local output] Getting setup options for 2 cluster nodes ...
[17:43:12.593] [local output]  - Node 1 of 2 ...
[17:43:12.594] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:12.595] [local output] Rscript port: 11299

[17:43:12.595] [local output]  - Node 2 of 2 ...
[17:43:12.596] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:12.597] [local output] Rscript port: 11299

[17:43:12.597] [local output] Getting setup options for 2 cluster nodes ... done
[17:43:12.597] [local output]  - Parallel setup requested for some PSOCK nodes
[17:43:12.598] [local output] Setting up PSOCK nodes in parallel
[17:43:12.598] List of 36
[17:43:12.598]  $ worker          : chr "localhost"
[17:43:12.598]   ..- attr(*, "localhost")= logi TRUE
[17:43:12.598]  $ master          : chr "localhost"
[17:43:12.598]  $ port            : int 11299
[17:43:12.598]  $ connectTimeout  : num 120
[17:43:12.598]  $ timeout         : num 2592000
[17:43:12.598]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:43:12.598]  $ homogeneous     : logi TRUE
[17:43:12.598]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:43:12.598]  $ rscript_envs    : NULL
[17:43:12.598]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:12.598]  $ rscript_startup : NULL
[17:43:12.598]  $ rscript_sh      : chr "sh"
[17:43:12.598]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:12.598]  $ methods         : logi TRUE
[17:43:12.598]  $ socketOptions   : chr "no-delay"
[17:43:12.598]  $ useXDR          : logi FALSE
[17:43:12.598]  $ outfile         : chr "/dev/null"
[17:43:12.598]  $ renice          : int NA
[17:43:12.598]  $ rshcmd          : NULL
[17:43:12.598]  $ user            : chr(0) 
[17:43:12.598]  $ revtunnel       : logi FALSE
[17:43:12.598]  $ rshlogfile      : NULL
[17:43:12.598]  $ rshopts         : chr(0) 
[17:43:12.598]  $ rank            : int 1
[17:43:12.598]  $ manual          : logi FALSE
[17:43:12.598]  $ dryrun          : logi FALSE
[17:43:12.598]  $ quiet           : logi FALSE
[17:43:12.598]  $ setup_strategy  : chr "parallel"
[17:43:12.598]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:12.598]  $ pidfile         : chr "/tmp/RtmpzPUCYD/worker.rank=1.parallelly.parent=50370.c4c25a0c519b.pid"
[17:43:12.598]  $ rshcmd_label    : NULL
[17:43:12.598]  $ rsh_call        : NULL
[17:43:12.598]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:12.598]  $ localMachine    : logi TRUE
[17:43:12.598]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:43:12.598]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:43:12.598]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:43:12.598]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:43:12.598]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:43:12.598]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:43:12.598]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:43:12.598]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:43:12.598]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:43:12.598]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:43:12.598]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:43:12.598]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:43:12.598]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:43:12.598]  $ arguments       :List of 28
[17:43:12.598]   ..$ worker          : chr "localhost"
[17:43:12.598]   ..$ master          : NULL
[17:43:12.598]   ..$ port            : int 11299
[17:43:12.598]   ..$ connectTimeout  : num 120
[17:43:12.598]   ..$ timeout         : num 2592000
[17:43:12.598]   ..$ rscript         : NULL
[17:43:12.598]   ..$ homogeneous     : NULL
[17:43:12.598]   ..$ rscript_args    : NULL
[17:43:12.598]   ..$ rscript_envs    : NULL
[17:43:12.598]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:12.598]   ..$ rscript_startup : NULL
[17:43:12.598]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:43:12.598]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:12.598]   ..$ methods         : logi TRUE
[17:43:12.598]   ..$ socketOptions   : chr "no-delay"
[17:43:12.598]   ..$ useXDR          : logi FALSE
[17:43:12.598]   ..$ outfile         : chr "/dev/null"
[17:43:12.598]   ..$ renice          : int NA
[17:43:12.598]   ..$ rshcmd          : NULL
[17:43:12.598]   ..$ user            : NULL
[17:43:12.598]   ..$ revtunnel       : logi NA
[17:43:12.598]   ..$ rshlogfile      : NULL
[17:43:12.598]   ..$ rshopts         : NULL
[17:43:12.598]   ..$ rank            : int 1
[17:43:12.598]   ..$ manual          : logi FALSE
[17:43:12.598]   ..$ dryrun          : logi FALSE
[17:43:12.598]   ..$ quiet           : logi FALSE
[17:43:12.598]   ..$ setup_strategy  : chr "parallel"
[17:43:12.598]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:43:12.618] [local output] System call to launch all workers:
[17:43:12.618] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpzPUCYD/worker.rank=1.parallelly.parent=50370.c4c25a0c519b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11299 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:43:12.618] [local output] Starting PSOCK main server
[17:43:12.619] [local output] Workers launched
[17:43:12.619] [local output] Waiting for workers to connect back
[17:43:12.620]  - [local output] 0 workers out of 2 ready
[17:43:12.862]  - [local output] 0 workers out of 2 ready
[17:43:12.863]  - [local output] 1 workers out of 2 ready
[17:43:12.863]  - [local output] 2 workers out of 2 ready
[17:43:12.863] [local output] Launching of workers completed
[17:43:12.863] [local output] Collecting session information from workers
[17:43:12.864] [local output]  - Worker #1 of 2
[17:43:12.865] [local output]  - Worker #2 of 2
[17:43:12.865] [local output] makeClusterPSOCK() ... done
[17:43:12.876] Packages needed by the future expression (n = 0): <none>
[17:43:12.877] Packages needed by future strategies (n = 1): ‘future’
[17:43:12.877] {
[17:43:12.877]     {
[17:43:12.877]         {
[17:43:12.877]             ...future.startTime <- base::Sys.time()
[17:43:12.877]             {
[17:43:12.877]                 {
[17:43:12.877]                   {
[17:43:12.877]                     {
[17:43:12.877]                       {
[17:43:12.877]                         base::local({
[17:43:12.877]                           has_future <- base::requireNamespace("future", 
[17:43:12.877]                             quietly = TRUE)
[17:43:12.877]                           if (has_future) {
[17:43:12.877]                             ns <- base::getNamespace("future")
[17:43:12.877]                             version <- ns[[".package"]][["version"]]
[17:43:12.877]                             if (is.null(version)) 
[17:43:12.877]                               version <- utils::packageVersion("future")
[17:43:12.877]                           }
[17:43:12.877]                           else {
[17:43:12.877]                             version <- NULL
[17:43:12.877]                           }
[17:43:12.877]                           if (!has_future || version < "1.8.0") {
[17:43:12.877]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:12.877]                               "", base::R.version$version.string), 
[17:43:12.877]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:12.877]                                 base::R.version$platform, 8 * 
[17:43:12.877]                                   base::.Machine$sizeof.pointer), 
[17:43:12.877]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:12.877]                                 "release", "version")], collapse = " "), 
[17:43:12.877]                               hostname = base::Sys.info()[["nodename"]])
[17:43:12.877]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:12.877]                               info)
[17:43:12.877]                             info <- base::paste(info, collapse = "; ")
[17:43:12.877]                             if (!has_future) {
[17:43:12.877]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:12.877]                                 info)
[17:43:12.877]                             }
[17:43:12.877]                             else {
[17:43:12.877]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:12.877]                                 info, version)
[17:43:12.877]                             }
[17:43:12.877]                             base::stop(msg)
[17:43:12.877]                           }
[17:43:12.877]                         })
[17:43:12.877]                       }
[17:43:12.877]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:12.877]                       base::options(mc.cores = 1L)
[17:43:12.877]                     }
[17:43:12.877]                     base::local({
[17:43:12.877]                       for (pkg in "future") {
[17:43:12.877]                         base::loadNamespace(pkg)
[17:43:12.877]                         base::library(pkg, character.only = TRUE)
[17:43:12.877]                       }
[17:43:12.877]                     })
[17:43:12.877]                   }
[17:43:12.877]                   options(future.plan = NULL)
[17:43:12.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:12.877]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:12.877]                     envir = parent.frame()) 
[17:43:12.877]                   {
[17:43:12.877]                     default_workers <- missing(workers)
[17:43:12.877]                     if (is.function(workers)) 
[17:43:12.877]                       workers <- workers()
[17:43:12.877]                     workers <- structure(as.integer(workers), 
[17:43:12.877]                       class = class(workers))
[17:43:12.877]                     stop_if_not(is.finite(workers), workers >= 
[17:43:12.877]                       1L)
[17:43:12.877]                     if ((workers == 1L && !inherits(workers, 
[17:43:12.877]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:12.877]                       if (default_workers) 
[17:43:12.877]                         supportsMulticore(warn = TRUE)
[17:43:12.877]                       return(sequential(..., envir = envir))
[17:43:12.877]                     }
[17:43:12.877]                     oopts <- options(mc.cores = workers)
[17:43:12.877]                     on.exit(options(oopts))
[17:43:12.877]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:12.877]                       envir = envir)
[17:43:12.877]                     if (!future$lazy) 
[17:43:12.877]                       future <- run(future)
[17:43:12.877]                     invisible(future)
[17:43:12.877]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:12.877]                 }
[17:43:12.877]                 ...future.workdir <- getwd()
[17:43:12.877]             }
[17:43:12.877]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:12.877]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:12.877]         }
[17:43:12.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:12.877]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:12.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:12.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:12.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:12.877]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:12.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:12.877]             base::names(...future.oldOptions))
[17:43:12.877]     }
[17:43:12.877]     if (FALSE) {
[17:43:12.877]     }
[17:43:12.877]     else {
[17:43:12.877]         if (TRUE) {
[17:43:12.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:12.877]                 open = "w")
[17:43:12.877]         }
[17:43:12.877]         else {
[17:43:12.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:12.877]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:12.877]         }
[17:43:12.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:12.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:12.877]             base::sink(type = "output", split = FALSE)
[17:43:12.877]             base::close(...future.stdout)
[17:43:12.877]         }, add = TRUE)
[17:43:12.877]     }
[17:43:12.877]     ...future.frame <- base::sys.nframe()
[17:43:12.877]     ...future.conditions <- base::list()
[17:43:12.877]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:12.877]     if (FALSE) {
[17:43:12.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:12.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:12.877]     }
[17:43:12.877]     ...future.result <- base::tryCatch({
[17:43:12.877]         base::withCallingHandlers({
[17:43:12.877]             ...future.value <- base::withVisible(base::local({
[17:43:12.877]                 ...future.makeSendCondition <- local({
[17:43:12.877]                   sendCondition <- NULL
[17:43:12.877]                   function(frame = 1L) {
[17:43:12.877]                     if (is.function(sendCondition)) 
[17:43:12.877]                       return(sendCondition)
[17:43:12.877]                     ns <- getNamespace("parallel")
[17:43:12.877]                     if (exists("sendData", mode = "function", 
[17:43:12.877]                       envir = ns)) {
[17:43:12.877]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:12.877]                         envir = ns)
[17:43:12.877]                       envir <- sys.frame(frame)
[17:43:12.877]                       master <- NULL
[17:43:12.877]                       while (!identical(envir, .GlobalEnv) && 
[17:43:12.877]                         !identical(envir, emptyenv())) {
[17:43:12.877]                         if (exists("master", mode = "list", envir = envir, 
[17:43:12.877]                           inherits = FALSE)) {
[17:43:12.877]                           master <- get("master", mode = "list", 
[17:43:12.877]                             envir = envir, inherits = FALSE)
[17:43:12.877]                           if (inherits(master, c("SOCKnode", 
[17:43:12.877]                             "SOCK0node"))) {
[17:43:12.877]                             sendCondition <<- function(cond) {
[17:43:12.877]                               data <- list(type = "VALUE", value = cond, 
[17:43:12.877]                                 success = TRUE)
[17:43:12.877]                               parallel_sendData(master, data)
[17:43:12.877]                             }
[17:43:12.877]                             return(sendCondition)
[17:43:12.877]                           }
[17:43:12.877]                         }
[17:43:12.877]                         frame <- frame + 1L
[17:43:12.877]                         envir <- sys.frame(frame)
[17:43:12.877]                       }
[17:43:12.877]                     }
[17:43:12.877]                     sendCondition <<- function(cond) NULL
[17:43:12.877]                   }
[17:43:12.877]                 })
[17:43:12.877]                 withCallingHandlers({
[17:43:12.877]                   NA
[17:43:12.877]                 }, immediateCondition = function(cond) {
[17:43:12.877]                   sendCondition <- ...future.makeSendCondition()
[17:43:12.877]                   sendCondition(cond)
[17:43:12.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.877]                   {
[17:43:12.877]                     inherits <- base::inherits
[17:43:12.877]                     invokeRestart <- base::invokeRestart
[17:43:12.877]                     is.null <- base::is.null
[17:43:12.877]                     muffled <- FALSE
[17:43:12.877]                     if (inherits(cond, "message")) {
[17:43:12.877]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:12.877]                       if (muffled) 
[17:43:12.877]                         invokeRestart("muffleMessage")
[17:43:12.877]                     }
[17:43:12.877]                     else if (inherits(cond, "warning")) {
[17:43:12.877]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:12.877]                       if (muffled) 
[17:43:12.877]                         invokeRestart("muffleWarning")
[17:43:12.877]                     }
[17:43:12.877]                     else if (inherits(cond, "condition")) {
[17:43:12.877]                       if (!is.null(pattern)) {
[17:43:12.877]                         computeRestarts <- base::computeRestarts
[17:43:12.877]                         grepl <- base::grepl
[17:43:12.877]                         restarts <- computeRestarts(cond)
[17:43:12.877]                         for (restart in restarts) {
[17:43:12.877]                           name <- restart$name
[17:43:12.877]                           if (is.null(name)) 
[17:43:12.877]                             next
[17:43:12.877]                           if (!grepl(pattern, name)) 
[17:43:12.877]                             next
[17:43:12.877]                           invokeRestart(restart)
[17:43:12.877]                           muffled <- TRUE
[17:43:12.877]                           break
[17:43:12.877]                         }
[17:43:12.877]                       }
[17:43:12.877]                     }
[17:43:12.877]                     invisible(muffled)
[17:43:12.877]                   }
[17:43:12.877]                   muffleCondition(cond)
[17:43:12.877]                 })
[17:43:12.877]             }))
[17:43:12.877]             future::FutureResult(value = ...future.value$value, 
[17:43:12.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:12.877]                   ...future.rng), globalenv = if (FALSE) 
[17:43:12.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:12.877]                     ...future.globalenv.names))
[17:43:12.877]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:12.877]         }, condition = base::local({
[17:43:12.877]             c <- base::c
[17:43:12.877]             inherits <- base::inherits
[17:43:12.877]             invokeRestart <- base::invokeRestart
[17:43:12.877]             length <- base::length
[17:43:12.877]             list <- base::list
[17:43:12.877]             seq.int <- base::seq.int
[17:43:12.877]             signalCondition <- base::signalCondition
[17:43:12.877]             sys.calls <- base::sys.calls
[17:43:12.877]             `[[` <- base::`[[`
[17:43:12.877]             `+` <- base::`+`
[17:43:12.877]             `<<-` <- base::`<<-`
[17:43:12.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:12.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:12.877]                   3L)]
[17:43:12.877]             }
[17:43:12.877]             function(cond) {
[17:43:12.877]                 is_error <- inherits(cond, "error")
[17:43:12.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:12.877]                   NULL)
[17:43:12.877]                 if (is_error) {
[17:43:12.877]                   sessionInformation <- function() {
[17:43:12.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:12.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:12.877]                       search = base::search(), system = base::Sys.info())
[17:43:12.877]                   }
[17:43:12.877]                   ...future.conditions[[length(...future.conditions) + 
[17:43:12.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:12.877]                     cond$call), session = sessionInformation(), 
[17:43:12.877]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:12.877]                   signalCondition(cond)
[17:43:12.877]                 }
[17:43:12.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:12.877]                 "immediateCondition"))) {
[17:43:12.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:12.877]                   ...future.conditions[[length(...future.conditions) + 
[17:43:12.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:12.877]                   if (TRUE && !signal) {
[17:43:12.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.877]                     {
[17:43:12.877]                       inherits <- base::inherits
[17:43:12.877]                       invokeRestart <- base::invokeRestart
[17:43:12.877]                       is.null <- base::is.null
[17:43:12.877]                       muffled <- FALSE
[17:43:12.877]                       if (inherits(cond, "message")) {
[17:43:12.877]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:12.877]                         if (muffled) 
[17:43:12.877]                           invokeRestart("muffleMessage")
[17:43:12.877]                       }
[17:43:12.877]                       else if (inherits(cond, "warning")) {
[17:43:12.877]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:12.877]                         if (muffled) 
[17:43:12.877]                           invokeRestart("muffleWarning")
[17:43:12.877]                       }
[17:43:12.877]                       else if (inherits(cond, "condition")) {
[17:43:12.877]                         if (!is.null(pattern)) {
[17:43:12.877]                           computeRestarts <- base::computeRestarts
[17:43:12.877]                           grepl <- base::grepl
[17:43:12.877]                           restarts <- computeRestarts(cond)
[17:43:12.877]                           for (restart in restarts) {
[17:43:12.877]                             name <- restart$name
[17:43:12.877]                             if (is.null(name)) 
[17:43:12.877]                               next
[17:43:12.877]                             if (!grepl(pattern, name)) 
[17:43:12.877]                               next
[17:43:12.877]                             invokeRestart(restart)
[17:43:12.877]                             muffled <- TRUE
[17:43:12.877]                             break
[17:43:12.877]                           }
[17:43:12.877]                         }
[17:43:12.877]                       }
[17:43:12.877]                       invisible(muffled)
[17:43:12.877]                     }
[17:43:12.877]                     muffleCondition(cond, pattern = "^muffle")
[17:43:12.877]                   }
[17:43:12.877]                 }
[17:43:12.877]                 else {
[17:43:12.877]                   if (TRUE) {
[17:43:12.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:12.877]                     {
[17:43:12.877]                       inherits <- base::inherits
[17:43:12.877]                       invokeRestart <- base::invokeRestart
[17:43:12.877]                       is.null <- base::is.null
[17:43:12.877]                       muffled <- FALSE
[17:43:12.877]                       if (inherits(cond, "message")) {
[17:43:12.877]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:12.877]                         if (muffled) 
[17:43:12.877]                           invokeRestart("muffleMessage")
[17:43:12.877]                       }
[17:43:12.877]                       else if (inherits(cond, "warning")) {
[17:43:12.877]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:12.877]                         if (muffled) 
[17:43:12.877]                           invokeRestart("muffleWarning")
[17:43:12.877]                       }
[17:43:12.877]                       else if (inherits(cond, "condition")) {
[17:43:12.877]                         if (!is.null(pattern)) {
[17:43:12.877]                           computeRestarts <- base::computeRestarts
[17:43:12.877]                           grepl <- base::grepl
[17:43:12.877]                           restarts <- computeRestarts(cond)
[17:43:12.877]                           for (restart in restarts) {
[17:43:12.877]                             name <- restart$name
[17:43:12.877]                             if (is.null(name)) 
[17:43:12.877]                               next
[17:43:12.877]                             if (!grepl(pattern, name)) 
[17:43:12.877]                               next
[17:43:12.877]                             invokeRestart(restart)
[17:43:12.877]                             muffled <- TRUE
[17:43:12.877]                             break
[17:43:12.877]                           }
[17:43:12.877]                         }
[17:43:12.877]                       }
[17:43:12.877]                       invisible(muffled)
[17:43:12.877]                     }
[17:43:12.877]                     muffleCondition(cond, pattern = "^muffle")
[17:43:12.877]                   }
[17:43:12.877]                 }
[17:43:12.877]             }
[17:43:12.877]         }))
[17:43:12.877]     }, error = function(ex) {
[17:43:12.877]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:12.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:12.877]                 ...future.rng), started = ...future.startTime, 
[17:43:12.877]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:12.877]             version = "1.8"), class = "FutureResult")
[17:43:12.877]     }, finally = {
[17:43:12.877]         if (!identical(...future.workdir, getwd())) 
[17:43:12.877]             setwd(...future.workdir)
[17:43:12.877]         {
[17:43:12.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:12.877]                 ...future.oldOptions$nwarnings <- NULL
[17:43:12.877]             }
[17:43:12.877]             base::options(...future.oldOptions)
[17:43:12.877]             if (.Platform$OS.type == "windows") {
[17:43:12.877]                 old_names <- names(...future.oldEnvVars)
[17:43:12.877]                 envs <- base::Sys.getenv()
[17:43:12.877]                 names <- names(envs)
[17:43:12.877]                 common <- intersect(names, old_names)
[17:43:12.877]                 added <- setdiff(names, old_names)
[17:43:12.877]                 removed <- setdiff(old_names, names)
[17:43:12.877]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:12.877]                   envs[common]]
[17:43:12.877]                 NAMES <- toupper(changed)
[17:43:12.877]                 args <- list()
[17:43:12.877]                 for (kk in seq_along(NAMES)) {
[17:43:12.877]                   name <- changed[[kk]]
[17:43:12.877]                   NAME <- NAMES[[kk]]
[17:43:12.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.877]                     next
[17:43:12.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:12.877]                 }
[17:43:12.877]                 NAMES <- toupper(added)
[17:43:12.877]                 for (kk in seq_along(NAMES)) {
[17:43:12.877]                   name <- added[[kk]]
[17:43:12.877]                   NAME <- NAMES[[kk]]
[17:43:12.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.877]                     next
[17:43:12.877]                   args[[name]] <- ""
[17:43:12.877]                 }
[17:43:12.877]                 NAMES <- toupper(removed)
[17:43:12.877]                 for (kk in seq_along(NAMES)) {
[17:43:12.877]                   name <- removed[[kk]]
[17:43:12.877]                   NAME <- NAMES[[kk]]
[17:43:12.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:12.877]                     next
[17:43:12.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:12.877]                 }
[17:43:12.877]                 if (length(args) > 0) 
[17:43:12.877]                   base::do.call(base::Sys.setenv, args = args)
[17:43:12.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:12.877]             }
[17:43:12.877]             else {
[17:43:12.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:12.877]             }
[17:43:12.877]             {
[17:43:12.877]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:12.877]                   0L) {
[17:43:12.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:12.877]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:12.877]                   base::options(opts)
[17:43:12.877]                 }
[17:43:12.877]                 {
[17:43:12.877]                   {
[17:43:12.877]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:12.877]                     NULL
[17:43:12.877]                   }
[17:43:12.877]                   options(future.plan = NULL)
[17:43:12.877]                   if (is.na(NA_character_)) 
[17:43:12.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:12.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:12.877]                   future::plan(list(a = function (..., workers = availableCores(), 
[17:43:12.877]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:12.877]                     envir = parent.frame()) 
[17:43:12.877]                   {
[17:43:12.877]                     if (is.function(workers)) 
[17:43:12.877]                       workers <- workers()
[17:43:12.877]                     workers <- structure(as.integer(workers), 
[17:43:12.877]                       class = class(workers))
[17:43:12.877]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:12.877]                       workers >= 1)
[17:43:12.877]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:12.877]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:12.877]                     }
[17:43:12.877]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:12.877]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:12.877]                       envir = envir)
[17:43:12.877]                     if (!future$lazy) 
[17:43:12.877]                       future <- run(future)
[17:43:12.877]                     invisible(future)
[17:43:12.877]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:12.877]                     envir = parent.frame()) 
[17:43:12.877]                   {
[17:43:12.877]                     default_workers <- missing(workers)
[17:43:12.877]                     if (is.function(workers)) 
[17:43:12.877]                       workers <- workers()
[17:43:12.877]                     workers <- structure(as.integer(workers), 
[17:43:12.877]                       class = class(workers))
[17:43:12.877]                     stop_if_not(is.finite(workers), workers >= 
[17:43:12.877]                       1L)
[17:43:12.877]                     if ((workers == 1L && !inherits(workers, 
[17:43:12.877]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:12.877]                       if (default_workers) 
[17:43:12.877]                         supportsMulticore(warn = TRUE)
[17:43:12.877]                       return(sequential(..., envir = envir))
[17:43:12.877]                     }
[17:43:12.877]                     oopts <- options(mc.cores = workers)
[17:43:12.877]                     on.exit(options(oopts))
[17:43:12.877]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:12.877]                       envir = envir)
[17:43:12.877]                     if (!future$lazy) 
[17:43:12.877]                       future <- run(future)
[17:43:12.877]                     invisible(future)
[17:43:12.877]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:12.877]                 }
[17:43:12.877]             }
[17:43:12.877]         }
[17:43:12.877]     })
[17:43:12.877]     if (TRUE) {
[17:43:12.877]         base::sink(type = "output", split = FALSE)
[17:43:12.877]         if (TRUE) {
[17:43:12.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:12.877]         }
[17:43:12.877]         else {
[17:43:12.877]             ...future.result["stdout"] <- base::list(NULL)
[17:43:12.877]         }
[17:43:12.877]         base::close(...future.stdout)
[17:43:12.877]         ...future.stdout <- NULL
[17:43:12.877]     }
[17:43:12.877]     ...future.result$conditions <- ...future.conditions
[17:43:12.877]     ...future.result$finished <- base::Sys.time()
[17:43:12.877]     ...future.result
[17:43:12.877] }
[17:43:12.953] MultisessionFuture started
[17:43:12.953] result() for ClusterFuture ...
[17:43:12.953] receiveMessageFromWorker() for ClusterFuture ...
[17:43:12.953] - Validating connection of MultisessionFuture
[17:43:12.994] - received message: FutureResult
[17:43:12.994] - Received FutureResult
[17:43:12.994] - Erased future from FutureRegistry
[17:43:12.995] result() for ClusterFuture ...
[17:43:12.995] - result already collected: FutureResult
[17:43:12.995] result() for ClusterFuture ... done
[17:43:12.995] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:12.995] result() for ClusterFuture ... done
[17:43:12.995] result() for ClusterFuture ...
[17:43:12.995] - result already collected: FutureResult
[17:43:12.995] result() for ClusterFuture ... done
[17:43:12.995] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:43:12.999] plan(): nbrOfWorkers() = 2
[17:43:12.999] getGlobalsAndPackages() ...
[17:43:12.999] Searching for globals...
[17:43:13.017] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:43:13.018] Searching for globals ... DONE
[17:43:13.018] Resolving globals: FALSE
[17:43:13.019] The total size of the 2 globals is 90.70 KiB (92872 bytes)
[17:43:13.019] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.58 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:43:13.019] - globals: [2] ‘nested’, ‘strategy2’
[17:43:13.019] - packages: [1] ‘future’
[17:43:13.020] getGlobalsAndPackages() ... DONE
[17:43:13.020] run() for ‘Future’ ...
[17:43:13.020] - state: ‘created’
[17:43:13.020] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:13.036] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:13.036] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:13.036]   - Field: ‘node’
[17:43:13.036]   - Field: ‘label’
[17:43:13.036]   - Field: ‘local’
[17:43:13.037]   - Field: ‘owner’
[17:43:13.037]   - Field: ‘envir’
[17:43:13.037]   - Field: ‘workers’
[17:43:13.037]   - Field: ‘packages’
[17:43:13.037]   - Field: ‘gc’
[17:43:13.037]   - Field: ‘conditions’
[17:43:13.037]   - Field: ‘persistent’
[17:43:13.037]   - Field: ‘expr’
[17:43:13.037]   - Field: ‘uuid’
[17:43:13.037]   - Field: ‘seed’
[17:43:13.037]   - Field: ‘version’
[17:43:13.038]   - Field: ‘result’
[17:43:13.038]   - Field: ‘asynchronous’
[17:43:13.038]   - Field: ‘calls’
[17:43:13.038]   - Field: ‘globals’
[17:43:13.038]   - Field: ‘stdout’
[17:43:13.038]   - Field: ‘earlySignal’
[17:43:13.038]   - Field: ‘lazy’
[17:43:13.038]   - Field: ‘state’
[17:43:13.038] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:13.038] - Launch lazy future ...
[17:43:13.039] Packages needed by the future expression (n = 1): ‘future’
[17:43:13.039] Packages needed by future strategies (n = 1): ‘future’
[17:43:13.039] {
[17:43:13.039]     {
[17:43:13.039]         {
[17:43:13.039]             ...future.startTime <- base::Sys.time()
[17:43:13.039]             {
[17:43:13.039]                 {
[17:43:13.039]                   {
[17:43:13.039]                     {
[17:43:13.039]                       {
[17:43:13.039]                         base::local({
[17:43:13.039]                           has_future <- base::requireNamespace("future", 
[17:43:13.039]                             quietly = TRUE)
[17:43:13.039]                           if (has_future) {
[17:43:13.039]                             ns <- base::getNamespace("future")
[17:43:13.039]                             version <- ns[[".package"]][["version"]]
[17:43:13.039]                             if (is.null(version)) 
[17:43:13.039]                               version <- utils::packageVersion("future")
[17:43:13.039]                           }
[17:43:13.039]                           else {
[17:43:13.039]                             version <- NULL
[17:43:13.039]                           }
[17:43:13.039]                           if (!has_future || version < "1.8.0") {
[17:43:13.039]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:13.039]                               "", base::R.version$version.string), 
[17:43:13.039]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:13.039]                                 base::R.version$platform, 8 * 
[17:43:13.039]                                   base::.Machine$sizeof.pointer), 
[17:43:13.039]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:13.039]                                 "release", "version")], collapse = " "), 
[17:43:13.039]                               hostname = base::Sys.info()[["nodename"]])
[17:43:13.039]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:13.039]                               info)
[17:43:13.039]                             info <- base::paste(info, collapse = "; ")
[17:43:13.039]                             if (!has_future) {
[17:43:13.039]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:13.039]                                 info)
[17:43:13.039]                             }
[17:43:13.039]                             else {
[17:43:13.039]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:13.039]                                 info, version)
[17:43:13.039]                             }
[17:43:13.039]                             base::stop(msg)
[17:43:13.039]                           }
[17:43:13.039]                         })
[17:43:13.039]                       }
[17:43:13.039]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:13.039]                       base::options(mc.cores = 1L)
[17:43:13.039]                     }
[17:43:13.039]                     base::local({
[17:43:13.039]                       for (pkg in "future") {
[17:43:13.039]                         base::loadNamespace(pkg)
[17:43:13.039]                         base::library(pkg, character.only = TRUE)
[17:43:13.039]                       }
[17:43:13.039]                     })
[17:43:13.039]                   }
[17:43:13.039]                   options(future.plan = NULL)
[17:43:13.039]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:13.039]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:13.039]                     envir = parent.frame()) 
[17:43:13.039]                   {
[17:43:13.039]                     default_workers <- missing(workers)
[17:43:13.039]                     if (is.function(workers)) 
[17:43:13.039]                       workers <- workers()
[17:43:13.039]                     workers <- structure(as.integer(workers), 
[17:43:13.039]                       class = class(workers))
[17:43:13.039]                     stop_if_not(is.finite(workers), workers >= 
[17:43:13.039]                       1L)
[17:43:13.039]                     if ((workers == 1L && !inherits(workers, 
[17:43:13.039]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:13.039]                       if (default_workers) 
[17:43:13.039]                         supportsMulticore(warn = TRUE)
[17:43:13.039]                       return(sequential(..., envir = envir))
[17:43:13.039]                     }
[17:43:13.039]                     oopts <- options(mc.cores = workers)
[17:43:13.039]                     on.exit(options(oopts))
[17:43:13.039]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:13.039]                       envir = envir)
[17:43:13.039]                     if (!future$lazy) 
[17:43:13.039]                       future <- run(future)
[17:43:13.039]                     invisible(future)
[17:43:13.039]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:13.039]                 }
[17:43:13.039]                 ...future.workdir <- getwd()
[17:43:13.039]             }
[17:43:13.039]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:13.039]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:13.039]         }
[17:43:13.039]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:13.039]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:13.039]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:13.039]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:13.039]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:13.039]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:13.039]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:13.039]             base::names(...future.oldOptions))
[17:43:13.039]     }
[17:43:13.039]     if (FALSE) {
[17:43:13.039]     }
[17:43:13.039]     else {
[17:43:13.039]         if (TRUE) {
[17:43:13.039]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:13.039]                 open = "w")
[17:43:13.039]         }
[17:43:13.039]         else {
[17:43:13.039]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:13.039]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:13.039]         }
[17:43:13.039]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:13.039]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:13.039]             base::sink(type = "output", split = FALSE)
[17:43:13.039]             base::close(...future.stdout)
[17:43:13.039]         }, add = TRUE)
[17:43:13.039]     }
[17:43:13.039]     ...future.frame <- base::sys.nframe()
[17:43:13.039]     ...future.conditions <- base::list()
[17:43:13.039]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:13.039]     if (FALSE) {
[17:43:13.039]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:13.039]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:13.039]     }
[17:43:13.039]     ...future.result <- base::tryCatch({
[17:43:13.039]         base::withCallingHandlers({
[17:43:13.039]             ...future.value <- base::withVisible(base::local({
[17:43:13.039]                 ...future.makeSendCondition <- local({
[17:43:13.039]                   sendCondition <- NULL
[17:43:13.039]                   function(frame = 1L) {
[17:43:13.039]                     if (is.function(sendCondition)) 
[17:43:13.039]                       return(sendCondition)
[17:43:13.039]                     ns <- getNamespace("parallel")
[17:43:13.039]                     if (exists("sendData", mode = "function", 
[17:43:13.039]                       envir = ns)) {
[17:43:13.039]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:13.039]                         envir = ns)
[17:43:13.039]                       envir <- sys.frame(frame)
[17:43:13.039]                       master <- NULL
[17:43:13.039]                       while (!identical(envir, .GlobalEnv) && 
[17:43:13.039]                         !identical(envir, emptyenv())) {
[17:43:13.039]                         if (exists("master", mode = "list", envir = envir, 
[17:43:13.039]                           inherits = FALSE)) {
[17:43:13.039]                           master <- get("master", mode = "list", 
[17:43:13.039]                             envir = envir, inherits = FALSE)
[17:43:13.039]                           if (inherits(master, c("SOCKnode", 
[17:43:13.039]                             "SOCK0node"))) {
[17:43:13.039]                             sendCondition <<- function(cond) {
[17:43:13.039]                               data <- list(type = "VALUE", value = cond, 
[17:43:13.039]                                 success = TRUE)
[17:43:13.039]                               parallel_sendData(master, data)
[17:43:13.039]                             }
[17:43:13.039]                             return(sendCondition)
[17:43:13.039]                           }
[17:43:13.039]                         }
[17:43:13.039]                         frame <- frame + 1L
[17:43:13.039]                         envir <- sys.frame(frame)
[17:43:13.039]                       }
[17:43:13.039]                     }
[17:43:13.039]                     sendCondition <<- function(cond) NULL
[17:43:13.039]                   }
[17:43:13.039]                 })
[17:43:13.039]                 withCallingHandlers({
[17:43:13.039]                   {
[17:43:13.039]                     a <- 1L
[17:43:13.039]                     plan_a <- unclass(future::plan("list"))
[17:43:13.039]                     nested_a <- nested[-1]
[17:43:13.039]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:43:13.039]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:43:13.039]                       strategy2))
[17:43:13.039]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:43:13.039]                       "init") <- NULL
[17:43:13.039]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:43:13.039]                       "init") <- NULL
[17:43:13.039]                     stopifnot(all.equal(plan_a, nested_a))
[17:43:13.039]                     y %<-% {
[17:43:13.039]                       b <- 2L
[17:43:13.039]                       plan_b <- future::plan("list")
[17:43:13.039]                       nested_b <- nested_a[-1]
[17:43:13.039]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:13.039]                         1L, inherits(plan_b[[1]], "future"), 
[17:43:13.039]                         inherits(future::plan("next"), "sequential"))
[17:43:13.039]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:13.039]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:13.039]                     }
[17:43:13.039]                     y
[17:43:13.039]                   }
[17:43:13.039]                 }, immediateCondition = function(cond) {
[17:43:13.039]                   sendCondition <- ...future.makeSendCondition()
[17:43:13.039]                   sendCondition(cond)
[17:43:13.039]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.039]                   {
[17:43:13.039]                     inherits <- base::inherits
[17:43:13.039]                     invokeRestart <- base::invokeRestart
[17:43:13.039]                     is.null <- base::is.null
[17:43:13.039]                     muffled <- FALSE
[17:43:13.039]                     if (inherits(cond, "message")) {
[17:43:13.039]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:13.039]                       if (muffled) 
[17:43:13.039]                         invokeRestart("muffleMessage")
[17:43:13.039]                     }
[17:43:13.039]                     else if (inherits(cond, "warning")) {
[17:43:13.039]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:13.039]                       if (muffled) 
[17:43:13.039]                         invokeRestart("muffleWarning")
[17:43:13.039]                     }
[17:43:13.039]                     else if (inherits(cond, "condition")) {
[17:43:13.039]                       if (!is.null(pattern)) {
[17:43:13.039]                         computeRestarts <- base::computeRestarts
[17:43:13.039]                         grepl <- base::grepl
[17:43:13.039]                         restarts <- computeRestarts(cond)
[17:43:13.039]                         for (restart in restarts) {
[17:43:13.039]                           name <- restart$name
[17:43:13.039]                           if (is.null(name)) 
[17:43:13.039]                             next
[17:43:13.039]                           if (!grepl(pattern, name)) 
[17:43:13.039]                             next
[17:43:13.039]                           invokeRestart(restart)
[17:43:13.039]                           muffled <- TRUE
[17:43:13.039]                           break
[17:43:13.039]                         }
[17:43:13.039]                       }
[17:43:13.039]                     }
[17:43:13.039]                     invisible(muffled)
[17:43:13.039]                   }
[17:43:13.039]                   muffleCondition(cond)
[17:43:13.039]                 })
[17:43:13.039]             }))
[17:43:13.039]             future::FutureResult(value = ...future.value$value, 
[17:43:13.039]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:13.039]                   ...future.rng), globalenv = if (FALSE) 
[17:43:13.039]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:13.039]                     ...future.globalenv.names))
[17:43:13.039]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:13.039]         }, condition = base::local({
[17:43:13.039]             c <- base::c
[17:43:13.039]             inherits <- base::inherits
[17:43:13.039]             invokeRestart <- base::invokeRestart
[17:43:13.039]             length <- base::length
[17:43:13.039]             list <- base::list
[17:43:13.039]             seq.int <- base::seq.int
[17:43:13.039]             signalCondition <- base::signalCondition
[17:43:13.039]             sys.calls <- base::sys.calls
[17:43:13.039]             `[[` <- base::`[[`
[17:43:13.039]             `+` <- base::`+`
[17:43:13.039]             `<<-` <- base::`<<-`
[17:43:13.039]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:13.039]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:13.039]                   3L)]
[17:43:13.039]             }
[17:43:13.039]             function(cond) {
[17:43:13.039]                 is_error <- inherits(cond, "error")
[17:43:13.039]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:13.039]                   NULL)
[17:43:13.039]                 if (is_error) {
[17:43:13.039]                   sessionInformation <- function() {
[17:43:13.039]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:13.039]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:13.039]                       search = base::search(), system = base::Sys.info())
[17:43:13.039]                   }
[17:43:13.039]                   ...future.conditions[[length(...future.conditions) + 
[17:43:13.039]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:13.039]                     cond$call), session = sessionInformation(), 
[17:43:13.039]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:13.039]                   signalCondition(cond)
[17:43:13.039]                 }
[17:43:13.039]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:13.039]                 "immediateCondition"))) {
[17:43:13.039]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:13.039]                   ...future.conditions[[length(...future.conditions) + 
[17:43:13.039]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:13.039]                   if (TRUE && !signal) {
[17:43:13.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.039]                     {
[17:43:13.039]                       inherits <- base::inherits
[17:43:13.039]                       invokeRestart <- base::invokeRestart
[17:43:13.039]                       is.null <- base::is.null
[17:43:13.039]                       muffled <- FALSE
[17:43:13.039]                       if (inherits(cond, "message")) {
[17:43:13.039]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:13.039]                         if (muffled) 
[17:43:13.039]                           invokeRestart("muffleMessage")
[17:43:13.039]                       }
[17:43:13.039]                       else if (inherits(cond, "warning")) {
[17:43:13.039]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:13.039]                         if (muffled) 
[17:43:13.039]                           invokeRestart("muffleWarning")
[17:43:13.039]                       }
[17:43:13.039]                       else if (inherits(cond, "condition")) {
[17:43:13.039]                         if (!is.null(pattern)) {
[17:43:13.039]                           computeRestarts <- base::computeRestarts
[17:43:13.039]                           grepl <- base::grepl
[17:43:13.039]                           restarts <- computeRestarts(cond)
[17:43:13.039]                           for (restart in restarts) {
[17:43:13.039]                             name <- restart$name
[17:43:13.039]                             if (is.null(name)) 
[17:43:13.039]                               next
[17:43:13.039]                             if (!grepl(pattern, name)) 
[17:43:13.039]                               next
[17:43:13.039]                             invokeRestart(restart)
[17:43:13.039]                             muffled <- TRUE
[17:43:13.039]                             break
[17:43:13.039]                           }
[17:43:13.039]                         }
[17:43:13.039]                       }
[17:43:13.039]                       invisible(muffled)
[17:43:13.039]                     }
[17:43:13.039]                     muffleCondition(cond, pattern = "^muffle")
[17:43:13.039]                   }
[17:43:13.039]                 }
[17:43:13.039]                 else {
[17:43:13.039]                   if (TRUE) {
[17:43:13.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.039]                     {
[17:43:13.039]                       inherits <- base::inherits
[17:43:13.039]                       invokeRestart <- base::invokeRestart
[17:43:13.039]                       is.null <- base::is.null
[17:43:13.039]                       muffled <- FALSE
[17:43:13.039]                       if (inherits(cond, "message")) {
[17:43:13.039]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:13.039]                         if (muffled) 
[17:43:13.039]                           invokeRestart("muffleMessage")
[17:43:13.039]                       }
[17:43:13.039]                       else if (inherits(cond, "warning")) {
[17:43:13.039]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:13.039]                         if (muffled) 
[17:43:13.039]                           invokeRestart("muffleWarning")
[17:43:13.039]                       }
[17:43:13.039]                       else if (inherits(cond, "condition")) {
[17:43:13.039]                         if (!is.null(pattern)) {
[17:43:13.039]                           computeRestarts <- base::computeRestarts
[17:43:13.039]                           grepl <- base::grepl
[17:43:13.039]                           restarts <- computeRestarts(cond)
[17:43:13.039]                           for (restart in restarts) {
[17:43:13.039]                             name <- restart$name
[17:43:13.039]                             if (is.null(name)) 
[17:43:13.039]                               next
[17:43:13.039]                             if (!grepl(pattern, name)) 
[17:43:13.039]                               next
[17:43:13.039]                             invokeRestart(restart)
[17:43:13.039]                             muffled <- TRUE
[17:43:13.039]                             break
[17:43:13.039]                           }
[17:43:13.039]                         }
[17:43:13.039]                       }
[17:43:13.039]                       invisible(muffled)
[17:43:13.039]                     }
[17:43:13.039]                     muffleCondition(cond, pattern = "^muffle")
[17:43:13.039]                   }
[17:43:13.039]                 }
[17:43:13.039]             }
[17:43:13.039]         }))
[17:43:13.039]     }, error = function(ex) {
[17:43:13.039]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:13.039]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:13.039]                 ...future.rng), started = ...future.startTime, 
[17:43:13.039]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:13.039]             version = "1.8"), class = "FutureResult")
[17:43:13.039]     }, finally = {
[17:43:13.039]         if (!identical(...future.workdir, getwd())) 
[17:43:13.039]             setwd(...future.workdir)
[17:43:13.039]         {
[17:43:13.039]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:13.039]                 ...future.oldOptions$nwarnings <- NULL
[17:43:13.039]             }
[17:43:13.039]             base::options(...future.oldOptions)
[17:43:13.039]             if (.Platform$OS.type == "windows") {
[17:43:13.039]                 old_names <- names(...future.oldEnvVars)
[17:43:13.039]                 envs <- base::Sys.getenv()
[17:43:13.039]                 names <- names(envs)
[17:43:13.039]                 common <- intersect(names, old_names)
[17:43:13.039]                 added <- setdiff(names, old_names)
[17:43:13.039]                 removed <- setdiff(old_names, names)
[17:43:13.039]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:13.039]                   envs[common]]
[17:43:13.039]                 NAMES <- toupper(changed)
[17:43:13.039]                 args <- list()
[17:43:13.039]                 for (kk in seq_along(NAMES)) {
[17:43:13.039]                   name <- changed[[kk]]
[17:43:13.039]                   NAME <- NAMES[[kk]]
[17:43:13.039]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.039]                     next
[17:43:13.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:13.039]                 }
[17:43:13.039]                 NAMES <- toupper(added)
[17:43:13.039]                 for (kk in seq_along(NAMES)) {
[17:43:13.039]                   name <- added[[kk]]
[17:43:13.039]                   NAME <- NAMES[[kk]]
[17:43:13.039]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.039]                     next
[17:43:13.039]                   args[[name]] <- ""
[17:43:13.039]                 }
[17:43:13.039]                 NAMES <- toupper(removed)
[17:43:13.039]                 for (kk in seq_along(NAMES)) {
[17:43:13.039]                   name <- removed[[kk]]
[17:43:13.039]                   NAME <- NAMES[[kk]]
[17:43:13.039]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.039]                     next
[17:43:13.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:13.039]                 }
[17:43:13.039]                 if (length(args) > 0) 
[17:43:13.039]                   base::do.call(base::Sys.setenv, args = args)
[17:43:13.039]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:13.039]             }
[17:43:13.039]             else {
[17:43:13.039]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:13.039]             }
[17:43:13.039]             {
[17:43:13.039]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:13.039]                   0L) {
[17:43:13.039]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:13.039]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:13.039]                   base::options(opts)
[17:43:13.039]                 }
[17:43:13.039]                 {
[17:43:13.039]                   {
[17:43:13.039]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:13.039]                     NULL
[17:43:13.039]                   }
[17:43:13.039]                   options(future.plan = NULL)
[17:43:13.039]                   if (is.na(NA_character_)) 
[17:43:13.039]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:13.039]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:13.039]                   future::plan(list(a = function (..., workers = availableCores(), 
[17:43:13.039]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:13.039]                     envir = parent.frame()) 
[17:43:13.039]                   {
[17:43:13.039]                     if (is.function(workers)) 
[17:43:13.039]                       workers <- workers()
[17:43:13.039]                     workers <- structure(as.integer(workers), 
[17:43:13.039]                       class = class(workers))
[17:43:13.039]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:13.039]                       workers >= 1)
[17:43:13.039]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:13.039]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:13.039]                     }
[17:43:13.039]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:13.039]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:13.039]                       envir = envir)
[17:43:13.039]                     if (!future$lazy) 
[17:43:13.039]                       future <- run(future)
[17:43:13.039]                     invisible(future)
[17:43:13.039]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:13.039]                     envir = parent.frame()) 
[17:43:13.039]                   {
[17:43:13.039]                     default_workers <- missing(workers)
[17:43:13.039]                     if (is.function(workers)) 
[17:43:13.039]                       workers <- workers()
[17:43:13.039]                     workers <- structure(as.integer(workers), 
[17:43:13.039]                       class = class(workers))
[17:43:13.039]                     stop_if_not(is.finite(workers), workers >= 
[17:43:13.039]                       1L)
[17:43:13.039]                     if ((workers == 1L && !inherits(workers, 
[17:43:13.039]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:13.039]                       if (default_workers) 
[17:43:13.039]                         supportsMulticore(warn = TRUE)
[17:43:13.039]                       return(sequential(..., envir = envir))
[17:43:13.039]                     }
[17:43:13.039]                     oopts <- options(mc.cores = workers)
[17:43:13.039]                     on.exit(options(oopts))
[17:43:13.039]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:13.039]                       envir = envir)
[17:43:13.039]                     if (!future$lazy) 
[17:43:13.039]                       future <- run(future)
[17:43:13.039]                     invisible(future)
[17:43:13.039]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:13.039]                 }
[17:43:13.039]             }
[17:43:13.039]         }
[17:43:13.039]     })
[17:43:13.039]     if (TRUE) {
[17:43:13.039]         base::sink(type = "output", split = FALSE)
[17:43:13.039]         if (TRUE) {
[17:43:13.039]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:13.039]         }
[17:43:13.039]         else {
[17:43:13.039]             ...future.result["stdout"] <- base::list(NULL)
[17:43:13.039]         }
[17:43:13.039]         base::close(...future.stdout)
[17:43:13.039]         ...future.stdout <- NULL
[17:43:13.039]     }
[17:43:13.039]     ...future.result$conditions <- ...future.conditions
[17:43:13.039]     ...future.result$finished <- base::Sys.time()
[17:43:13.039]     ...future.result
[17:43:13.039] }
[17:43:13.043] Exporting 2 global objects (90.70 KiB) to cluster node #1 ...
[17:43:13.043] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ...
[17:43:13.087] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ... DONE
[17:43:13.087] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[17:43:13.088] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[17:43:13.088] Exporting 2 global objects (90.70 KiB) to cluster node #1 ... DONE
[17:43:13.089] MultisessionFuture started
[17:43:13.089] - Launch lazy future ... done
[17:43:13.089] run() for ‘MultisessionFuture’ ... done
[17:43:13.089] result() for ClusterFuture ...
[17:43:13.089] receiveMessageFromWorker() for ClusterFuture ...
[17:43:13.089] - Validating connection of MultisessionFuture
[17:43:13.168] - received message: FutureResult
[17:43:13.169] - Received FutureResult
[17:43:13.169] - Erased future from FutureRegistry
[17:43:13.169] result() for ClusterFuture ...
[17:43:13.169] - result already collected: FutureResult
[17:43:13.169] result() for ClusterFuture ... done
[17:43:13.169] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:13.169] result() for ClusterFuture ... done
[17:43:13.169] result() for ClusterFuture ...
[17:43:13.170] - result already collected: FutureResult
[17:43:13.170] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:13.175] getGlobalsAndPackages() ...
[17:43:13.175] Searching for globals...
[17:43:13.176] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:13.177] Searching for globals ... DONE
[17:43:13.177] Resolving globals: FALSE
[17:43:13.177] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:13.178] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:13.178] - globals: [1] ‘data’
[17:43:13.178] - packages: [1] ‘future’
[17:43:13.178] getGlobalsAndPackages() ... DONE
[17:43:13.178] run() for ‘Future’ ...
[17:43:13.178] - state: ‘created’
[17:43:13.179] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:13.193] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:13.193] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:13.193]   - Field: ‘node’
[17:43:13.193]   - Field: ‘label’
[17:43:13.194]   - Field: ‘local’
[17:43:13.194]   - Field: ‘owner’
[17:43:13.194]   - Field: ‘envir’
[17:43:13.194]   - Field: ‘workers’
[17:43:13.194]   - Field: ‘packages’
[17:43:13.194]   - Field: ‘gc’
[17:43:13.194]   - Field: ‘conditions’
[17:43:13.194]   - Field: ‘persistent’
[17:43:13.194]   - Field: ‘expr’
[17:43:13.194]   - Field: ‘uuid’
[17:43:13.194]   - Field: ‘seed’
[17:43:13.195]   - Field: ‘version’
[17:43:13.195]   - Field: ‘result’
[17:43:13.195]   - Field: ‘asynchronous’
[17:43:13.195]   - Field: ‘calls’
[17:43:13.195]   - Field: ‘globals’
[17:43:13.195]   - Field: ‘stdout’
[17:43:13.195]   - Field: ‘earlySignal’
[17:43:13.195]   - Field: ‘lazy’
[17:43:13.195]   - Field: ‘state’
[17:43:13.195] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:13.196] - Launch lazy future ...
[17:43:13.196] Packages needed by the future expression (n = 1): ‘future’
[17:43:13.196] Packages needed by future strategies (n = 1): ‘future’
[17:43:13.197] {
[17:43:13.197]     {
[17:43:13.197]         {
[17:43:13.197]             ...future.startTime <- base::Sys.time()
[17:43:13.197]             {
[17:43:13.197]                 {
[17:43:13.197]                   {
[17:43:13.197]                     {
[17:43:13.197]                       {
[17:43:13.197]                         base::local({
[17:43:13.197]                           has_future <- base::requireNamespace("future", 
[17:43:13.197]                             quietly = TRUE)
[17:43:13.197]                           if (has_future) {
[17:43:13.197]                             ns <- base::getNamespace("future")
[17:43:13.197]                             version <- ns[[".package"]][["version"]]
[17:43:13.197]                             if (is.null(version)) 
[17:43:13.197]                               version <- utils::packageVersion("future")
[17:43:13.197]                           }
[17:43:13.197]                           else {
[17:43:13.197]                             version <- NULL
[17:43:13.197]                           }
[17:43:13.197]                           if (!has_future || version < "1.8.0") {
[17:43:13.197]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:13.197]                               "", base::R.version$version.string), 
[17:43:13.197]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:13.197]                                 base::R.version$platform, 8 * 
[17:43:13.197]                                   base::.Machine$sizeof.pointer), 
[17:43:13.197]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:13.197]                                 "release", "version")], collapse = " "), 
[17:43:13.197]                               hostname = base::Sys.info()[["nodename"]])
[17:43:13.197]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:13.197]                               info)
[17:43:13.197]                             info <- base::paste(info, collapse = "; ")
[17:43:13.197]                             if (!has_future) {
[17:43:13.197]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:13.197]                                 info)
[17:43:13.197]                             }
[17:43:13.197]                             else {
[17:43:13.197]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:13.197]                                 info, version)
[17:43:13.197]                             }
[17:43:13.197]                             base::stop(msg)
[17:43:13.197]                           }
[17:43:13.197]                         })
[17:43:13.197]                       }
[17:43:13.197]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:13.197]                       base::options(mc.cores = 1L)
[17:43:13.197]                     }
[17:43:13.197]                     base::local({
[17:43:13.197]                       for (pkg in "future") {
[17:43:13.197]                         base::loadNamespace(pkg)
[17:43:13.197]                         base::library(pkg, character.only = TRUE)
[17:43:13.197]                       }
[17:43:13.197]                     })
[17:43:13.197]                   }
[17:43:13.197]                   options(future.plan = NULL)
[17:43:13.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:13.197]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:13.197]                     envir = parent.frame()) 
[17:43:13.197]                   {
[17:43:13.197]                     default_workers <- missing(workers)
[17:43:13.197]                     if (is.function(workers)) 
[17:43:13.197]                       workers <- workers()
[17:43:13.197]                     workers <- structure(as.integer(workers), 
[17:43:13.197]                       class = class(workers))
[17:43:13.197]                     stop_if_not(is.finite(workers), workers >= 
[17:43:13.197]                       1L)
[17:43:13.197]                     if ((workers == 1L && !inherits(workers, 
[17:43:13.197]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:13.197]                       if (default_workers) 
[17:43:13.197]                         supportsMulticore(warn = TRUE)
[17:43:13.197]                       return(sequential(..., envir = envir))
[17:43:13.197]                     }
[17:43:13.197]                     oopts <- options(mc.cores = workers)
[17:43:13.197]                     on.exit(options(oopts))
[17:43:13.197]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:13.197]                       envir = envir)
[17:43:13.197]                     if (!future$lazy) 
[17:43:13.197]                       future <- run(future)
[17:43:13.197]                     invisible(future)
[17:43:13.197]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:13.197]                 }
[17:43:13.197]                 ...future.workdir <- getwd()
[17:43:13.197]             }
[17:43:13.197]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:13.197]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:13.197]         }
[17:43:13.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:13.197]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:13.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:13.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:13.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:13.197]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:13.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:13.197]             base::names(...future.oldOptions))
[17:43:13.197]     }
[17:43:13.197]     if (FALSE) {
[17:43:13.197]     }
[17:43:13.197]     else {
[17:43:13.197]         if (TRUE) {
[17:43:13.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:13.197]                 open = "w")
[17:43:13.197]         }
[17:43:13.197]         else {
[17:43:13.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:13.197]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:13.197]         }
[17:43:13.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:13.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:13.197]             base::sink(type = "output", split = FALSE)
[17:43:13.197]             base::close(...future.stdout)
[17:43:13.197]         }, add = TRUE)
[17:43:13.197]     }
[17:43:13.197]     ...future.frame <- base::sys.nframe()
[17:43:13.197]     ...future.conditions <- base::list()
[17:43:13.197]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:13.197]     if (FALSE) {
[17:43:13.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:13.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:13.197]     }
[17:43:13.197]     ...future.result <- base::tryCatch({
[17:43:13.197]         base::withCallingHandlers({
[17:43:13.197]             ...future.value <- base::withVisible(base::local({
[17:43:13.197]                 ...future.makeSendCondition <- local({
[17:43:13.197]                   sendCondition <- NULL
[17:43:13.197]                   function(frame = 1L) {
[17:43:13.197]                     if (is.function(sendCondition)) 
[17:43:13.197]                       return(sendCondition)
[17:43:13.197]                     ns <- getNamespace("parallel")
[17:43:13.197]                     if (exists("sendData", mode = "function", 
[17:43:13.197]                       envir = ns)) {
[17:43:13.197]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:13.197]                         envir = ns)
[17:43:13.197]                       envir <- sys.frame(frame)
[17:43:13.197]                       master <- NULL
[17:43:13.197]                       while (!identical(envir, .GlobalEnv) && 
[17:43:13.197]                         !identical(envir, emptyenv())) {
[17:43:13.197]                         if (exists("master", mode = "list", envir = envir, 
[17:43:13.197]                           inherits = FALSE)) {
[17:43:13.197]                           master <- get("master", mode = "list", 
[17:43:13.197]                             envir = envir, inherits = FALSE)
[17:43:13.197]                           if (inherits(master, c("SOCKnode", 
[17:43:13.197]                             "SOCK0node"))) {
[17:43:13.197]                             sendCondition <<- function(cond) {
[17:43:13.197]                               data <- list(type = "VALUE", value = cond, 
[17:43:13.197]                                 success = TRUE)
[17:43:13.197]                               parallel_sendData(master, data)
[17:43:13.197]                             }
[17:43:13.197]                             return(sendCondition)
[17:43:13.197]                           }
[17:43:13.197]                         }
[17:43:13.197]                         frame <- frame + 1L
[17:43:13.197]                         envir <- sys.frame(frame)
[17:43:13.197]                       }
[17:43:13.197]                     }
[17:43:13.197]                     sendCondition <<- function(cond) NULL
[17:43:13.197]                   }
[17:43:13.197]                 })
[17:43:13.197]                 withCallingHandlers({
[17:43:13.197]                   {
[17:43:13.197]                     value(future(subset(data, a == 2)))
[17:43:13.197]                   }
[17:43:13.197]                 }, immediateCondition = function(cond) {
[17:43:13.197]                   sendCondition <- ...future.makeSendCondition()
[17:43:13.197]                   sendCondition(cond)
[17:43:13.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.197]                   {
[17:43:13.197]                     inherits <- base::inherits
[17:43:13.197]                     invokeRestart <- base::invokeRestart
[17:43:13.197]                     is.null <- base::is.null
[17:43:13.197]                     muffled <- FALSE
[17:43:13.197]                     if (inherits(cond, "message")) {
[17:43:13.197]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:13.197]                       if (muffled) 
[17:43:13.197]                         invokeRestart("muffleMessage")
[17:43:13.197]                     }
[17:43:13.197]                     else if (inherits(cond, "warning")) {
[17:43:13.197]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:13.197]                       if (muffled) 
[17:43:13.197]                         invokeRestart("muffleWarning")
[17:43:13.197]                     }
[17:43:13.197]                     else if (inherits(cond, "condition")) {
[17:43:13.197]                       if (!is.null(pattern)) {
[17:43:13.197]                         computeRestarts <- base::computeRestarts
[17:43:13.197]                         grepl <- base::grepl
[17:43:13.197]                         restarts <- computeRestarts(cond)
[17:43:13.197]                         for (restart in restarts) {
[17:43:13.197]                           name <- restart$name
[17:43:13.197]                           if (is.null(name)) 
[17:43:13.197]                             next
[17:43:13.197]                           if (!grepl(pattern, name)) 
[17:43:13.197]                             next
[17:43:13.197]                           invokeRestart(restart)
[17:43:13.197]                           muffled <- TRUE
[17:43:13.197]                           break
[17:43:13.197]                         }
[17:43:13.197]                       }
[17:43:13.197]                     }
[17:43:13.197]                     invisible(muffled)
[17:43:13.197]                   }
[17:43:13.197]                   muffleCondition(cond)
[17:43:13.197]                 })
[17:43:13.197]             }))
[17:43:13.197]             future::FutureResult(value = ...future.value$value, 
[17:43:13.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:13.197]                   ...future.rng), globalenv = if (FALSE) 
[17:43:13.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:13.197]                     ...future.globalenv.names))
[17:43:13.197]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:13.197]         }, condition = base::local({
[17:43:13.197]             c <- base::c
[17:43:13.197]             inherits <- base::inherits
[17:43:13.197]             invokeRestart <- base::invokeRestart
[17:43:13.197]             length <- base::length
[17:43:13.197]             list <- base::list
[17:43:13.197]             seq.int <- base::seq.int
[17:43:13.197]             signalCondition <- base::signalCondition
[17:43:13.197]             sys.calls <- base::sys.calls
[17:43:13.197]             `[[` <- base::`[[`
[17:43:13.197]             `+` <- base::`+`
[17:43:13.197]             `<<-` <- base::`<<-`
[17:43:13.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:13.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:13.197]                   3L)]
[17:43:13.197]             }
[17:43:13.197]             function(cond) {
[17:43:13.197]                 is_error <- inherits(cond, "error")
[17:43:13.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:13.197]                   NULL)
[17:43:13.197]                 if (is_error) {
[17:43:13.197]                   sessionInformation <- function() {
[17:43:13.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:13.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:13.197]                       search = base::search(), system = base::Sys.info())
[17:43:13.197]                   }
[17:43:13.197]                   ...future.conditions[[length(...future.conditions) + 
[17:43:13.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:13.197]                     cond$call), session = sessionInformation(), 
[17:43:13.197]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:13.197]                   signalCondition(cond)
[17:43:13.197]                 }
[17:43:13.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:13.197]                 "immediateCondition"))) {
[17:43:13.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:13.197]                   ...future.conditions[[length(...future.conditions) + 
[17:43:13.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:13.197]                   if (TRUE && !signal) {
[17:43:13.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.197]                     {
[17:43:13.197]                       inherits <- base::inherits
[17:43:13.197]                       invokeRestart <- base::invokeRestart
[17:43:13.197]                       is.null <- base::is.null
[17:43:13.197]                       muffled <- FALSE
[17:43:13.197]                       if (inherits(cond, "message")) {
[17:43:13.197]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:13.197]                         if (muffled) 
[17:43:13.197]                           invokeRestart("muffleMessage")
[17:43:13.197]                       }
[17:43:13.197]                       else if (inherits(cond, "warning")) {
[17:43:13.197]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:13.197]                         if (muffled) 
[17:43:13.197]                           invokeRestart("muffleWarning")
[17:43:13.197]                       }
[17:43:13.197]                       else if (inherits(cond, "condition")) {
[17:43:13.197]                         if (!is.null(pattern)) {
[17:43:13.197]                           computeRestarts <- base::computeRestarts
[17:43:13.197]                           grepl <- base::grepl
[17:43:13.197]                           restarts <- computeRestarts(cond)
[17:43:13.197]                           for (restart in restarts) {
[17:43:13.197]                             name <- restart$name
[17:43:13.197]                             if (is.null(name)) 
[17:43:13.197]                               next
[17:43:13.197]                             if (!grepl(pattern, name)) 
[17:43:13.197]                               next
[17:43:13.197]                             invokeRestart(restart)
[17:43:13.197]                             muffled <- TRUE
[17:43:13.197]                             break
[17:43:13.197]                           }
[17:43:13.197]                         }
[17:43:13.197]                       }
[17:43:13.197]                       invisible(muffled)
[17:43:13.197]                     }
[17:43:13.197]                     muffleCondition(cond, pattern = "^muffle")
[17:43:13.197]                   }
[17:43:13.197]                 }
[17:43:13.197]                 else {
[17:43:13.197]                   if (TRUE) {
[17:43:13.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.197]                     {
[17:43:13.197]                       inherits <- base::inherits
[17:43:13.197]                       invokeRestart <- base::invokeRestart
[17:43:13.197]                       is.null <- base::is.null
[17:43:13.197]                       muffled <- FALSE
[17:43:13.197]                       if (inherits(cond, "message")) {
[17:43:13.197]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:13.197]                         if (muffled) 
[17:43:13.197]                           invokeRestart("muffleMessage")
[17:43:13.197]                       }
[17:43:13.197]                       else if (inherits(cond, "warning")) {
[17:43:13.197]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:13.197]                         if (muffled) 
[17:43:13.197]                           invokeRestart("muffleWarning")
[17:43:13.197]                       }
[17:43:13.197]                       else if (inherits(cond, "condition")) {
[17:43:13.197]                         if (!is.null(pattern)) {
[17:43:13.197]                           computeRestarts <- base::computeRestarts
[17:43:13.197]                           grepl <- base::grepl
[17:43:13.197]                           restarts <- computeRestarts(cond)
[17:43:13.197]                           for (restart in restarts) {
[17:43:13.197]                             name <- restart$name
[17:43:13.197]                             if (is.null(name)) 
[17:43:13.197]                               next
[17:43:13.197]                             if (!grepl(pattern, name)) 
[17:43:13.197]                               next
[17:43:13.197]                             invokeRestart(restart)
[17:43:13.197]                             muffled <- TRUE
[17:43:13.197]                             break
[17:43:13.197]                           }
[17:43:13.197]                         }
[17:43:13.197]                       }
[17:43:13.197]                       invisible(muffled)
[17:43:13.197]                     }
[17:43:13.197]                     muffleCondition(cond, pattern = "^muffle")
[17:43:13.197]                   }
[17:43:13.197]                 }
[17:43:13.197]             }
[17:43:13.197]         }))
[17:43:13.197]     }, error = function(ex) {
[17:43:13.197]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:13.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:13.197]                 ...future.rng), started = ...future.startTime, 
[17:43:13.197]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:13.197]             version = "1.8"), class = "FutureResult")
[17:43:13.197]     }, finally = {
[17:43:13.197]         if (!identical(...future.workdir, getwd())) 
[17:43:13.197]             setwd(...future.workdir)
[17:43:13.197]         {
[17:43:13.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:13.197]                 ...future.oldOptions$nwarnings <- NULL
[17:43:13.197]             }
[17:43:13.197]             base::options(...future.oldOptions)
[17:43:13.197]             if (.Platform$OS.type == "windows") {
[17:43:13.197]                 old_names <- names(...future.oldEnvVars)
[17:43:13.197]                 envs <- base::Sys.getenv()
[17:43:13.197]                 names <- names(envs)
[17:43:13.197]                 common <- intersect(names, old_names)
[17:43:13.197]                 added <- setdiff(names, old_names)
[17:43:13.197]                 removed <- setdiff(old_names, names)
[17:43:13.197]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:13.197]                   envs[common]]
[17:43:13.197]                 NAMES <- toupper(changed)
[17:43:13.197]                 args <- list()
[17:43:13.197]                 for (kk in seq_along(NAMES)) {
[17:43:13.197]                   name <- changed[[kk]]
[17:43:13.197]                   NAME <- NAMES[[kk]]
[17:43:13.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.197]                     next
[17:43:13.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:13.197]                 }
[17:43:13.197]                 NAMES <- toupper(added)
[17:43:13.197]                 for (kk in seq_along(NAMES)) {
[17:43:13.197]                   name <- added[[kk]]
[17:43:13.197]                   NAME <- NAMES[[kk]]
[17:43:13.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.197]                     next
[17:43:13.197]                   args[[name]] <- ""
[17:43:13.197]                 }
[17:43:13.197]                 NAMES <- toupper(removed)
[17:43:13.197]                 for (kk in seq_along(NAMES)) {
[17:43:13.197]                   name <- removed[[kk]]
[17:43:13.197]                   NAME <- NAMES[[kk]]
[17:43:13.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.197]                     next
[17:43:13.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:13.197]                 }
[17:43:13.197]                 if (length(args) > 0) 
[17:43:13.197]                   base::do.call(base::Sys.setenv, args = args)
[17:43:13.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:13.197]             }
[17:43:13.197]             else {
[17:43:13.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:13.197]             }
[17:43:13.197]             {
[17:43:13.197]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:13.197]                   0L) {
[17:43:13.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:13.197]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:13.197]                   base::options(opts)
[17:43:13.197]                 }
[17:43:13.197]                 {
[17:43:13.197]                   {
[17:43:13.197]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:13.197]                     NULL
[17:43:13.197]                   }
[17:43:13.197]                   options(future.plan = NULL)
[17:43:13.197]                   if (is.na(NA_character_)) 
[17:43:13.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:13.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:13.197]                   future::plan(list(a = function (..., workers = availableCores(), 
[17:43:13.197]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:13.197]                     envir = parent.frame()) 
[17:43:13.197]                   {
[17:43:13.197]                     if (is.function(workers)) 
[17:43:13.197]                       workers <- workers()
[17:43:13.197]                     workers <- structure(as.integer(workers), 
[17:43:13.197]                       class = class(workers))
[17:43:13.197]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:13.197]                       workers >= 1)
[17:43:13.197]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:13.197]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:13.197]                     }
[17:43:13.197]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:13.197]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:13.197]                       envir = envir)
[17:43:13.197]                     if (!future$lazy) 
[17:43:13.197]                       future <- run(future)
[17:43:13.197]                     invisible(future)
[17:43:13.197]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[17:43:13.197]                     envir = parent.frame()) 
[17:43:13.197]                   {
[17:43:13.197]                     default_workers <- missing(workers)
[17:43:13.197]                     if (is.function(workers)) 
[17:43:13.197]                       workers <- workers()
[17:43:13.197]                     workers <- structure(as.integer(workers), 
[17:43:13.197]                       class = class(workers))
[17:43:13.197]                     stop_if_not(is.finite(workers), workers >= 
[17:43:13.197]                       1L)
[17:43:13.197]                     if ((workers == 1L && !inherits(workers, 
[17:43:13.197]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:13.197]                       if (default_workers) 
[17:43:13.197]                         supportsMulticore(warn = TRUE)
[17:43:13.197]                       return(sequential(..., envir = envir))
[17:43:13.197]                     }
[17:43:13.197]                     oopts <- options(mc.cores = workers)
[17:43:13.197]                     on.exit(options(oopts))
[17:43:13.197]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:13.197]                       envir = envir)
[17:43:13.197]                     if (!future$lazy) 
[17:43:13.197]                       future <- run(future)
[17:43:13.197]                     invisible(future)
[17:43:13.197]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:13.197]                 }
[17:43:13.197]             }
[17:43:13.197]         }
[17:43:13.197]     })
[17:43:13.197]     if (TRUE) {
[17:43:13.197]         base::sink(type = "output", split = FALSE)
[17:43:13.197]         if (TRUE) {
[17:43:13.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:13.197]         }
[17:43:13.197]         else {
[17:43:13.197]             ...future.result["stdout"] <- base::list(NULL)
[17:43:13.197]         }
[17:43:13.197]         base::close(...future.stdout)
[17:43:13.197]         ...future.stdout <- NULL
[17:43:13.197]     }
[17:43:13.197]     ...future.result$conditions <- ...future.conditions
[17:43:13.197]     ...future.result$finished <- base::Sys.time()
[17:43:13.197]     ...future.result
[17:43:13.197] }
[17:43:13.200] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:43:13.200] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:43:13.200] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:43:13.201] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:43:13.201] MultisessionFuture started
[17:43:13.202] - Launch lazy future ... done
[17:43:13.202] run() for ‘MultisessionFuture’ ... done
[17:43:13.202] result() for ClusterFuture ...
[17:43:13.202] receiveMessageFromWorker() for ClusterFuture ...
[17:43:13.202] - Validating connection of MultisessionFuture
[17:43:13.262] - received message: FutureResult
[17:43:13.262] - Received FutureResult
[17:43:13.262] - Erased future from FutureRegistry
[17:43:13.262] result() for ClusterFuture ...
[17:43:13.263] - result already collected: FutureResult
[17:43:13.263] result() for ClusterFuture ... done
[17:43:13.263] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:13.263] result() for ClusterFuture ... done
[17:43:13.263] result() for ClusterFuture ...
[17:43:13.263] - result already collected: FutureResult
[17:43:13.263] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[17:43:13.264] plan(): Setting new future strategy stack:
[17:43:13.264] List of future strategies:
[17:43:13.264] 1. multisession:
[17:43:13.264]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:13.264]    - tweaked: FALSE
[17:43:13.264]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:13.264] 2. multisession:
[17:43:13.264]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:13.264]    - tweaked: FALSE
[17:43:13.264]    - call: plan(list(a = strategy1, b = strategy2))
[17:43:13.265] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:43:13.265] multisession:
[17:43:13.265] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:13.265] - tweaked: FALSE
[17:43:13.265] - call: plan(list(a = strategy1, b = strategy2))
[17:43:13.270] getGlobalsAndPackages() ...
[17:43:13.270] Not searching for globals
[17:43:13.270] - globals: [0] <none>
[17:43:13.270] getGlobalsAndPackages() ... DONE
[17:43:13.271] [local output] makeClusterPSOCK() ...
[17:43:13.271] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:43:13.272] [local output] Base port: 11684
[17:43:13.272] [local output] Getting setup options for 2 cluster nodes ...
[17:43:13.272] [local output]  - Node 1 of 2 ...
[17:43:13.273] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:13.274] [local output] Rscript port: 11684

[17:43:13.274] [local output]  - Node 2 of 2 ...
[17:43:13.275] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:13.275] [local output] Rscript port: 11684

[17:43:13.276] [local output] Getting setup options for 2 cluster nodes ... done
[17:43:13.276] [local output]  - Parallel setup requested for some PSOCK nodes
[17:43:13.276] [local output] Setting up PSOCK nodes in parallel
[17:43:13.276] List of 36
[17:43:13.276]  $ worker          : chr "localhost"
[17:43:13.276]   ..- attr(*, "localhost")= logi TRUE
[17:43:13.276]  $ master          : chr "localhost"
[17:43:13.276]  $ port            : int 11684
[17:43:13.276]  $ connectTimeout  : num 120
[17:43:13.276]  $ timeout         : num 2592000
[17:43:13.276]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:43:13.276]  $ homogeneous     : logi TRUE
[17:43:13.276]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:43:13.276]  $ rscript_envs    : NULL
[17:43:13.276]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:13.276]  $ rscript_startup : NULL
[17:43:13.276]  $ rscript_sh      : chr "sh"
[17:43:13.276]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:13.276]  $ methods         : logi TRUE
[17:43:13.276]  $ socketOptions   : chr "no-delay"
[17:43:13.276]  $ useXDR          : logi FALSE
[17:43:13.276]  $ outfile         : chr "/dev/null"
[17:43:13.276]  $ renice          : int NA
[17:43:13.276]  $ rshcmd          : NULL
[17:43:13.276]  $ user            : chr(0) 
[17:43:13.276]  $ revtunnel       : logi FALSE
[17:43:13.276]  $ rshlogfile      : NULL
[17:43:13.276]  $ rshopts         : chr(0) 
[17:43:13.276]  $ rank            : int 1
[17:43:13.276]  $ manual          : logi FALSE
[17:43:13.276]  $ dryrun          : logi FALSE
[17:43:13.276]  $ quiet           : logi FALSE
[17:43:13.276]  $ setup_strategy  : chr "parallel"
[17:43:13.276]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:13.276]  $ pidfile         : chr "/tmp/RtmpzPUCYD/worker.rank=1.parallelly.parent=50370.c4c224d616c2.pid"
[17:43:13.276]  $ rshcmd_label    : NULL
[17:43:13.276]  $ rsh_call        : NULL
[17:43:13.276]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:13.276]  $ localMachine    : logi TRUE
[17:43:13.276]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:43:13.276]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:43:13.276]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:43:13.276]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:43:13.276]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:43:13.276]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:43:13.276]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:43:13.276]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:43:13.276]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:43:13.276]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:43:13.276]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:43:13.276]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:43:13.276]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:43:13.276]  $ arguments       :List of 28
[17:43:13.276]   ..$ worker          : chr "localhost"
[17:43:13.276]   ..$ master          : NULL
[17:43:13.276]   ..$ port            : int 11684
[17:43:13.276]   ..$ connectTimeout  : num 120
[17:43:13.276]   ..$ timeout         : num 2592000
[17:43:13.276]   ..$ rscript         : NULL
[17:43:13.276]   ..$ homogeneous     : NULL
[17:43:13.276]   ..$ rscript_args    : NULL
[17:43:13.276]   ..$ rscript_envs    : NULL
[17:43:13.276]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:13.276]   ..$ rscript_startup : NULL
[17:43:13.276]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:43:13.276]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:13.276]   ..$ methods         : logi TRUE
[17:43:13.276]   ..$ socketOptions   : chr "no-delay"
[17:43:13.276]   ..$ useXDR          : logi FALSE
[17:43:13.276]   ..$ outfile         : chr "/dev/null"
[17:43:13.276]   ..$ renice          : int NA
[17:43:13.276]   ..$ rshcmd          : NULL
[17:43:13.276]   ..$ user            : NULL
[17:43:13.276]   ..$ revtunnel       : logi NA
[17:43:13.276]   ..$ rshlogfile      : NULL
[17:43:13.276]   ..$ rshopts         : NULL
[17:43:13.276]   ..$ rank            : int 1
[17:43:13.276]   ..$ manual          : logi FALSE
[17:43:13.276]   ..$ dryrun          : logi FALSE
[17:43:13.276]   ..$ quiet           : logi FALSE
[17:43:13.276]   ..$ setup_strategy  : chr "parallel"
[17:43:13.276]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:43:13.297] [local output] System call to launch all workers:
[17:43:13.298] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpzPUCYD/worker.rank=1.parallelly.parent=50370.c4c224d616c2.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11684 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:43:13.298] [local output] Starting PSOCK main server
[17:43:13.299] [local output] Workers launched
[17:43:13.299] [local output] Waiting for workers to connect back
[17:43:13.299]  - [local output] 0 workers out of 2 ready
[17:43:13.542]  - [local output] 0 workers out of 2 ready
[17:43:13.543]  - [local output] 1 workers out of 2 ready
[17:43:13.557]  - [local output] 1 workers out of 2 ready
[17:43:13.558]  - [local output] 2 workers out of 2 ready
[17:43:13.558] [local output] Launching of workers completed
[17:43:13.558] [local output] Collecting session information from workers
[17:43:13.559] [local output]  - Worker #1 of 2
[17:43:13.559] [local output]  - Worker #2 of 2
[17:43:13.559] [local output] makeClusterPSOCK() ... done
[17:43:13.570] Packages needed by the future expression (n = 0): <none>
[17:43:13.571] Packages needed by future strategies (n = 1): ‘future’
[17:43:13.571] {
[17:43:13.571]     {
[17:43:13.571]         {
[17:43:13.571]             ...future.startTime <- base::Sys.time()
[17:43:13.571]             {
[17:43:13.571]                 {
[17:43:13.571]                   {
[17:43:13.571]                     {
[17:43:13.571]                       {
[17:43:13.571]                         base::local({
[17:43:13.571]                           has_future <- base::requireNamespace("future", 
[17:43:13.571]                             quietly = TRUE)
[17:43:13.571]                           if (has_future) {
[17:43:13.571]                             ns <- base::getNamespace("future")
[17:43:13.571]                             version <- ns[[".package"]][["version"]]
[17:43:13.571]                             if (is.null(version)) 
[17:43:13.571]                               version <- utils::packageVersion("future")
[17:43:13.571]                           }
[17:43:13.571]                           else {
[17:43:13.571]                             version <- NULL
[17:43:13.571]                           }
[17:43:13.571]                           if (!has_future || version < "1.8.0") {
[17:43:13.571]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:13.571]                               "", base::R.version$version.string), 
[17:43:13.571]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:13.571]                                 base::R.version$platform, 8 * 
[17:43:13.571]                                   base::.Machine$sizeof.pointer), 
[17:43:13.571]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:13.571]                                 "release", "version")], collapse = " "), 
[17:43:13.571]                               hostname = base::Sys.info()[["nodename"]])
[17:43:13.571]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:13.571]                               info)
[17:43:13.571]                             info <- base::paste(info, collapse = "; ")
[17:43:13.571]                             if (!has_future) {
[17:43:13.571]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:13.571]                                 info)
[17:43:13.571]                             }
[17:43:13.571]                             else {
[17:43:13.571]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:13.571]                                 info, version)
[17:43:13.571]                             }
[17:43:13.571]                             base::stop(msg)
[17:43:13.571]                           }
[17:43:13.571]                         })
[17:43:13.571]                       }
[17:43:13.571]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:13.571]                       base::options(mc.cores = 1L)
[17:43:13.571]                     }
[17:43:13.571]                     base::local({
[17:43:13.571]                       for (pkg in "future") {
[17:43:13.571]                         base::loadNamespace(pkg)
[17:43:13.571]                         base::library(pkg, character.only = TRUE)
[17:43:13.571]                       }
[17:43:13.571]                     })
[17:43:13.571]                   }
[17:43:13.571]                   options(future.plan = NULL)
[17:43:13.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:13.571]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:43:13.571]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:13.571]                     envir = parent.frame()) 
[17:43:13.571]                   {
[17:43:13.571]                     if (is.function(workers)) 
[17:43:13.571]                       workers <- workers()
[17:43:13.571]                     workers <- structure(as.integer(workers), 
[17:43:13.571]                       class = class(workers))
[17:43:13.571]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:13.571]                       workers >= 1)
[17:43:13.571]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:13.571]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:13.571]                     }
[17:43:13.571]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:13.571]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:13.571]                       envir = envir)
[17:43:13.571]                     if (!future$lazy) 
[17:43:13.571]                       future <- run(future)
[17:43:13.571]                     invisible(future)
[17:43:13.571]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:13.571]                 }
[17:43:13.571]                 ...future.workdir <- getwd()
[17:43:13.571]             }
[17:43:13.571]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:13.571]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:13.571]         }
[17:43:13.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:13.571]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:13.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:13.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:13.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:13.571]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:13.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:13.571]             base::names(...future.oldOptions))
[17:43:13.571]     }
[17:43:13.571]     if (FALSE) {
[17:43:13.571]     }
[17:43:13.571]     else {
[17:43:13.571]         if (TRUE) {
[17:43:13.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:13.571]                 open = "w")
[17:43:13.571]         }
[17:43:13.571]         else {
[17:43:13.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:13.571]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:13.571]         }
[17:43:13.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:13.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:13.571]             base::sink(type = "output", split = FALSE)
[17:43:13.571]             base::close(...future.stdout)
[17:43:13.571]         }, add = TRUE)
[17:43:13.571]     }
[17:43:13.571]     ...future.frame <- base::sys.nframe()
[17:43:13.571]     ...future.conditions <- base::list()
[17:43:13.571]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:13.571]     if (FALSE) {
[17:43:13.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:13.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:13.571]     }
[17:43:13.571]     ...future.result <- base::tryCatch({
[17:43:13.571]         base::withCallingHandlers({
[17:43:13.571]             ...future.value <- base::withVisible(base::local({
[17:43:13.571]                 ...future.makeSendCondition <- local({
[17:43:13.571]                   sendCondition <- NULL
[17:43:13.571]                   function(frame = 1L) {
[17:43:13.571]                     if (is.function(sendCondition)) 
[17:43:13.571]                       return(sendCondition)
[17:43:13.571]                     ns <- getNamespace("parallel")
[17:43:13.571]                     if (exists("sendData", mode = "function", 
[17:43:13.571]                       envir = ns)) {
[17:43:13.571]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:13.571]                         envir = ns)
[17:43:13.571]                       envir <- sys.frame(frame)
[17:43:13.571]                       master <- NULL
[17:43:13.571]                       while (!identical(envir, .GlobalEnv) && 
[17:43:13.571]                         !identical(envir, emptyenv())) {
[17:43:13.571]                         if (exists("master", mode = "list", envir = envir, 
[17:43:13.571]                           inherits = FALSE)) {
[17:43:13.571]                           master <- get("master", mode = "list", 
[17:43:13.571]                             envir = envir, inherits = FALSE)
[17:43:13.571]                           if (inherits(master, c("SOCKnode", 
[17:43:13.571]                             "SOCK0node"))) {
[17:43:13.571]                             sendCondition <<- function(cond) {
[17:43:13.571]                               data <- list(type = "VALUE", value = cond, 
[17:43:13.571]                                 success = TRUE)
[17:43:13.571]                               parallel_sendData(master, data)
[17:43:13.571]                             }
[17:43:13.571]                             return(sendCondition)
[17:43:13.571]                           }
[17:43:13.571]                         }
[17:43:13.571]                         frame <- frame + 1L
[17:43:13.571]                         envir <- sys.frame(frame)
[17:43:13.571]                       }
[17:43:13.571]                     }
[17:43:13.571]                     sendCondition <<- function(cond) NULL
[17:43:13.571]                   }
[17:43:13.571]                 })
[17:43:13.571]                 withCallingHandlers({
[17:43:13.571]                   NA
[17:43:13.571]                 }, immediateCondition = function(cond) {
[17:43:13.571]                   sendCondition <- ...future.makeSendCondition()
[17:43:13.571]                   sendCondition(cond)
[17:43:13.571]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.571]                   {
[17:43:13.571]                     inherits <- base::inherits
[17:43:13.571]                     invokeRestart <- base::invokeRestart
[17:43:13.571]                     is.null <- base::is.null
[17:43:13.571]                     muffled <- FALSE
[17:43:13.571]                     if (inherits(cond, "message")) {
[17:43:13.571]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:13.571]                       if (muffled) 
[17:43:13.571]                         invokeRestart("muffleMessage")
[17:43:13.571]                     }
[17:43:13.571]                     else if (inherits(cond, "warning")) {
[17:43:13.571]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:13.571]                       if (muffled) 
[17:43:13.571]                         invokeRestart("muffleWarning")
[17:43:13.571]                     }
[17:43:13.571]                     else if (inherits(cond, "condition")) {
[17:43:13.571]                       if (!is.null(pattern)) {
[17:43:13.571]                         computeRestarts <- base::computeRestarts
[17:43:13.571]                         grepl <- base::grepl
[17:43:13.571]                         restarts <- computeRestarts(cond)
[17:43:13.571]                         for (restart in restarts) {
[17:43:13.571]                           name <- restart$name
[17:43:13.571]                           if (is.null(name)) 
[17:43:13.571]                             next
[17:43:13.571]                           if (!grepl(pattern, name)) 
[17:43:13.571]                             next
[17:43:13.571]                           invokeRestart(restart)
[17:43:13.571]                           muffled <- TRUE
[17:43:13.571]                           break
[17:43:13.571]                         }
[17:43:13.571]                       }
[17:43:13.571]                     }
[17:43:13.571]                     invisible(muffled)
[17:43:13.571]                   }
[17:43:13.571]                   muffleCondition(cond)
[17:43:13.571]                 })
[17:43:13.571]             }))
[17:43:13.571]             future::FutureResult(value = ...future.value$value, 
[17:43:13.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:13.571]                   ...future.rng), globalenv = if (FALSE) 
[17:43:13.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:13.571]                     ...future.globalenv.names))
[17:43:13.571]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:13.571]         }, condition = base::local({
[17:43:13.571]             c <- base::c
[17:43:13.571]             inherits <- base::inherits
[17:43:13.571]             invokeRestart <- base::invokeRestart
[17:43:13.571]             length <- base::length
[17:43:13.571]             list <- base::list
[17:43:13.571]             seq.int <- base::seq.int
[17:43:13.571]             signalCondition <- base::signalCondition
[17:43:13.571]             sys.calls <- base::sys.calls
[17:43:13.571]             `[[` <- base::`[[`
[17:43:13.571]             `+` <- base::`+`
[17:43:13.571]             `<<-` <- base::`<<-`
[17:43:13.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:13.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:13.571]                   3L)]
[17:43:13.571]             }
[17:43:13.571]             function(cond) {
[17:43:13.571]                 is_error <- inherits(cond, "error")
[17:43:13.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:13.571]                   NULL)
[17:43:13.571]                 if (is_error) {
[17:43:13.571]                   sessionInformation <- function() {
[17:43:13.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:13.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:13.571]                       search = base::search(), system = base::Sys.info())
[17:43:13.571]                   }
[17:43:13.571]                   ...future.conditions[[length(...future.conditions) + 
[17:43:13.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:13.571]                     cond$call), session = sessionInformation(), 
[17:43:13.571]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:13.571]                   signalCondition(cond)
[17:43:13.571]                 }
[17:43:13.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:13.571]                 "immediateCondition"))) {
[17:43:13.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:13.571]                   ...future.conditions[[length(...future.conditions) + 
[17:43:13.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:13.571]                   if (TRUE && !signal) {
[17:43:13.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.571]                     {
[17:43:13.571]                       inherits <- base::inherits
[17:43:13.571]                       invokeRestart <- base::invokeRestart
[17:43:13.571]                       is.null <- base::is.null
[17:43:13.571]                       muffled <- FALSE
[17:43:13.571]                       if (inherits(cond, "message")) {
[17:43:13.571]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:13.571]                         if (muffled) 
[17:43:13.571]                           invokeRestart("muffleMessage")
[17:43:13.571]                       }
[17:43:13.571]                       else if (inherits(cond, "warning")) {
[17:43:13.571]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:13.571]                         if (muffled) 
[17:43:13.571]                           invokeRestart("muffleWarning")
[17:43:13.571]                       }
[17:43:13.571]                       else if (inherits(cond, "condition")) {
[17:43:13.571]                         if (!is.null(pattern)) {
[17:43:13.571]                           computeRestarts <- base::computeRestarts
[17:43:13.571]                           grepl <- base::grepl
[17:43:13.571]                           restarts <- computeRestarts(cond)
[17:43:13.571]                           for (restart in restarts) {
[17:43:13.571]                             name <- restart$name
[17:43:13.571]                             if (is.null(name)) 
[17:43:13.571]                               next
[17:43:13.571]                             if (!grepl(pattern, name)) 
[17:43:13.571]                               next
[17:43:13.571]                             invokeRestart(restart)
[17:43:13.571]                             muffled <- TRUE
[17:43:13.571]                             break
[17:43:13.571]                           }
[17:43:13.571]                         }
[17:43:13.571]                       }
[17:43:13.571]                       invisible(muffled)
[17:43:13.571]                     }
[17:43:13.571]                     muffleCondition(cond, pattern = "^muffle")
[17:43:13.571]                   }
[17:43:13.571]                 }
[17:43:13.571]                 else {
[17:43:13.571]                   if (TRUE) {
[17:43:13.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.571]                     {
[17:43:13.571]                       inherits <- base::inherits
[17:43:13.571]                       invokeRestart <- base::invokeRestart
[17:43:13.571]                       is.null <- base::is.null
[17:43:13.571]                       muffled <- FALSE
[17:43:13.571]                       if (inherits(cond, "message")) {
[17:43:13.571]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:13.571]                         if (muffled) 
[17:43:13.571]                           invokeRestart("muffleMessage")
[17:43:13.571]                       }
[17:43:13.571]                       else if (inherits(cond, "warning")) {
[17:43:13.571]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:13.571]                         if (muffled) 
[17:43:13.571]                           invokeRestart("muffleWarning")
[17:43:13.571]                       }
[17:43:13.571]                       else if (inherits(cond, "condition")) {
[17:43:13.571]                         if (!is.null(pattern)) {
[17:43:13.571]                           computeRestarts <- base::computeRestarts
[17:43:13.571]                           grepl <- base::grepl
[17:43:13.571]                           restarts <- computeRestarts(cond)
[17:43:13.571]                           for (restart in restarts) {
[17:43:13.571]                             name <- restart$name
[17:43:13.571]                             if (is.null(name)) 
[17:43:13.571]                               next
[17:43:13.571]                             if (!grepl(pattern, name)) 
[17:43:13.571]                               next
[17:43:13.571]                             invokeRestart(restart)
[17:43:13.571]                             muffled <- TRUE
[17:43:13.571]                             break
[17:43:13.571]                           }
[17:43:13.571]                         }
[17:43:13.571]                       }
[17:43:13.571]                       invisible(muffled)
[17:43:13.571]                     }
[17:43:13.571]                     muffleCondition(cond, pattern = "^muffle")
[17:43:13.571]                   }
[17:43:13.571]                 }
[17:43:13.571]             }
[17:43:13.571]         }))
[17:43:13.571]     }, error = function(ex) {
[17:43:13.571]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:13.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:13.571]                 ...future.rng), started = ...future.startTime, 
[17:43:13.571]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:13.571]             version = "1.8"), class = "FutureResult")
[17:43:13.571]     }, finally = {
[17:43:13.571]         if (!identical(...future.workdir, getwd())) 
[17:43:13.571]             setwd(...future.workdir)
[17:43:13.571]         {
[17:43:13.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:13.571]                 ...future.oldOptions$nwarnings <- NULL
[17:43:13.571]             }
[17:43:13.571]             base::options(...future.oldOptions)
[17:43:13.571]             if (.Platform$OS.type == "windows") {
[17:43:13.571]                 old_names <- names(...future.oldEnvVars)
[17:43:13.571]                 envs <- base::Sys.getenv()
[17:43:13.571]                 names <- names(envs)
[17:43:13.571]                 common <- intersect(names, old_names)
[17:43:13.571]                 added <- setdiff(names, old_names)
[17:43:13.571]                 removed <- setdiff(old_names, names)
[17:43:13.571]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:13.571]                   envs[common]]
[17:43:13.571]                 NAMES <- toupper(changed)
[17:43:13.571]                 args <- list()
[17:43:13.571]                 for (kk in seq_along(NAMES)) {
[17:43:13.571]                   name <- changed[[kk]]
[17:43:13.571]                   NAME <- NAMES[[kk]]
[17:43:13.571]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.571]                     next
[17:43:13.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:13.571]                 }
[17:43:13.571]                 NAMES <- toupper(added)
[17:43:13.571]                 for (kk in seq_along(NAMES)) {
[17:43:13.571]                   name <- added[[kk]]
[17:43:13.571]                   NAME <- NAMES[[kk]]
[17:43:13.571]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.571]                     next
[17:43:13.571]                   args[[name]] <- ""
[17:43:13.571]                 }
[17:43:13.571]                 NAMES <- toupper(removed)
[17:43:13.571]                 for (kk in seq_along(NAMES)) {
[17:43:13.571]                   name <- removed[[kk]]
[17:43:13.571]                   NAME <- NAMES[[kk]]
[17:43:13.571]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.571]                     next
[17:43:13.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:13.571]                 }
[17:43:13.571]                 if (length(args) > 0) 
[17:43:13.571]                   base::do.call(base::Sys.setenv, args = args)
[17:43:13.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:13.571]             }
[17:43:13.571]             else {
[17:43:13.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:13.571]             }
[17:43:13.571]             {
[17:43:13.571]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:13.571]                   0L) {
[17:43:13.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:13.571]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:13.571]                   base::options(opts)
[17:43:13.571]                 }
[17:43:13.571]                 {
[17:43:13.571]                   {
[17:43:13.571]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:13.571]                     NULL
[17:43:13.571]                   }
[17:43:13.571]                   options(future.plan = NULL)
[17:43:13.571]                   if (is.na(NA_character_)) 
[17:43:13.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:13.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:13.571]                   future::plan(list(a = function (..., workers = availableCores(), 
[17:43:13.571]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:13.571]                     envir = parent.frame()) 
[17:43:13.571]                   {
[17:43:13.571]                     if (is.function(workers)) 
[17:43:13.571]                       workers <- workers()
[17:43:13.571]                     workers <- structure(as.integer(workers), 
[17:43:13.571]                       class = class(workers))
[17:43:13.571]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:13.571]                       workers >= 1)
[17:43:13.571]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:13.571]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:13.571]                     }
[17:43:13.571]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:13.571]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:13.571]                       envir = envir)
[17:43:13.571]                     if (!future$lazy) 
[17:43:13.571]                       future <- run(future)
[17:43:13.571]                     invisible(future)
[17:43:13.571]                   }, b = function (..., workers = availableCores(), 
[17:43:13.571]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:13.571]                     envir = parent.frame()) 
[17:43:13.571]                   {
[17:43:13.571]                     if (is.function(workers)) 
[17:43:13.571]                       workers <- workers()
[17:43:13.571]                     workers <- structure(as.integer(workers), 
[17:43:13.571]                       class = class(workers))
[17:43:13.571]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:13.571]                       workers >= 1)
[17:43:13.571]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:13.571]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:13.571]                     }
[17:43:13.571]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:13.571]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:13.571]                       envir = envir)
[17:43:13.571]                     if (!future$lazy) 
[17:43:13.571]                       future <- run(future)
[17:43:13.571]                     invisible(future)
[17:43:13.571]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:13.571]                 }
[17:43:13.571]             }
[17:43:13.571]         }
[17:43:13.571]     })
[17:43:13.571]     if (TRUE) {
[17:43:13.571]         base::sink(type = "output", split = FALSE)
[17:43:13.571]         if (TRUE) {
[17:43:13.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:13.571]         }
[17:43:13.571]         else {
[17:43:13.571]             ...future.result["stdout"] <- base::list(NULL)
[17:43:13.571]         }
[17:43:13.571]         base::close(...future.stdout)
[17:43:13.571]         ...future.stdout <- NULL
[17:43:13.571]     }
[17:43:13.571]     ...future.result$conditions <- ...future.conditions
[17:43:13.571]     ...future.result$finished <- base::Sys.time()
[17:43:13.571]     ...future.result
[17:43:13.571] }
[17:43:13.646] MultisessionFuture started
[17:43:13.647] result() for ClusterFuture ...
[17:43:13.647] receiveMessageFromWorker() for ClusterFuture ...
[17:43:13.647] - Validating connection of MultisessionFuture
[17:43:13.691] - received message: FutureResult
[17:43:13.691] - Received FutureResult
[17:43:13.691] - Erased future from FutureRegistry
[17:43:13.691] result() for ClusterFuture ...
[17:43:13.691] - result already collected: FutureResult
[17:43:13.691] result() for ClusterFuture ... done
[17:43:13.691] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:13.692] result() for ClusterFuture ... done
[17:43:13.692] result() for ClusterFuture ...
[17:43:13.692] - result already collected: FutureResult
[17:43:13.692] result() for ClusterFuture ... done
[17:43:13.692] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:43:13.696] plan(): nbrOfWorkers() = 2
[17:43:13.696] getGlobalsAndPackages() ...
[17:43:13.696] Searching for globals...
[17:43:13.718] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:43:13.718] Searching for globals ... DONE
[17:43:13.718] Resolving globals: FALSE
[17:43:13.720] The total size of the 2 globals is 88.27 KiB (90384 bytes)
[17:43:13.720] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 88.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (88.15 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:43:13.721] - globals: [2] ‘nested’, ‘strategy2’
[17:43:13.721] - packages: [1] ‘future’
[17:43:13.721] getGlobalsAndPackages() ... DONE
[17:43:13.721] run() for ‘Future’ ...
[17:43:13.722] - state: ‘created’
[17:43:13.722] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:13.739] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:13.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:13.740]   - Field: ‘node’
[17:43:13.740]   - Field: ‘label’
[17:43:13.740]   - Field: ‘local’
[17:43:13.740]   - Field: ‘owner’
[17:43:13.740]   - Field: ‘envir’
[17:43:13.740]   - Field: ‘workers’
[17:43:13.740]   - Field: ‘packages’
[17:43:13.741]   - Field: ‘gc’
[17:43:13.741]   - Field: ‘conditions’
[17:43:13.741]   - Field: ‘persistent’
[17:43:13.741]   - Field: ‘expr’
[17:43:13.741]   - Field: ‘uuid’
[17:43:13.741]   - Field: ‘seed’
[17:43:13.741]   - Field: ‘version’
[17:43:13.741]   - Field: ‘result’
[17:43:13.741]   - Field: ‘asynchronous’
[17:43:13.741]   - Field: ‘calls’
[17:43:13.741]   - Field: ‘globals’
[17:43:13.742]   - Field: ‘stdout’
[17:43:13.742]   - Field: ‘earlySignal’
[17:43:13.742]   - Field: ‘lazy’
[17:43:13.742]   - Field: ‘state’
[17:43:13.742] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:13.742] - Launch lazy future ...
[17:43:13.742] Packages needed by the future expression (n = 1): ‘future’
[17:43:13.743] Packages needed by future strategies (n = 1): ‘future’
[17:43:13.743] {
[17:43:13.743]     {
[17:43:13.743]         {
[17:43:13.743]             ...future.startTime <- base::Sys.time()
[17:43:13.743]             {
[17:43:13.743]                 {
[17:43:13.743]                   {
[17:43:13.743]                     {
[17:43:13.743]                       {
[17:43:13.743]                         base::local({
[17:43:13.743]                           has_future <- base::requireNamespace("future", 
[17:43:13.743]                             quietly = TRUE)
[17:43:13.743]                           if (has_future) {
[17:43:13.743]                             ns <- base::getNamespace("future")
[17:43:13.743]                             version <- ns[[".package"]][["version"]]
[17:43:13.743]                             if (is.null(version)) 
[17:43:13.743]                               version <- utils::packageVersion("future")
[17:43:13.743]                           }
[17:43:13.743]                           else {
[17:43:13.743]                             version <- NULL
[17:43:13.743]                           }
[17:43:13.743]                           if (!has_future || version < "1.8.0") {
[17:43:13.743]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:13.743]                               "", base::R.version$version.string), 
[17:43:13.743]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:13.743]                                 base::R.version$platform, 8 * 
[17:43:13.743]                                   base::.Machine$sizeof.pointer), 
[17:43:13.743]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:13.743]                                 "release", "version")], collapse = " "), 
[17:43:13.743]                               hostname = base::Sys.info()[["nodename"]])
[17:43:13.743]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:13.743]                               info)
[17:43:13.743]                             info <- base::paste(info, collapse = "; ")
[17:43:13.743]                             if (!has_future) {
[17:43:13.743]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:13.743]                                 info)
[17:43:13.743]                             }
[17:43:13.743]                             else {
[17:43:13.743]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:13.743]                                 info, version)
[17:43:13.743]                             }
[17:43:13.743]                             base::stop(msg)
[17:43:13.743]                           }
[17:43:13.743]                         })
[17:43:13.743]                       }
[17:43:13.743]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:13.743]                       base::options(mc.cores = 1L)
[17:43:13.743]                     }
[17:43:13.743]                     base::local({
[17:43:13.743]                       for (pkg in "future") {
[17:43:13.743]                         base::loadNamespace(pkg)
[17:43:13.743]                         base::library(pkg, character.only = TRUE)
[17:43:13.743]                       }
[17:43:13.743]                     })
[17:43:13.743]                   }
[17:43:13.743]                   options(future.plan = NULL)
[17:43:13.743]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:13.743]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:43:13.743]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:13.743]                     envir = parent.frame()) 
[17:43:13.743]                   {
[17:43:13.743]                     if (is.function(workers)) 
[17:43:13.743]                       workers <- workers()
[17:43:13.743]                     workers <- structure(as.integer(workers), 
[17:43:13.743]                       class = class(workers))
[17:43:13.743]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:13.743]                       workers >= 1)
[17:43:13.743]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:13.743]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:13.743]                     }
[17:43:13.743]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:13.743]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:13.743]                       envir = envir)
[17:43:13.743]                     if (!future$lazy) 
[17:43:13.743]                       future <- run(future)
[17:43:13.743]                     invisible(future)
[17:43:13.743]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:13.743]                 }
[17:43:13.743]                 ...future.workdir <- getwd()
[17:43:13.743]             }
[17:43:13.743]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:13.743]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:13.743]         }
[17:43:13.743]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:13.743]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:13.743]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:13.743]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:13.743]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:13.743]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:13.743]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:13.743]             base::names(...future.oldOptions))
[17:43:13.743]     }
[17:43:13.743]     if (FALSE) {
[17:43:13.743]     }
[17:43:13.743]     else {
[17:43:13.743]         if (TRUE) {
[17:43:13.743]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:13.743]                 open = "w")
[17:43:13.743]         }
[17:43:13.743]         else {
[17:43:13.743]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:13.743]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:13.743]         }
[17:43:13.743]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:13.743]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:13.743]             base::sink(type = "output", split = FALSE)
[17:43:13.743]             base::close(...future.stdout)
[17:43:13.743]         }, add = TRUE)
[17:43:13.743]     }
[17:43:13.743]     ...future.frame <- base::sys.nframe()
[17:43:13.743]     ...future.conditions <- base::list()
[17:43:13.743]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:13.743]     if (FALSE) {
[17:43:13.743]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:13.743]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:13.743]     }
[17:43:13.743]     ...future.result <- base::tryCatch({
[17:43:13.743]         base::withCallingHandlers({
[17:43:13.743]             ...future.value <- base::withVisible(base::local({
[17:43:13.743]                 ...future.makeSendCondition <- local({
[17:43:13.743]                   sendCondition <- NULL
[17:43:13.743]                   function(frame = 1L) {
[17:43:13.743]                     if (is.function(sendCondition)) 
[17:43:13.743]                       return(sendCondition)
[17:43:13.743]                     ns <- getNamespace("parallel")
[17:43:13.743]                     if (exists("sendData", mode = "function", 
[17:43:13.743]                       envir = ns)) {
[17:43:13.743]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:13.743]                         envir = ns)
[17:43:13.743]                       envir <- sys.frame(frame)
[17:43:13.743]                       master <- NULL
[17:43:13.743]                       while (!identical(envir, .GlobalEnv) && 
[17:43:13.743]                         !identical(envir, emptyenv())) {
[17:43:13.743]                         if (exists("master", mode = "list", envir = envir, 
[17:43:13.743]                           inherits = FALSE)) {
[17:43:13.743]                           master <- get("master", mode = "list", 
[17:43:13.743]                             envir = envir, inherits = FALSE)
[17:43:13.743]                           if (inherits(master, c("SOCKnode", 
[17:43:13.743]                             "SOCK0node"))) {
[17:43:13.743]                             sendCondition <<- function(cond) {
[17:43:13.743]                               data <- list(type = "VALUE", value = cond, 
[17:43:13.743]                                 success = TRUE)
[17:43:13.743]                               parallel_sendData(master, data)
[17:43:13.743]                             }
[17:43:13.743]                             return(sendCondition)
[17:43:13.743]                           }
[17:43:13.743]                         }
[17:43:13.743]                         frame <- frame + 1L
[17:43:13.743]                         envir <- sys.frame(frame)
[17:43:13.743]                       }
[17:43:13.743]                     }
[17:43:13.743]                     sendCondition <<- function(cond) NULL
[17:43:13.743]                   }
[17:43:13.743]                 })
[17:43:13.743]                 withCallingHandlers({
[17:43:13.743]                   {
[17:43:13.743]                     a <- 1L
[17:43:13.743]                     plan_a <- unclass(future::plan("list"))
[17:43:13.743]                     nested_a <- nested[-1]
[17:43:13.743]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:43:13.743]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:43:13.743]                       strategy2))
[17:43:13.743]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:43:13.743]                       "init") <- NULL
[17:43:13.743]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:43:13.743]                       "init") <- NULL
[17:43:13.743]                     stopifnot(all.equal(plan_a, nested_a))
[17:43:13.743]                     y %<-% {
[17:43:13.743]                       b <- 2L
[17:43:13.743]                       plan_b <- future::plan("list")
[17:43:13.743]                       nested_b <- nested_a[-1]
[17:43:13.743]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:43:13.743]                         1L, inherits(plan_b[[1]], "future"), 
[17:43:13.743]                         inherits(future::plan("next"), "sequential"))
[17:43:13.743]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:43:13.743]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:43:13.743]                     }
[17:43:13.743]                     y
[17:43:13.743]                   }
[17:43:13.743]                 }, immediateCondition = function(cond) {
[17:43:13.743]                   sendCondition <- ...future.makeSendCondition()
[17:43:13.743]                   sendCondition(cond)
[17:43:13.743]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.743]                   {
[17:43:13.743]                     inherits <- base::inherits
[17:43:13.743]                     invokeRestart <- base::invokeRestart
[17:43:13.743]                     is.null <- base::is.null
[17:43:13.743]                     muffled <- FALSE
[17:43:13.743]                     if (inherits(cond, "message")) {
[17:43:13.743]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:13.743]                       if (muffled) 
[17:43:13.743]                         invokeRestart("muffleMessage")
[17:43:13.743]                     }
[17:43:13.743]                     else if (inherits(cond, "warning")) {
[17:43:13.743]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:13.743]                       if (muffled) 
[17:43:13.743]                         invokeRestart("muffleWarning")
[17:43:13.743]                     }
[17:43:13.743]                     else if (inherits(cond, "condition")) {
[17:43:13.743]                       if (!is.null(pattern)) {
[17:43:13.743]                         computeRestarts <- base::computeRestarts
[17:43:13.743]                         grepl <- base::grepl
[17:43:13.743]                         restarts <- computeRestarts(cond)
[17:43:13.743]                         for (restart in restarts) {
[17:43:13.743]                           name <- restart$name
[17:43:13.743]                           if (is.null(name)) 
[17:43:13.743]                             next
[17:43:13.743]                           if (!grepl(pattern, name)) 
[17:43:13.743]                             next
[17:43:13.743]                           invokeRestart(restart)
[17:43:13.743]                           muffled <- TRUE
[17:43:13.743]                           break
[17:43:13.743]                         }
[17:43:13.743]                       }
[17:43:13.743]                     }
[17:43:13.743]                     invisible(muffled)
[17:43:13.743]                   }
[17:43:13.743]                   muffleCondition(cond)
[17:43:13.743]                 })
[17:43:13.743]             }))
[17:43:13.743]             future::FutureResult(value = ...future.value$value, 
[17:43:13.743]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:13.743]                   ...future.rng), globalenv = if (FALSE) 
[17:43:13.743]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:13.743]                     ...future.globalenv.names))
[17:43:13.743]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:13.743]         }, condition = base::local({
[17:43:13.743]             c <- base::c
[17:43:13.743]             inherits <- base::inherits
[17:43:13.743]             invokeRestart <- base::invokeRestart
[17:43:13.743]             length <- base::length
[17:43:13.743]             list <- base::list
[17:43:13.743]             seq.int <- base::seq.int
[17:43:13.743]             signalCondition <- base::signalCondition
[17:43:13.743]             sys.calls <- base::sys.calls
[17:43:13.743]             `[[` <- base::`[[`
[17:43:13.743]             `+` <- base::`+`
[17:43:13.743]             `<<-` <- base::`<<-`
[17:43:13.743]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:13.743]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:13.743]                   3L)]
[17:43:13.743]             }
[17:43:13.743]             function(cond) {
[17:43:13.743]                 is_error <- inherits(cond, "error")
[17:43:13.743]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:13.743]                   NULL)
[17:43:13.743]                 if (is_error) {
[17:43:13.743]                   sessionInformation <- function() {
[17:43:13.743]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:13.743]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:13.743]                       search = base::search(), system = base::Sys.info())
[17:43:13.743]                   }
[17:43:13.743]                   ...future.conditions[[length(...future.conditions) + 
[17:43:13.743]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:13.743]                     cond$call), session = sessionInformation(), 
[17:43:13.743]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:13.743]                   signalCondition(cond)
[17:43:13.743]                 }
[17:43:13.743]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:13.743]                 "immediateCondition"))) {
[17:43:13.743]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:13.743]                   ...future.conditions[[length(...future.conditions) + 
[17:43:13.743]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:13.743]                   if (TRUE && !signal) {
[17:43:13.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.743]                     {
[17:43:13.743]                       inherits <- base::inherits
[17:43:13.743]                       invokeRestart <- base::invokeRestart
[17:43:13.743]                       is.null <- base::is.null
[17:43:13.743]                       muffled <- FALSE
[17:43:13.743]                       if (inherits(cond, "message")) {
[17:43:13.743]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:13.743]                         if (muffled) 
[17:43:13.743]                           invokeRestart("muffleMessage")
[17:43:13.743]                       }
[17:43:13.743]                       else if (inherits(cond, "warning")) {
[17:43:13.743]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:13.743]                         if (muffled) 
[17:43:13.743]                           invokeRestart("muffleWarning")
[17:43:13.743]                       }
[17:43:13.743]                       else if (inherits(cond, "condition")) {
[17:43:13.743]                         if (!is.null(pattern)) {
[17:43:13.743]                           computeRestarts <- base::computeRestarts
[17:43:13.743]                           grepl <- base::grepl
[17:43:13.743]                           restarts <- computeRestarts(cond)
[17:43:13.743]                           for (restart in restarts) {
[17:43:13.743]                             name <- restart$name
[17:43:13.743]                             if (is.null(name)) 
[17:43:13.743]                               next
[17:43:13.743]                             if (!grepl(pattern, name)) 
[17:43:13.743]                               next
[17:43:13.743]                             invokeRestart(restart)
[17:43:13.743]                             muffled <- TRUE
[17:43:13.743]                             break
[17:43:13.743]                           }
[17:43:13.743]                         }
[17:43:13.743]                       }
[17:43:13.743]                       invisible(muffled)
[17:43:13.743]                     }
[17:43:13.743]                     muffleCondition(cond, pattern = "^muffle")
[17:43:13.743]                   }
[17:43:13.743]                 }
[17:43:13.743]                 else {
[17:43:13.743]                   if (TRUE) {
[17:43:13.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.743]                     {
[17:43:13.743]                       inherits <- base::inherits
[17:43:13.743]                       invokeRestart <- base::invokeRestart
[17:43:13.743]                       is.null <- base::is.null
[17:43:13.743]                       muffled <- FALSE
[17:43:13.743]                       if (inherits(cond, "message")) {
[17:43:13.743]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:13.743]                         if (muffled) 
[17:43:13.743]                           invokeRestart("muffleMessage")
[17:43:13.743]                       }
[17:43:13.743]                       else if (inherits(cond, "warning")) {
[17:43:13.743]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:13.743]                         if (muffled) 
[17:43:13.743]                           invokeRestart("muffleWarning")
[17:43:13.743]                       }
[17:43:13.743]                       else if (inherits(cond, "condition")) {
[17:43:13.743]                         if (!is.null(pattern)) {
[17:43:13.743]                           computeRestarts <- base::computeRestarts
[17:43:13.743]                           grepl <- base::grepl
[17:43:13.743]                           restarts <- computeRestarts(cond)
[17:43:13.743]                           for (restart in restarts) {
[17:43:13.743]                             name <- restart$name
[17:43:13.743]                             if (is.null(name)) 
[17:43:13.743]                               next
[17:43:13.743]                             if (!grepl(pattern, name)) 
[17:43:13.743]                               next
[17:43:13.743]                             invokeRestart(restart)
[17:43:13.743]                             muffled <- TRUE
[17:43:13.743]                             break
[17:43:13.743]                           }
[17:43:13.743]                         }
[17:43:13.743]                       }
[17:43:13.743]                       invisible(muffled)
[17:43:13.743]                     }
[17:43:13.743]                     muffleCondition(cond, pattern = "^muffle")
[17:43:13.743]                   }
[17:43:13.743]                 }
[17:43:13.743]             }
[17:43:13.743]         }))
[17:43:13.743]     }, error = function(ex) {
[17:43:13.743]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:13.743]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:13.743]                 ...future.rng), started = ...future.startTime, 
[17:43:13.743]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:13.743]             version = "1.8"), class = "FutureResult")
[17:43:13.743]     }, finally = {
[17:43:13.743]         if (!identical(...future.workdir, getwd())) 
[17:43:13.743]             setwd(...future.workdir)
[17:43:13.743]         {
[17:43:13.743]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:13.743]                 ...future.oldOptions$nwarnings <- NULL
[17:43:13.743]             }
[17:43:13.743]             base::options(...future.oldOptions)
[17:43:13.743]             if (.Platform$OS.type == "windows") {
[17:43:13.743]                 old_names <- names(...future.oldEnvVars)
[17:43:13.743]                 envs <- base::Sys.getenv()
[17:43:13.743]                 names <- names(envs)
[17:43:13.743]                 common <- intersect(names, old_names)
[17:43:13.743]                 added <- setdiff(names, old_names)
[17:43:13.743]                 removed <- setdiff(old_names, names)
[17:43:13.743]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:13.743]                   envs[common]]
[17:43:13.743]                 NAMES <- toupper(changed)
[17:43:13.743]                 args <- list()
[17:43:13.743]                 for (kk in seq_along(NAMES)) {
[17:43:13.743]                   name <- changed[[kk]]
[17:43:13.743]                   NAME <- NAMES[[kk]]
[17:43:13.743]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.743]                     next
[17:43:13.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:13.743]                 }
[17:43:13.743]                 NAMES <- toupper(added)
[17:43:13.743]                 for (kk in seq_along(NAMES)) {
[17:43:13.743]                   name <- added[[kk]]
[17:43:13.743]                   NAME <- NAMES[[kk]]
[17:43:13.743]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.743]                     next
[17:43:13.743]                   args[[name]] <- ""
[17:43:13.743]                 }
[17:43:13.743]                 NAMES <- toupper(removed)
[17:43:13.743]                 for (kk in seq_along(NAMES)) {
[17:43:13.743]                   name <- removed[[kk]]
[17:43:13.743]                   NAME <- NAMES[[kk]]
[17:43:13.743]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.743]                     next
[17:43:13.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:13.743]                 }
[17:43:13.743]                 if (length(args) > 0) 
[17:43:13.743]                   base::do.call(base::Sys.setenv, args = args)
[17:43:13.743]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:13.743]             }
[17:43:13.743]             else {
[17:43:13.743]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:13.743]             }
[17:43:13.743]             {
[17:43:13.743]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:13.743]                   0L) {
[17:43:13.743]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:13.743]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:13.743]                   base::options(opts)
[17:43:13.743]                 }
[17:43:13.743]                 {
[17:43:13.743]                   {
[17:43:13.743]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:13.743]                     NULL
[17:43:13.743]                   }
[17:43:13.743]                   options(future.plan = NULL)
[17:43:13.743]                   if (is.na(NA_character_)) 
[17:43:13.743]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:13.743]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:13.743]                   future::plan(list(a = function (..., workers = availableCores(), 
[17:43:13.743]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:13.743]                     envir = parent.frame()) 
[17:43:13.743]                   {
[17:43:13.743]                     if (is.function(workers)) 
[17:43:13.743]                       workers <- workers()
[17:43:13.743]                     workers <- structure(as.integer(workers), 
[17:43:13.743]                       class = class(workers))
[17:43:13.743]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:13.743]                       workers >= 1)
[17:43:13.743]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:13.743]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:13.743]                     }
[17:43:13.743]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:13.743]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:13.743]                       envir = envir)
[17:43:13.743]                     if (!future$lazy) 
[17:43:13.743]                       future <- run(future)
[17:43:13.743]                     invisible(future)
[17:43:13.743]                   }, b = function (..., workers = availableCores(), 
[17:43:13.743]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:13.743]                     envir = parent.frame()) 
[17:43:13.743]                   {
[17:43:13.743]                     if (is.function(workers)) 
[17:43:13.743]                       workers <- workers()
[17:43:13.743]                     workers <- structure(as.integer(workers), 
[17:43:13.743]                       class = class(workers))
[17:43:13.743]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:13.743]                       workers >= 1)
[17:43:13.743]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:13.743]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:13.743]                     }
[17:43:13.743]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:13.743]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:13.743]                       envir = envir)
[17:43:13.743]                     if (!future$lazy) 
[17:43:13.743]                       future <- run(future)
[17:43:13.743]                     invisible(future)
[17:43:13.743]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:13.743]                 }
[17:43:13.743]             }
[17:43:13.743]         }
[17:43:13.743]     })
[17:43:13.743]     if (TRUE) {
[17:43:13.743]         base::sink(type = "output", split = FALSE)
[17:43:13.743]         if (TRUE) {
[17:43:13.743]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:13.743]         }
[17:43:13.743]         else {
[17:43:13.743]             ...future.result["stdout"] <- base::list(NULL)
[17:43:13.743]         }
[17:43:13.743]         base::close(...future.stdout)
[17:43:13.743]         ...future.stdout <- NULL
[17:43:13.743]     }
[17:43:13.743]     ...future.result$conditions <- ...future.conditions
[17:43:13.743]     ...future.result$finished <- base::Sys.time()
[17:43:13.743]     ...future.result
[17:43:13.743] }
[17:43:13.747] Exporting 2 global objects (88.27 KiB) to cluster node #1 ...
[17:43:13.748] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ...
[17:43:13.791] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ... DONE
[17:43:13.791] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[17:43:13.792] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[17:43:13.792] Exporting 2 global objects (88.27 KiB) to cluster node #1 ... DONE
[17:43:13.793] MultisessionFuture started
[17:43:13.793] - Launch lazy future ... done
[17:43:13.793] run() for ‘MultisessionFuture’ ... done
[17:43:13.793] result() for ClusterFuture ...
[17:43:13.793] receiveMessageFromWorker() for ClusterFuture ...
[17:43:13.793] - Validating connection of MultisessionFuture
[17:43:13.877] - received message: FutureResult
[17:43:13.877] - Received FutureResult
[17:43:13.878] - Erased future from FutureRegistry
[17:43:13.878] result() for ClusterFuture ...
[17:43:13.878] - result already collected: FutureResult
[17:43:13.878] result() for ClusterFuture ... done
[17:43:13.878] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:13.878] result() for ClusterFuture ... done
[17:43:13.878] result() for ClusterFuture ...
[17:43:13.878] - result already collected: FutureResult
[17:43:13.878] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:43:13.884] getGlobalsAndPackages() ...
[17:43:13.884] Searching for globals...
[17:43:13.886] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:43:13.886] Searching for globals ... DONE
[17:43:13.886] Resolving globals: FALSE
[17:43:13.887] The total size of the 1 globals is 128 bytes (128 bytes)
[17:43:13.887] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:43:13.887] - globals: [1] ‘data’
[17:43:13.887] - packages: [1] ‘future’
[17:43:13.887] getGlobalsAndPackages() ... DONE
[17:43:13.888] run() for ‘Future’ ...
[17:43:13.888] - state: ‘created’
[17:43:13.888] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:13.902] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:13.902] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:13.902]   - Field: ‘node’
[17:43:13.903]   - Field: ‘label’
[17:43:13.903]   - Field: ‘local’
[17:43:13.903]   - Field: ‘owner’
[17:43:13.903]   - Field: ‘envir’
[17:43:13.903]   - Field: ‘workers’
[17:43:13.903]   - Field: ‘packages’
[17:43:13.903]   - Field: ‘gc’
[17:43:13.903]   - Field: ‘conditions’
[17:43:13.903]   - Field: ‘persistent’
[17:43:13.903]   - Field: ‘expr’
[17:43:13.904]   - Field: ‘uuid’
[17:43:13.904]   - Field: ‘seed’
[17:43:13.904]   - Field: ‘version’
[17:43:13.904]   - Field: ‘result’
[17:43:13.904]   - Field: ‘asynchronous’
[17:43:13.904]   - Field: ‘calls’
[17:43:13.904]   - Field: ‘globals’
[17:43:13.904]   - Field: ‘stdout’
[17:43:13.904]   - Field: ‘earlySignal’
[17:43:13.904]   - Field: ‘lazy’
[17:43:13.904]   - Field: ‘state’
[17:43:13.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:13.905] - Launch lazy future ...
[17:43:13.905] Packages needed by the future expression (n = 1): ‘future’
[17:43:13.905] Packages needed by future strategies (n = 1): ‘future’
[17:43:13.906] {
[17:43:13.906]     {
[17:43:13.906]         {
[17:43:13.906]             ...future.startTime <- base::Sys.time()
[17:43:13.906]             {
[17:43:13.906]                 {
[17:43:13.906]                   {
[17:43:13.906]                     {
[17:43:13.906]                       {
[17:43:13.906]                         base::local({
[17:43:13.906]                           has_future <- base::requireNamespace("future", 
[17:43:13.906]                             quietly = TRUE)
[17:43:13.906]                           if (has_future) {
[17:43:13.906]                             ns <- base::getNamespace("future")
[17:43:13.906]                             version <- ns[[".package"]][["version"]]
[17:43:13.906]                             if (is.null(version)) 
[17:43:13.906]                               version <- utils::packageVersion("future")
[17:43:13.906]                           }
[17:43:13.906]                           else {
[17:43:13.906]                             version <- NULL
[17:43:13.906]                           }
[17:43:13.906]                           if (!has_future || version < "1.8.0") {
[17:43:13.906]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:13.906]                               "", base::R.version$version.string), 
[17:43:13.906]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:13.906]                                 base::R.version$platform, 8 * 
[17:43:13.906]                                   base::.Machine$sizeof.pointer), 
[17:43:13.906]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:13.906]                                 "release", "version")], collapse = " "), 
[17:43:13.906]                               hostname = base::Sys.info()[["nodename"]])
[17:43:13.906]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:13.906]                               info)
[17:43:13.906]                             info <- base::paste(info, collapse = "; ")
[17:43:13.906]                             if (!has_future) {
[17:43:13.906]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:13.906]                                 info)
[17:43:13.906]                             }
[17:43:13.906]                             else {
[17:43:13.906]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:13.906]                                 info, version)
[17:43:13.906]                             }
[17:43:13.906]                             base::stop(msg)
[17:43:13.906]                           }
[17:43:13.906]                         })
[17:43:13.906]                       }
[17:43:13.906]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:13.906]                       base::options(mc.cores = 1L)
[17:43:13.906]                     }
[17:43:13.906]                     base::local({
[17:43:13.906]                       for (pkg in "future") {
[17:43:13.906]                         base::loadNamespace(pkg)
[17:43:13.906]                         base::library(pkg, character.only = TRUE)
[17:43:13.906]                       }
[17:43:13.906]                     })
[17:43:13.906]                   }
[17:43:13.906]                   options(future.plan = NULL)
[17:43:13.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:13.906]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:43:13.906]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:13.906]                     envir = parent.frame()) 
[17:43:13.906]                   {
[17:43:13.906]                     if (is.function(workers)) 
[17:43:13.906]                       workers <- workers()
[17:43:13.906]                     workers <- structure(as.integer(workers), 
[17:43:13.906]                       class = class(workers))
[17:43:13.906]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:13.906]                       workers >= 1)
[17:43:13.906]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:13.906]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:13.906]                     }
[17:43:13.906]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:13.906]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:13.906]                       envir = envir)
[17:43:13.906]                     if (!future$lazy) 
[17:43:13.906]                       future <- run(future)
[17:43:13.906]                     invisible(future)
[17:43:13.906]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:13.906]                 }
[17:43:13.906]                 ...future.workdir <- getwd()
[17:43:13.906]             }
[17:43:13.906]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:13.906]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:13.906]         }
[17:43:13.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:13.906]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:13.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:13.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:13.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:13.906]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:13.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:13.906]             base::names(...future.oldOptions))
[17:43:13.906]     }
[17:43:13.906]     if (FALSE) {
[17:43:13.906]     }
[17:43:13.906]     else {
[17:43:13.906]         if (TRUE) {
[17:43:13.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:13.906]                 open = "w")
[17:43:13.906]         }
[17:43:13.906]         else {
[17:43:13.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:13.906]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:13.906]         }
[17:43:13.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:13.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:13.906]             base::sink(type = "output", split = FALSE)
[17:43:13.906]             base::close(...future.stdout)
[17:43:13.906]         }, add = TRUE)
[17:43:13.906]     }
[17:43:13.906]     ...future.frame <- base::sys.nframe()
[17:43:13.906]     ...future.conditions <- base::list()
[17:43:13.906]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:13.906]     if (FALSE) {
[17:43:13.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:13.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:13.906]     }
[17:43:13.906]     ...future.result <- base::tryCatch({
[17:43:13.906]         base::withCallingHandlers({
[17:43:13.906]             ...future.value <- base::withVisible(base::local({
[17:43:13.906]                 ...future.makeSendCondition <- local({
[17:43:13.906]                   sendCondition <- NULL
[17:43:13.906]                   function(frame = 1L) {
[17:43:13.906]                     if (is.function(sendCondition)) 
[17:43:13.906]                       return(sendCondition)
[17:43:13.906]                     ns <- getNamespace("parallel")
[17:43:13.906]                     if (exists("sendData", mode = "function", 
[17:43:13.906]                       envir = ns)) {
[17:43:13.906]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:13.906]                         envir = ns)
[17:43:13.906]                       envir <- sys.frame(frame)
[17:43:13.906]                       master <- NULL
[17:43:13.906]                       while (!identical(envir, .GlobalEnv) && 
[17:43:13.906]                         !identical(envir, emptyenv())) {
[17:43:13.906]                         if (exists("master", mode = "list", envir = envir, 
[17:43:13.906]                           inherits = FALSE)) {
[17:43:13.906]                           master <- get("master", mode = "list", 
[17:43:13.906]                             envir = envir, inherits = FALSE)
[17:43:13.906]                           if (inherits(master, c("SOCKnode", 
[17:43:13.906]                             "SOCK0node"))) {
[17:43:13.906]                             sendCondition <<- function(cond) {
[17:43:13.906]                               data <- list(type = "VALUE", value = cond, 
[17:43:13.906]                                 success = TRUE)
[17:43:13.906]                               parallel_sendData(master, data)
[17:43:13.906]                             }
[17:43:13.906]                             return(sendCondition)
[17:43:13.906]                           }
[17:43:13.906]                         }
[17:43:13.906]                         frame <- frame + 1L
[17:43:13.906]                         envir <- sys.frame(frame)
[17:43:13.906]                       }
[17:43:13.906]                     }
[17:43:13.906]                     sendCondition <<- function(cond) NULL
[17:43:13.906]                   }
[17:43:13.906]                 })
[17:43:13.906]                 withCallingHandlers({
[17:43:13.906]                   {
[17:43:13.906]                     value(future(subset(data, a == 2)))
[17:43:13.906]                   }
[17:43:13.906]                 }, immediateCondition = function(cond) {
[17:43:13.906]                   sendCondition <- ...future.makeSendCondition()
[17:43:13.906]                   sendCondition(cond)
[17:43:13.906]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.906]                   {
[17:43:13.906]                     inherits <- base::inherits
[17:43:13.906]                     invokeRestart <- base::invokeRestart
[17:43:13.906]                     is.null <- base::is.null
[17:43:13.906]                     muffled <- FALSE
[17:43:13.906]                     if (inherits(cond, "message")) {
[17:43:13.906]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:13.906]                       if (muffled) 
[17:43:13.906]                         invokeRestart("muffleMessage")
[17:43:13.906]                     }
[17:43:13.906]                     else if (inherits(cond, "warning")) {
[17:43:13.906]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:13.906]                       if (muffled) 
[17:43:13.906]                         invokeRestart("muffleWarning")
[17:43:13.906]                     }
[17:43:13.906]                     else if (inherits(cond, "condition")) {
[17:43:13.906]                       if (!is.null(pattern)) {
[17:43:13.906]                         computeRestarts <- base::computeRestarts
[17:43:13.906]                         grepl <- base::grepl
[17:43:13.906]                         restarts <- computeRestarts(cond)
[17:43:13.906]                         for (restart in restarts) {
[17:43:13.906]                           name <- restart$name
[17:43:13.906]                           if (is.null(name)) 
[17:43:13.906]                             next
[17:43:13.906]                           if (!grepl(pattern, name)) 
[17:43:13.906]                             next
[17:43:13.906]                           invokeRestart(restart)
[17:43:13.906]                           muffled <- TRUE
[17:43:13.906]                           break
[17:43:13.906]                         }
[17:43:13.906]                       }
[17:43:13.906]                     }
[17:43:13.906]                     invisible(muffled)
[17:43:13.906]                   }
[17:43:13.906]                   muffleCondition(cond)
[17:43:13.906]                 })
[17:43:13.906]             }))
[17:43:13.906]             future::FutureResult(value = ...future.value$value, 
[17:43:13.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:13.906]                   ...future.rng), globalenv = if (FALSE) 
[17:43:13.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:13.906]                     ...future.globalenv.names))
[17:43:13.906]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:13.906]         }, condition = base::local({
[17:43:13.906]             c <- base::c
[17:43:13.906]             inherits <- base::inherits
[17:43:13.906]             invokeRestart <- base::invokeRestart
[17:43:13.906]             length <- base::length
[17:43:13.906]             list <- base::list
[17:43:13.906]             seq.int <- base::seq.int
[17:43:13.906]             signalCondition <- base::signalCondition
[17:43:13.906]             sys.calls <- base::sys.calls
[17:43:13.906]             `[[` <- base::`[[`
[17:43:13.906]             `+` <- base::`+`
[17:43:13.906]             `<<-` <- base::`<<-`
[17:43:13.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:13.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:13.906]                   3L)]
[17:43:13.906]             }
[17:43:13.906]             function(cond) {
[17:43:13.906]                 is_error <- inherits(cond, "error")
[17:43:13.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:13.906]                   NULL)
[17:43:13.906]                 if (is_error) {
[17:43:13.906]                   sessionInformation <- function() {
[17:43:13.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:13.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:13.906]                       search = base::search(), system = base::Sys.info())
[17:43:13.906]                   }
[17:43:13.906]                   ...future.conditions[[length(...future.conditions) + 
[17:43:13.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:13.906]                     cond$call), session = sessionInformation(), 
[17:43:13.906]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:13.906]                   signalCondition(cond)
[17:43:13.906]                 }
[17:43:13.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:13.906]                 "immediateCondition"))) {
[17:43:13.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:13.906]                   ...future.conditions[[length(...future.conditions) + 
[17:43:13.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:13.906]                   if (TRUE && !signal) {
[17:43:13.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.906]                     {
[17:43:13.906]                       inherits <- base::inherits
[17:43:13.906]                       invokeRestart <- base::invokeRestart
[17:43:13.906]                       is.null <- base::is.null
[17:43:13.906]                       muffled <- FALSE
[17:43:13.906]                       if (inherits(cond, "message")) {
[17:43:13.906]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:13.906]                         if (muffled) 
[17:43:13.906]                           invokeRestart("muffleMessage")
[17:43:13.906]                       }
[17:43:13.906]                       else if (inherits(cond, "warning")) {
[17:43:13.906]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:13.906]                         if (muffled) 
[17:43:13.906]                           invokeRestart("muffleWarning")
[17:43:13.906]                       }
[17:43:13.906]                       else if (inherits(cond, "condition")) {
[17:43:13.906]                         if (!is.null(pattern)) {
[17:43:13.906]                           computeRestarts <- base::computeRestarts
[17:43:13.906]                           grepl <- base::grepl
[17:43:13.906]                           restarts <- computeRestarts(cond)
[17:43:13.906]                           for (restart in restarts) {
[17:43:13.906]                             name <- restart$name
[17:43:13.906]                             if (is.null(name)) 
[17:43:13.906]                               next
[17:43:13.906]                             if (!grepl(pattern, name)) 
[17:43:13.906]                               next
[17:43:13.906]                             invokeRestart(restart)
[17:43:13.906]                             muffled <- TRUE
[17:43:13.906]                             break
[17:43:13.906]                           }
[17:43:13.906]                         }
[17:43:13.906]                       }
[17:43:13.906]                       invisible(muffled)
[17:43:13.906]                     }
[17:43:13.906]                     muffleCondition(cond, pattern = "^muffle")
[17:43:13.906]                   }
[17:43:13.906]                 }
[17:43:13.906]                 else {
[17:43:13.906]                   if (TRUE) {
[17:43:13.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:13.906]                     {
[17:43:13.906]                       inherits <- base::inherits
[17:43:13.906]                       invokeRestart <- base::invokeRestart
[17:43:13.906]                       is.null <- base::is.null
[17:43:13.906]                       muffled <- FALSE
[17:43:13.906]                       if (inherits(cond, "message")) {
[17:43:13.906]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:13.906]                         if (muffled) 
[17:43:13.906]                           invokeRestart("muffleMessage")
[17:43:13.906]                       }
[17:43:13.906]                       else if (inherits(cond, "warning")) {
[17:43:13.906]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:13.906]                         if (muffled) 
[17:43:13.906]                           invokeRestart("muffleWarning")
[17:43:13.906]                       }
[17:43:13.906]                       else if (inherits(cond, "condition")) {
[17:43:13.906]                         if (!is.null(pattern)) {
[17:43:13.906]                           computeRestarts <- base::computeRestarts
[17:43:13.906]                           grepl <- base::grepl
[17:43:13.906]                           restarts <- computeRestarts(cond)
[17:43:13.906]                           for (restart in restarts) {
[17:43:13.906]                             name <- restart$name
[17:43:13.906]                             if (is.null(name)) 
[17:43:13.906]                               next
[17:43:13.906]                             if (!grepl(pattern, name)) 
[17:43:13.906]                               next
[17:43:13.906]                             invokeRestart(restart)
[17:43:13.906]                             muffled <- TRUE
[17:43:13.906]                             break
[17:43:13.906]                           }
[17:43:13.906]                         }
[17:43:13.906]                       }
[17:43:13.906]                       invisible(muffled)
[17:43:13.906]                     }
[17:43:13.906]                     muffleCondition(cond, pattern = "^muffle")
[17:43:13.906]                   }
[17:43:13.906]                 }
[17:43:13.906]             }
[17:43:13.906]         }))
[17:43:13.906]     }, error = function(ex) {
[17:43:13.906]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:13.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:13.906]                 ...future.rng), started = ...future.startTime, 
[17:43:13.906]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:13.906]             version = "1.8"), class = "FutureResult")
[17:43:13.906]     }, finally = {
[17:43:13.906]         if (!identical(...future.workdir, getwd())) 
[17:43:13.906]             setwd(...future.workdir)
[17:43:13.906]         {
[17:43:13.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:13.906]                 ...future.oldOptions$nwarnings <- NULL
[17:43:13.906]             }
[17:43:13.906]             base::options(...future.oldOptions)
[17:43:13.906]             if (.Platform$OS.type == "windows") {
[17:43:13.906]                 old_names <- names(...future.oldEnvVars)
[17:43:13.906]                 envs <- base::Sys.getenv()
[17:43:13.906]                 names <- names(envs)
[17:43:13.906]                 common <- intersect(names, old_names)
[17:43:13.906]                 added <- setdiff(names, old_names)
[17:43:13.906]                 removed <- setdiff(old_names, names)
[17:43:13.906]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:13.906]                   envs[common]]
[17:43:13.906]                 NAMES <- toupper(changed)
[17:43:13.906]                 args <- list()
[17:43:13.906]                 for (kk in seq_along(NAMES)) {
[17:43:13.906]                   name <- changed[[kk]]
[17:43:13.906]                   NAME <- NAMES[[kk]]
[17:43:13.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.906]                     next
[17:43:13.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:13.906]                 }
[17:43:13.906]                 NAMES <- toupper(added)
[17:43:13.906]                 for (kk in seq_along(NAMES)) {
[17:43:13.906]                   name <- added[[kk]]
[17:43:13.906]                   NAME <- NAMES[[kk]]
[17:43:13.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.906]                     next
[17:43:13.906]                   args[[name]] <- ""
[17:43:13.906]                 }
[17:43:13.906]                 NAMES <- toupper(removed)
[17:43:13.906]                 for (kk in seq_along(NAMES)) {
[17:43:13.906]                   name <- removed[[kk]]
[17:43:13.906]                   NAME <- NAMES[[kk]]
[17:43:13.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:13.906]                     next
[17:43:13.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:13.906]                 }
[17:43:13.906]                 if (length(args) > 0) 
[17:43:13.906]                   base::do.call(base::Sys.setenv, args = args)
[17:43:13.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:13.906]             }
[17:43:13.906]             else {
[17:43:13.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:13.906]             }
[17:43:13.906]             {
[17:43:13.906]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:13.906]                   0L) {
[17:43:13.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:13.906]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:13.906]                   base::options(opts)
[17:43:13.906]                 }
[17:43:13.906]                 {
[17:43:13.906]                   {
[17:43:13.906]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:13.906]                     NULL
[17:43:13.906]                   }
[17:43:13.906]                   options(future.plan = NULL)
[17:43:13.906]                   if (is.na(NA_character_)) 
[17:43:13.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:13.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:13.906]                   future::plan(list(a = function (..., workers = availableCores(), 
[17:43:13.906]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:13.906]                     envir = parent.frame()) 
[17:43:13.906]                   {
[17:43:13.906]                     if (is.function(workers)) 
[17:43:13.906]                       workers <- workers()
[17:43:13.906]                     workers <- structure(as.integer(workers), 
[17:43:13.906]                       class = class(workers))
[17:43:13.906]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:13.906]                       workers >= 1)
[17:43:13.906]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:13.906]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:13.906]                     }
[17:43:13.906]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:13.906]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:13.906]                       envir = envir)
[17:43:13.906]                     if (!future$lazy) 
[17:43:13.906]                       future <- run(future)
[17:43:13.906]                     invisible(future)
[17:43:13.906]                   }, b = function (..., workers = availableCores(), 
[17:43:13.906]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:13.906]                     envir = parent.frame()) 
[17:43:13.906]                   {
[17:43:13.906]                     if (is.function(workers)) 
[17:43:13.906]                       workers <- workers()
[17:43:13.906]                     workers <- structure(as.integer(workers), 
[17:43:13.906]                       class = class(workers))
[17:43:13.906]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:13.906]                       workers >= 1)
[17:43:13.906]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:13.906]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:13.906]                     }
[17:43:13.906]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:13.906]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:13.906]                       envir = envir)
[17:43:13.906]                     if (!future$lazy) 
[17:43:13.906]                       future <- run(future)
[17:43:13.906]                     invisible(future)
[17:43:13.906]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:13.906]                 }
[17:43:13.906]             }
[17:43:13.906]         }
[17:43:13.906]     })
[17:43:13.906]     if (TRUE) {
[17:43:13.906]         base::sink(type = "output", split = FALSE)
[17:43:13.906]         if (TRUE) {
[17:43:13.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:13.906]         }
[17:43:13.906]         else {
[17:43:13.906]             ...future.result["stdout"] <- base::list(NULL)
[17:43:13.906]         }
[17:43:13.906]         base::close(...future.stdout)
[17:43:13.906]         ...future.stdout <- NULL
[17:43:13.906]     }
[17:43:13.906]     ...future.result$conditions <- ...future.conditions
[17:43:13.906]     ...future.result$finished <- base::Sys.time()
[17:43:13.906]     ...future.result
[17:43:13.906] }
[17:43:13.909] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:43:13.909] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:43:13.909] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:43:13.909] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:43:13.910] MultisessionFuture started
[17:43:13.910] - Launch lazy future ... done
[17:43:13.910] run() for ‘MultisessionFuture’ ... done
[17:43:13.910] result() for ClusterFuture ...
[17:43:13.911] receiveMessageFromWorker() for ClusterFuture ...
[17:43:13.911] - Validating connection of MultisessionFuture
[17:43:13.970] - received message: FutureResult
[17:43:13.970] - Received FutureResult
[17:43:13.970] - Erased future from FutureRegistry
[17:43:13.970] result() for ClusterFuture ...
[17:43:13.970] - result already collected: FutureResult
[17:43:13.970] result() for ClusterFuture ... done
[17:43:13.970] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:13.971] result() for ClusterFuture ... done
[17:43:13.971] result() for ClusterFuture ...
[17:43:13.971] - result already collected: FutureResult
[17:43:13.973] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[17:43:13.974] plan(): Setting new future strategy stack:
[17:43:13.974] List of future strategies:
[17:43:13.974] 1. FutureStrategy:
[17:43:13.974]    - args: function (..., envir = parent.frame())
[17:43:13.974]    - tweaked: FALSE
[17:43:13.974]    - call: future::plan(oplan)
[17:43:13.975] plan(): nbrOfWorkers() = 1
> 
